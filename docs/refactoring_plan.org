#+TITLE: TIL Compiler Refactoring Plan
#+AUTHOR: Architecture Documentation
#+DATE: 2025

* Overview

This document describes the plan to refactor the TIL compiler from a monolithic structure to a modular architecture that:
1. Prevents eval code from being called during type checking (fixes the insert_struct bug)
2. Prepares for compilation (not just interpretation)
3. Enables self-hosting (porting rstil.rs to TIL)
4. Creates clear phase boundaries

* Current Architecture (Monolithic)

Everything lives in =src/rstil.rs= (~5,400 lines):
- Context struct (lines 26-800+)
- Type checking (lines 1796-2880)
- Evaluation/interpreter (lines 2881-5100+)
- Main/CLI (lines 5187+)

*Problems:*
- No module boundaries → eval can be called from type checking
- Type checking and eval share Context with mixed compile-time and runtime state
- =insert_struct()= calls =eval_expr()= during type checking → arena errors
- Not compilation-friendly (too tightly coupled to interpretation)
- Hard to port to TIL for self-hosting

* Target Architecture (Modular)

#+begin_src
src/rs/lexer.rs        - Tokenization (DONE)
   ↓
src/rs/parser.rs       - AST building (DONE)
   ↓
src/rs/init.rs         - Declaration indexing + import declarations (TODO)
   ↓
src/rs/typer.rs        - Type checking (TODO)
   ↓
src/rs/interpreter.rs  - Runtime evaluation (TODO)
   ↓
src/rstil.rs           - CLI orchestration, main() (REMAINING)
#+end_src

** Module Responsibilities

*** lexer.rs ✅
- Tokenization
- Already separated

*** parser.rs ✅
- Parse tokens into AST
- Define AST types (Expr, NodeType, etc.)
- Already separated

*** init.rs (TODO)
- Declaration indexing ("context priming")
- Register symbols, functions, structs, enums in Context
- Process import declarations (copy declarations from imported files)
- Build Context for type checking phase
- *No eval, no arena access*

*** typer.rs (TODO)
- Type checking (check_types and all check_* functions)
- Type inference (get_value_type, get_fcall_value_type)
- Return/throws validation
- Mode checks
- *No eval, no arena access, no runtime operations*
- Can only call: parser, init functions

*** interpreter.rs (TODO)
- All eval_* functions
- Arena/memory management
- Runtime value initialization
- Process import values (eval constants/initializers from imported files)
- *Only phase that touches arena*

*** rstil.rs (REMAINING)
- main() entry point
- CLI argument parsing
- Pipeline orchestration
- Calls: lexer → parser → init → typer → interpreter
- Minimal logic, mostly glue code

* Phase Separation Benefits

** Compile-time phases (init + typer):
- Pure declaration and type analysis
- No memory allocation or runtime values
- Can run on any AST without execution
- Perfect for compilation

** Runtime phase (interpreter):
- Memory allocation
- Value initialization
- Actual program execution
- Only needed for interpretation

** Clean boundaries prevent bugs:
- typer.rs cannot call interpreter.rs (no circular dep)
- Type checking cannot accidentally trigger eval
- Fixes the insert_struct bug permanently

* Implementation Plan

** DONE Phase 1: Two-Phase Imports
*Status:* Complete

*Problem:* Currently imports call =run_file_with_context= which runs full eval. This creates circular dependency and isn't compilation-friendly.

*Solution:* Split imports into two phases:
1. *Declaration phase (init):* Parse imported file, copy declarations to parent context
2. *Value phase (eval):* Initialize constants/values in arena

*Changes:*
- [X] Create =init_import_declarations()= - declaration-only import
- [X] Update =init_context= to use new function
- [X] Update =eval_core_proc_import= to use separate values cache
- [X] Add separate import caches in Context (=imports_declarations_done=, =imports_values_done=)
- [X] Add =skip_init_and_typecheck= flag to =main_run= to skip Phase 1 during Phase 2

*Benefits:*
- Breaks circular dependency
- init_context no longer calls eval
- Ready for module extraction
- All tests pass

** Phase 2: Extract init.rs (TODO)
Move from rstil.rs to init.rs:
- =init_context()= function
- =init_import_declarations()= function
- Helper functions used only by init

** Phase 3: Extract typer.rs (TODO)
Move from rstil.rs to typer.rs:
- All =check_*= functions
- Type inference functions
- =register_struct_fields_for_typecheck=
- Audit: ensure no eval calls

*Critical fix:* Replace all =insert_struct= calls in type checking with =register_struct_fields_for_typecheck= to prevent eval during type checking.

** Phase 4: Extract interpreter.rs (TODO)
Move from rstil.rs to interpreter.rs:
- All =eval_*= functions
- Arena management
- =eval_import_values= function
- Context runtime methods

** Phase 5: Clean up rstil.rs (TODO)
- Keep only main(), CLI, orchestration
- Thin glue layer

* Future Enhancements

** Namespaced Imports
Support: =std := import("src/core/std")=
Then: =std.panic()= instead of just =panic()=

*Benefits:*
- Avoid name collisions
- Clear module boundaries
- More like modern languages

** Compilation Support
Once modules are separated:
- init + typer = compile-time phases
- Can generate LLVM IR, C code, or machine code
- interpreter.rs only needed for JIT/REPL

** Self-Hosting
Port each module to TIL:
1. til/lexer.til
2. til/parser.til
3. til/init.til
4. til/typer.til
5. til/interpreter.til (optional for AOT compiler)

* References

- Original bug: =insert_struct()= at line 475 calls =eval_expr= during type checking
- Partial fix: =register_struct_fields_for_typecheck()= at line 586
- Current import: =eval_core_proc_import= at line 3551
