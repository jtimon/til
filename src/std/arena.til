mode lib

// Arena: Low-level memory management
// Simple bump allocator with get/set/put/reserve operations.

Arena := struct {
    mut _memory : Vec = Vec()

    INITIAL_CAPACITY : I64 = 32768  // 32KB
}

namespace Arena {
    new := proc() returns Arena {
        mut a := Arena()
        a._memory = Vec.with_capacity(U8, Arena.INITIAL_CAPACITY)
        a._memory.push(0)  // REM: first address 0 is reserved (invalid), malloc always >0
        return a
    }

    /** Get current used length of arena memory */
    len := func(self: Arena) returns I64 {
        return self._memory.len()
    }

    /** Get size in bytes (same as len for Arena) */
    size := func(self: Arena) returns I64 {
        return self._memory.len()
    }

    /** Append bytes to arena, return offset where they were placed */
    put := proc(mut self: Arena, src_ptr: I64, num_bytes: I64) returns I64 {
        offset := self._memory.len()
        // Extend vec to make room (Vec grows naturally)
        self._memory.extend_with(0, num_bytes)
        // Copy the actual data
        memcpy(self._memory.ptr.offset(offset).data, src_ptr, num_bytes)
        return offset
    }

    /** Read bytes from arena at offset (returns pointer to data) */
    get := func(self: Arena, offset: I64, _num_bytes: I64) returns I64 {
        return self._memory.ptr.offset(offset).data
    }

    /** Write bytes to arena at offset */
    set := proc(mut self: Arena, offset: I64, src_ptr: I64, num_bytes: I64) {
        memcpy(self._memory.ptr.offset(offset).data, src_ptr, num_bytes)
    }

    /** Reserve space in arena, return offset where space was allocated */
    reserve := proc(mut self: Arena, size: I64) returns I64 {
        offset := self._memory.len()
        // Extend vec with zeros (Vec grows naturally)
        self._memory.extend_with(0, size)
        return offset
    }
}
