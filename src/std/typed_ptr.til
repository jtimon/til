mode lib

import("core.mem")

/** make_typed_ptr - Macro that generates a type-safe pointer struct.
 * Unlike Ptr which uses Dynamic for get/set, the generated struct has
 * T baked in at compile time -- real generics, no type erasure.
 *
 * Usage:
 *   I64Ptr := make_typed_ptr(I64)
 *   mut p := I64Ptr.new()
 *   p.set(42)
 *   mut result := 0
 *   p.get(result)
 *   p.delete()
 */
make_typed_ptr := macro(T: Type) returns struct {
    TemplatedPtr := struct {
        mut data: I64 = 0
        mut is_borrowed: I64 = 0
        mut alloc_size: I64 = 0

    namespace:
        new := proc() returns TemplatedPtr {
            mut p := TemplatedPtr()
            p.data = malloc(size_of(T))?
            p.alloc_size = size_of(T)
            return p

            catch (err: BadAlloc) { panic(loc(), "typed_ptr: malloc failed") }
        }

        new_array := proc(count: I64) returns TemplatedPtr {
            total := size_of(T).mul(count)
            mut p := TemplatedPtr()
            p.data = malloc(total)?
            p.alloc_size = total
            return p

            catch (err: BadAlloc) { panic(loc(), "typed_ptr: malloc failed") }
        }

        delete := func(mut self: TemplatedPtr) {
            if NULL.eq(self.data) { return }
            if self.is_borrowed.eq(0) {
                free(self.data)
            }
            self.data = NULL
        }

        is_null := func(self: TemplatedPtr) returns Bool {
            return NULL.eq(self.data)
        }

        set := proc(mut self: TemplatedPtr, value: T) {
            memcpy(self.data, to_ptr(value), size_of(T))
        }

        get := proc(self: TemplatedPtr, mut dest: T) {
            memcpy(to_ptr(dest), self.data, size_of(T))
        }
    }
    return TemplatedPtr
}
