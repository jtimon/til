mode lib

import("core.ptr")
import("core.vec")

/**
 * List - Dynamic heterogeneous collection (also known as Tuple).
 * Stores elements of different types in contiguous memory.
 * Type information tracked via parallel metadata vectors.
 */
List := struct {
    mut data : Ptr  = Ptr()  // Pointer to raw memory blob
    mut _len : I64 = 0      // Number of elements stored
    mut type_names : Vec = Vec()  // Vec<Str> - type name per element
    mut type_sizes : Vec = Vec()  // Vec<I64> - size per element

    /** Get number of elements in list. */
    len := func(self: List) returns I64 {
        return self._len
    }

    /** Get total size in bytes. */
    size := func(self: List) returns I64 throws OutOfBounds {
        return self.calc_used()?
    }

    /** Create new empty list. */
    new := proc() returns List {
        mut list := List()
        // Allocate enough for reasonable number of elements
        list.data = Ptr.new_by_size(1024)
        list._len = 0
        list.type_names = Vec.new(Str)
        list.type_sizes = Vec.new(I64)

        return list
    }

    /** Calculate byte offset for element at index. */
    calc_offset := proc(self: List, index: I64) returns I64 throws OutOfBounds {
        mut offset := 0
        mut i := 0
        while lt(i, index) {
            mut size := 0
            self.type_sizes.get(i, size)?
            offset = add(offset, size)
            i = add(i, 1)
        }
        return offset
    }

    /** Calculate total bytes used. */
    calc_used := proc(self: List) returns I64 throws OutOfBounds {
        return self.calc_offset(self._len)?
    }

    /** Append element to list.
     *  Takes the type as first parameter (like Vec.new) and value as second.
     *  Example: list.push(I64, 42), list.push(Str, "hello") */
    push := proc(mut self: List, T: Type, value: Dynamic) throws OutOfBounds {
        mut type_name := type_as_str(T)
        mut type_size := size_of(T)

        // Copy value to data blob at current end
        mut offset := self.calc_used()?
        mut dest := self.data.offset(offset)
        dest.copy_from_dynamic(value, type_size)

        // Record metadata
        self.type_names.push(type_name)
        self.type_sizes.push(type_size)
        self._len = add(self._len, 1)
    }

    /** Get element at index. */
    get := proc(self: List, index: I64, mut dest: Dynamic) throws OutOfBounds {
        if gteq(index, self._len) {
            throw OutOfBounds(msg=format("List.get: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw OutOfBounds(msg=format("List.get: negative index ", index.to_str()))
        }

        // Get type info for validation
        mut stored_type := ""
        self.type_names.get(index, stored_type)?

        mut _dest_type := type_as_str(dest)

        // TODO FIX type checking when Dynamic type checking is enabled
        // if not(Str.eq(stored_type, dest_type)) {
        //     throw TypeMismatchError(...)
        // }

        // Calculate offset and size
        mut offset := self.calc_offset(index)?
        mut size := 0
        self.type_sizes.get(index, size)?

        // Copy data to destination
        src := self.data.offset(offset)
        src.copy_to_dynamic(dest, size)
    }

    /** Set element at index.
     *  Takes the type as second parameter and value as third.
     *  Example: list.set(0, I64, 99), list.set(1, Str, "world") */
    set := proc(mut self: List, index: I64, T: Type, value: Dynamic) throws OutOfBounds {
        if gteq(index, self._len) {
            throw OutOfBounds(msg=format("List.set: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw OutOfBounds(msg=format("List.set: negative index ", index.to_str()))
        }

        mut new_type := type_as_str(T)
        mut new_size := size_of(T)

        mut old_type := ""
        self.type_names.get(index, old_type)?

        mut old_size := 0
        self.type_sizes.get(index, old_size)?

        // Case 1: Same size - simple overwrite
        if I64.eq(new_size, old_size) {
            mut offset := self.calc_offset(index)?
            mut dest := self.data.offset(offset)
            dest.copy_from_dynamic(value, new_size)

            // Update type name if different
            if not(Str.eq(new_type, old_type)) {
                self.type_names.set(index, new_type)?
            }
            return
        }

        // Case 2: Different size - need to shift elements
        mut old_offset := self.calc_offset(index)?
        mut after_offset := old_offset.add(old_size)
        mut used := self.calc_used()?
        mut bytes_after := used.sub(after_offset)

        // Shift elements after index
        if bytes_after.gt(0) {
            mut new_after_offset := old_offset.add(new_size)
            mut dest_shift := self.data.offset(new_after_offset)
            src_shift := self.data.offset(after_offset)
            dest_shift.copy_from(src_shift, bytes_after)
        }

        // Write new value
        mut write_dest := self.data.offset(old_offset)
        write_dest.copy_from_dynamic(value, new_size)

        // Update metadata
        self.type_names.set(index, new_type)?
        self.type_sizes.set(index, new_size)?
    }

    /** Pop last element from list. */
    pop := proc(mut self: List, mut dest: Dynamic) throws OutOfBounds {
        if self._len.eq(0) {
            throw OutOfBounds(msg=format(loc(), "List.pop: cannot pop from empty List"))
        }

        // Get last element FIRST before modifying anything
        mut last_index := sub(self._len, 1)
        mut offset := self.calc_offset(last_index)?
        mut size := 0
        self.type_sizes.get(last_index, size)?

        // Copy data to destination directly
        src := self.data.offset(offset)
        src.copy_to_dynamic(dest, size)

        // Now safe to remove from metadata
        mut dummy_name := ""
        self.type_names.pop(dummy_name)?
        mut dummy_size := 0
        self.type_sizes.pop(dummy_size)?

        // Decrement length
        self._len = last_index
    }

    /** Free list memory. */
    delete := proc(mut self: List) {
        if not(self.data.is_null()) {
            self.data.delete()
        }
        self.data = Ptr()
        self._len = 0

        mut names := self.type_names
        names.delete()

        mut sizes := self.type_sizes
        sizes.delete()
    }

    /** Clone the list. */
    clone := func(self: List) returns List throws OutOfBounds {
        mut cloned := List()
        cloned._len = self._len
        cloned.type_names = self.type_names.clone()
        cloned.type_sizes = self.type_sizes.clone()

        // Calculate total bytes used and allocate data buffer
        mut total_bytes := self.calc_used()?
        cloned.data = Ptr.new_by_size(total_bytes)
        cloned.data.copy_from(self.data, total_bytes)
        return cloned
    }
}
