mode lib

import("core.ptr")
import("core.vec")

/**
 * List - Dynamic heterogeneous collection (also known as Tuple).
 * Stores elements of different types in contiguous memory.
 * Type information tracked via parallel metadata vectors.
 */
List := struct {
    mut data : Ptr  = Ptr()  // Pointer to raw memory blob
    mut _len : I64 = 0      // Number of elements stored
    mut cap  : I64 = 0      // Allocated capacity in bytes for data buffer
    mut type_names : Vec = Vec()  // Vec<Str> - type name per element
    mut type_sizes : Vec = Vec()  // Vec<I64> - size per element

namespace:
    /** Get number of elements in list. */
    len : func(self: List) returns I64 = {
        return self._len
    }

    /** Get total size in bytes. */
    size : func(self: List) returns I64 throws IndexOutOfBoundsError = {
        return self.calc_used()?
    }

    /** Create new empty list. */
    new : proc() returns List = {
        mut list := List()
        list.cap = 1024
        list.data = Ptr.new_by_size(list.cap)
        list._len = 0
        list.type_names = Vec.new(Str)
        list.type_sizes = Vec.new(I64)

        return list
    }

    /** Calculate byte offset for element at index. */
    calc_offset : proc(self: List, index: I64) returns I64 throws IndexOutOfBoundsError = {
        mut offset := 0
        mut i := 0
        while lt(i, index) {
            size := cast(I64, self.type_sizes.get(i)?)
            offset = add(offset, size)
            i = add(i, 1)
        }
        return offset
    }

    /** Calculate total bytes used. */
    calc_used : proc(self: List) returns I64 throws IndexOutOfBoundsError = {
        return self.calc_offset(self._len)?
    }

    /** Append element to list.
     *  Takes the type as first parameter (like Vec.new) and value as second.
     *  Example: list.push(I64, 42), list.push(Str, "hello") */
    push : proc(mut self: List, T: Type, own value: Dynamic) throws IndexOutOfBoundsError = {
        dont_delete(value)
        mut type_name := type_as_str(T)
        mut type_size := size_of(T)

        // Copy value to data blob at current end
        mut offset := self.calc_used()?
        mut needed := offset.add(type_size)

        // Grow if needed
        if needed.gt(self.cap) {
            mut new_cap := self.cap.mul(2)
            if new_cap.lt(needed) {
                new_cap = needed
            }
            mut new_data := Ptr.new_by_size(new_cap)
            if offset.gt(0) {
                new_data.copy_from(self.data, offset)
            }
            if not(self.data.is_null()) {
                self.data.delete()
            }
            self.data = new_data
            self.cap = new_cap
        }

        mut dest := self.data.offset(offset)
        dest.copy_from_dynamic(value, type_size)

        // Record metadata
        self.type_names.push(own type_name)
        self.type_sizes.push(own type_size)
        self._len = add(self._len, 1)
    }

    /** Get reference to element at index. */
    get : proc(self: List, index: I64) returns Ptr throws IndexOutOfBoundsError = {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(msg=format("List.get: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }
        if lt(index, 0) {
            throw IndexOutOfBoundsError(msg=format("List.get: negative index ", index.to_str()))
        }
        offset := self.calc_offset(index)?
        return self.data.offset(offset)
    }

    /** Set element at index.
     *  Takes the type as second parameter and value as third.
     *  Example: list.set(0, I64, 99), list.set(1, Str, "world") */
    set : proc(mut self: List, index: I64, T: Type, own value: Dynamic) throws IndexOutOfBoundsError = {
        dont_delete(value)
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(msg=format("List.set: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw IndexOutOfBoundsError(msg=format("List.set: negative index ", index.to_str()))
        }

        mut new_type := type_as_str(T)
        mut new_size := size_of(T)

        old_type := cast(Str, self.type_names.get(index)?)

        old_size := cast(I64, self.type_sizes.get(index)?)

        // Case 1: Same size - simple overwrite
        if I64.eq(new_size, old_size) {
            mut offset := self.calc_offset(index)?
            mut dest := self.data.offset(offset)
            dest.copy_from_dynamic(value, new_size)

            // Update type name if different
            if not(Str.eq(new_type, old_type)) {
                self.type_names.set(index, own new_type)?
            }
            return
        }

        // Case 2: Different size - need to shift elements
        mut old_offset := self.calc_offset(index)?
        mut after_offset := old_offset.add(old_size)
        mut used := self.calc_used()?
        mut bytes_after := used.sub(after_offset)
        mut new_total := used.sub(old_size).add(new_size)

        // Grow if needed
        if new_total.gt(self.cap) {
            mut new_cap := self.cap.mul(2)
            if new_cap.lt(new_total) {
                new_cap = new_total
            }
            mut new_data := Ptr.new_by_size(new_cap)
            if used.gt(0) {
                new_data.copy_from(self.data, used)
            }
            if not(self.data.is_null()) {
                self.data.delete()
            }
            self.data = new_data
            self.cap = new_cap
        }

        // Shift elements after index
        if bytes_after.gt(0) {
            mut new_after_offset := old_offset.add(new_size)
            mut dest_shift := self.data.offset(new_after_offset)
            src_shift := self.data.offset(after_offset)
            dest_shift.copy_from(src_shift, bytes_after)
        }

        // Write new value
        mut write_dest := self.data.offset(old_offset)
        write_dest.copy_from_dynamic(value, new_size)

        // Update metadata
        self.type_names.set(index, own new_type)?
        self.type_sizes.set(index, own new_size)?
    }

    /** Pop last element from list. */
    pop : proc(mut self: List, mut dest: Dynamic) throws IndexOutOfBoundsError = {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError(msg=format(loc(), "List.pop: cannot pop from empty List"))
        }

        // Get last element FIRST before modifying anything
        mut last_index := sub(self._len, 1)
        mut offset := self.calc_offset(last_index)?
        size := cast(I64, self.type_sizes.get(last_index)?)

        // Copy data to destination directly
        src := self.data.offset(offset)
        src.copy_to_dynamic(dest, size)

        // Now safe to remove from metadata
        mut dummy_name := ""
        self.type_names.pop(dummy_name)?
        mut dummy_size := 0
        self.type_sizes.pop(dummy_size)?

        // Decrement length
        self._len = last_index
    }

    /** Free list memory. */
    delete : func(mut self: List) = {
        if not(self.data.is_null()) {
            self.data.delete()
        }
        self.data = Ptr()
        self._len = 0

        mut names := self.type_names
        names.delete()

        mut sizes := self.type_sizes
        sizes.delete()
    }

    /** Clone the list. */
    clone : func(self: List) returns List throws IndexOutOfBoundsError = {
        mut cloned := List()
        cloned._len = self._len
        cloned.type_names = self.type_names.clone()
        cloned.type_sizes = self.type_sizes.clone()

        // Allocate same capacity as original (not just used bytes)
        mut total_bytes := self.calc_used()?
        cloned.cap = self.cap
        if cloned.cap.lt(total_bytes) {
            cloned.cap = total_bytes
        }
        cloned.data = Ptr.new_by_size(cloned.cap)
        cloned.data.copy_from(self.data, total_bytes)
        return cloned
    }
}
