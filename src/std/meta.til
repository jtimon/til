mode lib

import("core.vec")

// Metaprogramming and introspection utilities

enum_to_str : ext_func(e: Dynamic) returns Str = {}
enum_get_payload : ext_func(e: Dynamic, payload_type: Type, mut out: Dynamic) = {}
enum_get_payload_type : ext_func(e: Dynamic, variant_name: Type, payload_type: Type) returns Str = {}

eval_to_str     : ext_proc(a: Str) returns Str = {}
eval_to_ast_str : ext_proc(src: Str) returns Str = {}  // TODO
eval_to_expr    : ext_proc(src: Str) returns Expr = {} // TODO
eval_file       : ext_proc(args: ..Str) = {}

// Struct introspection primitives (Issue #105)
// These are low-level ext functions used by struct_def_of in core/ast.til
__struct_field_count     : ext_func(type_name: Str) returns I64 = {}
__struct_field_name      : ext_func(type_name: Str, index: I64) returns Str = {}
__struct_field_is_mut    : ext_func(type_name: Str, index: I64) returns I64 = {}
__struct_field_type_kind : ext_func(type_name: Str, index: I64) returns Str = {}
__struct_field_type_arg  : ext_func(type_name: Str, index: I64) returns Str = {}

// Build a StructDef for the named type by querying scope_stack via ext functions
struct_def_of : proc(type_name: Str) returns StructDef = {
    mut def := StructDef()
    n := __struct_field_count(type_name)
    for i in 0..n {
        mut decl := Declaration()
        decl.name = __struct_field_name(type_name, i)
        decl.is_mut = __struct_field_is_mut(type_name, i).eq(1)

        type_kind := __struct_field_type_kind(type_name, i)
        type_arg := __struct_field_type_arg(type_name, i)

        if type_kind.eq("TCustom") {
            decl.value_type = ValueType.TCustom(type_arg)
        } else if type_kind.eq("TMulti") {
            decl.value_type = ValueType.TMulti(type_arg)
        }
        // TType and TFunction: skip for now

        def.members.push(decl)
    }
    return def
}

// Enum introspection primitives (Issue #106)
__enum_variant_count        : ext_func(type_name: Str) returns I64 = {}
__enum_variant_name         : ext_func(type_name: Str, index: I64) returns Str = {}
__enum_variant_has_payload  : ext_func(type_name: Str, index: I64) returns I64 = {}
__enum_variant_payload_type : ext_func(type_name: Str, index: I64) returns Str = {}

// Build an EnumDef for the named type by querying scope_stack via ext functions
enum_def_of : proc(type_name: Str) returns EnumDef = {
    mut def := EnumDef()
    n := __enum_variant_count(type_name)
    for i in 0..n {
        mut variant := EnumVariant()
        variant.name = __enum_variant_name(type_name, i)
        has_payload := __enum_variant_has_payload(type_name, i)
        if has_payload.eq(1) {
            payload_str := __enum_variant_payload_type(type_name, i)
            variant.payload_type.data = malloc(size_of(ValueType))?
            mut vt := ValueType.TCustom(payload_str)
            memcpy(variant.payload_type.data, to_ptr(vt), size_of(ValueType))
        }
        def.variants.push(variant)
    }
    catch (err: BadAlloc) { panic(loc(), "enum_def_of: malloc failed") }
    return def
}

// Introspection - Runtime type information utilities
//
// This struct acts as a namespace (has no mutable fields).
// It provides functions to query type information at runtime.

Introspection := struct {
    // No mutable fields - this is purely a namespace

namespace:
    // Check if a type has a specific const (immutable field)
    // This includes associated functions like clone, len, size, etc.
    // Returns true if the const exists, false otherwise
    has_const : ext_func(type_name: Str, const_name: Str) returns Bool = {}

    // Check if a type has a specific mutable field
    // Returns true if the field exists, false otherwise
    has_field : ext_func(type_name: Str, field_name: Str) returns Bool = {}

    // TODO: Future functions to implement:
    // get_consts := ext_func(type_name: Str) returns Vec;
    // get_fields := ext_func(type_name: Str) returns Vec;
    // get_field_type := ext_func(type_name: Str, field_name: Str) returns Str;
    // is_struct := ext_func(type_name: Str) returns Bool;
    // is_enum := ext_func(type_name: Str) returns Bool;
    // type_exists := ext_func(type_name: Str) returns Bool;
}
