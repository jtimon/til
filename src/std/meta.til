mode lib

import("core.vec")

// Metaprogramming and introspection utilities

enum_to_str := ext_func(e: Dynamic) returns Str {}
enum_get_payload := ext_func(e: Dynamic, payload_type: Type, mut out: Dynamic) {}
enum_get_payload_type := ext_func(e: Dynamic, variant_name: Type, payload_type: Type) returns Str {}

eval_to_str     := ext_proc(a: Str) returns Str {}
eval_to_ast_str := ext_proc(src: Str) returns Str {}  // TODO
eval_to_expr    := ext_proc(src: Str) returns Expr {} // TODO
eval_file       := ext_proc(args: ..Str) {}

// Introspection - Runtime type information utilities
//
// This struct acts as a namespace (has no mutable fields).
// It provides functions to query type information at runtime.

Introspection := struct {
    // No mutable fields - this is purely a namespace

    // Check if a type has a specific const (immutable field)
    // This includes associated functions like clone, len, size, etc.
    // Returns true if the const exists, false otherwise
    has_const := ext_func(type_name: Str, const_name: Str) returns Bool {}

    // Check if a type has a specific mutable field
    // Returns true if the field exists, false otherwise
    has_field := ext_func(type_name: Str, field_name: Str) returns Bool {}

    // TODO: Future functions to implement:
    // get_consts := ext_func(type_name: Str) returns Vec;
    // get_fields := ext_func(type_name: Str) returns Vec;
    // get_field_type := ext_func(type_name: Str, field_name: Str) returns Str;
    // is_struct := ext_func(type_name: Str) returns Bool;
    // is_enum := ext_func(type_name: Str) returns Bool;
    // type_exists := ext_func(type_name: Str) returns Bool;
}
