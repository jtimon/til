mode lib

import("core.vec")

DuplicatedKeyError := struct {
    mut msg: Str = ""
}

KeyNotFoundError := struct {
    mut msg: Str = ""
}

// Result of binary search: found flag and index
BinarySearchResult := struct {
    mut found: Bool = false
    mut index: I64 = 0
}

/**
 * Generic Map implementation - sorted by key, O(log n) lookup via binary search.
 * Uses parallel arrays for keys and values (keys kept sorted).
 * Type parameters passed as strings (key_type_name, value_type_name).
 * No generics syntax needed - uses dynamic typing like Array.
 *
 * Key type support:
 *   - Str: Fully supported (uses Str.cmp() for ordering)
 *   - I64, U8, Bool: Fully supported (uses memcmp for byte comparison)
 *   - Other primitives: Should work with memcmp
 *   - Structs: NOT recommended as keys (memcmp compares raw bytes including padding)
 *
 * Value type support:
 *   - Fully dynamic: Any type works (I64, Str, Bool, U8, Vec2, Array, etc.)
 *   - Uses memcpy for storage and retrieval
 *
 * Note: This implementation maintains sorted order, not insertion order.
 * For iteration in insertion order, use a different data structure.
 */
Map := struct {
    mut keys: Vec = Vec()         // Dynamic array of keys (sorted)
    mut values: Vec = Vec()       // Dynamic array of values (parallel)
    mut _size: I64 = 0                // Number of entries (internal, use len() to access)

namespace:
    /** Create new empty map with specified key and value types.
     *  Example: Map.new(Str, I64) */
    new := proc(KeyType: Type, ValueType: Type) returns Map {
        mut m := Map()
        m.keys = Vec.new_from_type_info(type_as_str(KeyType), size_of(KeyType))
        m.values = Vec.new_from_type_info(type_as_str(ValueType), size_of(ValueType))
        m._size = 0
        return m
    }

    /** Compare two keys. Returns -1 if a < b, 0 if a == b, 1 if a > b.
     *  For Str keys, uses lexicographic comparison via Str.cmp().
     *  For other types, uses memcmp on raw bytes. */
    compare_keys := func(self: Map, key_a_ptr: I64, key_b_ptr: I64) returns I64 {
        if self.keys._is_str_type() {
            // For Str keys, use Str.cmp() for proper lexicographic ordering
            mut a := ""
            mut b := ""
            memcpy(to_ptr(a), key_a_ptr, self.keys.ptr.elem_size)
            memcpy(to_ptr(b), key_b_ptr, self.keys.ptr.elem_size)
            return a.cmp(b)
        } else {
            // For other types, use memcmp
            result := memcmp(key_a_ptr, key_b_ptr, self.keys.ptr.elem_size)
            if result.lt(0) {
                return sub(0, 1)
            } else if result.gt(0) {
                return 1
            } else {
                return 0
            }
        }
    }

    /** Binary search for key. Returns BinarySearchResult with found flag and index.
     *  If found: index is where the key is.
     *  If not found: index is where the key should be inserted. */
    binary_search := func(self: Map, key: Dynamic) returns BinarySearchResult {
        mut result := BinarySearchResult()

        if self._size.eq(0) {
            result.found = false
            result.index = 0
            return result
        }

        mut low := 0
        mut high := self._size.sub(1)

        while low.lteq(high) {
            mut mid := low.add(high.sub(low).div(2))
            mid_key_ptr := self.keys.ptr.offset(mid.mul(self.keys.ptr.elem_size))
            cmp := self.compare_keys(to_ptr(key), mid_key_ptr.data)

            if cmp.eq(0) {
                // Found exact match
                result.found = true
                result.index = mid
                return result
            } else if cmp.lt(0) {
                // key < mid_key, search left half
                if mid.eq(0) {
                    result.found = false
                    result.index = 0
                    return result
                }
                high = mid.sub(1)
            } else {
                // key > mid_key, search right half
                low = mid.add(1)
            }
        }

        // Not found, return insertion point
        result.found = false
        result.index = low
        return result
    }

    /** Insert new key-value pair.
     *  Throws DuplicatedKeyError if key already exists.
     *  Use set() instead if you want to overwrite existing keys. */
    insert := proc(mut self: Map, own key: Dynamic, own value: Dynamic) throws DuplicatedKeyError {
        dont_delete(key)
        dont_delete(value)
        search := self.binary_search(key)

        if search.found {
            throw DuplicatedKeyError(msg=format(loc(), "Key already exists in map"))
        }

        // Insert at sorted position
        self.keys.insert_at(search.index, own key)?
        self.values.insert_at(search.index, own value)?
        self._size = self._size.add(1)

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.insert: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Set key-value pair.
     *  Overwrites value if key already exists.
     *  Creates new entry if key doesn't exist. */
    set := proc(mut self: Map, own key: Dynamic, own value: Dynamic) {
        dont_delete(key)
        dont_delete(value)
        search := self.binary_search(key)

        if search.found {
            // Key found - update value in place
            mut value_ptr := self.values.ptr.offset(search.index.mul(self.values.ptr.elem_size))
            value_ptr.copy_from_dynamic(value, self.values.ptr.elem_size)
        } else {
            // Key not found - insert at sorted position
            self.keys.insert_at(search.index, own key)?
            self.values.insert_at(search.index, own value)?
            self._size = self._size.add(1)
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.set: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Get borrowed Ptr to value for given key. No copy - points into map memory. */
    get := proc(self: Map, key: Dynamic) returns Ptr throws KeyNotFoundError {
        search := self.binary_search(key)
        if search.found {
            return self.values.ptr.offset(search.index.mul(self.values.ptr.elem_size))
        }
        throw KeyNotFoundError(msg=format(loc(), "Key not found in map"))
    }

    /** Check if key exists in map. */
    contains_key := proc(self: Map, key: Dynamic) returns Bool {
        search := self.binary_search(key)
        return search.found
    }

    /** Remove key from map. Does nothing if key doesn't exist. */
    remove := proc(mut self: Map, key: Dynamic) {
        search := self.binary_search(key)

        if search.found {
            // Remove by shifting elements
            self.keys.remove(search.index)?
            self.values.remove(search.index)?
            self._size = self._size.sub(1)
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.remove: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Get position (index) of key in sorted order.
     *  Returns -1 if key not found.
     *  Note: This returns the sorted position, not insertion order. */
    position := proc(self: Map, key: Dynamic) returns I64 {
        search := self.binary_search(key)
        if search.found {
            return search.index
        }
        return sub(0, 1)  // -1 for not found
    }

    /** Get number of entries in map. */
    len := proc(self: Map) returns I64 {
        return self._size
    }

    /** Check if map is empty. */
    is_empty := func(self: Map) returns Bool {
        return self._size.eq(0)
    }

    /** Clear all entries from map (reset to empty). */
    clear := proc(mut self: Map) {
        self._size = 0
        self.keys._len = 0
        self.values._len = 0
    }

    /** Get total size in bytes (keys + values). */
    size := func(self: Map) returns I64 {
        mut keys_size := mul(self._size, self.keys.ptr.elem_size)
        mut values_size := mul(self._size, self.values.ptr.elem_size)
        return add(keys_size, values_size)
    }

    /** Free map memory and reset. */
    delete := func(mut self: Map) {
        mut keys_arr := self.keys
        keys_arr.delete()

        mut values_arr := self.values
        values_arr.delete()

        self._size = 0
    }

    // Bug #36 fix: Now we can inline throwing functions in struct literal params
    clone := func(self: Map) returns Map {
        return Map(
            keys=self.keys.clone(),
            values=self.values.clone(),
            _size=self._size
        )
    }
}
