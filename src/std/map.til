mode lib

import("core.vec")

DuplicatedKeyError := struct {
    mut msg: Str = ""
}

KeyNotFoundError := struct {
    mut msg: Str = ""
}

// Result of hash lookup: found flag and index
HashLookupResult := struct {
    mut found: Bool = false
    mut index: I64 = 0
}

// Map constants (module-level to avoid struct initialization issues)
MAP_INITIAL_BUCKETS : I64 = 16
MAP_LOAD_FACTOR_THRESHOLD : I64 = 75  // percent (75 = 0.75)

/**
 * Generic Map implementation - O(1) average lookup via hash table with separate chaining.
 * Uses parallel arrays for keys and values, with bucket chains for hash collision handling.
 * Type parameters passed as strings (key_type_name, value_type_name).
 * No generics syntax needed - uses dynamic typing like Array.
 *
 * Key type support:
 *   - Str: Fully supported (uses Str.hash() for hashing, Str.eq() for comparison)
 *   - I64, U8, Bool: Supported (uses byte-based hash and memcmp for comparison)
 *   - Other primitives: Should work with memcmp
 *   - Structs: NOT recommended as keys (memcmp compares raw bytes including padding)
 *
 * Value type support:
 *   - Fully dynamic: Any type works (I64, Str, Bool, U8, Vec2, Array, etc.)
 *   - Uses memcpy for storage and retrieval
 */
Map := struct {
    mut key_type_name: Str = ""       // e.g., "Str", "I64"
    mut key_type_size: I64 = 0        // from size_of(KeyType)
    mut value_type_name: Str = ""     // e.g., "Str", "Bool", "Expr"
    mut value_type_size: I64 = 0      // from size_of(ValueType)
    mut keys: Vec = Vec()             // Dynamic array of keys
    mut values: Vec = Vec()           // Dynamic array of values (parallel to keys)
    mut buckets: Vec = Vec()          // Hash buckets: each entry is head index of chain (-1 = empty)
    mut nexts: Vec = Vec()            // Chain links: nexts[i] is next index after i (-1 = end)
    mut _size: I64 = 0                // Number of entries (internal, use len() to access)
    mut num_buckets: I64 = 0          // Current number of buckets

    /** Create new empty map with specified key and value types.
     *  Example: Map.new(Str, I64) */
    new := proc(KeyType: Type, ValueType: Type) returns Map {
        mut m := Map()
        m.key_type_name = type_as_str(KeyType)
        m.key_type_size = size_of(KeyType)
        m.value_type_name = type_as_str(ValueType)
        m.value_type_size = size_of(ValueType)
        m.keys = Vec.new_from_type_info(m.key_type_name, m.key_type_size)
        m.values = Vec.new_from_type_info(m.value_type_name, m.value_type_size)
        m.buckets = Vec.new(I64)
        m.nexts = Vec.new(I64)
        m._size = 0
        m.num_buckets = MAP_INITIAL_BUCKETS
        // Initialize all buckets to -1 (empty)
        for _ in 0..m.num_buckets {
            m.buckets.push(sub(0, 1))
        }

        catch (err: AllocError) {
            panic(loc(), "Map.new: unexpected AllocError: ", err.msg)
        }

        return m
    }

    /** Check if two keys are equal.
     *  For Str keys, uses Str.eq().
     *  For other types, uses memcmp. */
    keys_equal := func(self: Map, key_a_ptr: I64, key_b_ptr: I64) returns Bool {
        if Str.eq(self.key_type_name, "Str") {
            mut a := ""
            mut b := ""
            memcpy(to_ptr(a), key_a_ptr, self.key_type_size)
            memcpy(to_ptr(b), key_b_ptr, self.key_type_size)
            return a.eq(b)
        } else {
            return memcmp(key_a_ptr, key_b_ptr, self.key_type_size).eq(0)
        }
    }

    /** Hash a key and return bucket index.
     *  For Str keys, uses Str.hash().
     *  For other types, uses FNV-1a on raw bytes. */
    hash_key := func(self: Map, key: Dynamic) returns I64 {
        mut h : I64 = 0
        if Str.eq(self.key_type_name, "Str") {
            mut k := ""
            memcpy(to_ptr(k), to_ptr(key), self.key_type_size)
            h = k.hash()
        } else {
            // FNV-1a hash on raw bytes
            FNV_OFFSET_BASIS : I64 = sub(0, 3750763034362895579)
            FNV_PRIME : I64 = 1099511628211
            h = FNV_OFFSET_BASIS
            for i in 0..self.key_type_size {
                mut byte_val : U8 = 0
                memcpy(to_ptr(byte_val), add(to_ptr(key), i), 1)
                h = I64_xor(h, U8.to_i64(byte_val))
                h = mul(h, FNV_PRIME)
            }
        }
        // Make positive and get bucket index
        if lt(h, 0) {
            h = sub(0, h)
        }
        return mod(h, self.num_buckets)
    }

    /** Hash lookup for key. Returns HashLookupResult with found flag and index.
     *  If found: index is the position in keys/values arrays.
     *  If not found: index is -1. */
    hash_lookup := proc(self: Map, key: Dynamic) returns HashLookupResult {
        mut result := HashLookupResult()
        result.found = false
        result.index = sub(0, 1)

        if self._size.gt(0) {
            bucket_idx := self.hash_key(key)
            mut idx : I64 = 0
            self.buckets.get(bucket_idx, idx)

            // Walk the chain
            while idx.gteq(0) {
                key_ptr := add(self.keys.ptr, mul(idx, self.key_type_size))
                if self.keys_equal(to_ptr(key), key_ptr) {
                    result.found = true
                    result.index = idx
                }
                if not(result.found) {
                    // Move to next in chain
                    mut next_idx : I64 = 0
                    self.nexts.get(idx, next_idx)
                    idx = next_idx
                } else {
                    idx = sub(0, 1)  // Exit loop
                }
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.hash_lookup: unexpected IndexOutOfBoundsError: ", err.msg)
        }

        return result
    }

    /** Insert new key-value pair.
     *  Throws DuplicatedKeyError if key already exists.
     *  Use set() instead if you want to overwrite existing keys. */
    insert := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError, DuplicatedKeyError {
        search := self.hash_lookup(key)

        if search.found {
            throw DuplicatedKeyError(msg=format(loc(), "Key already exists in map"))
        }

        // Append key and value
        new_idx := self._size
        self.keys.push(key)
        self.values.push(value)

        // Link into bucket chain (prepend to chain)
        bucket_idx := self.hash_key(key)
        mut old_head : I64 = 0
        self.buckets.get(bucket_idx, old_head)
        self.nexts.push(old_head)
        self.buckets.set(bucket_idx, new_idx)

        self._size = add(self._size, 1)

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.insert: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Set key-value pair.
     *  Overwrites value if key already exists.
     *  Creates new entry if key doesn't exist. */
    set := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError {
        search := self.hash_lookup(key)

        if search.found {
            // Key found - update value in place
            mut value_ptr := add(self.values.ptr, mul(search.index, self.value_type_size))
            memcpy(value_ptr, to_ptr(value), self.value_type_size)
        } else {
            // Key not found - append and link into bucket chain
            new_idx := self._size
            self.keys.push(key)
            self.values.push(value)

            bucket_idx := self.hash_key(key)
            mut old_head : I64 = 0
            self.buckets.get(bucket_idx, old_head)
            self.nexts.push(old_head)
            self.buckets.set(bucket_idx, new_idx)

            self._size = add(self._size, 1)
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.set: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Get value for given key.
     *  Copies value into dest parameter.
     *  Throws KeyNotFoundError if key doesn't exist. */
    get := proc(self: Map, key: Dynamic, mut dest: Dynamic) throws KeyNotFoundError {
        search := self.hash_lookup(key)

        if search.found {
            mut value_ptr := add(self.values.ptr, mul(search.index, self.value_type_size))
            memcpy(to_ptr(dest), value_ptr, self.value_type_size)
            return
        }

        throw KeyNotFoundError(msg=format(loc(), "Key not found in map"))
    }

    /** Check if key exists in map. */
    contains_key := proc(self: Map, key: Dynamic) returns Bool {
        search := self.hash_lookup(key)
        return search.found
    }

    /** Remove key from map. Does nothing if key doesn't exist.
     *  Note: Uses lazy deletion - marks entry as removed but doesn't reclaim space. */
    remove := proc(mut self: Map, key: Dynamic) {
        if self._size.eq(0) {
            return
        }

        bucket_idx := self.hash_key(key)
        mut prev_idx : I64 = sub(0, 1)
        mut idx : I64 = 0
        self.buckets.get(bucket_idx, idx)

        // Walk the chain to find the key
        while idx.gteq(0) {
            key_ptr := add(self.keys.ptr, mul(idx, self.key_type_size))
            if self.keys_equal(to_ptr(key), key_ptr) {
                // Found it - unlink from chain
                mut next_idx : I64 = 0
                self.nexts.get(idx, next_idx)

                if prev_idx.lt(0) {
                    // Removing head of chain
                    self.buckets.set(bucket_idx, next_idx)
                } else {
                    // Removing from middle/end of chain
                    self.nexts.set(prev_idx, next_idx)
                }

                self._size = sub(self._size, 1)
                return
            }
            prev_idx = idx
            self.nexts.get(idx, idx)
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.remove: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Get position (index) of key in internal storage.
     *  Returns -1 if key not found.
     *  Note: With hash table, this returns internal storage index. */
    position := proc(self: Map, key: Dynamic) returns I64 {
        search := self.hash_lookup(key)
        if search.found {
            return search.index
        }
        return sub(0, 1)  // -1 for not found
    }

    /** Get number of entries in map. */
    len := proc(self: Map) returns I64 {
        return self._size
    }

    /** Check if map is empty. */
    is_empty := func(self: Map) returns Bool {
        return self._size.eq(0)
    }

    /** Clear all entries from map (reset to empty). */
    clear := proc(mut self: Map) {
        self._size = 0
        self.keys._len = 0
        self.values._len = 0
        self.nexts._len = 0
        // Reset all buckets to -1 (empty)
        for i in 0..self.num_buckets {
            self.buckets.set(i, sub(0, 1))
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "Map.clear: unexpected IndexOutOfBoundsError: ", err.msg)
        }
    }

    /** Get total size in bytes (keys + values). */
    size := func(self: Map) returns I64 {
        mut keys_size := mul(self._size, self.key_type_size)
        mut values_size := mul(self._size, self.value_type_size)
        return add(keys_size, values_size)
    }

    /** Free map memory and reset. */
    delete := proc(mut self: Map) {
        mut keys_arr := self.keys
        keys_arr.delete()

        mut values_arr := self.values
        values_arr.delete()

        mut buckets_arr := self.buckets
        buckets_arr.delete()

        mut nexts_arr := self.nexts
        nexts_arr.delete()

        self._size = 0
        self.num_buckets = 0
    }

    // Bug #36 fix: Now we can inline throwing functions in struct literal params
    clone := func(self: Map) returns Map throws AllocError {
        return Map(
            key_type_name=self.key_type_name,
            key_type_size=self.key_type_size,
            value_type_name=self.value_type_name,
            value_type_size=self.value_type_size,
            keys=self.keys.clone(),
            values=self.values.clone(),
            buckets=self.buckets.clone(),
            nexts=self.nexts.clone(),
            _size=self._size,
            num_buckets=self.num_buckets
        )
    }
}
