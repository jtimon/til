mode lib

// Error types for system operations
SpawnError := struct {
    mut msg: Str = ""
}

SleepError := struct {
    mut msg: Str = ""
}

WaitError := struct {
    mut msg: Str = ""
}

/**
 * Executes a command using exec-style semantics (not shell).
 * Args are passed directly: run_cmd("ls", "-la", "/path")
 * NOT as a shell string: run_cmd("ls -la /path") -- this would fail
 * For shell command strings, use: run_cmd("bash", "-c", "your command here")
 *
 * WARNING: In mode safe_script, only whitelisted commands are allowed.
 * In other modes, arbitrary commands can be executed - use with caution.
 *
 * Returns exit code, output is written to mut output_str arg.
 */
run_cmd := ext_proc(mut output_str: Str, args: ..Str) returns I64 {}

/**
 * Like run_cmd but prints the command before executing it.
 */
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    exit_code := output_str.run_cmd("bash", "-c", cmd)

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: I64_OverflowError) { panic(loc(), err.msg) }

    return exit_code
}

/**
 * Spawns a new process by executing the given command string.
 *
 * This is a low-level primitive that starts the command in the background
 * without waiting for it to finish. The command is passed to the operating
 * system's shell (e.g., /bin/sh on Unix, cmd.exe on Windows).
 *
 * Returns: A platform-specific process identifier (PID on Unix, process handle on Windows)
 * Throws:  SpawnError if the process cannot be created (e.g., command not found, permission denied)
 */
spawn_cmd := ext_proc(cmd: Str) returns I64 throws SpawnError {}

/**
 * Checks the status of a running process without blocking.
 *
 * Returns:
 *   -1          if the process is still running
 *   >=0         exit code if the process has terminated
 *
 * This is a non-blocking poll. It can be called repeatedly to monitor progress.
 */
check_cmd_status := ext_proc(pid: I64) returns I64 {}

/**
 * Waits for a spawned process to finish and returns its exit code.
 *
 * This function blocks until the process identified by `pid` terminates.
 * It repeatedly polls the process status with a short sleep interval to avoid
 * busy-waiting.
 *
 * Returns: The exit code of the terminated process
 * Throws:  WaitError if an invalid PID is provided or another OS error occurs
 */
wait_cmd := proc(pid: I64) returns I64 throws SleepError {
    neg_one := sub(0, 1)  // -1
    while true {
        mut status := check_cmd_status(pid)
        if not(status.eq(neg_one)) {
            return status
        }
        sleep(50)  // sleep 50 milliseconds between polls
    }
}

/**
 * Pauses execution of the current process for the specified duration.
 *
 * This is a blocking sleep -- the interpreter will not execute any Til code
 * until the sleep duration has elapsed. It is primarily useful for polling loops
 * (e.g., waiting for background processes in test runners) to avoid busy-waiting
 * and reduce CPU usage.
 *
 * @param milliseconds: I64  The number of milliseconds to sleep.
 *                      Must be >= 0. Very large values are allowed but may be
 *                      capped by the operating system.
 * Throws: SleepError if the sleep is interrupted by a signal or an OS error occurs.
 */
sleep := ext_proc(milliseconds: I64) throws SleepError {}

/**
 * Returns the number of hardware threads available on the current system.
 *
 * This typically equals the number of logical processors (including hyperthreading).
 * For example, a 4-core CPU with hyperthreading returns 8.
 *
 * Returns: Number of threads (always >= 1)
 */
get_thread_count := ext_proc() returns I64 {}

/**
 * Returns the modification time of a file as Unix timestamp (seconds since epoch).
 * Returns -1 if the file does not exist or cannot be accessed.
 */
file_mtime := ext_proc(path: Str) returns I64 {}

/**
 * Lists files in a directory (raw version returning newline-separated string).
 * Returns filenames only (not full paths), excluding "." and "..".
 * Returns empty string if directory doesn't exist.
 */
list_dir_raw := ext_proc(path: Str) returns Str {}

/**
 * Lists files in a directory.
 * Returns filenames only (not full paths), excluding "." and "..".
 * Returns empty vector (of Str) if directory doesn't exist.
 */
list_dir := proc(path: Str) returns Vec throws AllocError, IndexOutOfBoundsError {
    raw := list_dir_raw(path)
    if raw.len().eq(0) {
        return Vec.new(Str)
    }
    return raw.split("\n")
}

/**
 * Simple glob for "dir/\*.ext" patterns.
 * Only supports patterns like "path/to/dir/\*.suffix".
 * Returns full paths (dir + "/" + filename).
 */
glob_files := proc(pattern: Str) returns Vec throws AllocError, IndexOutOfBoundsError {
    // Find last slash to split dir/pattern
    mut last_slash := 0
    for i in 0..pattern.len() {
        if pattern.get_char(i).eq("/") {
            last_slash = i
        }
    }

    dir := get_substr(pattern, 0, last_slash)
    file_pattern := get_substr(pattern, last_slash.add(1), pattern.len())

    // Extract suffix from "*.til" -> ".til"
    star_pos := file_pattern.find("*")
    suffix := get_substr(file_pattern, star_pos.add(1), file_pattern.len())

    mut result := Vec.new(Str)
    for f: Str in list_dir(dir) {
        if f.ends_with(suffix) {
            result.push(format(dir, "/", f))
        }
    }
    return result
}
