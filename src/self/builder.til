mode lib

import("src.self.interpreter")
import("src.self.precomp")
import("src.self.ccodegen")

// Note: import_path_to_file_path is available from init.til (via interpreter.til)

// Result type for parse_file (AST + mode)
ParseResult := struct {
    mut ast: Expr = Expr()
    mut file_mode: ModeDef = ModeDef()
}

// Parse a single file and return its AST and mode
parse_file := proc(path: Str) returns ParseResult throws Str {
    // Create lexer (reads file internally)
    mut lexer := Lexer.new(path)

    // Parse mode
    mut file_mode := parse_mode(path, lexer)

    // Parse body
    mut ast := parse_body(lexer, TokenType.Eof)

    mut result := ParseResult()
    result.ast = ast
    result.file_mode = file_mode

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Check if an expression is an import call
is_import_call := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.Identifier(name):
                return name.eq("import")
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Get import path from an import call expression
// Returns empty string if not an import call or path not found
get_import_path := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 1) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                if name.eq("import") {
                    mut import_arg := Expr()
                    expr.params.get(1, import_arg)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch import_arg.node_type {
                    case NodeType.LLiteral(lit):
                        switch lit {
                        case Literal.Str(import_path):
                            return import_path
                        case:
                            return ""
                        }
                    case:
                        return ""
                    }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}


// Collect imports from a single AST (non-recursive, returns new imports found)
collect_imports_single := proc(ast: Expr, mut imported: Set, mut dep_asts: Vec) throws Str {
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            mut import_path := get_import_path(child)
            if gt(import_path.len(), 0) {
                mut file_path := import_path_to_file_path(import_path)
                if not(imported.contains(file_path)) {
                    _ := imported.insert(file_path)
                    mut parse_result := parse_file(file_path)
                    // Recursively collect imports from this dependency first
                    collect_imports_single(parse_result.ast, imported, dep_asts)
                    dep_asts.push(parse_result.ast)
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Merge dependency AST params into all_params Vec, skipping imports
merge_dep_params := proc(dep: Expr, mut all_params: Vec) throws Str {
    switch dep.node_type {
    case NodeType.Body:
        mut j := 0
        while lt(j, dep.params.len()) {
            mut child := Expr()
            dep.params.get(j, child)
            if not(is_import_call(child)) {
                all_params.push(child)
            }
            j = add(j, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Build a TIL source file to C (default target)
// Returns the generated C code as a string
build := proc(path: Str) returns Str throws Str {
    println("Building file '", path, "'")

    // Parse main file
    mut main_result := parse_file(path)
    mut main_ast := main_result.ast
    mut main_mode := main_result.file_mode

    // Collect all imports recursively
    mut imported := Set.new(Str)
    _ := imported.insert(path)
    mut dep_asts := Vec.new(Expr)

    // Auto-import core.til first (like the interpreter does)
    mut core_path := "src/core/core.til"
    if not(path.eq(core_path)) {
        if not(imported.contains(core_path)) {
            _ := imported.insert(core_path)
            mut core_result := parse_file(core_path)
            // Collect core.til's imports first
            collect_imports_single(core_result.ast, imported, dep_asts)
            dep_asts.push(core_result.ast)
        }
    }

    collect_imports_single(main_ast, imported, dep_asts)

    // Merge all ASTs into one
    mut all_params := Vec.new(Expr)

    // Add dependencies first (in order they were collected)
    mut i := 0
    while lt(i, dep_asts.len()) {
        mut dep := Expr()
        dep_asts.get(i, dep)
        merge_dep_params(dep, all_params)
        i = add(i, 1)
    }

    // Add main file contents (skip imports)
    merge_dep_params(main_ast, all_params)

    mut merged_ast := Expr(NodeType.Body, all_params, main_ast.line, main_ast.col)

    // Run init phase (register declarations in context)
    // Use the mode from the main file
    mut context := Context.new(path, main_mode.name)
    mut errors := init_context(context, merged_ast)

    // Mark all already-imported files as done so mode imports don't re-import them
    // Both init and typer phases need to skip these files
    mut imported_idx := 0
    while lt(imported_idx, imported.len()) {
        mut file_path := ""
        imported.get(imported_idx, file_path)
        _ := context.imports_init_done.insert(file_path)
        _ := context.imports_typer_done.insert(file_path)
        imported_idx = add(imported_idx, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Run typer phase (type checking)
    mut mode_errors := basic_mode_checks(context, merged_ast)
    errors.extend(mode_errors)
    mut type_errors := check_types(context, merged_ast)
    errors.extend(type_errors)

    // Type checking - fail if there are errors (like the interpreter does)
    if gt(errors.len(), 0) {
        mut err_i := 0
        while lt(err_i, errors.len()) {
            mut err := ""
            errors.get(err_i, err)
            println(path, ":", err)
            err_i = add(err_i, 1)
        }
        mut err_count := I64.to_str(errors.len())
        throw format("Compiler errors: ", err_count, " type errors found")
    }

    catch (err: AllocError) { throw err.msg }

    // Precomputation phase: Transform UFCS calls into regular function calls
    merged_ast = precomp_expr(context, merged_ast)

    // Generate C code
    mut c_code := emit(merged_ast, context)

    // Write output file
    mut output_path := path.replace(".til", ".c")
    _ := writefile(output_path, c_code)
    println("Wrote C output to '", output_path, "'")

    // TODO: Compile with gcc (run_cmd not available in lib mode yet)

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return c_code
}
