// Builder module - orchestrates compilation to target languages
// Mirrors src/rs/builder.rs

mode lib

import("self.lexer")
import("self.parser")
import("self.mode")
import("self.ccodegen")
import("self.init")
import("self.typer")
import("self.desugarer")
import("self.garbager")
import("self.ufcs")
import("self.precomp")
import("self.scavenger")
import("self.target")
import("std.io")
import("std.sys")

// Parse a single file and return its AST (and mode for main file)
// Returns ParseFileResult struct since TIL doesn't have tuples
ParseFileResult := struct {
    mut ast: Expr = Expr()
    mut mode_def: ModeDef = ModeDef()?
}

parse_file := proc(path: Str) returns ParseFileResult throws Str {
    source := readfile(path)
    // readfile returns empty string on error (file not found, etc.)
    if source.is_empty() {
        throw concat("File '", path).concat("' not found or empty.")
    }

    mut lexer := lexer_from_source(path, source)?
    catch (err: Str) {
        throw path.concat(":").concat(err)
    }

    mode_def := parse_mode(path, lexer)?
    catch (err: Str) {
        throw path.concat(":").concat(err)
    }

    ast := parse_tokens(lexer)?
    catch (err: Str) {
        throw path.concat(":").concat(err)
    }

    mut result := ParseFileResult()
    result.ast = ast
    result.mode_def = mode_def

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Recursively collect all imports from an AST
// Each file is precompiled with its own path before being added to all_asts
collect_imports := proc(ast: Expr, mut imported: Set, mut all_asts: Vec, mut context: Context) throws Str {
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.FCall(_):
                if not(child.params.is_empty()) {
                    mut first_param := Expr()
                    child.params.get(0, first_param)?
                    switch first_param.node_type {
                    case NodeType.Identifier(name):
                        if name.eq("import").and(child.params.len().gt(1)) {
                            mut second_param := Expr()
                            child.params.get(1, second_param)?
                            switch second_param.node_type {
                            case NodeType.LLiteral(lit)?:
                                switch lit {
                                case Literal.Str(import_path):
                                    file_path := import_path_to_file_path(import_path)
                                    if not(imported.contains(file_path)) {
                                        _ := imported.insert(file_path.clone())
                                        // Bug #128: Use already-resolved AST from typer phase if available
                                        mut dep_resolved := Expr()
                                        context.imported_asts.get(file_path, dep_resolved)?
                                        catch (err: KeyNotFoundError) {
                                            dep_result := parse_file(file_path)?
                                            context.imported_asts.set(file_path.clone(), dep_result.ast.clone())
                                            dep_resolved = dep_result.ast
                                        }
                                        // Recursively collect imports from this dependency
                                        collect_imports(dep_resolved, imported, all_asts, context)?
                                        // Desugar + UFCS + Precomp with the correct path for this file
                                        // (type resolution already done by typer_import_declarations)
                                        saved_path := context.path.clone()
                                        context.path = file_path.clone()
                                        dep_desugared := desugar_expr(context, dep_resolved)?
                                        dep_garbaged := garbager_expr(context, dep_desugared)?
                                        dep_ufcs := ufcs_expr(context, dep_garbaged)?
                                        dep_ast := precomp_expr(context, dep_ufcs)?
                                        // Update with precompiled version
                                        context.imported_asts.set(file_path.clone(), dep_ast.clone())
                                        context.path = saved_path
                                        all_asts.push(dep_ast)
                                    }
                                case:
                                    // REM: not a string literal
                                }
                            case:
                                // REM: not a literal
                            }
                        }
                    case:
                        // REM: not an identifier
                    }
                }
            case:
                // REM: not an FCall
            }
        }
    case:
        // REM: not a Body
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Merge multiple ASTs into one, filtering out import statements
merge_asts := proc(main_ast: Expr, dep_asts: Vec) returns Expr {
    mut all_params := Vec.new(Expr)

    // Add dependencies first (in order they were collected)
    for dep: Expr in dep_asts {
        switch dep.node_type {
        case NodeType.Body:
            for child: Expr in dep.params {
                // Skip import statements
                if not(is_import_call(child)) {
                    all_params.push(child.clone())
                }
            }
        case:
            // REM: not a Body
        }
    }

    // Add main file contents (skip imports)?
    switch main_ast.node_type {
    case NodeType.Body:
        for child: Expr in main_ast.params {
            if not(is_import_call(child)) {
                all_params.push(child.clone())
            }
        }
    case:
        // REM: not a Body
    }

    mut result := Expr()
    result.node_type = NodeType.Body
    result.params = all_params
    result.line = main_ast.line
    result.col = main_ast.col

    return result
}

is_import_call := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.FCall(_):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.Identifier(name)?:
                return name.eq("import")
            case:
                return false
            }
            catch (err: IndexOutOfBoundsError) {
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Collect import paths from an AST without precompilation (lightweight for deps checking)
collect_import_paths := proc(ast: Expr, mut collected: Set) {
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.FCall(_):
                if not(child.params.is_empty()) {
                    mut first_param := Expr()
                    child.params.get(0, first_param)?
                    switch first_param.node_type {
                    case NodeType.Identifier(name):
                        if name.eq("import").and(child.params.len().gt(1)) {
                            mut second_param := Expr()
                            child.params.get(1, second_param)?
                            switch second_param.node_type {
                            case NodeType.LLiteral(lit)?:
                                switch lit {
                                case Literal.Str(import_path)?:
                                    file_path := import_path_to_file_path(import_path)
                                    if not(collected.contains(file_path)) {
                                        _ := collected.insert(file_path.clone())
                                        // Recursively collect imports from this dependency
                                        dep_result := parse_file(file_path)?
                                        collect_import_paths(dep_result.ast, collected)
                                        catch (err: Str) {
                                            // Ignore parse errors for deps checking
                                        }
                                    }
                                case:
                                    // REM: not a string literal
                                }
                            case:
                                // REM: not a literal
                            }
                        }
                    case:
                        // REM: not an identifier
                    }
                }
            case:
                // REM: not an FCall
            }
        }
    case:
        // REM: not a Body
    }

    catch (err: IndexOutOfBoundsError) {
        // Ignore index errors for deps checking
    }
}

// Collect all dependencies for a TIL source file (for rebuild checking)
// Returns all file paths that the main file depends on, including:
// - The main file itself
// - core.til and its imports
// - Mode-specific imports
// - All transitive imports
collect_all_deps := proc(path: Str) returns Vec throws Str {
    mut deps := Set.new(Str)

    // Add main file
    _ := deps.insert(path.clone())

    // Parse main file to get its mode and imports
    main_result := parse_file(path)?

    // Add core.til and its imports (unless main file IS core.til)?
    core_path := "src/core/core.til"
    if not(path.eq(core_path)) {
        _ := deps.insert(core_path)
        core_result := parse_file(core_path)?
        collect_import_paths(core_result.ast, deps)
    }

    // Add mode-specific imports
    for import_str: Str in main_result.mode_def.imports {
        file_path := import_path_to_file_path(import_str)
        if not(deps.contains(file_path)) {
            _ := deps.insert(file_path.clone())
            mode_result := parse_file(file_path)?
            collect_import_paths(mode_result.ast, deps)
            catch (err: Str) {
                // Ignore parse errors for deps checking
            }
        }
    }

    // Collect main file's imports
    collect_import_paths(main_result.ast, deps)

    // Convert Set to Vec
    mut result := Vec.new(Str)
    for dep: Str in deps {
        result.push(dep.clone())
    }

    return result
}

// Build a TIL source file with target, lang, and translate_only options
// Returns the output path (executable or source file)
build := proc(path: Str, target: Target, lang: Lang, translate_only: Bool) returns Str throws Str {
    // Validate lang is supported for target
    validate_lang_for_target(lang, target)?

    // Currently only C is fully supported
    switch lang {
    case Lang.C:
        // Supported
    case Lang.TIL:
        throw "Lang 'til' is not supported yet. TIL-to-TIL translation is a placeholder for future debugging features."
    case:
        throw concat("Lang '", lang_to_str(lang)).concat("' is not supported yet. Only 'c' is currently implemented.")
    }

    // Parse main file
    main_result := parse_file(path)?

    // Create context with "lib" mode first (like interpreter does at interpreter.rs:2713)
    // This ensures core.til is typechecked with lib mode, not the main file's mode
    mut context := Context.new(path, "lib")?

    // Reusable error vector to avoid shadowing
    mut errors := Vec.new(Str)

    // Auto-import core.til first (like the interpreter does at interpreter.rs:2714-2717)
    // This runs init + typer on core.til and all its imports with lib mode
    core_path := "src/core/core.til"
    if not(path.eq(core_path)) {
        core_result := parse_file(core_path)?
        errors = init_context(context, core_result.ast)?
        if not(errors.is_empty()) {
            for err: Str in errors {
                println(err)
            }
            throw concat("Compiler errors: ", errors.len().to_str()).concat(" init errors in core.til")
        }
        errors = check_types(context, core_result.ast)?
        if not(errors.is_empty()) {
            for err: Str in errors {
                println(err)
            }
            throw concat("Compiler errors: ", errors.len().to_str()).concat(" type errors in core.til")
        }
        _ := context.imports_init_done.insert(core_path)
        _ := context.imports_typer_done.insert(core_path)
    }

    // Now set the mode to the main file's mode (like interpreter does at interpreter.rs:2610-2611)
    context.mode_def = main_result.mode_def.clone()

    // Process mode-specific imports (like the interpreter does at interpreter.rs:2515-2541)
    for import_str: Str in context.mode_def.imports.clone() {
        mut import_func_name_expr := Expr()
        import_func_name_expr.node_type = NodeType.Identifier("import")
        import_func_name_expr.line = 0
        import_func_name_expr.col = 0

        mut import_path_expr := Expr()
        import_path_expr.node_type = NodeType.LLiteral(Literal.Str(import_str.clone()))
        import_path_expr.line = 0
        import_path_expr.col = 0

        mut import_fcall_expr := Expr()
        import_fcall_expr.node_type = NodeType.FCall(false)
        import_fcall_expr.params = Vec.new(Expr)
        import_fcall_expr.params.push(import_func_name_expr)
        import_fcall_expr.params.push(import_path_expr)
        import_fcall_expr.line = 0
        import_fcall_expr.col = 0

        // Mode imports need init and typer phases (no eval for builder)
        init_import_declarations(context, import_fcall_expr, import_str)?
        catch (err: Str) {
            throw path.concat(":").concat(err)
        }
        errors = typer_import_declarations(context, import_str)
        if not(errors.is_empty()) {
            for err: Str in errors {
                println(err)
            }
            throw concat("Compiler errors: ", errors.len().to_str()).concat(" type errors found")
        }
    }

    // Mark main file as "done" to prevent re-processing via circular imports
    // (like interpreter does at interpreter.rs:2598-2601)
    _ := context.imports_init_done.insert(path.clone())
    _ := context.imports_typer_done.insert(path.clone())

    // Run init + typer on the main file (this handles its imports internally)
    errors.clear()
    mut tmp_errors := init_context(context, main_result.ast)?
    for err: Str in tmp_errors {
        errors.push(err.clone())
    }
    if not(errors.is_empty()) {
        for err: Str in errors {
            println(err)
        }
        throw concat("Compiler errors: ", errors.len().to_str()).concat(" init errors found")
    }

    tmp_errors = basic_mode_checks(context, main_result.ast)?
    for err: Str in tmp_errors {
        errors.push(err.clone())
    }
    tmp_errors = check_types(context, main_result.ast)?
    for err: Str in tmp_errors {
        errors.push(err.clone())
    }
    if not(errors.is_empty()) {
        for err: Str in errors {
            println(err)
        }
        throw concat("Compiler errors: ", errors.len().to_str()).concat(" type errors found")
    }

    // === Post-typer: Collect and merge ASTs for codegen ===
    // Now that type checking passed, collect all imported files for code generation
    // Each file is precompiled with its own path before merging
    mut imported := Set.new(Str)
    _ := imported.insert(path.clone())
    // Store main file AST so circular imports can find it during precomp
    context.imported_asts.set(path.clone(), main_result.ast.clone())
    mut dep_asts := Vec.new(Expr)

    // Collect core.til and its imports
    if not(path.eq(core_path)) {
        codegen_core_result := parse_file(core_path)?
        _ := imported.insert(core_path)
        collect_imports(codegen_core_result.ast, imported, dep_asts, context)?
        // Resolve types + Desugar + UFCS + Precomp core.til with its own path
        core_saved_path := context.path.clone()
        context.path = core_path
        core_resolved := resolve_inferred_types(context, codegen_core_result.ast)?
        core_desugared := desugar_expr(context, core_resolved)?
        core_garbaged := garbager_expr(context, core_desugared)?
        core_ufcs_ast := ufcs_expr(context, core_garbaged)?
        core_precomp_ast := precomp_expr(context, core_ufcs_ast)?
        context.path = core_saved_path
        dep_asts.push(core_precomp_ast)
    }

    // Collect mode imports
    for import_str: Str in context.mode_def.imports.clone() {
        file_path := import_path_to_file_path(import_str)
        if not(imported.contains(file_path)) {
            _ := imported.insert(file_path.clone())
            mode_result := parse_file(file_path)?
            collect_imports(mode_result.ast, imported, dep_asts, context)?
            // Resolve types + Desugar + UFCS + Precomp mode file with its own path
            mode_saved_path := context.path.clone()
            context.path = file_path.clone()
            mode_resolved := resolve_inferred_types(context, mode_result.ast)?
            mode_desugared := desugar_expr(context, mode_resolved)?
            mode_garbaged := garbager_expr(context, mode_desugared)?
            mode_ufcs_ast := ufcs_expr(context, mode_garbaged)?
            mode_precomp_ast := precomp_expr(context, mode_ufcs_ast)?
            context.path = mode_saved_path
            dep_asts.push(mode_precomp_ast)
        }
    }

    // Collect main file's imports
    collect_imports(main_result.ast, imported, dep_asts, context)?

    // Resolve types + Desugar + UFCS + Precomp main file with its own path (context.path should already be correct)
    main_resolved := resolve_inferred_types(context, main_result.ast)?
    main_desugared := desugar_expr(context, main_resolved)?
    main_garbaged := garbager_expr(context, main_desugared)?
    main_ufcs := ufcs_expr(context, main_garbaged)?
    main_ast := precomp_expr(context, main_ufcs)?

    // Merge all precompiled ASTs for codegen
    merged_ast := merge_asts(main_ast, dep_asts)

    // Scavenger phase: Remove unused function declarations
    merged_ast2 := scavenger_expr(context, merged_ast)?

    // Generate C code
    c_code := emit(merged_ast2, context)?

    // Write output file to ./gen/{LANG_NAME_141}/c/ directory instead of alongside source
    // Bug #141: Use LANG_NAME_141 to separate rstil (rs) and til outputs
    c_filename := path.replace(".til", ".c")
    gen_prefix := concat("gen/", LANG_NAME_141).concat("/c/")
    mut source_output_path := c_filename.clone()
    if c_filename.starts_with("src/") {
        source_output_path = c_filename.replace("src/", gen_prefix)
    } else {
        source_output_path = concat(gen_prefix, c_filename)
    }
    // Create output directory if it doesn't exist
    parent_dir := fs_parent_dir(source_output_path)
    if not(parent_dir.is_empty()) {
        _ := fs_mkdir_p(parent_dir)
    }
    write_err := writefile(source_output_path, c_code)
    if not(write_err.is_empty()) {
        throw concat("Failed to write '", source_output_path).concat("': ").concat(write_err)
    }

    // If translate_only, return the source file path
    if translate_only {
        return source_output_path
    }

    // Get toolchain command for target
    compiler := toolchain_command(target, lang)?

    // Compile - output to bin/{LANG_NAME_141}/ directory in project root, preserving relative path
    // Bug #141: Use LANG_NAME_141 to separate rstil (rs) and til outputs
    // e.g., src/til.til -> bin/til/til, src/examples/hello_script.til -> bin/til/examples/hello_script
    exe_extension := executable_extension(target)
    bin_filename := path.replace(".til", exe_extension)
    bin_prefix := concat("bin/", LANG_NAME_141).concat("/")
    mut exe_path_str := bin_filename.clone()
    if bin_filename.starts_with("src/") {
        exe_path_str = bin_filename.replace("src/", bin_prefix)
    } else {
        exe_path_str = concat(bin_prefix, bin_filename)
    }
    // Create bin directory if it doesn't exist
    bin_parent_dir := fs_parent_dir(exe_path_str)
    if not(bin_parent_dir.is_empty()) {
        _ := fs_mkdir_p(bin_parent_dir)
    }

    // Build command with extra args for target
    mut cmd_args := Vec.new(Str)
    cmd_args.push("-I")
    cmd_args.push("src")
    extra_args := toolchain_extra_args(target, lang)
    for extra_arg: Str in extra_args {
        cmd_args.push(extra_arg.clone())
    }
    cmd_args.push(source_output_path.clone())
    cmd_args.push("-o")
    cmd_args.push(exe_path_str.clone())

    // Build full command string with stderr redirected to stdout (like Rust's cmd.output())?
    mut full_cmd := compiler
    for arg: Str in cmd_args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    full_cmd = full_cmd.concat(" 2>&1")  // Capture stderr like Rust does
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)

    if exit_code.eq(0) {
        return exe_path_str
    } else {
        throw compiler.concat(" failed: ").concat(output)
    }
}
