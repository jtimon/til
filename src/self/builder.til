mode liba

import("self.interpreter")
import("self.precomp")
import("self.scavenger")
import("self.ccodegen")
import("self.target")       // Target, Lang, toolchain_command, toolchain_extra_args, executable_extension, validate_lang_for_target, lang_to_str
import("std.io")            // writefile
import("std.sys")           // run_cmd

// Note: import_path_to_file_path is available from init.til (via interpreter.til)

// Result type for parse_file (AST + mode)
ParseResult := struct {
    mut ast: Expr = Expr()
    mut file_mode: ModeDef = ModeDef()
}

// Parse a single file and return its AST (and mode for main file)
parse_file := proc(path: Str) returns ParseResult throws Str {
    source := readfile(path)
    mut lexer := lexer_from_source(path, source)

    // Parse mode
    mut file_mode := parse_mode(path, lexer)

    // Parse body
    mut ast := parse_body(lexer, TokenType.Eof)

    mut result := ParseResult()
    result.ast = ast
    result.file_mode = file_mode

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Check if an expression is an import call
is_import_call := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.Identifier(name):
                return name.eq("import")
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Get import path from an import call expression
// Returns empty string if not an import call or path not found
get_import_path := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 1) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                if name.eq("import") {
                    mut import_arg := Expr()
                    expr.params.get(1, import_arg)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch import_arg.node_type {
                    case NodeType.LLiteral(lit):
                        switch lit {
                        case Literal.Str(import_path):
                            return import_path
                        case:
                            return ""
                        }
                    case:
                        return ""
                    }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}


// Collect imports from a single AST (non-recursive, returns new imports found)
// Each file is precompiled with its own path before being added to dep_asts
collect_imports_single := proc(ast: Expr, mut imported: Set, mut dep_asts: Vec, mut context: Context) throws Str {
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            mut import_path := get_import_path(child)
            if gt(import_path.len(), 0) {
                mut file_path := import_path_to_file_path(import_path)
                if not(imported.contains(file_path)) {
                    _ := imported.insert(file_path)
                    mut parse_result := parse_file(file_path)
                    // Store AST in imported_asts so precomp can find it for circular imports
                    context.imported_asts.set(file_path, parse_result.ast)
                    // Recursively collect imports from this dependency first
                    collect_imports_single(parse_result.ast, imported, dep_asts, context)
                    // Precomp with the correct path for this file
                    mut saved_path := context.path
                    context.path = file_path
                    mut dep_ast := precomp_expr(context, parse_result.ast)
                    // Update with precompiled version
                    context.imported_asts.set(file_path, dep_ast)
                    context.path = saved_path
                    dep_asts.push(dep_ast)
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Merge dependency AST params into all_params Vec, skipping imports
merge_dep_params := proc(dep: Expr, mut all_params: Vec) throws Str {
    switch dep.node_type {
    case NodeType.Body:
        mut j := 0
        while lt(j, dep.params.len()) {
            mut child := Expr()
            dep.params.get(j, child)
            if not(is_import_call(child)) {
                all_params.push(child)
            }
            j = add(j, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Build a TIL source file with target, lang, and translate_only options
// Returns the output path (executable or source file)
build := proc(path: Str, target: Target, lang: Lang, translate_only: Bool) returns Str throws Str {
    // Validate lang is supported for target
    validate_lang_for_target(lang, target)

    // Currently only C is fully supported
    switch lang {
    case Lang.C:
        // Supported
    case Lang.TIL:
        throw "Lang 'til' is not supported yet. TIL-to-TIL translation is a placeholder for future debugging features."
    case:
        throw format("Lang '", lang_to_str(lang), "' is not supported yet. Only 'c' is currently implemented.")
    }

    // Parse main file
    mut main_result := parse_file(path)
    mut main_ast := main_result.ast
    mut main_mode := main_result.file_mode

    // Create context with "lib" mode first (like interpreter does at interpreter.rs:2713)
    // This ensures core.til is typechecked with lib mode, not the main file's mode
    mut context := Context.new(path, "lib")

    // Auto-import core.til first (like the interpreter does at interpreter.rs:2714-2717)
    // This runs init + typer on core.til and all its imports with lib mode
    mut core_path := "src/core/core.til"
    if not(path.eq(core_path)) {
        mut core_result := parse_file(core_path)
        mut init_errors := init_context(context, core_result.ast)
        if init_errors.len().gt(0) {
            for err: Str in init_errors {
                println(err)
            }
            throw format("Compiler errors: ", init_errors.len().to_str(), " init errors in core.til")
        }
        mut typer_errors := check_types(context, core_result.ast)
        if typer_errors.len().gt(0) {
            for err: Str in typer_errors {
                println(err)
            }
            throw format("Compiler errors: ", typer_errors.len().to_str(), " type errors in core.til")
        }
        _ := context.imports_init_done.insert(core_path)
        _ := context.imports_typer_done.insert(core_path)
    }

    // Now set the mode to the main file's mode (like interpreter does at interpreter.rs:2610-2611)
    context.mode_def = main_mode

    // Process mode-specific imports (like the interpreter does at interpreter.rs:2515-2541)
    mut mode_import_idx := 0
    while lt(mode_import_idx, context.mode_def.imports.len()) {
        mut import_str := ""
        context.mode_def.imports.get(mode_import_idx, import_str)

        mut import_func_name_expr := Expr.new_explicit(NodeType.Identifier("import"), Vec.new(Expr), 0, 0)
        mut import_path_expr := Expr.new_explicit(NodeType.LLiteral(Literal.Str(import_str)), Vec.new(Expr), 0, 0)
        mut import_params := Vec.new(Expr)
        import_params.push(import_func_name_expr)
        import_params.push(import_path_expr)
        mut import_fcall_expr := Expr.new_explicit(NodeType.FCall, import_params, 0, 0)

        // Mode imports need init and typer phases (no eval for builder)
        init_import_declarations(context, import_fcall_expr, import_str)
        mut typer_errs := typer_import_declarations(context, import_str)
        if typer_errs.len().gt(0) {
            for err: Str in typer_errs {
                println(err)
            }
            throw format("Compiler errors: ", typer_errs.len().to_str(), " type errors found")
        }
        mode_import_idx = add(mode_import_idx, 1)
    }

    // Mark main file as "done" to prevent re-processing via circular imports
    // (like interpreter does at interpreter.rs:2598-2601)
    _ := context.imports_init_done.insert(path)
    _ := context.imports_typer_done.insert(path)

    // Run init + typer on the main file (this handles its imports internally)
    mut errors := init_context(context, main_ast)
    if errors.len().gt(0) {
        for err: Str in errors {
            println(err)
        }
        throw format("Compiler errors: ", errors.len().to_str(), " init errors found")
    }

    mut mode_errors := basic_mode_checks(context, main_ast)
    errors.extend(mode_errors)
    mut type_errors := check_types(context, main_ast)
    errors.extend(type_errors)
    if errors.len().gt(0) {
        for err: Str in errors {
            println(err)
        }
        throw format("Compiler errors: ", errors.len().to_str(), " type errors found")
    }

    // === Post-typer: Collect and merge ASTs for codegen ===
    // Now that type checking passed, collect all imported files for code generation
    // Each file is precompiled with its own path before merging
    mut imported := Set.new(Str)
    _ := imported.insert(path)
    // Store main file AST so circular imports can find it during precomp
    context.imported_asts.set(path, main_ast)
    mut dep_asts := Vec.new(Expr)

    // Collect core.til and its imports
    if not(path.eq(core_path)) {
        mut core_result := parse_file(core_path)
        _ := imported.insert(core_path)
        collect_imports_single(core_result.ast, imported, dep_asts, context)
        // Precomp core.til with its own path
        mut saved_path := context.path
        context.path = core_path
        mut core_ast := precomp_expr(context, core_result.ast)
        context.path = saved_path
        dep_asts.push(core_ast)
    }

    // Collect mode imports
    mut mode_collect_idx := 0
    while lt(mode_collect_idx, context.mode_def.imports.len()) {
        mut import_str := ""
        context.mode_def.imports.get(mode_collect_idx, import_str)
        mut file_path := import_path_to_file_path(import_str)
        if not(imported.contains(file_path)) {
            _ := imported.insert(file_path)
            mut mode_result := parse_file(file_path)
            collect_imports_single(mode_result.ast, imported, dep_asts, context)
            // Precomp mode file with its own path
            mut saved_path := context.path
            context.path = file_path
            mut mode_ast := precomp_expr(context, mode_result.ast)
            context.path = saved_path
            dep_asts.push(mode_ast)
        }
        mode_collect_idx = add(mode_collect_idx, 1)
    }

    // Collect main file's imports
    collect_imports_single(main_ast, imported, dep_asts, context)

    // Precomp main file with its own path (context.path should already be correct)
    main_ast = precomp_expr(context, main_ast)

    // Merge all precompiled ASTs for codegen
    mut all_params := Vec.new(Expr)

    // Add dependencies first (in order they were collected)
    mut i := 0
    while lt(i, dep_asts.len()) {
        mut dep := Expr()
        dep_asts.get(i, dep)
        merge_dep_params(dep, all_params)
        i = add(i, 1)
    }

    // Add main file contents (skip imports)
    merge_dep_params(main_ast, all_params)

    mut merged_ast := Expr.new_explicit(NodeType.Body, all_params, main_ast.line, main_ast.col)

    // Scavenger phase: Remove unused function declarations
    merged_ast = scavenger_expr(context, merged_ast)

    // Generate C code
    mut c_code := emit(merged_ast, context)

    // DEBUG: trace segfault

    // Write output file to ./gen/c/ directory instead of alongside source
    mut c_filename := path.replace(".til", ".c")
    mut source_output_path := c_filename
    if c_filename.starts_with("src/") {
        source_output_path = c_filename.replacen("src/", "gen/c/", 1)
    } else {
        source_output_path = concat("gen/c/", c_filename)
    }
    // Create output directory if it doesn't exist
    // Extract parent directory path (everything up to last /)
    mut last_slash := source_output_path.rfind("/")
    if gt(last_slash, 0) {
        mut parent_dir := source_output_path.get_substr(0, last_slash)
        mut mkdir_output := ""
        _ := run_cmd(mkdir_output, "mkdir", "-p", parent_dir)
    }
    _ := writefile(source_output_path, c_code)

    // If translate_only, return the source file path
    if translate_only {
        return source_output_path
    }

    // Get toolchain command for target
    mut compiler := toolchain_command(target, lang)

    // Compile - output to bin/ directory in project root, preserving relative path
    // e.g., src/til.til -> bin/til, src/examples/hello_script.til -> bin/examples/hello_script
    mut exe_extension := executable_extension(target)
    mut bin_filename := path.replace(".til", exe_extension)
    mut exe_path_str := bin_filename
    if bin_filename.starts_with("src/") {
        exe_path_str = bin_filename.replacen("src/", "bin/", 1)
    } else {
        exe_path_str = concat("bin/", bin_filename)
    }
    // Create bin directory if it doesn't exist
    mut exe_last_slash := exe_path_str.rfind("/")
    if gt(exe_last_slash, 0) {
        mut exe_parent_dir := exe_path_str.get_substr(0, exe_last_slash)
        mut mkdir_bin_output := ""
        _ := run_cmd(mkdir_bin_output, "mkdir", "-p", exe_parent_dir)
    }

    // Build command with extra args for target
    mut cmd_str := compiler.concat(" -I src")
    mut extra_args := toolchain_extra_args(target, lang)
    mut arg_idx := 0
    while arg_idx.lt(extra_args.len()) {
        mut extra_arg := ""
        extra_args.get(arg_idx, extra_arg)
        cmd_str = cmd_str.concat(" ").concat(extra_arg)
        arg_idx.inc()
    }
    cmd_str = cmd_str.concat(" ").concat(source_output_path).concat(" -o ").concat(exe_path_str)

    mut pid := spawn_cmd(cmd_str)
    catch (err: SpawnError) {
        throw format("Failed to run ", compiler, ": ", err.msg)
    }
    mut exit_code := wait_cmd(pid)
    catch (err: SleepError) {
        throw format("Failed to wait for ", compiler, ": ", err.msg)
    }
    if not(exit_code.eq(0)) {
        throw format(compiler, " failed")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return exe_path_str
}
