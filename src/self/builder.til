mode liba

import("self.interpreter")
import("self.precomp")
import("self.scavenger")
import("self.ccodegen")
import("std.io")            // writefile

// Note: import_path_to_file_path is available from init.til (via interpreter.til)

// Result type for parse_file (AST + mode)
ParseResult := struct {
    mut ast: Expr = Expr()
    mut file_mode: ModeDef = ModeDef()
}

// Parse a single file and return its AST (and mode for main file)
parse_file := proc(path: Str) returns ParseResult throws Str {
    source := readfile(path)
    mut lexer := lexer_from_source(path, source)

    // Parse mode
    mut file_mode := parse_mode(path, lexer)

    // Parse body
    mut ast := parse_body(lexer, TokenType.Eof)

    mut result := ParseResult()
    result.ast = ast
    result.file_mode = file_mode

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Check if an expression is an import call
is_import_call := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.Identifier(name):
                return name.eq("import")
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Get import path from an import call expression
// Returns empty string if not an import call or path not found
get_import_path := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 1) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                if name.eq("import") {
                    mut import_arg := Expr()
                    expr.params.get(1, import_arg)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch import_arg.node_type {
                    case NodeType.LLiteral(lit):
                        switch lit {
                        case Literal.Str(import_path):
                            return import_path
                        case:
                            return ""
                        }
                    case:
                        return ""
                    }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}


// Collect imports from a single AST (non-recursive, returns new imports found)
// Each file is precompiled with its own path before being added to dep_asts
collect_imports_single := proc(ast: Expr, mut imported: Set, mut dep_asts: Vec, mut context: Context) throws Str {
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            mut import_path := get_import_path(child)
            if gt(import_path.len(), 0) {
                mut file_path := import_path_to_file_path(import_path)
                if not(imported.contains(file_path)) {
                    _ := imported.insert(file_path)
                    mut parse_result := parse_file(file_path)
                    // Store AST in imported_asts so precomp can find it for circular imports
                    context.imported_asts.set(file_path, parse_result.ast)
                    // Recursively collect imports from this dependency first
                    collect_imports_single(parse_result.ast, imported, dep_asts, context)
                    // Precomp with the correct path for this file
                    mut saved_path := context.path
                    context.path = file_path
                    mut dep_ast := precomp_expr(context, parse_result.ast)
                    // Update with precompiled version
                    context.imported_asts.set(file_path, dep_ast)
                    context.path = saved_path
                    dep_asts.push(dep_ast)
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Merge dependency AST params into all_params Vec, skipping imports
merge_dep_params := proc(dep: Expr, mut all_params: Vec) throws Str {
    switch dep.node_type {
    case NodeType.Body:
        mut j := 0
        while lt(j, dep.params.len()) {
            mut child := Expr()
            dep.params.get(j, child)
            if not(is_import_call(child)) {
                all_params.push(child)
            }
            j = add(j, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body
    }
    catch (err: AllocError) { throw err.msg }
}

// Build a TIL source file to C (default target)
// Returns the generated C code as a string
build := proc(path: Str) returns Str throws Str {

    // Parse main file
    mut main_result := parse_file(path)
    mut main_ast := main_result.ast
    mut main_mode := main_result.file_mode

    // Create context with "lib" mode first (like interpreter does at interpreter.rs:2713)
    // This ensures core.til is typechecked with lib mode, not the main file's mode
    mut context := Context.new(path, "lib")

    // Auto-import core.til first (like the interpreter does at interpreter.rs:2714-2717)
    // This runs init + typer on core.til and all its imports with lib mode
    mut core_path := "src/core/core.til"
    if not(path.eq(core_path)) {
        mut core_result := parse_file(core_path)
        mut init_errors := init_context(context, core_result.ast)
        if init_errors.len().gt(0) {
            for err: Str in init_errors {
                println(err)
            }
            throw format("Compiler errors: ", init_errors.len().to_str(), " init errors in core.til")
        }
        mut typer_errors := check_types(context, core_result.ast)
        if typer_errors.len().gt(0) {
            for err: Str in typer_errors {
                println(err)
            }
            throw format("Compiler errors: ", typer_errors.len().to_str(), " type errors in core.til")
        }
        _ := context.imports_init_done.insert(core_path)
        _ := context.imports_typer_done.insert(core_path)
    }

    // Now set the mode to the main file's mode (like interpreter does at interpreter.rs:2610-2611)
    context.mode_def = main_mode

    // Process mode-specific imports (like the interpreter does at interpreter.rs:2515-2541)
    mut mode_import_idx := 0
    while lt(mode_import_idx, context.mode_def.imports.len()) {
        mut import_str := ""
        context.mode_def.imports.get(mode_import_idx, import_str)

        mut import_func_name_expr := Expr.new_explicit(NodeType.Identifier("import"), Vec.new(Expr), 0, 0)
        mut import_path_expr := Expr.new_explicit(NodeType.LLiteral(Literal.Str(import_str)), Vec.new(Expr), 0, 0)
        mut import_params := Vec.new(Expr)
        import_params.push(import_func_name_expr)
        import_params.push(import_path_expr)
        mut import_fcall_expr := Expr.new_explicit(NodeType.FCall, import_params, 0, 0)

        // Mode imports need init and typer phases (no eval for builder)
        init_import_declarations(context, import_fcall_expr, import_str)
        mut typer_errs := typer_import_declarations(context, import_str)
        if typer_errs.len().gt(0) {
            for err: Str in typer_errs {
                println(err)
            }
            throw format("Compiler errors: ", typer_errs.len().to_str(), " type errors found")
        }
        mode_import_idx = add(mode_import_idx, 1)
    }

    // Mark main file as "done" to prevent re-processing via circular imports
    // (like interpreter does at interpreter.rs:2598-2601)
    _ := context.imports_init_done.insert(path)
    _ := context.imports_typer_done.insert(path)

    // Run init + typer on the main file (this handles its imports internally)
    mut errors := init_context(context, main_ast)
    if errors.len().gt(0) {
        for err: Str in errors {
            println(err)
        }
        throw format("Compiler errors: ", errors.len().to_str(), " init errors found")
    }

    mut mode_errors := basic_mode_checks(context, main_ast)
    errors.extend(mode_errors)
    mut type_errors := check_types(context, main_ast)
    errors.extend(type_errors)
    if errors.len().gt(0) {
        for err: Str in errors {
            println(err)
        }
        throw format("Compiler errors: ", errors.len().to_str(), " type errors found")
    }

    // === Post-typer: Collect and merge ASTs for codegen ===
    // Now that type checking passed, collect all imported files for code generation
    // Each file is precompiled with its own path before merging
    mut imported := Set.new(Str)
    _ := imported.insert(path)
    // Store main file AST so circular imports can find it during precomp
    context.imported_asts.set(path, main_ast)
    mut dep_asts := Vec.new(Expr)

    // Collect core.til and its imports
    if not(path.eq(core_path)) {
        mut core_result := parse_file(core_path)
        _ := imported.insert(core_path)
        collect_imports_single(core_result.ast, imported, dep_asts, context)
        // Precomp core.til with its own path
        mut saved_path := context.path
        context.path = core_path
        mut core_ast := precomp_expr(context, core_result.ast)
        context.path = saved_path
        dep_asts.push(core_ast)
    }

    // Collect mode imports
    mut mode_collect_idx := 0
    while lt(mode_collect_idx, context.mode_def.imports.len()) {
        mut import_str := ""
        context.mode_def.imports.get(mode_collect_idx, import_str)
        mut file_path := import_path_to_file_path(import_str)
        if not(imported.contains(file_path)) {
            _ := imported.insert(file_path)
            mut mode_result := parse_file(file_path)
            collect_imports_single(mode_result.ast, imported, dep_asts, context)
            // Precomp mode file with its own path
            mut saved_path := context.path
            context.path = file_path
            mut mode_ast := precomp_expr(context, mode_result.ast)
            context.path = saved_path
            dep_asts.push(mode_ast)
        }
        mode_collect_idx = add(mode_collect_idx, 1)
    }

    // Collect main file's imports
    collect_imports_single(main_ast, imported, dep_asts, context)

    // Precomp main file with its own path (context.path should already be correct)
    main_ast = precomp_expr(context, main_ast)

    // Merge all precompiled ASTs for codegen
    mut all_params := Vec.new(Expr)

    // Add dependencies first (in order they were collected)
    mut i := 0
    while lt(i, dep_asts.len()) {
        mut dep := Expr()
        dep_asts.get(i, dep)
        merge_dep_params(dep, all_params)
        i = add(i, 1)
    }

    // Add main file contents (skip imports)
    merge_dep_params(main_ast, all_params)

    mut merged_ast := Expr.new_explicit(NodeType.Body, all_params, main_ast.line, main_ast.col)

    // DEBUG: trace segfault

    // Scavenger phase: Remove unused function declarations
    merged_ast = scavenger_expr(context, merged_ast)

    // DEBUG: trace segfault

    // Generate C code
    mut c_code := emit(merged_ast, context)

    // DEBUG: trace segfault

    // Write output file to ./gen/c/ directory instead of alongside source
    mut c_filename := path.replace(".til", ".c")
    mut output_path := c_filename
    if c_filename.starts_with("src/") {
        output_path = c_filename.replacen("src/", "gen/c/", 1)
    } else {
        output_path = concat("gen/c/", c_filename)
    }
    // Create output directory if it doesn't exist
    // Extract parent directory path (everything up to last /)
    mut last_slash := output_path.rfind("/")
    if gt(last_slash, 0) {
        mut parent_dir := output_path.get_substr(0, last_slash)
        mut mkdir_output := ""
        _ := run_cmd(mkdir_output, "mkdir", "-p", parent_dir)
    }
    _ := writefile(output_path, c_code)

    // TODO: Compile with gcc (run_cmd not available in lib mode yet)

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return c_code
}
