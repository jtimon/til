mode liba

import("core.array")
import("core.ptr")
import("self.parser")
import("core.set")
import("std.io")            // readfile
import("std.meta")          // enum_to_str

// Unix path separator (Windows not supported in TIL)
MAIN_SEPARATOR_STR := "/"

// Init phase: Declaration indexing and import processing
// This module handles the "context priming" phase that runs before type checking.
// No eval, no arena access - declarations only.
//
// Translated from src/rs/init.rs

SymbolInfo := struct {
    mut value_type: ValueType = ValueType.TFunction(FunctionType.FTFunc)
    mut is_mut: Bool = false
    mut is_copy: Bool = false
    mut is_own: Bool = false
    mut is_comptime_const: Bool = false  // true if value was comptime-evaluable at declaration

    clone := func(self: SymbolInfo) returns SymbolInfo {
        return SymbolInfo(value_type=self.value_type, is_mut=self.is_mut, is_copy=self.is_copy, is_own=self.is_own, is_comptime_const=self.is_comptime_const)
    }
}

EnumVal := struct {
    mut enum_type: Str = ""
    mut enum_name: Str = ""
    // Payload for tagged unions: stores the associated data
    // For now, supports Bool (1 byte) and I64 (8 bytes)
    mut payload: Ptr = Ptr()  // Ptr to Vec<U8>, NULL = None
    mut payload_type: Ptr = Ptr()  // Ptr to ValueType, NULL = None

    clone := func(self: EnumVal) returns EnumVal {
        return EnumVal(
            enum_type=self.enum_type,
            enum_name=self.enum_name,
            payload=self.payload,
            payload_type=self.payload_type
        )
    }
}

// Scope stack for proper lexical scoping
ScopeType := enum {
    Global,      // Top-level module scope
    Function,    // Function body
    Block,       // Generic block (if, else, loop body)
    Catch        // Catch block (for error handling)
}

ScopeFrame := struct {
    // maps variable names to their offsets in the arena
    mut arena_index: Map = Map.new(Str, I64)  // HashMap<String, usize> in Rust (stores offsets)

    // All declared symbols (types, constants, variables, and function names)
    // This is necessary for so called "context priming" or "declaration indexing"
    // aka declaring things in whatever order, aka not needing forward declarations
    // in theory it should only be needed for the "type" phase after the init context phase
    // but it can be convenient at times in eval or compile phases too, I guess.
    mut symbols: Map = Map.new(Str, SymbolInfo)

    // All functions, with their function types, signatures and bodies (functions, methods, macros, etc).
    mut funcs: Map = Map.new(Str, SFuncDef)

    // Enum type definitions (variants and associated data)
    mut enums: Map = Map.new(Str, SEnumDef)

    // Struct type definitions (fields and associated constants [including functions, structs are namespaces, almost])
    mut structs: Map = Map.new(Str, SStructDef)

    // Scope type (helps with cleanup and debugging)
    mut scope_type: ScopeType = ScopeType.Global

    clone := func(self: ScopeFrame) returns ScopeFrame throws AllocError {
        return ScopeFrame(
            arena_index=self.arena_index.clone(),
            symbols=self.symbols.clone(),
            funcs=self.funcs.clone(),
            enums=self.enums.clone(),
            structs=self.structs.clone(),
            scope_type=self.scope_type
        )
    }
}

ScopeStack := struct {
    // Stack of scope frames
    mut frames: Vec = Vec.new(ScopeFrame)


    new := func() returns ScopeStack throws Str {
        mut stack := ScopeStack()
        stack.frames = Vec.new(ScopeFrame)
        catch (err: AllocError) {
            throw err.msg
        }
        return stack
    }

    push := proc(mut self: ScopeStack, scope_type: ScopeType) throws Str {
        mut frame := ScopeFrame()
        frame.arena_index = Map.new(Str, I64)
        frame.symbols = Map.new(Str, SymbolInfo)
        frame.funcs = Map.new(Str, SFuncDef)
        frame.enums = Map.new(Str, SEnumDef)
        frame.structs = Map.new(Str, SStructDef)
        frame.scope_type = scope_type
        self.frames.push(frame)
        catch (err: AllocError) {
            throw err.msg
        }
    }

    pop := proc(mut self: ScopeStack) returns ScopeFrame throws Str, IndexOutOfBoundsError {
        if self.frames.len().lteq(1) {
            throw "Cannot pop global scope"
        }

        mut popped := ScopeFrame()
        self.frames.pop(popped)
        return popped
    }

    len := proc(self: ScopeStack) returns I64 {
        return self.frames.len()
    }

    size := func(self: ScopeStack) returns I64 {
        return self.frames.size()
    }

    // REM TODO Use this approach instead of the other workaround in files other than interpreter.til
    last_frame := func(self: ScopeStack) returns ScopeFrame throws IndexOutOfBoundsError {
        mut out := ScopeFrame()
        self.frames.get(self.frames.len().sub(1), out)
        return out
    }

    lookup_var := func(self: ScopeStack, name: Str) returns I64 throws KeyNotFoundError {
        // Walk up the stack from innermost to outermost
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            if frame.arena_index.contains_key(name) {
                mut offset := 0
                frame.arena_index.get(name, offset)
                catch (err: KeyNotFoundError) {
                    // Var not found, continue searching
                }
                return offset
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in lookup_var: ", err.msg)
        }
        throw KeyNotFoundError(msg="lookup_var: Var not found in ScopeStack")
    }

    lookup_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws KeyNotFoundError {
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            if frame.symbols.contains_key(name) {
                mut symbol := SymbolInfo()
                frame.symbols.get(name, symbol)
                catch (err: KeyNotFoundError) {
                    // Symbol not found, continue searching
                }
                return symbol
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in lookup_symbol: ", err.msg)
        }
        throw KeyNotFoundError(msg="lookup_symbol: Symbol not found in ScopeStack")
    }

    /// Bug #50: Check if accessing this symbol would require closure capture.
    /// Returns true if we're inside a nested function and the symbol is defined
    /// in an outer function scope (not global, not current function).
    is_closure_capture := func(self: ScopeStack, name: Str) returns Bool {
        mut function_boundaries_crossed := 0
        mut in_function := false

        // Walk from innermost to outermost scope
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            // Track when we enter/exit function scopes
            switch frame.scope_type {
            case ScopeType.Function:
                if in_function {
                    // We've crossed from one function into an outer function
                    function_boundaries_crossed = function_boundaries_crossed.add(1)
                } else {
                    in_function = true
                }
            case:
            }

            // Check if symbol is in this frame
            if frame.symbols.contains_key(name) {
                // Symbol found - is it a closure capture?
                // It's a capture if:
                // 1. We've crossed at least one function boundary to get here
                // 2. We're not in global scope
                switch frame.scope_type {
                case ScopeType.Global:
                    return false
                case:
                    return function_boundaries_crossed.gt(0)
                }
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in is_closure_capture: ", err.msg)
        }
        return false
    }

    declare_var := proc(mut self: ScopeStack, name: Str, offset: I64, symbol: SymbolInfo) throws Str, IndexOutOfBoundsError, AllocError, DuplicatedKeyError {
        if self.frames.len().eq(0) {
            throw "No active scope"
        }

        mut last_idx := self.frames.len().sub(1)
        mut current_frame := ScopeFrame()
        self.frames.get(last_idx, current_frame)

        // Check for redeclaration in current scope only
        // Bug #35: Skip check for "_" - it's special for discarding return values
        if not(name.eq("_")).and(current_frame.arena_index.contains_key(name)) {
            throw format("Variable '", name, "' already declared in this scope")
        }

        current_frame.arena_index.insert(name.clone(), offset.to_str())
        current_frame.symbols.insert(name, symbol)
        self.frames.set(last_idx, current_frame)
    }

    declare_symbol := proc(mut self: ScopeStack, name: Str, symbol: SymbolInfo) throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.symbols.insert(name, symbol)
            self.frames.set(last_idx, current_frame)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: DuplicatedKeyError) {
            throw err.msg
        }
    }

    remove_symbol := proc(mut self: ScopeStack, name: Str) returns Ptr throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.symbols.contains_key(name) {
                current_frame.symbols.remove(name)
                self.frames.set(last_idx, current_frame)
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found and removed
                return ptr
            }
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        return Ptr()  // NULL - not found
    }

    remove_var := proc(mut self: ScopeStack, name: Str) returns Ptr throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.arena_index.contains_key(name) {
                mut offset_str := ""
                current_frame.arena_index.get(name, offset_str)
                current_frame.arena_index.remove(name)
                self.frames.set(last_idx, current_frame)
                mut ptr := Ptr()
                ptr.data = offset_str.to_i64()
                return ptr
            }
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: KeyNotFoundError) {
            throw err.msg
        }
        return Ptr()  // NULL - not found
    }

    // Insert a variable without a corresponding symbol (simpler than declare_var)
    insert_var := proc(mut self: ScopeStack, name: Str, offset: I64) throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.arena_index.insert(name, offset.to_str())
            self.frames.set(last_idx, current_frame)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: DuplicatedKeyError) {
            throw err.msg
        }
    }

    lookup_func := func(self: ScopeStack, name: Str) returns SFuncDef throws KeyNotFoundError {
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            if frame.funcs.contains_key(name) {
                mut func_def := SFuncDef()
                frame.funcs.get(name, func_def)
                catch (err: KeyNotFoundError) {
                    // Function not found, continue searching
                }
                return func_def
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in lookup_func: ", err.msg)
        }
        throw KeyNotFoundError(msg="lookup_func: Function not found in Context")
    }

    declare_func := proc(mut self: ScopeStack, name: Str, func_def: SFuncDef) throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.funcs.insert(name, func_def)
            self.frames.set(last_idx, current_frame)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: DuplicatedKeyError) {
            throw err.msg
        }
    }

    lookup_enum := func(self: ScopeStack, name: Str) returns SEnumDef throws KeyNotFoundError {
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            if frame.enums.contains_key(name) {
                mut enum_def := SEnumDef()
                frame.enums.get(name, enum_def)
                catch (err: KeyNotFoundError) {
                    // Enum not found, continue searching
                }
                return enum_def
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in lookup_enum: ", err.msg)
        }
        throw KeyNotFoundError(msg="lookup_enum: Enum not found in ScopeStack")
    }

    declare_enum := proc(mut self: ScopeStack, name: Str, enum_def: SEnumDef) throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.enums.insert(name, enum_def)
            self.frames.set(last_idx, current_frame)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: DuplicatedKeyError) {
            throw err.msg
        }
    }

    lookup_struct := func(self: ScopeStack, name: Str) returns SStructDef throws KeyNotFoundError {
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            if frame.structs.contains_key(name) {
                mut struct_def := SStructDef()
                frame.structs.get(name, struct_def)
                catch (err: KeyNotFoundError) {
                    // Struct not found, continue searching
                }
                return struct_def
            }
        }

        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in lookup_struct: ", err.msg)
        }
        throw KeyNotFoundError(msg="lookup_struct: Struct not found in ScopeStack")
    }

    all_structs := func(self: ScopeStack) returns Vec throws Str {
        mut result := Vec.new(SStructDef)
        for i in self.frames.len().sub(1)..sub(0, 1) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)

            for struct_def: SStructDef in frame.structs.values {
                result.push(struct_def)
            }
        }

        catch (err: IndexOutOfBoundsError) {
            throw loc().concat("IndexOutOfBoundsError in all_structs: ").concat(err.msg)
        }
        catch (err: AllocError) {
            throw loc().concat("AllocError in all_structs: ").concat(err.msg)
        }
        return result
    }

    declare_struct := proc(mut self: ScopeStack, name: Str, struct_def: SStructDef) throws Str {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.structs.insert(name, struct_def)
            self.frames.set(last_idx, current_frame)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: DuplicatedKeyError) {
            throw err.msg
        }
    }

    get_symbols_with_prefix := func(self: ScopeStack, prefix: Str) returns Vec throws Str {
        // Collect all keys from all scopes that start with the given prefix
        mut keys := Vec.new(Str)
        mut prefix_len := prefix.len()
        for frame: ScopeFrame in self.frames {
            for key: Str in frame.symbols.keys {
                // Check if key starts with prefix
                if key.len().gteq(prefix_len) {
                    mut matches := true
                    mut k := 0
                    while k.lt(prefix_len) {
                        mut key_char := get_char(key, k)
                        mut prefix_char := get_char(prefix, k)
                        if not(key_char.eq(prefix_char)) {
                            matches = false
                        }
                        k.inc()
                    }
                    if matches {
                        keys.push(key.clone())
                    }
                }
            }
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        return keys
    }

    get_all_struct_names := func(self: ScopeStack) returns Vec throws Str {
        mut names := Vec.new(Str)
        for frame: ScopeFrame in self.frames {
            for key: Str in frame.structs.keys {
                names.push(key.clone())
            }
        }
        catch (err: AllocError) {
            throw err.msg
        }
        return names
    }

    clone := func(self: ScopeStack) returns ScopeStack throws AllocError {
        return ScopeStack(frames=self.frames.clone())
    }
}

get_func_name_in_call := func(e: Expr) returns Str throws Str {
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw "get_func_name_in_call(): expected fcall node."
    }
    if e.params.len().eq(0) {
        throw "get_func_name_in_call(): fcall nodes must have at least 1 parameter."
    }
    mut param := e.get(0)
    // e.get throws Str on error, will propagate
    mut func_name := ""
    switch param.node_type {
    case NodeType.Identifier(f_name):
        func_name = f_name.clone()
    case:
        mut param_node_type_str := enum_to_str(param.node_type)
        throw format("in get_func_name_in_call(): Identifiers can only contain identifiers, found '", param_node_type_str, "'")
    }
    catch (err: AllocError) { throw concat("get_func_name_in_call: ", err.msg) }
    return func_name
}

value_type_func_proc := func(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str {
    mut returns_len := func_def.return_types.len()
    if returns_len.eq(0) {
        throw e.error(path, "init", format("func '", name, "' does not return anything"))
    }
    if returns_len.eq(1) {
        mut return_type := ValueType.TCustom("")  # Dummy init, will be overwritten by get()
        func_def.return_types.get(0, return_type)
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        switch return_type {
        case ValueType.TCustom(custom_type_str):
            return return_type
        case:
            throw e.error(path, "init", format("func '", name, "' returns unsupported type ", value_type_to_str(return_type)))
        }
    }
    throw e.todo_error(path, "init", format("func '", name, "' returns multiple values"))
}

get_ufcs_fcall_value_type := func(context: Context, e: Expr, f_name: Str, id_expr: Expr, symbol: SymbolInfo) returns ValueType throws Str {
    if id_expr.params.len().eq(0) {
        throw e.error(context.path, "init", format("Cannot call '", f_name, "', it is not a function or struct, it is a '", value_type_to_str(symbol.value_type), "'"))
    }

    // Get the last param (the method name)
    mut last_idx := id_expr.params.len().sub(1)
    mut method_name_expr := Expr()
    id_expr.params.get(last_idx, method_name_expr)

    mut method_name := ""
    switch method_name_expr.node_type {
    case NodeType.Identifier(name):
        method_name = name
    case:
        mut node_type_str := enum_to_str(method_name_expr.node_type)
        throw e.error(context.path, "init", format("Expected identifier for method name, found '", node_type_str, "'"))
    }

    // Check if it's a regular function
    mut found_func := false
    mut func_def := SFuncDef()
    func_def = context.scope_stack.lookup_func(method_name)
    found_func = true
    catch (err: KeyNotFoundError) {
        // Not found, continue to check other options
    }
    if found_func {
        return value_type_func_proc(context.path, e, f_name, func_def)
    }

    // Create identifier expression without the last param (method name) to get the type
    mut id_without_method := id_expr.clone()
    mut new_len := id_without_method.params.len().sub(1)
    id_without_method.params._len = new_len

    // Get the type of the nested identifier
    mut target_type := get_value_type(context, id_without_method)

    // Check if it's an associated function for this type
    switch target_type {
    case ValueType.TCustom(custom_type_name):
        mut id_expr_name := format(custom_type_name, ".", method_name)
        mut found_method := false
        mut method_def := SFuncDef()
        method_def = context.scope_stack.lookup_func(id_expr_name)
        found_method = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if found_method {
            return value_type_func_proc(context.path, e, id_expr_name, method_def)
        }
        throw e.error(context.path, "init", format("Type '", custom_type_name, "' has no method '", method_name, "'"))
    case:
        throw e.error(context.path, "init", format("'", f_name, "' of type '", value_type_to_str(target_type), "' doesn't support methods"))
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
}

get_fcall_value_type := func(context: Context, e: Expr) returns ValueType throws Str {

    mut f_name := get_func_name_in_call(e)

    // Check if this is a UFCS call on a function/expression result
    // If e has 2+ params (func name + target + args), check if the target's type
    // has an associated method with this name, prioritizing it over standalone functions
    if e.params.len().gteq(2) {
        mut first_arg := e.get(1)  // Get the UFCS target (skip func name at index 0)

        // Try to get the type of the first argument
        mut target_type := get_value_type(context, first_arg)
        catch (err: Str) {
            // Couldn't determine type, fall through
        }

        switch target_type {
        case ValueType.TCustom(custom_type_name):
            // Check if this type has an associated method with this name
            mut method_name := format(custom_type_name, ".", f_name)
            mut found_method := false
            mut method_func_def := SFuncDef()
            method_func_def = context.scope_stack.lookup_func(method_name)
            found_method = true
            catch (err: KeyNotFoundError) {
                // Not found, fall through
            }
            if found_method {
                // UFCS method exists! Use it instead of standalone function
                return value_type_func_proc(context.path, e, method_name, method_func_def)
            }
        case:
            // Not TCustom or no method, fall through
        }
        catch (err: I64_OverflowError) {
            throw err.msg
        }
        // If we couldn't determine type or no associated method exists, fall through
    }

    // Original logic: check for standalone function
    mut found_standalone := false
    mut standalone_func_def := SFuncDef()
    standalone_func_def = context.scope_stack.lookup_func(f_name)
    found_standalone = true
    catch (err: KeyNotFoundError) {
        // Not a standalone function
    }
    if found_standalone {
        return value_type_func_proc(context.path, e, f_name, standalone_func_def)
    }

    // Not a standalone function, check if it's a symbol (type, enum, struct, etc)
    mut symbol := context.scope_stack.lookup_symbol(f_name)
    catch (err: KeyNotFoundError) {
        throw e.error(context.path, "init", format("Undefined symbol '", f_name, "'"))
    }
    mut id_expr := e.get(0)

    switch symbol.value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        // Handle struct constructor or struct method calls
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(f_name)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(context.path, "init", format("struct '", f_name, "' not found in context"))
        }

        // Check if there's a member access after the struct name
        if id_expr.params.len().eq(0) {
            // Constructor: MyStruct() or MyStruct(field=value, ...)
            // Check that all args are NamedArg (struct literals require named args)
            if e.params.len().gt(1) {
                mut arg_idx := 1
                while arg_idx.lt(e.params.len()) {
                    mut arg := Expr()
                    e.params.get(arg_idx, arg)
                    switch arg.node_type {
                    case NodeType.NamedArg(_):
                        // OK - named arg is allowed
                    case:
                        throw arg.error(context.path, "init", format(
                            "Struct literal '", f_name, "' requires named arguments (e.g., ", f_name, "(x=10, y=20)). Positional arguments are not allowed."))
                    }
                    arg_idx.inc()
                }
            }
            // Just "StructName()" or "StructName(field=value, ...)" - constructor call
            return ValueType.TCustom(f_name.clone())
        }

        mut after_dot := Expr()  # Default init, will be overwritten by get()
        id_expr.params.get(0, after_dot)
        switch after_dot.node_type {
        case NodeType.Identifier(after_dot_name):
            // Inline get_member_or_err logic
            mut member_decl := Declaration()
            mut member_idx := 0
            mut found_member := false
            while member_idx.lt(struct_def.members.len()) {
                mut temp_member := Declaration()
                struct_def.members.get(member_idx, temp_member)
                if Str.eq(temp_member.name, after_dot_name) {
                    member_decl = temp_member
                    found_member = true
                }
                member_idx.inc()
            }
            if not(found_member) {
                throw e.error(context.path, "init", format("Struct '", f_name, "' has no member '", after_dot_name, "'"))
            }
            mut member_default_value := Expr()  # Default init, will be overwritten by get()
            struct_def.default_values.get(after_dot_name, member_default_value)
            catch (key_err: KeyNotFoundError) {
                throw e.error(context.path, "init", format("Struct '", f_name, "' has no default value for '", after_dot_name, "'"))
            }

            switch member_default_value.node_type {
            case NodeType.FuncDef(func_def):
                mut combined_name := format(f_name, ".", after_dot_name)
                return value_type_func_proc(context.path, e, combined_name, func_def)
            case:
                throw e.error(context.path, "init", format("Cannot call '", f_name, ".", after_dot_name, "', it is not a function, it is '", value_type_to_str(member_decl.value_type), "'"))
            }
        case:
            throw e.lang_error(context.path, "init", format("Expected identifier after '", f_name, ".' found '", enum_to_str(after_dot.node_type), "'"))
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }


    case ValueType.TType(TTypeDef.TEnumDef):
        // Handle enum constructor calls like Color.Green(true)
        mut enum_def := SEnumDef()
        enum_def = context.scope_stack.lookup_enum(f_name)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(context.path, "init", format("enum '", f_name, "' not found in context"))
        }

        // Check if there's a member access (variant) after the enum name
        if id_expr.params.len().eq(0) {
            // Just referencing the enum type itself, not constructing
            return ValueType.TType(TTypeDef.TEnumDef)
        }

        mut after_dot := Expr()  # Default init, will be overwritten by get()
        id_expr.params.get(0, after_dot)
        switch after_dot.node_type {
        case NodeType.Identifier(variant_name):
            // Check if this variant exists in the enum (will throw KeyNotFoundError if not)
            mut payload_ptr := enum_def.get(variant_name)  // Bug #38 fix: use helper method

            // Check if variant has a payload (NULL means no payload)
            if not(NULL.eq(payload_ptr.data)) {
                mut payload_type := ValueType.TCustom("")
                memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                switch payload_type {
                case ValueType.TCustom(payload_type_name):
                    // This variant expects a payload
                    if e.params.len().lt(2) {
                        throw e.error(context.path, "init", format("Enum constructor ", f_name, ".", variant_name, " expects a payload of type '", payload_type_name, "'"))
                    }
                    // Type check the payload argument
                    mut payload_expr := e.get(1)
                    mut payload_actual_type := get_value_type(context, payload_expr)

                    // TODO: Verify payload type matches expected type
                    // For now, we just accept any payload
                case:
                    // Non-TCustom payload types are not currently supported
                    throw e.todo_error(context.path, "init", format("Enum variant payload type '", value_type_to_str(payload_type), "' not yet supported"))
                }
            } else {
                // This variant doesn't have a payload (NULL means None)
                if e.params.len().gt(1) {
                    throw e.error(context.path, "init", format("Enum variant ", f_name, ".", variant_name, " does not take a payload"))
                }
            }

            // Return the enum type
            return ValueType.TCustom(f_name.clone())
        case:
            throw e.lang_error(context.path, "init", format("Expected identifier after '", f_name, ".' found '", enum_to_str(after_dot.node_type), "'"))
        }
    case ValueType.TCustom(custom_type_name):
            # Check if it's an enum first
            mut found_enum := false
            mut enum_def := SEnumDef()
            enum_def = context.scope_stack.lookup_enum(custom_type_name)
            found_enum = true
            catch (err: KeyNotFoundError) {
                // Not an enum
            }
            if found_enum {
                # It's an enum - try UFCS method call
                mut enum_after_dot := Expr()
                if id_expr.params.len().eq(0) {
                    return ValueType.TCustom(f_name.clone())
                }
                id_expr.params.get(0, enum_after_dot)

                switch enum_after_dot.node_type {
                case NodeType.Identifier(enum_after_dot_name):
                    # Try associated method first
                    mut method_name := format(custom_type_name, ".", enum_after_dot_name)
                    mut found_method := false
                    mut method_func := SFuncDef()
                    method_func = context.scope_stack.lookup_func(method_name)
                    found_method = true
                    catch (method_err: KeyNotFoundError) {
                        // Method not found
                    }
                    if found_method {
                        return value_type_func_proc(context.path, e, method_name, method_func)
                    }

                    # Fall back to UFCS: try standalone function with enum as first arg
                    mut found_ufcs := false
                    mut ufcs_result := ValueType.TCustom("")  // dummy default
                    ufcs_result = get_ufcs_fcall_value_type(context, e, f_name, id_expr, symbol)
                    found_ufcs = true
                    catch (err: Str) {
                        throw e.error(context.path, "init", format("enum '", custom_type_name, "' has no method '", enum_after_dot_name, "' and no matching function found for UFCS"))
                    }
                    if found_ufcs {
                        return ufcs_result
                    }

                case:
                    throw e.lang_error(context.path, "init", format("Expected identifier after '", f_name, ".' found '", enum_to_str(enum_after_dot.node_type), "'"))
                }
            }

            # Not an enum, try struct
            mut struct_def := context.scope_stack.lookup_struct(custom_type_name)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "init", format("type '", f_name, "' not found in context"))
            }

            mut after_dot := Expr()
            if id_expr.params.len().eq(0) {
                return ValueType.TCustom(f_name.clone())
            }
            id_expr.params.get(0, after_dot)

            switch after_dot.node_type {
            case NodeType.Identifier(after_dot_name):
                # Bug #10 fix: Check if we have a multi-level chain like struct.field.method
                # If id_expr.params has 2+ elements, try to resolve all-but-last as field access
                if id_expr.params.len().gteq(2) {
                    # Try to resolve the field access chain (all params except the last)
                    # Example: for e.params.len, resolve "e.params" to get its type
                    mut field_access_expr := id_expr.clone()
                    # Remove the last element (method/property name)
                    mut new_len := field_access_expr.params.len().sub(1)
                    field_access_expr.params._len = new_len

                    mut got_intermediate := false
                    mut intermediate_type := ValueType.TCustom("")  # dummy default
                    intermediate_type = get_value_type(context, field_access_expr)
                    got_intermediate = true
                    catch (err: Str) {
                        # Failed to resolve intermediate - just fall through to normal logic
                    }

                    if got_intermediate {
                        # Successfully resolved intermediate field access
                        # Now check if the last param is a member/method of that type
                        mut last_param := Expr()
                        id_expr.params.get(id_expr.params.len().sub(1), last_param)

                        switch last_param.node_type {
                        case NodeType.Identifier(final_member_name):
                            switch intermediate_type {
                            case ValueType.TCustom(intermediate_type_name):
                                # First check if it's a method on this type
                                mut method_name := format(intermediate_type_name, ".", final_member_name)
                                mut found_intermediate_method := false
                                mut intermediate_method_def := SFuncDef()
                                intermediate_method_def = context.scope_stack.lookup_func(method_name)
                                found_intermediate_method = true
                                catch (method_err: KeyNotFoundError) {
                                    // Method not found
                                }
                                if found_intermediate_method {
                                    return value_type_func_proc(context.path, e, method_name, intermediate_method_def)
                                }

                                # Try UFCS: standalone function with intermediate type as first arg
                                mut found_standalone := false
                                mut standalone_def := SFuncDef()
                                standalone_def = context.scope_stack.lookup_func(final_member_name)
                                found_standalone = true
                                catch (standalone_err: KeyNotFoundError) {
                                    // Standalone not found
                                }
                                if found_standalone {
                                    return value_type_func_proc(context.path, e, final_member_name, standalone_def)
                                }

                                # Check if it's a struct with this member as a field
                                mut found_intermediate_struct := false
                                mut intermediate_struct_def := SStructDef()
                                intermediate_struct_def = context.scope_stack.lookup_struct(intermediate_type_name)
                                found_intermediate_struct = true
                                catch (struct_err: KeyNotFoundError) {
                                    // Struct not found
                                }
                                if found_intermediate_struct {
                                    mut found_member := false
                                    mut member_decl := Declaration()
                                    member_decl = SStructDef.get_member(intermediate_struct_def, final_member_name)
                                    found_member = true
                                    catch (member_err: Str) {
                                        // Member not found
                                    }
                                    if found_member {
                                        # It's a field access - return the field's type
                                        return value_type_clone(member_decl.value_type)
                                    }
                                }
                            case:
                                # Intermediate type is not a custom type, fall through
                            }
                        case:
                            # Last param is not an identifier, fall through
                        }
                    }
                }

                # Original logic: single-level access (struct.member)
                mut member_decl := SStructDef.get_member(struct_def, after_dot_name)
                catch (err: Str) {
                    // member not found, try UFCS
                    mut ufcs_result := get_ufcs_fcall_value_type(context, e, f_name, id_expr, symbol)
                    catch (ufcs_err: Str) {
                        throw e.error(context.path, "init", format("struct '", custom_type_name, "' has no member '", after_dot_name, "'"))
                    }
                    return ufcs_result
                }

                mut member_default_value := Expr()  # Default init, will be overwritten by get()
                struct_def.default_values.get(after_dot_name, member_default_value)
                catch (key_err: KeyNotFoundError) {
                    throw e.error(context.path, "init", format("struct '", custom_type_name, "' has no default value for '", after_dot_name, "'"))
                }

                switch member_default_value.node_type {
                case NodeType.FuncDef(func_def):
                    mut combined_name := format(custom_type_name, ".", after_dot_name)
                    return value_type_func_proc(context.path, e, combined_name, func_def)
                case:
                    throw e.error(context.path, "init", format("Cannot call '", f_name, ".", after_dot_name, "', it is not a function, it is '", value_type_to_str(member_decl.value_type), "'"))
                }

            case:
                throw e.lang_error(context.path, "init", format("Expected identifier after '", f_name, ".' found '", enum_to_str(after_dot.node_type), "'"))
            }
        case ValueType.TMulti(_):
            # Variadic parameters are implemented as Array at runtime
            # Treat them as Array for type checking method calls
            mut custom_type_name := "Array"
            mut struct_def := context.scope_stack.lookup_struct(custom_type_name)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "init", format("struct '", custom_type_name, "' not found in context"))
            }

            mut variadic_after_dot := Expr()
            if id_expr.params.len().eq(0) {
                return ValueType.TCustom(custom_type_name)
            }
            id_expr.params.get(0, variadic_after_dot)

            switch variadic_after_dot.node_type {
            case NodeType.Identifier(variadic_after_dot_name):
                mut member_decl := SStructDef.get_member(struct_def, variadic_after_dot_name)
                catch (err: Str) {
                    // member not found, try UFCS
                    mut ufcs_result := get_ufcs_fcall_value_type(context, e, f_name, id_expr, symbol)
                    catch (ufcs_err: Str) {
                        throw e.error(context.path, "init", format("struct '", custom_type_name, "' has no member '", variadic_after_dot_name, "' (variadic)"))
                    }
                    return ufcs_result
                }

                mut member_default_value := Expr()  # Default init, will be overwritten by get()
                struct_def.default_values.get(variadic_after_dot_name, member_default_value)
                catch (key_err: KeyNotFoundError) {
                    throw e.error(context.path, "init", format("struct '", custom_type_name, "' has no default value for '", variadic_after_dot_name, "' (variadic)"))
                }

                switch member_default_value.node_type {
                case NodeType.FuncDef(func_def):
                    mut combined_name := format(custom_type_name, ".", variadic_after_dot_name)
                    return value_type_func_proc(context.path, e, combined_name, func_def)
                case:
                    throw e.error(context.path, "init", format("Cannot call '", custom_type_name, ".", variadic_after_dot_name, "', it is not a function, it is '", value_type_to_str(member_decl.value_type), "'"))
                }

            case:
                throw e.lang_error(context.path, "init", format("Expected identifier after '", f_name, ".' found '", enum_to_str(variadic_after_dot.node_type), "'"))
            }
        case:
            return get_ufcs_fcall_value_type(context, e, f_name, id_expr, symbol)
        }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
    throw e.error(context.path, "init", format("Undefined symbol '", f_name, "'"))
}

get_value_type := func(context: Context, e: Expr) returns ValueType throws Str {
    switch e.node_type {
    case NodeType.LLiteral(literal):
        switch literal {
        case Literal.Number(num_val):
            return ValueType.TCustom("I64")
        case Literal.Str(str_val):
            return ValueType.TCustom("Str")
        case Literal.List(list_val):
            return ValueType.TCustom("List")
        case:
            throw e.error(context.path, "init", format("Unsupported literal type '", enum_to_str(literal), "'"))
        }
    case NodeType.FuncDef(func_def):
        switch func_def.function_type {
        case FunctionType.FTFunc:
            return ValueType.TFunction(FunctionType.FTFunc)
        case FunctionType.FTFuncExt:
            return ValueType.TFunction(FunctionType.FTFunc)
        case FunctionType.FTProc:
            return ValueType.TFunction(FunctionType.FTProc)
        case FunctionType.FTProcExt:
            return ValueType.TFunction(FunctionType.FTProc)
        case FunctionType.FTMacro:
            return ValueType.TFunction(FunctionType.FTMacro)
        }
    case NodeType.EnumDef(_):
        return ValueType.TType(TTypeDef.TEnumDef)
    case NodeType.StructDef(_):
        return ValueType.TType(TTypeDef.TStructDef)
    case NodeType.FCall:
        return get_fcall_value_type(context, e)
    case NodeType.Range:
        mut range_elem_type := get_value_type(context, e.get(0))
        return ValueType.TCustom(format(value_type_to_str(range_elem_type), "Range"))

    case NodeType.Identifier(name):
        // Bug #32 fix: Handle field access on expression results
        // When name is "_" and params[0] is an FCall, get the type of that expression first,
        // then traverse the field access chain in params[1..]
        if name.eq("_") {
            if e.params.len().gt(0) {
                // Get the type of the base expression (params[0])
                base_expr := e.get(0)
                mut current_type := get_value_type(context, base_expr)

                // Traverse the field access chain in params[1..]
                for i in 1..e.params.len() {
                    field_expr := e.get(i)
                    mut field_name := ""
                    switch field_expr.node_type {
                    case NodeType.Identifier(n):
                        field_name = n
                    case:
                        throw e.error(context.path, "init", "Expected identifier in field access chain")
                    }

                    switch current_type {
                    case ValueType.TCustom(type_name):
                        mut struct_def := context.scope_stack.lookup_struct(type_name)
                        catch (err: KeyNotFoundError) {
                            throw e.error(context.path, "init", format("'", type_name, "' is not a struct"))
                        }
                        mut member := SStructDef.get_member_or_err(struct_def, field_name, type_name, context.path, e)
                        current_type = value_type_clone(member.value_type)
                    case:
                        throw e.error(context.path, "init", format("Cannot access fields on type '", value_type_to_str(current_type), "'"))
                    }
                }

                return current_type
            }
        }

        mut symbol := context.scope_stack.lookup_symbol(name)
        catch (err: KeyNotFoundError) {
            throw e.error(context.path, "init", format("Undefined symbol '", name, "'"))
        }
        mut current_type := value_type_clone(symbol.value_type)

        # If there are no parameters, just return the type of the first identifier
        if e.params.len().eq(0) {
            return current_type
        }

        # Now, process each nested member.
        for cursor: Expr in e.params {
            mut member_name := ""
            switch cursor.node_type {
            case NodeType.Identifier(n):
                member_name = n
            case:
                throw e.lang_error(context.path, "init", format("Identifiers can only contain identifiers, found '", enum_to_str(cursor.node_type), "'"))
            }

            switch current_type {
            case ValueType.TType(TTypeDef.TStructDef):
                # If it's a struct, resolve its member
                mut struct_def := context.scope_stack.lookup_struct(name)
                catch (err: KeyNotFoundError) {
                    throw e.error(context.path, "init", format("Struct '", name, "' not found"))
                }
                mut decl := SStructDef.get_member_or_err(struct_def, member_name, name, context.path, e)
                current_type = value_type_clone(decl.value_type)

            case ValueType.TType(TTypeDef.TEnumDef):
                # If it's an enum, resolve the variant
                mut enum_def := context.scope_stack.lookup_enum(name)
                catch (err: KeyNotFoundError) {
                    throw e.error(context.path, "init", format("Enum '", name, "' not found"))
                }
                if enum_def.contains_key(member_name) {  // Bug #38 fix: use helper method
                    return ValueType.TCustom(name)
                }
                throw e.error(context.path, "init", format("Enum '", name, "' has no value '", member_name, "'"))

            case ValueType.TCustom(custom_type_name):
                # If it's a custom type (a struct), resolve the member
                mut struct_def := context.scope_stack.lookup_struct(custom_type_name)
                catch (err: KeyNotFoundError) {
                    throw e.error(context.path, "init", format("Struct '", custom_type_name, "' not found"))
                }
                mut decl := SStructDef.get_member_or_err(struct_def, member_name, custom_type_name, context.path, e)
                current_type = value_type_clone(decl.value_type)

            case ValueType.TMulti(_variadic_type_name):
                # Variadic parameters are implemented as Array at runtime
                current_type = ValueType.TCustom("Array")

            case:
                throw e.error(context.path, "init", format("'", name, "' of type '", value_type_to_str(current_type), "' can't have members"))
            }
        }

        return current_type  # Return the type of the last field (x)

    case NodeType.Pattern(pattern_info):
        # Extract enum type from "EnumType.Variant" format
        mut variant_name := pattern_info.variant_name
        mut dot_pos := Str.rfind(variant_name, ".")
        if dot_pos.gteq(0) {
            mut enum_type := get_substr(variant_name, 0, dot_pos)
            return ValueType.TCustom(enum_type)
        }
        # If no dot, assume the whole thing is the enum type (shouldn't happen in practice)
        return ValueType.TCustom(variant_name.clone())

    case NodeType.NamedArg(_):
        if e.params.len().gt(0) {
            return get_value_type(context, e.get(0))
        }
        throw e.error(context.path, "init", "NamedArg must have a value expression")

    case:
        throw e.error(context.path, "init", format("get_value_type() not implemented for '", enum_to_str(e.node_type), "' yet."))
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
}

# Convert dot-based import path to OS-specific file path
# Example: "std.io" -> "src/std/io.til" (Unix) or "src\std\io.til" (Windows)
# Auto-prefixes with "src."
import_path_to_file_path := func(import_path: Str) returns Str throws Str {
    mut full_path := format("src.", import_path)
    mut file_path := full_path.replace(".", MAIN_SEPARATOR_STR)
    mut result := format(file_path, ".til")
    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return result
}

# Import declarations only (no eval) - for init phase
# This processes imports during declaration indexing, copying only declarations
# to the parent context. The typer and eval phases will use the stored AST.
init_import_declarations := proc(mut context: Context, e: Expr, import_path_str: Str) throws Str {
    mut path := import_path_to_file_path(import_path_str)
    mut original_path := context.path.clone()

    # Already done (or in progress)? Skip.
    # Adding to done at START handles both circular imports and re-imports.
    if context.imports_init_done.contains(path) {
        return
    }

    # Mark as done immediately - before processing - to handle circular imports
    _ := context.imports_init_done.insert(path.clone())

    # Read and parse the imported file
    mut source := readfile(path)
    catch (err: Str) {
        throw e.error(context.path, "import", format("File '", path, "' not found or could not be read: ", err))
    }

    context.path = path.clone()

    # Lex the imported file
    mut lexer := lexer_from_source(path, source)
    catch (err: Str) {
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("While trying to import ", path, " from ", original_path, ":\n", err))
    }
    catch (err: IndexOutOfBoundsError) {
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("While trying to import ", path, " from ", original_path, ":\n", err.msg))
    }

    # Parse mode
    mut parsed_mode := parse_mode(path, lexer)
    catch (err: Str) {
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("While trying to import ", path, " from ", original_path, ":\n", err))
    }

    # Check if mode can be imported
    if not(can_be_imported(parsed_mode)) {
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("file '", path, "' of mode '", parsed_mode.name, "' cannot be imported"))
    }

    mut previous_mode := context.mode_def.clone()
    context.mode_def = parsed_mode

    # Process mode imports recursively
    mut import_idx := 0
    while import_idx.lt(context.mode_def.imports.len()) {
        mut import_str := ""  # Default init, will be overwritten by get()
        context.mode_def.imports.get(import_idx, import_str)
        import_func_name_expr := Expr(node_type=NodeType.Identifier("import"), line=0, col=0)
        import_path_expr := Expr(node_type=NodeType.LLiteral(Literal.Str(import_str)), line=0, col=0)
        mut import_fcall_expr := Expr(node_type=NodeType.FCall, line=0, col=0)
        import_fcall_expr.params.push(import_func_name_expr)
        import_fcall_expr.params.push(import_path_expr)

        init_import_declarations(context, import_fcall_expr, import_str)
        catch (err: Str) {
            context.mode_def = previous_mode
            context.path = original_path.clone()
            throw err
        }

        import_idx.inc()
    }

    # Parse to AST
    mut imported_ast := parse_tokens(lexer)
    catch (err: Str) {
        context.mode_def = previous_mode
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("While trying to import ", path, " from ", original_path, ":\n", err))
    }
    catch (err: IndexOutOfBoundsError) {
        context.mode_def = previous_mode
        context.path = original_path.clone()
        throw e.error(context.path, "import", format("While trying to import ", path, " from ", original_path, ":\n", err.msg))
    }

    # Run init_context to extract declarations
    # This will recursively handle any imports in the imported file
    mut errors := init_context(context, imported_ast)
    if errors.len().gt(0) {
        context.mode_def = previous_mode
        mut orig_path_clone := original_path.clone()
        context.path = original_path.clone()
        mut error_msg := format("While trying to import ", path, " from ", orig_path_clone, ":\n")
        for err: Str in errors {
            error_msg = format(error_msg, path, ":", err, "\n")
        }
        throw error_msg
    }

    # Store AST and mode for typer and eval phases
    Map.insert(context.imported_asts, path.clone(), imported_ast)
    Map.insert(context.imported_modes, path.clone(), context.mode_def.clone())

    # Restore context state
    context.mode_def = previous_mode
    context.path = original_path.clone()

    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
    catch (err: DuplicatedKeyError) {
        throw err.msg
    }
}

// Context priming / declaration indexing
// Process AST and register all declarations (funcs, enums, structs, vars)
// Returns array of error strings (empty if success)
// Corresponds to init_context in init.rs
init_context := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)

    switch e.node_type {
    case NodeType.Body:
        for se: Expr in e.params {
            mut sub_errors := init_context(context, se)
            for sub_err: Str in sub_errors {
                errors.push(sub_err)
            }
        }

    case NodeType.FCall:
        mut f_name := get_func_name_in_call(e)
        if f_name.eq("import") {
            # Extract import path (must be literal string)
            mut import_path_expr := e.get(1)
            catch (err: Str) {
                errors.push(e.lang_error(context.path, "import", format(context.path, ":", err)))
                return errors
            }

            mut import_path := ""
            mut import_node_type := import_path_expr.node_type
            switch import_node_type {
            case NodeType.LLiteral(import_path_str_lit_expr):
                mut literal_type := import_path_str_lit_expr
                switch literal_type {
                case Literal.Str(import_path_):
                    import_path = import_path_
                case:
                    errors.push(import_path_expr.lang_error(context.path, "import", format("Expected literal 'Str' for import, found literal '", enum_to_str(literal_type), "'")))
                    return errors
                }
            case:
                errors.push(import_path_expr.lang_error(context.path, "import", format("Expected literal Str for import, found '", enum_to_str(import_node_type), "'")))
                return errors
            }

            # Process import declarations (no eval)
            init_import_declarations(context, e, import_path)
            catch (err: Str) {
                errors.push(err)
                return errors
            }
        }

    case NodeType.Declaration(decl):
        // Check if already declared as func
        mut found_as_func := false
        mut existing_func := SFuncDef()
        existing_func = context.scope_stack.lookup_func(decl.name)
        found_as_func = true
        catch (err: KeyNotFoundError) {
            found_as_func = false
        }
        // Check if already declared as symbol
        mut found_as_symbol := false
        mut existing_symbol := SymbolInfo()
        existing_symbol = context.scope_stack.lookup_symbol(decl.name)
        found_as_symbol = true
        catch (err: KeyNotFoundError) {
            found_as_symbol = false
        }
        // Bug #35: Skip "already declared" check for "_" - it's special for discarding return values
        if not(decl.name.eq("_")).and(found_as_func.or(found_as_symbol)) {
            errors.push(e.error(context.path, "init", format("'", decl.name, "' already declared.")))
        }
        if not(e.params.len().eq(1)) {
            errors.push(e.lang_error(context.path, "init", format("in init_context, while declaring ", decl.name, ", declarations must take exactly one value.")))
            return errors
        }
        mut inner_e := e.get(0)
        catch (err: Str) {
            errors.push(err)
            return errors
        }

        mut value_type := get_value_type(context, inner_e)
        catch (err: Str) {
            errors.push(err)
            return errors
        }

        // Check if declared type differs from inferred type
        // INFER_TYPE is "auto" - used with TCustom
        mut is_infer_type := false
        switch decl.value_type {
        case ValueType.TCustom(type_str):
            if type_str.eq(INFER_TYPE) {
                is_infer_type = true
            }
        case:
            // Not custom/infer type
        }
        if not(is_infer_type) {
            // Check for U8/I64 coercion
            mut is_u8_i64_coercion := false
            switch decl.value_type {
            case ValueType.TCustom(dt):
                if dt.eq("U8") {
                    switch value_type {
                    case ValueType.TCustom(vt):
                        if vt.eq("I64") {
                            is_u8_i64_coercion = true
                        }
                    case:
                        // Not custom type
                    }
                }
            case:
                // Not custom type
            }
            if is_u8_i64_coercion {
                value_type = value_type_clone(decl.value_type)
            } else {
                // Check type mismatch using string comparison
                mut decl_vt_str := enum_to_str(decl.value_type)
                mut value_vt_str := enum_to_str(value_type)
                if not(value_vt_str.eq(decl_vt_str)) {
                    errors.push(e.error(context.path, "init", format("'", decl.name, "' declared of type '", value_type_to_str(decl.value_type), "' but initialized to type '", value_type_to_str(value_type), "'.")))
                }
            }
        }

        switch value_type {
        case ValueType.TFunction(ftype):
            switch ftype {
            case FunctionType.FTFunc:
                switch inner_e.node_type {
                case NodeType.FuncDef(func_def):
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                    context.scope_stack.declare_func(decl.name, func_def.clone())
                case:
                    errors.push(e.lang_error(context.path, "init", format(value_type_to_str(value_type), "s should have definitions")))
                    return errors
                }
            case FunctionType.FTFuncExt:
                switch inner_e.node_type {
                case NodeType.FuncDef(func_def):
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                    context.scope_stack.declare_func(decl.name, func_def.clone())
                case:
                    errors.push(e.lang_error(context.path, "init", format(value_type_to_str(value_type), "s should have definitions")))
                    return errors
                }
            case FunctionType.FTProc:
                switch inner_e.node_type {
                case NodeType.FuncDef(func_def):
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                    context.scope_stack.declare_func(decl.name, func_def.clone())
                case:
                    errors.push(e.lang_error(context.path, "init", format(value_type_to_str(value_type), "s should have definitions")))
                    return errors
                }
            case FunctionType.FTProcExt:
                switch inner_e.node_type {
                case NodeType.FuncDef(func_def):
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                    context.scope_stack.declare_func(decl.name, func_def.clone())
                case:
                    errors.push(e.lang_error(context.path, "init", format(value_type_to_str(value_type), "s should have definitions")))
                    return errors
                }
            case FunctionType.FTMacro:
                switch inner_e.node_type {
                case NodeType.FuncDef(func_def):
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                    context.scope_stack.declare_func(decl.name, func_def.clone())
                case:
                    errors.push(e.lang_error(context.path, "init", format(value_type_to_str(value_type), "s should have definitions")))
                    return errors
                }
            }

        case ValueType.TType(TTypeDef.TEnumDef):
            if not(inner_e.params.len().eq(0)) {
                errors.push(e.lang_error(context.path, "init", format("while declaring ", decl.name, ": enum declarations don't have any parameters in the tree.")))
                return errors
            }
            switch inner_e.node_type {
            case NodeType.EnumDef(enum_def):
                context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                context.scope_stack.declare_enum(decl.name, enum_def.clone())
            case:
                errors.push(e.lang_error(context.path, "init", "enums should have definitions."))
                return errors
            }

        case ValueType.TType(TTypeDef.TStructDef):
            if not(inner_e.params.len().eq(0)) {
                errors.push(e.lang_error(context.path, "init", format("while declaring ", decl.name, ", struct declarations must have exactly 0 params.")))
                return errors
            }
            switch inner_e.node_type {
            case NodeType.StructDef(struct_def):
                # Register the struct itself
                context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
                context.scope_stack.declare_struct(decl.name, struct_def.clone())
                # Register associated funcs and constants (non-mut members only)
                for member_decl: Declaration in struct_def.members {
                    if not(member_decl.is_mut) {
                        # Skip instance fields - only process non-mut fields
                        # Try to find a default_value (required for funcs/consts)
                        mut has_default_value := false
                        mut member_expr := Expr()
                        struct_def.default_values.get(member_decl.name, member_expr)
                        has_default_value = true
                        catch (key_err: KeyNotFoundError) {
                            # No default value, skip this member
                        }
                        if has_default_value {
                            mut member_value_type := ValueType.TCustom(INFER_TYPE)
                            member_value_type = get_value_type(context, member_expr)
                            catch (err: Str) {
                                # Failed to get type - just use INFER_TYPE default
                            }
                            mut full_name := format(decl.name, ".", member_decl.name)  # Note: using '.' not '::'
                            # Register in symbols
                            ScopeStack.declare_symbol(context.scope_stack, full_name.clone(), SymbolInfo(value_type=value_type_clone(member_value_type), is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own))
                            # If it's a function, also register in funcs
                            switch member_expr.node_type {
                            case NodeType.FuncDef(func_def):
                                ScopeStack.declare_func(context.scope_stack, full_name, func_def.clone())
                            case:
                                # Not a function, skip
                            }
                        }
                    }
                }
            case:
                errors.push(e.lang_error(context.path, "init", "struct declarations should have definitions."))
                return errors
            }

        case ValueType.TMulti(_):
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
        case ValueType.TCustom(_):
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type_clone(value_type), is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))
        case:
            # Unreachable - all ValueType variants are covered above
            # But needed because exhaustiveness check doesn't understand nested patterns like TType(TTypeDef.TEnumDef)
        }

    case:
        if not(context.mode_def.allows_base_anything) {
            if context.mode_def.allows_base_calls {
                errors.push(e.error(context.path, "mode", format("mode '", context.mode_def.name, "' allows only declarations and calls in the root context, found '", enum_to_str(e.node_type), "'.")))
            } else {
                errors.push(e.error(context.path, "mode", format("mode '", context.mode_def.name, "' allows only declarations in the root context, found '", enum_to_str(e.node_type), "'.")))
            }
        }
    }
    catch (err: AllocError) {
        throw err.msg
    }
    catch (err: I64_OverflowError) {
        throw err.msg
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

// Temporary storage for enum payload data during construction
EnumPayload := struct {
    mut data: Vec = Vec.new(U8)
    mut value_type: ValueType = ValueType.TCustom("")

    clone := func(self: EnumPayload) returns EnumPayload throws AllocError {
        return EnumPayload(data=self.data.clone(), value_type=self.value_type)
    }
}

Context := struct {
    mut mode_def: ModeDef = ModeDef()  # All contexts need a mode
    # TODO use Context.path to properly report eval errors, or...no, don't refactor the whole eval phase to return Result<String, String>
    mut path: Str = ""  # this is needed for core func "loc"
    # Scope stack for proper lexical scoping
    mut scope_stack: ScopeStack = ScopeStack.new()
    # Temporary storage for enum payload data during construction (Ptr for Option pattern, NULL = None)
    mut temp_enum_payload: Ptr = Ptr()  # Ptr to EnumPayload
    # Import tracking - per-phase to allow circular imports
    # Add to done at START of processing (not end) - handles both circular and re-imports
    mut imported_asts: Map = Map.new(Str, Expr)  # path -> parsed AST (stored after init, used by typer and eval)
    mut imported_modes: Map = Map.new(Str, ModeDef)  # path -> mode (stored after init, used by typer)
    mut imports_init_done: Set = Set.new(Str)
    mut imports_typer_done: Set = Set.new(Str)
    mut imports_precomp_done: Set = Set.new(Str)
    mut imports_eval_done: Set = Set.new(Str)
    # REM: A hashmap for in the future return a struct (namespace) so that it can be assigned to a constant/var
    # REM: This would enable: std := import("src/std") and then std.panic(), std.format(), etc.
    # REM: TODO change the cached type to support import as returning a struct_def
    # REM: TODO change the cached type to support import as returning a struct_def
    # Bug #40 fix: Track current function name and forin counter for deterministic _for_i_ names
    mut current_precomp_func: Str = ""  # Empty string means None/global scope
    mut precomp_forin_counter: I64 = 0

    # Context methods (insert/get/copy methods moved to EvalArena in interpreter.til)
    new := func(path: Str, mode_name: Str) returns Context throws Str {
        mut scope_stack := ScopeStack.new()
        scope_stack.push(ScopeType.Global) # Initialize global scope

        # Create a dummy token for mode initialization errors
        dummy_token := Token(token_type=TokenType.Mode, token_str=mode_name, line=0, col=0)

        mode_def := mode_from_name(mode_name, path, dummy_token)

        result := Context(
            path=path,
            mode_def=mode_def,
            scope_stack=scope_stack,
            temp_enum_payload=Ptr(),
            imported_asts=Map.new(Str, Expr),
            imported_modes=Map.new(Str, ModeDef),
            imports_init_done=Set.new(Str),
            imports_typer_done=Set.new(Str),
            imports_precomp_done=Set.new(Str),
            imports_eval_done=Set.new(Str)
        )
        catch (err: AllocError) {
            throw err.msg
        }
        return result
    }

    // Bug #38 fix: Use ordered variants Vec for consistent variant positioning
    get_variant_pos := func(selfi: SEnumDef, variant_name: Str, path: Str, e: Expr) returns I64 throws Str {
        for i in 0..selfi.variants.len() {
            mut v := EnumVariant()
            selfi.variants.get(i, v)
            if v.name.eq(variant_name) {
                return i
            }
        }
        mut names := Vec.new(Str)
        for i in 0..selfi.variants.len() {
            mut v := EnumVariant()
            selfi.variants.get(i, v)
            names.push(v.name)
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        throw e.lang_error(path, "context", format("Error: Enum variant '", variant_name, "' not found in variants: ", names.to_str(), "."))
    }

    // Bug #38 fix: Use ordered variants Vec for consistent variant positioning
    variant_pos_to_str := func(selfi: SEnumDef, position: I64, path: Str, e: Expr) returns Str throws Str {
        if position.lt(0).or(position.gteq(selfi.variants.len())) {
            mut names := Vec.new(Str)
            for i in 0..selfi.variants.len() {
                mut v := EnumVariant()
                selfi.variants.get(i, v)
                names.push(v.name)
            }
            catch (err: IndexOutOfBoundsError) {
                throw err.msg
            }
            catch (err: AllocError) {
                throw err.msg
            }
            throw e.lang_error(path, "context", format("Error: Invalid position '", I64.to_str(position), "' for enum variant in '", names.to_str(), "'."))
        }
        # If position is valid, return the corresponding variant name
        mut v := EnumVariant()
        selfi.variants.get(position, v)
        mut result := v.name.clone()
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
        return result
    }

    map_instance_fields := proc(mut self: Context, custom_type_name: Str, instance_name: Str, e: Expr) throws Str {
        mut struct_def := self.scope_stack.lookup_struct(custom_type_name)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(self.path, "context", format("map_instance_fields: definition for '", custom_type_name, "' not found"))
        }

        mut instance_symbol := self.scope_stack.lookup_symbol(instance_name)
        catch (sym_err: KeyNotFoundError) {
            throw e.lang_error(self.path, "context", format("map_instance_fields: instance '", instance_name, "' not found in symbols"))
        }
        mut is_mut := instance_symbol.is_mut

        mut base_offset := self.scope_stack.lookup_var(instance_name)
        catch (var_err: KeyNotFoundError) {
            throw e.lang_error(self.path, "context", format("map_instance_fields: base offset for '", instance_name, "' not found"))
        }

        mut current_offset := 0
        mut member_idx := 0
        while member_idx.lt(struct_def.members.len()) {
            mut decl := Declaration()
            struct_def.members.get(member_idx, decl)
            catch (idx_err: IndexOutOfBoundsError) {
                member_idx.inc()
            }
            mut field_name := decl.name

            if decl.is_mut {
                mut combined_name := format(instance_name, ".", field_name)
                mut field_offset := base_offset.add(current_offset)
                self.scope_stack.insert_var(combined_name.clone(), field_offset)

                self.scope_stack.declare_symbol(
                    combined_name.clone(),
                    SymbolInfo(value_type=value_type_clone(decl.value_type), is_mut=is_mut)
                )

                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    mut found_nested_struct := false
                    mut nested_struct_def := SStructDef()
                    nested_struct_def = self.scope_stack.lookup_struct(type_name)
                    found_nested_struct = true
                    catch (nested_err: KeyNotFoundError) {
                        // Nested struct not found
                    }
                    if found_nested_struct {
                        self.map_instance_fields(type_name, combined_name, e)
                        // Error will propagate via throws Str
                    }
                case:
                    # Not a custom type
                }

                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(name):
                    field_size = self.get_type_size(name)
                    // Errors propagate via throws Str
                case:
                    throw e.lang_error(self.path, "context", format("map_instance_fields: Unsupported value type '", value_type_to_str(decl.value_type), "'"))
                }

                current_offset = current_offset.add(field_size)
            }
            # Immutable struct fields are handled generically through struct_defs
            member_idx.inc()
        }
        catch (err: AllocError) {
            throw err.msg
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: I64_OverflowError) {
            throw err.msg
        }
    }

    get_struct := func(self: Context, id: Str, e: Expr) returns Str throws Str {
        # Validate that the struct variable exists by checking if we can get its offset
        mut found_var := false
        mut offset := 0
        offset = self.scope_stack.lookup_var(id)
        found_var = true
        catch (err: KeyNotFoundError) {
            // Not found directly
        }
        if found_var {
            # Direct variable lookup succeeded
            return id
        }
        if id.contains(".") {
            # For field paths, validate we can calculate offset
            _ := self.get_field_offset(id)
            catch (err: Str) {
                throw e.lang_error(self.path, "context", format("get_struct: ", err))
            }
            return id
        }
        throw e.lang_error(self.path, "context", format("struct not found for id '", id, "'"))
    }

    // Scope management helpers for upcoming context clone refactor
    // These will replace context cloning with proper scope push/pop

    // Push a new function scope and switch to the function's source path
    // Returns the saved path that should be restored when popping
    push_function_scope := proc(mut self: Context, function_path: Str) returns Str throws Str {
        self.scope_stack.push(ScopeType.Function)
        mut saved_path := self.path.clone()
        catch (err: AllocError) {
            throw err.msg
        }
        self.path = function_path
        return saved_path
    }

    // Pop the current function scope and restore the previous path
    pop_function_scope := proc(mut self: Context, saved_path: Str) throws Str {
        self.path = saved_path
        _ := self.scope_stack.pop()
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
    }

    // Get the size of a type in bytes
    get_type_size := func(self: Context, type_name: Str) returns I64 throws Str {
        if type_name.eq("U8") {
            return 1
        }
        if type_name.eq("I64") {
            return 8
        }

        // Check if it's an enum
        mut found_enum := false
        mut enum_def := SEnumDef()
        enum_def = self.scope_stack.lookup_enum(type_name)
        found_enum = true
        catch (err: KeyNotFoundError) {
            // Not an enum
        }

        if found_enum {
            // Calculate maximum variant size (8 bytes for tag + largest payload)
            mut max_size := 8  // Start with tag size

            // Bug #38 fix: iterate over variants Vec
            mut i := 0
            while i.lt(enum_def.variants.len()) {
                mut v := EnumVariant()
                enum_def.variants.get(i, v)

                // Check if payload exists (not NULL)
                if not(NULL.eq(v.payload_type.data)) {
                    mut payload_type := ValueType.TCustom("")
                    memcpy(to_ptr(payload_type), v.payload_type.data, size_of(ValueType))
                    switch payload_type {
                    case ValueType.TCustom(t):
                        payload_size := self.get_type_size(t)
                        variant_total := add(8, payload_size)  // tag + payload
                        if variant_total.gt(max_size) {
                            max_size = variant_total
                        }
                    case:
                        // Unsupported payload type
                    }
                }
                i.inc()
            }
            catch (err: IndexOutOfBoundsError) {
                throw format("get_type_size: index error in enum '", type_name, "'")
            }

            return max_size
        }

        // Check if it's a struct
        mut found_struct := false
        mut struct_def := SStructDef()
        struct_def = self.scope_stack.lookup_struct(type_name)
        found_struct = true
        catch (err: KeyNotFoundError) {
            // Not a struct
        }

        if found_struct {
            // Calculate size of struct's fields manually
            mut total_size := 0

            for decl: Declaration in struct_def.members {
                if decl.is_mut {
                    mut field_size := 0
                    switch decl.value_type {
                    case ValueType.TCustom(t):
                        field_size = self.get_type_size(t)
                    case:
                        throw format("get_type_size: unsupported value type '", value_type_to_str(decl.value_type), "' in '", type_name, ".", decl.name, "'")
                    }
                    total_size = total_size.add(field_size)
                }
            }

            return total_size
        }

        throw format("get_type_size: type '", type_name, "' not found in struct or enum defs")
    }

    // Calculate the offset of a specific field within a struct type
    calculate_field_offset := func(self: Context, struct_type: Str, field_name: Str) returns I64 throws Str {
        mut struct_def := self.scope_stack.lookup_struct(struct_type)
        catch (err: KeyNotFoundError) {
            throw format("calculate_field_offset: struct '", struct_type, "' not found")
        }

        mut current_offset := 0

        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                if decl.name.eq(field_name) {
                    return current_offset
                }

                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(t):
                    field_size = self.get_type_size(t)
                case:
                    throw format("calculate_field_offset: unsupported field type '", value_type_to_str(decl.value_type), "' in '", struct_type, ".", decl.name, "'")
                }

                current_offset = current_offset.add(field_size)
            }
        }

        throw format("calculate_field_offset: field '", field_name, "' not found in struct '", struct_type, "'")
    }

    // Get the absolute arena offset for a field path (e.g., "my_vec._len")
    get_field_offset := func(self: Context, field_path: Str) returns I64 throws Str {
        mut parts := field_path.split(".")
        catch (err: AllocError) {
            throw format("get_field_offset: alloc error splitting '", field_path, "'")
        }
        if parts.len().eq(0) {
            throw "get_field_offset: empty field path"
        }

        mut base_var := ""
        parts.get(0, base_var)
        catch (err: IndexOutOfBoundsError) {
            throw "get_field_offset: empty field path"
        }

        mut base_offset := self.scope_stack.lookup_var(base_var)
        catch (err: KeyNotFoundError) {
            throw format("get_field_offset: base variable '", base_var, "' not found in arena_index")
        }
        mut current_offset := base_offset

        // Get the base variable's type
        mut base_symbol := self.scope_stack.lookup_symbol(base_var)
        catch (err: KeyNotFoundError) {
            throw format("get_field_offset: base variable '", base_var, "' not found in symbols")
        }

        mut current_type := ""
        switch base_symbol.value_type {
        case ValueType.TCustom(t):
            current_type = t.clone()
        case:
            throw format("get_field_offset: base variable '", base_var, "' is not a struct")
        }

        // Walk through the remaining parts of the path
        mut should_continue_path := true
        mut idx := 1
        while idx.lt(parts.len()) {
            if should_continue_path {
                mut field_name := ""
                parts.get(idx, field_name)

                field_offset := self.calculate_field_offset(current_type, field_name)
                current_offset = current_offset.add(field_offset)

                // Update current_type to the type of this field (for nested access)
                mut struct_def := self.scope_stack.lookup_struct(current_type)
                catch (err: KeyNotFoundError) {
                    throw format("get_field_offset: struct '", current_type, "' not found")
                }

                // Find the field declaration
                mut field_found := false
                mut field_decl := Declaration()
                mut fi := 0
                while fi.lt(struct_def.members.len()) {
                    mut decl := Declaration()
                    struct_def.members.get(fi, decl)
                    if decl.name.eq(field_name) {
                        field_decl = decl
                        field_found = true
                    }
                    fi.inc()
                }
                catch (err: IndexOutOfBoundsError) {
                    throw format("get_field_offset: index error finding field '", field_name, "'")
                }

                if not(field_found) {
                    throw format("get_field_offset: field '", field_name, "' not found in struct '", current_type, "'")
                }

                switch field_decl.value_type {
                case ValueType.TCustom(t):
                    current_type = t.clone()
                case:
                    // If this is the last part and it's a primitive, that's fine
                    if idx.eq(parts.len().sub(1)) {
                        should_continue_path = false
                    } else {
                        throw format("get_field_offset: field '", field_name, "' in '", current_type, "' is not a struct, cannot continue path")
                    }
                }
            }
            idx.inc()
        }
        catch (err: AllocError) {
            throw err.msg
        }

        return current_offset
    }

    // Get the ValueType for a field path (e.g., "s.color")
    get_field_type := func(self: Context, field_path: Str) returns ValueType throws Str {
        mut parts := field_path.split(".")
        catch (err: AllocError) {
            throw format("get_field_type: alloc error splitting '", field_path, "'")
        }
        if parts.len().eq(0) {
            throw "get_field_type: empty field path"
        }

        mut base_var := ""
        parts.get(0, base_var)
        catch (err: IndexOutOfBoundsError) {
            throw "get_field_type: empty field path"
        }

        // Get the base variable's type
        mut base_symbol := self.scope_stack.lookup_symbol(base_var)
        catch (err: KeyNotFoundError) {
            throw format("get_field_type: base variable '", base_var, "' not found in symbols")
        }

        mut current_type := ValueType.TCustom("")
        current_type = value_type_clone(base_symbol.value_type)

        // Walk through the remaining parts of the path
        mut idx := 1
        while idx.lt(parts.len()) {
            mut field_name := ""
            parts.get(idx, field_name)

            // Get the type name from current_type
            mut type_name := ""
            switch current_type {
            case ValueType.TCustom(t):
                type_name = t.clone()
            case:
                throw format("get_field_type: cannot access field '", field_name, "' on non-struct type")
            }

            mut struct_def := self.scope_stack.lookup_struct(type_name)
            catch (err: KeyNotFoundError) {
                throw format("get_field_type: struct '", type_name, "' not found")
            }

            // Find the field declaration
            mut field_found := false
            mut field_decl := Declaration()
            mut fi := 0
            while fi.lt(struct_def.members.len()) {
                mut decl := Declaration()
                struct_def.members.get(fi, decl)
                if decl.name.eq(field_name) {
                    field_decl = decl
                    field_found = true
                }
                fi.inc()
            }
            catch (err: IndexOutOfBoundsError) {
                throw format("get_field_type: index error finding field '", field_name, "'")
            }

            if not(field_found) {
                throw format("get_field_type: field '", field_name, "' not found in struct '", type_name, "'")
            }

            current_type = value_type_clone(field_decl.value_type)
            idx.inc()
        }
        catch (err: AllocError) {
            throw err.msg
        }

        return current_type
    }

    register_struct_fields_for_typecheck := proc(mut self: Context, instance_name: Str, custom_type_name: Str) throws Str {
        mut found_struct := false
        mut struct_def := SStructDef()
        struct_def = self.scope_stack.lookup_struct(custom_type_name).clone()
        found_struct = true
        catch (err: KeyNotFoundError) {
            // Struct not found
        }
        if not(found_struct) {
            return
        }

        for decl: Declaration in struct_def.members {
            mut combined_name := format(instance_name, ".", decl.name)
            self.scope_stack.declare_symbol(
                combined_name.clone(),
                SymbolInfo(value_type=value_type_clone(decl.value_type), is_mut=decl.is_mut)
            )

            switch decl.value_type {
            case ValueType.TCustom(nested_type_name):
                mut found_nested := false
                mut nested_struct_def := SStructDef()
                nested_struct_def = self.scope_stack.lookup_struct(nested_type_name)
                found_nested = true
                catch (nested_err: KeyNotFoundError) {
                    // Nested struct not found
                }
                if found_nested {
                    self.register_struct_fields_for_typecheck(combined_name, nested_type_name)
                }
            case:
                # Not a custom type
            }
        }
        catch (err: IndexOutOfBoundsError) {
            throw err.msg
        }
        catch (err: I64_OverflowError) {
            throw err.msg
        }
        catch (err: AllocError) {
            throw err.msg
        }
    }

    clone := func(self: Context) returns Context throws AllocError {
        return Context(
            mode_def=self.mode_def,
            path=self.path,
            scope_stack=self.scope_stack.clone(),
            temp_enum_payload=self.temp_enum_payload,
            imported_asts=self.imported_asts.clone(),
            imported_modes=self.imported_modes.clone(),
            imports_init_done=self.imports_init_done.clone(),
            imports_typer_done=self.imports_typer_done.clone(),
            imports_precomp_done=self.imports_precomp_done.clone(),
            imports_eval_done=self.imports_eval_done.clone()
        )
    }
}
