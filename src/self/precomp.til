mode liba

import("self.init")
import("self.interpreter")
import("self.precomp_ext")

// Precomputation phase: Performs compile-time constant folding for pure functions
// and handles struct/enum constructors and import().
// This phase runs after ufcs, before interpreter/builder.

// ---------- Main entry point

/// Precomputation phase: Perform compile-time constant folding and handle
/// struct/enum constructors and import().
/// Takes an AST that has already passed type checking and UFCS resolution.
precomp_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    case NodeType.Body:
        return precomp_body(context, e)
    case NodeType.FCall(_):
        mut const_folded := precomp_fcall(context, e)?
        // Try compile-time constant folding for pure functions with literal args.
        // Only fold at global scope - inside function definitions, values from other
        // modules may not be available yet (import ordering). Interpreter doesn't
        // evaluate function bodies during import either.
        at_global_scope := context.scope_stack.frames.len().eq(1)
        if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
            const_folded = eval_comptime(context, const_folded)?
        }
        return const_folded
    case NodeType.If:
        return precomp_params(context, e)
    case NodeType.While:
        return precomp_params(context, e)
    case NodeType.Switch:
        return precomp_switch(context, e)?
    case NodeType.FuncDef(func_def):
        return precomp_func_def(context, e, func_def)?
    case NodeType.Declaration(decl):
        return precomp_declaration(context, e, decl)?
    case NodeType.Assignment:
        return precomp_params(context, e)
    case NodeType.Return:
        return precomp_params(context, e)
    case NodeType.Throw:
        return precomp_params(context, e)
    case NodeType.Catch:
        return precomp_catch(context, e)?
    case NodeType.Range:
        return precomp_params(context, e)
    // Struct/enum definitions - need to process default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        return precomp_struct_def(context, e, struct_def)?
    case NodeType.EnumDef:
        return e.clone()
    // Identifiers can have nested params (e.g., a.b.c for field access chains)
    case NodeType.Identifier:
        return precomp_params(context, e)
    // Leaf nodes - no transformation needed
    case NodeType.LLiteral:
        return e.clone()
    case NodeType.DefaultCase:
        return e.clone()
    case NodeType.Pattern:
        return e.clone()
    // Break and Continue are leaf nodes (no params) - no transformation needed
    case NodeType.Break:
        return e.clone()
    case NodeType.Continue:
        return e.clone()
    // Named arguments - transform the value expression
    case NodeType.NamedArg(name):
        mut new_params := Vec.new(Expr)
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(NodeType.NamedArg(name), e, new_params)
    // ForIn should have been desugared in desugarer phase
    case NodeType.ForIn(_):
        panic(loc(), "ForIn should have been desugared in desugarer phase")
    }
}

// ---------- Compile-time constant folding

/// Check if an expression can be evaluated at compile time.
/// Currently only handles literals and pure function calls with literal arguments.
is_comptime_evaluable := proc(context: Context, e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.LLiteral:
        return true
    // Type definitions and function definitions are static metadata - always comptime
    case NodeType.StructDef:
        return true
    case NodeType.EnumDef:
        return true
    case NodeType.FuncDef:
        return true
    case NodeType.Identifier(name):
        // Check if this is a simple identifier (no field access chain)
        if e.params.len().gt(0) {
            return false  // Field access chains not supported
        }
        // Look up the symbol and check if it's a comptime const
        mut symbol := context.scope_stack.lookup_symbol(name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        return symbol.is_comptime_const
    case NodeType.FCall(_):
        f_name := get_func_name_in_call(e)?
        catch (err: Str) {
            return false  // Can't get function name
        }
        // Special case: exit terminates the program
        if f_name.eq("exit") { return false }
        // TODO: Properly detect ext_funcs and functions with side effects.
        // For now, hardcode malloc exclusion since it's an ext_func with side effects.
        if f_name.eq("malloc") { return false }

        // Use get_func_def_for_fcall_with_expr like interpreter does
        mut e_clone := e.clone()
        mut func_def := SFuncDef()
        mut func_def_found := false
        func_def = get_func_def_for_fcall_with_expr(context, e_clone)?
        func_def_found = true
        catch (err: KeyNotFoundError) {
            // Could be a struct constructor - check if all args are comptime
            combined_name := get_combined_name(context.path, e.get(0)?)?
            catch (err2: Str) {
                return false
            }
            // Try to look up as struct
            mut is_struct := false
            _ := context.scope_stack.lookup_struct(combined_name)?
            is_struct = true
            catch (err3: KeyNotFoundError) {
                // REM: Not a struct
            }
            if is_struct {
                // It's a struct constructor - check all args are comptime
                mut struct_j := 1
                while struct_j.lt(e.params.len()) {
                    mut struct_arg := Expr()
                    e.params.get(struct_j, struct_arg)?
                    catch (err4: IndexOutOfBoundsError) {
                        return false
                    }
                    // Handle named args - check the value inside
                    mut arg_to_check := struct_arg
                    switch struct_arg.node_type {
                    case NodeType.NamedArg(_):
                        if struct_arg.params.len().gt(0) {
                            struct_arg.params.get(0, arg_to_check)?
                            catch (err5: IndexOutOfBoundsError) {
                                return false
                            }
                        }
                    case:
                    }
                    if not(is_comptime_evaluable(context, arg_to_check)) {
                        return false
                    }
                    struct_j.inc()
                }
                return true  // Struct constructor with all comptime args
            }
            // Check if it's an enum constructor (e.g., Color.Green(true))
            if context.scope_stack.is_enum_constructor(combined_name) {
                // It's an enum constructor - check all args are comptime
                mut k := 1
                while k.lt(e.params.len()) {
                    mut arg := Expr()
                    e.params.get(k, arg)?
                    catch (err_arg: IndexOutOfBoundsError) {
                        return false
                    }
                    if not(is_comptime_evaluable(context, arg)) {
                        return false
                    }
                    k.inc()
                }
                return true
            }
            return false  // Unknown function
        }
        catch (err: Str) {
            return false  // Function lookup error
        }
        if not(func_def_found) {
            return false
        }
        // Must be pure function (not proc) that returns a value
        if func_def.is_proc() {
            return false
        }
        // Funcs with no return type can't be folded (nothing to fold to)
        if func_def.return_types.len().eq(0) {
            return false
        }
        // Functions that can throw are allowed - if they actually throw,
        // we'll report the error in eval_comptime.
        // All arguments must be comptime-evaluable
        mut fcall_i := 1
        while fcall_i.lt(e.params.len()) {
            mut fcall_arg := Expr()
            e.params.get(fcall_i, fcall_arg)?
            catch (err: IndexOutOfBoundsError) {
                return false
            }
            if not(is_comptime_evaluable(context, fcall_arg)) {
                return false
            }
            fcall_i.inc()
        }
        return true
    case:
        return false
    }
}

/// Evaluate a comptime-evaluable expression and convert result back to AST literal.
eval_comptime := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Save and restore context.path - interpreter may change it during function calls
    saved_path := context.path
    result := eval_expr(context, e)?
    context.path = saved_path

    // Check if the function threw an exception during evaluation
    if result.is_throw {
        mut thrown_type := result.thrown_type
        if thrown_type.eq("") {
            thrown_type = "unknown"
        }
        throw e.error(context.path, "precomp", format("Exception '", thrown_type, "' thrown during precomputation: ", result.value))
    }

    // EvalResult.value is a String representation of the value
    // Convert back to LLiteral based on the result type
    value_type := get_value_type(context, e)?
    switch value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("U8") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("Str") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Str(result.value)), e, Vec.new(Expr))
        }
        // Check if it's a struct type - result.value is the instance name
        _struct_def := context.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            // For enums and other types: eval_expr was called (catching any errors),
            // but we can't convert the result back to AST literal, so return original
            return e.clone()
        }
        // Try to convert struct back to literal, fall back to original expr if unsupported
        mut struct_literal := EvalArena.to_struct_literal(context, result.value, type_name, e)?
        catch (err: Str) {
            return e.clone()
        }
        return struct_literal
    case:
        // For other types, eval was done (errors caught), return original (no folding)
        return e.clone()
    }

}

// ---------- AST transformation

/// Transform Body node - recursively transform all statements
precomp_body := proc(mut context: Context, e: Expr) returns Expr {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        new_params.push(precomp_expr(context, p)?)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform node params - recursively transform all child expressions
precomp_params := proc(mut context: Context, e: Expr) returns Expr {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        new_params.push(precomp_expr(context, p)?)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Check if a switch can be desugared to if/else.
/// Only switches with qualified enum variant cases (EnumType.Variant) can be desugared.
/// Cases with variables, patterns, ranges, etc. cannot be desugared.
switch_can_desugar := func(e: Expr) returns Bool {
    mut i := 1
    while i.add(1).lt(e.params.len().add(1)) {
        mut case_expr := Expr()
        e.params.get(i, case_expr)?
        switch case_expr.node_type {
        case NodeType.Identifier:
            // Check if this is a qualified enum variant (has dot, e.g., EnumType.Variant)
            // vs a simple variable (no dot, e.g., expected)
            // An identifier is a qualified enum variant only if it has params
            // (i.e., EnumType has .Variant as a param)
            // If no params, it's a variable - can't desugar
            if case_expr.params.len().eq(0) {
                return false
            }
        case NodeType.DefaultCase:
            // Default case: case: - this is fine for desugaring
        case NodeType.Pattern:
            // Any pattern means we can't desugar (payload binding, nested patterns, etc.)
            return false
        case:
            // Ranges, literals, etc. - can't desugar
            return false
        }
        i = i.add(2)
    }
    catch (err: IndexOutOfBoundsError) {
        // REM: Shouldn't happen, but return false to be safe
    }
    return true
}

/// Transform Switch - desugar to if/else chain when no payload bindings exist.
/// Issue #110: Desugar switch statements to if/else chains in precomp phase.
/// For switches WITH payload binding, keep the Switch node for interpreter/ccodegen.
precomp_switch := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Switch structure: params[0] is switch expression, then pairs of (case, body)
    if e.params.len().eq(0) {
        return e.clone()
    }

    // Only desugar switches with simple identifier cases (no patterns, ranges, etc.)
    if not(switch_can_desugar(e)) {
        return precomp_switch_with_payload(context, e)?
    }

    // Desugar to if/else chain
    return precomp_switch_desugar(context, e)?
}

/// Handle switches with payload binding (keep as Switch node)
precomp_switch_with_payload := proc(mut context: Context, e: Expr) returns Expr throws Str {
    mut new_params := Vec.new(Expr)

    // Transform switch expression
    mut switch_expr := Expr()
    e.params.get(0, switch_expr)?
    new_params.push(precomp_expr(context, switch_expr)?)

    // Get the type of the switch expression for pattern binding resolution
    mut switch_expr_type := ValueType.TCustom("")
    mut got_switch_type := true
    switch_expr_type = get_value_type(context, switch_expr)?
    catch (err: Str) {
        got_switch_type = false
    }

    // Process case/body pairs
    mut i := 1
    while i.add(1).lt(e.params.len().add(1)) {
        mut case_expr := Expr()
        mut body_expr := Expr()
        e.params.get(i, case_expr)?
        e.params.get(i.add(1), body_expr)?

        // Transform case expression (no scope change needed for case itself)
        new_params.push(precomp_expr(context, case_expr)?)

        // For pattern matching with binding variable, add binding to scope before processing body
        switch case_expr.node_type {
        case NodeType.Pattern(pattern_info):
            mut handled := false
            if got_switch_type {
                switch switch_expr_type {
                case ValueType.TCustom(enum_name):
                    // Extract variant name (after the last dot)
                    variant_name := pattern_info.variant_name
                    mut variant := variant_name
                    dot_pos := variant_name.rfind(".")
                    if dot_pos.gteq(0) {
                        variant = get_substr(variant_name, dot_pos.add(1), variant_name.len())?
                    }

                    // Get payload type from enum definition
                    mut enum_found := true
                    mut enum_def := context.scope_stack.lookup_enum(enum_name)?
                    catch (err: KeyNotFoundError) {
                        enum_found = false
                    }

                    if enum_found {
                        mut payload_type := ValueType.TCustom("")
                        mut got_payload := false
                        // Bug #38 fix: use helper method
                        payload_ptr := enum_def.get(variant)?
                        if not(NULL.eq(payload_ptr.data)) {
                            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                            got_payload = true
                        }
                        catch (err: KeyNotFoundError) {
                            // REM: Variant not found or no payload
                        }

                        if got_payload {
                            // Push block scope, declare binding variable, transform body, pop scope
                            context.scope_stack.push(ScopeType.Block)
                            sym := SymbolInfo(value_type=payload_type, is_mut=false, is_copy=false, is_own=false)
                            context.scope_stack.declare_symbol(pattern_info.binding_var, sym)?
                            new_params.push(precomp_expr(context, body_expr)?)
                            _ := context.scope_stack.pop()?
                            handled = true
                        }
                    }
                case:
                }
            }
            if not(handled) {
                // No payload type found or switch type not found, transform body without binding
                new_params.push(precomp_expr(context, body_expr)?)
            }
        case:
            // Not a pattern, transform body normally
            new_params.push(precomp_expr(context, body_expr)?)
        }

        i = i.add(2)
    }

    // Handle odd trailing element (default case body without case expression)
    if i.lt(e.params.len()) {
        mut trailing := Expr()
        e.params.get(i, trailing)?
        new_params.push(precomp_expr(context, trailing)?)
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_switch_with_payload: ", err.msg)
    }
    return Expr.new_clone(NodeType.Switch, e, new_params)
}

/// Desugar switch to if/else chain (no payload bindings)
/// switch expr { case A: body1 case B: body2 case: default_body }
/// becomes:
/// if Str.eq(enum_to_str(expr), "EnumType.A") { body1 }
/// else if Str.eq(enum_to_str(expr), "EnumType.B") { body2 }
/// else { default_body }
precomp_switch_desugar := proc(mut context: Context, e: Expr) returns Expr throws Str {
    mut switch_expr := Expr()
    e.params.get(0, switch_expr)?
    transformed_switch_expr := precomp_expr(context, switch_expr)?

    // Get the enum type name from the switch expression
    // If type inference fails, fall back to not desugaring
    mut type_infer_failed := false
    mut switch_type := ValueType.TCustom("")
    switch_type = get_value_type(context, switch_expr)?
    catch (type_err: Str) {
        type_infer_failed = true
    }
    if type_infer_failed {
        return precomp_switch_with_payload(context, e)?
    }

    mut enum_type_name := ""
    switch switch_type {
    case ValueType.TCustom(name):
        // Check if this is actually an enum type (not a primitive like Str, I64, Bool, U8)
        if name.eq("Str").or(name.eq("I64")).or(name.eq("Bool")).or(name.eq("U8")) {
            // Not an enum - keep as Switch node, don't desugar
            return precomp_switch_with_payload(context, e)?
        }
        // Note: We don't check lookup_enum here because the enum might not be registered
        // yet during precomp (import ordering). The desugaring will still work correctly
        // as enum_to_str handles any enum type.
        enum_type_name = name
        // TEMP DEBUG: Skip TokenType to find which switches cause issues
        if name.eq("TokenType") {
            return precomp_switch_with_payload(context, e)?
        }
    case:
        return precomp_switch_with_payload(context, e)?
    }

    // Generate a unique temp variable name to avoid evaluating switch_expr multiple times
    temp_var_id := context.precomp_forin_counter
    context.precomp_forin_counter.inc()
    mut temp_var_name := ""
    if context.current_precomp_func.len().eq(0) {
        temp_var_name = format("_switch_tmp_", I64.to_str(temp_var_id))
    } else {
        temp_var_name = format("_switch_tmp_", context.current_precomp_func, "_", I64.to_str(temp_var_id))
    }

    // Build: _switch_tmp := switch_expr
    // Use the actual type (switch_type) instead of INFER_TYPE since precomp runs after typer
    temp_decl := Declaration(name=temp_var_name, value_type=switch_type, is_mut=false, is_copy=false, is_own=false, default_value=NULL)
    mut temp_decl_params := Vec.new(Expr)
    temp_decl_params.push(transformed_switch_expr)
    temp_decl_expr := Expr.new_explicit(NodeType.Declaration(temp_decl), temp_decl_params, e.line, e.col)

    // Use the temp variable for all comparisons
    temp_var_expr := Expr.new_explicit(NodeType.Identifier(temp_var_name), Vec.new(Expr), e.line, e.col)

    // Collect cases and bodies as parallel Vecs (variant_name="" means default case)
    mut case_variants := Vec.new(Str)
    mut case_bodies := Vec.new(Expr)

    mut i := 1
    while i.add(1).lt(e.params.len().add(1)) {
        mut case_expr := Expr()
        mut body_expr := Expr()
        e.params.get(i, case_expr)?
        e.params.get(i.add(1), body_expr)?
        transformed_body := precomp_expr(context, body_expr)?

        switch case_expr.node_type {
        case NodeType.Identifier:
            // Get the full variant name including enum type
            ident_variant_name := get_combined_name(context.path, case_expr)?
            case_variants.push(ident_variant_name)
            case_bodies.push(transformed_body)
        case NodeType.Pattern(pattern_info):
            // Pattern with "_" binding (no actual binding)
            if pattern_info.binding_var.eq("_") {
                case_variants.push(pattern_info.variant_name)
                case_bodies.push(transformed_body)
            } else {
                // This shouldn't happen - we checked for payload bindings earlier
                throw e.lang_error(context.path, "precomp", "Unexpected payload binding in switch desugaring")
            }
        case NodeType.DefaultCase:
            case_variants.push("")  // Empty string marks default case
            case_bodies.push(transformed_body)
        case:
            // For other case types, get combined name
            other_variant_name := get_combined_name(context.path, case_expr)?
            case_variants.push(other_variant_name)
            case_bodies.push(transformed_body)
        }
        i = i.add(2)
    }

    // Handle trailing default body
    if i.lt(e.params.len()) {
        mut trailing := Expr()
        e.params.get(i, trailing)?
        default_body := precomp_expr(context, trailing)?
        case_variants.push("")  // Empty string marks default case
        case_bodies.push(default_body)
    }

    // Build if/else chain from the end (innermost first)
    mut result_set := false
    mut result := Expr()

    // Iterate backwards
    mut j := case_variants.len().sub(1)
    while j.gteq(0) {
        mut curr_variant_name := ""
        mut body := Expr()
        case_variants.get(j, curr_variant_name)?
        case_bodies.get(j, body)?

        if curr_variant_name.eq("") {
            // Default case becomes the else branch
            result = body
            result_set = true
        } else {
            // Build: Str.eq(enum_to_str(_switch_tmp), "EnumType.Variant")
            mut enum_to_str_params := Vec.new(Expr)
            enum_to_str_params.push(Expr.new_explicit(NodeType.Identifier("enum_to_str"), Vec.new(Expr), e.line, e.col))
            enum_to_str_params.push(temp_var_expr.clone())
            enum_to_str_call := Expr.new_explicit(NodeType.FCall(false), enum_to_str_params, e.line, e.col)

            // Full variant string: "EnumType.Variant"
            dot_pos := curr_variant_name.rfind(".")
            mut variant_short := curr_variant_name
            if dot_pos.gteq(0) {
                variant_short = get_substr(curr_variant_name, dot_pos.add(1), curr_variant_name.len())?
            }
            variant_str := format(enum_type_name, ".", variant_short)
            variant_literal := Expr.new_explicit(NodeType.LLiteral(Literal.Str(variant_str)), Vec.new(Expr), e.line, e.col)

            mut cond_params := Vec.new(Expr)
            cond_params.push(Expr.new_explicit(NodeType.Identifier("Str.eq"), Vec.new(Expr), e.line, e.col))
            cond_params.push(enum_to_str_call)
            cond_params.push(variant_literal)
            condition := Expr.new_explicit(NodeType.FCall(false), cond_params, e.line, e.col)

            // Build if node
            mut if_params := Vec.new(Expr)
            if_params.push(condition)
            if_params.push(body)
            if result_set {
                if_params.push(result)
            }

            result = Expr.new_explicit(NodeType.If, if_params, e.line, e.col)
            result_set = true
        }

        j = j.sub(1)
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_switch_desugar: ", err.msg)
    }

    // If no cases at all, throw error
    if not(result_set) {
        throw e.lang_error(context.path, "precomp", "Switch has no cases")
    }

    // Wrap in a Body with the temp variable declaration
    mut body_params := Vec.new(Expr)
    body_params.push(temp_decl_expr)
    body_params.push(result)
    return Expr.new_explicit(NodeType.Body, body_params, e.line, e.col)
}

/// Build a default value expression for a given ValueType.
/// Used when generating placeholder values for enum variant payloads in for-in loops.
/// Bug #33: for-in loops don't work with enum collections
/// Bug #86: Handle enum payload types recursively
build_default_value_for_forin := func(context: Context, vt: ValueType, line: I64, col: I64) returns Expr {
    switch vt {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
        }
        if type_name.eq("U8") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
        }
        if type_name.eq("Bool") {
            return Expr.new_explicit(NodeType.Identifier("false"), Vec.new(Expr), line, col)
        }
        if type_name.eq("Str") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Str("")), Vec.new(Expr), line, col)
        }
        // For other types (structs, other enums), check if it's an enum
        // Bug #86: Check if this type is an enum - enums need special constructor syntax
        mut is_enum := false
        mut enum_def := context.scope_stack.lookup_enum(type_name)?
        is_enum = true
        catch (err: KeyNotFoundError) {
            // Not an enum
        }
        if is_enum {
            // Build proper enum constructor: EnumType.FirstVariant or EnumType.FirstVariant(payload)
            if enum_def.variants.len().gt(0) {
                mut first_v := EnumVariant()
                enum_def.variants.get(0, first_v)?
                first_variant := first_v.name
                payload_type_ptr := first_v.payload_type
                catch (err: IndexOutOfBoundsError) {
                    // Shouldn't happen since we checked len > 0
                }
                variant_id := Expr.new_explicit(NodeType.Identifier(first_variant), Vec.new(Expr), line, col)
                mut variant_id_params := Vec.new(Expr)
                variant_id_params.push(variant_id)
                enum_id := Expr.new_explicit(NodeType.Identifier(type_name), variant_id_params, line, col)
                if not(NULL.eq(payload_type_ptr.data)) {
                    // Variant has a payload - need FCall with default value (recursive)
                    mut payload_vt := ValueType.TCustom("")
                    memcpy(to_ptr(payload_vt), payload_type_ptr.data, size_of(ValueType))
                    default_arg := build_default_value_for_forin(context, payload_vt, line, col)
                    mut enum_payload_fcall_params := Vec.new(Expr)
                    enum_payload_fcall_params.push(enum_id)
                    enum_payload_fcall_params.push(default_arg)
                    return Expr.new_explicit(NodeType.FCall(false), enum_payload_fcall_params, line, col)
                } else {
                    // Variant has no payload - just the identifier chain
                    return enum_id
                }
            } else {
                // Empty enum - fall back to struct-like constructor (shouldn't happen)
                mut empty_enum_fcall_params := Vec.new(Expr)
                empty_enum_fcall_params.push(Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), line, col))
                return Expr.new_explicit(NodeType.FCall(false), empty_enum_fcall_params, line, col)
            }
        } else {
            // Not an enum - use struct-like constructor: TYPE()
            mut struct_fcall_params := Vec.new(Expr)
            struct_fcall_params.push(Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), line, col))
            return Expr.new_explicit(NodeType.FCall(false), struct_fcall_params, line, col)
        }
    case:
        // For function types and other types, use a placeholder (shouldn't typically happen)
        return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
    }
}

/// Desugar ForIn to a range-based for loop with get() calls
// for VAR: TYPE in COLLECTION { body }
// becomes:
/// for _for_i in 0..collection.len() {
//     mut VAR := TYPE() or EnumType.FirstVariant(...) for enums
///     collection.get(_for_i, VAR)
//     catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
///     body
/// }
precomp_forin := proc(mut context: Context, e: Expr, var_type_name: Str) returns Expr throws Str {
    // Extract var_name from params[0]
    if e.params.len().lt(1) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing loop variable")
    }
    mut var_expr := e.get(0)?
    mut var_name := ""
    switch var_expr.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        throw e.lang_error(context.path, "precomp", "ForIn: expected identifier for loop variable")
    }

    // Declare loop variable in scope BEFORE processing body (body references it)
    context.scope_stack.declare_symbol(var_name, SymbolInfo(
        value_type=ValueType.TCustom(var_type_name),
        is_mut=true
    ))?

    // Get collection expression (params[1])
    if e.params.len().lt(2) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing collection expression")
    }
    collection_expr := precomp_expr(context, e.get(1)?)?

    // Get body (params[2])
    if e.params.len().lt(3) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing body")
    }
    body_expr := precomp_expr(context, e.get(2)?)?

    // Build: mut _for_i_funcname_N := 0 (unique name to avoid conflicts with nested loops)
    // Bug #40 fix: Use per-function counter and include function name for deterministic output
    forin_id := context.precomp_forin_counter
    context.precomp_forin_counter.inc()
    mut index_var_name := ""
    if context.current_precomp_func.len().gt(0) {
        index_var_name = format("_for_i_", context.current_precomp_func, "_", I64.to_str(forin_id))
    } else {
        index_var_name = format("_for_i_", I64.to_str(forin_id))
    }
    index_decl := Declaration(name=index_var_name, value_type=str_to_value_type(INFER_TYPE), is_mut=true, is_copy=false, is_own=false, default_value=NULL)
    mut zero_params := Vec.new(Expr)
    zero_literal := Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), zero_params, e.line, e.col)
    mut decl_params := Vec.new(Expr)
    decl_params.push(zero_literal)
    index_decl_expr := Expr.new_explicit(NodeType.Declaration(index_decl), decl_params, e.line, e.col)

    // Build len(collection) - already desugared form
    mut len_params := Vec.new(Expr)
    len_params.push(Expr.new_explicit(NodeType.Identifier("len"), Vec.new(Expr), e.line, e.col))
    len_params.push(collection_expr.clone())
    len_call_expr := Expr.new_explicit(NodeType.FCall(false), len_params, e.line, e.col)

    // Build lt(_for_i, len_result) - already desugared form
    mut cond_params := Vec.new(Expr)
    cond_params.push(Expr.new_explicit(NodeType.Identifier("lt"), Vec.new(Expr), e.line, e.col))
    cond_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    cond_params.push(len_call_expr)
    cond_expr := Expr.new_explicit(NodeType.FCall(false), cond_params, e.line, e.col)

    // Build: mut VAR := TYPE() or EnumType.FirstVariant(...) for enums
    var_decl := Declaration(name=var_name, value_type=ValueType.TCustom(var_type_name), is_mut=true, is_copy=false, is_own=false, default_value=NULL)

    // Check if this is an enum type - enums need special handling since they don't have
    // a parameterless constructor. We need to use the first variant as a placeholder.
    // Bug #33: for-in loops don't work with enum collections
    mut type_call := Expr()
    mut is_enum := false
    mut enum_def := context.scope_stack.lookup_enum(var_type_name)?
    is_enum = true
    catch (err: KeyNotFoundError) {
        // Not an enum
    }

    if is_enum {
        // Get the first variant from the enum (arbitrary choice - value will be overwritten by get())
        // Bug #38 fix: use variants Vec
        if enum_def.variants.len().gt(0) {
            mut first_v := EnumVariant()
            enum_def.variants.get(0, first_v)?
            first_variant := first_v.name
            payload_type_ptr := first_v.payload_type
            catch (err: IndexOutOfBoundsError) {
                // Shouldn't happen since we checked len > 0
            }

            // Build the enum constructor:
            // - For variants WITHOUT payload: EnumType.Variant (just identifier chain)
            // - For variants WITH payload: EnumType.Variant(default_payload) (FCall)
            variant_id := Expr.new_explicit(NodeType.Identifier(first_variant), Vec.new(Expr), e.line, e.col)
            mut variant_id_params := Vec.new(Expr)
            variant_id_params.push(variant_id)
            enum_id := Expr.new_explicit(NodeType.Identifier(var_type_name), variant_id_params, e.line, e.col)

            if not(NULL.eq(payload_type_ptr.data)) {
                // Variant has a payload - need FCall with default value
                mut payload_vt := ValueType.TCustom("")
                memcpy(to_ptr(payload_vt), payload_type_ptr.data, size_of(ValueType))
                default_arg := build_default_value_for_forin(context, payload_vt, e.line, e.col)
                mut fcall_params := Vec.new(Expr)
                fcall_params.push(enum_id)
                fcall_params.push(default_arg)
                type_call = Expr.new_explicit(NodeType.FCall(false), fcall_params, e.line, e.col)
            } else {
                // Variant has no payload - just the identifier chain (NOT an FCall)
                type_call = enum_id
            }
        } else {
            // Empty enum - shouldn't happen, fall back to struct-like constructor
            mut empty_enum_type_call_params := Vec.new(Expr)
            empty_enum_type_call_params.push(Expr.new_explicit(NodeType.Identifier(var_type_name), Vec.new(Expr), e.line, e.col))
            type_call = Expr.new_explicit(NodeType.FCall(false), empty_enum_type_call_params, e.line, e.col)
        }
    } else {
        // Not an enum - use struct-like constructor: TYPE()
        mut struct_type_call_params := Vec.new(Expr)
        struct_type_call_params.push(Expr.new_explicit(NodeType.Identifier(var_type_name), Vec.new(Expr), e.line, e.col))
        type_call = Expr.new_explicit(NodeType.FCall(false), struct_type_call_params, e.line, e.col)
    }

    mut var_decl_params := Vec.new(Expr)
    var_decl_params.push(type_call)
    var_decl_expr := Expr.new_explicit(NodeType.Declaration(var_decl), var_decl_params, e.line, e.col)

    // Build: get(collection, _for_i, VAR) - already desugared form
    mut get_params := Vec.new(Expr)
    get_params.push(Expr.new_explicit(NodeType.Identifier("get"), Vec.new(Expr), e.line, e.col))
    get_params.push(collection_expr.clone())
    get_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    get_params.push(Expr.new_explicit(NodeType.Identifier(var_name), Vec.new(Expr), e.line, e.col))
    get_call := Expr.new_explicit(NodeType.FCall(false), get_params, e.line, e.col)

    // Build: catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    // Build err.msg (identifier with field access)
    mut msg_field := Vec.new(Expr)
    msg_field.push(Expr.new_explicit(NodeType.Identifier("msg"), Vec.new(Expr), e.line, e.col))
    err_msg_expr := Expr.new_explicit(NodeType.Identifier("err"), msg_field, e.line, e.col)

    // Build loc() call
    mut loc_params := Vec.new(Expr)
    loc_params.push(Expr.new_explicit(NodeType.Identifier("loc"), Vec.new(Expr), e.line, e.col))
    loc_call := Expr.new_explicit(NodeType.FCall(false), loc_params, e.line, e.col)

    // Build panic(loc(), err.msg)
    mut panic_params := Vec.new(Expr)
    panic_params.push(Expr.new_explicit(NodeType.Identifier("panic"), Vec.new(Expr), e.line, e.col))
    panic_params.push(loc_call)
    panic_params.push(err_msg_expr)
    panic_call := Expr.new_explicit(NodeType.FCall(false), panic_params, e.line, e.col)

    // Build catch body
    mut catch_body_params := Vec.new(Expr)
    catch_body_params.push(panic_call)
    catch_body := Expr.new_explicit(NodeType.Body, catch_body_params, e.line, e.col)

    // Catch structure: [name_expr, type_expr, body_expr]
    mut catch_params := Vec.new(Expr)
    catch_params.push(Expr.new_explicit(NodeType.Identifier("err"), Vec.new(Expr), e.line, e.col))
    catch_params.push(Expr.new_explicit(NodeType.Identifier("IndexOutOfBoundsError"), Vec.new(Expr), e.line, e.col))
    catch_params.push(catch_body)
    catch_expr := Expr.new_explicit(NodeType.Catch, catch_params, e.line, e.col)

    // Build: _for_i = add(_for_i, 1)
    // Already desugared form - no UFCS resolution needed
    mut add_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.Identifier("add"), Vec.new(Expr), e.line, e.col))
    add_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    mut one_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.LLiteral(Literal.Number("1")), one_params, e.line, e.col))
    add_call := Expr.new_explicit(NodeType.FCall(false), add_params, e.line, e.col)

    mut inc_params := Vec.new(Expr)
    inc_params.push(add_call)
    inc_stmt := Expr.new_explicit(NodeType.Assignment(index_var_name), inc_params, e.line, e.col)

    // Build while body: var_decl, get_call + catch (together), original body statements, inc
    // The catch must be right after get_call so it only catches IndexOutOfBoundsError from get,
    // not from user code in the loop body
    mut while_body_params := Vec.new(Expr)
    while_body_params.push(var_decl_expr)
    while_body_params.push(get_call)
    while_body_params.push(catch_expr)

    // Bug #57 fix: Transform continue statements to include increment before continue
    transformed_body := transform_continue_with_step(body_expr, inc_stmt)?
    // Add original body statements (transformed)
    switch transformed_body.node_type {
    case NodeType.Body:
        for i in 0..transformed_body.params.len() {
            mut p := Expr()
            transformed_body.params.get(i, p)?
            while_body_params.push(p.clone())
        }
    case:
        while_body_params.push(transformed_body)
    }
    while_body_params.push(inc_stmt.clone())
    while_body := Expr.new_explicit(NodeType.Body, while_body_params, e.line, e.col)

    // Build while: while _for_i.lt(collection.len()) { ... }
    mut while_params := Vec.new(Expr)
    while_params.push(cond_expr)
    while_params.push(while_body)
    while_expr := Expr.new_explicit(NodeType.While, while_params, e.line, e.col)

    // Build outer body: index_decl, while
    mut outer_body_params := Vec.new(Expr)
    outer_body_params.push(index_decl_expr)
    outer_body_params.push(while_expr)

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_forin: ", err.msg)
    }

    return Expr.new_explicit(NodeType.Body, outer_body_params, e.line, e.col)
}

/// Transform StructDef - recursively transform default values (which contain function defs)
precomp_struct_def := proc(mut context: Context, e: Expr, struct_def: SStructDef) returns Expr throws Str {
    mut new_default_values := Map.new(Str, Expr)
    mut i := 0
    while i.lt(struct_def.default_values.keys.len()) {
        mut name := ""
        struct_def.default_values.keys.get(i, name)?
        mut value_expr := Expr()
        struct_def.default_values.get(name, value_expr)?

        // Bug #40 fix: For method definitions, set function name context
        mut is_func := false
        switch value_expr.node_type {
        case NodeType.FuncDef:
            is_func = true
        case:
        }
        saved_func := context.current_precomp_func
        saved_counter := context.precomp_forin_counter
        if is_func {
            context.current_precomp_func = name
            context.precomp_forin_counter = 0
        }

        new_default_values.set(name, precomp_expr(context, value_expr)?)

        // Bug #40 fix: Restore previous function context
        if is_func {
            context.current_precomp_func = saved_func
            context.precomp_forin_counter = saved_counter
        }

        i.inc()
    }
    mut new_struct_def := SStructDef()
    new_struct_def.members = struct_def.members.clone()
    new_struct_def.default_values = new_default_values

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_struct_def: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("precomp_struct_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params.clone())
}

/// Transform FuncDef - push scope frame for function args, transform body, pop frame
precomp_func_def := proc(mut context: Context, e: Expr, func_def: SFuncDef) returns Expr throws Str {
    // Push a new scope frame with the function's parameters
    context.scope_stack.push(ScopeType.Function)
    for arg: Declaration in func_def.args {
        sym := SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
        context.scope_stack.declare_symbol(arg.name, sym)?
    }

    // Transform the function body
    mut new_body := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        new_body.push(precomp_expr(context, stmt)?)
    }

    // Pop the function scope frame
    _ := context.scope_stack.pop()?

    mut new_func_def := SFuncDef()
    new_func_def.function_type = func_def.function_type
    new_func_def.args = func_def.args.clone()
    new_func_def.return_types = func_def.return_types.clone()
    new_func_def.throw_types = func_def.throw_types.clone()
    new_func_def.body = new_body
    new_func_def.source_path = func_def.source_path.clone()

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_func_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params.clone())
}

/// Transform Declaration - register the declared variable in scope, then transform value
precomp_declaration := proc(mut context: Context, e: Expr, decl: Declaration) returns Expr throws Str {
    // Eagerly create default instance template for this struct type
    inner_e := e.get(0)?
    mut value_type := get_value_type(context, inner_e)?
    catch (err: Str) {
        throw e.lang_error(context.path, "precomp", err)
    }

    // Error if INFER_TYPE reaches precomp - typer should have resolved all types
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "precomp", format("Declaration '", decl.name, "' has INFER_TYPE - should have been resolved by typer"))
        }
    case:
    }
    // Type checking - check for U8/I64 coercion
    mut is_u8_decl := false
    mut is_i64_value := false
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq("U8") {
            is_u8_decl = true
        }
    case:
    }
    switch value_type {
    case ValueType.TCustom(val_type_name):
        if val_type_name.eq("I64") {
            is_i64_value = true
        }
    case:
    }
    if is_u8_decl.and(is_i64_value) {
        value_type = decl.value_type
    } else {
        // Check types match
        if not(value_type_to_str(decl.value_type).eq(value_type_to_str(value_type))) {
            throw e.lang_error(context.path, "precomp", format("'", decl.name, "' declared of type ", value_type_to_str(decl.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
        }
    }

    // Handle EnumDef early
    switch value_type {
    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(decl.name, enum_def)?
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))?
            return e.clone()
        case:
            throw e.lang_error(context.path, "precomp", format("Cannot declare '", decl.name, "' of type '", value_type_to_str(decl.value_type), "', expected enum definition."))
        }
    case:
    }

    // Handle StructDef early
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            context.scope_stack.declare_struct(decl.name, struct_def)?
            saved_path := context.path
            _ := eval_declaration(decl, context, e)?
            context.path = saved_path
        case:
        }
    case:
    }

    // Bug #40 fix: For function declarations, set the function name and reset counter
    // BEFORE processing the body so for-in loops get deterministic names
    mut is_func_decl := false
    if e.params.len().gt(0) {
        switch inner_e.node_type {
        case NodeType.FuncDef:
            is_func_decl = true
        case:
        }
    }
    saved_func := context.current_precomp_func
    saved_counter := context.precomp_forin_counter
    if is_func_decl {
        context.current_precomp_func = decl.name
        context.precomp_forin_counter = 0
    }

    // First transform the value expression (if any)
    mut new_params := Vec.new(Expr)
    if e.params.len().gt(0) {
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
    }

    // Bug #40 fix: Restore previous function context
    if is_func_decl {
        context.current_precomp_func = saved_func
        context.precomp_forin_counter = saved_counter
    }

    // REM: Declarations currently always require an initialization value,
    // so new_params should never be empty.
    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "precomp", "Declarations can have only one child expression")
    }

    // Determine if this is a compile-time constant
    // Only mut matters for constantness - copy/own are about ownership, orthogonal to comptime.
    // Any type can be comptime - the type doesn't matter, only how the value is computed.
    mut first_param := Expr()
    new_params.get(0, first_param)?
    is_comptime_const := not(decl.is_mut)
        .and(is_comptime_evaluable(context, first_param))

    // Register the declared variable in scope
    sym := SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=is_comptime_const)
    context.scope_stack.declare_symbol(decl.name, sym)?

    // Also register function definitions so UFCS can resolve their return types
    switch value_type {
    case ValueType.TFunction:
        if new_params.len().gt(0) {
            mut fp := Expr()
            new_params.get(0, fp)?
            switch fp.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
            }
        }
    case:
    }

    // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
    // Unlike the is_comptime_const flag (which also requires !is_mut for folding identifiers),
    // we store ALL comptime-evaluable values including mut ones, just like interpreter does.
    // This is needed for eval_expr to work during constant folding (e.g., mut loop variables).
    // Only do this at global scope - inside function bodies, evaluating could cause side effects
    // to run at compile time AND runtime (e.g., print_debug func in mode liba).
    at_global_scope := context.scope_stack.frames.len().eq(1)
    if at_global_scope {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            if custom_type_name.eq("I64").or(custom_type_name.eq("U8")).or(custom_type_name.eq("Str")) {
                if is_comptime_evaluable(context, first_param) {
                    result := eval_expr(context, first_param)?
                    if not(result.is_throw) {
                        EvalArena.insert_primitive(context, decl.name, value_type, result.value, e)?
                    }
                }
            }
        case:
        }
    }

    // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
    // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
    // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
    if at_global_scope.and(not(decl.is_mut)).and(not(decl.is_copy)).and(not(decl.is_own)).and(is_comptime_evaluable(context, first_param)) {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            // Skip primitives (I64, U8) - handled above. Skip Str - needs special handling.
            if not(custom_type_name.eq("I64")).and(not(custom_type_name.eq("U8"))).and(not(custom_type_name.eq("Str"))) {
                // Check if this is a struct type (not a struct definition)
                mut instance_sym := context.scope_stack.lookup_symbol(custom_type_name)?
                catch (err: KeyNotFoundError) {
                    // Type not found, skip
                }
                switch instance_sym.value_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    instance_saved_path := context.path
                    _ := eval_declaration(decl, context, e)?
                    context.path = instance_saved_path
                case:
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_declaration: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform Catch node - register the catch variable in scope before processing body
/// This enables UFCS resolution for methods called on the error variable
/// Catch structure: [var_name_expr, type_expr, body_expr]
precomp_catch := proc(mut context: Context, e: Expr) returns Expr throws Str {
    if e.params.len().lt(3) {
        // Malformed catch - just use default handling
        return precomp_params(context, e)
    }

    // Get the catch variable name and type
    mut name_expr := Expr()
    mut type_expr := Expr()
    e.params.get(0, name_expr)?
    e.params.get(1, type_expr)?
    mut var_name := ""
    mut type_name := ""
    switch name_expr.node_type {
    case NodeType.Identifier(n):
        var_name = n
    case:
        return precomp_params(context, e)  // Not a simple identifier, use default handling
    }
    switch type_expr.node_type {
    case NodeType.Identifier(t):
        type_name = t
    case:
        return precomp_params(context, e)  // Not a simple type, use default handling
    }

    // Push a scope frame for the catch block
    context.scope_stack.push(ScopeType.Catch)

    // Register the catch variable in the scope
    mut sym := SymbolInfo()
    sym.value_type = ValueType.TCustom(type_name)
    sym.is_mut = false
    sym.is_copy = false
    sym.is_own = false
    sym.is_comptime_const = false
    context.scope_stack.declare_symbol(var_name, sym)?

    // Transform the catch body (params[2])
    mut body_expr := Expr()
    e.params.get(2, body_expr)?
    new_body := precomp_expr(context, body_expr)?

    // Pop the scope frame
    _ := context.scope_stack.pop()?

    // Return the transformed catch with original var_name, type, and new body
    mut new_params := Vec.new(Expr)
    new_params.push(name_expr)
    new_params.push(type_expr)
    new_params.push(new_body)

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_catch: ", err.msg)
    }

    return Expr.new_clone(NodeType.Catch, e, new_params)
}

/// Transform FCall node - handles compile-time intrinsics, struct/enum constructors, and import()
precomp_fcall := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // 1. Check for compile-time intrinsics (loc, _file, _line, _col)
    mut was_replaced := false
    replaced := try_replace_comptime_intrinsic(context, e, was_replaced)?
    if was_replaced {
        return replaced
    }

    // Get func_expr and combined_name before any transformation
    if e.params.len().eq(0) {
        // Empty FCall, shouldn't happen but just return as-is
        return e.clone()
    }
    mut func_expr := e.get(0)?

    mut combined_name := ""
    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?
    case:
    }

    // 3. Struct constructor - create instance like eval does (before arg transform)
    if not(combined_name.eq("")) {
        mut struct_found := false
        _dummy_struct := context.scope_stack.lookup_struct(combined_name)?
        struct_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if struct_found {
            _ := create_default_instance(context, combined_name, e)?
            switch func_expr.node_type {
            case NodeType.Identifier(id_name):
                if func_expr.params.len().eq(0) {
                    insert_struct_instance(context, id_name, combined_name, e)?
                }
            case:
            }
            // Transform arguments for struct constructor
            mut struct_params := Vec.new(Expr)
            for p: Expr in e.params {
                struct_params.push(precomp_expr(context, p)?)
            }
            return Expr.new_clone(e.node_type, e, struct_params)
        }
    }

    // 4. Enum constructor (e.g., Color.Green(true)) - before arg transform
    if context.scope_stack.is_enum_constructor(combined_name) {
        // Transform arguments for enum constructor
        mut enum_params := Vec.new(Expr)
        for p: Expr in e.params {
            enum_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(e.node_type, e, enum_params)
    }

    // 5. Transform all arguments
    mut transformed_params := Vec.new(Expr)
    for p: Expr in e.params {
        transformed_params.push(precomp_expr(context, p)?)
    }
    mut new_e := Expr.new_clone(e.node_type, e, transformed_params)

    // Get func_expr again from transformed expression
    if new_e.params.len().eq(0) {
        return new_e
    }
    func_expr = new_e.get(0)?

    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?

        // 6. Handle ext functions and import()
        mut func_found := false
        mut func_def := context.scope_stack.lookup_func(combined_name)?
        func_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if func_found {
            // Ext functions: evaluation happens through eval_comptime path (see doc/precomp.org)
            // Exception: import() must run during precomp to load code
            if func_def.is_ext() {
                mut parts := combined_name.split(".")?
                if parts.len().gt(0) {
                    mut last_part := ""
                    parts.get(parts.len().sub(1), last_part)?
                    if last_part.eq("import") {
                        _ := eval_expr(context, new_e)?
                    }
                }
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_fcall: ", err.msg)
    }

    // No transformation needed (UFCS already resolved in ufcs phase)
    return new_e
}
