mode liba

import("self.init")
import("self.interpreter")
import("self.precomp_ext")

// Precomputation phase: Performs compile-time constant folding for pure functions
// and handles struct/enum constructors and import().
// This phase runs after ufcs, before interpreter/builder.

// ---------- Issue #105: Early struct macro expansion

/// Build a substitution map from macro Type/Dynamic parameters to actual type names.
/// For `make_vec3(I64)` where `make_vec3` takes `T: Type`, returns {"T": "I64"}.
build_type_param_subs : func(func_def: FuncDef, fcall: Expr) returns Map throws Str = {
    mut subs := Map.new(Str, Str)
    for i in 0..func_def.sig.args.len() {
        arg := cast(Declaration, func_def.sig.args.get(i)?)
        switch arg.value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("Type").or(type_name.eq("Dynamic")) {
                // FCall params: [0] = function name identifier, [1..] = arguments
                if fcall.params.len().gt(i.add(1)) {
                    actual_arg := cast(Expr, fcall.params.get(i.add(1))?)
                    switch actual_arg.node_type {
                    case NodeType.Identifier(actual_type_name):
                        subs.set(arg.name, actual_type_name)
                    case:
                    }
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("build_type_param_subs: ", err.msg)
    }

    return subs
}

/// Recursively replace Identifier nodes matching type param names with concrete types.
substitute_type_params_in_expr : func(e: Expr, subs: Map) returns Expr = {
    switch e.node_type {
    case NodeType.Identifier(name):
        mut new_name := name
        sub_val := cast(Str, subs.get(name)?)
        new_name = sub_val
        catch (_err: KeyNotFoundError) {
            // Expected: not all identifiers are type params
        }
        mut new_params := Vec.new(Expr)
        for p: Expr in e.params {
            new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.Identifier(new_name), e, new_params)
    case NodeType.FuncDef(func_def):
        new_func_def := substitute_type_params_in_funcdef(func_def, subs)
        mut funcdef_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            funcdef_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, funcdef_new_params)
    // Issue #106: Substitute type params in enum variant payload types
    case NodeType.EnumDef(enum_def):
        new_enum := substitute_type_params_in_enum(enum_def, subs)
        mut enumdef_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            enumdef_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.EnumDef(new_enum), e, enumdef_new_params)
    // Issue #106: Substitute type params in switch-case pattern variant names
    case NodeType.Pattern(pattern_info):
        mut new_variant_name := pattern_info.variant_name.clone()
        // Pattern variant_name format is "EnumType.Variant" - substitute the enum type prefix
        dot_pos := pattern_info.variant_name.find(".")
        if dot_pos.gteq(0) {
            enum_prefix := pattern_info.variant_name.get_substr(0, dot_pos)?
            catch (_err: IndexOutOfBoundsError) {
                panic(loc(), "substitute_type_params_in_expr: get_substr failed on pattern variant_name")
            }
            prefix_sub := cast(Str, subs.get(enum_prefix)?)
            variant_suffix := pattern_info.variant_name.get_substr(dot_pos, pattern_info.variant_name.len())?
            catch (_err2: IndexOutOfBoundsError) {
                panic(loc(), "substitute_type_params_in_expr: get_substr failed on pattern variant_name suffix")
            }
            new_variant_name = format(prefix_sub, variant_suffix)
            catch (_err: KeyNotFoundError) {
                // Expected: enum prefix not in subs
            }
        }
        return Expr.new_clone(NodeType.Pattern(PatternInfo(variant_name=new_variant_name, binding_var=pattern_info.binding_var.clone())), e, Vec.new(Expr))
    case:
        mut default_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            default_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(e.node_type, e, default_new_params)
    }
}

/// Substitute type param names in a FuncDef's args, return types, throw types, and body.
substitute_type_params_in_funcdef : func(func_def: FuncDef, subs: Map) returns FuncDef = {
    mut new_args := Vec.new(Declaration)
    for arg: Declaration in func_def.sig.args {
        mut substituted := false
        switch arg.value_type {
        case ValueType.TCustom(type_name):
            concrete := cast(Str, subs.get(type_name)?)
            new_args.push(Declaration(name=arg.name, value_type=ValueType.TCustom(concrete), is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))
            substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(substituted) {
            new_args.push(arg)
        }
    }
    mut new_returns := Vec.new(ValueType)
    for rt: ValueType in func_def.sig.return_types {
        mut rt_substituted := false
        switch rt {
        case ValueType.TCustom(type_name):
            rt_concrete := cast(Str, subs.get(type_name)?)
            new_returns.push(ValueType.TCustom(rt_concrete))
            rt_substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(rt_substituted) {
            new_returns.push(rt)
        }
    }
    mut new_throws := Vec.new(ValueType)
    for tt: ValueType in func_def.sig.throw_types {
        mut tt_substituted := false
        switch tt {
        case ValueType.TCustom(type_name):
            tt_concrete := cast(Str, subs.get(type_name)?)
            new_throws.push(ValueType.TCustom(tt_concrete))
            tt_substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(tt_substituted) {
            new_throws.push(tt)
        }
    }
    mut new_body := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        new_body.push(substitute_type_params_in_expr(stmt, subs))
    }
    mut new_func_def := FuncDef()
    new_func_def.sig = FuncSig(
        function_type=func_def.sig.function_type,
        args=new_args,
        return_types=new_returns,
        throw_types=new_throws
    )
    new_func_def.arg_names = func_def.arg_names.clone()
    new_func_def.body = new_body
    new_func_def.source_path = func_def.source_path.clone()
    return new_func_def
}

/// Apply type param substitution to a struct definition's member types and default values.
substitute_type_params_in_struct : func(struct_def: StructDef, subs: Map) returns StructDef = {
    mut new_members := Vec.new(Declaration)
    for member: Declaration in struct_def.members {
        mut substituted := false
        switch member.value_type {
        case ValueType.TCustom(type_name):
            concrete_type := cast(Str, subs.get(type_name)?)
            new_members.push(Declaration(name=member.name, value_type=ValueType.TCustom(concrete_type), is_mut=member.is_mut, is_copy=member.is_copy, is_own=member.is_own))
            substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(substituted) {
            new_members.push(member)
        }
    }

    mut new_defaults := Map.new(Str, Expr)
    for name: Str in struct_def.default_values.keys {
        expr := cast(Expr, struct_def.default_values.get(name)?)
        catch (err: KeyNotFoundError) {
            panic(loc(), format("KeyNotFoundError iterating keys: ", err.msg))
        }
        new_defaults.set(name, substitute_type_params_in_expr(expr, subs))
    }

    return StructDef(members=new_members, default_values=new_defaults)
}

/// Issue #106: Apply type param substitution to an enum definition's variant payload types.
substitute_type_params_in_enum : func(enum_def: EnumDef, subs: Map) returns EnumDef = {
    mut new_variants := Vec.new(EnumVariant)
    for v: EnumVariant in enum_def.variants {
        if not(v.payload_type.is_null()) {
            // Read the ValueType from the Ptr
            mut pt := ValueType.TCustom("")
            memcpy(to_ptr(pt), v.payload_type.data, size_of(ValueType))
            switch pt {
            case ValueType.TCustom(type_name):
                sub_val := cast(Str, subs.get(type_name)?)
                // Build new variant with substituted payload type
                mut new_payload := ValueType.TCustom(sub_val)
                mut new_variant := EnumVariant()
                new_variant.name = v.name.clone()
                new_variant.payload_type.data = malloc(size_of(ValueType))?
                catch (err: BadAlloc) { panic(loc(), "substitute_type_params_in_enum: malloc failed") }
                memcpy(new_variant.payload_type.data, to_ptr(new_payload), size_of(ValueType))
                new_variants.push(new_variant)
                catch (_err: KeyNotFoundError) {
                    new_variants.push(v.clone())
                }
            case:
                new_variants.push(v.clone())
            }
        } else {
            new_variants.push(v.clone())
        }
    }
    return EnumDef(variants=new_variants, methods=enum_def.methods.clone())
}

/// Extract namespace stmts from a macro's body AST.
/// Scans for Return nodes or Declaration nodes containing a StructDef or EnumDef with params (namespace stmts).
/// Returns the first matching set of namespace params (simple macros only).
extract_namespace_from_macro : func(func_def: FuncDef) returns NamespaceDef = {
    for stmt: Expr in func_def.body {
        // Pattern 1: return struct/enum { ... namespace: ... }
        switch stmt.node_type {
        case NodeType.Return:
            if stmt.params.len().gt(0) {
                ret_val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_namespace_from_macro: IndexOutOfBoundsError after len check")
                }
                switch ret_val.node_type {
                case NodeType.StructDef(struct_def):
                    if struct_def.ns.members.len().gt(0) {
                        return struct_def.ns.clone()
                    }
                case NodeType.EnumDef(enum_def):
                    if enum_def.ns.members.len().gt(0) {
                        return enum_def.ns.clone()
                    }
                case:
                }
            }
        case:
        }
        // Pattern 2: TemplatedPtr/TemplatedOption := struct/enum { ... namespace: ... }
        switch stmt.node_type {
        case NodeType.Declaration(_):
            if stmt.params.len().gt(0) {
                val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_namespace_from_macro: IndexOutOfBoundsError after len check")
                }
                switch val.node_type {
                case NodeType.StructDef(struct_def):
                    if struct_def.ns.members.len().gt(0) {
                        return struct_def.ns.clone()
                    }
                case NodeType.EnumDef(enum_def):
                    if enum_def.ns.members.len().gt(0) {
                        return enum_def.ns.clone()
                    }
                case:
                }
            }
        case:
        }
    }
    return NamespaceDef()
}

/// Extract the internal type name from a macro body (e.g., "TemplatedPtr" from
/// `TemplatedPtr := struct { ... }` or "TemplatedOption" from `TemplatedOption := enum { ... }`).
/// Returns empty string for anonymous types (`return struct/enum { ... }`).
extract_internal_type_name : func(func_def: FuncDef) returns Str = {
    for stmt: Expr in func_def.body {
        switch stmt.node_type {
        case NodeType.Declaration(inner_decl):
            if stmt.params.len().gt(0) {
                val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_internal_type_name: IndexOutOfBoundsError after len check")
                }
                mut is_type_def := false
                switch val.node_type {
                case NodeType.StructDef(_):
                    is_type_def = true
                case NodeType.EnumDef(_):
                    is_type_def = true
                case:
                }
                if is_type_def {
                    return inner_decl.name
                }
            }
        case:
        }
    }
    return ""
}

/// Issue #105: Expand struct-returning macros before type checking.
/// Runs between init and typer to make struct definitions available for type checking.
/// Only expands macros at the top-level body that return struct definitions.
expand_struct_macros : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.Body:
    case:
        return e.clone()
    }

    mut new_params := Vec.new(Expr)
    mut modified := false

    for p: Expr in e.params {
        mut handled := false
        switch p.node_type {
        case NodeType.Declaration(decl):
            if p.params.len().gt(0) {
                inner_e := p.get(0)?
                switch inner_e.node_type {
                case NodeType.FCall(_):
                    // Issue #105: anonymous struct instantiation - struct { ... }(args)
                    if inner_e.params.len().gt(0) {
                        esm_first_param := inner_e.get(0)?
                        mut esm_is_anon_struct := false
                        switch esm_first_param.node_type {
                        case NodeType.StructDef(esm_struct_def):
                            esm_is_anon_struct = true
                            esm_temp_name := format("AnonStruct", I64.to_str(context.anon_struct_counter))
                            context.anon_struct_counter.inc()
                            context.scope_stack.declare_struct(esm_temp_name, esm_struct_def.clone())?
                            context.scope_stack.declare_symbol(esm_temp_name.clone(), SymbolInfo(value_type=ValueType.TType(TTypeDef.TStructDef), is_mut=false, is_copy=false, is_own=false, is_comptime_const=false))?
                            // Register immutable fields as namespace constants
                            for esm_member_decl: Declaration in esm_struct_def.members {
                                if not(esm_member_decl.is_mut) {
                                    mut esm_has_default := false
                                    esm_member_expr := cast(Expr, esm_struct_def.default_values.get(esm_member_decl.name)?)
                                    esm_has_default = true
                                    catch (_err: KeyNotFoundError) { }
                                    if esm_has_default {
                                        mut esm_member_vt := ValueType.TCustom(INFER_TYPE)
                                        esm_member_vt = get_value_type(context, esm_member_expr)?
                                        catch (_err: Str) { }
                                        esm_member_full_name := format(esm_temp_name, ".", esm_member_decl.name)
                                        context.scope_stack.declare_symbol(esm_member_full_name, SymbolInfo(value_type=esm_member_vt, is_mut=esm_member_decl.is_mut, is_copy=esm_member_decl.is_copy, is_own=esm_member_decl.is_own, is_comptime_const=false))?
                                    }
                                }
                            }
                            // Generate struct methods (delete/clone) and set on ns
                            esm_auto_ns := generate_struct_methods(esm_temp_name, esm_struct_def.clone(), p.line, p.col)
                            mut esm_final_struct_def := esm_struct_def.clone()
                            if esm_auto_ns.members.len().gt(0) {
                                esm_final_struct_def.ns = esm_auto_ns
                                // Register ns methods via init helper
                                mut esm_ns_errors := Vec.new(Str)
                                init_namespace_into_struct(context, esm_temp_name, esm_final_struct_def.ns, p, esm_ns_errors)?
                                if esm_ns_errors.len().gt(0) {
                                    throw esm_ns_errors.join("\n")
                                }
                            }
                            // Re-register the struct with ns
                            context.scope_stack.declare_struct(esm_temp_name.clone(), esm_final_struct_def.clone())?
                            // Build struct definition declaration for codegen
                            mut esm_struct_decl := Declaration()
                            esm_struct_decl.name = esm_temp_name.clone()
                            esm_struct_decl.value_type = ValueType.TType(TTypeDef.TStructDef)
                            esm_struct_decl.is_mut = false
                            esm_struct_decl.is_copy = false
                            esm_struct_decl.is_own = false
                            mut esm_decl_params := Vec.new(Expr)
                            esm_decl_params.push(Expr.new_clone(NodeType.StructDef(esm_final_struct_def), esm_first_param, Vec.new(Expr)))
                            esm_struct_decl_expr := Expr.new_clone(NodeType.Declaration(esm_struct_decl), esm_first_param, esm_decl_params)
                            new_params.push(esm_struct_decl_expr)
                            // Replace StructDef with Identifier in the FCall
                            esm_id_expr := Expr.new_clone(NodeType.Identifier(esm_temp_name.clone()), esm_first_param, Vec.new(Expr))
                            mut esm_fcall_params := Vec.new(Expr)
                            esm_fcall_params.push(esm_id_expr)
                            mut esm_skip := true
                            for esm_ip: Expr in inner_e.params {
                                if esm_skip {
                                    esm_skip = false
                                } else {
                                    esm_fcall_params.push(esm_ip.clone())
                                }
                            }
                            esm_new_fcall := Expr.new_clone(inner_e.node_type, inner_e, esm_fcall_params)
                            mut esm_new_p_params := Vec.new(Expr)
                            esm_new_p_params.push(esm_new_fcall)
                            esm_new_p := Expr.new_clone(p.node_type, p, esm_new_p_params)
                            new_params.push(esm_new_p)
                            modified = true
                            handled = true
                        case:
                        }
                        if esm_is_anon_struct {
                            // Already handled above, skip to next param
                        } else {
                    // Check if the function is a macro returning struct
                    f_name := get_func_name_in_call(inner_e)?
                    mut found_func := false
                    mut func_def := FuncDef()
                    func_def = context.scope_stack.lookup_func(f_name)?
                    found_func = true
                    catch (_err: KeyNotFoundError) {
                        // Expected: not all calls are to known functions
                    }
                    if found_func {
                        if func_def.is_macro() {
                            if func_def.sig.return_types.len().gt(0) {
                                // Extract all data from func_def before mutable borrows
                                macro_return_type := cast(ValueType, func_def.sig.return_types.get(0)?)
                                catch (_err: IndexOutOfBoundsError) {
                                    panic(loc(), "IndexOutOfBoundsError getting return type after len check")
                                }
                                type_subs := build_type_param_subs(func_def, inner_e)?
                                macro_ns := extract_namespace_from_macro(func_def)
                                macro_internal_name := extract_internal_type_name(func_def)

                                // Check for struct-returning macro
                                mut is_struct_macro := false
                                switch macro_return_type {
                                case ValueType.TType(TTypeDef.TStructDef):
                                    is_struct_macro = true
                                case:
                                }
                                if is_struct_macro {
                                    // Expand the macro (mutably borrows context)
                                    expanded := eval_comptime(context, inner_e)?
                                    switch expanded.node_type {
                                    case NodeType.StructDef(struct_def):
                                        // Substitute type params (e.g. T -> I64) in member types and defaults
                                        mut substituted := struct_def.clone()
                                        if type_subs.keys.len().gt(0) {
                                            substituted = substitute_type_params_in_struct(struct_def, type_subs)
                                        }
                                        // Resolve INFER_TYPE in struct members from default values
                                        mut resolved_members := Vec.new(Declaration)
                                        for member_decl: Declaration in substituted.members {
                                            mut resolved := false
                                            switch member_decl.value_type {
                                            case ValueType.TCustom(type_name):
                                                if type_name.eq(INFER_TYPE) {
                                                    default_value := cast(Expr, substituted.default_values.get(member_decl.name)?)
                                                    mut resolved_type := get_value_type(context, default_value)?
                                                    catch (_err: Str) {}
                                                    resolved_member := Declaration(name=member_decl.name, value_type=resolved_type, is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own)
                                                    resolved_members.push(resolved_member)
                                                    resolved = true
                                                    catch (_err: KeyNotFoundError) {
                                                        // Expected: not all members have defaults
                                                    }
                                                }
                                            case:
                                            }
                                            if not(resolved) {
                                                resolved_members.push(member_decl)
                                            }
                                        }
                                        // Issue #105: Precompute struct default values (e.g. NULL -> 0)
                                        // Defaults come from macro body AST and weren't processed by precomp
                                        mut precomputed_defaults := Map.new(Str, Expr)
                                        mut cur_def_key := ""
                                        for def_key: Str in substituted.default_values.keys {
                                            cur_def_key = def_key
                                            def_val := cast(Expr, substituted.default_values.get(def_key)?)
                                            catch (err: KeyNotFoundError) {
                                                panic(loc(), format("KeyNotFoundError iterating keys: ", err.msg))
                                            }
                                            mut precomputed := precomp_expr(context, def_val)?
                                            precomputed_defaults.set(cur_def_key, precomputed)
                                            catch (_err: Str) {
                                                precomputed_defaults.set(cur_def_key, def_val)
                                            }
                                        }
                                        // Build combined ns: auto-generated + user-defined from macro namespace
                                        mut combined_ns := NamespaceDef()
                                        // Check if macro namespace already defines delete/clone
                                        mut ns_has_delete := false
                                        mut ns_has_clone := false
                                        for ns_m: Declaration in macro_ns.members {
                                            if ns_m.name.eq("delete") { ns_has_delete = true }
                                            if ns_m.name.eq("clone") { ns_has_clone = true }
                                        }
                                        // Generate auto delete/clone methods
                                        mut auto_struct := StructDef(members=resolved_members.clone(), default_values=precomputed_defaults.clone())
                                        dummy := Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), 0, 0)
                                        if ns_has_delete { auto_struct.default_values.set("delete", dummy.clone()) }
                                        if ns_has_clone { auto_struct.default_values.set("clone", dummy) }
                                        auto_ns := generate_struct_methods(decl.name, auto_struct, p.line, p.col)
                                        if auto_ns.members.len().gt(0) {
                                            for auto_m: Declaration in auto_ns.members {
                                                combined_ns.members.push(auto_m.clone())
                                            }
                                            for auto_k: Str in auto_ns.default_values.keys {
                                                auto_v := cast(Expr, auto_ns.default_values.get(auto_k)?)
                                                combined_ns.default_values.set(auto_k.clone(), auto_v.clone())
                                            }
                                            catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
                                        }
                                        // Merge user namespace from macro body (with type param substitution)
                                        if macro_ns.members.len().gt(0) {
                                            mut ns_subs := type_subs.clone()
                                            if not(macro_internal_name.eq("")) {
                                                ns_subs.set(macro_internal_name, decl.name)
                                            }
                                            for user_member: Declaration in macro_ns.members {
                                                // User methods override auto-generated ones
                                                mut new_combined_members := Vec.new(Declaration)
                                                for cm: Declaration in combined_ns.members {
                                                    if not(cm.name.eq(user_member.name)) {
                                                        new_combined_members.push(cm.clone())
                                                    }
                                                }
                                                combined_ns.members.delete()
                                                combined_ns.members = new_combined_members
                                                combined_ns.members.push(user_member.clone())
                                            }
                                            for user_ns_name: Str in macro_ns.default_values.keys {
                                                user_ns_val := cast(Expr, macro_ns.default_values.get(user_ns_name)?)
                                                substituted_val := substitute_type_params_in_expr(user_ns_val, ns_subs)
                                                combined_ns.default_values.set(user_ns_name.clone(), substituted_val)
                                            }
                                            catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
                                        }
                                        resolved_struct := StructDef(members=resolved_members, default_values=precomputed_defaults, ns=combined_ns)
                                        resolved_expanded := Expr.new_clone(NodeType.StructDef(resolved_struct.clone()), expanded, Vec.new(Expr))
                                        // Register the struct in context
                                        context.scope_stack.declare_struct(decl.name, resolved_struct.clone())?
                                        // Register immutable fields as namespace constants (same as init_context for regular structs)
                                        for member_decl: Declaration in resolved_struct.members {
                                            if not(member_decl.is_mut) {
                                                mut has_default_value := false
                                                member_expr := cast(Expr, resolved_struct.default_values.get(member_decl.name)?)
                                                has_default_value = true
                                                catch (key_err: KeyNotFoundError) {
                                                    // No default value, skip this member
                                                }
                                                if has_default_value {
                                                    mut member_value_type := ValueType.TCustom(INFER_TYPE)
                                                    member_value_type = get_value_type(context, member_expr)?
                                                    catch (err: Str) {
                                                        // Failed to get type - just use INFER_TYPE default
                                                    }
                                                    member_full_name := format(decl.name, ".", member_decl.name)
                                                    ScopeStack.declare_symbol(context.scope_stack, member_full_name.clone(), SymbolInfo(value_type=value_type_clone(member_value_type), is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own))?
                                                }
                                            }
                                        }
                                        // Register ns methods via init helper
                                        if resolved_struct.ns.members.len().gt(0) {
                                            mut ns_errors := Vec.new(Str)
                                            init_namespace_into_struct(context, decl.name, resolved_struct.ns, p, ns_errors)?
                                            if ns_errors.len().gt(0) {
                                                throw ns_errors.join("\n")
                                            }
                                        }
                                        // Replace the FCall with the StructDef in the AST
                                        mut expanded_params := Vec.new(Expr)
                                        expanded_params.push(resolved_expanded)
                                        new_p := Expr.new_clone(p.node_type, p, expanded_params)
                                        new_params.push(new_p)
                                        modified = true
                                        handled = true
                                    case:
                                    }
                                }
                                // Issue #106: Check if macro returns an enum definition
                                mut is_enum_macro := false
                                switch macro_return_type {
                                case ValueType.TType(TTypeDef.TEnumDef):
                                    is_enum_macro = true
                                case:
                                }
                                if is_enum_macro.and(not(handled)) {
                                    // Expand the macro
                                    enum_expanded := eval_comptime(context, inner_e)?
                                    switch enum_expanded.node_type {
                                    case NodeType.EnumDef(enum_def):
                                        // Substitute type params in variant payload types
                                        mut enum_substituted := enum_def.clone()
                                        if type_subs.keys.len().gt(0) {
                                            enum_substituted = substitute_type_params_in_enum(enum_def, type_subs)
                                        }
                                        // Clear preinit-generated methods (they reference the internal name)
                                        enum_substituted.methods = Map.new(Str, Expr)
                                        // Build combined ns: auto-generated + user-defined from macro namespace
                                        mut enum_combined_ns := NamespaceDef()
                                        mut enum_ns_has_delete := false
                                        mut enum_ns_has_clone := false
                                        for enum_ns_m: Declaration in macro_ns.members {
                                            if enum_ns_m.name.eq("delete") { enum_ns_has_delete = true }
                                            if enum_ns_m.name.eq("clone") { enum_ns_has_clone = true }
                                        }
                                        auto_enum_ns := generate_enum_methods(decl.name, enum_ns_has_delete, enum_ns_has_clone, p.line, p.col)
                                        if auto_enum_ns.members.len().gt(0) {
                                            for auto_em: Declaration in auto_enum_ns.members {
                                                enum_combined_ns.members.push(auto_em.clone())
                                            }
                                            for auto_ek: Str in auto_enum_ns.default_values.keys {
                                                auto_ev := cast(Expr, auto_enum_ns.default_values.get(auto_ek)?)
                                                enum_combined_ns.default_values.set(auto_ek.clone(), auto_ev.clone())
                                            }
                                            catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
                                        }
                                        // Merge user namespace from macro body (with type param substitution)
                                        if macro_ns.members.len().gt(0) {
                                            mut enum_ns_subs := type_subs.clone()
                                            if not(macro_internal_name.eq("")) {
                                                enum_ns_subs.set(macro_internal_name, decl.name)
                                            }
                                            for enum_user_member: Declaration in macro_ns.members {
                                                mut enum_new_combined := Vec.new(Declaration)
                                                for ecm: Declaration in enum_combined_ns.members {
                                                    if not(ecm.name.eq(enum_user_member.name)) {
                                                        enum_new_combined.push(ecm.clone())
                                                    }
                                                }
                                                enum_combined_ns.members.delete()
                                                enum_combined_ns.members = enum_new_combined
                                                enum_combined_ns.members.push(enum_user_member.clone())
                                            }
                                            for enum_user_name: Str in macro_ns.default_values.keys {
                                                enum_user_val := cast(Expr, macro_ns.default_values.get(enum_user_name)?)
                                                enum_sub_val := substitute_type_params_in_expr(enum_user_val, enum_ns_subs)
                                                enum_combined_ns.default_values.set(enum_user_name.clone(), enum_sub_val)
                                            }
                                            catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
                                        }
                                        enum_substituted.ns = enum_combined_ns
                                        enum_resolved_expanded := Expr.new_clone(NodeType.EnumDef(enum_substituted.clone()), enum_expanded, Vec.new(Expr))
                                        // Register the enum in context
                                        context.scope_stack.declare_enum(decl.name, enum_substituted.clone())?
                                        // Register ns methods via init helper
                                        if enum_substituted.ns.members.len().gt(0) {
                                            mut enum_ns_errors := Vec.new(Str)
                                            init_namespace_into_enum(context, decl.name, enum_substituted.ns, p, enum_ns_errors)?
                                            if enum_ns_errors.len().gt(0) {
                                                throw enum_ns_errors.join("\n")
                                            }
                                        }
                                        // Replace the FCall with the EnumDef in the AST
                                        mut enum_expanded_params := Vec.new(Expr)
                                        enum_expanded_params.push(enum_resolved_expanded)
                                        enum_new_p := Expr.new_clone(p.node_type, p, enum_expanded_params)
                                        new_params.push(enum_new_p)
                                        modified = true
                                        handled = true
                                    case:
                                    }
                                }
                            }
                        }
                    }
                        } // else (not anon struct)
                    } // if inner_e.params.len().gt(0)
                case:
                }
            }
        case:
        }
        if not(handled) {
            // Issue #105: Recurse into function/proc body to expand anonymous struct FCalls
            mut pending_decls := Vec.new(Expr)
            mut was_expanded := false
            expanded_p := expand_anon_struct_fcalls_recursive(context, p, pending_decls, was_expanded)?
            if pending_decls.len().gt(0) {
                for pd: Expr in pending_decls {
                    new_params.push(pd.clone())
                }
                modified = true
            }
            if was_expanded {
                new_params.push(expanded_p)
                modified = true
            } else {
                new_params.push(p)
            }
        }
    }

    if modified {
        return Expr.new_clone(e.node_type, e, new_params)
    }
    return e.clone()
}

/// Issue #105: Recursively walk an expression and expand anonymous struct FCall instantiations.
/// Sets was_expanded to true and returns modified expr if any change was made.
/// pending_decls collects struct declarations + namespace blocks to inject at top level.
expand_anon_struct_fcalls_recursive : proc(mut context: Context, e: Expr, mut pending_decls: Vec, mut was_expanded: Bool) returns Expr throws Str = {
    // Check if this is an FCall with a StructDef first param
    mut is_anon_fcall := false
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            ear_first := e.get(0)?
            switch ear_first.node_type {
            case NodeType.StructDef(ear_sd):
                is_anon_fcall = true
                ear_temp := format("AnonStruct", I64.to_str(context.anon_struct_counter))
                context.anon_struct_counter.inc()
                context.scope_stack.declare_struct(ear_temp, ear_sd.clone())?
                context.scope_stack.declare_symbol(ear_temp.clone(), SymbolInfo(value_type=ValueType.TType(TTypeDef.TStructDef), is_mut=false, is_copy=false, is_own=false, is_comptime_const=false))?
                // Register immutable fields as namespace constants
                for ear_md: Declaration in ear_sd.members {
                    if not(ear_md.is_mut) {
                        mut ear_has_def := false
                        ear_me := cast(Expr, ear_sd.default_values.get(ear_md.name)?)
                        ear_has_def = true
                        catch (_err: KeyNotFoundError) { }
                        if ear_has_def {
                            mut ear_mvt := ValueType.TCustom(INFER_TYPE)
                            ear_mvt = get_value_type(context, ear_me)?
                            catch (_err: Str) { }
                            ear_mfn := format(ear_temp, ".", ear_md.name)
                            context.scope_stack.declare_symbol(ear_mfn, SymbolInfo(value_type=ear_mvt, is_mut=ear_md.is_mut, is_copy=ear_md.is_copy, is_own=ear_md.is_own, is_comptime_const=false))?
                        }
                    }
                }
                // Generate struct methods (delete/clone) and set on ns
                ear_auto_ns := generate_struct_methods(ear_temp, ear_sd.clone(), e.line, e.col)
                mut ear_final_sd := ear_sd.clone()
                if ear_auto_ns.members.len().gt(0) {
                    ear_final_sd.ns = ear_auto_ns
                    mut ear_ns_errors := Vec.new(Str)
                    init_namespace_into_struct(context, ear_temp, ear_final_sd.ns, e, ear_ns_errors)?
                    if ear_ns_errors.len().gt(0) {
                        throw ear_ns_errors.join("\n")
                    }
                }
                context.scope_stack.declare_struct(ear_temp.clone(), ear_final_sd.clone())?
                // Build struct definition declaration for codegen
                mut ear_decl := Declaration()
                ear_decl.name = ear_temp.clone()
                ear_decl.value_type = ValueType.TType(TTypeDef.TStructDef)
                ear_decl.is_mut = false
                ear_decl.is_copy = false
                ear_decl.is_own = false
                mut ear_dp := Vec.new(Expr)
                ear_dp.push(Expr.new_clone(NodeType.StructDef(ear_final_sd), ear_first, Vec.new(Expr)))
                ear_decl_expr := Expr.new_clone(NodeType.Declaration(ear_decl), ear_first, ear_dp)
                pending_decls.push(ear_decl_expr)
                // Replace StructDef with Identifier in the FCall
                ear_id := Expr.new_clone(NodeType.Identifier(ear_temp.clone()), ear_first, Vec.new(Expr))
                mut ear_fp := Vec.new(Expr)
                ear_fp.push(ear_id)
                mut ear_skip := true
                for ear_p: Expr in e.params {
                    if ear_skip {
                        ear_skip = false
                    } else {
                        ear_fp.push(ear_p.clone())
                    }
                }
                was_expanded = true
                return Expr.new_clone(e.node_type, e, ear_fp)
            case:
            }
        }
    case:
    }

    // Check if this is a Declaration with a StructDef value (e.g. P := struct { ... })
    // Only process if the struct isn't already registered (avoids duplicating top-level structs)
    switch e.node_type {
    case NodeType.Declaration(ear_decl):
        if e.params.len().gt(0) {
            ear_decl_inner := e.get(0)?
            switch ear_decl_inner.node_type {
            case NodeType.StructDef(ear_decl_sd):
                if context.scope_stack.has_struct(ear_decl.name) {
                    // Already registered at top level - skip
                    return e.clone()
                }
                // Register the struct with the declared name
                context.scope_stack.declare_struct(ear_decl.name, ear_decl_sd.clone())?
                context.scope_stack.declare_symbol(ear_decl.name.clone(), SymbolInfo(value_type=ValueType.TType(TTypeDef.TStructDef), is_mut=false, is_copy=false, is_own=false, is_comptime_const=false))?
                // Register immutable fields as namespace constants
                for ear_decl_md: Declaration in ear_decl_sd.members {
                    if not(ear_decl_md.is_mut) {
                        mut ear_decl_has_def := false
                        ear_decl_me := cast(Expr, ear_decl_sd.default_values.get(ear_decl_md.name)?)
                        ear_decl_has_def = true
                        catch (_err: KeyNotFoundError) { }
                        if ear_decl_has_def {
                            mut ear_decl_mvt := ValueType.TCustom(INFER_TYPE)
                            ear_decl_mvt = get_value_type(context, ear_decl_me)?
                            catch (_err: Str) { }
                            ear_decl_mfn := format(ear_decl.name, ".", ear_decl_md.name)
                            context.scope_stack.declare_symbol(ear_decl_mfn, SymbolInfo(value_type=ear_decl_mvt, is_mut=ear_decl_md.is_mut, is_copy=ear_decl_md.is_copy, is_own=ear_decl_md.is_own, is_comptime_const=false))?
                        }
                    }
                }
                // Generate struct methods (delete/clone) and set on ns
                ear_decl_auto_ns := generate_struct_methods(ear_decl.name, ear_decl_sd.clone(), e.line, e.col)
                mut ear_decl_final_sd := ear_decl_sd.clone()
                if ear_decl_auto_ns.members.len().gt(0) {
                    ear_decl_final_sd.ns = ear_decl_auto_ns
                    mut ear_decl_ns_errors := Vec.new(Str)
                    init_namespace_into_struct(context, ear_decl.name, ear_decl_final_sd.ns, e, ear_decl_ns_errors)?
                    if ear_decl_ns_errors.len().gt(0) {
                        throw ear_decl_ns_errors.join("\n")
                    }
                }
                context.scope_stack.declare_struct(ear_decl.name.clone(), ear_decl_final_sd.clone())?
                // Add struct definition to pending top-level decls for codegen
                pending_decls.push(e.clone())
                // Return original expression (stays in body; codegen skips TType declarations)
                was_expanded = true
                return e.clone()
            case:
            }
        }
    case:
    }

    // Recurse into child expressions
    mut ear_any_changed := false
    mut ear_new_params := Vec.new(Expr)
    for ear_cp: Expr in e.params {
        mut ear_cp_changed := false
        ear_cp_result := expand_anon_struct_fcalls_recursive(context, ear_cp, pending_decls, ear_cp_changed)?
        if ear_cp_changed {
            ear_new_params.push(ear_cp_result)
            ear_any_changed = true
        } else {
            ear_new_params.push(ear_cp.clone())
        }
    }

    // Also recurse into FuncDef bodies
    switch e.node_type {
    case NodeType.FuncDef(ear_fd):
        mut ear_body_changed := false
        mut ear_new_body := Vec.new(Expr)
        for ear_bs: Expr in ear_fd.body {
            mut ear_bs_changed := false
            ear_bs_result := expand_anon_struct_fcalls_recursive(context, ear_bs, pending_decls, ear_bs_changed)?
            if ear_bs_changed {
                ear_new_body.push(ear_bs_result)
                ear_body_changed = true
            } else {
                ear_new_body.push(ear_bs.clone())
            }
        }
        if ear_body_changed {
            mut ear_new_fd := ear_fd.clone()
            ear_new_fd.body = ear_new_body
            was_expanded = true
            return Expr.new_clone(NodeType.FuncDef(ear_new_fd), e, ear_new_params)
        }
    case:
    }

    if ear_any_changed {
        was_expanded = true
        return Expr.new_clone(e.node_type, e, ear_new_params)
    }
    return e.clone()
}

// ---------- Main entry point

/// Precomputation phase: Perform compile-time constant folding and handle
/// struct/enum constructors and import().
/// Takes an AST that has already passed type checking and UFCS resolution.
precomp_expr : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.Body:
        return precomp_body(context, e)?
    case NodeType.FCall(_):
        mut const_folded := precomp_fcall(context, e)?
        // Try compile-time constant folding for pure functions with literal args.
        // Only fold at global scope - inside function definitions, values from other
        // modules may not be available yet (import ordering). Interpreter doesn't
        // evaluate function bodies during import either.
        at_global_scope := context.scope_stack.frames.len().eq(1)

        // Check if this is a macro call - macros MUST be evaluated at compile-time
        // but only when called at global scope with comptime args (same as funcs,
        // just with an error if args aren't comptime instead of silent skip)
        is_macro_call := is_macro_fcall(context, const_folded)
        if at_global_scope.and(is_macro_call) {
            // Macros require all arguments to be compile-time evaluable
            if not(is_comptime_evaluable(context, const_folded)?) {
                f_name := get_func_name_in_call(const_folded)?
                throw const_folded.error(context.path, "precomp",
                    format("Macro '", f_name, "' requires all arguments to be compile-time constants"))
            }
            // Force compile-time evaluation
            const_folded = eval_comptime(context, const_folded)?
            return const_folded
        }

        if at_global_scope.and(is_comptime_evaluable(context, const_folded)?) {
            const_folded = eval_comptime(context, const_folded)?
        }
        return const_folded
    case NodeType.If:
        return precomp_params(context, e)?
    case NodeType.While:
        return precomp_params(context, e)?
    case NodeType.Switch:
        throw e.lang_error(context.path, "precomp", "Switch should have been desugared to if/else by desugarer phase")
    case NodeType.FuncDef(func_def):
        return precomp_func_def(context, e, func_def)?
    case NodeType.Declaration(decl):
        return precomp_declaration(context, e, decl)?
    case NodeType.Assignment:
        return precomp_params(context, e)?
    case NodeType.Return:
        return precomp_params(context, e)?
    case NodeType.Throw:
        return precomp_params(context, e)?
    case NodeType.Catch:
        return precomp_catch(context, e)?
    case NodeType.Range:
        return precomp_params(context, e)?
    // Struct/enum definitions - need to process default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        return precomp_struct_def(context, e, struct_def)?
    case NodeType.EnumDef(_):
        return e.clone()
    // Identifiers can have nested params (e.g., a.b.c for field access chains)
    case NodeType.Identifier:
        return precomp_params(context, e)?
    // Leaf nodes - no transformation needed
    case NodeType.LLiteral:
        return e.clone()
    case NodeType.DefaultCase:
        return e.clone()
    case NodeType.Pattern:
        return e.clone()
    // Break and Continue are leaf nodes (no params) - no transformation needed
    case NodeType.Break:
        return e.clone()
    case NodeType.Continue:
        return e.clone()
    // Named arguments - transform the value expression
    case NodeType.NamedArg(name):
        mut new_params := Vec.new(Expr)
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(NodeType.NamedArg(name), e, new_params)
    // ForIn should have been desugared in desugarer phase
    case NodeType.ForIn(_):
        panic(loc(), "ForIn should have been desugared in desugarer phase")
    }
}

// ---------- Compile-time constant folding

/// Check if an FCall is a macro call.
is_macro_fcall : proc(context: Context, e: Expr) returns Bool = {
    mut e_clone := e.clone()
    func_def := get_func_def_for_fcall_with_expr(context, e_clone)?
    result := func_def.is_macro()

    catch (_err: Str) {
        return false
    }
    catch (_err: KeyNotFoundError) {
        return false
    }

    return result
}

/// Check if an expression can be evaluated at compile time.
/// Currently only handles literals and pure function calls with literal arguments.
is_comptime_evaluable : proc(context: Context, e: Expr) returns Bool throws Str = {
    switch e.node_type {
    case NodeType.LLiteral:
        return true
    // Type definitions and function definitions are static metadata - always comptime
    case NodeType.StructDef:
        return true
    case NodeType.EnumDef:
        return true
    case NodeType.FuncDef:
        return true
    case NodeType.Identifier(name):
        // Check if this is a simple identifier (no field access chain)
        if e.params.len().gt(0) {
            return false  // Field access chains not supported
        }
        // Look up the symbol and check if it's a comptime const
        mut symbol := context.scope_stack.lookup_symbol(name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        return symbol.is_comptime_const
    case NodeType.FCall(_):
        f_name := get_func_name_in_call(e)?
        catch (err: Str) {
            return false  // Can't get function name
        }
        // Special case: exit terminates the program
        if f_name.eq("exit") { return false }
        // TODO: Properly detect ext_funcs and functions with side effects.
        // For now, hardcode malloc exclusion since it's an ext_func with side effects.
        if f_name.eq("malloc") { return false }

        // Use get_func_def_for_fcall_with_expr like interpreter does
        mut e_clone := e.clone()
        mut func_def := FuncDef()
        mut func_def_found := false
        func_def = get_func_def_for_fcall_with_expr(context, e_clone)?
        func_def_found = true
        catch (err: KeyNotFoundError) {
            // Could be a struct constructor - check if all args are comptime
            combined_name := get_combined_name(context.path, e.get(0)?)?
            catch (err2: Str) {
                return false
            }
            // Try to look up as struct
            mut is_struct := false
            _ := context.scope_stack.lookup_struct(combined_name)?
            is_struct = true
            catch (err3: KeyNotFoundError) {
                // REM: Not a struct
            }
            if is_struct {
                // It's a struct constructor - check all args are comptime
                mut struct_j := 1
                while struct_j.lt(e.params.len()) {
                    struct_arg := e.get(struct_j)?
                    dont_delete(struct_arg)
                    // Handle named args - check the value inside
                    mut arg_to_check := struct_arg
                    switch struct_arg.node_type {
                    case NodeType.NamedArg(_):
                        if struct_arg.params.len().gt(0) {
                            atc := cast(Expr, struct_arg.params.get(0)?)
                            arg_to_check = atc
                            catch (err5: IndexOutOfBoundsError) {
                                panic(loc(), "struct_arg.params.get(0): len > 0 checked: ", err5.msg)
                            }
                        }
                    case:
                    }
                    if not(is_comptime_evaluable(context, arg_to_check)?) {
                        return false
                    }
                    struct_j.inc()
                }
                return true  // Struct constructor with all comptime args
            }
            // Check if it's an enum constructor (e.g., Color.Green(true))
            if context.scope_stack.is_enum_constructor(combined_name) {
                // It's an enum constructor - check all args are comptime
                mut k := 1
                while k.lt(e.params.len()) {
                    arg := e.get(k)?
                    dont_delete(arg)
                    if not(is_comptime_evaluable(context, arg)?) {
                        return false
                    }
                    k.inc()
                }
                return true
            }
            return false  // Unknown function
        }
        catch (err: Str) {
            return false  // Function lookup error
        }
        if not(func_def_found) {
            return false
        }
        // Must be pure function (not proc) that returns a value
        if func_def.is_proc() {
            return false
        }
        // Funcs with no return type can't be folded (nothing to fold to)
        if func_def.sig.return_types.len().eq(0) {
            return false
        }
        // Functions that can throw are allowed - if they actually throw,
        // we'll report the error in eval_comptime.
        // All arguments must be comptime-evaluable
        mut fcall_i := 1
        while fcall_i.lt(e.params.len()) {
            fcall_arg := e.get(fcall_i)?
            dont_delete(fcall_arg)
            if not(is_comptime_evaluable(context, fcall_arg)?) {
                return false
            }
            fcall_i.inc()
        }
        return true
    case:
        return false
    }
}

/// Evaluate a comptime-evaluable expression and convert result back to AST literal.
eval_comptime : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    // Save and restore context.path - interpreter may change it during function calls
    saved_path := context.path
    result := eval_expr(context, e)?
    catch (err: Str) {
        // REM: Restore context.path before re-throwing (Rust captures Result, restores, then ?)
        context.path = saved_path
        throw err
    }
    context.path = saved_path

    // Check if the function threw an exception during evaluation
    if result.is_throw {
        mut thrown_type := result.thrown_type
        if thrown_type.eq("") {
            thrown_type = "unknown"
        }
        throw e.error(context.path, "precomp", format("Exception '", thrown_type, "' thrown during precomputation: ", result.value))
    }

    // EvalResult.value is a String representation of the value
    // Convert back to LLiteral based on the result type
    value_type := get_value_type(context, e)?
    switch value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("U8") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("Str") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Str(result.value)), e, Vec.new(Expr))
        }
        // Check if it's a struct type - result.value is the instance name
        _struct_def := context.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            // For enums and other types: eval_expr was called (catching any errors),
            // but we can't convert the result back to AST literal, so return original
            return e.clone()
        }
        // Try to convert struct back to literal, fall back to original expr if unsupported
        mut struct_literal := EvalHeap.to_struct_literal(context, result.value, type_name, e)?
        catch (err: Str) {
            return e.clone()
        }
        return struct_literal
    case ValueType.TType(TTypeDef.TStructDef):
        // Issue #105: First-class structs - macro returning a struct definition
        struct_name := result.value
        sd := context.scope_stack.lookup_struct(struct_name)?
        catch (err: KeyNotFoundError) {
            throw e.error(context.path, "precomp", format("Macro returned struct type but definition '", struct_name, "' not found"))
        }
        return Expr.new_clone(NodeType.StructDef(sd.clone()), e, Vec.new(Expr))
    // Issue #106: First-class enums - macro returning an enum definition
    case ValueType.TType(TTypeDef.TEnumDef):
        enum_name := result.value
        enum_def := context.scope_stack.lookup_enum(enum_name)?
        return Expr.new_clone(NodeType.EnumDef(enum_def.clone()), e, Vec.new(Expr))
        catch (_err: KeyNotFoundError) {
            throw e.error(context.path, "precomp", format("Macro returned enum type but definition '", enum_name, "' not found"))
        }
    case:
        // For other types, eval was done (errors caught), return original (no folding)
        return e.clone()
    }

}

// ---------- AST transformation

/// Transform Body node - recursively transform all statements
precomp_body : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        saved_decl_count := context.anon_struct_decls.len()
        result := precomp_expr(context, p)?
        // Issue #105: inject pending anonymous struct declarations before the statement that uses them
        if context.anon_struct_decls.len().gt(saved_decl_count) {
            // Drain new decls from end of list
            for pending_decl: Expr in context.anon_struct_decls {
                new_params.push(pending_decl.clone())
            }
            context.anon_struct_decls = Vec.new(Expr)
        }
        new_params.push(result)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform node params - recursively transform all child expressions
precomp_params : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        new_params.push(precomp_expr(context, p)?)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform StructDef - recursively transform default values (which contain function defs)
precomp_struct_def : proc(mut context: Context, e: Expr, struct_def: StructDef) returns Expr throws Str = {
    mut new_default_values := Map.new(Str, Expr)
    mut i := 0
    while i.lt(struct_def.default_values.keys.len()) {
        name := cast(Str, struct_def.default_values.keys.get(i)?)
        value_expr := cast(Expr, struct_def.default_values.get(name)?)

        // Bug #40 fix: For method definitions, set function name context
        mut is_func := false
        switch value_expr.node_type {
        case NodeType.FuncDef:
            is_func = true
        case:
        }
        saved_func := context.current_precomp_func
        saved_counter := context.precomp_forin_counter
        if is_func {
            context.current_precomp_func = name
            context.precomp_forin_counter = 0
        }

        new_default_values.set(name, precomp_expr(context, value_expr)?)

        // Bug #40 fix: Restore previous function context
        if is_func {
            context.current_precomp_func = saved_func
            context.precomp_forin_counter = saved_counter
        }

        i.inc()
    }
    // Also transform ns default values (namespace function bodies)
    mut ns_new_default_values := Map.new(Str, Expr)
    mut ns_i := 0
    while ns_i.lt(struct_def.ns.default_values.keys.len()) {
        ns_name := cast(Str, struct_def.ns.default_values.keys.get(ns_i)?)
        ns_value_expr := cast(Expr, struct_def.ns.default_values.get(ns_name)?)

        mut ns_is_func := false
        switch ns_value_expr.node_type {
        case NodeType.FuncDef:
            ns_is_func = true
        case:
        }
        ns_saved_func := context.current_precomp_func
        ns_saved_counter := context.precomp_forin_counter
        if ns_is_func {
            context.current_precomp_func = ns_name
            context.precomp_forin_counter = 0
        }

        ns_transformed := precomp_expr(context, ns_value_expr)?
        ns_new_default_values.set(ns_name, ns_transformed)

        if ns_is_func {
            context.current_precomp_func = ns_saved_func
            context.precomp_forin_counter = ns_saved_counter
        }

        ns_i.inc()
    }
    new_ns := NamespaceDef(
        members=struct_def.ns.members.clone(),
        default_values=ns_new_default_values
    )

    mut new_struct_def := StructDef()
    new_struct_def.members = struct_def.members.clone()
    new_struct_def.default_values = new_default_values
    new_struct_def.ns = new_ns

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_struct_def: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("precomp_struct_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params.clone())
}

/// Transform FuncDef - push scope frame for function args, transform body, pop frame
precomp_func_def : proc(mut context: Context, e: Expr, func_def: FuncDef) returns Expr throws Str = {
    // Push a new scope frame with the function's parameters
    context.scope_stack.push(ScopeType.Function)
    for arg: Declaration in func_def.sig.args {
        sym := SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
        context.scope_stack.declare_symbol(arg.name, sym)?
    }

    // Transform the function body
    mut new_body := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        new_body.push(precomp_expr(context, stmt)?)
    }

    // Pop the function scope frame
    _ := context.scope_stack.pop()?

    new_func_def := FuncDef(
        sig=FuncSig(
            function_type=func_def.sig.function_type,
            args=func_def.sig.args,
            return_types=func_def.sig.return_types,
            throw_types=func_def.sig.throw_types
        ),
        arg_names=func_def.arg_names,
        body=new_body,
        source_path=func_def.source_path
    )

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_func_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params.clone())
}

/// Transform Declaration - register the declared variable in scope, then transform value
precomp_declaration : proc(mut context: Context, e: Expr, decl: Declaration) returns Expr throws Str = {
    // Eagerly create default instance template for this struct type
    inner_e := e.get(0)?
    mut value_type := get_value_type(context, inner_e)?
    catch (err: Str) {
        throw e.lang_error(context.path, "precomp", err)
    }

    // Issue #91: Detect function signature definitions
    // A FuncDef with empty body and type-only args (no names) is a function signature type
    switch inner_e.node_type {
    case NodeType.FuncDef(func_def):
        if func_def.body.len().eq(0) {
            mut all_type_only := true
            for arg: Declaration in func_def.sig.args {
                if not(arg.name.eq("")) {
                    all_type_only = false
                }
            }
            if all_type_only {
                mut is_func_or_proc := false
                switch func_def.sig.function_type {
                case FunctionType.FTFunc:
                    is_func_or_proc = true
                case FunctionType.FTProc:
                    is_func_or_proc = true
                case:
                }
                if is_func_or_proc {
                    value_type = ValueType.TType(TTypeDef.TFuncSig)
                }
            }
        }
    case:
    }

    // Issue #105: Accept INFER_TYPE inside macro bodies (typer doesn't resolve inside FuncDef bodies)
    mut is_infer_type := false
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq(INFER_TYPE) {
            is_infer_type = true
        }
    case:
    }
    // Type checking - check for U8/I64 coercion
    mut is_u8_decl := false
    mut is_i64_value := false
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq("U8") {
            is_u8_decl = true
        }
    case:
    }
    switch value_type {
    case ValueType.TCustom(val_type_name):
        if val_type_name.eq("I64") {
            is_i64_value = true
        }
    case:
    }
    // Issue #91: Resolve function signature type references
    // When decl.value_type is a custom type name that resolves to a FunctionSig,
    // look up the signature and set value_type to match the function type.
    mut has_sig_func_def := false
    mut sig_func_def := FuncDef()
    switch decl.value_type {
    case ValueType.TCustom(sig_name):
        sig_sym := context.scope_stack.lookup_symbol(sig_name)?
        catch (err: KeyNotFoundError) {
            // Not found - not a FunctionSig reference, continue normally
        }
        if not(has_sig_func_def) {
            switch sig_sym.value_type {
            case ValueType.TType(TTypeDef.TFuncSig):
                sig_sfd := context.scope_stack.lookup_func(sig_name)?
                catch (err: KeyNotFoundError) {
                    // Should not happen if symbol has FuncSig type
                }
                if not(has_sig_func_def) {
                    sig_func_def = sig_sfd
                    has_sig_func_def = true
                    value_type = ValueType.TFunction(sig_sfd.sig.function_type)
                }
            case:
            }
        }
    case:
    }

    if is_infer_type {
        // Issue #105: Skip type checking for inferred types inside macro bodies
    } else if has_sig_func_def {
        // Issue #91: FunctionSig reference resolved above - skip type check
    } else if is_u8_decl.and(is_i64_value) {
        value_type = decl.value_type
    } else {
        // Check types match
        if not(value_type_to_str(decl.value_type).eq(value_type_to_str(value_type))) {
            throw e.lang_error(context.path, "precomp", format("'", decl.name, "' declared of type ", value_type_to_str(decl.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
        }
    }

    // Handle EnumDef early
    switch value_type {
    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(decl.name, enum_def)?
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=true))?
            // Update scope_stack with namespace FuncDefs so interpreter uses desugared versions
            for enum_ns_name: Str in enum_def.ns.default_values.keys {
                enum_ns_value_expr := cast(Expr, enum_def.ns.default_values.get(enum_ns_name)?)
                catch (err: KeyNotFoundError) {
                    panic(loc(), "enum ns update_func KeyNotFoundError: ", err.msg)
                }
                switch enum_ns_value_expr.node_type {
                case NodeType.FuncDef(enum_ns_func_def):
                    enum_ns_full_name := format(decl.name, ".", enum_ns_name)
                    context.scope_stack.update_func(enum_ns_full_name, enum_ns_func_def.clone())?
                    catch (err: Str) {
                        panic(loc(), "enum ns update_func failed: ", err)
                    }
                case:
                }
            }
            return e.clone()
        case:
            throw e.lang_error(context.path, "precomp", format("Cannot declare '", decl.name, "' of type '", value_type_to_str(decl.value_type), "', expected enum definition."))
        }
    case:
    }

    // Handle StructDef early
    // Issue #108: Don't overwrite if struct already exists with merged namespace members
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            if not(context.scope_stack.has_struct(decl.name)) {
                context.scope_stack.declare_struct(decl.name, struct_def)?
            }
            saved_path := context.path
            _ := eval_declaration(decl, context, e)?
            context.path = saved_path
        case:
        }
    case:
    }

    // Issue #91: Register function signature type and return early
    switch value_type {
    case ValueType.TType(TTypeDef.TFuncSig):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(decl.name, func_def.clone())?
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=true))?
            return e.clone()
        case:
        }
    case:
    }

    // Issue #105: If inner_e is an FCall (e.g. macro call returning struct), we need to
    // process it through precomp_expr first, then check if the result is a StructDef.
    // The struct registration for literal StructDef RHS already happened above.
    // For macro-expanded StructDefs, we do it after new_params processing below.

    // Bug #40 fix: For function declarations, set the function name and reset counter
    // BEFORE processing the body so for-in loops get deterministic names
    mut is_func_decl := false
    if e.params.len().gt(0) {
        switch inner_e.node_type {
        case NodeType.FuncDef:
            is_func_decl = true
        case:
        }
    }
    saved_func := context.current_precomp_func
    saved_counter := context.precomp_forin_counter
    if is_func_decl {
        context.current_precomp_func = decl.name
        context.precomp_forin_counter = 0
    }

    // Issue #91: Resolve arg/return/throw types from function signature into the FuncDef
    // BEFORE processing the body, so UFCS resolution inside the body knows the arg types.
    mut has_resolved_inner := false
    mut resolved_inner_e := inner_e
    if has_sig_func_def {
        switch inner_e.node_type {
        case NodeType.FuncDef(precomp_orig_fd):
            mut precomp_resolved_fd := precomp_orig_fd.clone()
            if not(precomp_resolved_fd.sig.args.len().eq(sig_func_def.sig.args.len())) {
                throw e.lang_error(context.path, "precomp", format("'", decl.name, "' has ", precomp_resolved_fd.sig.args.len().to_str(), " parameters but function signature expects ", sig_func_def.sig.args.len().to_str(), "."))
            }
            mut precomp_arg_idx := 0
            for precomp_sig_arg: Declaration in sig_func_def.sig.args {
                mut precomp_resolved_arg := cast(Declaration, precomp_resolved_fd.sig.args.get(precomp_arg_idx)?)
                precomp_resolved_arg.value_type = precomp_sig_arg.value_type
                precomp_resolved_fd.sig.args.set(precomp_arg_idx, precomp_resolved_arg)?
                precomp_arg_idx = add(precomp_arg_idx, 1)
            }
            precomp_resolved_fd.sig.return_types = sig_func_def.sig.return_types
            precomp_resolved_fd.sig.throw_types = sig_func_def.sig.throw_types
            precomp_resolved_fd.sig.function_type = sig_func_def.sig.function_type
            resolved_inner_e = Expr(node_type=NodeType.FuncDef(precomp_resolved_fd), params=inner_e.params, line=inner_e.line, col=inner_e.col)
            has_resolved_inner = true
        case:
        }
    }

    // First transform the value expression (if any)
    mut new_params := Vec.new(Expr)
    if has_resolved_inner {
        new_params.push(precomp_expr(context, resolved_inner_e)?)
    } else if e.params.len().gt(0) {
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
    }

    // Bug #40 fix: Restore previous function context
    if is_func_decl {
        context.current_precomp_func = saved_func
        context.precomp_forin_counter = saved_counter
    }

    // REM: Declarations currently always require an initialization value,
    // so new_params should never be empty.
    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "precomp", "Declarations can have only one child expression")
    }

    // Issue #105: After anonymous struct expansion, re-evaluate the type from the transformed expression
    mut is_infer := false
    switch value_type {
    case ValueType.TCustom(vt_name):
        if vt_name.eq(INFER_TYPE) {
            is_infer = true
        }
    case:
    }
    if is_infer.and(new_params.len().gt(0)) {
        new_first := cast(Expr, new_params.get(0)?)
        mut have_new_type := true
        new_type := get_value_type(context, new_first)?
        catch (_err: Str) {
            have_new_type = false
        }
        if have_new_type {
            mut new_is_infer := false
            switch new_type {
            case ValueType.TCustom(new_vt_name):
                if new_vt_name.eq(INFER_TYPE) {
                    new_is_infer = true
                }
            case:
            }
            if not(new_is_infer) {
                value_type = new_type
            }
        }
    }

    // Issue #105: After macro expansion, check if the result is a StructDef
    // and register it (the pre-expansion check above only handles literal StructDef RHS)
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        if new_params.len().gt(0) {
            expanded_param := cast(Expr, new_params.get(0)?)
            switch expanded_param.node_type {
            case NodeType.StructDef(expanded_struct_def):
                if not(context.scope_stack.has_struct(decl.name)) {
                    context.scope_stack.declare_struct(decl.name, expanded_struct_def.clone())?
                    new_e := Expr.new_clone(e.node_type, e, new_params.clone())
                    expanded_saved_path := context.path
                    _ := eval_declaration(decl, context, new_e)?
                    context.path = expanded_saved_path
                }
            case:
            }
        }
    case:
    }

    // Update scope_stack with transformed namespace FuncDefs so interpreter uses them
    if new_params.len().gt(0) {
        struct_ns_param := cast(Expr, new_params.get(0)?)
        switch struct_ns_param.node_type {
        case NodeType.StructDef(struct_ns_sd):
            for struct_ns_name: Str in struct_ns_sd.ns.default_values.keys {
                struct_ns_value_expr := cast(Expr, struct_ns_sd.ns.default_values.get(struct_ns_name)?)
                catch (err: KeyNotFoundError) {
                    panic(loc(), "struct ns update_func KeyNotFoundError: ", err.msg)
                }
                switch struct_ns_value_expr.node_type {
                case NodeType.FuncDef(struct_ns_func_def):
                    struct_ns_full_name := format(decl.name, ".", struct_ns_name)
                    context.scope_stack.update_func(struct_ns_full_name, struct_ns_func_def.clone())?
                    catch (err: Str) {
                        panic(loc(), "struct ns update_func failed: ", err)
                    }
                case:
                }
            }
        case:
        }
    }

    // Determine if this is a compile-time constant
    // Only mut matters for constantness - copy/own are about ownership, orthogonal to comptime.
    // Any type can be comptime - the type doesn't matter, only how the value is computed.
    first_param := cast(Expr, new_params.get(0)?)
    is_comptime_const := not(decl.is_mut)
        .and(is_comptime_evaluable(context, first_param)?)

    // Register the declared variable in scope
    sym := SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=is_comptime_const)
    context.scope_stack.declare_symbol(decl.name, sym)?

    // Also register function definitions so UFCS can resolve their return types
    switch value_type {
    case ValueType.TFunction:
        if new_params.len().gt(0) {
            fp := cast(Expr, new_params.get(0)?)
            switch fp.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
            }
        }
    case:
    }

    // Store I64/U8/Str declarations in heap when their initializer is comptime-evaluable.
    // Unlike the is_comptime_const flag (which also requires !is_mut for folding identifiers),
    // we store ALL comptime-evaluable values including mut ones, just like interpreter does.
    // This is needed for eval_expr to work during constant folding (e.g., mut loop variables).
    // Only do this at global scope - inside function bodies, evaluating could cause side effects
    // to run at compile time AND runtime (e.g., print_debug func in mode liba).
    at_global_scope := context.scope_stack.frames.len().eq(1)
    if at_global_scope {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            if custom_type_name.eq("I64").or(custom_type_name.eq("U8")).or(custom_type_name.eq("Str")) {
                if is_comptime_evaluable(context, first_param)? {
                    result := eval_expr(context, first_param)?
                    if not(result.is_throw) {
                        EvalHeap.insert_primitive(context, decl.name, value_type, result.value, e)?
                    }
                }
            }
        case:
        }
    }

    // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
    // run eval_declaration to store the instance in EvalHeap so ccodegen can find it.
    // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
    if at_global_scope.and(not(decl.is_mut)).and(not(decl.is_copy)).and(not(decl.is_own)).and(is_comptime_evaluable(context, first_param)?) {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            // Skip primitives (I64, U8) - handled above. Skip Str - needs special handling.
            if not(custom_type_name.eq("I64")).and(not(custom_type_name.eq("U8"))).and(not(custom_type_name.eq("Str"))) {
                // Check if this is a struct type (not a struct definition)
                mut instance_sym := context.scope_stack.lookup_symbol(custom_type_name)?
                catch (err: KeyNotFoundError) {
                    // Type not found, skip
                }
                switch instance_sym.value_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    instance_saved_path := context.path
                    _ := eval_declaration(decl, context, e)?
                    context.path = instance_saved_path

                    // Bug #133 fix: Track precomputed heap values for static array serialization
                    needs_heap := EvalHeap.type_needs_heap_serialization(context, custom_type_name)
                    if needs_heap {
                        context.precomputed_heap_values.push(PrecomputedHeapValue(
                            var_name=decl.name.clone(),
                            instance_name=decl.name.clone(),
                            type_name=custom_type_name.clone()
                        ))
                    }
                case:
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_declaration: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform Catch node - register the catch variable in scope before processing body
/// This enables UFCS resolution for methods called on the error variable
/// Catch structure: [var_name_expr, type_expr, body_expr]
precomp_catch : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    if e.params.len().lt(3) {
        // Malformed catch - just use default handling
        return precomp_params(context, e)?
    }

    // Get the catch variable name and type
    name_expr := cast(Expr, e.params.get(0)?)
    type_expr := cast(Expr, e.params.get(1)?)
    mut var_name := ""
    mut type_name := ""
    switch name_expr.node_type {
    case NodeType.Identifier(n):
        var_name = n
    case:
        return precomp_params(context, e)?  // Not a simple identifier, use default handling
    }
    switch type_expr.node_type {
    case NodeType.Identifier(t):
        type_name = t
    case:
        return precomp_params(context, e)?  // Not a simple type, use default handling
    }

    // Push a scope frame for the catch block
    context.scope_stack.push(ScopeType.Catch)

    // Register the catch variable in the scope
    mut sym := SymbolInfo()
    sym.value_type = ValueType.TCustom(type_name)
    sym.is_mut = false
    sym.is_copy = false
    sym.is_own = false
    sym.is_comptime_const = false
    context.scope_stack.declare_symbol(var_name, sym)?

    // Transform the catch body (params[2])
    body_expr := e.get(2)?
    dont_delete(body_expr)
    new_body := precomp_expr(context, body_expr)?

    // Pop the scope frame
    _ := context.scope_stack.pop()?

    // Return the transformed catch with original var_name, type, and new body
    mut new_params := Vec.new(Expr)
    new_params.push(name_expr)
    new_params.push(type_expr)
    new_params.push(new_body)

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_catch: ", err.msg)
    }

    return Expr.new_clone(NodeType.Catch, e, new_params)
}

/// Transform FCall node - handles compile-time intrinsics, struct/enum constructors, and import()
precomp_fcall : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    // 1. Check for compile-time intrinsics (loc, _file, _line, _col)
    mut was_replaced := false
    replaced := try_replace_comptime_intrinsic(context, e, was_replaced)?
    if was_replaced {
        return replaced
    }

    // Get func_expr and combined_name before any transformation
    if e.params.len().eq(0) {
        // Empty FCall, shouldn't happen but just return as-is
        return e.clone()
    }
    mut func_expr := e.get(0)?

    // Issue #105: anonymous struct instantiation - struct { ... }(args)
    // Register the anonymous struct and replace StructDef with Identifier
    switch func_expr.node_type {
    case NodeType.StructDef(pf_struct_def):
        pf_temp_name := format("AnonStruct", I64.to_str(context.anon_struct_counter))
        context.anon_struct_counter.inc()
        context.scope_stack.declare_struct(pf_temp_name, pf_struct_def.clone())?
        context.scope_stack.declare_symbol(pf_temp_name.clone(), SymbolInfo(value_type=ValueType.TType(TTypeDef.TStructDef), is_mut=false, is_copy=false, is_own=false, is_comptime_const=false))?
        // Register immutable fields as namespace constants
        for pf_member_decl: Declaration in pf_struct_def.members {
            if not(pf_member_decl.is_mut) {
                mut pf_has_default := false
                pf_member_expr := cast(Expr, pf_struct_def.default_values.get(pf_member_decl.name)?)
                pf_has_default = true
                catch (_err: KeyNotFoundError) { }
                if pf_has_default {
                    mut pf_member_vt := ValueType.TCustom(INFER_TYPE)
                    pf_member_vt = get_value_type(context, pf_member_expr)?
                    catch (_err: Str) { }
                    pf_member_full_name := format(pf_temp_name, ".", pf_member_decl.name)
                    context.scope_stack.declare_symbol(pf_member_full_name, SymbolInfo(value_type=pf_member_vt, is_mut=pf_member_decl.is_mut, is_copy=pf_member_decl.is_copy, is_own=pf_member_decl.is_own, is_comptime_const=false))?
                }
            }
        }
        // Generate struct methods (delete/clone) and set on ns
        pf_auto_ns := generate_struct_methods(pf_temp_name, pf_struct_def.clone(), e.line, e.col)
        mut pf_final_sd := pf_struct_def.clone()
        if pf_auto_ns.members.len().gt(0) {
            pf_final_sd.ns = pf_auto_ns
            mut pf_ns_errors := Vec.new(Str)
            init_namespace_into_struct(context, pf_temp_name, pf_final_sd.ns, e, pf_ns_errors)?
            if pf_ns_errors.len().gt(0) {
                throw pf_ns_errors.join("\n")
            }
        }
        context.scope_stack.declare_struct(pf_temp_name.clone(), pf_final_sd.clone())?
        // Create default instance for codegen
        _ := create_default_instance(context, pf_temp_name, e)?
        // Add struct declaration to pending list for codegen to emit
        mut pf_struct_decl := Declaration()
        pf_struct_decl.name = pf_temp_name.clone()
        pf_struct_decl.value_type = ValueType.TType(TTypeDef.TStructDef)
        pf_struct_decl.is_mut = false
        pf_struct_decl.is_copy = false
        pf_struct_decl.is_own = false
        mut pf_decl_params := Vec.new(Expr)
        pf_decl_params.push(Expr.new_clone(NodeType.StructDef(pf_final_sd), func_expr, Vec.new(Expr)))
        pf_struct_decl_expr := Expr.new_clone(NodeType.Declaration(pf_struct_decl), func_expr, pf_decl_params)
        context.anon_struct_decls.push(pf_struct_decl_expr)
        // Replace StructDef with Identifier and continue as normal struct constructor
        pf_id_expr := Expr.new_clone(NodeType.Identifier(pf_temp_name.clone()), func_expr, Vec.new(Expr))
        mut pf_new_params := Vec.new(Expr)
        pf_new_params.push(pf_id_expr)
        mut pf_skip := true
        for pf_p: Expr in e.params {
            if pf_skip {
                pf_skip = false
            } else {
                pf_new_params.push(precomp_expr(context, pf_p)?)
            }
        }
        return Expr.new_clone(e.node_type, e, pf_new_params)
    case:
    }

    mut combined_name := ""
    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?
    case:
    }

    // 3. Struct constructor - create instance like eval does (before arg transform)
    if not(combined_name.eq("")) {
        mut struct_found := false
        _dummy_struct := context.scope_stack.lookup_struct(combined_name)?
        struct_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if struct_found {
            _ := create_default_instance(context, combined_name, e)?
            switch func_expr.node_type {
            case NodeType.Identifier(id_name):
                if func_expr.params.len().eq(0) {
                    insert_struct_instance(context, id_name, combined_name, e)?
                }
            case:
            }
            // Transform arguments for struct constructor
            mut struct_params := Vec.new(Expr)
            for p: Expr in e.params {
                struct_params.push(precomp_expr(context, p)?)
            }
            return Expr.new_clone(e.node_type, e, struct_params)
        }
    }

    // 4. Enum constructor (e.g., Color.Green(true)) - before arg transform
    if context.scope_stack.is_enum_constructor(combined_name) {
        // Transform arguments for enum constructor
        mut enum_params := Vec.new(Expr)
        for p: Expr in e.params {
            enum_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(e.node_type, e, enum_params)
    }

    // 5. Transform all arguments
    mut all_transformed_params := Vec.new(Expr)
    for p: Expr in e.params {
        all_transformed_params.push(precomp_expr(context, p)?)
    }
    mut new_e := Expr.new_clone(e.node_type, e, all_transformed_params)

    // Get func_expr again from transformed expression
    if new_e.params.len().eq(0) {
        return new_e
    }
    func_expr = new_e.get(0)?

    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?

        // 6. Handle ext functions and import()
        mut func_found := false
        mut func_def := context.scope_stack.lookup_func(combined_name)?
        func_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if func_found {
            // Ext functions: evaluation happens through eval_comptime path (see doc/precomp.org)
            // Exception: import() must run during precomp to load code
            if func_def.is_ext() {
                mut parts := combined_name.split(".")?
                if parts.len().gt(0) {
                    last_part := cast(Str, parts.get(parts.len().sub(1))?)
                    if last_part.eq("import") {
                        _ := eval_expr(context, new_e)?
                    }
                }
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_fcall: ", err.msg)
    }

    // No transformation needed (UFCS already resolved in ufcs phase)
    return new_e
}
