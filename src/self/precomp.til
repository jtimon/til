mode lib

import("self.init")
import("self.interpreter")

// Precomputation phase: Transforms UFCS calls into regular function calls
// and performs compile-time constant folding for pure functions.
// This phase runs after typer, before interpreter/builder.

// Called when precomp encounters an import() call.
// Runs precomp on the imported file to set up struct templates.
precomp_import_declarations := proc(mut context: Context, import_path_str: Str) throws Str {
    file_path := import_path_to_file_path(import_path_str)

    // Already done (or in progress)? Skip.
    if context.imports_precomp_done.contains(file_path) {
        return
    }

    // Mark as done immediately - before processing - to handle circular imports
    _ := context.imports_precomp_done.insert(file_path)

    // Get stored AST from init phase
    mut ast := Expr()
    context.imported_asts.get(file_path, ast)
    catch (err: KeyNotFoundError) {
        throw format("precomp: Import ", file_path, " not found in stored ASTs - init phase should have stored it")
    }

    // Save and restore context path
    original_path := context.path
    context.path = file_path

    // Run precomp on the imported AST
    _ := precomp_expr(context, ast)

    context.path = original_path

    catch (err: AllocError) {
        throw format("precomp_import_declarations: ", err.msg)
    }
}

// ---------- Named argument reordering

/// Reorder named arguments to match function parameter order.
/// Transforms: func(b=3, a=10) -> func(10, 3) (for func(a, b))
/// This runs during precomp so both interpreter and builder share the work.
reorder_named_args := func(context: Context, e: Expr, func_def: SFuncDef) returns Expr throws Str {
    // params[0] is the function identifier, params[1..] are the arguments
    // Calculate call_args_len (number of arguments, not counting function identifier)
    mut call_args_len := 0
    if e.params.len().gt(1) {
        call_args_len = e.params.len().sub(1)
    }

    // Check if function is variadic - named args and default filling not supported
    is_variadic := func_proc_has_multi_arg(func_def)

    // Check if there are any named args
    mut has_named_args := false
    mut i := 1
    while i.lt(e.params.len()) {
        mut arg := e.get(i)
        switch arg.node_type {
        case NodeType.NamedArg(_):
            has_named_args = true
        case:
        }
        i = i.add(1)
    }

    // Named args are not supported for variadic functions
    if has_named_args.and(is_variadic) {
        throw e.error(context.path, "precomp", "Named arguments are not supported for variadic functions")
    }

    // Check if we need to fill in default values (fewer args than params)
    // Don't apply to variadic functions
    mut needs_defaults := false
    if not(is_variadic).and(call_args_len.lt(func_def.args.len())) {
        needs_defaults = true
    }

    // If no named args and no defaults needed, return unchanged
    if not(has_named_args).and(not(needs_defaults)) {
        return e.clone()
    }

    mut result := Vec.new(Expr)
    result.push(e.get(0)) // Keep function identifier

    // Count positional args (before first named arg)
    mut positional_count := 0
    for i in 1..e.params.len() {
        mut arg := e.get(i)
        switch arg.node_type {
        case NodeType.NamedArg(_):
            break
        case:
            positional_count = positional_count.add(1)
        }
    }

    // Check that all named args come after positional args
    mut seen_named := false
    i = 1
    while i.lt(e.params.len()) {
        mut arg := e.get(i)
        switch arg.node_type {
        case NodeType.NamedArg(_):
            seen_named = true
        case:
            if seen_named {
                throw e.error(context.path, "precomp", "Positional arguments cannot appear after named arguments")
            }
        }
        i = i.add(1)
    }

    // Build result: first positional args, then fill in from named args
    // Use a Vec of Option-like values (empty string = None, otherwise = Some)
    mut final_args := Vec.new(Expr)
    mut final_args_set := Vec.new(Bool)
    i = 0
    while i.lt(func_def.args.len()) {
        final_args.push(Expr())
        final_args_set.push(false)
        i = i.add(1)
    }

    // Place positional arguments
    i = 0
    while i.lt(positional_count) {
        if i.gteq(func_def.args.len()) {
            throw e.error(context.path, "precomp", format("Too many positional arguments: expected at most ", func_def.args.len().to_str()))
        }
        final_args.set(i, e.get(i.add(1)))
        final_args_set.set(i, true)
        i = i.add(1)
    }

    // Place named arguments
    i = positional_count.add(1)
    while i.lt(e.params.len()) {
        mut arg := e.get(i)
        switch arg.node_type {
        case NodeType.NamedArg(arg_name):
            // Find the parameter index by name
            mut param_idx := sub(0, 1)
            mut j := 0
            while j.lt(func_def.args.len()) {
                mut arg_decl := Declaration()
                func_def.args.get(j, arg_decl)
                if arg_decl.name.eq(arg_name) {
                    param_idx = j
                    j = func_def.args.len() // break
                } else {
                    j = j.add(1)
                }
            }
            if param_idx.lt(0) {
                throw arg.error(context.path, "precomp", format("Unknown parameter name '", arg_name, "'"))
            }
            mut already_set := false
            final_args_set.get(param_idx, already_set)
            if already_set {
                throw arg.error(context.path, "precomp", format("Argument '", arg_name, "' specified multiple times"))
            }
            if arg.params.len().eq(0) {
                throw arg.error(context.path, "precomp", format("Named argument '", arg_name, "' has no value"))
            }
            final_args.set(param_idx, arg.get(0))
            final_args_set.set(param_idx, true)
        case:
        }
        i = i.add(1)
    }

    // Check all required args are present and build final result
    i = 0
    while i.lt(final_args.len()) {
        mut is_set := false
        final_args_set.get(i, is_set)
        if is_set {
            mut arg := Expr()
            final_args.get(i, arg)
            result.push(arg)
        } else {
            // Check if this parameter has a default value
            mut arg_decl := Declaration()
            func_def.args.get(i, arg_decl)
            if not(NULL.eq(arg_decl.default_value.data)) {
                mut default_expr := Expr()
                memcpy(to_ptr(default_expr), arg_decl.default_value.data, size_of(Expr))
                result.push(default_expr.clone())
            } else {
                throw e.error(context.path, "precomp", format("Missing argument for parameter '", arg_decl.name, "'"))
            }
        }
        i = i.add(1)
    }

    final_result := Expr.new_clone(NodeType.FCall, e, result)

    catch (err: IndexOutOfBoundsError) {
        throw format("reorder_named_args: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("reorder_named_args: ", err.msg)
    }

    return final_result
}

// ---------- Main entry point

/// Precomputation phase: Transform UFCS calls into regular function calls.
/// Takes an AST that has already passed type checking and returns a semantically
/// equivalent AST with all UFCS calls resolved.
///
/// Examples:
///   a.add(b)         -> I64.add(a, b)     (where a is I64)
///   obj.items.len()  -> Vec.len(obj.items)
///   add(1, 2).mul(3) -> I64.mul(add(1, 2), 3)
precomp_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    case NodeType.Body:
        return precomp_body(context, e)
    case NodeType.FCall:
        return precomp_fcall(context, e)
    case NodeType.If:
        return precomp_params(context, e)
    case NodeType.While:
        return precomp_params(context, e)
    case NodeType.Switch:
        return precomp_switch(context, e)
    case NodeType.FuncDef(func_def):
        return precomp_func_def(context, e, func_def)
    case NodeType.Declaration(decl):
        return precomp_declaration(context, e, decl)
    case NodeType.Assignment:
        return precomp_params(context, e)
    case NodeType.Return:
        return precomp_params(context, e)
    case NodeType.Throw:
        return precomp_params(context, e)
    case NodeType.Catch:
        return precomp_params(context, e)
    case NodeType.Range:
        return precomp_params(context, e)
    // Struct/enum definitions - need to process default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        return precomp_struct_def(context, e, struct_def)
    case NodeType.EnumDef:
        return e.clone()
    // Identifiers can have nested params (e.g., a.b.c for field access chains)
    case NodeType.Identifier:
        return precomp_params(context, e)
    // Leaf nodes - no transformation needed
    case NodeType.LLiteral:
        return e.clone()
    case NodeType.DefaultCase:
        return e.clone()
    case NodeType.Pattern:
        return e.clone()
    // Break and Continue are leaf nodes (no params) - no transformation needed
    case NodeType.Break:
        return e.clone()
    case NodeType.Continue:
        return e.clone()
    // Named arguments - transform the value expression
    case NodeType.NamedArg(name):
        mut new_params := Vec.new(Expr)
        mut i := 0
        while i.lt(e.params.len()) {
            mut p := e.get(i)
            new_params.push(precomp_expr(context, p))
            i = i.add(1)
        }
        catch (err: AllocError) {
            throw format("precomp_expr NamedArg: ", err.msg)
        }
        return Expr.new_clone(NodeType.NamedArg(name), e, new_params)
    // ForIn desugaring: for VAR: TYPE in COLLECTION { body } -> while loop
    // After desugaring, recursively precomp the result to resolve UFCS and loc()
    case NodeType.ForIn(var_type_name):
        desugared := precomp_forin(context, e, var_type_name)
        return precomp_expr(context, desugared)
    case:
        return e.clone()
    }
}

// ---------- Compile-time constant folding

/// Check if an expression can be evaluated at compile time.
/// Currently only handles literals and pure function calls with literal arguments.
is_comptime_evaluable := proc(context: Context, e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.LLiteral:
        return true
    case NodeType.Identifier(name):
        // Check if this is a simple identifier (no field access chain)
        if e.params.len().gt(0) {
            return false  // Field access chains not supported
        }
        // Look up the symbol and check if it's a comptime const
        mut symbol := context.scope_stack.lookup_symbol(name)
        catch (err: KeyNotFoundError) {
            return false
        }
        return symbol.is_comptime_const
    case NodeType.FCall:
        f_name := get_func_name_in_call(e)
        catch (err: Str) {
            return false  // Can't get function name
        }
        // Special case: exit terminates the program
        if f_name.eq("exit") { return false }
        // TODO: Properly detect ext_funcs and functions with side effects.
        // For now, hardcode malloc exclusion since it's an ext_func with side effects.
        if f_name.eq("malloc") { return false }

        mut func_def := context.scope_stack.lookup_func(f_name)
        catch (err: KeyNotFoundError) {
            // Could be a struct constructor - check if all args are comptime
            combined_name := get_combined_name(context.path, e.get(0))
            catch (err2: Str) {
                return false
            }
            mut struct_def := context.scope_stack.lookup_struct(combined_name)
            catch (err3: KeyNotFoundError) {
                return false  // Unknown function
            }
            // It's a struct constructor - check all args are comptime
            mut j := 1
            while j.lt(e.params.len()) {
                mut arg := Expr()
                e.params.get(j, arg)
                catch (err4: IndexOutOfBoundsError) {
                    return false
                }
                // Handle named args - check the value inside
                mut arg_to_check := arg
                switch arg.node_type {
                case NodeType.NamedArg(_):
                    if arg.params.len().gt(0) {
                        arg.params.get(0, arg_to_check)
                        catch (err5: IndexOutOfBoundsError) {
                            return false
                        }
                    }
                case:
                }
                if not(is_comptime_evaluable(context, arg_to_check)) {
                    return false
                }
                j = j.add(1)
            }
            return true  // Struct constructor with all comptime args
        }
        // Must be pure function (not proc)
        if func_def.is_proc() {
            return false
        }
        // Functions that can throw are NOT comptime-evaluable because
        // if they throw, we can't fold them to a literal
        if func_def.throw_types.len().gt(0) {
            return false
        }
        // All arguments must be comptime-evaluable
        mut i := 1
        while i.lt(e.params.len()) {
            mut arg := Expr()
            e.params.get(i, arg)
            catch (err: IndexOutOfBoundsError) {
                return false
            }
            if not(is_comptime_evaluable(context, arg)) {
                return false
            }
            i = i.add(1)
        }
        return true
    case:
        return false
    }
}

/// Evaluate a comptime-evaluable expression and convert result back to AST literal.
eval_comptime := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Save and restore context.path - interpreter may change it during function calls
    saved_path := context.path
    result := eval_expr(context, e)
    context.path = saved_path

    // Check if the function threw an exception during evaluation
    if result.is_throw {
        mut thrown_type := result.thrown_type
        if thrown_type.eq("") {
            thrown_type = "unknown"
        }
        throw e.error(context.path, "precomp", format("Exception '", thrown_type, "' thrown during precomputation: ", result.value))
    }

    // EvalResult.value is a String representation of the value
    // Convert back to LLiteral based on the result type
    value_type := get_value_type(context, e)
    switch value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("Str") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Str(result.value)), e, Vec.new(Expr))
        }
        // Check if it's a struct type - result.value is the instance name
        mut struct_def := context.scope_stack.lookup_struct(type_name)
        catch (err: KeyNotFoundError) {
            throw format("Cannot convert comptime result type: ", type_name)
        }
        return Arena.to_struct_literal(context, result.value, type_name, e)
    case:
        throw "Cannot convert comptime result type"
    }
}

// ---------- AST transformation

/// Transform Body node - recursively transform all statements
precomp_body := proc(mut context: Context, e: Expr) returns Expr throws Str {
    mut new_params := Vec.new(Expr)
    mut i := 0
    while i.lt(e.params.len()) {
        mut p := Expr()
        e.params.get(i, p)
        new_params.push(precomp_expr(context, p))
        i = i.add(1)
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_body: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_body: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform node params - recursively transform all child expressions
precomp_params := proc(mut context: Context, e: Expr) returns Expr throws Str {
    mut new_params := Vec.new(Expr)
    mut i := 0
    while i.lt(e.params.len()) {
        mut p := Expr()
        e.params.get(i, p)
        new_params.push(precomp_expr(context, p))
        i = i.add(1)
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_params: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_params: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform Switch - handle pattern binding variables by adding them to scope
/// before processing the case body. This mirrors the typer's handling of Bug #28.
precomp_switch := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Switch structure: params[0] is switch expression, then pairs of (case, body)
    if e.params.len().eq(0) {
        return e.clone()
    }

    mut new_params := Vec.new(Expr)

    // Transform switch expression
    mut switch_expr := Expr()
    e.params.get(0, switch_expr)
    new_params.push(precomp_expr(context, switch_expr))

    // Get the type of the switch expression for pattern binding resolution
    mut switch_expr_type := ValueType.TCustom("")
    mut got_switch_type := true
    switch_expr_type = get_value_type(context, switch_expr)
    catch (err: Str) {
        got_switch_type = false
    }

    // Process case/body pairs
    mut i := 1
    while i.add(1).lt(e.params.len().add(1)) {
        mut case_expr := Expr()
        mut body_expr := Expr()
        e.params.get(i, case_expr)
        e.params.get(i.add(1), body_expr)

        // Transform case expression (no scope change needed for case itself)
        new_params.push(precomp_expr(context, case_expr))

        // For pattern matching with binding variable, add binding to scope before processing body
        switch case_expr.node_type {
        case NodeType.Pattern(pattern_info):
            mut handled := false
            if got_switch_type {
                switch switch_expr_type {
                case ValueType.TCustom(enum_name):
                    // Extract variant name (after the last dot)
                    variant_name := pattern_info.variant_name
                    mut variant := variant_name
                    dot_pos := variant_name.rfind(".")
                    if dot_pos.gteq(0) {
                        variant = get_substr(variant_name, dot_pos.add(1), variant_name.len())
                    }

                    // Get payload type from enum definition
                    mut enum_found := true
                    mut enum_def := context.scope_stack.lookup_enum(enum_name)
                    catch (err: KeyNotFoundError) {
                        enum_found = false
                    }

                    if enum_found {
                        mut payload_type := ValueType.TCustom("")
                        mut got_payload := false
                        enum_def.enum_map.get(variant, payload_type)
                        got_payload = true
                        catch (err: KeyNotFoundError) {
                            // Variant not found or no payload
                        }

                        if got_payload {
                            // Push block scope, declare binding variable, transform body, pop scope
                            context.scope_stack.push(ScopeType.Block)
                            sym := SymbolInfo(value_type=payload_type, is_mut=false, is_copy=false, is_own=false)
                            context.scope_stack.declare_symbol(pattern_info.binding_var, sym)
                            new_params.push(precomp_expr(context, body_expr))
                            _ := context.scope_stack.pop()
                            handled = true
                        }
                    }
                case:
                }
            }
            if not(handled) {
                // No payload type found or switch type not found, transform body without binding
                new_params.push(precomp_expr(context, body_expr))
            }
        case:
            // Not a pattern, transform body normally
            new_params.push(precomp_expr(context, body_expr))
        }

        i = i.add(2)
    }

    // Handle odd trailing element (default case body without case expression)
    if i.lt(e.params.len()) {
        mut trailing := Expr()
        e.params.get(i, trailing)
        new_params.push(precomp_expr(context, trailing))
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_switch: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_switch: ", err.msg)
    }

    return Expr.new_clone(NodeType.Switch, e, new_params)
}

/// Desugar ForIn to a range-based for loop with get() calls
// for VAR: TYPE in COLLECTION { body }
// becomes:
/// for _for_i in 0..collection.len() {
//     mut VAR := TYPE()
///     collection.get(_for_i, VAR)
//     catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
///     body
/// }
precomp_forin := proc(mut context: Context, e: Expr, var_type_name: Str) returns Expr throws Str {
    // Extract var_name from params[0]
    if e.params.len().lt(1) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing loop variable")
    }
    mut var_expr := e.get(0)
    mut var_name := ""
    switch var_expr.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        throw e.lang_error(context.path, "precomp", "ForIn: expected identifier for loop variable")
    }

    // Get collection expression (params[1])
    if e.params.len().lt(2) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing collection expression")
    }
    collection_expr := precomp_expr(context, e.get(1))

    // Get body (params[2])
    if e.params.len().lt(3) {
        throw e.lang_error(context.path, "precomp", "ForIn: missing body")
    }
    body_expr := precomp_expr(context, e.get(2))

    // Build: mut _for_i := 0
    index_var_name := "_for_i"
    index_decl := Declaration(name=index_var_name, value_type=str_to_value_type(INFER_TYPE), is_mut=true, is_copy=false, is_own=false, default_value=NULL)
    mut zero_params := Vec.new(Expr)
    zero_literal := Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), zero_params, e.line, e.col)
    mut decl_params := Vec.new(Expr)
    decl_params.push(zero_literal)
    index_decl_expr := Expr.new_explicit(NodeType.Declaration(index_decl), decl_params, e.line, e.col)

    // Build len(collection) - already desugared form
    mut len_params := Vec.new(Expr)
    len_params.push(Expr.new_explicit(NodeType.Identifier("len"), Vec.new(Expr), e.line, e.col))
    len_params.push(collection_expr.clone())
    len_call_expr := Expr.new_explicit(NodeType.FCall, len_params, e.line, e.col)

    // Build lt(_for_i, len_result) - already desugared form
    mut cond_params := Vec.new(Expr)
    cond_params.push(Expr.new_explicit(NodeType.Identifier("lt"), Vec.new(Expr), e.line, e.col))
    cond_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    cond_params.push(len_call_expr)
    cond_expr := Expr.new_explicit(NodeType.FCall, cond_params, e.line, e.col)

    // Build: mut VAR := TYPE()
    var_decl := Declaration(name=var_name, value_type=ValueType.TCustom(var_type_name), is_mut=true, is_copy=false, is_own=false, default_value=NULL)
    mut type_call_params := Vec.new(Expr)
    type_call_params.push(Expr.new_explicit(NodeType.Identifier(var_type_name), Vec.new(Expr), e.line, e.col))
    type_call := Expr.new_explicit(NodeType.FCall, type_call_params, e.line, e.col)
    mut var_decl_params := Vec.new(Expr)
    var_decl_params.push(type_call)
    var_decl_expr := Expr.new_explicit(NodeType.Declaration(var_decl), var_decl_params, e.line, e.col)

    // Build: get(collection, _for_i, VAR) - already desugared form
    mut get_params := Vec.new(Expr)
    get_params.push(Expr.new_explicit(NodeType.Identifier("get"), Vec.new(Expr), e.line, e.col))
    get_params.push(collection_expr.clone())
    get_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    get_params.push(Expr.new_explicit(NodeType.Identifier(var_name), Vec.new(Expr), e.line, e.col))
    get_call := Expr.new_explicit(NodeType.FCall, get_params, e.line, e.col)

    // Build: catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    // Build err.msg (identifier with field access)
    mut msg_field := Vec.new(Expr)
    msg_field.push(Expr.new_explicit(NodeType.Identifier("msg"), Vec.new(Expr), e.line, e.col))
    err_msg_expr := Expr.new_explicit(NodeType.Identifier("err"), msg_field, e.line, e.col)

    // Build loc() call
    mut loc_params := Vec.new(Expr)
    loc_params.push(Expr.new_explicit(NodeType.Identifier("loc"), Vec.new(Expr), e.line, e.col))
    loc_call := Expr.new_explicit(NodeType.FCall, loc_params, e.line, e.col)

    // Build panic(loc(), err.msg)
    mut panic_params := Vec.new(Expr)
    panic_params.push(Expr.new_explicit(NodeType.Identifier("panic"), Vec.new(Expr), e.line, e.col))
    panic_params.push(loc_call)
    panic_params.push(err_msg_expr)
    panic_call := Expr.new_explicit(NodeType.FCall, panic_params, e.line, e.col)

    // Build catch body
    mut catch_body_params := Vec.new(Expr)
    catch_body_params.push(panic_call)
    catch_body := Expr.new_explicit(NodeType.Body, catch_body_params, e.line, e.col)

    // Catch structure: [name_expr, type_expr, body_expr]
    mut catch_params := Vec.new(Expr)
    catch_params.push(Expr.new_explicit(NodeType.Identifier("err"), Vec.new(Expr), e.line, e.col))
    catch_params.push(Expr.new_explicit(NodeType.Identifier("IndexOutOfBoundsError"), Vec.new(Expr), e.line, e.col))
    catch_params.push(catch_body)
    catch_expr := Expr.new_explicit(NodeType.Catch, catch_params, e.line, e.col)

    // Build: _for_i = add(_for_i, 1)
    // Already desugared form - no UFCS resolution needed
    mut add_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.Identifier("add"), Vec.new(Expr), e.line, e.col))
    add_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    mut one_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.LLiteral(Literal.Number("1")), one_params, e.line, e.col))
    add_call := Expr.new_explicit(NodeType.FCall, add_params, e.line, e.col)

    mut inc_params := Vec.new(Expr)
    inc_params.push(add_call)
    inc_stmt := Expr.new_explicit(NodeType.Assignment(index_var_name), inc_params, e.line, e.col)

    // Build while body: var_decl, get_call + catch (together), original body statements, inc
    // The catch must be right after get_call so it only catches IndexOutOfBoundsError from get,
    // not from user code in the loop body
    mut while_body_params := Vec.new(Expr)
    while_body_params.push(var_decl_expr)
    while_body_params.push(get_call)
    while_body_params.push(catch_expr)

    // Add original body statements
    switch body_expr.node_type {
    case NodeType.Body:
        for i in 0..body_expr.params.len() {
            mut p := Expr()
            body_expr.params.get(i, p)
            while_body_params.push(p.clone())
        }
    case:
        while_body_params.push(body_expr)
    }
    while_body_params.push(inc_stmt)
    while_body := Expr.new_explicit(NodeType.Body, while_body_params, e.line, e.col)

    // Build while: while _for_i.lt(collection.len()) { ... }
    mut while_params := Vec.new(Expr)
    while_params.push(cond_expr)
    while_params.push(while_body)
    while_expr := Expr.new_explicit(NodeType.While, while_params, e.line, e.col)

    // Build outer body: index_decl, while
    mut outer_body_params := Vec.new(Expr)
    outer_body_params.push(index_decl_expr)
    outer_body_params.push(while_expr)

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_forin: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_forin: ", err.msg)
    }

    return Expr.new_explicit(NodeType.Body, outer_body_params, e.line, e.col)
}

/// Transform StructDef - recursively transform default values (which contain function defs)
precomp_struct_def := proc(mut context: Context, e: Expr, struct_def: SStructDef) returns Expr throws Str {
    mut new_default_values := Map.new(Str, Expr)
    mut i := 0
    while i.lt(struct_def.default_values.keys.len()) {
        mut name := ""
        struct_def.default_values.keys.get(i, name)
        mut value_expr := Expr()
        struct_def.default_values.get(name, value_expr)
        new_default_values.set(name, precomp_expr(context, value_expr))
        i = i.add(1)
    }
    mut new_struct_def := SStructDef()
    new_struct_def.members = struct_def.members.clone()
    new_struct_def.default_values = new_default_values

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_struct_def: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_struct_def: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("precomp_struct_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params.clone())
}

/// Transform FuncDef - push scope frame for function args, transform body, pop frame
precomp_func_def := proc(mut context: Context, e: Expr, func_def: SFuncDef) returns Expr throws Str {
    // Push a new scope frame with the function's parameters
    context.scope_stack.push(ScopeType.Function)
    mut i := 0
    while i.lt(func_def.args.len()) {
        mut arg := Declaration()
        func_def.args.get(i, arg)
        sym := SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
        context.scope_stack.declare_symbol(arg.name, sym)
        i = i.add(1)
    }

    // Transform the function body
    mut new_body := Vec.new(Expr)
    mut j := 0
    while j.lt(func_def.body.len()) {
        mut stmt := Expr()
        func_def.body.get(j, stmt)
        new_body.push(precomp_expr(context, stmt))
        j = j.add(1)
    }

    // Pop the function scope frame
    _ := context.scope_stack.pop()

    mut new_func_def := SFuncDef()
    new_func_def.function_type = func_def.function_type
    new_func_def.args = func_def.args.clone()
    new_func_def.return_types = func_def.return_types.clone()
    new_func_def.throw_types = func_def.throw_types.clone()
    new_func_def.body = new_body
    new_func_def.source_path = func_def.source_path.clone()

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_func_def: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_func_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params.clone())
}

/// Transform Declaration - register the declared variable in scope, then transform value
precomp_declaration := proc(mut context: Context, e: Expr, decl: Declaration) returns Expr throws Str {
    // First transform the value expression (if any)
    mut new_params := Vec.new(Expr)
    if e.params.len().gt(0) {
        mut i := 0
        while i.lt(e.params.len()) {
            mut p := Expr()
            e.params.get(i, p)
            new_params.push(precomp_expr(context, p))
            i = i.add(1)
        }
    }

    // Determine the type from the value if it's 'auto'
    mut value_type := decl.value_type
    switch decl.value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("auto") {
            if new_params.len().gt(0) {
                mut first_param := Expr()
                new_params.get(0, first_param)
                value_type = get_value_type(context, first_param)
                catch (err: Str) {
                    // Keep original type if we can't determine it
                }
            }
        }
    case:
    }

    // REM: Declarations currently always require an initialization value,
    // so new_params should never be empty.
    if new_params.len().eq(0) {
        throw e.lang_error(context.path, "precomp", "Declaration without initializer")
    }

    // Determine if this is a compile-time constant
    // Must be truly immutable (not mut, copy, or own) and have a comptime-evaluable value.
    // Also, only I64 and U8 types are currently supported for comptime storage in arena.
    // Str, structs, enums require infrastructure not available during precomp.
    mut is_supported_type := false
    switch value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64").or(type_name.eq("U8")) {
            is_supported_type = true
        }
    case:
    }
    mut first_param := Expr()
    new_params.get(0, first_param)
    mut is_comptime_const := is_supported_type
        .and(not(decl.is_mut))
        .and(not(decl.is_copy))
        .and(not(decl.is_own))
        .and(is_comptime_evaluable(context, first_param))

    // Register the declared variable in scope
    sym := SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=is_comptime_const)
    context.scope_stack.declare_symbol(decl.name, sym)

    // Also register function definitions so UFCS can resolve their return types
    switch value_type {
    case ValueType.TFunction:
        if new_params.len().gt(0) {
            mut fp := Expr()
            new_params.get(0, fp)
            switch fp.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)
            case:
            }
        }
    case:
    }

    // For struct definitions, register them in scope and create Arena templates
    // by calling eval_declaration. This is needed for struct comptime folding
    // (to_struct_literal needs the Arena template to read field values).
    // We save/restore context.path to avoid polluting it during default value evaluation.
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        mut fp := Expr()
        new_params.get(0, fp)
        switch fp.node_type {
        case NodeType.StructDef(struct_def):
            context.scope_stack.declare_struct(decl.name, struct_def)
            saved_path := context.path
            _ := eval_declaration(decl, context, e)
            context.path = saved_path
        case:
        }
    case:
    }

    // For non-mut declarations with comptime-evaluable values, store in arena
    // so that later eval_expr calls can look them up during constant folding.
    if is_comptime_const {
        mut inner_e := Expr()
        new_params.get(0, inner_e)
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            if custom_type_name.eq("I64").or(custom_type_name.eq("U8")) {
                result := eval_expr(context, inner_e)
                if not(result.is_throw) {
                    Arena.insert_primitive(context, decl.name, value_type, result.value, e)
                }
            }
        case:
        }
    }

    // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
    // run eval_declaration to store the instance in Arena so ccodegen can find it.
    // Only do this if the value is comptime-evaluable (doesn't depend on runtime values).
    mut first_param := Expr()
    new_params.get(0, first_param)
    if not(decl.is_mut).and(not(decl.is_copy)).and(not(decl.is_own)).and(is_comptime_evaluable(context, first_param)) {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            // Skip primitives (I64, U8) - handled above. Skip Str - needs special handling.
            if not(custom_type_name.eq("I64")).and(not(custom_type_name.eq("U8"))).and(not(custom_type_name.eq("Str"))) {
                // Check if this is a struct type (not a struct definition)
                mut sym := context.scope_stack.lookup_symbol(custom_type_name)
                catch (err: KeyNotFoundError) {
                    // Type not found, skip
                }
                switch sym.value_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    saved_path := context.path
                    _ := eval_declaration(decl, context, e)
                    context.path = saved_path
                case:
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_declaration: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_declaration: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform FCall node - this is where UFCS resolution happens
precomp_fcall := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Check for loc() - replace with string literal before any other processing
    if e.params.len().eq(1) {
        mut func_expr := Expr()
        e.params.get(0, func_expr)
        switch func_expr.node_type {
        case NodeType.Identifier(name):
            if name.eq("loc") {
                mut loc_str := format(context.path, ":", I64.to_str(e.line), ":", I64.to_str(e.col), ":")
                return Expr.new_clone(NodeType.LLiteral(Literal.Str(loc_str)), e, Vec.new(Expr))
            }
        case:
        }
        catch (err: IndexOutOfBoundsError) {
            throw format("precomp_fcall loc check: ", err.msg)
        }
        catch (err: AllocError) {
            throw format("precomp_fcall loc check: ", err.msg)
        }
        catch (err: I64_OverflowError) {
            throw format("precomp_fcall loc check: ", err.msg)
        }
    }

    // Special handling for import() calls - precomp the imported file first
    f_name := get_func_name_in_call(e)
    catch (err: Str) {
        // Can't get function name, continue
    }
    if f_name.eq("import") {
        if e.params.len().gt(1) {
            mut path_expr := Expr()
            e.params.get(1, path_expr)
            catch (err: IndexOutOfBoundsError) {
                // Can't get path, continue
            }
            switch path_expr.node_type {
            case NodeType.LLiteral(lit):
                switch lit {
                case Literal.Str(import_path_str):
                    precomp_import_declarations(context, import_path_str)
                case:
                }
            case:
            }
        }
    }

    // First, recursively transform all arguments
    mut transformed_params := Vec.new(Expr)
    mut i := 0
    while i.lt(e.params.len()) {
        mut p := Expr()
        e.params.get(i, p)
        transformed_params.push(precomp_expr(context, p))
        i = i.add(1)
    }
    mut e := Expr.new_clone(e.node_type, e, transformed_params)

    // Now check if this is a UFCS call and transform it
    if e.params.len().eq(0) {
        // Empty FCall, shouldn't happen but just return as-is
        return e
    }

    mut func_expr := Expr()
    e.params.get(0, func_expr)

    switch func_expr.node_type {
    case NodeType.Identifier:
        mut combined_name := get_combined_name(context.path, func_expr)

        // Regular function call - check if it exists
        mut func_found := false
        mut func_def := context.scope_stack.lookup_func(combined_name)
        func_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if func_found {
            // Reorder named arguments to positional order before constant folding
            reordered := reorder_named_args(context, e, func_def)

            // Try compile-time constant folding for pure functions with literal args
            if is_comptime_evaluable(context, reordered) {
                mut folded := eval_comptime(context, reordered)
                catch (err: Str) {
                    // Exception thrown during compile-time evaluation - propagate error
                    if err.find("thrown during precomputation").gteq(0) {
                        throw err
                    }
                    // Other errors (e.g., can't convert result type) - fall through
                    return reordered
                }
                return folded
            }
            return reordered
        }

        // Case 3: Struct/enum constructor - no transformation needed
        mut struct_found := false
        mut dummy3 := context.scope_stack.lookup_struct(combined_name)
        struct_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if struct_found {
            return e
        }

        // Check for enum constructors (e.g., Color.Green(true))
        mut parts := combined_name.split(".")
        if parts.len().eq(2) {
            mut enum_type := ""
            parts.get(0, enum_type)
            mut enum_found := false
            mut enum_def := context.scope_stack.lookup_enum(enum_type)
            enum_found = true
            catch (err: KeyNotFoundError) {
                // Not found
            }
            if enum_found {
                mut variant_name := ""
                parts.get(1, variant_name)
                if enum_def.enum_map.contains_key(variant_name) {
                    return e
                }
            }
        }

        // UFCS for chained calls: func(result, args) -> Type.func(result, args)
        // e.g., add(1, 2).mul(3) becomes mul(add(1,2), 3) which transforms to I64.mul(add(1,2), 3)
        // This only applies when no standalone function with this name exists (checked above).
        if e.params.len().gteq(2) {
            mut first_arg := Expr()
            e.params.get(1, first_arg)
            mut got_type := true
            mut target_type := get_value_type(context, first_arg)
            catch (err: Str) {
                got_type = false
            }
            if got_type {
                switch target_type {
                case ValueType.TCustom(custom_type_name):
                    mut method_name := format(custom_type_name, ".", combined_name)
                    mut method_found := false
                    mut dummy := context.scope_stack.lookup_func(method_name)
                    method_found = true
                    catch (err: KeyNotFoundError) {
                        // Not found
                    }
                    if method_found {
                        // Transform: func(target, args...) -> Type.func(target, args...)
                        mut new_e := Expr.new_clone(NodeType.Identifier(method_name), func_expr, Vec.new(Expr))
                        mut new_args := Vec.new(Expr)
                        new_args.push(new_e)
                        // Add remaining args
                        mut j := 1
                        while j.lt(e.params.len()) {
                            mut arg := Expr()
                            e.params.get(j, arg)
                            new_args.push(arg)
                            j = j.add(1)
                        }
                        return Expr.new_clone(NodeType.FCall, func_expr, new_args)
                    }
                case:
                }
            }
        }

        // UFCS with dot notation (e.g., a.method(b) or a.field.method())
        if func_expr.params.len().gt(0) {
            mut func_name_expr := Expr()
            func_expr.params.get(func_expr.params.len().sub(1), func_name_expr)

            switch func_name_expr.node_type {
            case NodeType.Identifier(ufcs_func_name):
                mut parts2 := combined_name.split(".")
                // Remove the method name (last element)
                if parts2.len().gt(0) {
                    parts2.remove(parts2.len().sub(1))
                }

                // Create identifier expression for the receiver (everything except the method name)
                mut id_params := func_expr.params.clone()
                if id_params.len().gt(0) {
                    id_params.remove(id_params.len().sub(1))
                }
                mut receiver_expr := Expr.new_clone(func_expr.node_type, e, id_params)

                // Try as an associated method (Type.method) first - this takes priority over standalone functions
                // because x.and(y) should resolve to Bool.and(x, y) not and(x, y) when both exist
                mut got_type2 := true
                mut value_type := get_value_type(context, receiver_expr)
                catch (err: Str) {
                    got_type2 = false
                }
                if got_type2 {
                    // Get type name from value_type - TCustom or TMulti (variadic params become Array)
                    mut custom_type_name := ""
                    mut has_type_name := false
                    switch value_type {
                    case ValueType.TCustom(type_name):
                        custom_type_name = type_name
                        has_type_name = true
                    case ValueType.TMulti:
                        custom_type_name = "Array"
                        has_type_name = true
                    case:
                    }
                    if has_type_name {
                        mut method_name := format(custom_type_name, ".", ufcs_func_name)
                        mut assoc_method_found := false
                        mut dummy5 := context.scope_stack.lookup_func(method_name)
                        assoc_method_found = true
                        catch (err: KeyNotFoundError) {
                            // Not found
                        }
                        if assoc_method_found {
                            mut new_e := Expr.new_clone(NodeType.Identifier(method_name), func_expr, Vec.new(Expr))
                            mut new_args := Vec.new(Expr)
                            new_args.push(new_e)
                            new_args.push(receiver_expr)
                            // Add remaining args
                            mut j := 1
                            while j.lt(e.params.len()) {
                                mut arg := Expr()
                                e.params.get(j, arg)
                                new_args.push(arg)
                                j = j.add(1)
                            }
                            return Expr.new_clone(NodeType.FCall, func_expr, new_args)
                        }
                    }
                }

                // Fall back to standalone function
                mut standalone_found := false
                mut dummy4 := context.scope_stack.lookup_func(ufcs_func_name)
                standalone_found = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }
                if standalone_found {
                    mut new_e := Expr.new_clone(NodeType.Identifier(ufcs_func_name), func_expr, Vec.new(Expr))
                    mut new_args := Vec.new(Expr)
                    new_args.push(new_e)
                    new_args.push(receiver_expr)
                    // Add remaining args
                    mut j := 1
                    while j.lt(e.params.len()) {
                        mut arg := Expr()
                        e.params.get(j, arg)
                        new_args.push(arg)
                        j = j.add(1)
                    }
                    return Expr.new_clone(NodeType.FCall, func_expr, new_args)
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_fcall: ", err.msg)
    }
    catch (err: AllocError) {
        throw format("precomp_fcall: ", err.msg)
    }
    catch (err: I64_OverflowError) {
        throw format("precomp_fcall: ", err.msg)
    }

    // No transformation needed
    return e
}
