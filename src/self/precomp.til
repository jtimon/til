mode liba

import("self.init")
import("self.interpreter")
import("self.precomp_ext")

// Precomputation phase: Performs compile-time constant folding for pure functions
// and handles struct/enum constructors and import().
// This phase runs after ufcs, before interpreter/builder.

// ---------- Issue #105: Early struct macro expansion

/// Build a substitution map from macro Type/Dynamic parameters to actual type names.
/// For `make_vec3(I64)` where `make_vec3` takes `T: Type`, returns {"T": "I64"}.
build_type_param_subs : func(func_def: SFuncDef, fcall: Expr) returns Map throws Str = {
    mut subs := Map.new(Str, Str)
    for i in 0..func_def.sig.args.len() {
        arg := cast(Declaration, func_def.sig.args.get(i)?)
        switch arg.value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("Type").or(type_name.eq("Dynamic")) {
                // FCall params: [0] = function name identifier, [1..] = arguments
                if fcall.params.len().gt(i.add(1)) {
                    actual_arg := cast(Expr, fcall.params.get(i.add(1))?)
                    switch actual_arg.node_type {
                    case NodeType.Identifier(actual_type_name):
                        subs.set(arg.name, actual_type_name)
                    case:
                    }
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("build_type_param_subs: ", err.msg)
    }

    return subs
}

/// Recursively replace Identifier nodes matching type param names with concrete types.
substitute_type_params_in_expr : func(e: Expr, subs: Map) returns Expr = {
    switch e.node_type {
    case NodeType.Identifier(name):
        mut new_name := name
        sub_val := cast(Str, subs.get(name)?)
        new_name = sub_val
        catch (_err: KeyNotFoundError) {
            // Expected: not all identifiers are type params
        }
        mut new_params := Vec.new(Expr)
        for p: Expr in e.params {
            new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.Identifier(new_name), e, new_params)
    case NodeType.FuncDef(func_def):
        new_func_def := substitute_type_params_in_funcdef(func_def, subs)
        mut funcdef_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            funcdef_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, funcdef_new_params)
    // Issue #106: Substitute type params in enum variant payload types
    case NodeType.EnumDef(enum_def):
        new_enum := substitute_type_params_in_enum(enum_def, subs)
        mut enumdef_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            enumdef_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(NodeType.EnumDef(new_enum), e, enumdef_new_params)
    // Issue #106: Substitute type params in switch-case pattern variant names
    case NodeType.Pattern(pattern_info):
        mut new_variant_name := pattern_info.variant_name.clone()
        // Pattern variant_name format is "EnumType.Variant" - substitute the enum type prefix
        dot_pos := pattern_info.variant_name.find(".")
        if dot_pos.gteq(0) {
            enum_prefix := pattern_info.variant_name.get_substr(0, dot_pos)?
            catch (_err: IndexOutOfBoundsError) {
                panic(loc(), "substitute_type_params_in_expr: get_substr failed on pattern variant_name")
            }
            prefix_sub := cast(Str, subs.get(enum_prefix)?)
            variant_suffix := pattern_info.variant_name.get_substr(dot_pos, pattern_info.variant_name.len())?
            catch (_err2: IndexOutOfBoundsError) {
                panic(loc(), "substitute_type_params_in_expr: get_substr failed on pattern variant_name suffix")
            }
            new_variant_name = format(prefix_sub, variant_suffix)
            catch (_err: KeyNotFoundError) {
                // Expected: enum prefix not in subs
            }
        }
        return Expr.new_clone(NodeType.Pattern(PatternInfo(variant_name=new_variant_name, binding_var=pattern_info.binding_var.clone())), e, Vec.new(Expr))
    case:
        mut default_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            default_new_params.push(substitute_type_params_in_expr(p, subs))
        }
        return Expr.new_clone(e.node_type, e, default_new_params)
    }
}

/// Substitute type param names in a FuncDef's args, return types, throw types, and body.
substitute_type_params_in_funcdef : func(func_def: SFuncDef, subs: Map) returns SFuncDef = {
    mut new_args := Vec.new(Declaration)
    for arg: Declaration in func_def.sig.args {
        mut substituted := false
        switch arg.value_type {
        case ValueType.TCustom(type_name):
            concrete := cast(Str, subs.get(type_name)?)
            new_args.push(Declaration(name=arg.name, value_type=ValueType.TCustom(concrete), is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))
            substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(substituted) {
            new_args.push(arg)
        }
    }
    mut new_returns := Vec.new(ValueType)
    for rt: ValueType in func_def.sig.return_types {
        mut rt_substituted := false
        switch rt {
        case ValueType.TCustom(type_name):
            rt_concrete := cast(Str, subs.get(type_name)?)
            new_returns.push(ValueType.TCustom(rt_concrete))
            rt_substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(rt_substituted) {
            new_returns.push(rt)
        }
    }
    mut new_throws := Vec.new(ValueType)
    for tt: ValueType in func_def.sig.throw_types {
        mut tt_substituted := false
        switch tt {
        case ValueType.TCustom(type_name):
            tt_concrete := cast(Str, subs.get(type_name)?)
            new_throws.push(ValueType.TCustom(tt_concrete))
            tt_substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(tt_substituted) {
            new_throws.push(tt)
        }
    }
    mut new_body := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        new_body.push(substitute_type_params_in_expr(stmt, subs))
    }
    mut new_func_def := SFuncDef()
    new_func_def.sig = FuncSig(
        function_type=func_def.sig.function_type,
        args=new_args,
        return_types=new_returns,
        throw_types=new_throws
    )
    new_func_def.arg_names = func_def.arg_names.clone()
    new_func_def.body = new_body
    new_func_def.source_path = func_def.source_path.clone()
    return new_func_def
}

/// Apply type param substitution to a struct definition's member types and default values.
substitute_type_params_in_struct : func(struct_def: SStructDef, subs: Map) returns SStructDef = {
    mut new_members := Vec.new(Declaration)
    for member: Declaration in struct_def.members {
        mut substituted := false
        switch member.value_type {
        case ValueType.TCustom(type_name):
            concrete_type := cast(Str, subs.get(type_name)?)
            new_members.push(Declaration(name=member.name, value_type=ValueType.TCustom(concrete_type), is_mut=member.is_mut, is_copy=member.is_copy, is_own=member.is_own))
            substituted = true
            catch (_err: KeyNotFoundError) {
                // Expected: not all types need substitution
            }
        case:
        }
        if not(substituted) {
            new_members.push(member)
        }
    }

    mut new_defaults := Map.new(Str, Expr)
    for name: Str in struct_def.default_values.keys {
        expr := cast(Expr, struct_def.default_values.get(name)?)
        catch (err: KeyNotFoundError) {
            panic(loc(), format("KeyNotFoundError iterating keys: ", err.msg))
        }
        new_defaults.set(name, substitute_type_params_in_expr(expr, subs))
    }

    return SStructDef(members=new_members, default_values=new_defaults)
}

/// Issue #106: Apply type param substitution to an enum definition's variant payload types.
substitute_type_params_in_enum : func(enum_def: SEnumDef, subs: Map) returns SEnumDef = {
    mut new_variants := Vec.new(EnumVariant)
    for v: EnumVariant in enum_def.variants {
        if not(v.payload_type.is_null()) {
            // Read the ValueType from the Ptr
            mut pt := ValueType.TCustom("")
            memcpy(to_ptr(pt), v.payload_type.data, size_of(ValueType))
            switch pt {
            case ValueType.TCustom(type_name):
                sub_val := cast(Str, subs.get(type_name)?)
                // Build new variant with substituted payload type
                mut new_payload := ValueType.TCustom(sub_val)
                mut new_variant := EnumVariant()
                new_variant.name = v.name.clone()
                new_variant.payload_type.data = malloc(size_of(ValueType))?
                catch (err: BadAlloc) { panic(loc(), "substitute_type_params_in_enum: malloc failed") }
                memcpy(new_variant.payload_type.data, to_ptr(new_payload), size_of(ValueType))
                new_variants.push(new_variant)
                catch (_err: KeyNotFoundError) {
                    new_variants.push(v.clone())
                }
            case:
                new_variants.push(v.clone())
            }
        } else {
            new_variants.push(v.clone())
        }
    }
    return SEnumDef(variants=new_variants, methods=enum_def.methods.clone())
}

/// Extract namespace stmts from a macro's body AST.
/// Scans for Return nodes or Declaration nodes containing a StructDef or EnumDef with params (namespace stmts).
/// Returns the first matching set of namespace params (simple macros only).
extract_namespace_stmts_from_macro : func(func_def: SFuncDef) returns Vec = {
    mut result := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        // Pattern 1: return struct/enum { ... namespace: ... }
        switch stmt.node_type {
        case NodeType.Return:
            if stmt.params.len().gt(0) {
                ret_val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_namespace_stmts_from_macro: IndexOutOfBoundsError after len check")
                }
                mut ret_is_type_def := false
                switch ret_val.node_type {
                case NodeType.StructDef(_):
                    ret_is_type_def = true
                case NodeType.EnumDef(_):
                    ret_is_type_def = true
                case:
                }
                if ret_is_type_def.and(ret_val.params.len().gt(0)) {
                    for p: Expr in ret_val.params {
                        result.push(p.clone())
                    }
                    return result
                }
            }
        case:
        }
        // Pattern 2: TemplatedPtr/TemplatedOption := struct/enum { ... namespace: ... }
        switch stmt.node_type {
        case NodeType.Declaration(_):
            if stmt.params.len().gt(0) {
                val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_namespace_stmts_from_macro: IndexOutOfBoundsError after len check")
                }
                mut val_is_type_def := false
                switch val.node_type {
                case NodeType.StructDef(_):
                    val_is_type_def = true
                case NodeType.EnumDef(_):
                    val_is_type_def = true
                case:
                }
                if val_is_type_def.and(val.params.len().gt(0)) {
                    for p: Expr in val.params {
                        result.push(p.clone())
                    }
                    return result
                }
            }
        case:
        }
    }
    return result
}

/// Extract the internal type name from a macro body (e.g., "TemplatedPtr" from
/// `TemplatedPtr := struct { ... }` or "TemplatedOption" from `TemplatedOption := enum { ... }`).
/// Returns empty string for anonymous types (`return struct/enum { ... }`).
extract_internal_type_name : func(func_def: SFuncDef) returns Str = {
    for stmt: Expr in func_def.body {
        switch stmt.node_type {
        case NodeType.Declaration(inner_decl):
            if stmt.params.len().gt(0) {
                val := cast(Expr, stmt.params.get(0)?)
                catch (_err: IndexOutOfBoundsError) {
                    panic(loc(), "extract_internal_type_name: IndexOutOfBoundsError after len check")
                }
                mut is_type_def := false
                switch val.node_type {
                case NodeType.StructDef(_):
                    is_type_def = true
                case NodeType.EnumDef(_):
                    is_type_def = true
                case:
                }
                if is_type_def {
                    return inner_decl.name
                }
            }
        case:
        }
    }
    return ""
}

/// Issue #105: Expand struct-returning macros before type checking.
/// Runs between init and typer to make struct definitions available for type checking.
/// Only expands macros at the top-level body that return struct definitions.
expand_struct_macros : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.Body:
    case:
        return e.clone()
    }

    mut new_params := Vec.new(Expr)
    mut modified := false

    for p: Expr in e.params {
        mut handled := false
        switch p.node_type {
        case NodeType.Declaration(decl):
            if p.params.len().gt(0) {
                inner_e := p.get(0)?
                switch inner_e.node_type {
                case NodeType.FCall(_):
                    // Check if the function is a macro returning struct
                    f_name := get_func_name_in_call(inner_e)?
                    mut found_func := false
                    mut func_def := SFuncDef()
                    func_def = context.scope_stack.lookup_func(f_name)?
                    found_func = true
                    catch (_err: KeyNotFoundError) {
                        // Expected: not all calls are to known functions
                    }
                    if found_func {
                        if func_def.is_macro() {
                            if func_def.sig.return_types.len().gt(0) {
                                // Extract all data from func_def before mutable borrows
                                macro_return_type := cast(ValueType, func_def.sig.return_types.get(0)?)
                                catch (_err: IndexOutOfBoundsError) {
                                    panic(loc(), "IndexOutOfBoundsError getting return type after len check")
                                }
                                type_subs := build_type_param_subs(func_def, inner_e)?
                                macro_ns_stmts := extract_namespace_stmts_from_macro(func_def)
                                macro_internal_name := extract_internal_type_name(func_def)

                                // Check for struct-returning macro
                                mut is_struct_macro := false
                                switch macro_return_type {
                                case ValueType.TType(TTypeDef.TStructDef):
                                    is_struct_macro = true
                                case:
                                }
                                if is_struct_macro {
                                    // Expand the macro (mutably borrows context)
                                    expanded := eval_comptime(context, inner_e)?
                                    switch expanded.node_type {
                                    case NodeType.StructDef(struct_def):
                                        // Substitute type params (e.g. T -> I64) in member types and defaults
                                        mut substituted := struct_def.clone()
                                        if type_subs.keys.len().gt(0) {
                                            substituted = substitute_type_params_in_struct(struct_def, type_subs)
                                        }
                                        // Resolve INFER_TYPE in struct members from default values
                                        mut resolved_members := Vec.new(Declaration)
                                        for member_decl: Declaration in substituted.members {
                                            mut resolved := false
                                            switch member_decl.value_type {
                                            case ValueType.TCustom(type_name):
                                                if type_name.eq(INFER_TYPE) {
                                                    default_value := cast(Expr, substituted.default_values.get(member_decl.name)?)
                                                    mut resolved_type := get_value_type(context, default_value)?
                                                    catch (_err: Str) {}
                                                    resolved_member := Declaration(name=member_decl.name, value_type=resolved_type, is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own)
                                                    resolved_members.push(resolved_member)
                                                    resolved = true
                                                    catch (_err: KeyNotFoundError) {
                                                        // Expected: not all members have defaults
                                                    }
                                                }
                                            case:
                                            }
                                            if not(resolved) {
                                                resolved_members.push(member_decl)
                                            }
                                        }
                                        // Issue #105: Precompute struct default values (e.g. NULL -> 0)
                                        // Defaults come from macro body AST and weren't processed by precomp
                                        mut precomputed_defaults := Map.new(Str, Expr)
                                        mut cur_def_key := ""
                                        for def_key: Str in substituted.default_values.keys {
                                            cur_def_key = def_key
                                            def_val := cast(Expr, substituted.default_values.get(def_key)?)
                                            catch (err: KeyNotFoundError) {
                                                panic(loc(), format("KeyNotFoundError iterating keys: ", err.msg))
                                            }
                                            mut precomputed := precomp_expr(context, def_val)?
                                            precomputed_defaults.set(cur_def_key, precomputed)
                                            catch (_err: Str) {
                                                precomputed_defaults.set(cur_def_key, def_val)
                                            }
                                        }
                                        resolved_struct := SStructDef(members=resolved_members, default_values=precomputed_defaults)
                                        resolved_expanded := Expr.new_clone(NodeType.StructDef(resolved_struct.clone()), expanded, Vec.new(Expr))
                                        // Register the struct in context
                                        context.scope_stack.declare_struct(decl.name, resolved_struct.clone())?
                                        // Register immutable fields as namespace constants (same as init_context for regular structs)
                                        for member_decl: Declaration in resolved_struct.members {
                                            if not(member_decl.is_mut) {
                                                mut has_default_value := false
                                                member_expr := cast(Expr, resolved_struct.default_values.get(member_decl.name)?)
                                                has_default_value = true
                                                catch (key_err: KeyNotFoundError) {
                                                    // No default value, skip this member
                                                }
                                                if has_default_value {
                                                    mut member_value_type := ValueType.TCustom(INFER_TYPE)
                                                    member_value_type = get_value_type(context, member_expr)?
                                                    catch (err: Str) {
                                                        // Failed to get type - just use INFER_TYPE default
                                                    }
                                                    member_full_name := format(decl.name, ".", member_decl.name)
                                                    ScopeStack.declare_symbol(context.scope_stack, member_full_name.clone(), SymbolInfo(value_type=value_type_clone(member_value_type), is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own))?
                                                }
                                            }
                                        }
                                        // Replace the FCall with the StructDef in the AST
                                        mut expanded_params := Vec.new(Expr)
                                        expanded_params.push(resolved_expanded)
                                        new_p := Expr.new_clone(p.node_type, p, expanded_params)
                                        new_params.push(new_p)
                                        // Issue #105: Check if macro namespace stmts already define delete/clone
                                        mut ns_has_delete := false
                                        mut ns_has_clone := false
                                        for ns_stmt: Expr in macro_ns_stmts {
                                            switch ns_stmt.node_type {
                                            case NodeType.Declaration(ns_stmt_decl):
                                                if ns_stmt_decl.name.eq("delete") {
                                                    ns_has_delete = true
                                                }
                                                if ns_stmt_decl.name.eq("clone") {
                                                    ns_has_clone = true
                                                }
                                            case:
                                            }
                                        }
                                        // Generate delete/clone methods only if not provided by macro namespace
                                        mut auto_struct := resolved_struct.clone()
                                        if ns_has_delete.or(ns_has_clone) {
                                            // Add fake members so generate_struct_methods skips them
                                            dummy := Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), 0, 0)
                                            if ns_has_delete {
                                                auto_struct.default_values.set("delete", dummy.clone())
                                            }
                                            if ns_has_clone {
                                                auto_struct.default_values.set("clone", dummy)
                                            }
                                        }
                                        methods_result := generate_struct_methods(decl.name, auto_struct, p.line, p.col)
                                        if methods_result.needs_methods {
                                            // Run init on the namespace block to register the methods
                                            mut ns_body_params := Vec.new(Expr)
                                            ns_body_params.push(methods_result.ns_block.clone())
                                            ns_body := Expr.new_clone(NodeType.Body, p, ns_body_params)
                                            _ := init_context(context, ns_body)?
                                            new_params.push(methods_result.ns_block)
                                        }
                                        // Issue #105: Process namespace stmts extracted from macro body
                                        if macro_ns_stmts.len().gt(0) {
                                            // Build substitution map: type params + internal struct name -> external name
                                            mut ns_subs := type_subs.clone()
                                            if not(macro_internal_name.eq("")) {
                                                ns_subs.set(macro_internal_name, decl.name)
                                            }
                                            // Apply type substitution to namespace stmts
                                            mut substituted_stmts := Vec.new(Expr)
                                            for ns_s: Expr in macro_ns_stmts {
                                                substituted_stmts.push(substitute_type_params_in_expr(ns_s, ns_subs))
                                            }
                                            // Build NamespaceDef from substituted stmts (same pattern as split_inline_namespaces)
                                            mut ns_members := Vec.new(Declaration)
                                            mut ns_default_values := Map.new(Str, Expr)
                                            for sub_stmt: Expr in substituted_stmts {
                                                switch sub_stmt.node_type {
                                                case NodeType.Declaration(ns_decl):
                                                    ns_members.push(ns_decl.clone())
                                                    if sub_stmt.params.len().gt(0) {
                                                        ns_val := cast(Expr, sub_stmt.params.get(0)?)
                                                        catch (_err: IndexOutOfBoundsError) {
                                                            panic(loc(), "sub_stmt.params.get(0) after len check")
                                                        }
                                                        ns_default_values.set(ns_decl.name, ns_val)
                                                    }
                                                case NodeType.Assignment(assign_name):
                                                    if sub_stmt.params.len().gt(0) {
                                                        assign_ns_val := cast(Expr, sub_stmt.params.get(0)?)
                                                        catch (_err: IndexOutOfBoundsError) {
                                                            panic(loc(), "sub_stmt.params.get(0) after len check")
                                                        }
                                                        ns_assign_decl := Declaration(name=assign_name, value_type=ValueType.TCustom(INFER_TYPE), is_mut=false, is_copy=false, is_own=false)
                                                        ns_members.push(ns_assign_decl)
                                                        ns_default_values.set(assign_name, assign_ns_val)
                                                    }
                                                case:
                                                }
                                            }
                                            if ns_members.len().gt(0) {
                                                mut user_ns_def := SNamespaceDef()
                                                user_ns_def.type_name = decl.name
                                                user_ns_def.members = ns_members
                                                user_ns_def.default_values = ns_default_values
                                                user_ns_expr := Expr.new_explicit(NodeType.NamespaceDef(user_ns_def), Vec.new(Expr), p.line, p.col)
                                                // Run init on the namespace to register methods
                                                mut user_ns_body_params := Vec.new(Expr)
                                                user_ns_body_params.push(user_ns_expr.clone())
                                                user_ns_body := Expr.new_clone(NodeType.Body, p, user_ns_body_params)
                                                user_ns_errors := init_context(context, user_ns_body)?
                                                if user_ns_errors.len().gt(0) {
                                                    mut err_msg := ""
                                                    for user_err: Str in user_ns_errors {
                                                        if err_msg.len().gt(0) {
                                                            err_msg = format(err_msg, "\n", user_err)
                                                        } else {
                                                            err_msg = user_err
                                                        }
                                                    }
                                                    throw err_msg
                                                }
                                                new_params.push(user_ns_expr)
                                            }
                                        }
                                        modified = true
                                        handled = true
                                    case:
                                    }
                                }
                                // Issue #106: Check if macro returns an enum definition
                                mut is_enum_macro := false
                                switch macro_return_type {
                                case ValueType.TType(TTypeDef.TEnumDef):
                                    is_enum_macro = true
                                case:
                                }
                                if is_enum_macro.and(not(handled)) {
                                    // Expand the macro
                                    enum_expanded := eval_comptime(context, inner_e)?
                                    switch enum_expanded.node_type {
                                    case NodeType.EnumDef(enum_def):
                                        // Substitute type params in variant payload types
                                        mut enum_substituted := enum_def.clone()
                                        if type_subs.keys.len().gt(0) {
                                            enum_substituted = substitute_type_params_in_enum(enum_def, type_subs)
                                        }
                                        // Clear preinit-generated methods (they reference the internal name)
                                        // They'll be regenerated with the correct external name below
                                        enum_substituted.methods = Map.new(Str, Expr)
                                        enum_resolved_expanded := Expr.new_clone(NodeType.EnumDef(enum_substituted.clone()), enum_expanded, Vec.new(Expr))
                                        // Register the enum in context
                                        context.scope_stack.declare_enum(decl.name, enum_substituted.clone())?
                                        // Replace the FCall with the EnumDef in the AST
                                        mut enum_expanded_params := Vec.new(Expr)
                                        enum_expanded_params.push(enum_resolved_expanded)
                                        enum_new_p := Expr.new_clone(p.node_type, p, enum_expanded_params)
                                        new_params.push(enum_new_p)
                                        // Check if macro namespace stmts already define delete/clone
                                        mut enum_ns_has_delete := false
                                        mut enum_ns_has_clone := false
                                        for enum_ns_stmt: Expr in macro_ns_stmts {
                                            switch enum_ns_stmt.node_type {
                                            case NodeType.Declaration(enum_ns_stmt_decl):
                                                if enum_ns_stmt_decl.name.eq("delete") {
                                                    enum_ns_has_delete = true
                                                }
                                                if enum_ns_stmt_decl.name.eq("clone") {
                                                    enum_ns_has_clone = true
                                                }
                                            case:
                                            }
                                        }
                                        // Generate delete/clone methods if not provided by macro namespace
                                        enum_methods_result := generate_enum_methods(decl.name, enum_ns_has_delete, enum_ns_has_clone, p.line, p.col)
                                        if enum_methods_result.needs_methods {
                                            mut enum_ns_body_params := Vec.new(Expr)
                                            enum_ns_body_params.push(enum_methods_result.ns_block.clone())
                                            enum_ns_body := Expr.new_clone(NodeType.Body, p, enum_ns_body_params)
                                            _ := init_context(context, enum_ns_body)?
                                            new_params.push(enum_methods_result.ns_block)
                                        }
                                        // Process namespace stmts extracted from macro body
                                        if macro_ns_stmts.len().gt(0) {
                                            mut enum_ns_subs := type_subs.clone()
                                            if not(macro_internal_name.eq("")) {
                                                enum_ns_subs.set(macro_internal_name, decl.name)
                                            }
                                            // Apply type substitution to namespace stmts
                                            mut enum_substituted_stmts := Vec.new(Expr)
                                            for enum_ns_s: Expr in macro_ns_stmts {
                                                enum_substituted_stmts.push(substitute_type_params_in_expr(enum_ns_s, enum_ns_subs))
                                            }
                                            // Build NamespaceDef from substituted stmts
                                            mut enum_ns_members := Vec.new(Declaration)
                                            mut enum_ns_default_values := Map.new(Str, Expr)
                                            for enum_sub_stmt: Expr in enum_substituted_stmts {
                                                switch enum_sub_stmt.node_type {
                                                case NodeType.Declaration(enum_ns_decl):
                                                    enum_ns_members.push(enum_ns_decl.clone())
                                                    if enum_sub_stmt.params.len().gt(0) {
                                                        enum_ns_val := cast(Expr, enum_sub_stmt.params.get(0)?)
                                                        catch (_err: IndexOutOfBoundsError) {
                                                            panic(loc(), "enum_sub_stmt.params.get(0) after len check")
                                                        }
                                                        enum_ns_default_values.set(enum_ns_decl.name, enum_ns_val)
                                                    }
                                                case NodeType.Assignment(enum_assign_name):
                                                    if enum_sub_stmt.params.len().gt(0) {
                                                        enum_assign_ns_val := cast(Expr, enum_sub_stmt.params.get(0)?)
                                                        catch (_err: IndexOutOfBoundsError) {
                                                            panic(loc(), "enum_sub_stmt.params.get(0) after len check")
                                                        }
                                                        enum_ns_assign_decl := Declaration(name=enum_assign_name, value_type=ValueType.TCustom(INFER_TYPE), is_mut=false, is_copy=false, is_own=false)
                                                        enum_ns_members.push(enum_ns_assign_decl)
                                                        enum_ns_default_values.set(enum_assign_name, enum_assign_ns_val)
                                                    }
                                                case:
                                                }
                                            }
                                            if enum_ns_members.len().gt(0) {
                                                mut enum_user_ns_def := SNamespaceDef()
                                                enum_user_ns_def.type_name = decl.name
                                                enum_user_ns_def.members = enum_ns_members
                                                enum_user_ns_def.default_values = enum_ns_default_values
                                                enum_user_ns_expr := Expr.new_explicit(NodeType.NamespaceDef(enum_user_ns_def), Vec.new(Expr), p.line, p.col)
                                                // Run init on the namespace to register methods
                                                mut enum_user_ns_body_params := Vec.new(Expr)
                                                enum_user_ns_body_params.push(enum_user_ns_expr.clone())
                                                enum_user_ns_body := Expr.new_clone(NodeType.Body, p, enum_user_ns_body_params)
                                                enum_user_ns_errors := init_context(context, enum_user_ns_body)?
                                                if enum_user_ns_errors.len().gt(0) {
                                                    mut enum_err_msg := ""
                                                    for enum_user_err: Str in enum_user_ns_errors {
                                                        if enum_err_msg.len().gt(0) {
                                                            enum_err_msg = format(enum_err_msg, "\n", enum_user_err)
                                                        } else {
                                                            enum_err_msg = enum_user_err
                                                        }
                                                    }
                                                    throw enum_err_msg
                                                }
                                                new_params.push(enum_user_ns_expr)
                                            }
                                        }
                                        modified = true
                                        handled = true
                                    case:
                                    }
                                }
                            }
                        }
                    }
                case:
                }
            }
        case:
        }
        if not(handled) {
            new_params.push(p)
        }
    }

    if modified {
        return Expr.new_clone(e.node_type, e, new_params)
    }
    return e.clone()
}

// ---------- Main entry point

/// Precomputation phase: Perform compile-time constant folding and handle
/// struct/enum constructors and import().
/// Takes an AST that has already passed type checking and UFCS resolution.
precomp_expr : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.Body:
        return precomp_body(context, e)?
    case NodeType.FCall(_):
        mut const_folded := precomp_fcall(context, e)?
        // Try compile-time constant folding for pure functions with literal args.
        // Only fold at global scope - inside function definitions, values from other
        // modules may not be available yet (import ordering). Interpreter doesn't
        // evaluate function bodies during import either.
        at_global_scope := context.scope_stack.frames.len().eq(1)

        // Check if this is a macro call - macros MUST be evaluated at compile-time
        // but only when called at global scope with comptime args (same as funcs,
        // just with an error if args aren't comptime instead of silent skip)
        is_macro_call := is_macro_fcall(context, const_folded)
        if at_global_scope.and(is_macro_call) {
            // Macros require all arguments to be compile-time evaluable
            if not(is_comptime_evaluable(context, const_folded)?) {
                f_name := get_func_name_in_call(const_folded)?
                throw const_folded.error(context.path, "precomp",
                    format("Macro '", f_name, "' requires all arguments to be compile-time constants"))
            }
            // Force compile-time evaluation
            const_folded = eval_comptime(context, const_folded)?
            return const_folded
        }

        if at_global_scope.and(is_comptime_evaluable(context, const_folded)?) {
            const_folded = eval_comptime(context, const_folded)?
        }
        return const_folded
    case NodeType.If:
        return precomp_params(context, e)?
    case NodeType.While:
        return precomp_params(context, e)?
    case NodeType.Switch:
        throw e.lang_error(context.path, "precomp", "Switch should have been desugared to if/else by desugarer phase")
    case NodeType.FuncDef(func_def):
        return precomp_func_def(context, e, func_def)?
    case NodeType.Declaration(decl):
        return precomp_declaration(context, e, decl)?
    case NodeType.Assignment:
        return precomp_params(context, e)?
    case NodeType.Return:
        return precomp_params(context, e)?
    case NodeType.Throw:
        return precomp_params(context, e)?
    case NodeType.Catch:
        return precomp_catch(context, e)?
    case NodeType.Range:
        return precomp_params(context, e)?
    // Struct/enum definitions - need to process default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        return precomp_struct_def(context, e, struct_def)?
    case NodeType.EnumDef:
        return e.clone()
    // Identifiers can have nested params (e.g., a.b.c for field access chains)
    case NodeType.Identifier:
        return precomp_params(context, e)?
    // Leaf nodes - no transformation needed
    case NodeType.LLiteral:
        return e.clone()
    case NodeType.DefaultCase:
        return e.clone()
    case NodeType.Pattern:
        return e.clone()
    // Break and Continue are leaf nodes (no params) - no transformation needed
    case NodeType.Break:
        return e.clone()
    case NodeType.Continue:
        return e.clone()
    // Named arguments - transform the value expression
    case NodeType.NamedArg(name):
        mut new_params := Vec.new(Expr)
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(NodeType.NamedArg(name), e, new_params)
    // Issue #108: NamespaceDef - transform function bodies and update scope_stack
    case NodeType.NamespaceDef(ns_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in ns_def.default_values.keys {
            value_expr := cast(Expr, ns_def.default_values.get(name)?)
            catch (err: KeyNotFoundError) {
                panic(loc(), format("KeyNotFoundError iterating keys: ", err.msg))
            }

            mut is_func := false
            switch value_expr.node_type {
            case NodeType.FuncDef(_):
                is_func = true
            case:
            }

            saved_func := context.current_precomp_func.clone()
            saved_counter := context.precomp_forin_counter
            if is_func {
                context.current_precomp_func = name.clone()
                context.precomp_forin_counter = 0
            }

            transformed := precomp_expr(context, value_expr)?

            // Update scope_stack with transformed FuncDef so interpreter uses it
            switch transformed.node_type {
            case NodeType.FuncDef(func_def):
                full_name := format(ns_def.type_name, ".", name)
                context.scope_stack.update_func(full_name, func_def.clone())?
                catch (err: Str) {
                    panic(loc(), format("update_func failed: ", err))
                }
            case:
                // Not a func, nothing to update
            }

            new_default_values.set(name.clone(), transformed)

            if is_func {
                context.current_precomp_func = saved_func
                context.precomp_forin_counter = saved_counter
            }
        }
        mut new_ns_def := SNamespaceDef()
        new_ns_def.type_name = ns_def.type_name.clone()
        new_ns_def.members = ns_def.members.clone()
        new_ns_def.default_values = new_default_values
        return Expr.new_clone(NodeType.NamespaceDef(new_ns_def), e, Vec.new(Expr))
    // ForIn should have been desugared in desugarer phase
    case NodeType.ForIn(_):
        panic(loc(), "ForIn should have been desugared in desugarer phase")
    }
}

// ---------- Compile-time constant folding

/// Check if an FCall is a macro call.
is_macro_fcall : proc(context: Context, e: Expr) returns Bool = {
    mut e_clone := e.clone()
    func_def := get_func_def_for_fcall_with_expr(context, e_clone)?
    result := func_def.is_macro()

    catch (_err: Str) {
        return false
    }
    catch (_err: KeyNotFoundError) {
        return false
    }

    return result
}

/// Check if an expression can be evaluated at compile time.
/// Currently only handles literals and pure function calls with literal arguments.
is_comptime_evaluable : proc(context: Context, e: Expr) returns Bool throws Str = {
    switch e.node_type {
    case NodeType.LLiteral:
        return true
    // Type definitions and function definitions are static metadata - always comptime
    case NodeType.StructDef:
        return true
    case NodeType.EnumDef:
        return true
    case NodeType.FuncDef:
        return true
    case NodeType.Identifier(name):
        // Check if this is a simple identifier (no field access chain)
        if e.params.len().gt(0) {
            return false  // Field access chains not supported
        }
        // Look up the symbol and check if it's a comptime const
        mut symbol := context.scope_stack.lookup_symbol(name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        return symbol.is_comptime_const
    case NodeType.FCall(_):
        f_name := get_func_name_in_call(e)?
        catch (err: Str) {
            return false  // Can't get function name
        }
        // Special case: exit terminates the program
        if f_name.eq("exit") { return false }
        // TODO: Properly detect ext_funcs and functions with side effects.
        // For now, hardcode malloc exclusion since it's an ext_func with side effects.
        if f_name.eq("malloc") { return false }

        // Use get_func_def_for_fcall_with_expr like interpreter does
        mut e_clone := e.clone()
        mut func_def := SFuncDef()
        mut func_def_found := false
        func_def = get_func_def_for_fcall_with_expr(context, e_clone)?
        func_def_found = true
        catch (err: KeyNotFoundError) {
            // Could be a struct constructor - check if all args are comptime
            combined_name := get_combined_name(context.path, e.get(0)?)?
            catch (err2: Str) {
                return false
            }
            // Try to look up as struct
            mut is_struct := false
            _ := context.scope_stack.lookup_struct(combined_name)?
            is_struct = true
            catch (err3: KeyNotFoundError) {
                // REM: Not a struct
            }
            if is_struct {
                // It's a struct constructor - check all args are comptime
                mut struct_j := 1
                while struct_j.lt(e.params.len()) {
                    struct_arg := e.get(struct_j)?
                    dont_delete(struct_arg)
                    // Handle named args - check the value inside
                    mut arg_to_check := struct_arg
                    switch struct_arg.node_type {
                    case NodeType.NamedArg(_):
                        if struct_arg.params.len().gt(0) {
                            atc := cast(Expr, struct_arg.params.get(0)?)
                            arg_to_check = atc
                            catch (err5: IndexOutOfBoundsError) {
                                panic(loc(), "struct_arg.params.get(0): len > 0 checked: ", err5.msg)
                            }
                        }
                    case:
                    }
                    if not(is_comptime_evaluable(context, arg_to_check)?) {
                        return false
                    }
                    struct_j.inc()
                }
                return true  // Struct constructor with all comptime args
            }
            // Check if it's an enum constructor (e.g., Color.Green(true))
            if context.scope_stack.is_enum_constructor(combined_name) {
                // It's an enum constructor - check all args are comptime
                mut k := 1
                while k.lt(e.params.len()) {
                    arg := e.get(k)?
                    dont_delete(arg)
                    if not(is_comptime_evaluable(context, arg)?) {
                        return false
                    }
                    k.inc()
                }
                return true
            }
            return false  // Unknown function
        }
        catch (err: Str) {
            return false  // Function lookup error
        }
        if not(func_def_found) {
            return false
        }
        // Must be pure function (not proc) that returns a value
        if func_def.is_proc() {
            return false
        }
        // Funcs with no return type can't be folded (nothing to fold to)
        if func_def.sig.return_types.len().eq(0) {
            return false
        }
        // Functions that can throw are allowed - if they actually throw,
        // we'll report the error in eval_comptime.
        // All arguments must be comptime-evaluable
        mut fcall_i := 1
        while fcall_i.lt(e.params.len()) {
            fcall_arg := e.get(fcall_i)?
            dont_delete(fcall_arg)
            if not(is_comptime_evaluable(context, fcall_arg)?) {
                return false
            }
            fcall_i.inc()
        }
        return true
    case:
        return false
    }
}

/// Evaluate a comptime-evaluable expression and convert result back to AST literal.
eval_comptime : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    // Save and restore context.path - interpreter may change it during function calls
    saved_path := context.path
    result := eval_expr(context, e)?
    catch (err: Str) {
        // REM: Restore context.path before re-throwing (Rust captures Result, restores, then ?)
        context.path = saved_path
        throw err
    }
    context.path = saved_path

    // Check if the function threw an exception during evaluation
    if result.is_throw {
        mut thrown_type := result.thrown_type
        if thrown_type.eq("") {
            thrown_type = "unknown"
        }
        throw e.error(context.path, "precomp", format("Exception '", thrown_type, "' thrown during precomputation: ", result.value))
    }

    // EvalResult.value is a String representation of the value
    // Convert back to LLiteral based on the result type
    value_type := get_value_type(context, e)?
    switch value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("U8") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Number(result.value)), e, Vec.new(Expr))
        }
        if type_name.eq("Str") {
            return Expr.new_clone(NodeType.LLiteral(Literal.Str(result.value)), e, Vec.new(Expr))
        }
        // Check if it's a struct type - result.value is the instance name
        _struct_def := context.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            // For enums and other types: eval_expr was called (catching any errors),
            // but we can't convert the result back to AST literal, so return original
            return e.clone()
        }
        // Try to convert struct back to literal, fall back to original expr if unsupported
        mut struct_literal := EvalHeap.to_struct_literal(context, result.value, type_name, e)?
        catch (err: Str) {
            return e.clone()
        }
        return struct_literal
    case ValueType.TType(TTypeDef.TStructDef):
        // Issue #105: First-class structs - macro returning a struct definition
        struct_name := result.value
        sd := context.scope_stack.lookup_struct(struct_name)?
        catch (err: KeyNotFoundError) {
            throw e.error(context.path, "precomp", format("Macro returned struct type but definition '", struct_name, "' not found"))
        }
        return Expr.new_clone(NodeType.StructDef(sd.clone()), e, Vec.new(Expr))
    // Issue #106: First-class enums - macro returning an enum definition
    case ValueType.TType(TTypeDef.TEnumDef):
        enum_name := result.value
        enum_def := context.scope_stack.lookup_enum(enum_name)?
        return Expr.new_clone(NodeType.EnumDef(enum_def.clone()), e, Vec.new(Expr))
        catch (_err: KeyNotFoundError) {
            throw e.error(context.path, "precomp", format("Macro returned enum type but definition '", enum_name, "' not found"))
        }
    case:
        // For other types, eval was done (errors caught), return original (no folding)
        return e.clone()
    }

}

// ---------- AST transformation

/// Transform Body node - recursively transform all statements
precomp_body : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        new_params.push(precomp_expr(context, p)?)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform node params - recursively transform all child expressions
precomp_params : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    mut new_params := Vec.new(Expr)
    for p: Expr in e.params {
        new_params.push(precomp_expr(context, p)?)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform StructDef - recursively transform default values (which contain function defs)
precomp_struct_def : proc(mut context: Context, e: Expr, struct_def: SStructDef) returns Expr throws Str = {
    mut new_default_values := Map.new(Str, Expr)
    mut i := 0
    while i.lt(struct_def.default_values.keys.len()) {
        name := cast(Str, struct_def.default_values.keys.get(i)?)
        value_expr := cast(Expr, struct_def.default_values.get(name)?)

        // Bug #40 fix: For method definitions, set function name context
        mut is_func := false
        switch value_expr.node_type {
        case NodeType.FuncDef:
            is_func = true
        case:
        }
        saved_func := context.current_precomp_func
        saved_counter := context.precomp_forin_counter
        if is_func {
            context.current_precomp_func = name
            context.precomp_forin_counter = 0
        }

        new_default_values.set(name, precomp_expr(context, value_expr)?)

        // Bug #40 fix: Restore previous function context
        if is_func {
            context.current_precomp_func = saved_func
            context.precomp_forin_counter = saved_counter
        }

        i.inc()
    }
    mut new_struct_def := SStructDef()
    new_struct_def.members = struct_def.members.clone()
    new_struct_def.default_values = new_default_values

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_struct_def: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("precomp_struct_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params.clone())
}

/// Transform FuncDef - push scope frame for function args, transform body, pop frame
precomp_func_def : proc(mut context: Context, e: Expr, func_def: SFuncDef) returns Expr throws Str = {
    // Push a new scope frame with the function's parameters
    context.scope_stack.push(ScopeType.Function)
    for arg: Declaration in func_def.sig.args {
        sym := SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
        context.scope_stack.declare_symbol(arg.name, sym)?
    }

    // Transform the function body
    mut new_body := Vec.new(Expr)
    for stmt: Expr in func_def.body {
        new_body.push(precomp_expr(context, stmt)?)
    }

    // Pop the function scope frame
    _ := context.scope_stack.pop()?

    new_func_def := SFuncDef(
        sig=FuncSig(
            function_type=func_def.sig.function_type,
            args=func_def.sig.args,
            return_types=func_def.sig.return_types,
            throw_types=func_def.sig.throw_types
        ),
        arg_names=func_def.arg_names,
        body=new_body,
        source_path=func_def.source_path
    )

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_func_def: ", err.msg)
    }

    return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params.clone())
}

/// Transform Declaration - register the declared variable in scope, then transform value
precomp_declaration : proc(mut context: Context, e: Expr, decl: Declaration) returns Expr throws Str = {
    // Eagerly create default instance template for this struct type
    inner_e := e.get(0)?
    mut value_type := get_value_type(context, inner_e)?
    catch (err: Str) {
        throw e.lang_error(context.path, "precomp", err)
    }

    // Issue #91: Detect function signature definitions
    // A FuncDef with empty body and type-only args (no names) is a function signature type
    switch inner_e.node_type {
    case NodeType.FuncDef(func_def):
        if func_def.body.len().eq(0) {
            mut all_type_only := true
            for arg: Declaration in func_def.sig.args {
                if not(arg.name.eq("")) {
                    all_type_only = false
                }
            }
            if all_type_only {
                mut is_func_or_proc := false
                switch func_def.sig.function_type {
                case FunctionType.FTFunc:
                    is_func_or_proc = true
                case FunctionType.FTProc:
                    is_func_or_proc = true
                case:
                }
                if is_func_or_proc {
                    value_type = ValueType.TType(TTypeDef.TFuncSig)
                }
            }
        }
    case:
    }

    // Issue #105: Accept INFER_TYPE inside macro bodies (typer doesn't resolve inside FuncDef bodies)
    mut is_infer_type := false
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq(INFER_TYPE) {
            is_infer_type = true
        }
    case:
    }
    // Type checking - check for U8/I64 coercion
    mut is_u8_decl := false
    mut is_i64_value := false
    switch decl.value_type {
    case ValueType.TCustom(decl_type_name):
        if decl_type_name.eq("U8") {
            is_u8_decl = true
        }
    case:
    }
    switch value_type {
    case ValueType.TCustom(val_type_name):
        if val_type_name.eq("I64") {
            is_i64_value = true
        }
    case:
    }
    // Issue #91: Resolve function signature type references
    // When decl.value_type is a custom type name that resolves to a FunctionSig,
    // look up the signature and set value_type to match the function type.
    mut has_sig_func_def := false
    mut sig_func_def := SFuncDef()
    switch decl.value_type {
    case ValueType.TCustom(sig_name):
        sig_sym := context.scope_stack.lookup_symbol(sig_name)?
        catch (err: KeyNotFoundError) {
            // Not found - not a FunctionSig reference, continue normally
        }
        if not(has_sig_func_def) {
            switch sig_sym.value_type {
            case ValueType.TType(TTypeDef.TFuncSig):
                sig_sfd := context.scope_stack.lookup_func(sig_name)?
                catch (err: KeyNotFoundError) {
                    // Should not happen if symbol has FuncSig type
                }
                if not(has_sig_func_def) {
                    sig_func_def = sig_sfd
                    has_sig_func_def = true
                    value_type = ValueType.TFunction(sig_sfd.sig.function_type)
                }
            case:
            }
        }
    case:
    }

    if is_infer_type {
        // Issue #105: Skip type checking for inferred types inside macro bodies
    } else if has_sig_func_def {
        // Issue #91: FunctionSig reference resolved above - skip type check
    } else if is_u8_decl.and(is_i64_value) {
        value_type = decl.value_type
    } else {
        // Check types match
        if not(value_type_to_str(decl.value_type).eq(value_type_to_str(value_type))) {
            throw e.lang_error(context.path, "precomp", format("'", decl.name, "' declared of type ", value_type_to_str(decl.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
        }
    }

    // Handle EnumDef early
    switch value_type {
    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(decl.name, enum_def)?
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=true))?
            return e.clone()
        case:
            throw e.lang_error(context.path, "precomp", format("Cannot declare '", decl.name, "' of type '", value_type_to_str(decl.value_type), "', expected enum definition."))
        }
    case:
    }

    // Handle StructDef early
    // Issue #108: Don't overwrite if struct already exists with merged namespace members
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            if not(context.scope_stack.has_struct(decl.name)) {
                context.scope_stack.declare_struct(decl.name, struct_def)?
            }
            saved_path := context.path
            _ := eval_declaration(decl, context, e)?
            context.path = saved_path
        case:
        }
    case:
    }

    // Issue #91: Register function signature type and return early
    switch value_type {
    case ValueType.TType(TTypeDef.TFuncSig):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(decl.name, func_def.clone())?
            context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=true))?
            return e.clone()
        case:
        }
    case:
    }

    // Issue #105: If inner_e is an FCall (e.g. macro call returning struct), we need to
    // process it through precomp_expr first, then check if the result is a StructDef.
    // The struct registration for literal StructDef RHS already happened above.
    // For macro-expanded StructDefs, we do it after new_params processing below.

    // Bug #40 fix: For function declarations, set the function name and reset counter
    // BEFORE processing the body so for-in loops get deterministic names
    mut is_func_decl := false
    if e.params.len().gt(0) {
        switch inner_e.node_type {
        case NodeType.FuncDef:
            is_func_decl = true
        case:
        }
    }
    saved_func := context.current_precomp_func
    saved_counter := context.precomp_forin_counter
    if is_func_decl {
        context.current_precomp_func = decl.name
        context.precomp_forin_counter = 0
    }

    // Issue #91: Resolve arg/return/throw types from function signature into the FuncDef
    // BEFORE processing the body, so UFCS resolution inside the body knows the arg types.
    mut has_resolved_inner := false
    mut resolved_inner_e := inner_e
    if has_sig_func_def {
        switch inner_e.node_type {
        case NodeType.FuncDef(precomp_orig_fd):
            mut precomp_resolved_fd := precomp_orig_fd.clone()
            if not(precomp_resolved_fd.sig.args.len().eq(sig_func_def.sig.args.len())) {
                throw e.lang_error(context.path, "precomp", format("'", decl.name, "' has ", precomp_resolved_fd.sig.args.len().to_str(), " parameters but function signature expects ", sig_func_def.sig.args.len().to_str(), "."))
            }
            mut precomp_arg_idx := 0
            for precomp_sig_arg: Declaration in sig_func_def.sig.args {
                mut precomp_resolved_arg := cast(Declaration, precomp_resolved_fd.sig.args.get(precomp_arg_idx)?)
                precomp_resolved_arg.value_type = precomp_sig_arg.value_type
                precomp_resolved_fd.sig.args.set(precomp_arg_idx, precomp_resolved_arg)?
                precomp_arg_idx = add(precomp_arg_idx, 1)
            }
            precomp_resolved_fd.sig.return_types = sig_func_def.sig.return_types
            precomp_resolved_fd.sig.throw_types = sig_func_def.sig.throw_types
            precomp_resolved_fd.sig.function_type = sig_func_def.sig.function_type
            resolved_inner_e = Expr(node_type=NodeType.FuncDef(precomp_resolved_fd), params=inner_e.params, line=inner_e.line, col=inner_e.col)
            has_resolved_inner = true
        case:
        }
    }

    // First transform the value expression (if any)
    mut new_params := Vec.new(Expr)
    if has_resolved_inner {
        new_params.push(precomp_expr(context, resolved_inner_e)?)
    } else if e.params.len().gt(0) {
        for p: Expr in e.params {
            new_params.push(precomp_expr(context, p)?)
        }
    }

    // Bug #40 fix: Restore previous function context
    if is_func_decl {
        context.current_precomp_func = saved_func
        context.precomp_forin_counter = saved_counter
    }

    // REM: Declarations currently always require an initialization value,
    // so new_params should never be empty.
    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "precomp", "Declarations can have only one child expression")
    }

    // Issue #105: After macro expansion, check if the result is a StructDef
    // and register it (the pre-expansion check above only handles literal StructDef RHS)
    switch value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        if new_params.len().gt(0) {
            expanded_param := cast(Expr, new_params.get(0)?)
            switch expanded_param.node_type {
            case NodeType.StructDef(expanded_struct_def):
                if not(context.scope_stack.has_struct(decl.name)) {
                    context.scope_stack.declare_struct(decl.name, expanded_struct_def.clone())?
                    new_e := Expr.new_clone(e.node_type, e, new_params.clone())
                    expanded_saved_path := context.path
                    _ := eval_declaration(decl, context, new_e)?
                    context.path = expanded_saved_path
                }
            case:
            }
        }
    case:
    }

    // Determine if this is a compile-time constant
    // Only mut matters for constantness - copy/own are about ownership, orthogonal to comptime.
    // Any type can be comptime - the type doesn't matter, only how the value is computed.
    first_param := cast(Expr, new_params.get(0)?)
    is_comptime_const := not(decl.is_mut)
        .and(is_comptime_evaluable(context, first_param)?)

    // Register the declared variable in scope
    sym := SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own, is_comptime_const=is_comptime_const)
    context.scope_stack.declare_symbol(decl.name, sym)?

    // Also register function definitions so UFCS can resolve their return types
    switch value_type {
    case ValueType.TFunction:
        if new_params.len().gt(0) {
            fp := cast(Expr, new_params.get(0)?)
            switch fp.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
            }
        }
    case:
    }

    // Store I64/U8/Str declarations in heap when their initializer is comptime-evaluable.
    // Unlike the is_comptime_const flag (which also requires !is_mut for folding identifiers),
    // we store ALL comptime-evaluable values including mut ones, just like interpreter does.
    // This is needed for eval_expr to work during constant folding (e.g., mut loop variables).
    // Only do this at global scope - inside function bodies, evaluating could cause side effects
    // to run at compile time AND runtime (e.g., print_debug func in mode liba).
    at_global_scope := context.scope_stack.frames.len().eq(1)
    if at_global_scope {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            if custom_type_name.eq("I64").or(custom_type_name.eq("U8")).or(custom_type_name.eq("Str")) {
                if is_comptime_evaluable(context, first_param)? {
                    result := eval_expr(context, first_param)?
                    if not(result.is_throw) {
                        EvalHeap.insert_primitive(context, decl.name, value_type, result.value, e)?
                    }
                }
            }
        case:
        }
    }

    // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
    // run eval_declaration to store the instance in EvalHeap so ccodegen can find it.
    // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
    if at_global_scope.and(not(decl.is_mut)).and(not(decl.is_copy)).and(not(decl.is_own)).and(is_comptime_evaluable(context, first_param)?) {
        switch value_type {
        case ValueType.TCustom(custom_type_name):
            // Skip primitives (I64, U8) - handled above. Skip Str - needs special handling.
            if not(custom_type_name.eq("I64")).and(not(custom_type_name.eq("U8"))).and(not(custom_type_name.eq("Str"))) {
                // Check if this is a struct type (not a struct definition)
                mut instance_sym := context.scope_stack.lookup_symbol(custom_type_name)?
                catch (err: KeyNotFoundError) {
                    // Type not found, skip
                }
                switch instance_sym.value_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    instance_saved_path := context.path
                    _ := eval_declaration(decl, context, e)?
                    context.path = instance_saved_path

                    // Bug #133 fix: Track precomputed heap values for static array serialization
                    needs_heap := EvalHeap.type_needs_heap_serialization(context, custom_type_name)
                    if needs_heap {
                        context.precomputed_heap_values.push(PrecomputedHeapValue(
                            var_name=decl.name.clone(),
                            instance_name=decl.name.clone(),
                            type_name=custom_type_name.clone()
                        ))
                    }
                case:
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_declaration: ", err.msg)
    }

    return Expr.new_clone(e.node_type, e, new_params)
}

/// Transform Catch node - register the catch variable in scope before processing body
/// This enables UFCS resolution for methods called on the error variable
/// Catch structure: [var_name_expr, type_expr, body_expr]
precomp_catch : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    if e.params.len().lt(3) {
        // Malformed catch - just use default handling
        return precomp_params(context, e)?
    }

    // Get the catch variable name and type
    name_expr := cast(Expr, e.params.get(0)?)
    type_expr := cast(Expr, e.params.get(1)?)
    mut var_name := ""
    mut type_name := ""
    switch name_expr.node_type {
    case NodeType.Identifier(n):
        var_name = n
    case:
        return precomp_params(context, e)?  // Not a simple identifier, use default handling
    }
    switch type_expr.node_type {
    case NodeType.Identifier(t):
        type_name = t
    case:
        return precomp_params(context, e)?  // Not a simple type, use default handling
    }

    // Push a scope frame for the catch block
    context.scope_stack.push(ScopeType.Catch)

    // Register the catch variable in the scope
    mut sym := SymbolInfo()
    sym.value_type = ValueType.TCustom(type_name)
    sym.is_mut = false
    sym.is_copy = false
    sym.is_own = false
    sym.is_comptime_const = false
    context.scope_stack.declare_symbol(var_name, sym)?

    // Transform the catch body (params[2])
    body_expr := e.get(2)?
    dont_delete(body_expr)
    new_body := precomp_expr(context, body_expr)?

    // Pop the scope frame
    _ := context.scope_stack.pop()?

    // Return the transformed catch with original var_name, type, and new body
    mut new_params := Vec.new(Expr)
    new_params.push(name_expr)
    new_params.push(type_expr)
    new_params.push(new_body)

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_catch: ", err.msg)
    }

    return Expr.new_clone(NodeType.Catch, e, new_params)
}

/// Transform FCall node - handles compile-time intrinsics, struct/enum constructors, and import()
precomp_fcall : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    // 1. Check for compile-time intrinsics (loc, _file, _line, _col)
    mut was_replaced := false
    replaced := try_replace_comptime_intrinsic(context, e, was_replaced)?
    if was_replaced {
        return replaced
    }

    // Get func_expr and combined_name before any transformation
    if e.params.len().eq(0) {
        // Empty FCall, shouldn't happen but just return as-is
        return e.clone()
    }
    mut func_expr := e.get(0)?

    mut combined_name := ""
    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?
    case:
    }

    // 3. Struct constructor - create instance like eval does (before arg transform)
    if not(combined_name.eq("")) {
        mut struct_found := false
        _dummy_struct := context.scope_stack.lookup_struct(combined_name)?
        struct_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if struct_found {
            _ := create_default_instance(context, combined_name, e)?
            switch func_expr.node_type {
            case NodeType.Identifier(id_name):
                if func_expr.params.len().eq(0) {
                    insert_struct_instance(context, id_name, combined_name, e)?
                }
            case:
            }
            // Transform arguments for struct constructor
            mut struct_params := Vec.new(Expr)
            for p: Expr in e.params {
                struct_params.push(precomp_expr(context, p)?)
            }
            return Expr.new_clone(e.node_type, e, struct_params)
        }
    }

    // 4. Enum constructor (e.g., Color.Green(true)) - before arg transform
    if context.scope_stack.is_enum_constructor(combined_name) {
        // Transform arguments for enum constructor
        mut enum_params := Vec.new(Expr)
        for p: Expr in e.params {
            enum_params.push(precomp_expr(context, p)?)
        }
        return Expr.new_clone(e.node_type, e, enum_params)
    }

    // 5. Transform all arguments
    mut all_transformed_params := Vec.new(Expr)
    for p: Expr in e.params {
        all_transformed_params.push(precomp_expr(context, p)?)
    }
    mut new_e := Expr.new_clone(e.node_type, e, all_transformed_params)

    // Get func_expr again from transformed expression
    if new_e.params.len().eq(0) {
        return new_e
    }
    func_expr = new_e.get(0)?

    switch func_expr.node_type {
    case NodeType.Identifier:
        combined_name = get_combined_name(context.path, func_expr)?

        // 6. Handle ext functions and import()
        mut func_found := false
        mut func_def := context.scope_stack.lookup_func(combined_name)?
        func_found = true
        catch (err: KeyNotFoundError) {
            // Not found
        }
        if func_found {
            // Ext functions: evaluation happens through eval_comptime path (see doc/precomp.org)
            // Exception: import() must run during precomp to load code
            if func_def.is_ext() {
                mut parts := combined_name.split(".")?
                if parts.len().gt(0) {
                    last_part := cast(Str, parts.get(parts.len().sub(1))?)
                    if last_part.eq("import") {
                        _ := eval_expr(context, new_e)?
                    }
                }
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("precomp_fcall: ", err.msg)
    }

    // No transformation needed (UFCS already resolved in ufcs phase)
    return new_e
}
