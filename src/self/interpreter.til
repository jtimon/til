mode liba

import("self.init")
import("self.parser")
import("self.preinit")
import("self.typer")
import("self.desugarer")
import("self.garbager")
import("self.ufcs")
import("self.precomp")
import("self.ext")
import("self.eval_arena")
import("self.mode")         // parse_mode, can_be_imported
import("self.lexer")        // lexer_from_source, parse_tokens
import("std.io")            // readfile

// Interpreter/Eval phase: Runtime evaluation and execution
// This module handles the eval phase that runs after type checking.
// Manages arena, memory allocation, and actual program execution.

RETURN_INSTANCE_NAME := "___temp_return_val_"

/// Convert I64 to little-endian bytes (Vec<U8>)?
i64_to_le_bytes := func(val: I64) returns Vec {
    mut bytes := Vec.new(U8)
    // Extract 8 bytes in little-endian order using bit shifts
    for i in 0..8 {
        mut byte_val : U8 = 0
        memcpy(to_ptr(byte_val), add(to_ptr(val), i), 1)
        bytes.push(byte_val)
    }
    return bytes
}

/// Copy bytes from arena memory into a Vec<U8>
arena_memory_slice := func(arena: EvalArena, offset: I64, size: I64) returns Vec {
    mut bytes := Vec.new(U8)
    for _ in 0..size {
        bytes.push(0)
    }
    memcpy(bytes.ptr.data, arena.get(offset, size), size)
    return bytes
}


EvalResult := struct {
    mut value: Str = ""
    mut is_return: Bool = false
    mut is_throw: Bool = false
    mut is_break: Bool = false
    mut is_continue: Bool = false
    mut thrown_type: Str = ""  // Empty string = None
    mut arena_offset: I64 = 0  // 0 means None (arena offset 0 is reserved for null)
}

namespace EvalResult {
    new := func(value: Str) returns EvalResult {
        return EvalResult(value=value)
    }

    new_return := func(value: Str) returns EvalResult {
        return EvalResult(value=value, is_return=true)
    }

    new_throw := func(value: Str, thrown_type: ValueType) returns EvalResult {
        return EvalResult(value=value, is_throw=true, thrown_type=value_type_to_str(thrown_type))
    }

    new_break := func() returns EvalResult {
        return EvalResult(is_break=true)
    }

    new_continue := func() returns EvalResult {
        return EvalResult(is_continue=true)
    }
}

// string_from_context is in til
// validate_conditional_params is in typer.til

// Helper to evaluate boolean conditions for if/while statements.
eval_condition_to_bool := proc(context: Context, result: EvalResult, expr: Expr) returns Bool throws Str {
    // Handle "true" and "false" directly (builtins return these, and they're the constant names)
    if result.value.eq("true") {
        return true
    }
    if result.value.eq("false") {
        return false
    }

    // Otherwise it's a Bool struct identifier - read its .data field
    bool_id := result.value
    data_field_id := format(bool_id, ".data")
    u8_val := EvalArena.get_u8(context, data_field_id, expr)?
    u8_zero := U8.from_i64(0)?
    catch (err: U8_Overflow) { throw err.msg }
    return not(u8_val.eq(u8_zero))
}

// validate_func_arg_count is in typer.til

/// Read PRIMITIVE field values from an already-evaluated struct instance.
/// This reads ACTUAL primitive values (I64, U8, Str) from the arena.
/// For nested struct fields (Str, Vec, etc.), recursively reads primitive values
/// but skips ptr fields to avoid copying pointers to temp instance memory.
/// Bug #43 fix: Recursively read primitive fields from nested structs to get
/// correct cap, _len values while skipping ptr. Also reads Str values as strings.
read_struct_primitive_fields := proc(ctx: Context, instance_id: Str, struct_type: Str, prefix: Str, e: Expr) returns Map throws Str, I64_Overflow {
    mut struct_def := ctx.scope_stack.lookup_struct(struct_type)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(ctx.path, "read_struct_primitive_fields", format("struct '", struct_type, "' not found"))
    }

    mut values := Map.new(Str, Str)
    for decl: Declaration in struct_def.members {
        if decl.is_mut {
            field_id := format(instance_id, ".", decl.name)
            mut key := ""
            if prefix.eq("") {
                key = decl.name
            } else {
                key = format(prefix, ".", decl.name)
            }

            mut type_name := ""
            mut is_custom := false
            switch decl.value_type {
            case ValueType.TCustom(tn):
                type_name = tn
                is_custom = true
            case:
                // Not a custom type
            }

            if is_custom {
                if type_name.eq("I64") {
                    // Skip 'ptr' and 'c_string' fields - these point to temp instance memory
                    if decl.name.eq("ptr").or(decl.name.eq("c_string")) {
                        // Skip - let these use static default (0)
                    } else {
                        // Read actual I64 value from evaluated instance
                        val := EvalArena.get_i64(ctx, field_id, e)?
                        values.set(key, val.to_str())
                    }
                } else if type_name.eq("U8") {
                    // Read actual U8 value from evaluated instance
                    u8_val := EvalArena.get_u8(ctx, field_id, e)?
                    values.set(key, u8_val.to_str())
                } else if type_name.eq("Str") {
                    // Bug #43 fix: Read actual string VALUE, not pointer
                    str_val := string_from_context(ctx, field_id, e)?
                    values.set(key, str_val)
                } else {
                    // For nested structs (Vec, etc.), recursively read primitive fields
                    _dummy_struct := ctx.scope_stack.lookup_struct(type_name)?
                    mut nested_key := ""
                    if prefix.eq("") {
                        nested_key = decl.name
                    } else {
                        nested_key = format(prefix, ".", decl.name)
                    }
                    mut nested_values := read_struct_primitive_fields(ctx, field_id, type_name, nested_key, e)?
                    // Copy nested values to values map
                    for k: Str in nested_values.keys {
                        mut v := ""
                        nested_values.get(k, v)?
                        values.set(k, v)
                    }
                    catch (err: KeyNotFoundError) {
                        // struct not found, skip
                    }
                }
            }
        }
    }
    return values
}

/// Pre-evaluate all default values for a struct type, including nested structs.
/// Returns a map from field name (with dotted paths for nested) to evaluated string value.
eval_struct_defaults := proc(mut ctx: Context, struct_type: Str, e: Expr) returns Map throws Str {
    mut struct_def := ctx.scope_stack.lookup_struct(struct_type)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(ctx.path, "eval_struct_defaults", format("struct '", struct_type, "' not found"))
    }

    mut defaults := Map.new(Str, Str)
    for decl: Declaration in struct_def.members {
        if decl.is_mut {
            // Check if default_values has this field
            if struct_def.default_values.contains_key(decl.name) {
                mut default_expr := Expr()
                struct_def.default_values.get(decl.name, default_expr)?

                // For nested struct types, eagerly create template BEFORE evaluating default
                // This handles forward references: Inner1's template is created before Inner1() is evaluated
                mut type_name := ""
                mut is_custom := false
                switch decl.value_type {
                case ValueType.TCustom(tn):
                    type_name = tn
                    is_custom = true
                case:
                    // Not a custom type
                }
                if is_custom {
                    // Skip primitives, enums, and Str (handled specially)
                    if not(type_name.eq("U8")).and(not(type_name.eq("I64"))).and(not(type_name.eq("Str"))) {
                        mut is_enum := false
                        _dummy_enum := ctx.scope_stack.lookup_enum(type_name)?
                        is_enum = true
                        catch (err: KeyNotFoundError) {
                            is_enum = false
                        }
                        if not(is_enum) {
                            _dummy_struct := ctx.scope_stack.lookup_struct(type_name)?
                            // Eagerly create template for nested struct (handles forward refs)
                            mut _ := create_default_instance(ctx, type_name, e)?
                            catch (err: KeyNotFoundError) {
                                // struct not found, skip
                            }
                        }
                    }
                }

                // Now evaluate the default expression (template exists if needed)
                res := eval_expr(ctx, default_expr)?
                if res.is_throw {
                    mut thrown_str := res.thrown_type
                    if thrown_str.eq("") {
                        thrown_str = "unknown"
                    }
                    throw e.lang_error(ctx.path, "eval_struct_defaults", format("thrown '", thrown_str, "' while evaluating default for field '", decl.name, "'"))
                }
                defaults.set(decl.name, res.value)

                // Handle nested structs recursively (get their defaults)
                if is_custom {
                    if not(type_name.eq("U8")).and(not(type_name.eq("I64"))).and(not(type_name.eq("Str"))) {
                        mut is_enum2 := false
                        _dummy_enum2 := ctx.scope_stack.lookup_enum(type_name)?
                        is_enum2 = true
                        catch (err: KeyNotFoundError) {
                            is_enum2 = false
                        }
                        if not(is_enum2) {
                            _dummy_struct2 := ctx.scope_stack.lookup_struct(type_name)?

                            // First, get static defaults for nested structs (Str, Vec fields)
                            mut nested := Map.new(Str, Str)
                            nested = eval_struct_defaults(ctx, type_name, e)?
                            // Iterate nested map and insert with prefix
                            for k: Str in nested.keys {
                                mut v := ""
                                nested.get(k, v)?
                                defaults.set(format(decl.name, ".", k), v)
                            }

                            // Bug #43 fix: Then, override with actual primitive values from evaluated instance
                            // This ensures cap, _len, key_type_name, etc. are correctly copied to template
                            instance_id := res.value
                            mut primitive_values := read_struct_primitive_fields(ctx, instance_id, type_name, decl.name, e)?
                            for prim_k: Str in primitive_values.keys {
                                mut prim_v := ""
                                primitive_values.get(prim_k, prim_v)?
                                defaults.set(prim_k, prim_v)
                            }

                            catch (err: KeyNotFoundError) {
                                // struct not found, skip
                            }
                        }
                    }
                }
            }
        }
    }
    catch (err: KeyNotFoundError) { throw err.msg }
    catch (err: I64_Overflow) { throw err.msg }
    return defaults
}

/// Create a default instance template for a struct type.
/// Called eagerly when struct declarations are evaluated.
create_default_instance := proc(mut ctx: Context, struct_type: Str, e: Expr) returns I64 throws Str {
    // Check if template already exists (e.g., from a previous import)
    if g_arena.default_instances.contains_key(struct_type) {
        mut offset := 0
        g_arena.default_instances.get(struct_type, offset)?
        catch (err: KeyNotFoundError) { throw err.msg }
        return offset
    }

    // Create template instance
    template_id := format("__default_", struct_type)

    // Declare temporary symbol for template (needed by insert_struct_core)
    sym_info := SymbolInfo(value_type=ValueType.TCustom(struct_type), is_mut=true, is_copy=false, is_own=false)
    ctx.scope_stack.declare_symbol(template_id, sym_info)?

    // Evaluate defaults and create template
    defaults := eval_struct_defaults(ctx, struct_type, e)?
    // Pass negative value to indicate "allocate new memory" (since offset 0 is reserved/invalid)
    result := EvalArena.insert_struct_core(ctx, template_id, struct_type, sub(0, 1), defaults, e)?

    // Get the template's arena offset (first mapping is the base struct)
    if result.arena_mappings.len().eq(0) {
        throw e.lang_error(ctx.path, "create_default_instance", "No arena mapping for template")
    }
    mut first_mapping := EvalArenaMapping()
    result.arena_mappings.get(0, first_mapping)?
    template_offset := first_mapping.offset
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Cache the template offset
    g_arena.default_instances.set(struct_type, template_offset.clone())

    return template_offset
}

/// Insert a struct instance using cached template.
/// Template is guaranteed to exist - created eagerly on eval_declaration.
insert_struct_instance := proc(mut ctx: Context, id: Str, type_name: Str, e: Expr) throws Str {
    if not(g_arena.default_instances.contains_key(type_name)) {
        throw e.lang_error(ctx.path, "insert_struct_instance", format("template for '", type_name, "' not found"))
    }
    mut template_offset := 0
    g_arena.default_instances.get(type_name, template_offset)?
    catch (err: KeyNotFoundError) { throw err.msg }
    EvalArena.insert_struct(ctx, id, type_name, template_offset, e)?
}

eval_expr := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    switch e.node_type {
    case NodeType.Body:
        return eval_body(context, e.params)?
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(li64):
            return EvalResult.new(li64)
        case Literal.Str(lstring):
            return EvalResult.new(lstring)
        case Literal.List(llist):
            return EvalResult.new(llist)
        }
    case NodeType.FCall(_):
        f_name := get_func_name_in_call(e)?
        return eval_func_proc_call(f_name, context, e)?
    case NodeType.Declaration(declaration):
        return eval_declaration(declaration, context, e)?
    case NodeType.Assignment(var_name):
        return eval_assignment(var_name, context, e)?
    case NodeType.Identifier(name):
        return eval_identifier_expr(name, context, e)?
    case NodeType.If:
        _ := validate_conditional_params(context.path, e, "if", 2, 3)
        mut cond_expr := Expr()
        e.params.get(0, cond_expr)?
        mut result_cond := eval_expr(context, cond_expr)?
        if result_cond.is_throw {
            return result_cond
        }
        if eval_condition_to_bool(context, result_cond, cond_expr)? {
            return eval_expr(context, e.get(1)?)?
        } else if e.params.len().eq(3) {
            return eval_expr(context, e.get(2)?)?
        } else {
            return EvalResult.new("")
        }
    case NodeType.While:
        _ := validate_conditional_params(context.path, e, "while", 2, 2)
        mut while_cond_expr := Expr()
        e.params.get(0, while_cond_expr)?
        mut while_result_cond := eval_expr(context, while_cond_expr)?
        if while_result_cond.is_throw {
            return while_result_cond
        }
        while eval_condition_to_bool(context, while_result_cond, while_cond_expr)? {
            result := eval_expr(context, e.get(1)?)?
            if result.is_return.or(result.is_throw) {
                return result
            }
            if result.is_break {
                // Break exits the loop immediately
                break
            }
            // Continue just skips to the next iteration (re-evaluate condition)
            // No special handling needed - we just don't return
            while_cond_expr = e.get(0)?
            while_result_cond = eval_expr(context, while_cond_expr)?
            if while_result_cond.is_throw {
                return while_result_cond
            }
        }
        return EvalResult.new("")
    case NodeType.Switch:
        throw e.lang_error(context.path, "eval", "Switch should have been desugared to if/else by desugarer phase")
    case NodeType.Return:
        if e.params.len().eq(0) {
            return EvalResult.new_return("")
        } else if e.params.len().gt(1) {
            throw e.lang_error(context.path, "eval", "multiple return values not implemented yet")
        } else {
            return_result := eval_expr(context, e.get(0)?)?
            if return_result.is_throw {
                return return_result
            }
            mut ret := EvalResult.new_return(return_result.value)
            ret.arena_offset = return_result.arena_offset
            return ret
        }
    case NodeType.Throw:
        if not(e.params.len().eq(1)) {
            throw e.lang_error(context.path, "eval", "Throw can only return one value. This should have been caught before")
        } else {
            param_expr := e.get(0)?
            throw_result := eval_expr(context, param_expr)?
            if throw_result.is_throw {
                return throw_result
            }
            thrown_type := get_value_type(context, param_expr)?
            return EvalResult.new_throw(throw_result.value, thrown_type)
        }
    case NodeType.Catch:
        throw e.lang_error(context.path, "eval", "Catch statements should always be evaluated within bodies.")
    case NodeType.Break:
        return EvalResult.new_break()
    case NodeType.Continue:
        return EvalResult.new_continue()
    // Issue #108: NamespaceDef already processed by init - members merged into type
    case NodeType.NamespaceDef(_ns_def):
        return EvalResult.new("")
    case:
        throw e.lang_error(context.path, "eval", format("Not implemented yet, found node type ", enum_to_str(e.node_type), "."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return EvalResult.new("")
}

eval_func_proc_call := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    mut is_fcall := false
    switch e.node_type {
    case NodeType.FCall(_):
        is_fcall = true
    case:
    }
    if not(is_fcall) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall node type")
    }

    if e.params.len().eq(0) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall with at least one param for the Identifier")
    }
    func_expr := e.get(0)?

    // Check if this is a struct instantiation
    mut is_struct := false
    mut struct_def := SStructDef()
    struct_def = context.scope_stack.lookup_struct(name)?
    is_struct = true
    catch (err: KeyNotFoundError) {
        // is_struct stays false - struct not found
    }
    if is_struct {
        id_expr := e.get(0)?
        if id_expr.params.len().eq(0) {
            // Clone struct members to avoid issues
            struct_members := struct_def.members.clone()

            // Check if this is a struct literal (has named args) or default constructor
            mut has_named_args := false
            for check_i in 1..e.params.len() {
                mut check_arg := Expr()
                e.params.get(check_i, check_arg)?
                switch check_arg.node_type {
                case NodeType.NamedArg(_):
                    has_named_args = true
                case:
                }
            }

            if has_named_args {
                // Struct literal: Vec2(x=10, y=20)
                // Create a temp instance, set field values, return temp name
                temp_id := g_arena.temp_id_counter
                g_arena.temp_id_counter = g_arena.temp_id_counter.add(1)
                temp_name := format(RETURN_INSTANCE_NAME, I64.to_str(temp_id))

                // Declare the temp symbol
                context.scope_stack.declare_symbol(temp_name.clone(), SymbolInfo(value_type=ValueType.TCustom(name.clone()), is_mut=true))?

                // Create struct instance with default values
                insert_struct_instance(context, temp_name.clone(), name, e)?

                // Process named arguments to override field values
                for named_j in 1..e.params.len() {
                    mut named_arg := Expr()
                    e.params.get(named_j, named_arg)?
                    mut field_name := ""
                    mut is_named_arg := false
                    switch named_arg.node_type {
                    case NodeType.NamedArg(fname):
                        field_name = fname
                        is_named_arg = true
                    case:
                        // Not a named arg, skip
                    }

                    if is_named_arg {
                        // Find the field type in the struct definition
                        mut field_type := ValueType.TCustom("")
                        mut found_field := false
                        for named_k in 0..struct_members.len() {
                            mut member := Declaration()
                            struct_members.get(named_k, member)?
                            if member.name.eq(field_name) {
                                field_type = member.value_type
                                found_field = true
                            }
                        }
                        if not(found_field) {
                            throw named_arg.error(context.path, "eval", format("Field '", field_name, "' not found in struct '", name, "'"))
                        }

                        // Evaluate the value expression
                        named_value_expr := named_arg.get(0)?
                        named_value_result := eval_expr(context, named_value_expr)?
                        if named_value_result.is_throw {
                            return named_value_result
                        }

                        // Set the field value based on its type
                        field_id := format(temp_name, ".", field_name)
                        switch field_type {
                        case ValueType.TCustom(field_type_name):
                            if field_type_name.eq("I64") {
                                EvalArena.insert_i64(context, field_id.clone(), named_value_result.value.clone(), named_arg)?
                            } else if field_type_name.eq("U8") {
                                EvalArena.insert_u8(context, field_id.clone(), named_value_result.value.clone(), named_arg)?
                            } else if field_type_name.eq("Str") {
                                if named_value_result.arena_offset.gt(0) {
                                    str_field_dest_offset := context.get_field_offset(field_id)?
                                    str_field_type_size := context.get_type_size("Str")?
                                    g_arena.set(str_field_dest_offset, g_arena.get(named_value_result.arena_offset, str_field_type_size), str_field_type_size)
                                } else {
                                    EvalArena.insert_string(context, field_id.clone(), named_value_result.value.clone(), named_arg)?
                                }
                            } else {
                                // Could be enum or nested struct
                                field_custom_symbol := context.scope_stack.lookup_symbol(field_type_name.clone())?
                                switch field_custom_symbol.value_type {
                                case ValueType.TType(TTypeDef.TEnumDef):
                                    _ := EvalArena.insert_enum(context, field_id.clone(), field_type_name.clone(), named_value_result.value.clone(), named_arg)?
                                case ValueType.TType(TTypeDef.TStructDef):
                                    // Issue #159: deep copy via memcpy.
                                    // Garbager inserts clone for identifier args; fresh constructors are already new.
                                    // Copy bytes from source into parent struct's field slot.
                                    src_offset := context.scope_stack.lookup_var(named_value_result.value)?
                                    dest_offset := context.get_field_offset(field_id)?
                                    type_size := context.get_type_size(field_type_name)?
                                    g_arena.set(dest_offset, g_arena.get(src_offset, type_size), type_size)
                                case:
                                    throw named_arg.error(context.path, "eval", format("Unsupported field type '", field_type_name, "' for field '", field_name, "'"))
                                }
                            }
                        case:
                            throw named_arg.error(context.path, "eval", format("Unsupported field type for field '", field_name, "'"))
                        }
                    } // end if is_named_arg
                }

                return EvalResult.new(temp_name)
            } else {
                // Default constructor: Vec2()
                // Bug #160 fix: Create temp instance instead of using type name
                // This ensures field access via get_field_offset works correctly
                temp_id := g_arena.temp_id_counter
                g_arena.temp_id_counter = g_arena.temp_id_counter.add(1)
                temp_name := format(RETURN_INSTANCE_NAME, I64.to_str(temp_id))

                // Declare temp symbol
                context.scope_stack.declare_symbol(temp_name.clone(), SymbolInfo(value_type=ValueType.TCustom(name.clone()), is_mut=true))?

                insert_struct_instance(context, temp_name.clone(), name, e)?
                mut result_val := temp_name
                if name.eq("U8") {
                    result_val = "0"
                } else if name.eq("I64") {
                    result_val = "0"
                } else if name.eq("Str") {
                    result_val = ""
                }
                return EvalResult.new(result_val)
            }
        }
    }

    combined_name := get_combined_name(context.path, func_expr)?

    // Check if this is an enum constructor call (e.g., Color.Green(true))
    if context.scope_stack.is_enum_constructor(combined_name) {
        // Extract enum_type and variant_name
        parts := combined_name.split(".")?
        mut enum_type := ""
        parts.get(0, enum_type)?
        mut variant_name := ""
        parts.get(1, variant_name)?

        // Get the enum definition to check if this variant has a payload type
        enum_def := context.scope_stack.lookup_enum(enum_type)?
        mut has_variant := false
        mut has_payload := false
        mut variant_type := ValueType.TCustom("")  // Will be set if payload exists
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(variant_name)?
        has_variant = true
        if not(NULL.eq(payload_ptr.data)) {
            has_payload = true
            memcpy(to_ptr(variant_type), payload_ptr.data, size_of(ValueType))
        }
        catch (err: KeyNotFoundError) {
            // has_variant stays false - variant not found
        }

        if has_variant {
            if has_payload {
                // This variant expects a payload
                if e.params.len().lt(2) {
                    throw e.error(context.path, "eval", format("Enum constructor ", enum_type, ".", variant_name, " expects a payload of type ", value_type_to_str(variant_type)))
                }

                // Evaluate the payload argument
                payload_expr := e.get(1)?
                payload_result := eval_expr(context, payload_expr)?
                if payload_result.is_throw {
                    return payload_result
                }

                // Convert payload to bytes based on type
                mut payload_bytes := Vec.new(U8)
                mut handled_payload := false

                switch variant_type {
                case ValueType.TCustom(type_name):
                    if type_name.eq("I64") {
                        i64_val := I64.from_str(payload_result.value)
                        payload_bytes = i64_to_le_bytes(i64_val)
                        handled_payload = true
                    } else {
                        // Handle struct payloads
                        struct_type_name := type_name
                        mut type_symbol := SymbolInfo()
                        type_symbol = context.scope_stack.lookup_symbol(struct_type_name)?
                        catch (err: KeyNotFoundError) {
                            throw e.error(context.path, "eval", format("Unknown type '", struct_type_name, "'"))
                        }

                        switch type_symbol.value_type {
                        case ValueType.TType(TTypeDef.TStructDef):
                            // Get struct size
                            struct_size := context.get_type_size(struct_type_name)?

                            // Get struct variable name from the original expression or create temporary for literals
                            mut struct_var_name := ""
                            mut struct_var_set := false
                            switch payload_expr.node_type {
                            case NodeType.Identifier(ident_name):
                                if struct_type_name.eq("Str") {
                                    // For Str payloads with identifier expressions (like t.token_str),
                                    // create a temporary Str from the evaluated result value
                                    last_frame := context.scope_stack.last_frame()?
                                    temp_var_name := format("__temp_str_", I64.to_str(last_frame.arena_index.len()))
                                    string_value := payload_result.value

                                    // Add symbol entry before calling insert_string
                                    context.scope_stack.declare_symbol(temp_var_name, SymbolInfo(value_type=ValueType.TCustom("Str")))?

                                    EvalArena.insert_string(context, temp_var_name, string_value, e)?
                                    struct_var_name = temp_var_name
                                    struct_var_set = true
                                } else {
                                    struct_var_name = ident_name
                                    struct_var_set = true
                                }
                            case NodeType.LLiteral(lit):
                                switch lit {
                                case Literal.Str(_):
                                    if struct_type_name.eq("Str") {
                                        // For string literals, create a temporary Str struct
                                        str_lit_last_frame := context.scope_stack.last_frame()?
                                        str_lit_temp_var_name := format("__temp_str_", I64.to_str(str_lit_last_frame.arena_index.len()))
                                        str_lit_string_value := payload_result.value

                                        // Add symbol entry before calling insert_string
                                        context.scope_stack.declare_symbol(str_lit_temp_var_name, SymbolInfo(value_type=ValueType.TCustom("Str")))?

                                        EvalArena.insert_string(context, str_lit_temp_var_name, str_lit_string_value, e)?
                                        struct_var_name = str_lit_temp_var_name
                                        struct_var_set = true
                                    }
                                case Literal.Number(_):
                                    if struct_type_name.eq("I64") {
                                        // For I64 literals, create a temporary I64 struct
                                        i64_lit_last_frame := context.scope_stack.last_frame()?
                                        i64_lit_temp_var_name := format("__temp_i64_", I64.to_str(i64_lit_last_frame.arena_index.len()))
                                        i64_lit_value := payload_result.value

                                        // Add symbol entry before calling insert_i64
                                        context.scope_stack.declare_symbol(i64_lit_temp_var_name, SymbolInfo(value_type=ValueType.TCustom("I64")))?

                                        EvalArena.insert_i64(context, i64_lit_temp_var_name, i64_lit_value, e)?
                                        struct_var_name = i64_lit_temp_var_name
                                        struct_var_set = true
                                    }
                                case:
                                }
                            // Bug #56 fix: Handle FCall (e.g., x.clone()) for Str payloads
                            case NodeType.FCall(_):
                                if struct_type_name.eq("Str") {
                                    str_fcall_last_frame := context.scope_stack.last_frame()?
                                    str_fcall_temp_var_name := format("__temp_str_", I64.to_str(str_fcall_last_frame.arena_index.len()))
                                    str_fcall_string_value := payload_result.value

                                    context.scope_stack.declare_symbol(str_fcall_temp_var_name, SymbolInfo(value_type=ValueType.TCustom("Str")))?

                                    EvalArena.insert_string(context, str_fcall_temp_var_name, str_fcall_string_value, e)?
                                    struct_var_name = str_fcall_temp_var_name
                                    struct_var_set = true
                                }
                            case:
                            }

                            if not(struct_var_set) {
                                throw e.error(context.path, "eval", format("Enum variant payload must be a variable, literal, or function call, got ", enum_to_str(payload_expr.node_type)))
                            }

                            // Get struct offset from arena
                            mut struct_offset := 0
                            struct_offset = context.scope_stack.lookup_var(struct_var_name)?
                            catch (err: KeyNotFoundError) {
                                throw e.error(context.path, "eval", format("Struct '", struct_var_name, "' not found in arena"))
                            }

                            // Copy struct bytes from arena
                            payload_bytes = arena_memory_slice(g_arena, struct_offset, struct_size)
                            handled_payload = true

                        case ValueType.TType(TTypeDef.TEnumDef):
                            // Handle enum payloads
                            // Get enum variable name from the original expression
                            mut enum_var_name := ""
                            mut enum_var_set := false
                            switch payload_expr.node_type {
                            case NodeType.Identifier(ident_name):
                                if payload_expr.params.len().eq(0) {
                                    enum_var_name = ident_name
                                    enum_var_set = true
                                } else {
                                    // This is a nested enum constructor call (e.g., InnerEnum.ValueA(42))
                                    enum_ctor_last_frame := context.scope_stack.last_frame()?
                                    enum_ctor_temp_var_name := format("__temp_enum_", I64.to_str(enum_ctor_last_frame.arena_index.len()))

                                    enum_ctor_nested_result := eval_expr(context, payload_expr)?
                                    if enum_ctor_nested_result.is_throw {
                                        return enum_ctor_nested_result
                                    }

                                    context.scope_stack.declare_symbol(enum_ctor_temp_var_name, SymbolInfo(value_type=ValueType.TCustom(struct_type_name)))?

                                    _ := EvalArena.insert_enum(context, enum_ctor_temp_var_name, struct_type_name, enum_ctor_nested_result.value, e)?
                                    enum_var_name = enum_ctor_temp_var_name
                                    enum_var_set = true
                                }
                            case NodeType.FCall(_):
                                // This is a nested enum constructor call
                                enum_fcall_last_frame := context.scope_stack.last_frame()?
                                enum_fcall_temp_var_name := format("__temp_enum_", I64.to_str(enum_fcall_last_frame.arena_index.len()))

                                enum_fcall_nested_result := eval_expr(context, payload_expr)?
                                if enum_fcall_nested_result.is_throw {
                                    return enum_fcall_nested_result
                                }

                                context.scope_stack.declare_symbol(enum_fcall_temp_var_name, SymbolInfo(value_type=ValueType.TCustom(struct_type_name)))?

                                _ := EvalArena.insert_enum(context, enum_fcall_temp_var_name, struct_type_name, enum_fcall_nested_result.value, e)?
                                enum_var_name = enum_fcall_temp_var_name
                                enum_var_set = true
                            case:
                            }

                            if not(enum_var_set) {
                                throw e.error(context.path, "eval", format("Enum payload must be a variable identifier or enum constructor, got ", enum_to_str(payload_expr.node_type)))
                            }

                            // Get the full enum value including its payload
                            enum_val := EvalArena.get_enum(context, enum_var_name, e)?

                            // Calculate total enum size: 8 bytes tag + payload bytes
                            mut enum_bytes := Vec.new(U8)

                            // Get the variant position
                            inner_enum_def := context.scope_stack.lookup_enum(struct_type_name)?
                            variant_pos := Context.get_variant_pos(inner_enum_def, enum_val.enum_name, context.path, e)?

                            // Add 8 bytes for variant tag
                            enum_bytes = i64_to_le_bytes(variant_pos)

                            // Add payload bytes if present
                            if not(NULL.eq(enum_val.payload.data)) {
                                mut enum_payload_vec := Vec.new(U8)
                                memcpy(to_ptr(enum_payload_vec), enum_val.payload.data, size_of(Vec))
                                for pi in 0..enum_payload_vec.len() {
                                    mut pb := U8.from_i64(0)?
                                    enum_payload_vec.get(pi, pb)?
                                    enum_bytes.push(pb)
                                }
                            }

                            payload_bytes = enum_bytes
                            handled_payload = true
                        case:
                            throw e.error(context.path, "eval", format("Unsupported payload type: ", value_type_to_str(variant_type)))
                        }
                    }
                case:
                    throw e.error(context.path, "eval", format("Unsupported payload type: ", value_type_to_str(variant_type)))
                }

                // Store payload in temp location for insert_enum to use
                // Bug #74 fix: Heap-allocate EnumPayload to avoid use-after-free
                mut temp_payload := EnumPayload(data=payload_bytes, value_type=variant_type)
                heap_payload_ptr := malloc(size_of(EnumPayload))?
                memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
                context.temp_enum_payload.data = heap_payload_ptr

                // Return the enum variant name
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: KeyNotFoundError) { throw err.msg }
                return EvalResult.new(format(enum_type, ".", variant_name))
            }
        } else {
            // This variant doesn't have a payload, but constructor was called with args
            if e.params.len().gt(1) {
                throw e.error(context.path, "eval", format("Enum variant ", enum_type, ".", variant_name, " does not take a payload"))
            }
        }
        if not(has_variant) {
            throw e.error(context.path, "eval", format("Enum ", enum_type, " does not have variant ", variant_name))
        }
    }

    // TODO: After precomp, UFCS is already resolved so the mutation in get_func_def_for_fcall_with_expr
    // is a no-op. Could save this clone by adding a simpler lookup function that doesn't need &mut.
    mut new_fcall_e := e.clone()
    mut func_def := SFuncDef()
    func_def = get_func_def_for_fcall_with_expr(context, new_fcall_e)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Instantiations should be handled already")
    }
    if func_def.is_ext() {
        // External/core functions are treated specially
        is_proc := func_def.is_proc()
        parts2 := combined_name.split(".")?
        mut last_name := ""
        if parts2.len().gt(0) {
            parts2.get(parts2.len().sub(1), last_name)?
        } else {
            throw e.lang_error(context.path, "eval", "Somehow function without name")
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return eval_core_func_proc_call(last_name, context, new_fcall_e, is_proc)?
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: U8_Overflow) { throw err.msg }
    catch (err: BadAlloc) { panic(loc(), "eval_func_proc_call: buy more ram") }
    return eval_user_func_proc_call(func_def, combined_name, context, new_fcall_e)?
}

eval_declaration := proc(declaration: Declaration, mut context: Context, e: Expr) returns EvalResult throws Str {
    inner_e := e.get(0)?
    mut value_type := ValueType.TCustom("")
    value_type = get_value_type(context, inner_e)?
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", err)
    }

    // Type checking - INFER_TYPE should have been resolved by typer
    mut decl_is_u8 := false
    mut value_is_i64 := false
    switch declaration.value_type {
    case ValueType.TCustom(s):
        if s.eq("U8") { decl_is_u8 = true }
    case:
    }
    switch value_type {
    case ValueType.TCustom(s):
        if s.eq("I64") { value_is_i64 = true }
    case:
    }

    if decl_is_u8 {
        if value_is_i64 {
            value_type = declaration.value_type
        }
    } else if not(value_type_to_str(value_type).eq(value_type_to_str(declaration.value_type))) {
        throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type ", value_type_to_str(declaration.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
    }

    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "eval", "Declarations can have only one child expression")
    }

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type '", value_type_to_str(declaration.value_type), "' but still to infer type '", s, "'"))
        } else if s.eq("I64") {
            i64_result := eval_expr(context, inner_e)?
            if i64_result.is_throw {
                return i64_result
            }
            i64_expr_result_str := i64_result.value
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            EvalArena.insert_primitive(context, declaration.name, value_type, i64_expr_result_str, e)?
            return EvalResult.new("")
        } else if s.eq("U8") {
            u8_result := eval_expr(context, inner_e)?
            if u8_result.is_throw {
                return u8_result
            }
            u8_expr_result_str := u8_result.value
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            EvalArena.insert_primitive(context, declaration.name, value_type, u8_expr_result_str, e)?
            return EvalResult.new("")
        } else if s.eq("Str") {
            str_result := eval_expr(context, inner_e)?
            if str_result.is_throw {
                return str_result
            }
            str_expr_result_str := str_result.value
            str_expr_arena_offset := str_result.arena_offset
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            if str_expr_arena_offset.gt(0) {
                mut str_decl_last_idx := context.scope_stack.frames.len().sub(1)
                mut str_decl_last_frame := ScopeFrame()
                context.scope_stack.frames.get(str_decl_last_idx, str_decl_last_frame)?
                str_decl_last_frame.arena_index.set(declaration.name, str_expr_arena_offset)
                context.scope_stack.frames.set(str_decl_last_idx, str_decl_last_frame)?
                return EvalResult.new("")
            }
            EvalArena.insert_primitive(context, declaration.name, value_type, str_expr_result_str, e)?
            return EvalResult.new("")
        } else {
            // Custom type (not I64/U8/Str)
            custom_type_name := s
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            mut custom_symbol := SymbolInfo()
            custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "eval", format("Symbol '", custom_type_name, "' not found in context"))
            }

            mut is_enum_def := false
            mut is_struct_def := false
            switch custom_symbol.value_type {
            case ValueType.TType(TTypeDef.TEnumDef):
                is_enum_def = true
            case ValueType.TType(TTypeDef.TStructDef):
                is_struct_def = true
            case:
            }

            if is_enum_def {
                enum_def_result := eval_expr(context, inner_e)?
                if enum_def_result.is_throw {
                    return enum_def_result
                }
                enum_expr_result_str := enum_def_result.value
                _ := EvalArena.insert_enum(context, declaration.name, custom_type_name, enum_expr_result_str, e)?
            } else if is_struct_def {
                // Special case for instantiation
                mut is_fcall := false
                switch inner_e.node_type {
                case NodeType.FCall(_):
                    is_fcall = true
                case:
                }
                if is_fcall {
                    if inner_e.params.len().eq(1) {
                        mut first_param := Expr()
                        inner_e.params.get(0, first_param)?
                        switch first_param.node_type {
                        case NodeType.Identifier(potentially_struct_name):
                            if first_param.params.len().eq(0) {
                                mut is_struct := false
                                _ := context.scope_stack.lookup_struct(potentially_struct_name)?
                                is_struct = true
                                catch (err: KeyNotFoundError) {
                                    // is_struct stays false - struct not found
                                }
                                if is_struct {
                                    insert_struct_instance(context, declaration.name, custom_type_name, e)?
                                    return EvalResult.new("")
                                }
                            }
                        case:
                        }
                    }
                }
                // otherwise continue, it's a function that returns a struct
                struct_def_result := eval_expr(context, inner_e)?
                if struct_def_result.is_throw {
                    return struct_def_result
                }
                struct_expr_result_str := struct_def_result.value

                // Issue #159: Garbager handles clone() insertion for deep copy semantics
                // Interpreter just binds offsets - both for temp return values and existing variables
                // Bug #160: Deterministic dispatch - instance fields use get_field_offset
                mut struct_offset := 0
                mut struct_found_offset := false
                struct_offset = context.scope_stack.lookup_var(struct_expr_result_str)?
                struct_found_offset = true
                catch (err: KeyNotFoundError) {
                    if struct_expr_result_str.contains(".") {
                        struct_offset = context.get_field_offset(struct_expr_result_str)?
                        struct_found_offset = true
                    }
                }
                if not(struct_found_offset) {
                    throw e.lang_error(context.path, "eval", format("Could not find arena index for '", struct_expr_result_str, "'"))
                }
                mut struct_last_idx := context.scope_stack.frames.len().sub(1)
                mut struct_last_frame := ScopeFrame()
                context.scope_stack.frames.get(struct_last_idx, struct_last_frame)?
                struct_last_frame.arena_index.set(declaration.name, struct_offset)
                context.scope_stack.frames.set(struct_last_idx, struct_last_frame)?
            } else {
                throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(custom_symbol.value_type), "'. Only 'enum' and 'struct' custom types allowed."))
            }
            return EvalResult.new("")
        }
    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(declaration.name, enum_def.clone())?
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected enum definition."))
        }
    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            // Issue #108: Don't overwrite struct if already declared (may have merged namespace members)
            if not(context.scope_stack.has_struct(declaration.name)) {
                context.scope_stack.declare_struct(declaration.name, struct_def.clone())?
            }
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            // Process struct members with default values
            for member_decl: Declaration in struct_def.members {
                if not(member_decl.is_mut) {
                    combined_name := format(declaration.name, ".", member_decl.name)
                    mut default_value := Expr()
                    struct_def.default_values.get(member_decl.name, default_value)?
                    catch (err: KeyNotFoundError) {
                        throw e.lang_error(context.path, "eval", format("Struct member '", declaration.name, ".", member_decl.name, "' expected to have default value."))
                    }

                    // INFER_TYPE should have been resolved by typer
                    mut member_value_type := member_decl.value_type
                    switch member_decl.value_type {
                    case ValueType.TCustom(s2):
                        if s2.eq(INFER_TYPE) {
                            throw e.lang_error(context.path, "eval", format("Struct member '", declaration.name, ".", member_decl.name, "' has INFER_TYPE - should have been resolved by typer"))
                        }
                    case:
                    }

                    // Handle member based on type
                    switch member_value_type {
                    case ValueType.TCustom(member_type_name):
                        member_result := eval_expr(context, default_value)?
                        if member_result.is_throw {
                            return member_result
                        }
                        member_expr_result_str := member_result.value
                        if member_type_name.eq("I64") {
                            EvalArena.insert_primitive(context, combined_name, member_value_type, member_expr_result_str, e)?
                        } else if member_type_name.eq("U8") {
                            EvalArena.insert_primitive(context, combined_name, member_value_type, member_expr_result_str, e)?
                        } else if member_type_name.eq("Str") {
                            EvalArena.insert_primitive(context, combined_name, member_value_type, member_expr_result_str, e)?
                        } else {
                            // Issue #159 Step 7: Replace copy_fields with memcpy
                            // for struct member default values during struct definition.
                            insert_struct_instance(context, combined_name, member_type_name, e)?
                            nested_src_offset := context.scope_stack.lookup_var(member_expr_result_str)?
                            catch (err: KeyNotFoundError) {
                                throw e.lang_error(context.path, "eval", format("Undefined variable '", member_expr_result_str, "' for member '", combined_name, "'"))
                            }
                            nested_dest_offset := context.get_field_offset(combined_name)?
                            nested_type_size := context.get_type_size(member_type_name)?
                            g_arena.set(nested_dest_offset, g_arena.get(nested_src_offset, nested_type_size), nested_type_size)
                        }
                    case:
                        throw e.todo_error(context.path, "eval", format("Cannot declare '", declaration.name, ".", member_decl.name, "' of type '", value_type_to_str(member_decl.value_type), "'"))
                    }

                    context.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=member_decl.value_type, is_mut=member_decl.is_mut, is_copy=member_decl.is_copy, is_own=member_decl.is_own))?
                }
            }
            // Eagerly create default instance template for this struct type
            _ := create_default_instance(context, declaration.name, e)?
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare ", declaration.name, " of type ", enum_to_str(declaration.value_type), ", expected struct definition."))
        }
    case ValueType.TFunction(func_type):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(declaration.name, func_def.clone())?
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo(value_type=value_type, is_mut=declaration.is_mut, is_copy=declaration.is_copy, is_own=declaration.is_own))?
            return EvalResult.new("")
        case:
            throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected '", value_type_to_str(value_type), "' definition."))
        }
    case ValueType.TMulti(types):
        throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "'"))
    case:
        throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of unhandled type '", value_type_to_str(value_type), "'"))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return EvalResult.new("")
}

eval_assignment := proc(var_name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // For field access (e.g., "v.x"), extract the base variable name
    mut base_var_name := var_name
    if var_name.contains(".") {
        parts := var_name.split(".")?
        if parts.len().gt(0) {
            parts.get(0, base_var_name)?
        }
    }

    symbol_info := context.scope_stack.lookup_symbol(base_var_name)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Symbol '", base_var_name, "' not found in context"))
    }

    if not(symbol_info.is_mut) {
        if not(symbol_info.is_copy) {
            if not(symbol_info.is_own) {
                throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': Assignments can only be to mut values."))
            }
        }
    }
    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': assignments must take exactly one value"))
    }

    inner_e := e.get(0)?
    value_type := get_value_type(context, inner_e)?
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", err)
    }

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Cannot assign ", var_name, ", type should already be inferred of type '", value_type_to_str(symbol_info.value_type), "'."))
        } else if s.eq("I64") {
            assign_i64_result := eval_expr(context, inner_e)?
            if assign_i64_result.is_throw {
                return assign_i64_result
            }
            assign_i64_expr_result_str := assign_i64_result.value
            EvalArena.insert_primitive(context, var_name, value_type, assign_i64_expr_result_str, e)?
        } else if s.eq("U8") {
            assign_u8_result := eval_expr(context, inner_e)?
            if assign_u8_result.is_throw {
                return assign_u8_result
            }
            assign_u8_expr_result_str := assign_u8_result.value
            EvalArena.insert_primitive(context, var_name, value_type, assign_u8_expr_result_str, e)?
        } else if s.eq("Str") {
            assign_str_result := eval_expr(context, inner_e)?
            if assign_str_result.is_throw {
                return assign_str_result
            }
            assign_str_expr_result_str := assign_str_result.value
            assign_str_arena_offset := assign_str_result.arena_offset
            if assign_str_arena_offset.gt(0) {
                mut assign_str_dest_offset := 0
                if var_name.contains(".") {
                    assign_str_dest_offset = context.get_field_offset(var_name)?
                } else {
                    assign_str_dest_offset = context.scope_stack.lookup_var(var_name)?
                    catch (err: KeyNotFoundError) {
                        throw e.lang_error(context.path, "eval", format("Could not find arena index for '", var_name, "'"))
                    }
                }
                assign_str_type_size := context.get_type_size("Str")?
                g_arena.set(assign_str_dest_offset, g_arena.get(assign_str_arena_offset, assign_str_type_size), assign_str_type_size)
            } else {
                EvalArena.insert_primitive(context, var_name, value_type, assign_str_expr_result_str, e)?
            }
        } else {
            // Custom type
            assign_custom_type_name := s
            assign_custom_symbol_info := context.scope_stack.lookup_symbol(assign_custom_type_name)?
            catch (err: KeyNotFoundError) {
                throw inner_e.lang_error(context.path, "eval", format("Unknown custom type '", assign_custom_type_name, "'"))
            }

            switch assign_custom_symbol_info.value_type {
            case ValueType.TType(TTypeDef.TEnumDef):
                assign_enum_result := eval_expr(context, inner_e)?
                if assign_enum_result.is_throw {
                    return assign_enum_result
                }
                assign_enum_expr_result_str := assign_enum_result.value
                _ := EvalArena.insert_enum(context, var_name, assign_custom_type_name, assign_enum_expr_result_str, e)?
            case ValueType.TType(TTypeDef.TStructDef):
                assign_struct_result := eval_expr(context, inner_e)?
                if assign_struct_result.is_throw {
                    return assign_struct_result
                }
                assign_struct_expr_result_str := assign_struct_result.value
                // Issue #159 Step 6: Replace copy_fields with clone + offset rebinding/memcpy
                // Garbager inserts clone for identifiers; fresh constructors are already new.
                if var_name.contains(".") {
                    // Field path: memcpy into field slot
                    mut assign_src_offset := 0
                    mut assign_src_found := false
                    assign_src_offset = context.scope_stack.lookup_var(assign_struct_expr_result_str)?
                    assign_src_found = true
                    catch (err: KeyNotFoundError) {
                        if assign_struct_expr_result_str.contains(".") {
                            assign_src_offset = context.get_field_offset(assign_struct_expr_result_str)?
                            assign_src_found = true
                        }
                    }
                    if not(assign_src_found) {
                        throw inner_e.lang_error(context.path, "eval", format("Undefined variable '", assign_struct_expr_result_str, "' for assignment to '", var_name, "'"))
                    }
                    assign_dest_offset := context.get_field_offset(var_name)?
                    assign_type_size := context.get_type_size(assign_custom_type_name)?
                    g_arena.set(assign_dest_offset, g_arena.get(assign_src_offset, assign_type_size), assign_type_size)
                } else {
                    // Simple var: memcpy into existing slot
                    // Must use memcpy (not offset rebinding) because the variable
                    // may live in an outer scope frame. Offset rebinding would only
                    // update the current frame, leaving the outer frame stale.
                    mut assign_src_offset := 0
                    mut assign_src_found := false
                    assign_src_offset = context.scope_stack.lookup_var(assign_struct_expr_result_str)?
                    assign_src_found = true
                    catch (err: KeyNotFoundError) {
                        if assign_struct_expr_result_str.contains(".") {
                            assign_src_offset = context.get_field_offset(assign_struct_expr_result_str)?
                            assign_src_found = true
                        }
                    }
                    if not(assign_src_found) {
                        throw inner_e.lang_error(context.path, "eval", format("Could not find arena index for '", assign_struct_expr_result_str, "'"))
                    }
                    assign_dest_offset := context.scope_stack.lookup_var(var_name)?
                    catch (err: KeyNotFoundError) {
                        throw inner_e.lang_error(context.path, "eval", format("Could not find arena index for '", var_name, "'"))
                    }
                    assign_type_size := context.get_type_size(assign_custom_type_name)?
                    g_arena.set(assign_dest_offset, g_arena.get(assign_src_offset, assign_type_size), assign_type_size)
                }
            case:
                throw inner_e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of custom type '", assign_custom_type_name, "' of value type '", value_type_to_str(assign_custom_symbol_info.value_type), "'."))
            }
        }
        return EvalResult.new("")
    case ValueType.TType(TTypeDef.TStructDef):
        throw e.todo_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'"))
    case ValueType.TFunction(func_type):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(var_name, func_def.clone())?
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' to function type '", value_type_to_str(value_type), "'"))
        }
    case ValueType.TType(TTypeDef.TEnumDef):
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'."))
    case ValueType.TMulti(types):
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'."))
    case:
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of unhandled type '", value_type_to_str(value_type), "'."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return EvalResult.new("")
}

eval_identifier_expr_struct_member := proc(name: Str, inner_name: Str, mut context: Context, inner_e: Expr, member_decl: Declaration) returns EvalResult throws Str {
    switch member_decl.value_type {
    case ValueType.TCustom(custom_type_name):
        combined := format(name, ".", inner_name)
        if custom_type_name.eq("I64") {
            i64_result := EvalArena.get_i64(context, combined, inner_e)?
            return EvalResult.new(I64.to_str(i64_result))
        } else if custom_type_name.eq("U8") {
            u8_result : U8 = EvalArena.get_u8(context, combined, inner_e)?
            return EvalResult.new(U8.to_str(u8_result))
        } else if custom_type_name.eq("Str") {
            result := string_from_context(context, combined, inner_e)?
            return EvalResult.new(result)
        } else {
            return EvalResult.new(combined)
        }
    case:
        throw inner_e.lang_error(context.path, "eval", format("struct '", name, "' has no const (static) member '", inner_name, "' of struct value type '", value_type_to_str(member_decl.value_type), "'"))
    }
    return EvalResult.new("")
}

eval_identifier_expr_struct := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    struct_def := context.scope_stack.lookup_struct(name)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Struct '", name, "' not found in context"))
    }
    inner_e := e.get(0)?
    switch inner_e.node_type {
    case NodeType.Identifier(inner_name):
        member_decl := struct_def.get_member_or_err(inner_name, name, context.path, e)?
        return eval_identifier_expr_struct_member(name, inner_name, context, inner_e, member_decl)?
    case:
        throw e.lang_error(context.path, "eval", format("identifier '", name, "' should only have identifiers inside."))
    }
    return EvalResult.new("")
}

eval_custom_expr := proc(e: Expr, mut context: Context, name: Str, custom_type_name: Str) returns EvalResult throws Str {
    custom_symbol := context.scope_stack.lookup_symbol(custom_type_name)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Argument '", name, "' is of undefined type ", custom_type_name, "."))
    }

    switch custom_symbol.value_type {
    case ValueType.TType(TTypeDef.TEnumDef):
        // If name equals the type name, this is a reference to the type itself, not a variable
        if name.eq(custom_type_name) {
            throw e.lang_error(context.path, "eval", format("Cannot use enum type '", name, "' as a value"))
        }
        enum_val := EvalArena.get_enum(context, name, e)?
        // Set temp_enum_payload so that if this enum is assigned to another variable,
        // the payload will be preserved
        if not(NULL.eq(enum_val.payload.data)) {
            // Read payload vec from Ptr
            mut payload_vec := Vec.new(U8)
            memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
            // Check if payload_type is set (not NULL)
            if not(NULL.eq(enum_val.payload_type.data)) {
                // Read payload_type from Ptr
                mut payload_type := ValueType.TCustom("")
                memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
                // Bug #74 fix: Heap-allocate EnumPayload to avoid use-after-free
                mut temp_payload := EnumPayload(data=payload_vec.clone(), value_type=payload_type)
                heap_payload_ptr := malloc(size_of(EnumPayload))?
                memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
                context.temp_enum_payload.data = heap_payload_ptr
            }
        }
        return EvalResult.new(format(custom_type_name, ".", enum_val.enum_name))
    case ValueType.TType(TTypeDef.TStructDef):
        if e.params.len().eq(0) {
            return EvalResult.new(name)
        }

        mut current_name := name
        mut current_type := ValueType.TCustom(custom_type_name)

        for inner_e: Expr in e.params {
            switch inner_e.node_type {
            case NodeType.Identifier(inner_name):
                switch current_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    throw inner_e.todo_error(context.path, "eval", format("'", current_name, "': StructDef cannot be a field yet"))
                case ValueType.TCustom(curr_type_name):
                    inner_custom_symbol := context.scope_stack.lookup_symbol(curr_type_name)?
                    catch (err: KeyNotFoundError) {
                        throw inner_e.lang_error(context.path, "eval", format("Custom type '", curr_type_name, "' not found in symbols"))
                    }
                    switch inner_custom_symbol.value_type {
                    case ValueType.TType(TTypeDef.TStructDef):
                        struct_def := context.scope_stack.lookup_struct(curr_type_name)?
                        catch (err: KeyNotFoundError) {
                            throw e.lang_error(context.path, "eval", format("Struct '", curr_type_name, "' not found in context"))
                        }
                        member_decl := struct_def.get_member_or_err(inner_name, curr_type_name, context.path, inner_e)?
                        current_type = member_decl.value_type
                        current_name = format(current_name, ".", inner_name)
                    case ValueType.TType(TTypeDef.TEnumDef):
                        throw inner_e.lang_error(context.path, "eval", format("Enum '", current_name, "' does not support nested members"))
                    case:
                        throw inner_e.lang_error(context.path, "eval", "Custom types cannot have nested members")
                    }
                case ValueType.TType(TTypeDef.TEnumDef):
                    throw inner_e.lang_error(context.path, "eval", format("Enum '", current_name, "' does not support nested members"))
                case:
                    throw inner_e.lang_error(context.path, "eval", format("Unexpected type for '", current_name, "', cannot access member '", inner_name, "'"))
                }
            case:
                throw inner_e.lang_error(context.path, "eval", format("Expected identifier, found ", enum_to_str(inner_e.node_type)))
            }
        }

        if e.params.len().eq(0) {
            throw e.lang_error(context.path, "eval", "eval_custom_expr: Expected at least one parameter")
        }
        mut last_inner_e := Expr()
        e.params.get(e.params.len().sub(1), last_inner_e)?

        switch current_type {
        case ValueType.TCustom(curr_type_name):
            if curr_type_name.eq("I64") {
                i64_result := EvalArena.get_i64(context, current_name, e)?
                return EvalResult.new(I64.to_str(i64_result))
            } else if curr_type_name.eq("U8") {
                u8_result : U8 = EvalArena.get_u8(context, current_name, e)?
                return EvalResult.new(U8.to_str(u8_result))
            } else if curr_type_name.eq("Str") {
                result := string_from_context(context, current_name, e)?
                return EvalResult.new(result)
            } else {
                curr_type_name_str := value_type_to_str(current_type)
                custom_symbol_info := context.scope_stack.lookup_symbol(curr_type_name_str)?
                catch (err: KeyNotFoundError) {
                    throw last_inner_e.lang_error(context.path, "eval", format("Unknown custom type '", curr_type_name_str, "'"))
                }
                switch custom_symbol_info.value_type {
                case ValueType.TType(TTypeDef.TEnumDef):
                    field_enum_val := EvalArena.get_enum(context, current_name, last_inner_e)?
                    // Set temp_enum_payload if this enum has a payload
                    if not(NULL.eq(field_enum_val.payload.data)) {
                        // Read payload vec from Ptr
                        mut field_payload_vec := Vec.new(U8)
                        memcpy(to_ptr(field_payload_vec), field_enum_val.payload.data, size_of(Vec))
                        // Check if payload_type is set (not NULL)
                        if not(NULL.eq(field_enum_val.payload_type.data)) {
                            // Read payload_type from Ptr
                            mut field_payload_type := ValueType.TCustom("")
                            memcpy(to_ptr(field_payload_type), field_enum_val.payload_type.data, size_of(ValueType))
                            // Bug #74 fix: Heap-allocate EnumPayload to avoid use-after-free
                            mut field_temp_payload := EnumPayload(data=field_payload_vec.clone(), value_type=field_payload_type)
                            field_heap_payload_ptr := malloc(size_of(EnumPayload))?
                            memcpy(field_heap_payload_ptr, to_ptr(field_temp_payload), size_of(EnumPayload))
                            context.temp_enum_payload.data = field_heap_payload_ptr
                        }
                    }
                    return EvalResult.new(format(curr_type_name_str, ".", field_enum_val.enum_name))
                case ValueType.TType(TTypeDef.TStructDef):
                    return EvalResult.new(current_name)
                case:
                    throw last_inner_e.todo_error(context.path, "eval", format("Cannot access '", current_name, "'. Fields of custom type '", curr_type_name_str, "' not implemented"))
                }
            }
        case:
            throw e.lang_error(context.path, "eval", format("Invalid type for '", current_name, "'."))
        }
    case:
        throw e.lang_error(context.path, "eval", format("'", name, "' of type: '", custom_type_name, "': custom types are supposed to be struct or enum, found '", value_type_to_str(custom_symbol.value_type), "'."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: BadAlloc) { panic(loc(), "eval_custom_expr: buy more ram") }
    return EvalResult.new("")
}

eval_identifier_expr := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // Bug #32 fix: Handle field access on expression results
    // When name is "_" and params[0] is an FCall, evaluate that first,
    // then params[1..] are field access on its result
    if name.eq("_") {
        if e.params.len().gt(0) {
            // Evaluate the base expression (params[0])
            base_expr := e.get(0)?
            base_result := eval_expr(context, base_expr)?
            if base_result.is_throw {
                return base_result
            }

            // Get the type of the result
            base_type := get_value_type(context, base_expr)?

            // Now we have the result stored in arena - access the fields
            // The result.value contains the identifier for the result
            result_name := base_result.value

            // If there's only one param (the FCall), just return the result
            if e.params.len().eq(1) {
                return base_result
            }

            // Build the full field path by traversing params[1..]
            mut current_name := result_name
            for path_i in 1..e.params.len() {
                path_field_expr := e.get(path_i)?
                switch path_field_expr.node_type {
                case NodeType.Identifier(path_field_name):
                    current_name = format(current_name, ".", path_field_name)
                case:
                    throw e.error(context.path, "eval", "Expected identifier in field access chain")
                }
            }

            // Now evaluate the final field access using the built path
            // We need to determine the type of the final field to return it properly
            switch base_type {
            case ValueType.TCustom(base_type_name):
                // Get the struct definition to traverse the field chain
                mut current_type := base_type_name
                for type_i in 1..e.params.len() {
                    type_field_expr := e.get(type_i)?
                    switch type_field_expr.node_type {
                    case NodeType.Identifier(type_field_name):
                        type_struct_def := context.scope_stack.lookup_struct(current_type)?
                        catch (err: KeyNotFoundError) {
                            throw e.error(context.path, "eval", format("Struct '", current_type, "' not found"))
                        }
                        type_member := SStructDef.get_member_or_err(type_struct_def, type_field_name, current_type, context.path, e)?
                        switch type_member.value_type {
                        case ValueType.TCustom(inner_type):
                            current_type = inner_type
                        case:
                            throw e.error(context.path, "eval", format("Unexpected field type for '", type_field_name, "'"))
                        }
                    case:
                        // Already handled above
                    }
                }

                // Now get the value based on the final type
                if current_type.eq("I64") {
                    i64_val := EvalArena.get_i64(context, current_name, e)?
                    return EvalResult.new(I64.to_str(i64_val))
                } else if current_type.eq("U8") {
                    u8_val : U8 = EvalArena.get_u8(context, current_name, e)?
                    return EvalResult.new(U8.to_str(u8_val))
                } else if current_type.eq("Str") {
                    val := string_from_context(context, current_name, e)?
                    return EvalResult.new(val)
                } else {
                    // Bug #157: Check if this is an enum type - need to read actual value from arena
                    if context.scope_stack.has_enum(current_type) {
                        enum_val := EvalArena.get_enum(context, current_name, e)?
                        return EvalResult.new(format(enum_val.enum_type, ".", enum_val.enum_name))
                    }
                    // Return the field path for struct fields
                    return EvalResult.new(current_name)
                }
            case:
                throw e.error(context.path, "eval", "Cannot access fields on non-struct type")
            }
        }
    }

    symbol_info := context.scope_stack.lookup_symbol(name)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Undefined symbol '", name, "'. This should have been caught in the compile phase."))
    }

    switch symbol_info.value_type {
    case ValueType.TFunction(FunctionType.FTFunc):
        return EvalResult.new(name)
    case ValueType.TFunction(FunctionType.FTProc):
        return EvalResult.new(name)
    case ValueType.TFunction(FunctionType.FTMacro):
        return EvalResult.new(name)
    case ValueType.TType(TTypeDef.TEnumDef):
        inner_e := e.get(0)?
        switch inner_e.node_type {
        case NodeType.Identifier(inner_name):
            // TODO check that inner_name is in enum_def
            // TODO check if that inner_name has an optional type
            return EvalResult.new(format(name, ".", inner_name))
        case:
            throw e.lang_error(context.path, "eval", format("identifier '", name, "' should only have identifiers inside."))
        }
    case ValueType.TType(TTypeDef.TStructDef):
        return eval_identifier_expr_struct(name, context, e)?
    case ValueType.TCustom(ident_s):
        if ident_s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Can't infer the type of identifier '", name, "'."))
        } else if ident_s.eq("I64") {
            ident_i64_val := EvalArena.get_i64(context, name, e)?
            return EvalResult.new(I64.to_str(ident_i64_val))
        } else if ident_s.eq("U8") {
            ident_u8_val : U8 = EvalArena.get_u8(context, name, e)?
            return EvalResult.new(U8.to_str(ident_u8_val))
        } else if ident_s.eq("Str") {
            if e.params.len().eq(0) {
                ident_val := string_from_context(context, name, e)?
                mut ident_str_result := EvalResult.new(ident_val)
                ident_str_result.arena_offset = context.scope_stack.lookup_var(name)?
                catch (err: KeyNotFoundError) {
                    // Variable not in arena (shouldn't happen but safe fallback)
                }
                return ident_str_result
            }
            return eval_custom_expr(e, context, name, ident_s)?
        } else {
            return eval_custom_expr(e, context, name, ident_s)?
        }
    case:
        throw e.todo_error(context.path, "eval", format("Can't use identifier '", name, "'. Type ", value_type_to_str(symbol_info.value_type), " not supported yet."))
    }

    return EvalResult.new("")
}

eval_body := proc(mut context: Context, statements: Vec) returns EvalResult throws Str {
    mut pending_throw := EvalResult()
    mut has_pending_throw := false

    for i in 0..statements.len() {
        mut stmt := Expr()
        statements.get(i, stmt)?

        if has_pending_throw {
            throw_result := pending_throw
            mut is_catch := false
            switch stmt.node_type {
            case NodeType.Catch:
                is_catch = true
            case:
            }
            if is_catch {
                if stmt.params.len().eq(3) {
                    // params[0]: error variable name (e.g., "err")
                    // params[1]: error type (e.g., "AllocError")
                    // params[2]: body
                    mut var_expr := Expr()
                    stmt.params.get(0, var_expr)?
                    mut var_name := ""
                    switch var_expr.node_type {
                    case NodeType.Identifier(name):
                        var_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch variable must be an identifier")
                    }
                    mut type_expr := Expr()
                    stmt.params.get(1, type_expr)?
                    mut type_name := ""
                    switch type_expr.node_type {
                    case NodeType.Identifier(name):
                        type_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch type must be an identifier")
                    }
                    if not(throw_result.thrown_type.eq("")) {
                        thrown_type := throw_result.thrown_type
                        if type_name.eq(thrown_type) {
                            // Bind the error variable to the caught error value
                            context.scope_stack.declare_symbol(var_name, SymbolInfo(value_type=ValueType.TCustom(thrown_type)))?

                            // Map instance fields for the error variable
                            // First try to find the arena index for proper field mapping
                            mut found_offset := false
                            offset := context.scope_stack.lookup_var(throw_result.value)?
                            found_offset = true
                            catch (err: KeyNotFoundError) {
                                // found_offset stays false - var not found
                            }

                            if found_offset {
                                mut lf_idx := context.scope_stack.frames.len().sub(1)
                                mut lf := ScopeFrame()
                                context.scope_stack.frames.get(lf_idx, lf)?
                                lf.arena_index.set(var_name.clone(), offset)
                                context.scope_stack.frames.set(lf_idx, lf)?

                                // Copy ALL field mappings (including nested) from thrown instance to catch variable
                                // This handles both mutable and immutable fields, and nested struct fields
                                source_prefix := format(throw_result.value, ".")
                                dest_prefix := format(var_name, ".")

                                lf2 := context.scope_stack.last_frame()?
                                mut keys_to_copy := Vec.new(Str)
                                for akey: Str in lf2.arena_index.keys {
                                    if akey.starts_with(source_prefix) {
                                        keys_to_copy.push(akey.clone())
                                    }
                                }
                                for src_key: Str in keys_to_copy {
                                    mut src_offset := 0
                                    mut found_key := false
                                    src_offset = context.scope_stack.lookup_var(src_key)?
                                    found_key = true
                                    catch (err: KeyNotFoundError) {
                                        // found_key stays false - var not found
                                    }
                                    if found_key {
                                        dest_key := src_key.replacen(source_prefix, dest_prefix, 1)
                                        mut lf3_idx := context.scope_stack.frames.len().sub(1)
                                        mut lf3 := ScopeFrame()
                                        context.scope_stack.frames.get(lf3_idx, lf3)?
                                        lf3.arena_index.set(dest_key, src_offset)
                                        context.scope_stack.frames.set(lf3_idx, lf3)?
                                    }
                                }

                                // Also copy symbol mappings for all fields
                                symbol_keys_to_copy := context.scope_stack.get_symbols_with_prefix(source_prefix)
                                for sym_src_key: Str in symbol_keys_to_copy {
                                    mut src_symbol := SymbolInfo()
                                    mut found_sym := false
                                    src_symbol = context.scope_stack.lookup_symbol(sym_src_key)?
                                    found_sym = true
                                    catch (err: KeyNotFoundError) {
                                        // found_sym stays false - symbol not found
                                    }
                                    if found_sym {
                                        sym_dest_key := sym_src_key.replacen(source_prefix, dest_prefix, 1)
                                        context.scope_stack.declare_symbol(sym_dest_key, src_symbol.clone())?
                                    }
                                }
                            } else {
                                // Fallback: try to map fields from the thrown value or type
                                // Special handling for Str: when throwing a string literal, we need to create a proper Str struct
                                if thrown_type.eq("Str") {
                                    // The thrown value is the actual string content, not a struct instance name
                                    // Create a proper Str struct for the catch variable
                                    EvalArena.insert_string(context, var_name, throw_result.value, stmt)?
                                } else {
                                    mut struct_def := SStructDef()
                                    mut has_struct := false
                                    struct_def = context.scope_stack.lookup_struct(thrown_type)?
                                    has_struct = true
                                    catch (err: KeyNotFoundError) { }
                                    if has_struct {
                                        source_name := throw_result.value

                                        // Register the base variable first
                                        mut base_offset := 0
                                        mut base_found := false
                                        base_offset = context.scope_stack.lookup_var(source_name)?
                                        base_found = true
                                        catch (err: KeyNotFoundError) { }
                                        if base_found {
                                            mut lf4_idx := context.scope_stack.frames.len().sub(1)
                                            mut lf4 := ScopeFrame()
                                            context.scope_stack.frames.get(lf4_idx, lf4)?
                                            lf4.arena_index.set(var_name, base_offset)
                                            context.scope_stack.frames.set(lf4_idx, lf4)?
                                        }

                                        // Copy symbol mappings for all fields
                                        for field_decl: Declaration in struct_def.members {
                                            dst_field := format(var_name, ".", field_decl.name)
                                            context.scope_stack.declare_symbol(dst_field, SymbolInfo(value_type=field_decl.value_type))?
                                        }
                                    }
                                }
                            }

                            mut body_expr := Expr()
                            stmt.params.get(2, body_expr)?
                            catch_body_result := eval_body(context, body_expr.params)?

                            // Clean up the error variable binding after the catch block
                            _ := context.scope_stack.remove_symbol(var_name)?
                            _ := context.scope_stack.remove_var(var_name)?
                            // Also remove the field symbol mappings
                            mut cleanup_struct_def := SStructDef()
                            mut has_cleanup_struct := false
                            cleanup_struct_def = context.scope_stack.lookup_struct(thrown_type)?
                            has_cleanup_struct = true
                            catch (err: KeyNotFoundError) { }
                            if has_cleanup_struct {
                                for cleanup_field_decl: Declaration in cleanup_struct_def.members {
                                    combined_name := format(var_name, ".", cleanup_field_decl.name)
                                    _ := context.scope_stack.remove_symbol(combined_name)?
                                }
                            }

                            if catch_body_result.is_return.or(catch_body_result.is_break).or(catch_body_result.is_continue) {
                                return catch_body_result
                            } else if catch_body_result.is_throw {
                                pending_throw = catch_body_result
                                has_pending_throw = true
                            } else {
                                has_pending_throw = false
                            }
                        }
                    }
                }
            }
        } else {
            // If no pending throw, ignore catch statements
            mut body_is_catch := false
            switch stmt.node_type {
            case NodeType.Catch:
                body_is_catch = true
            case:
            }
            if not(body_is_catch) {
                stmt_result := eval_expr(context, stmt)?
                if stmt_result.is_return.or(stmt_result.is_break).or(stmt_result.is_continue) {
                    return stmt_result
                } else if stmt_result.is_throw {
                    pending_throw = stmt_result
                    has_pending_throw = true
                }
            }
        }
    }

    if has_pending_throw {
        return pending_throw
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return EvalResult.new("")
}

// ---------- generic eval things

// MutArgEntry - internal structure for tracking mut arguments
MutArgEntry := struct {
    mut arg_name: Str = ""
    mut source_name: Str = ""
    mut value_type: ValueType = ValueType.TMulti("")
}

// MutArgStructData - data for Struct variant of MutArgValue
MutArgStructData := struct {
    mut offset: I64 = 0
    mut type_name: Str = ""
    mut was_passed_by_ref: Bool = false
}

// MutArgValue - enum with payloads matching Rust's MutArgValue
MutArgValue := enum {
    I64: I64,
    U8: U8,
    Str: Str,
    Enum: EnumVal,
    Struct: MutArgStructData,
}

// CollectedMutArg - collected mut arg to write back
CollectedMutArg := struct {
    mut source_name: Str = ""
    mut value: MutArgValue = MutArgValue.I64(0)
}

eval_user_func_proc_call := proc(func_def: SFuncDef, name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // TODO REFACTOR: Replace context.clone() with scope push/pop

    mut function_frame := ScopeFrame(scope_type=ScopeType.Function)
    saved_path := context.path
    _ := validate_func_arg_count(context.path, e, name, func_def)?

    mut param_index := 1
    mut mut_args := Vec.new(MutArgEntry)
    mut pass_by_ref_params := Vec.new(Str)
    mut params_consumed := false

    for arg: Declaration in func_def.args {
        if not(params_consumed) {
            // Use set() to allow overwriting - Rust's HashMap.insert overwrites
            function_frame.symbols.set(arg.name, SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))

            switch arg.value_type {
            case ValueType.TMulti(multi_value_type):
                // Handle variadic args
                mut values := Vec.new(Str)
                for vi in param_index..e.params.len() {
                    mut expr := Expr()
                    e.params.get(vi, expr)?
                    arg_result := eval_expr(context, expr)?
                    if arg_result.is_throw {
                        return arg_result
                    }
                    values.push(arg_result.value)
                }

                array_type_name := "Array"
                // Use set() to overwrite the TMulti entry with TCustom("Array")
                function_frame.symbols.set(arg.name, SymbolInfo(value_type=ValueType.TCustom(array_type_name), is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))
                EvalArena.insert_array_into_frame(context, function_frame, arg.name, multi_value_type, values, e)?
                params_consumed = true

            case ValueType.TCustom(custom_type_name):
                current_arg := e.get(param_index)?

                // Special handling for Dynamic parameters: don't evaluate, just copy the value
                // When a type like I64, U8, Str is passed to a Dynamic/Type parameter,
                // store the type name as a string so size_of(T) and type_as_str(T) can use it
                if custom_type_name.eq("Dynamic").or(custom_type_name.eq("Type")) {
                    switch current_arg.node_type {
                    case NodeType.Identifier(id_name):
                        // Bug #37 fix: Only treat as type reference if there are NO params.
                        // An enum constructor like SimpleColor.Green has params (Green),
                        // so it should fall through to normal evaluation, not be treated as a type.
                        if current_arg.params.len().eq(0) {
                            mut sym := SymbolInfo()
                            sym = context.scope_stack.lookup_symbol(id_name)?
                            switch sym.value_type {
                            case ValueType.TType(tdef):
                                // This is a type identifier - store the type name as a string
                                function_frame.symbols.set(arg.name, SymbolInfo(value_type=ValueType.TCustom("Str")))
                                EvalArena.insert_string_into_frame(context, function_frame, arg.name, id_name, e)?
                                param_index.inc()
                                continue  // Skip eval_expr for this parameter
                            case:
                            }
                            catch (err: KeyNotFoundError) { }
                        }
                    case:
                    }
                    // If it's not a type identifier, fall through to normal evaluation
                }

                {
                    // Check if this is an enum argument and save payload
                    mut enum_payload_backup := EnumPayload()
                    mut has_enum_backup := false
                    switch current_arg.node_type {
                    case NodeType.Identifier(id_name):
                        mut enum_arg_sym := SymbolInfo()
                        enum_arg_sym = context.scope_stack.lookup_symbol(id_name)?
                        switch enum_arg_sym.value_type {
                        case ValueType.TCustom(enum_arg_type_name):
                            mut enum_type_sym := SymbolInfo()
                            enum_type_sym = context.scope_stack.lookup_symbol(enum_arg_type_name)?
                            switch enum_type_sym.value_type {
                            case ValueType.TType(TTypeDef.TEnumDef):
                                enum_val := EvalArena.get_enum(context, id_name, e)?
                                if not(NULL.eq(enum_val.payload.data)) {
                                    mut payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
                                    if not(NULL.eq(enum_val.payload_type.data)) {
                                        mut payload_type := ValueType.TCustom("")
                                        memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
                                        enum_payload_backup = EnumPayload(data=payload_vec.clone(), value_type=payload_type)
                                        has_enum_backup = true
                                    }
                                }
                                catch (err3: Str) { }
                            case:
                            }
                            catch (err2: KeyNotFoundError) { }
                        case:
                        }
                        catch (err1: KeyNotFoundError) { }
                    case:
                    }

                    eval_result := eval_expr(context, current_arg)?
                    if eval_result.is_throw {
                        return eval_result
                    }
                    arg_result_arena_offset := eval_result.arena_offset
                    arg_result_str := eval_result.value

                    // Restore enum payload if we saved it
                    if has_enum_backup {
                        // Bug #74 fix: Heap-allocate EnumPayload to avoid use-after-free
                        mut temp_payload := EnumPayload()
                        temp_payload = enum_payload_backup
                        heap_payload_ptr := malloc(size_of(EnumPayload))?
                        memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
                        context.temp_enum_payload.data = heap_payload_ptr
                    }

                    // Resolve Dynamic/Type to actual type first
                    mut resolved_type_name := custom_type_name
                    if custom_type_name.eq("Dynamic") {
                        resolved_type_name = value_type_to_str(get_value_type(context, current_arg)?)
                    } else if custom_type_name.eq("Type") {
                        resolved_type_name = value_type_to_str(get_value_type(context, current_arg)?)
                    }

                    // Create resolved ValueType for the parameter
                    resolved_value_type := ValueType.TCustom(resolved_type_name)

                    // Now push to mut_args with the resolved type
                    if arg.is_mut {
                        switch current_arg.node_type {
                        case NodeType.Identifier(id_):
                            // Build full path for field access
                            mut full_id := id_
                            for param: Expr in current_arg.params {
                                switch param.node_type {
                                case NodeType.Identifier(field_name):
                                    full_id = format(full_id, ".", field_name)
                                case:
                                    throw e.lang_error(context.path, "eval", "Field access must use identifiers")
                                }
                            }
                            mut mut_entry := MutArgEntry()
                            mut_entry.arg_name = arg.name
                            mut_entry.source_name = full_id
                            mut_entry.value_type = ValueType.TCustom(resolved_type_name)
                            mut_args.push(mut_entry)
                        case:
                            throw e.lang_error(context.path, "eval", "mut arguments must be passed as identifiers or field access")
                        }
                    }

                    // Handle ownership transfer for 'own' parameters
                    // Like const/mut: identifiers (including field access) by reference, expressions copied
                    if arg.is_own {
                        switch current_arg.node_type {
                        case NodeType.Identifier(source_var):
                            // Transfer arena offset from caller to function frame
                            mut offset := 0
                            offset = context.scope_stack.lookup_var(source_var)?
                            function_frame.arena_index.set(arg.name, offset)

                            // Transfer symbol info for fields
                            own_prefix := format(source_var, ".")
                            symbol_keys_to_transfer := context.scope_stack.get_symbols_with_prefix(own_prefix)
                            for transfer_key: Str in symbol_keys_to_transfer {
                                mut field_sym := SymbolInfo()
                                field_sym = context.scope_stack.lookup_symbol(transfer_key)?
                                own_new_key := transfer_key.replace(source_var, arg.name)
                                function_frame.symbols.set(own_new_key, field_sym.clone())
                                catch (err_sym: KeyNotFoundError) { }
                            }

                            // Remove from caller's context (ownership transferred)
                            _ := context.scope_stack.remove_var(source_var)?
                            _ := context.scope_stack.remove_symbol(source_var)?
                            for remove_key: Str in symbol_keys_to_transfer {
                                _ := context.scope_stack.remove_symbol(remove_key)?
                            }

                            param_index.inc()
                            continue  // Skip normal allocation logic
                            catch (err_var: KeyNotFoundError) { }
                        case:
                            // If not an identifier, fall through to copy like const/mut do
                        }
                    }

                    // Phase 3: Pass-by-reference for non-copy, non-own, non-Type parameters
                    // If argument is a variable (identifier), share arena offset instead of copying
                    // Note: Type parameters need copy semantics for type name storage, so skip them
                    // Note: Dynamic parameters NOW use pass-by-reference (including mut Dynamic)
                    // Note: own parameters are handled separately above and should not fall through here
                    // Works for ALL types thanks to field offset refactoring (commit 2b9d08d):
                    // - Only base offset stored in arena_index
                    // - Field offsets calculated dynamically from struct definitions
                    // - Inline memory layout means sharing base offset shares all fields
                    if not(arg.is_copy).and(not(arg.is_own)).and(not(resolved_type_name.eq("Type"))) {
                        switch current_arg.node_type {
                        case NodeType.Identifier(source_var):
                            // Only share offset for SIMPLE identifiers (no field access, no params)
                            // Field access like s.cap is also an Identifier node but has params
                            if current_arg.params.len().eq(0) {
                                // Share arena offset from caller context (zero-copy pass-by-reference)
                                mut share_offset := 0
                                share_offset = context.scope_stack.lookup_var(source_var)?
                                // Create symbol info for parameter using the resolved type
                                param_symbol := SymbolInfo(value_type=resolved_value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
                                function_frame.symbols.set(arg.name.clone(), param_symbol)
                                function_frame.arena_index.set(arg.name.clone(), share_offset)

                                // Copy symbol entries for fields from ALL frames to callee
                                ref_prefix := format(source_var, ".")
                                ref_replacement_prefix := format(arg.name, ".")
                                mut ref_field_symbols_to_copy := Vec.new(SymbolEntry)
                                for ref_caller_frame: ScopeFrame in context.scope_stack.frames {
                                    for ref_skey: Str in ref_caller_frame.symbols.keys {
                                        if ref_skey.starts_with(ref_prefix) {
                                            mut ref_svalue := SymbolInfo()
                                            ref_caller_frame.symbols.get(ref_skey, ref_svalue)?
                                            ref_new_skey := ref_skey.replacen(ref_prefix, ref_replacement_prefix, 1)
                                            ref_field_symbols_to_copy.push(SymbolEntry(name=ref_new_skey, info=ref_svalue.clone()))
                                        }
                                    }
                                }
                                for ref_entry: SymbolEntry in ref_field_symbols_to_copy {
                                    function_frame.symbols.set(ref_entry.name, ref_entry.info)
                                }

                                // Track that this parameter was passed by reference
                                pass_by_ref_params.push(arg.name.clone())

                                param_index.inc()
                                continue  // Skip allocation logic - we're sharing the offset
                                catch (err: KeyNotFoundError) { }
                            }
                        case:
                        }
                        // If not an identifier or not found, fall through to normal allocation
                        // (expressions must allocate fresh memory)
                    }

                    {
                        switch resolved_type_name {
                        case "I64":
                            EvalArena.insert_i64_into_frame(context, function_frame, arg.name, arg_result_str, e)?
                        case "U8":
                            EvalArena.insert_u8_into_frame(context, function_frame, arg.name, arg_result_str, e)?
                        case "Str":
                            if arg_result_arena_offset.gt(0) {
                                function_frame.arena_index.set(arg.name, arg_result_arena_offset)
                            } else {
                                EvalArena.insert_string_into_frame(context, function_frame, arg.name, arg_result_str, e)?
                            }
                        case:
                            // Custom type (enum or struct)
                            mut custom_symbol := SymbolInfo()
                            mut custom_symbol_found := false
                            custom_symbol = context.scope_stack.lookup_symbol(resolved_type_name)?
                            custom_symbol_found = true
                            catch (err: KeyNotFoundError) { }
                            if not(custom_symbol_found) {
                                throw e.lang_error(context.path, "eval", format("Undefined symbol for custom type '", resolved_type_name, "'"))
                            }
                            mut is_enum_def := false
                            mut is_struct_def := false
                            switch custom_symbol.value_type {
                            case ValueType.TType(ttype_val):
                                switch ttype_val {
                                case TTypeDef.TEnumDef:
                                    is_enum_def = true
                                case TTypeDef.TStructDef:
                                    is_struct_def = true
                                }
                            case:
                            }
                            if is_enum_def {
                                // Transfer payload from outer context if present (temp_enum_payload already on context)
                                _ := EvalArena.insert_enum_into_frame(context, function_frame, arg.name, resolved_type_name, arg_result_str, e)?
                            } else if is_struct_def {
                                // Bug #10 fix: Handle field access chains like s.items
                                mut source_id := ""
                                if current_arg.params.len().gt(0) {
                                    // Build the full path for field access: "s.items"
                                    mut full_path := ""
                                    switch current_arg.node_type {
                                    case NodeType.Identifier(base_id):
                                        full_path = base_id.clone()
                                        for struct_pi in 0..current_arg.params.len() {
                                            mut struct_param := Expr()
                                            current_arg.params.get(struct_pi, struct_param)?
                                            switch struct_param.node_type {
                                            case NodeType.Identifier(struct_field_name):
                                                full_path = format(full_path, ".", struct_field_name)
                                            case:
                                                throw e.lang_error(context.path, "eval", "Field access must use identifiers")
                                            }
                                        }
                                        source_id = full_path
                                    case:
                                        // For non-identifier expressions (like Vec.new(Expr)),
                                        // use the arg_result_str which contains the allocated result
                                        source_id = arg_result_str.clone()
                                    }
                                } else {
                                    switch current_arg.node_type {
                                    case NodeType.Identifier(ident_name):
                                        source_id = ident_name.clone()
                                    case:
                                        // For non-identifier expressions (like Vec.new(Expr)),
                                        // use the arg_result_str which contains the allocated result
                                        source_id = arg_result_str.clone()
                                    }
                                }

                                mut is_identifier := false
                                switch current_arg.node_type {
                                case NodeType.Identifier:
                                    is_identifier = true
                                case:
                                }
                                if is_identifier {
                                    id_ := source_id // Use the full path we calculated

                                    // For pass-by-reference (non-copy, non-own, non-Type), just share the offset
                                    mut should_share_offset := false
                                    if not(arg.is_copy) {
                                        if not(arg.is_own) {
                                            if not(resolved_type_name.eq("Type")) {
                                                should_share_offset = true
                                            }
                                        }
                                    }
                                    if should_share_offset {
                                        mut src_offset := 0
                                        mut src_offset_found := false
                                        src_offset = context.scope_stack.lookup_var(id_)?
                                        src_offset_found = true
                                        catch (err: KeyNotFoundError) { }
                                        if not(src_offset_found) {
                                            if id_.contains(".") {
                                                // Field path - calculate offset dynamically
                                                src_offset = context.get_field_offset(id_)?
                                            } else {
                                                throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context arena_index"))
                                            }
                                        }

                                        // Create symbol for parameter
                                        function_frame.symbols.set(arg.name.clone(), SymbolInfo(value_type=resolved_value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))

                                        // Share the offset (pass-by-reference)
                                        function_frame.arena_index.set(arg.name.clone(), src_offset)

                                        // Copy symbol entries for fields
                                        pbr_prefix := format(id_, ".")
                                        pbr_replacement_prefix := format(arg.name, ".")
                                        mut pbr_field_symbols_to_copy := Vec.new(SymbolEntry)
                                        for pbr_caller_frame: ScopeFrame in context.scope_stack.frames {
                                            for pbr_skey: Str in pbr_caller_frame.symbols.keys {
                                                if pbr_skey.starts_with(pbr_prefix) {
                                                    mut pbr_svalue := SymbolInfo()
                                                    pbr_caller_frame.symbols.get(pbr_skey, pbr_svalue)?
                                                    catch (err: KeyNotFoundError) { }
                                                    pbr_new_skey := pbr_skey.replacen(pbr_prefix, pbr_replacement_prefix, 1)
                                                    pbr_field_symbols_to_copy.push(SymbolEntry(name=pbr_new_skey, info=pbr_svalue.clone()))
                                                }
                                            }
                                        }
                                        for pbr_entry: SymbolEntry in pbr_field_symbols_to_copy {
                                            function_frame.symbols.set(pbr_entry.name, pbr_entry.info)
                                        }

                                        // Track that this was passed by reference
                                        pass_by_ref_params.push(arg.name.clone())
                                    }
                                    if not(should_share_offset).and(arg.is_copy) {
                                        // Issue #159: garbager inserts Type.clone() for struct identifier copy params.
                                        // The clone is now an FCall wrapping the identifier, so this branch
                                        // won't be reached for struct copy params anymore (they go through
                                        // the expression branch below). Keep this as a safety fallback
                                        // that just binds the offset.
                                        mut copy_src_offset := 0
                                        mut copy_src_offset_found := false
                                        copy_src_offset = context.scope_stack.lookup_var(id_)?
                                        copy_src_offset_found = true
                                        catch (err: KeyNotFoundError) { }
                                        if not(copy_src_offset_found) {
                                            if id_.contains(".") {
                                                copy_src_offset = context.get_field_offset(id_)?
                                            } else {
                                                throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context arena_index"))
                                            }
                                        }
                                        function_frame.arena_index.set(arg.name.clone(), copy_src_offset)
                                    }
                                    if not(should_share_offset).and(not(arg.is_copy)) {
                                        // Own/Type identifier parameters: ownership transfer via offset binding.
                                        // No allocation or copy needed - just bind the existing offset.
                                        mut own_src_offset := 0
                                        mut own_src_offset_found := false
                                        own_src_offset = context.scope_stack.lookup_var(id_)?
                                        own_src_offset_found = true
                                        catch (err: KeyNotFoundError) {
                                            // REM: not found in arena_index, try field path
                                        }
                                        if not(own_src_offset_found) {
                                            if id_.contains(".") {
                                                own_src_offset = context.get_field_offset(id_)?
                                            } else {
                                                throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context arena_index"))
                                            }
                                        }
                                        function_frame.arena_index.set(arg.name.clone(), own_src_offset)
                                    }
                                } else {
                                    if arg.is_copy {
                                        // Issue #159: garbager inserts Type.clone() for copy params.
                                        // Clone result is already allocated, just bind offset.
                                        expr_copy_src_offset := context.scope_stack.lookup_var(source_id)?
                                        catch (err: KeyNotFoundError) {
                                            throw e.lang_error(context.path, "eval", format("Source '", source_id, "' not found in caller context"))
                                        }
                                        function_frame.arena_index.set(arg.name.clone(), expr_copy_src_offset)
                                    } else {
                                        // Own/Type expression parameters: bind the expression result offset.
                                        // The expression is already evaluated and allocated in the arena.
                                        expr_src_offset := context.scope_stack.lookup_var(source_id)?
                                        catch (err: KeyNotFoundError) {
                                            throw e.lang_error(context.path, "eval", format("Source '", source_id, "' not found in caller context"))
                                        }
                                        function_frame.arena_index.set(arg.name.clone(), expr_src_offset)

                                        // For own parameters, remove the source from caller's context (ownership transferred)
                                        if arg.is_own {
                                            _ := context.scope_stack.remove_var(source_id)?
                                            _ := context.scope_stack.remove_symbol(source_id)?
                                        }
                                    }
                                }
                            } else {
                                throw e.lang_error(context.path, "eval", format("Cannot use '", arg.name, "' of type '", resolved_type_name, "' as an argument. Custom types can only be struct or enum."))
                            }
                        }
                        }
                    }

            case:
                throw e.todo_error(context.path, "eval", format("Cannot use '", arg.name, "' of type '", value_type_to_str(arg.value_type), "' as an argument. Only enum custom types allowed for now."))
            }

            param_index.inc()
        }
    }

    // Push the populated frame and set function path
    context.scope_stack.frames.push(function_frame)
    context.path = func_def.source_path.clone()

    result := eval_body(context, func_def.body)?
    if result.is_throw {
        // When throwing from a method, we need to copy the thrown struct's arena_index entries
        // from the function frame to the caller frame so that catch blocks can access fields
        if not(result.thrown_type.eq("")) {
            thrown_type_name := result.thrown_type
            // Check if this is a custom type (struct)
            mut type_symbol := SymbolInfo()
            mut type_symbol_found := false
            type_symbol = context.scope_stack.lookup_symbol(thrown_type_name)?
            type_symbol_found = true
            catch (err: KeyNotFoundError) { }
            if type_symbol_found {
                mut thrown_is_struct_def := false
                switch type_symbol.value_type {
                case ValueType.TType(ttype_val2):
                    switch ttype_val2 {
                    case TTypeDef.TStructDef:
                        thrown_is_struct_def = true
                    case:
                    }
                case:
                }
                if thrown_is_struct_def {
                    // Copy the base variable entry first (from function frame to caller frame)
                    mut base_offset := 0
                    mut base_offset_found := false
                    base_offset = context.scope_stack.lookup_var(result.value)?
                    base_offset_found = true
                    catch (err: KeyNotFoundError) { }
                    if base_offset_found {
                        // Get the second-to-last frame (caller's frame)
                        thrown_frame_count := context.scope_stack.frames.len()
                        if thrown_frame_count.gteq(2) {
                            mut thrown_caller_frame := ScopeFrame()
                            context.scope_stack.frames.get(thrown_frame_count.sub(2), thrown_caller_frame)?
                            thrown_caller_frame.arena_index.set(result.value.clone(), base_offset)
                            context.scope_stack.frames.set(thrown_frame_count.sub(2), thrown_caller_frame)?
                        }
                    }

                    // Copy symbol entries for fields to caller's frame (not current frame which is about to be popped)
                    throw_source_prefix := format(result.value, ".")
                    throw_frame_count := context.scope_stack.frames.len()
                    throw_symbol_keys_to_copy := context.scope_stack.get_symbols_with_prefix(throw_source_prefix)
                    for throw_sym_key: Str in throw_symbol_keys_to_copy {
                        mut throw_src_symbol := SymbolInfo()
                        mut throw_src_symbol_found := false
                        throw_src_symbol = context.scope_stack.lookup_symbol(throw_sym_key)?
                        throw_src_symbol_found = true
                        catch (err: KeyNotFoundError) { }
                        if throw_src_symbol_found {
                            if throw_frame_count.gt(1) {
                                mut throw_sym_caller_frame := ScopeFrame()
                                context.scope_stack.frames.get(throw_frame_count.sub(2), throw_sym_caller_frame)?
                                throw_sym_caller_frame.symbols.set(throw_sym_key, throw_src_symbol.clone())
                                context.scope_stack.frames.set(throw_frame_count.sub(2), throw_sym_caller_frame)?
                            }
                        }
                    }
                }
            }
        }
        // Pop frame and restore path before returning
        _ := context.scope_stack.pop()?
        context.path = saved_path
        return result // CLEANUP SITE 3: Propagate throw from function body
    }
    result_arena_offset := result.arena_offset
    result_str := result.value

    // Save struct/enum return value info BEFORE popping (needed for return handling)
    mut saved_return_offset := 0
    mut has_saved_return_offset := false
    if func_def.return_types.len().eq(1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)?
        mut is_tcustom := false
        mut custom_type_name := ""
        switch return_type {
        case ValueType.TCustom(custom_name):
            is_tcustom = true
            custom_type_name = custom_name
        case:
        }
        if is_tcustom {
            switch custom_type_name {
            case "I64":
            case "U8":
            case "Str":
                // None for primitives
            case:
                // Bug #160: Try lookup_var first, then get_field_offset for field paths
                saved_return_offset = context.scope_stack.lookup_var(result_str)?
                has_saved_return_offset = true
                catch (err: KeyNotFoundError) {
                    if result_str.contains(".") {
                        saved_return_offset = context.get_field_offset(result_str)?
                        has_saved_return_offset = true
                        catch (err2: Str) {
                            // REM: Field offset not found, has_saved_return_offset stays false
                        }
                    }
                }
            }
        }
    }

    // Save enum value if returning an enum variable (not constructor)
    mut saved_enum_value := EnumVal()
    mut has_saved_enum_value := false
    if func_def.return_types.len().eq(1) {
        mut ret_return_type := ValueType.TCustom("")
        func_def.return_types.get(0, ret_return_type)?
        mut ret_is_tcustom := false
        mut ret_custom_type_name := ""
        switch ret_return_type {
        case ValueType.TCustom(custom_name):
            ret_is_tcustom = true
            ret_custom_type_name = custom_name
        case:
        }
        if ret_is_tcustom {
            mut ret_custom_symbol := SymbolInfo()
            mut ret_custom_symbol_found := false
            ret_custom_symbol = context.scope_stack.lookup_symbol(ret_custom_type_name)?
            ret_custom_symbol_found = true
            catch (err: KeyNotFoundError) { }
            if ret_custom_symbol_found {
                mut ret_is_enum_def := false
                switch ret_custom_symbol.value_type {
                case ValueType.TType(ttype_val3):
                    switch ttype_val3 {
                    case TTypeDef.TEnumDef:
                        ret_is_enum_def = true
                    case:
                    }
                case:
                }
                if ret_is_enum_def {
                    if not(result_str.contains(".")) {
                        // This is a variable, not a constructor - save the enum value
                        saved_enum_value = EvalArena.get_enum(context, result_str, e)?
                        has_saved_enum_value = true
                        // May fail if not actually an enum - that's okay, has_saved_enum_value stays false
                        catch (err: Str) { }
                    }
                }
            }
        }
    }

    // Collect mut_args values BEFORE popping the function frame
    // (we need to read from the function frame where the args live)
    // NOTE: MutArgValueType, MutArgValue, CollectedMutArg structs defined earlier
    mut collected_mut_args := Vec.new(CollectedMutArg)

    for mi in 0..mut_args.len() {
        mut m := MutArgEntry()
        mut_args.get(mi, m)?
        // Check if this arg was passed by ref
        mut was_passed_by_ref := false
        for ref_check_i in 0..pass_by_ref_params.len() {
            mut ref_param := ""
            pass_by_ref_params.get(ref_check_i, ref_param)?
            if ref_param.eq(m.arg_name) {
                was_passed_by_ref = true
            }
        }

        mut mut_arg_is_tcustom := false
        mut mut_arg_type_name := ""
        switch m.value_type {
        case ValueType.TCustom(custom_name):
            mut_arg_is_tcustom = true
            mut_arg_type_name = custom_name
        case:
        }

        if mut_arg_is_tcustom {
            switch mut_arg_type_name {
            case "I64":
                mut_arg_i64_val := EvalArena.get_i64(context, m.arg_name, e)?
                collected_mut_args.push(CollectedMutArg(source_name=m.source_name.clone(), value=MutArgValue.I64(mut_arg_i64_val)))
            case "U8":
                mut_arg_u8_val : U8 = EvalArena.get_u8(context, m.arg_name, e)?
                collected_mut_args.push(CollectedMutArg(source_name=m.source_name.clone(), value=MutArgValue.U8(mut_arg_u8_val)))
            case "Str":
                mut_arg_val := string_from_context(context, m.arg_name, e)?
                collected_mut_args.push(CollectedMutArg(source_name=m.source_name.clone(), value=MutArgValue.Str(mut_arg_val)))
            case:
                // Custom type (enum or struct)
                mut mut_arg_symbol_info := SymbolInfo()
                mut mut_arg_symbol_info_found := false
                mut_arg_symbol_info = context.scope_stack.lookup_symbol(mut_arg_type_name)?
                mut_arg_symbol_info_found = true
                catch (err: KeyNotFoundError) { }
                if not(mut_arg_symbol_info_found) {
                    _ := context.scope_stack.pop()?
                    context.path = saved_path
                    throw e.lang_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", mut_arg_type_name, "' as an mut argument. Undefined symbol."))
                }
                mut mut_arg_is_enum_def := false
                mut mut_arg_is_struct_def := false
                switch mut_arg_symbol_info.value_type {
                case ValueType.TType(ttype_val4):
                    switch ttype_val4 {
                    case TTypeDef.TEnumDef:
                        mut_arg_is_enum_def = true
                    case TTypeDef.TStructDef:
                        mut_arg_is_struct_def = true
                    }
                case:
                }
                if mut_arg_is_enum_def {
                    mut_arg_enum_val := EvalArena.get_enum(context, m.arg_name, e)?
                    collected_mut_args.push(CollectedMutArg(source_name=m.source_name.clone(), value=MutArgValue.Enum(mut_arg_enum_val)))
                } else if mut_arg_is_struct_def {
                    mut mut_arg_offset := 0
                    mut mut_arg_offset_found := false
                    mut_arg_offset = context.scope_stack.lookup_var(m.arg_name)?
                    mut_arg_offset_found = true
                    catch (err: KeyNotFoundError) { }
                    if mut_arg_offset_found {
                        collected_mut_args.push(CollectedMutArg(source_name=m.source_name.clone(), value=MutArgValue.Struct(MutArgStructData(offset=mut_arg_offset, type_name=mut_arg_type_name.clone(), was_passed_by_ref=was_passed_by_ref))))
                    } else {
                        _ := context.scope_stack.pop()?
                        context.path = saved_path
                        throw e.lang_error(context.path, "eval", format("Missing struct arena index for argument '", m.arg_name, "'"))
                    }
                } else {
                    _ := context.scope_stack.pop()?
                    context.path = saved_path
                    throw e.lang_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", mut_arg_type_name, "' as a mut argument. Not an enum or struct, but a '", value_type_to_str(mut_arg_symbol_info.value_type), "'."))
                }
            }
        } else {
            _ := context.scope_stack.pop()?
            context.path = saved_path
            throw e.todo_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", value_type_to_str(m.value_type), "' as a mut argument. Only structs and enums allowed for now."))
        }
    }

    // Pop function frame BEFORE writing mut args back to caller
    _ := context.scope_stack.pop()?
    context.path = saved_path.clone()

    // Write collected mut_args values to caller's frame (now on top)
    for ci in 0..collected_mut_args.len() {
        mut c := CollectedMutArg()
        collected_mut_args.get(ci, c)?
        switch c.value {
        case MutArgValue.I64(val):
            EvalArena.insert_i64(context, c.source_name, I64.to_str(val), e)?
        case MutArgValue.U8(val):
            EvalArena.insert_u8(context, c.source_name, U8.to_str(val), e)?
        case MutArgValue.Str(val):
            EvalArena.insert_string(context, c.source_name, val, e)?
        case MutArgValue.Enum(writeback_enum_val):
            // Bug #38 fix: Set temp_enum_payload so insert_enum preserves the payload
            if not(NULL.eq(writeback_enum_val.payload.data)).and(not(NULL.eq(writeback_enum_val.payload_type.data))) {
                // Read payload Vec and ValueType from the pointers
                mut writeback_payload_vec := Vec.new(U8)
                memcpy(to_ptr(writeback_payload_vec), writeback_enum_val.payload.data, size_of(Vec))
                mut writeback_payload_type := ValueType.TCustom("")
                memcpy(to_ptr(writeback_payload_type), writeback_enum_val.payload_type.data, size_of(ValueType))
                // Create EnumPayload and set temp_enum_payload
                mut writeback_temp_payload := EnumPayload(data=writeback_payload_vec.clone(), value_type=writeback_payload_type)
                writeback_heap_payload_ptr := malloc(size_of(EnumPayload))?
                memcpy(writeback_heap_payload_ptr, to_ptr(writeback_temp_payload), size_of(EnumPayload))
                context.temp_enum_payload.data = writeback_heap_payload_ptr
            }
            _ := EvalArena.insert_enum(context, c.source_name, writeback_enum_val.enum_type, format(writeback_enum_val.enum_type, ".", writeback_enum_val.enum_name), e)?
        case MutArgValue.Struct(struct_data):
            mut lf12_idx := context.scope_stack.frames.len().sub(1)
            mut lf12 := ScopeFrame()
            context.scope_stack.frames.get(lf12_idx, lf12)?
            lf12.arena_index.set(c.source_name.clone(), struct_data.offset)
            context.scope_stack.frames.set(lf12_idx, lf12)?
            // Bug #160: map_instance_fields removed - type checker handles symbol registration
        }
    }

    // If function returns a user-defined struct or enum, copy it back to caller frame as temp return val
    // NOTE: Frame already popped above, using saved_return_offset and saved_enum_value
    if func_def.return_types.len().eq(1) {
        mut copy_ret_return_type := ValueType.TCustom("")
        func_def.return_types.get(0, copy_ret_return_type)?
        mut copy_ret_is_tcustom := false
        mut copy_ret_custom_type_name := ""
        switch copy_ret_return_type {
        case ValueType.TCustom(custom_name):
            copy_ret_is_tcustom = true
            copy_ret_custom_type_name = custom_name
        case:
        }
        if copy_ret_is_tcustom {
            // Skip primitive types I64, U8, Str - they return values directly
            switch copy_ret_custom_type_name {
            case "I64":
            case "U8":
            case "Str":
                // Do nothing for primitive types
            case:
                mut copy_ret_custom_symbol := SymbolInfo()
                mut copy_ret_custom_symbol_found := false
                copy_ret_custom_symbol = context.scope_stack.lookup_symbol(copy_ret_custom_type_name)?
                copy_ret_custom_symbol_found = true
                catch (err: KeyNotFoundError) { }
                if copy_ret_custom_symbol_found {
                    mut copy_ret_is_struct_def := false
                    mut copy_ret_is_enum_def := false
                    switch copy_ret_custom_symbol.value_type {
                    case ValueType.TType(ttype_val5):
                        switch ttype_val5 {
                        case TTypeDef.TStructDef:
                            copy_ret_is_struct_def = true
                        case TTypeDef.TEnumDef:
                            copy_ret_is_enum_def = true
                        }
                    case:
                    }
                    if copy_ret_is_struct_def {
                        return_instance := format(RETURN_INSTANCE_NAME, I64.to_str(g_arena.temp_id_counter))
                        g_arena.temp_id_counter = g_arena.temp_id_counter.add(1)

                        // Use saved offset (saved before popping)
                        if not(has_saved_return_offset) {
                            throw e.lang_error(context.path, "eval", format("Missing arena index for return value '", result_str, "'"))
                        }
                        copy_ret_offset := saved_return_offset

                        // Insert the temporary return variable into the caller's frame
                        context.scope_stack.declare_symbol(return_instance.clone(), SymbolInfo(value_type=ValueType.TCustom(copy_ret_custom_type_name.clone()), is_mut=true))?

                        // Share the base offset in caller's frame
                        mut lf13_idx := context.scope_stack.frames.len().sub(1)
                        mut lf13 := ScopeFrame()
                        context.scope_stack.frames.get(lf13_idx, lf13)?
                        lf13.arena_index.set(return_instance.clone(), copy_ret_offset)
                        context.scope_stack.frames.set(lf13_idx, lf13)?

                        return EvalResult.new_return(return_instance) // CLEANUP SITE 4: Return struct instance
                    } else if copy_ret_is_enum_def {
                        // For enum returns, check if result_str is a constructor expression or a variable
                        if result_str.contains(".") {
                            // This is a constructor expression - just return as-is
                            return EvalResult.new(result_str) // CLEANUP SITE 5: Return enum constructor
                        }

                        // This is a variable, use saved enum value
                        if not(has_saved_enum_value) {
                            throw e.lang_error(context.path, "eval", format("Missing enum value for return value '", result_str, "'"))
                        }

                        enum_return_instance := format(RETURN_INSTANCE_NAME, I64.to_str(g_arena.temp_id_counter))
                        g_arena.temp_id_counter = g_arena.temp_id_counter.add(1)

                        // Set temp_enum_payload if the enum has a payload
                        if not(NULL.eq(saved_enum_value.payload.data)) {
                            mut copy_ret_payload_vec := Vec.new(U8)
                            memcpy(to_ptr(copy_ret_payload_vec), saved_enum_value.payload.data, size_of(Vec))
                            if not(NULL.eq(saved_enum_value.payload_type.data)) {
                                mut copy_ret_payload_type := ValueType.TCustom("")
                                memcpy(to_ptr(copy_ret_payload_type), saved_enum_value.payload_type.data, size_of(ValueType))
                                // Bug #74 fix: Heap-allocate EnumPayload to avoid use-after-free
                                mut copy_ret_temp_payload := EnumPayload(data=copy_ret_payload_vec.clone(), value_type=copy_ret_payload_type)
                                copy_ret_heap_payload_ptr := malloc(size_of(EnumPayload))?
                                memcpy(copy_ret_heap_payload_ptr, to_ptr(copy_ret_temp_payload), size_of(EnumPayload))
                                context.temp_enum_payload.data = copy_ret_heap_payload_ptr
                            }
                        }

                        _ := EvalArena.insert_enum(context, enum_return_instance, saved_enum_value.enum_type, format(saved_enum_value.enum_type, ".", saved_enum_value.enum_name), e)?
                        return EvalResult.new_return(enum_return_instance) // CLEANUP SITE 6: Return enum variable
                    }
                }
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Frame already popped above
    catch (err: BadAlloc) { panic(loc(), "eval_user_func_proc_call: buy more ram") }
    mut final_result := EvalResult.new(result_str)
    final_result.arena_offset = result_arena_offset
    return final_result // CLEANUP SITE 7: Return normal value (final return)
}

// ---------- Core function/procedure dispatcher

eval_core_func_proc_call := proc(name: Str, mut context: Context, e: Expr, is_proc: Bool) returns EvalResult throws Str {
    switch name {
    case "loc":
        return func_loc(context, e)?
    case "_file":
        return func_file(context, e)?
    case "_line":
        return func_line(context, e)?
    case "_col":
        return func_col(context, e)?
    case "size_of":
        return func_size_of(context, e)?
    case "type_as_str":
        return func_type_as_str(context, e)?
    case "to_ptr":
        return func_to_ptr(context, e)?
    case "create_alias":
        return func_create_alias(context, e)?
    case "malloc":
        return func_malloc(context, e)?
    case "free":
        return func_free(context, e)?
    case "memset":
        return func_memset(context, e)?
    case "memcpy":
        return func_memcpy(context, e)?
    case "memcmp":
        return func_memcmp(context, e)?
    case "i64_lt":
        return func_lt(context, e)?
    case "i64_gt":
        return func_gt(context, e)?
    case "u8_lt":
        return func_u8_lt(context, e)?
    case "u8_gt":
        return func_u8_gt(context, e)?
    case "u8_xor":
        return func_u8_xor(context, e)?
    case "u8_and":
        return func_u8_and(context, e)?
    case "u8_or":
        return func_u8_or(context, e)?
    case "i64_add":
        return func_add(context, e)?
    case "i64_sub":
        return func_sub(context, e)?
    case "i64_mul":
        return func_mul(context, e)?
    case "i64_div":
        return func_div(context, e)?
    case "i64_mod":
        return func_mod(context, e)?
    case "i64_and":
        return func_i64_and(context, e)?
    case "i64_or":
        return func_i64_or(context, e)?
    case "i64_xor":
        return func_i64_xor(context, e)?
    case "str_to_i64":
        return func_str_to_i64(context, e)?
    case "i64_to_str":
        return func_i64_to_str(context, e)?
    case "enum_to_str":
        return func_enum_to_str(context, e)?
    case "enum_get_payload":
        return func_enum_get_payload(context, e)?
    case "enum_get_payload_type":
        return func_enum_get_payload_type(context, e)?
    case "u8_to_i64":
        return func_u8_to_i64(context, e)?
    case "i64_to_u8":
        return func_i64_to_u8(context, e)?
    case "u8_add":
        return func_u8_add(context, e)?
    case "u8_div":
        return func_u8_div(context, e)?
    case "u8_mod":
        return func_u8_mod(context, e)?
    case "u8_mul":
        return func_u8_mul(context, e)?
    case "u8_sub":
        return func_u8_sub(context, e)?
    case "eval_to_str":
        return proc_eval_to_str(context, e)?
    case "exit":
        return func_exit(context, e)?
    case "import":
        return proc_import(context, e)?
    case "input_read_line":
        return proc_input_read_line(context, e)?
    case "single_print":
        return proc_single_print(context, e)?
    case "print_flush":
        return proc_print_flush(context, e)?
    case "readfile":
        return proc_readfile(context, e)?
    case "writefile":
        return proc_writefile(context, e)?
    case "run_cmd":
        return proc_run_cmd(context, e)?
    case "spawn_cmd":
        return proc_spawn_cmd(context, e)?
    case "check_cmd_status":
        return proc_check_cmd_status(context, e)?
    case "sleep":
        return proc_sleep(context, e)?
    case "get_thread_count":
        return proc_get_thread_count(context, e)?
    case "file_mtime":
        return func_file_mtime(context, e)?
    case "list_dir_raw":
        return func_list_dir_raw(context, e)?
    case "fs_parent_dir":
        return func_fs_parent_dir(context, e)?
    case "fs_mkdir_p":
        return proc_fs_mkdir_p(context, e)?
    case "eval_file":
        return proc_eval_file(context, e)?
    case "has_const":
        return func_has_const(context, e)?
    case "has_field":
        return func_has_field(context, e)?
    case:
        if is_proc {
            throw e.lang_error(context.path, "eval", format("Core procedure '", name, "' not implemented."))
        } else {
            throw e.lang_error(context.path, "eval", format("Core function '", name, "' not implemented."))
        }
    }
    catch (err: U8_Overflow) { throw err.msg }
    return EvalResult.new("")
}

// ---------- main_interpret, interpret_file_with_context, interpret_file (like rstil.rs)

/// Main run function - lexes, parses, inits, typechecks, and evaluates source code
/// Follows rstil.rs main_interpret implementation
main_interpret := proc(skip_init_and_typecheck: Bool, mut context: Context, path: Str, source: Str, main_args: Vec) returns EvalResult throws Str {
    // Mark main file as "done" to prevent re-processing via circular imports
    _ := context.imports_init_done.insert(path.clone())
    _ := context.imports_typer_done.insert(path.clone())
    _ := context.imports_precomp_done.insert(path.clone())
    _ := context.imports_eval_done.insert(path.clone())

    // Lex source
    mut lexer := lexer_from_source(path, source)?
    catch (err: Str) {
        throw format(path, ":", err)
    }
    catch (err: IndexOutOfBoundsError) {
        throw format(path, ":", err.msg)
    }

    // Parse mode
    mut parsed_mode := parse_mode(path, lexer)?
    catch (err: Str) {
        throw format(path, ":", err)
    }
    context.mode_def = parsed_mode

    // Process mode imports (e.g., test mode auto-imports test helpers)
    for import_str: Str in context.mode_def.imports {
        // Create synthetic import expression
        import_func_name_expr := Expr(node_type=NodeType.Identifier("import"), line=0, col=0)
        import_path_expr := Expr(node_type=NodeType.LLiteral(Literal.Str(import_str)), line=0, col=0)
        mut import_fcall_expr := Expr(node_type=NodeType.FCall(false), line=0, col=0)
        import_fcall_expr.params.push(import_func_name_expr)
        import_fcall_expr.params.push(import_path_expr)

        // Mode imports need full processing: init, typer, eval
        init_import_declarations(context, import_fcall_expr, import_str)?
        catch (err: Str) {
            throw format(path, ":", err)
        }

        typer_errors := typer_import_declarations(context, import_str)
        if typer_errors.len().gt(0) {
            for err_msg: Str in typer_errors {
                println(err_msg)
            }
            throw format("Compiler errors: ", typer_errors.len().to_str(), " type errors found")
        }

        // Eval the import
        _ := proc_import(context, import_fcall_expr)?
        catch (err: Str) {
            throw format(path, ":", err)
        }
    }

    // Parse the body
    mut e := parse_tokens(lexer)?
    catch (err: Str) {
        throw format(path, ":", err)
    }
    catch (err: IndexOutOfBoundsError) {
        throw format(path, ":", err.msg)
    }

    // Preinit phase: auto-generate delete/clone methods
    e = preinit_expr(e)

    // Skip init and type checking if this is Phase 2 of a two-phase import
    if not(skip_init_and_typecheck) {
        mut errors := init_context(context, e)?
        catch (err: Str) {
            throw format(path, ":", err)
        }

        if errors.len().gt(0) {
            for err_msg: Str in errors {
                println(err_msg)
            }
            throw format("Compiler errors: ", errors.len().to_str(), " declaration errors found")
        }

        mode_errors := basic_mode_checks(context, e)?
        catch (err: Str) {
            throw format(path, ":", err)
        }
        for mode_err: Str in mode_errors {
            errors.push(mode_err)
        }

        // For modes that require a main proc, add an implicit call to main
        if context.mode_def.needs_main_proc {
            main_ident_expr := Expr(node_type=NodeType.Identifier("main"), line=0, col=0)
            mut main_call_expr := Expr(node_type=NodeType.FCall(false), line=0, col=0)
            main_call_expr.params.push(main_ident_expr)

            // Add string args
            for arg_str: Str in main_args {
                arg_expr := Expr(node_type=NodeType.LLiteral(Literal.Str(arg_str)), line=0, col=0)
                main_call_expr.params.push(arg_expr)
            }

            e.params.push(main_call_expr)
        }

        // Bug #128: Unified type checking - runs check_types and resolves INFER_TYPE in one call
        type_result := type_check(context, e)?
        catch (err: Str) {
            throw format(path, ":", err)
        }
        for type_err: Str in type_result.errors {
            errors.push(type_err)
        }

        // TODO: check_body_returns_throws for root body - needs SFuncDef and ThrownType
        // For now, skip this check (can be added post-self-hosting)

        if errors.len().gt(0) {
            for err_msg: Str in errors {
                println(err_msg)
            }
            throw format("Compiler errors: ", errors.len().to_str(), " type errors found")
        }

        e = type_result.resolved_ast

        // Desugarer phase: Transform ForIn to while loops
        e = desugar_expr(context, e)?

        // Garbager phase: Auto-generate delete() methods for structs
        e = garbager_expr(context, e)?

        // UFCS phase: Transform UFCS calls into regular function calls
        e = ufcs_expr(context, e)?

        // Precomputation phase: Compile-time constant folding
        e = precomp_expr(context, e)?
    }

    // Evaluate the expression
    eval_result := eval_expr(context, e)?
    if eval_result.is_throw {
        throw format(path, ":", eval_result.value)
    }
    return eval_result
}

/// Run a file with an existing context (for imports)
/// Follows rstil.rs interpret_file_with_context implementation
interpret_file_with_context := proc(is_import: Bool, skip_init: Bool, mut context: Context, path: Str, main_args: Vec) returns EvalResult throws Str {
    mut previous_mode := context.mode_def

    source := readfile(path)?
    catch (err: ReadError) {
        throw format("Failed to read file '", path, "': ", err.msg)
    }

    run_result := main_interpret(skip_init, context, path, source, main_args)?

    if is_import {
        if not(can_be_imported(context.mode_def)) {
            throw format("file '", path, "' of mode '", context.mode_def.name, "' cannot be imported")
        }
    }

    context.mode_def = previous_mode  // restore the context mode of the calling file
    return run_result
}

/// Run a file from scratch (creates new context, imports core.til first)
/// Follows rstil.rs interpret_file implementation
interpret_file := proc(path: Str, main_args: Vec) returns EvalResult throws Str {
    mut context := Context.new(path, "lib")?  // default mode, will be overwritten by file's mode
    // Context.new throws Str on error

    if not(path.eq("src/core/core.til")) {
        // Automatically import core.til (needs full init and eval, skip_init=false)
        core_path := "src/core/core.til"
        mut empty_args := Vec.new(Str)
        _ := interpret_file_with_context(true, false, context, core_path, empty_args)?
    }

    return interpret_file_with_context(false, false, context, path, main_args)?
}

// ---------- proc_eval_to_str, proc_eval_file, proc_import (moved from ext.til)

proc_eval_to_str := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "eval_to_str", 1, true)?

    path := "eval"  // Placeholder path
    source_expr := eval_expr(context, e.get(1)?)?
    if source_expr.is_throw { return source_expr }

    str_source := format("mode script; ", source_expr.value)
    return main_interpret(false, context, path, str_source, Vec.new(Str))?
}

proc_eval_file := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    if e.params.len().lt(2) {
        throw e.lang_error(context.path, "eval", "Core proc 'eval_file' expects at least 1 parameter")
    }

    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    path := result.value

    mut main_args := Vec.new(Str)
    for i in 2..e.params.len() {
        arg_result := eval_expr(context, e.get(i)?)?
        if arg_result.is_throw { return arg_result }
        main_args.push(arg_result.value)
    }

    _ := interpret_file(path, main_args)?
    return EvalResult.new("")
}

// import_path_to_file_path is defined in init.til

proc_import := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "import", 1, true)?

    result := eval_expr(context, e.get(1)?)?
    if result.is_throw {
        return result // Propagate throw
    }

    original_path := context.path.clone()
    path := import_path_to_file_path(result.value)

    // Already done (or in progress)? Skip.
    // Adding to done at START handles both circular imports and re-imports.
    if context.imports_eval_done.contains(path) {
        return EvalResult.new("")
    }

    // Mark as done immediately - before processing - to handle circular imports
    _ := context.imports_eval_done.insert(path.clone())

    // Get stored AST from init phase
    mut ast := Expr()
    if not(context.imported_asts.contains_key(path)) {
        throw e.error(context.path, "eval", format(
            "Import ", path, " not found in stored ASTs - init phase should have stored it"))
    }
    context.imported_asts.get(path, ast)?
    catch (err: KeyNotFoundError) {
        throw e.error(context.path, "eval", format(
            "Import ", path, " not found in stored ASTs - init phase should have stored it"))
    }

    context.path = path.clone()

    // Run desugar + garbager + ufcs + precomp on the imported AST if not already done
    if not(context.imports_precomp_done.contains(path)) {
        _ := context.imports_precomp_done.insert(path.clone())
        ast = desugar_expr(context, ast)?
        ast = garbager_expr(context, ast)?
        ast = ufcs_expr(context, ast)?
        ast = precomp_expr(context, ast)?
    }

    // Eval the precomp'd AST
    eval_result := eval_expr(context, ast)?

    context.path = original_path

    if eval_result.is_throw {
        throw e.error(context.path, "eval", format(
            "While importing ", path, ":\n", eval_result.value))
    }
    return EvalResult.new("")
}
