mode lib

import("self.init")
import("self.parser")
import("self.typer")
import("self.precomp")
import("self.ext")
import("self.arena")
import("self.mode")         // parse_mode, can_be_imported
import("self.lexer")        // lexer_from_source, parse_tokens
import("std.io")            // readfile

// Interpreter/Eval phase: Runtime evaluation and execution
// This module handles the eval phase that runs after type checking.
// Manages arena, memory allocation, and actual program execution.

RETURN_INSTANCE_NAME := "___temp_return_val_"

/// Convert I64 to little-endian bytes (Vec<U8>)
i64_to_le_bytes := func(val: I64) returns Vec throws AllocError {
    mut bytes := Vec.new(U8)
    // Extract 8 bytes in little-endian order using bit shifts
    mut i := 0
    while i.lt(8) {
        mut byte_val : U8 = 0
        memcpy(to_ptr(byte_val), add(to_ptr(val), i), 1)
        bytes.push(byte_val)
        i = i.add(1)
    }
    return bytes
}

/// Copy bytes from arena memory into a Vec<U8>
arena_memory_slice := func(arena: Arena, offset: I64, size: I64) returns Vec throws AllocError {
    mut bytes := Vec.new(U8)
    mut i := 0
    while i.lt(size) {
        bytes.push(0)
        i = i.add(1)
    }
    memcpy(bytes.ptr, add(arena.memory.ptr, offset), size)
    return bytes
}

/// Saved offsets for struct copy when source and dest have the same name
SavedOffsets := struct {
    mut offsets: Vec = Vec.new(ArenaMapping)
    mut temp_src_key: Str = ""
}

EvalResult := struct {
    mut value: Str = ""
    mut is_return: Bool = false
    mut is_throw: Bool = false
    mut thrown_type: Str = ""  // Empty string = None

    new := func(value: Str) returns EvalResult {
        mut r := EvalResult()
        r.value = value
        r.is_return = false
        r.is_throw = false
        r.thrown_type = ""
        return r
    }

    new_return := func(value: Str) returns EvalResult {
        mut r := EvalResult()
        r.value = value
        r.is_return = true
        r.is_throw = false
        r.thrown_type = ""
        return r
    }

    new_throw := func(value: Str, thrown_type: ValueType) returns EvalResult throws Str {
        mut r := EvalResult()
        r.value = value
        r.is_return = false
        r.is_throw = true
        r.thrown_type = value_type_to_str(thrown_type)
        return r
    }
}

// string_from_context is in til
// validate_conditional_params is in typer.til

// Helper to evaluate boolean conditions for if/while statements.
eval_condition_to_bool := proc(context: Context, result: EvalResult, expr: Expr) returns Bool throws Str {
    // Handle "true" and "false" directly (builtins return these, and they're the constant names)
    if result.value.eq("true") {
        return true
    }
    if result.value.eq("false") {
        return false
    }

    // Otherwise it's a Bool struct identifier - read its .data field
    bool_id := result.value
    data_field_id := format(bool_id, ".data")
    u8_val := Arena.get_u8(context, data_field_id, expr)
    u8_zero := U8.from_i64(0)
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: U8_OverflowError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return not(u8_val.eq(u8_zero))
}

// validate_func_arg_count is in typer.til

/// Pre-evaluate all default values for a struct type, including nested structs.
/// Returns a map from field name (with dotted paths for nested) to evaluated string value.
eval_struct_defaults := proc(mut ctx: Context, struct_type: Str, e: Expr) returns Map throws Str {
    mut struct_def := ctx.scope_stack.lookup_struct(struct_type)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(ctx.path, "eval_struct_defaults", format("struct '", struct_type, "' not found"))
    }

    mut defaults := Map.new(Str, Str)
    mut i := 0
    while i.lt(struct_def.members.len()) {
        mut decl := Declaration()
        struct_def.members.get(i, decl)
        if decl.is_mut {
            // Check if default_values has this field
            if struct_def.default_values.contains_key(decl.name) {
                mut default_expr := Expr()
                struct_def.default_values.get(decl.name, default_expr)

                // For nested struct types, eagerly create template BEFORE evaluating default
                // This handles forward references: Inner1's template is created before Inner1() is evaluated
                mut type_name := ""
                mut is_custom := false
                switch decl.value_type {
                case ValueType.TCustom(tn):
                    type_name = tn
                    is_custom = true
                case:
                    // Not a custom type
                }
                if is_custom {
                    // Skip primitives, enums, and Str (handled specially)
                    if not(type_name.eq("U8")).and(not(type_name.eq("I64"))).and(not(type_name.eq("Str"))) {
                        mut is_enum := false
                        mut dummy_enum := ctx.scope_stack.lookup_enum(type_name)
                        is_enum = true
                        catch (err: KeyNotFoundError) {
                            is_enum = false
                        }
                        if not(is_enum) {
                            mut dummy_struct := ctx.scope_stack.lookup_struct(type_name)
                            // Eagerly create template for nested struct (handles forward refs)
                            mut _ := create_default_instance(ctx, type_name, e)
                            catch (err: KeyNotFoundError) {
                                // struct not found, skip
                            }
                        }
                    }
                }

                // Now evaluate the default expression (template exists if needed)
                res := eval_expr(ctx, default_expr)
                if res.is_throw {
                    mut thrown_str := res.thrown_type
                    if thrown_str.eq("") {
                        thrown_str = "unknown"
                    }
                    throw e.lang_error(ctx.path, "eval_struct_defaults", format("thrown '", thrown_str, "' while evaluating default for field '", decl.name, "'"))
                }
                defaults.insert(decl.name, res.value)

                // Handle nested structs recursively (get their defaults)
                if is_custom {
                    if not(type_name.eq("U8")).and(not(type_name.eq("I64"))).and(not(type_name.eq("Str"))) {
                        mut is_enum2 := false
                        mut dummy_enum2 := ctx.scope_stack.lookup_enum(type_name)
                        is_enum2 = true
                        catch (err: KeyNotFoundError) {
                            is_enum2 = false
                        }
                        if not(is_enum2) {
                            mut dummy_struct2 := ctx.scope_stack.lookup_struct(type_name)
                            mut nested := Map.new(Str, Str)
                            nested = eval_struct_defaults(ctx, type_name, e)
                            // Iterate nested map and insert with prefix
                            mut keys := nested.keys
                            mut j := 0
                            while j.lt(nested.len()) {
                                mut k := ""
                                keys.get(j, k)
                                mut v := ""
                                nested.get(k, v)
                                defaults.insert(format(decl.name, ".", k), v)
                                j = j.add(1)
                            }
                            catch (err: KeyNotFoundError) {
                                // struct not found, skip
                            }
                        }
                    }
                }
            }
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
    catch (err: DuplicatedKeyError) { throw err.msg }
    return defaults
}

/// Create a default instance template for a struct type.
/// Called eagerly when struct declarations are evaluated.
create_default_instance := proc(mut ctx: Context, struct_type: Str, e: Expr) returns I64 throws Str {
    // Check if template already exists (e.g., from a previous import)
    if arena.default_instances.contains_key(struct_type) {
        mut offset := 0
        arena.default_instances.get(struct_type, offset)
        catch (err: KeyNotFoundError) { throw err.msg }
        return offset
    }

    // Create template instance
    template_id := format("__default_", struct_type)

    // Declare temporary symbol for template (needed by insert_struct_core)
    mut sym_info := SymbolInfo()
    sym_info.value_type = ValueType.TCustom(struct_type)
    sym_info.is_mut = true
    sym_info.is_copy = false
    sym_info.is_own = false
    ctx.scope_stack.declare_symbol(template_id, sym_info)

    // Evaluate defaults and create template
    defaults := eval_struct_defaults(ctx, struct_type, e)
    result := Arena.insert_struct_core(ctx, template_id, struct_type, 0, defaults, e)

    // Get the template's arena offset (first mapping is the base struct)
    if result.arena_mappings.len().eq(0) {
        throw e.lang_error(ctx.path, "create_default_instance", "No arena mapping for template")
    }
    mut first_mapping := ArenaMapping()
    result.arena_mappings.get(0, first_mapping)
    template_offset := first_mapping.offset
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Cache the template offset
    arena.default_instances.insert(struct_type, template_offset)
    catch (err: DuplicatedKeyError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    return template_offset
}

/// Insert a struct instance using cached template.
/// Template is guaranteed to exist - created eagerly on eval_declaration.
insert_struct_instance := proc(mut ctx: Context, id: Str, type_name: Str, e: Expr) throws Str {
    if not(arena.default_instances.contains_key(type_name)) {
        throw e.lang_error(ctx.path, "insert_struct_instance", format("template for '", type_name, "' not found"))
    }
    mut template_offset := 0
    arena.default_instances.get(type_name, template_offset)
    catch (err: KeyNotFoundError) { throw err.msg }
    Arena.insert_struct(ctx, id, type_name, template_offset, e)
}

/// Insert a struct instance into a specific frame using cached template.
/// Template is guaranteed to exist - created eagerly on eval_declaration.
insert_struct_instance_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, type_name: Str, e: Expr) throws Str {
    if not(arena.default_instances.contains_key(type_name)) {
        throw e.lang_error(ctx.path, "insert_struct_instance_into_frame", format("template for '", type_name, "' not found"))
    }
    mut template_offset := 0
    arena.default_instances.get(type_name, template_offset)
    catch (err: KeyNotFoundError) { throw err.msg }
    Arena.insert_struct_into_frame(ctx, frame, id, type_name, template_offset, e)
}

eval_expr := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    switch e.node_type {
    case NodeType.Body:
        return eval_body(context, e.params)
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(li64):
            return EvalResult.new(li64)
        case Literal.Str(lstring):
            return EvalResult.new(lstring)
        case Literal.List(llist):
            return EvalResult.new(llist)
        }
    case NodeType.FCall:
        f_name := get_func_name_in_call(e)
        return eval_func_proc_call(f_name, context, e)
    case NodeType.Declaration(declaration):
        return eval_declaration(declaration, context, e)
    case NodeType.Assignment(var_name):
        return eval_assignment(var_name, context, e)
    case NodeType.Identifier(name):
        return eval_identifier_expr(name, context, e)
    case NodeType.If:
        _ := validate_conditional_params(context.path, e, "if", 2, 3)
        mut cond_expr := Expr()
        e.params.get(0, cond_expr)
        mut result_cond := eval_expr(context, cond_expr)
        if result_cond.is_throw {
            return result_cond
        }
        if eval_condition_to_bool(context, result_cond, cond_expr) {
            return eval_expr(context, e.get(1))
        } else if e.params.len().eq(3) {
            return eval_expr(context, e.get(2))
        } else {
            return EvalResult.new("")
        }
    case NodeType.While:
        _ := validate_conditional_params(context.path, e, "while", 2, 2)
        mut cond_expr := Expr()
        e.params.get(0, cond_expr)
        mut result_cond := eval_expr(context, cond_expr)
        if result_cond.is_throw {
            return result_cond
        }
        while eval_condition_to_bool(context, result_cond, cond_expr) {
            result := eval_expr(context, e.get(1))
            if result.is_return.or(result.is_throw) {
                return result
            }
            cond_expr = e.get(0)
            result_cond = eval_expr(context, cond_expr)
            if result_cond.is_throw {
                return result_cond
            }
        }
        return EvalResult.new("")
    case NodeType.Switch:
        if e.params.len().lt(3) {
            throw e.lang_error(context.path, "eval", "switch nodes must have at least 3 parameters.")
        }
        to_switch := e.get(0)
        value_type := get_value_type(context, to_switch)
        result_to_switch := eval_expr(context, to_switch)
        if result_to_switch.is_throw {
            return result_to_switch
        }

        mut param_it := 1
        while param_it.lt(e.params.len()) {
            case_expr := e.get(param_it)
            // Check if DefaultCase
            mut is_default := false
            switch case_expr.node_type {
            case NodeType.DefaultCase:
                is_default = true
            case:
                // not default
            }
            if is_default {
                param_it = param_it.add(1)
                return eval_expr(context, e.get(param_it))
            }

            case_type := get_value_type(context, case_expr)
            vt_str := value_type_to_str(value_type)
            ct_str := value_type_to_str(case_type)
            if not(ct_str.eq(vt_str)).and(not(ct_str.eq(format(vt_str, "Range")))) {
                throw e.lang_error(context.path, "eval", format("switch value type ", vt_str, ", case value type ", ct_str))
            }

            // Handle pattern matching with payload extraction
            mut is_pattern := false
            mut pattern_variant := ""
            mut pattern_binding := ""
            switch case_expr.node_type {
            case NodeType.Pattern(pinfo):
                is_pattern = true
                pattern_variant = pinfo.variant_name
                pattern_binding = pinfo.binding_var
            case:
                // not a pattern
            }

            if is_pattern {
                // Get enum variable name from to_switch
                // For field access (e.g., s.color), construct the full path
                mut enum_var_name := ""
                switch to_switch.node_type {
                case NodeType.Identifier(name):
                    // Check if this is a field access (has params that are identifiers)
                    if to_switch.params.len().gt(0) {
                        enum_var_name = name
                        mut i := 0
                        while i.lt(to_switch.params.len()) {
                            mut param := Expr()
                            to_switch.params.get(i, param)
                            switch param.node_type {
                            case NodeType.Identifier(field_name):
                                enum_var_name = format(enum_var_name, ".", field_name)
                            case:
                                // not an identifier field access
                            }
                            i = i.add(1)
                        }
                    } else {
                        enum_var_name = name
                    }
                case:
                    throw case_expr.error(context.path, "eval", "Pattern matching requires switch value to be a variable")
                }

                enum_val := Arena.get_enum(context, enum_var_name, case_expr)
                full_variant := format(enum_val.enum_type, ".", enum_val.enum_name)

                // Check if variant matches
                if full_variant.eq(pattern_variant).or(enum_val.enum_name.eq(pattern_variant)) {
                    // Match! Extract the payload and bind it to the variable
                    param_it = param_it.add(1)

                    // Extract payload into the binding variable if present
                    if not(NULL.eq(enum_val.payload_type.data)) {
                        // TODO: Full payload extraction - simplified for now
                        // The Rust version handles I64, Str, struct, and enum payloads
                        // This is complex byte manipulation that needs Arena support
                        mut sym_info := SymbolInfo()
                        sym_info.value_type = ValueType.TCustom("I64")
                        sym_info.is_mut = false
                        sym_info.is_copy = false
                        sym_info.is_own = false
                        context.scope_stack.declare_symbol(pattern_binding, sym_info)
                        // TODO: Arena.insert_* based on payload type
                    }

                    // Execute the case body with the bound variable available
                    return eval_expr(context, e.get(param_it))
                } else {
                    // No match, continue to next case
                    param_it = param_it.add(2)
                }
            } else {
                // Not a pattern - check Range or direct match
                mut is_range := false
                switch case_expr.node_type {
                case NodeType.Range:
                    is_range = true
                case:
                    // not range
                }

                mut is_match := false
                if is_range {
                    mut start_expr := Expr()
                    case_expr.params.get(0, start_expr)
                    start := eval_expr(context, start_expr)
                    if start.is_throw {
                        return start
                    }
                    mut end_expr := Expr()
                    case_expr.params.get(1, end_expr)
                    end := eval_expr(context, end_expr)
                    if end.is_throw {
                        return end
                    }

                    // Check if numeric type
                    mut is_numeric := false
                    switch value_type {
                    case ValueType.TCustom(s):
                        if s.eq("I64").or(s.eq("U8")) {
                            is_numeric = true
                        }
                    case:
                        // not custom
                    }

                    if is_numeric {
                        val := I64.from_str(result_to_switch.value)
                        start_val := I64.from_str(start.value)
                        end_val := I64.from_str(end.value)
                        is_match = val.gteq(start_val).and(val.lteq(end_val))
                    } else {
                        // String ranges not supported in self-hosted interpreter
                        throw e.lang_error(context.path, "eval", "String range comparisons not yet supported")
                    }
                } else {
                    result_case := eval_expr(context, case_expr)
                    if result_case.is_throw {
                        return result_case
                    }
                    is_match = result_to_switch.value.eq(result_case.value)
                }

                param_it = param_it.add(1)
                if is_match {
                    return eval_expr(context, e.get(param_it))
                }
                param_it = param_it.add(1)
            }
        }
        return EvalResult.new("")
    case NodeType.Return:
        if e.params.len().eq(0) {
            return EvalResult.new_return("")
        } else if e.params.len().gt(1) {
            throw e.lang_error(context.path, "eval", "multiple return values not implemented yet")
        } else {
            result := eval_expr(context, e.get(0))
            if result.is_throw {
                return result
            }
            return EvalResult.new_return(result.value)
        }
    case NodeType.Throw:
        if not(e.params.len().eq(1)) {
            throw e.lang_error(context.path, "eval", "Throw can only return one value. This should have been caught before")
        } else {
            param_expr := e.get(0)
            result := eval_expr(context, param_expr)
            if result.is_throw {
                return result
            }
            thrown_type := get_value_type(context, param_expr)
            return EvalResult.new_throw(result.value, thrown_type)
        }
    case NodeType.Catch:
        throw e.lang_error(context.path, "eval", "Catch statements should always be evaluated within bodies.")
    case:
        throw e.lang_error(context.path, "eval", format("Not implemented yet, found node type ", enum_to_str(e.node_type), "."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return EvalResult.new("")
}

eval_func_proc_call := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    mut is_fcall := false
    switch e.node_type {
    case NodeType.FCall:
        is_fcall = true
    case:
    }
    if not(is_fcall) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall node type")
    }

    if e.params.len().eq(0) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall with at least one param for the Identifier")
    }
    func_expr := e.get(0)

    // Check if this is a struct instantiation
    mut is_struct := false
    _ := context.scope_stack.lookup_struct(name)
    is_struct = true
    catch (err: KeyNotFoundError) {
        // is_struct stays false - struct not found
    }
    if is_struct {
        // TODO allow instantiations with arguments
        id_expr := e.get(0)
        if id_expr.params.len().eq(0) {
            mut id_name := ""
            switch id_expr.node_type {
            case NodeType.Identifier(s):
                id_name = s
            case:
                throw e.todo_error(context.path, "eval", "Expected identifier name for struct instantiation")
            }
            insert_struct_instance(context, id_name, name, e)
            mut result_val := id_name
            if id_name.eq("U8") {
                result_val = "0"
            } else if id_name.eq("I64") {
                result_val = "0"
            } else if id_name.eq("Str") {
                result_val = ""
            }
            return EvalResult.new(result_val)
        }
    }

    combined_name := get_combined_name(context.path, func_expr)

    // Check if this is an enum constructor call (e.g., Color.Green(true))
    parts := combined_name.split(".")
    if parts.len().eq(2) {
        mut enum_type := ""
        parts.get(0, enum_type)
        mut is_enum := false
        _ := context.scope_stack.lookup_enum(enum_type)
        is_enum = true
        catch (err: KeyNotFoundError) {
            // is_enum stays false - not an enum
        }
        if is_enum {
            // This is an enum constructor!
            mut variant_name := ""
            parts.get(1, variant_name)

            // Get the enum definition to check if this variant has a payload type
            enum_def := context.scope_stack.lookup_enum(enum_type)
            mut variant_type := ValueType.TCustom("")
            mut has_variant := false
            mut has_payload := false
            enum_def.enum_map.get(variant_name, variant_type)
            has_variant = true
            mut is_infer := false
            switch variant_type {
            case ValueType.TCustom(""):
                is_infer = true
            case:
            }
            if not(is_infer) {
                has_payload = true
            }
            catch (err: KeyNotFoundError) {
                // has_variant stays false - variant not found
            }

            if has_variant {
                if has_payload {
                    // This variant expects a payload
                    if e.params.len().lt(2) {
                        throw e.error(context.path, "eval", format("Enum constructor ", enum_type, ".", variant_name, " expects a payload of type ", value_type_to_str(variant_type)))
                    }

                    // Evaluate the payload argument
                    payload_expr := e.get(1)
                    payload_result := eval_expr(context, payload_expr)
                    if payload_result.is_throw {
                        return payload_result
                    }

                    // Convert payload to bytes based on type
                    mut payload_bytes := Vec.new(U8)
                    mut handled_payload := false

                    switch variant_type {
                    case ValueType.TCustom(type_name):
                        if type_name.eq("I64") {
                            i64_val := I64.from_str(payload_result.value)
                            payload_bytes = i64_to_le_bytes(i64_val)
                            handled_payload = true
                        } else {
                            // Handle struct payloads
                            struct_type_name := type_name
                            mut type_symbol := SymbolInfo()
                            type_symbol = context.scope_stack.lookup_symbol(struct_type_name)
                            catch (err: KeyNotFoundError) {
                                throw e.error(context.path, "eval", format("Unknown type '", struct_type_name, "'"))
                            }

                            switch type_symbol.value_type {
                            case ValueType.TType(TTypeDef.TStructDef):
                                // Get struct size
                                struct_size := context.get_type_size(struct_type_name)

                                // Get struct variable name from the original expression or create temporary for literals
                                mut struct_var_name := ""
                                mut struct_var_set := false
                                switch payload_expr.node_type {
                                case NodeType.Identifier(ident_name):
                                    if struct_type_name.eq("Str") {
                                        // For Str payloads with identifier expressions (like t.token_str),
                                        // create a temporary Str from the evaluated result value
                                        last_frame := context.scope_stack.last_frame()
                                        temp_var_name := format("__temp_str_", I64.to_str(last_frame.arena_index.len()))
                                        string_value := payload_result.value

                                        // Add symbol entry before calling insert_string
                                        context.scope_stack.declare_symbol(temp_var_name, SymbolInfo.new(ValueType.TCustom("Str"), false, false, false))

                                        Arena.insert_string(context, temp_var_name, string_value, e)
                                        struct_var_name = temp_var_name
                                        struct_var_set = true
                                    } else {
                                        struct_var_name = ident_name
                                        struct_var_set = true
                                    }
                                case NodeType.LLiteral(lit):
                                    switch lit {
                                    case Literal.Str(_):
                                        if struct_type_name.eq("Str") {
                                            // For string literals, create a temporary Str struct
                                            last_frame2 := context.scope_stack.last_frame()
                                            temp_var_name := format("__temp_str_", I64.to_str(last_frame2.arena_index.len()))
                                            string_value := payload_result.value

                                            // Add symbol entry before calling insert_string
                                            context.scope_stack.declare_symbol(temp_var_name, SymbolInfo.new(ValueType.TCustom("Str"), false, false, false))

                                            Arena.insert_string(context, temp_var_name, string_value, e)
                                            struct_var_name = temp_var_name
                                            struct_var_set = true
                                        }
                                    case Literal.Number(_):
                                        if struct_type_name.eq("I64") {
                                            // For I64 literals, create a temporary I64 struct
                                            last_frame3 := context.scope_stack.last_frame()
                                            temp_var_name := format("__temp_i64_", I64.to_str(last_frame3.arena_index.len()))
                                            i64_value := payload_result.value

                                            // Add symbol entry before calling insert_i64
                                            context.scope_stack.declare_symbol(temp_var_name, SymbolInfo.new(ValueType.TCustom("I64"), false, false, false))

                                            Arena.insert_i64(context, temp_var_name, i64_value, e)
                                            struct_var_name = temp_var_name
                                            struct_var_set = true
                                        }
                                    case:
                                    }
                                case:
                                }

                                if not(struct_var_set) {
                                    throw e.error(context.path, "eval", format("Struct payload must be a variable identifier or literal, got ", enum_to_str(payload_expr.node_type)))
                                }

                                // Get struct offset from arena
                                mut offset := 0
                                offset = context.scope_stack.lookup_var(struct_var_name)
                                catch (err: KeyNotFoundError) {
                                    throw e.error(context.path, "eval", format("Struct '", struct_var_name, "' not found in arena"))
                                }

                                // Copy struct bytes from arena
                                payload_bytes = arena_memory_slice(arena, offset, struct_size)
                                handled_payload = true

                            case ValueType.TType(TTypeDef.TEnumDef):
                                // Handle enum payloads
                                // Get enum variable name from the original expression
                                mut enum_var_name := ""
                                mut enum_var_set := false
                                switch payload_expr.node_type {
                                case NodeType.Identifier(ident_name):
                                    if payload_expr.params.len().eq(0) {
                                        enum_var_name = ident_name
                                        enum_var_set = true
                                    } else {
                                        // This is a nested enum constructor call (e.g., InnerEnum.ValueA(42))
                                        last_frame4 := context.scope_stack.last_frame()
                                        temp_var_name := format("__temp_enum_", I64.to_str(last_frame4.arena_index.len()))

                                        nested_result := eval_expr(context, payload_expr)
                                        if nested_result.is_throw {
                                            return nested_result
                                        }

                                        context.scope_stack.declare_symbol(temp_var_name, SymbolInfo.new(ValueType.TCustom(struct_type_name), false, false, false))

                                        _ := Arena.insert_enum(context, temp_var_name, struct_type_name, nested_result.value, e)
                                        enum_var_name = temp_var_name
                                        enum_var_set = true
                                    }
                                case NodeType.FCall:
                                    // This is a nested enum constructor call
                                    last_frame5 := context.scope_stack.last_frame()
                                    temp_var_name := format("__temp_enum_", I64.to_str(last_frame5.arena_index.len()))

                                    nested_result := eval_expr(context, payload_expr)
                                    if nested_result.is_throw {
                                        return nested_result
                                    }

                                    context.scope_stack.declare_symbol(temp_var_name, SymbolInfo.new(ValueType.TCustom(struct_type_name), false, false, false))

                                    _ := Arena.insert_enum(context, temp_var_name, struct_type_name, nested_result.value, e)
                                    enum_var_name = temp_var_name
                                    enum_var_set = true
                                case:
                                }

                                if not(enum_var_set) {
                                    throw e.error(context.path, "eval", format("Enum payload must be a variable identifier or enum constructor, got ", enum_to_str(payload_expr.node_type)))
                                }

                                // Get the full enum value including its payload
                                enum_val := Arena.get_enum(context, enum_var_name, e)

                                // Calculate total enum size: 8 bytes tag + payload bytes
                                mut enum_bytes := Vec.new(U8)

                                // Get the variant position
                                inner_enum_def := context.scope_stack.lookup_enum(struct_type_name)
                                variant_pos := Context.get_variant_pos(inner_enum_def, enum_val.enum_name, context.path, e)

                                // Add 8 bytes for variant tag
                                enum_bytes = i64_to_le_bytes(variant_pos)

                                // Add payload bytes if present
                                if not(NULL.eq(enum_val.payload.data)) {
                                    mut enum_payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(enum_payload_vec), enum_val.payload.data, size_of(Vec))
                                    mut pi := 0
                                    while pi.lt(enum_payload_vec.len()) {
                                        mut pb := U8.from_i64(0)
                                        enum_payload_vec.get(pi, pb)
                                        enum_bytes.push(pb)
                                        pi = pi.add(1)
                                    }
                                }

                                payload_bytes = enum_bytes
                                handled_payload = true
                            case:
                                throw e.error(context.path, "eval", format("Unsupported payload type: ", value_type_to_str(variant_type)))
                            }
                        }
                    case:
                        throw e.error(context.path, "eval", format("Unsupported payload type: ", value_type_to_str(variant_type)))
                    }

                    // Store payload in temp location for insert_enum to use
                    mut temp_payload := EnumPayload.new(payload_bytes, variant_type)
                    context.temp_enum_payload.data = to_ptr(temp_payload)

                    // Return the enum variant name
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    catch (err: KeyNotFoundError) { throw err.msg }
                    return EvalResult.new(format(enum_type, ".", variant_name))
                }
            } else {
                // This variant doesn't have a payload, but constructor was called with args
                if e.params.len().gt(1) {
                    throw e.error(context.path, "eval", format("Enum variant ", enum_type, ".", variant_name, " does not take a payload"))
                }
            }
            if not(has_variant) {
                throw e.error(context.path, "eval", format("Enum ", enum_type, " does not have variant ", variant_name))
            }
        }
    }

    // TODO: After precomp, UFCS is already resolved so the mutation in get_func_def_for_fcall_with_expr
    // is a no-op. Could save this clone by adding a simpler lookup function that doesn't need &mut.
    mut new_fcall_e := e.clone()
    mut func_def := SFuncDef()
    func_def = get_func_def_for_fcall_with_expr(context, new_fcall_e)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Instantiations should be handled already")
    }
    if func_def.is_ext() {
        // External/core functions are treated specially
        is_proc := func_def.is_proc()
        parts2 := combined_name.split(".")
        mut last_name := ""
        if parts2.len().gt(0) {
            parts2.get(parts2.len().sub(1), last_name)
        } else {
            throw e.lang_error(context.path, "eval", "Somehow function without name")
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return eval_core_func_proc_call(last_name, context, new_fcall_e, is_proc)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: U8_OverflowError) { throw err.msg }
    return eval_user_func_proc_call(func_def, combined_name, context, new_fcall_e)
}

eval_declaration := proc(declaration: Declaration, mut context: Context, e: Expr) returns EvalResult throws Str {
    inner_e := e.get(0)
    mut value_type := ValueType.TCustom("")
    value_type = get_value_type(context, inner_e)
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", err)
    }

    // Check type compatibility
    mut decl_is_infer := false
    switch declaration.value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            decl_is_infer = true
        }
    case:
    }

    if not(decl_is_infer) {
        mut decl_is_u8 := false
        mut value_is_i64 := false
        switch declaration.value_type {
        case ValueType.TCustom(s):
            if s.eq("U8") { decl_is_u8 = true }
        case:
        }
        switch value_type {
        case ValueType.TCustom(s):
            if s.eq("I64") { value_is_i64 = true }
        case:
        }

        if decl_is_u8 {
            if value_is_i64 {
                value_type = declaration.value_type
            }
        } else if not(enum_to_str(value_type).eq(enum_to_str(declaration.value_type))) {
            throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type ", value_type_to_str(declaration.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
        }
    }

    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "eval", "Declarations can have only one child expression")
    }

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type '", value_type_to_str(declaration.value_type), "' but still to infer type '", s, "'"))
        } else if s.eq("I64") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            Arena.insert_primitive(context, declaration.name, value_type, expr_result_str, e)
            return EvalResult.new("")
        } else if s.eq("U8") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            Arena.insert_primitive(context, declaration.name, value_type, expr_result_str, e)
            return EvalResult.new("")
        } else if s.eq("Str") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            Arena.insert_primitive(context, declaration.name, value_type, expr_result_str, e)
            return EvalResult.new("")
        } else {
            // Custom type (not I64/U8/Str)
            custom_type_name := s
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            mut custom_symbol := SymbolInfo()
            custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "eval", format("Symbol '", custom_type_name, "' not found in context"))
            }

            mut is_enum_def := false
            mut is_struct_def := false
            switch custom_symbol.value_type {
            case ValueType.TType(TTypeDef.TEnumDef):
                is_enum_def = true
            case ValueType.TType(TTypeDef.TStructDef):
                is_struct_def = true
            case:
            }

            if is_enum_def {
                result := eval_expr(context, inner_e)
                if result.is_throw {
                    return result
                }
                enum_expr_result_str := result.value
                _ := Arena.insert_enum(context, declaration.name, custom_type_name, enum_expr_result_str, e)
            } else if is_struct_def {
                // Special case for instantiation
                mut is_fcall := false
                switch inner_e.node_type {
                case NodeType.FCall:
                    is_fcall = true
                case:
                }
                if is_fcall {
                    if inner_e.params.len().eq(1) {
                        mut first_param := Expr()
                        inner_e.params.get(0, first_param)
                        switch first_param.node_type {
                        case NodeType.Identifier(potentially_struct_name):
                            if first_param.params.len().eq(0) {
                                mut is_struct := false
                                _ := context.scope_stack.lookup_struct(potentially_struct_name)
                                is_struct = true
                                catch (err: KeyNotFoundError) {
                                    // is_struct stays false - struct not found
                                }
                                if is_struct {
                                    insert_struct_instance(context, declaration.name, custom_type_name, e)
                                    return EvalResult.new("")
                                }
                            }
                        case:
                        }
                    }
                }
                // otherwise continue, it's a function that returns a struct
                result := eval_expr(context, inner_e)
                if result.is_throw {
                    return result
                }
                expr_result_str := result.value

                // Bug #25 fix: mut declarations should create independent copies
                // Exception: temporary return values can be transferred (zero-copy)
                // Non-mut declarations can share offsets (will use 'own' keyword for transfers in future)
                is_temp_return_val := expr_result_str.starts_with(RETURN_INSTANCE_NAME)

                if declaration.is_mut {
                    if not(is_temp_return_val) {
                        // Allocate space and copy fields for mut declaration (independent copy)
                        insert_struct_instance(context, declaration.name, custom_type_name, e)
                        Arena.copy_fields(context, custom_type_name, expr_result_str, declaration.name, e)
                    } else {
                        // Share offset for temp return value (zero-copy transfer)
                        offset := context.scope_stack.lookup_var(expr_result_str)
                        catch (err: KeyNotFoundError) {
                            throw e.lang_error(context.path, "eval", format("Could not find arena index for '", expr_result_str, "'"))
                        }
                        mut last_idx := context.scope_stack.frames.len().sub(1)
                        mut last_frame := ScopeFrame()
                        context.scope_stack.frames.get(last_idx, last_frame)
                        last_frame.arena_index.insert(declaration.name, offset)
                        context.scope_stack.frames.set(last_idx, last_frame)
                        context.map_instance_fields(custom_type_name, declaration.name, e)
                    }
                } else {
                    // Share offset for non-mut declaration (zero-copy transfer)
                    offset2 := context.scope_stack.lookup_var(expr_result_str)
                    catch (err: KeyNotFoundError) {
                        throw e.lang_error(context.path, "eval", format("Could not find arena index for '", expr_result_str, "'"))
                    }
                    mut last_idx2 := context.scope_stack.frames.len().sub(1)
                    mut last_frame2 := ScopeFrame()
                    context.scope_stack.frames.get(last_idx2, last_frame2)
                    last_frame2.arena_index.insert(declaration.name, offset2)
                    context.scope_stack.frames.set(last_idx2, last_frame2)
                    context.map_instance_fields(custom_type_name, declaration.name, e)
                }
            } else {
                throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(custom_symbol.value_type), "'. Only 'enum' and 'struct' custom types allowed."))
            }
            return EvalResult.new("")
        }
    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(declaration.name, enum_def.clone())
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected enum definition."))
        }
    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            context.scope_stack.declare_struct(declaration.name, struct_def.clone())
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            // Process struct members with default values
            mut mi := 0
            while mi.lt(struct_def.members.len()) {
                mut member_decl := Declaration()
                struct_def.members.get(mi, member_decl)
                if not(member_decl.is_mut) {
                    combined_name := format(declaration.name, ".", member_decl.name)
                    mut default_value := Expr()
                    struct_def.default_values.get(member_decl.name, default_value)
                    catch (err: KeyNotFoundError) {
                        throw e.lang_error(context.path, "eval", format("Struct member '", declaration.name, ".", member_decl.name, "' expected to have default value."))
                    }

                    mut member_value_type := member_decl.value_type
                    mut is_infer := false
                    switch member_decl.value_type {
                    case ValueType.TCustom(s2):
                        if s2.eq(INFER_TYPE) {
                            is_infer = true
                        }
                    case:
                    }
                    if is_infer {
                        member_value_type = get_value_type(context, default_value)
                        catch (err: Str) {
                            throw e.lang_error(context.path, "eval", err)
                        }
                    }

                    // Check if member_value_type is still INFER
                    mut still_infer := false
                    switch member_value_type {
                    case ValueType.TCustom(s3):
                        if s3.eq(INFER_TYPE) {
                            still_infer = true
                        }
                    case:
                    }
                    if still_infer {
                        throw e.lang_error(context.path, "eval", format("Cannot infer type of '", declaration.name, ".", member_decl.name, "', but it should be inferred already."))
                    }

                    // Handle member based on type
                    switch member_value_type {
                    case ValueType.TCustom(type_name):
                        result := eval_expr(context, default_value)
                        if result.is_throw {
                            return result
                        }
                        expr_result_str := result.value
                        if type_name.eq("I64") {
                            Arena.insert_primitive(context, combined_name, member_value_type, expr_result_str, e)
                        } else if type_name.eq("U8") {
                            Arena.insert_primitive(context, combined_name, member_value_type, expr_result_str, e)
                        } else if type_name.eq("Str") {
                            Arena.insert_primitive(context, combined_name, member_value_type, expr_result_str, e)
                        } else {
                            insert_struct_instance(context, combined_name, type_name, e)
                            Arena.copy_fields(context, type_name, expr_result_str, combined_name, e)
                        }
                    case ValueType.TFunction(func_type):
                        switch default_value.node_type {
                        case NodeType.FuncDef(func_def):
                            context.scope_stack.declare_func(combined_name, func_def.clone())
                        case:
                            throw e.lang_error(context.path, "eval", format("Cannot declare '", declaration.name, ".", member_decl.name, "' of type '", value_type_to_str(member_value_type), "', expected function definition."))
                        }
                    case:
                        throw e.todo_error(context.path, "eval", format("Cannot declare '", declaration.name, ".", member_decl.name, "' of type '", value_type_to_str(member_decl.value_type), "'"))
                    }

                    context.scope_stack.declare_symbol(combined_name, SymbolInfo.new(member_decl.value_type, member_decl.is_mut, member_decl.is_copy, member_decl.is_own))
                }
                mi = mi.add(1)
            }
            // Eagerly create default instance template for this struct type
            _ := create_default_instance(context, declaration.name, e)
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare ", declaration.name, " of type ", enum_to_str(declaration.value_type), ", expected struct definition."))
        }
    case ValueType.TFunction(func_type):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(declaration.name, func_def.clone())
            context.scope_stack.declare_symbol(declaration.name, SymbolInfo.new(value_type, declaration.is_mut, declaration.is_copy, declaration.is_own))
            return EvalResult.new("")
        case:
            throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected '", value_type_to_str(value_type), "' definition."))
        }
    case ValueType.TMulti(types):
        throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "'"))
    case:
        throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of unhandled type '", value_type_to_str(value_type), "'"))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: DuplicatedKeyError) { throw err.msg }
    return EvalResult.new("")
}

eval_assignment := proc(var_name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // For field access (e.g., "v.x"), extract the base variable name
    mut base_var_name := var_name
    if var_name.contains(".") {
        parts := var_name.split(".")
        if parts.len().gt(0) {
            parts.get(0, base_var_name)
        }
    }

    symbol_info := context.scope_stack.lookup_symbol(base_var_name)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Symbol '", base_var_name, "' not found in context"))
    }

    if not(symbol_info.is_mut) {
        if not(symbol_info.is_copy) {
            if not(symbol_info.is_own) {
                throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': Assignments can only be to mut values."))
            }
        }
    }
    if not(e.params.len().eq(1)) {
        throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': assignments must take exactly one value"))
    }

    inner_e := e.get(0)
    value_type := get_value_type(context, inner_e)
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", err)
    }

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Cannot assign ", var_name, ", type should already be inferred of type '", value_type_to_str(symbol_info.value_type), "'."))
        } else if s.eq("I64") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            Arena.insert_primitive(context, var_name, value_type, expr_result_str, e)
        } else if s.eq("U8") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            Arena.insert_primitive(context, var_name, value_type, expr_result_str, e)
        } else if s.eq("Str") {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            Arena.insert_primitive(context, var_name, value_type, expr_result_str, e)
        } else {
            // Custom type
            custom_type_name := s
            custom_symbol_info := context.scope_stack.lookup_symbol(custom_type_name)
            catch (err: KeyNotFoundError) {
                throw inner_e.lang_error(context.path, "eval", format("Unknown custom type '", custom_type_name, "'"))
            }

            switch custom_symbol_info.value_type {
            case ValueType.TType(TTypeDef.TEnumDef):
                result := eval_expr(context, inner_e)
                if result.is_throw {
                    return result
                }
                expr_result_str := result.value
                _ := Arena.insert_enum(context, var_name, custom_type_name, expr_result_str, e)
            case ValueType.TType(TTypeDef.TStructDef):
                result := eval_expr(context, inner_e)
                if result.is_throw {
                    return result
                }
                expr_result_str := result.value
                Arena.copy_fields(context, custom_type_name, expr_result_str, var_name, inner_e)
            case:
                throw inner_e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of custom type '", custom_type_name, "' of value type '", value_type_to_str(custom_symbol_info.value_type), "'."))
            }
        }
        return EvalResult.new("")
    case ValueType.TType(TTypeDef.TStructDef):
        throw e.todo_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'"))
    case ValueType.TFunction(func_type):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(var_name, func_def.clone())
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' to function type '", value_type_to_str(value_type), "'"))
        }
    case ValueType.TType(TTypeDef.TEnumDef):
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'."))
    case ValueType.TMulti(types):
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'."))
    case:
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of unhandled type '", value_type_to_str(value_type), "'."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    return EvalResult.new("")
}

eval_identifier_expr_struct_member := proc(name: Str, inner_name: Str, mut context: Context, inner_e: Expr, member_decl: Declaration) returns EvalResult throws Str {
    switch member_decl.value_type {
    case ValueType.TCustom(custom_type_name):
        combined := format(name, ".", inner_name)
        if custom_type_name.eq("I64") {
            i64_result := Arena.get_i64(context, combined, inner_e)
            return EvalResult.new(I64.to_str(i64_result))
        } else if custom_type_name.eq("U8") {
            u8_result : U8 = Arena.get_u8(context, combined, inner_e)
            return EvalResult.new(U8.to_str(u8_result))
        } else if custom_type_name.eq("Str") {
            result := string_from_context(context, combined, inner_e)
            return EvalResult.new(result)
        } else {
            return EvalResult.new(combined)
        }
    case:
        throw inner_e.lang_error(context.path, "eval", format("struct '", name, "' has no const (static) member '", inner_name, "' of struct value type '", value_type_to_str(member_decl.value_type), "'"))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return EvalResult.new("")
}

eval_identifier_expr_struct := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    struct_def := context.scope_stack.lookup_struct(name)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Struct '", name, "' not found in context"))
    }
    inner_e := e.get(0)
    switch inner_e.node_type {
    case NodeType.Identifier(inner_name):
        member_decl := struct_def.get_member_or_err(inner_name, name, context.path, e)
        return eval_identifier_expr_struct_member(name, inner_name, context, inner_e, member_decl)
    case:
        throw e.lang_error(context.path, "eval", format("identifier '", name, "' should only have identifiers inside."))
    }
    return EvalResult.new("")
}

eval_custom_expr := proc(e: Expr, mut context: Context, name: Str, custom_type_name: Str) returns EvalResult throws Str {
    custom_symbol := context.scope_stack.lookup_symbol(custom_type_name)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Argument '", name, "' is of undefined type ", custom_type_name, "."))
    }

    switch custom_symbol.value_type {
    case ValueType.TType(TTypeDef.TEnumDef):
        // If name equals the type name, this is a reference to the type itself, not a variable
        if name.eq(custom_type_name) {
            throw e.lang_error(context.path, "eval", format("Cannot use enum type '", name, "' as a value"))
        }
        enum_val := Arena.get_enum(context, name, e)
        // Set temp_enum_payload so that if this enum is assigned to another variable,
        // the payload will be preserved
        if not(NULL.eq(enum_val.payload.data)) {
            // Read payload vec from Ptr
            mut payload_vec := Vec.new(U8)
            memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
            // Check if payload_type is set (not NULL)
            if not(NULL.eq(enum_val.payload_type.data)) {
                // Read payload_type from Ptr
                mut payload_type := ValueType.TCustom("")
                memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
                mut temp_payload := EnumPayload.new(payload_vec.clone(), payload_type)
                context.temp_enum_payload.data = to_ptr(temp_payload)
            }
        }
        return EvalResult.new(format(custom_type_name, ".", enum_val.enum_name))
    case ValueType.TType(TTypeDef.TStructDef):
        if e.params.len().eq(0) {
            return EvalResult.new(name)
        }

        mut current_name := name
        mut current_type := ValueType.TCustom(custom_type_name)

        mut pi := 0
        while pi.lt(e.params.len()) {
            mut inner_e := Expr()
            e.params.get(pi, inner_e)
            switch inner_e.node_type {
            case NodeType.Identifier(inner_name):
                switch current_type {
                case ValueType.TType(TTypeDef.TStructDef):
                    throw inner_e.todo_error(context.path, "eval", format("'", current_name, "': StructDef cannot be a field yet"))
                case ValueType.TCustom(curr_type_name):
                    inner_custom_symbol := context.scope_stack.lookup_symbol(curr_type_name)
                    catch (err: KeyNotFoundError) {
                        throw inner_e.lang_error(context.path, "eval", format("Custom type '", curr_type_name, "' not found in symbols"))
                    }
                    switch inner_custom_symbol.value_type {
                    case ValueType.TType(TTypeDef.TStructDef):
                        struct_def := context.scope_stack.lookup_struct(curr_type_name)
                        catch (err: KeyNotFoundError) {
                            throw e.lang_error(context.path, "eval", format("Struct '", curr_type_name, "' not found in context"))
                        }
                        member_decl := struct_def.get_member_or_err(inner_name, curr_type_name, context.path, inner_e)
                        current_type = member_decl.value_type
                        current_name = format(current_name, ".", inner_name)
                    case ValueType.TType(TTypeDef.TEnumDef):
                        throw inner_e.lang_error(context.path, "eval", format("Enum '", current_name, "' does not support nested members"))
                    case:
                        throw inner_e.lang_error(context.path, "eval", "Custom types cannot have nested members")
                    }
                case ValueType.TType(TTypeDef.TEnumDef):
                    throw inner_e.lang_error(context.path, "eval", format("Enum '", current_name, "' does not support nested members"))
                case:
                    throw inner_e.lang_error(context.path, "eval", format("Unexpected type for '", current_name, "', cannot access member '", inner_name, "'"))
                }
            case:
                throw inner_e.lang_error(context.path, "eval", format("Expected identifier, found ", enum_to_str(inner_e.node_type)))
            }
            pi = pi.add(1)
        }

        if e.params.len().eq(0) {
            throw e.lang_error(context.path, "eval", "eval_custom_expr: Expected at least one parameter")
        }
        mut last_inner_e := Expr()
        e.params.get(e.params.len().sub(1), last_inner_e)

        switch current_type {
        case ValueType.TCustom(curr_type_name):
            if curr_type_name.eq("I64") {
                i64_result := Arena.get_i64(context, current_name, e)
                return EvalResult.new(I64.to_str(i64_result))
            } else if curr_type_name.eq("U8") {
                u8_result : U8 = Arena.get_u8(context, current_name, e)
                return EvalResult.new(U8.to_str(u8_result))
            } else if curr_type_name.eq("Str") {
                result := string_from_context(context, current_name, e)
                return EvalResult.new(result)
            } else {
                curr_type_name_str := value_type_to_str(current_type)
                custom_symbol_info := context.scope_stack.lookup_symbol(curr_type_name_str)
                catch (err: KeyNotFoundError) {
                    throw last_inner_e.lang_error(context.path, "eval", format("Unknown custom type '", curr_type_name_str, "'"))
                }
                switch custom_symbol_info.value_type {
                case ValueType.TType(TTypeDef.TEnumDef):
                    enum_val := Arena.get_enum(context, current_name, last_inner_e)
                    // Set temp_enum_payload if this enum has a payload
                    if not(NULL.eq(enum_val.payload.data)) {
                        // Read payload vec from Ptr
                        mut payload_vec := Vec.new(U8)
                        memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
                        // Check if payload_type is set (not NULL)
                        if not(NULL.eq(enum_val.payload_type.data)) {
                            // Read payload_type from Ptr
                            mut payload_type := ValueType.TCustom("")
                            memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
                            mut temp_payload := EnumPayload.new(payload_vec.clone(), payload_type)
                            context.temp_enum_payload.data = to_ptr(temp_payload)
                        }
                    }
                    return EvalResult.new(format(curr_type_name_str, ".", enum_val.enum_name))
                case ValueType.TType(TTypeDef.TStructDef):
                    return EvalResult.new(current_name)
                case:
                    throw last_inner_e.todo_error(context.path, "eval", format("Cannot access '", current_name, "'. Fields of custom type '", curr_type_name_str, "' not implemented"))
                }
            }
        case:
            throw e.lang_error(context.path, "eval", format("Invalid type for '", current_name, "'."))
        }
    case:
        throw e.lang_error(context.path, "eval", format("'", name, "' of type: '", custom_type_name, "': custom types are supposed to be struct or enum, found '", value_type_to_str(custom_symbol.value_type), "'."))
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return EvalResult.new("")
}

eval_identifier_expr := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    symbol_info := context.scope_stack.lookup_symbol(name)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("Undefined symbol '", name, "'. This should have been caught in the compile phase."))
    }

    switch symbol_info.value_type {
    case ValueType.TFunction(FunctionType.FTFunc):
        return EvalResult.new(name)
    case ValueType.TFunction(FunctionType.FTProc):
        return EvalResult.new(name)
    case ValueType.TFunction(FunctionType.FTMacro):
        return EvalResult.new(name)
    case ValueType.TType(TTypeDef.TEnumDef):
        inner_e := e.get(0)
        switch inner_e.node_type {
        case NodeType.Identifier(inner_name):
            // TODO check that inner_name is in enum_def
            // TODO check if that inner_name has an optional type
            return EvalResult.new(format(name, ".", inner_name))
        case:
            throw e.lang_error(context.path, "eval", format("identifier '", name, "' should only have identifiers inside."))
        }
    case ValueType.TType(TTypeDef.TStructDef):
        return eval_identifier_expr_struct(name, context, e)
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Can't infer the type of identifier '", name, "'."))
        } else if s.eq("I64") {
            i64_val := Arena.get_i64(context, name, e)
            return EvalResult.new(I64.to_str(i64_val))
        } else if s.eq("U8") {
            u8_val : U8 = Arena.get_u8(context, name, e)
            return EvalResult.new(U8.to_str(u8_val))
        } else if s.eq("Str") {
            if e.params.len().eq(0) {
                val := string_from_context(context, name, e)
                return EvalResult.new(val)
            }
            return eval_custom_expr(e, context, name, s)
        } else {
            return eval_custom_expr(e, context, name, s)
        }
    case:
        throw e.todo_error(context.path, "eval", format("Can't use identifier '", name, "'. Type ", value_type_to_str(symbol_info.value_type), " not supported yet."))
    }
    return EvalResult.new("")
}

eval_body := proc(mut context: Context, statements: Vec) returns EvalResult throws Str {
    mut i := 0
    mut pending_throw := EvalResult()
    mut has_pending_throw := false

    while i.lt(statements.len()) {
        mut stmt := Expr()
        statements.get(i, stmt)

        if has_pending_throw {
            throw_result := pending_throw
            mut is_catch := false
            switch stmt.node_type {
            case NodeType.Catch:
                is_catch = true
            case:
            }
            if is_catch {
                if stmt.params.len().eq(3) {
                    // params[0]: error variable name (e.g., "err")
                    // params[1]: error type (e.g., "AllocError")
                    // params[2]: body
                    mut var_expr := Expr()
                    stmt.params.get(0, var_expr)
                    mut var_name := ""
                    switch var_expr.node_type {
                    case NodeType.Identifier(name):
                        var_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch variable must be an identifier")
                    }
                    mut type_expr := Expr()
                    stmt.params.get(1, type_expr)
                    mut type_name := ""
                    switch type_expr.node_type {
                    case NodeType.Identifier(name):
                        type_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch type must be an identifier")
                    }
                    if not(throw_result.thrown_type.eq("")) {
                        thrown_type := throw_result.thrown_type
                        if type_name.eq(thrown_type) {
                            // Bind the error variable to the caught error value
                            context.scope_stack.declare_symbol(var_name, SymbolInfo.new(ValueType.TCustom(thrown_type), false, false, false))

                            // Map instance fields for the error variable
                            // First try to find the arena index for proper field mapping
                            mut found_offset := false
                            offset := context.scope_stack.lookup_var(throw_result.value)
                            found_offset = true
                            catch (err: KeyNotFoundError) {
                                // found_offset stays false - var not found
                            }

                            if found_offset {
                                mut lf_idx := context.scope_stack.frames.len().sub(1)
                                mut lf := ScopeFrame()
                                context.scope_stack.frames.get(lf_idx, lf)
                                lf.arena_index.insert(var_name, offset)
                                context.scope_stack.frames.set(lf_idx, lf)

                                // Copy ALL field mappings (including nested) from thrown instance to catch variable
                                source_prefix := format(throw_result.value, ".")
                                dest_prefix := format(var_name, ".")

                                lf2 := context.scope_stack.last_frame()
                                // Build list of keys with prefix by iterating map.keys Vec
                                mut keys_to_copy := Vec.new(Str)
                                mut lf2_arena_keys := lf2.arena_index.keys
                                mut ai := 0
                                while ai.lt(lf2.arena_index.len()) {
                                    mut akey := ""
                                    lf2_arena_keys.get(ai, akey)
                                    if akey.starts_with(source_prefix) {
                                        keys_to_copy.push(akey.clone())
                                    }
                                    ai = ai.add(1)
                                }
                                catch (err_alloc: AllocError) { }
                                mut ki := 0
                                while ki.lt(keys_to_copy.len()) {
                                    mut src_key := ""
                                    keys_to_copy.get(ki, src_key)
                                    mut src_offset := 0
                                    mut found_key := false
                                    src_offset = context.scope_stack.lookup_var(src_key)
                                    found_key = true
                                    catch (err: KeyNotFoundError) {
                                        // found_key stays false - var not found
                                    }
                                    if found_key {
                                        mut dest_key := src_key.replace(source_prefix, dest_prefix)
                                        mut lf3_idx := context.scope_stack.frames.len().sub(1)
                                        mut lf3 := ScopeFrame()
                                        context.scope_stack.frames.get(lf3_idx, lf3)
                                        lf3.arena_index.insert(dest_key, src_offset)
                                        context.scope_stack.frames.set(lf3_idx, lf3)
                                    }
                                    ki = ki.add(1)
                                }

                                // Also copy symbol mappings for all fields - build list with prefix
                                mut symbol_keys_to_copy := Vec.new(Str)
                                mut lf2_sym_keys := lf2.symbols.keys
                                mut sai := 0
                                while sai.lt(lf2.symbols.len()) {
                                    mut skey := ""
                                    lf2_sym_keys.get(sai, skey)
                                    if skey.starts_with(source_prefix) {
                                        symbol_keys_to_copy.push(skey.clone())
                                    }
                                    sai = sai.add(1)
                                }
                                catch (err_alloc2: AllocError) { }
                                mut si := 0
                                while si.lt(symbol_keys_to_copy.len()) {
                                    mut sym_src_key := ""
                                    symbol_keys_to_copy.get(si, sym_src_key)
                                    mut src_symbol := SymbolInfo()
                                    mut found_sym := false
                                    src_symbol = context.scope_stack.lookup_symbol(sym_src_key)
                                    found_sym = true
                                    catch (err: KeyNotFoundError) {
                                        // found_sym stays false - symbol not found
                                    }
                                    if found_sym {
                                        sym_dest_key := sym_src_key.replace(source_prefix, dest_prefix)
                                        context.scope_stack.declare_symbol(sym_dest_key, src_symbol.clone())
                                    }
                                    si = si.add(1)
                                }
                            } else {
                                // Fallback: try to map fields from the thrown value or type
                                // Special handling for Str: when throwing a string literal, we need to create a proper Str struct
                                if thrown_type.eq("Str") {
                                    // The thrown value is the actual string content, not a struct instance name
                                    // Create a proper Str struct for the catch variable
                                    Arena.insert_string(context, var_name, throw_result.value, stmt)
                                } else {
                                    mut struct_def := SStructDef()
                                    mut has_struct := false
                                    struct_def = context.scope_stack.lookup_struct(thrown_type)
                                    has_struct = true
                                    catch (err: KeyNotFoundError) { }
                                    if has_struct {
                                        source_name := throw_result.value

                                        // Register the base variable first
                                        mut base_offset := 0
                                        mut base_found := false
                                        base_offset = context.scope_stack.lookup_var(source_name)
                                        base_found = true
                                        catch (err: KeyNotFoundError) { }
                                        if base_found {
                                            mut lf4_idx := context.scope_stack.frames.len().sub(1)
                                            mut lf4 := ScopeFrame()
                                            context.scope_stack.frames.get(lf4_idx, lf4)
                                            lf4.arena_index.insert(var_name, base_offset)
                                            context.scope_stack.frames.set(lf4_idx, lf4)
                                        }

                                        mut fi := 0
                                        while fi.lt(struct_def.members.len()) {
                                            mut field_decl := Declaration()
                                            struct_def.members.get(fi, field_decl)
                                            src_instance_field := format(source_name, ".", field_decl.name)
                                            src_type_field := format(thrown_type, ".", field_decl.name)
                                            dst_field := format(var_name, ".", field_decl.name)

                                            // Add symbol for the field
                                            context.scope_stack.declare_symbol(dst_field, SymbolInfo.new(field_decl.value_type, false, false, false))

                                            // Copy arena_index entry for the field
                                            // Try instance field first, then fall back to type field
                                            mut field_offset := 0
                                            mut found_field := false
                                            field_offset = context.scope_stack.lookup_var(src_instance_field)
                                            found_field = true
                                            catch (err: KeyNotFoundError) {
                                                field_offset = context.scope_stack.lookup_var(src_type_field)
                                                found_field = true
                                                catch (err2: KeyNotFoundError) { }
                                            }
                                            if found_field {
                                                mut lf5_idx := context.scope_stack.frames.len().sub(1)
                                                mut lf5 := ScopeFrame()
                                                context.scope_stack.frames.get(lf5_idx, lf5)
                                                lf5.arena_index.insert(dst_field, field_offset)
                                                context.scope_stack.frames.set(lf5_idx, lf5)
                                            }
                                            fi = fi.add(1)
                                        }
                                    }
                                }
                            }

                            mut body_expr := Expr()
                            stmt.params.get(2, body_expr)
                            result := eval_body(context, body_expr.params)

                            // Clean up the error variable binding after the catch block
                            _ := context.scope_stack.remove_symbol(var_name)
                            _ := context.scope_stack.remove_var(var_name)
                            // Also remove the field mappings
                            mut cleanup_struct_def := SStructDef()
                            mut has_cleanup_struct := false
                            cleanup_struct_def = context.scope_stack.lookup_struct(thrown_type)
                            has_cleanup_struct = true
                            catch (err: KeyNotFoundError) { }
                            if has_cleanup_struct {
                                mut cfi := 0
                                while cfi.lt(cleanup_struct_def.members.len()) {
                                    mut cleanup_field_decl := Declaration()
                                    cleanup_struct_def.members.get(cfi, cleanup_field_decl)
                                    combined_name := format(var_name, ".", cleanup_field_decl.name)
                                    _ := context.scope_stack.remove_symbol(combined_name)
                                    _ := context.scope_stack.remove_var(combined_name)
                                    cfi = cfi.add(1)
                                }
                            }

                            if result.is_return {
                                return result
                            } else if result.is_throw {
                                pending_throw = result
                                has_pending_throw = true
                            } else {
                                has_pending_throw = false
                            }
                        }
                    }
                }
            }
        } else {
            // If no pending throw, ignore catch statements
            mut is_catch := false
            switch stmt.node_type {
            case NodeType.Catch:
                is_catch = true
            case:
            }
            if not(is_catch) {
                result := eval_expr(context, stmt)
                if result.is_return {
                    return result
                } else if result.is_throw {
                    pending_throw = result
                    has_pending_throw = true
                }
            }
        }

        i = i.add(1)
    }

    if has_pending_throw {
        return pending_throw
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: DuplicatedKeyError) { throw err.msg }
    return EvalResult.new("")
}

// ---------- generic eval things

// MutArgEntry - internal structure for tracking mut arguments
MutArgEntry := struct {
    mut arg_name: Str = ""
    mut source_name: Str = ""
    mut value_type: ValueType = ValueType.TMulti("")
}

// MutArgStructData - data for Struct variant of MutArgValue
MutArgStructData := struct {
    mut offset: I64 = 0
    mut type_name: Str = ""
    mut was_passed_by_ref: Bool = false

    new := func(offset: I64, type_name: Str, was_passed_by_ref: Bool) returns MutArgStructData {
        mut result := MutArgStructData()
        result.offset = offset
        result.type_name = type_name
        result.was_passed_by_ref = was_passed_by_ref
        return result
    }
}

// MutArgValue - enum with payloads matching Rust's MutArgValue
MutArgValue := enum {
    I64: I64,
    U8: U8,
    Str: Str,
    Enum: EnumVal,
    Struct: MutArgStructData,
}

// CollectedMutArg - collected mut arg to write back
CollectedMutArg := struct {
    mut source_name: Str = ""
    mut value: MutArgValue = MutArgValue.I64(0)

    new := func(source_name: Str, value: MutArgValue) returns CollectedMutArg {
        mut result := CollectedMutArg()
        result.source_name = source_name
        result.value = value
        return result
    }
}

eval_user_func_proc_call := proc(func_def: SFuncDef, name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // TODO REFACTOR: Replace context.clone() with scope push/pop

    mut function_frame := ScopeFrame()
    function_frame.scope_type = ScopeType.Function
    saved_path := context.path
    _ := validate_func_arg_count(context.path, e, name, func_def)

    mut param_index := 1
    mut mut_args := Vec.new(MutArgEntry)
    mut pass_by_ref_params := Vec.new(Str)
    mut params_consumed := false

    mut arg_i := 0
    while arg_i.lt(func_def.args.len()) {
        if not(params_consumed) {
            mut arg := Declaration()
            func_def.args.get(arg_i, arg)
            function_frame.symbols.insert(arg.name, SymbolInfo.new(arg.value_type, arg.is_mut, arg.is_copy, arg.is_own))

            switch arg.value_type {
            case ValueType.TMulti(multi_value_type):
                // Handle variadic args
                mut values := Vec.new(Str)
                mut vi := param_index
                while vi.lt(e.params.len()) {
                    mut expr := Expr()
                    e.params.get(vi, expr)
                    result := eval_expr(context, expr)
                    if result.is_throw {
                        return result
                    }
                    values.push(result.value)
                    vi = vi.add(1)
                }

                array_type_name := "Array"
                function_frame.symbols.insert(arg.name, SymbolInfo.new(ValueType.TCustom(array_type_name), arg.is_mut, arg.is_copy, arg.is_own))
                Arena.insert_array_into_frame(context, function_frame, arg.name, multi_value_type, values, e)
                params_consumed = true

            case ValueType.TCustom(custom_type_name):
                current_arg := e.get(param_index)

                // Special handling for Dynamic/Type parameters
                mut skip_this_param := false
                if custom_type_name.eq("Dynamic") {
                    switch current_arg.node_type {
                    case NodeType.Identifier(id_name):
                        mut sym := SymbolInfo()
                        sym = context.scope_stack.lookup_symbol(id_name)
                        switch sym.value_type {
                        case ValueType.TType(tdef):
                            // This is a type identifier - store the type name as a string
                            function_frame.symbols.insert(arg.name, SymbolInfo.new(ValueType.TCustom("Str"), false, false, false))
                            Arena.insert_string_into_frame(context, function_frame, arg.name, id_name, e)
                            param_index = param_index.add(1)
                            skip_this_param = true
                        case:
                        }
                        catch (err: KeyNotFoundError) { }
                    case:
                    }
                } else if custom_type_name.eq("Type") {
                    switch current_arg.node_type {
                    case NodeType.Identifier(id_name):
                        mut sym := SymbolInfo()
                        sym = context.scope_stack.lookup_symbol(id_name)
                        switch sym.value_type {
                        case ValueType.TType(tdef):
                            // This is a type identifier - store the type name as a string
                            function_frame.symbols.insert(arg.name, SymbolInfo.new(ValueType.TCustom("Str"), false, false, false))
                            Arena.insert_string_into_frame(context, function_frame, arg.name, id_name, e)
                            param_index = param_index.add(1)
                            skip_this_param = true
                        case:
                        }
                        catch (err: KeyNotFoundError) { }
                    case:
                    }
                }

                if not(skip_this_param) {
                    // Check if this is an enum argument and save payload
                    mut enum_payload_backup := EnumPayload()
                    mut has_enum_backup := false
                    switch current_arg.node_type {
                    case NodeType.Identifier(id_name):
                        mut sym := SymbolInfo()
                        sym = context.scope_stack.lookup_symbol(id_name)
                        switch sym.value_type {
                        case ValueType.TCustom(arg_type_name):
                            mut type_sym := SymbolInfo()
                            type_sym = context.scope_stack.lookup_symbol(arg_type_name)
                            switch type_sym.value_type {
                            case ValueType.TType(TTypeDef.TEnumDef):
                                enum_val := Arena.get_enum(context, id_name, e)
                                if not(NULL.eq(enum_val.payload.data)) {
                                    mut payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
                                    if not(NULL.eq(enum_val.payload_type.data)) {
                                        mut payload_type := ValueType.TCustom("")
                                        memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
                                        enum_payload_backup = EnumPayload.new(payload_vec.clone(), payload_type)
                                        has_enum_backup = true
                                    }
                                }
                                catch (err3: Str) { }
                            case:
                            }
                            catch (err2: KeyNotFoundError) { }
                        case:
                        }
                        catch (err1: KeyNotFoundError) { }
                    case:
                    }

                    result := eval_expr(context, current_arg)
                    if result.is_throw {
                        return result
                    }
                    result_str := result.value

                    // Restore enum payload if we saved it
                    if has_enum_backup {
                        context.temp_enum_payload = enum_payload_backup
                    }

                    // Resolve Dynamic/Type to actual type first
                    mut resolved_type_name := custom_type_name
                    if custom_type_name.eq("Dynamic") {
                        resolved_type_name = value_type_to_str(get_value_type(context, current_arg))
                    } else if custom_type_name.eq("Type") {
                        resolved_type_name = value_type_to_str(get_value_type(context, current_arg))
                    }

                    // Create resolved ValueType for the parameter
                    resolved_value_type := ValueType.TCustom(resolved_type_name)

                    // Now push to mut_args with the resolved type
                    if arg.is_mut {
                        switch current_arg.node_type {
                        case NodeType.Identifier(id_):
                            // Build full path for field access
                            mut full_id := id_
                            if current_arg.params.len().gt(0) {
                                mut pi2 := 0
                                while pi2.lt(current_arg.params.len()) {
                                    mut param := Expr()
                                    current_arg.params.get(pi2, param)
                                    switch param.node_type {
                                    case NodeType.Identifier(field_name):
                                        full_id = format(full_id, ".", field_name)
                                    case:
                                        throw e.lang_error(context.path, "eval", "Field access must use identifiers")
                                    }
                                    pi2 = pi2.add(1)
                                }
                            }
                            mut mut_entry := MutArgEntry()
                            mut_entry.arg_name = arg.name
                            mut_entry.source_name = full_id
                            mut_entry.value_type = ValueType.TCustom(resolved_type_name)
                            mut_args.push(mut_entry)
                        case:
                            throw e.lang_error(context.path, "eval", "mut arguments must be passed as identifiers or field access")
                        }
                    }

                    // Handle ownership transfer for 'own' parameters
                    mut own_handled := false
                    if arg.is_own {
                        switch current_arg.node_type {
                        case NodeType.Identifier(source_var):
                            mut offset := 0
                            offset = context.scope_stack.lookup_var(source_var)
                            function_frame.arena_index.insert(arg.name, offset)

                            // Transfer all related entries - iterate over map keys and filter by prefix
                            prefix := format(source_var, ".")
                            lf6 := context.scope_stack.last_frame()
                            // Build list of keys to transfer by iterating map.keys Vec
                            mut keys_to_transfer := Vec.new(Str)
                            mut arena_keys := lf6.arena_index.keys
                            mut ki := 0
                            while ki.lt(lf6.arena_index.len()) {
                                mut key := ""
                                arena_keys.get(ki, key)
                                if key.starts_with(prefix) {
                                    keys_to_transfer.push(key.clone())
                                }
                                ki = ki.add(1)
                            }

                            // Now process the matching keys
                            mut ki2 := 0
                            while ki2.lt(keys_to_transfer.len()) {
                                mut key := ""
                                keys_to_transfer.get(ki2, key)
                                mut field_offset := 0
                                mut have_field_offset := false
                                field_offset = context.scope_stack.lookup_var(key)
                                have_field_offset = true
                                catch (err_var: KeyNotFoundError) { }
                                if have_field_offset {
                                    mut new_key := key.replace(source_var, arg.name)
                                    function_frame.arena_index.insert(new_key, field_offset)
                                    mut field_sym := SymbolInfo()
                                    field_sym = context.scope_stack.lookup_symbol(key)
                                    function_frame.symbols.insert(new_key, field_sym.clone())
                                    catch (err_sym: KeyNotFoundError) { }
                                }
                                ki2 = ki2.add(1)
                            }

                            // Remove from caller's context (ownership transferred)
                            _ := context.scope_stack.remove_var(source_var)
                            _ := context.scope_stack.remove_symbol(source_var)
                            mut ki3 := 0
                            while ki3.lt(keys_to_transfer.len()) {
                                mut key := ""
                                keys_to_transfer.get(ki3, key)
                                _ := context.scope_stack.remove_var(key)
                                _ := context.scope_stack.remove_symbol(key)
                                ki3 = ki3.add(1)
                            }

                            param_index = param_index.add(1)
                            own_handled = true
                            catch (err1: KeyNotFoundError) { }
                            catch (err_alloc: AllocError) { }
                        case:
                        }
                    }

                    if not(own_handled) {
                        // Phase 3: Pass-by-reference for non-copy, non-own, non-Type parameters
                        // If argument is a variable (identifier), share arena offset instead of copying
                        // Note: Type parameters need copy semantics for type name storage, so skip them
                        // Note: Dynamic parameters NOW use pass-by-reference (including mut Dynamic)
                        // Note: own parameters are handled separately above and should not fall through here
                        // Works for ALL types thanks to field offset refactoring (commit 2b9d08d):
                        // - Only base offset stored in arena_index
                        // - Field offsets calculated dynamically from struct definitions
                        // - Inline memory layout means sharing base offset shares all fields
                        mut should_pass_by_ref := false
                        if not(arg.is_copy) {
                            if not(arg.is_own) {
                                if not(custom_type_name.eq("Type")) {
                                    should_pass_by_ref = true
                                }
                            }
                        }
                        if should_pass_by_ref {
                            mut pass_by_ref_done := false
                            switch current_arg.node_type {
                            case NodeType.Identifier(source_var):
                                // Only share offset for SIMPLE identifiers (no field access, no params)
                                // Field access like s.cap is also an Identifier node but has params
                                if current_arg.params.len().eq(0) {
                                    // Share arena offset from caller context (zero-copy pass-by-reference)
                                    mut offset_found := false
                                    mut offset := 0
                                    offset = context.scope_stack.lookup_var(source_var)
                                    offset_found = true
                                    catch (err: KeyNotFoundError) { }
                                    if offset_found {
                                        // Create symbol info for parameter using the resolved type
                                        param_symbol := SymbolInfo.new(resolved_value_type, arg.is_mut, arg.is_copy, arg.is_own)
                                        function_frame.symbols.insert(arg.name.clone(), param_symbol)
                                        function_frame.arena_index.insert(arg.name.clone(), offset)

                                        // CRITICAL: Copy all nested field offsets AND symbols from ALL frames to callee
                                        // insert_struct registers nested field offsets (e.g., "l.start.x")
                                        // We need to copy these so field access works in the callee
                                        // Must search ALL frames because globals like `true` are in frame 0
                                        prefix := format(source_var, ".")
                                        replacement_prefix := format(arg.name, ".")
                                        mut field_offsets_to_copy := Vec.new(ArenaMapping)
                                        mut field_symbols_to_copy := Vec.new(SymbolEntry)
                                        mut fi := 0
                                        while fi.lt(context.scope_stack.frames.len()) {
                                            mut caller_frame := ScopeFrame()
                                            context.scope_stack.frames.get(fi, caller_frame)
                                            // Copy arena_index entries
                                            arena_keys := caller_frame.arena_index.keys
                                            mut aki := 0
                                            while aki.lt(arena_keys.len()) {
                                                mut key := ""
                                                arena_keys.get(aki, key)
                                                if key.starts_with(prefix) {
                                                    mut value := 0
                                                    caller_frame.arena_index.get(key, value)
                                                    mut new_key := key.replace(prefix, replacement_prefix)
                                                    mut mapping := ArenaMapping()
                                                    mapping.name = new_key
                                                    mapping.offset = value
                                                    field_offsets_to_copy.push(mapping)
                                                }
                                                aki = aki.add(1)
                                            }
                                            // Copy symbols entries
                                            symbol_keys := caller_frame.symbols.keys
                                            mut ski := 0
                                            while ski.lt(symbol_keys.len()) {
                                                mut skey := ""
                                                symbol_keys.get(ski, skey)
                                                if skey.starts_with(prefix) {
                                                    mut svalue := SymbolInfo()
                                                    caller_frame.symbols.get(skey, svalue)
                                                    new_skey := skey.replace(prefix, replacement_prefix)
                                                    mut entry := SymbolEntry()
                                                    entry.name = new_skey
                                                    entry.info = svalue.clone()
                                                    field_symbols_to_copy.push(entry)
                                                }
                                                ski = ski.add(1)
                                            }
                                            fi = fi.add(1)
                                        }
                                        // Insert collected offsets
                                        mut foi := 0
                                        while foi.lt(field_offsets_to_copy.len()) {
                                            mut mapping := ArenaMapping()
                                            field_offsets_to_copy.get(foi, mapping)
                                            function_frame.arena_index.insert(mapping.name, mapping.offset)
                                            foi = foi.add(1)
                                        }
                                        // Insert collected symbols
                                        mut fsi := 0
                                        while fsi.lt(field_symbols_to_copy.len()) {
                                            mut entry := SymbolEntry()
                                            field_symbols_to_copy.get(fsi, entry)
                                            function_frame.symbols.insert(entry.name, entry.info)
                                            fsi = fsi.add(1)
                                        }

                                        // Track that this parameter was passed by reference
                                        pass_by_ref_params.push(arg.name.clone())

                                        param_index = param_index.add(1)
                                        pass_by_ref_done = true
                                    }
                                }
                            case:
                            }
                            // If not an identifier or not found, fall through to normal allocation
                            // (expressions must allocate fresh memory)
                        }

                        if not(pass_by_ref_done) {
                        switch custom_type_name {
                        case "I64":
                            Arena.insert_i64_into_frame(context, function_frame, arg.name, result_str, e)
                        case "U8":
                            Arena.insert_u8_into_frame(context, function_frame, arg.name, result_str, e)
                        case "Str":
                            Arena.insert_string_into_frame(context, function_frame, arg.name, result_str, e)
                        case:
                            // Custom type (enum or struct)
                            mut custom_symbol := SymbolInfo()
                            mut custom_symbol_found := false
                            custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)
                            custom_symbol_found = true
                            catch (err: KeyNotFoundError) { }
                            if not(custom_symbol_found) {
                                throw e.lang_error(context.path, "eval", format("Undefined symbol for custom type '", custom_type_name, "'"))
                            }
                            mut is_enum_def := false
                            mut is_struct_def := false
                            switch custom_symbol.value_type {
                            case ValueType.TType(ttype_val):
                                switch ttype_val {
                                case TTypeDef.TEnumDef:
                                    is_enum_def = true
                                case TTypeDef.TStructDef:
                                    is_struct_def = true
                                }
                            case:
                            }
                            if is_enum_def {
                                // Transfer payload from outer context if present (temp_enum_payload already on context)
                                _ := Arena.insert_enum_into_frame(context, function_frame, arg.name, custom_type_name, result_str, e)
                            } else if is_struct_def {
                                // Bug #10 fix: Handle field access chains like s.items
                                mut source_id := ""
                                if current_arg.params.len().gt(0) {
                                    // Build the full path for field access: "s.items"
                                    mut full_path := ""
                                    switch current_arg.node_type {
                                    case NodeType.Identifier(base_id):
                                        full_path = base_id.clone()
                                        mut pi := 0
                                        while pi.lt(current_arg.params.len()) {
                                            mut param := Expr()
                                            current_arg.params.get(pi, param)
                                            switch param.node_type {
                                            case NodeType.Identifier(field_name):
                                                full_path = format(full_path, ".", field_name)
                                            case:
                                                throw e.lang_error(context.path, "eval", "Field access must use identifiers")
                                            }
                                            pi = pi.add(1)
                                        }
                                        source_id = full_path
                                    case:
                                        // For non-identifier expressions (like Vec.new(Expr)),
                                        // use the result_str which contains the allocated result
                                        source_id = result_str.clone()
                                    }
                                } else {
                                    switch current_arg.node_type {
                                    case NodeType.Identifier(ident_name):
                                        source_id = ident_name.clone()
                                    case:
                                        // For non-identifier expressions (like Vec.new(Expr)),
                                        // use the result_str which contains the allocated result
                                        source_id = result_str.clone()
                                    }
                                }

                                mut is_identifier := false
                                switch current_arg.node_type {
                                case NodeType.Identifier:
                                    is_identifier = true
                                case:
                                }
                                if is_identifier {
                                    id_ := source_id // Use the full path we calculated
                                    // If source and dest have the same name, we need to save the source offsets
                                    // before insert_struct overwrites them
                                    mut saved_offsets := SavedOffsets()
                                    mut has_saved_offsets := false
                                    if id_.eq(arg.name) {
                                        mut offsets := Vec.new(ArenaMapping)
                                        // Save all arena_index entries that start with the struct name
                                        // This includes the base offset and all nested field offsets
                                        prefix := format(id_, ".")
                                        last_frame := context.scope_stack.last_frame()
                                        arena_keys := last_frame.arena_index.keys
                                        mut ki := 0
                                        while ki.lt(arena_keys.len()) {
                                            mut key := ""
                                            arena_keys.get(ki, key)
                                            mut should_copy := false
                                            if key.eq(id_) {
                                                should_copy = true
                                            } else if key.starts_with(prefix) {
                                                should_copy = true
                                            }
                                            if should_copy {
                                                mut offset_val := 0
                                                last_frame.arena_index.get(key, offset_val)
                                                mut mapping := ArenaMapping()
                                                mapping.name = key.clone()
                                                mapping.offset = offset_val
                                                offsets.push(mapping)
                                            }
                                            ki = ki.add(1)
                                        }
                                        saved_offsets.offsets = offsets
                                        saved_offsets.temp_src_key = format("__temp_src_", id_)
                                        has_saved_offsets = true
                                    }

                                    // For pass-by-reference (non-copy, non-own, non-Type), just share the offset
                                    mut should_share_offset := false
                                    if not(arg.is_copy) {
                                        if not(arg.is_own) {
                                            if not(custom_type_name.eq("Type")) {
                                                should_share_offset = true
                                            }
                                        }
                                    }
                                    if should_share_offset {
                                        mut src_offset := 0
                                        mut src_offset_found := false
                                        src_offset = context.scope_stack.lookup_var(id_)
                                        src_offset_found = true
                                        catch (err: KeyNotFoundError) { }
                                        if not(src_offset_found) {
                                            if id_.contains(".") {
                                                // Field path - calculate offset dynamically
                                                src_offset = context.get_field_offset(id_)
                                            } else {
                                                throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context arena_index"))
                                            }
                                        }

                                        // Create symbol for parameter
                                        function_frame.symbols.insert(arg.name.clone(), SymbolInfo.new(resolved_value_type, arg.is_mut, arg.is_copy, arg.is_own))

                                        // Share the offset (pass-by-reference)
                                        function_frame.arena_index.insert(arg.name.clone(), src_offset)

                                        // Copy nested field offsets (e.g., "o1.inner_vec._len" -> "self._len")
                                        // Must search ALL frames because globals like `true` are in frame 0
                                        prefix := format(id_, ".")
                                        replacement_prefix := format(arg.name, ".")
                                        mut field_offsets_to_copy := Vec.new(ArenaMapping)
                                        mut field_symbols_to_copy := Vec.new(SymbolEntry)
                                        mut fi := 0
                                        while fi.lt(context.scope_stack.frames.len()) {
                                            mut caller_frame := ScopeFrame()
                                            context.scope_stack.frames.get(fi, caller_frame)
                                            // Copy arena_index entries
                                            arena_keys := caller_frame.arena_index.keys
                                            mut aki := 0
                                            while aki.lt(arena_keys.len()) {
                                                mut key := ""
                                                arena_keys.get(aki, key)
                                                if key.starts_with(prefix) {
                                                    mut value := 0
                                                    caller_frame.arena_index.get(key, value)
                                                    mut new_key := key.replace(prefix, replacement_prefix)
                                                    mut mapping := ArenaMapping()
                                                    mapping.name = new_key
                                                    mapping.offset = value
                                                    field_offsets_to_copy.push(mapping)
                                                }
                                                aki = aki.add(1)
                                            }
                                            // Copy symbols entries
                                            symbol_keys := caller_frame.symbols.keys
                                            mut ski := 0
                                            while ski.lt(symbol_keys.len()) {
                                                mut skey := ""
                                                symbol_keys.get(ski, skey)
                                                if skey.starts_with(prefix) {
                                                    mut svalue := SymbolInfo()
                                                    caller_frame.symbols.get(skey, svalue)
                                                    new_skey := skey.replace(prefix, replacement_prefix)
                                                    mut entry := SymbolEntry()
                                                    entry.name = new_skey
                                                    entry.info = svalue.clone()
                                                    field_symbols_to_copy.push(entry)
                                                }
                                                ski = ski.add(1)
                                            }
                                            fi = fi.add(1)
                                        }
                                        // Insert collected offsets
                                        mut foi := 0
                                        while foi.lt(field_offsets_to_copy.len()) {
                                            mut mapping := ArenaMapping()
                                            field_offsets_to_copy.get(foi, mapping)
                                            function_frame.arena_index.insert(mapping.name, mapping.offset)
                                            foi = foi.add(1)
                                        }
                                        // Insert collected symbols
                                        mut fsi := 0
                                        while fsi.lt(field_symbols_to_copy.len()) {
                                            mut entry := SymbolEntry()
                                            field_symbols_to_copy.get(fsi, entry)
                                            function_frame.symbols.insert(entry.name, entry.info)
                                            fsi = fsi.add(1)
                                        }

                                        // Track that this was passed by reference
                                        pass_by_ref_params.push(arg.name.clone())
                                    }
                                    if not(should_share_offset) {
                                        // For copy parameters, allocate and copy
                                        insert_struct_instance_into_frame(context, function_frame, arg.name, custom_type_name, e)

                                        // Push frame temporarily for copy_fields (needs dest accessible)
                                        context.scope_stack.frames.push(function_frame)

                                        // If we saved offsets, restore them with temp keys for copy_fields
                                        if has_saved_offsets {
                                            mut mi := 0
                                            while mi.lt(saved_offsets.offsets.len()) {
                                                mut mapping := ArenaMapping()
                                                saved_offsets.offsets.get(mi, mapping)
                                                mut new_key := ""
                                                if mapping.name.eq(id_) {
                                                    new_key = saved_offsets.temp_src_key.clone()
                                                } else if mapping.name.starts_with(format(id_, ".")) {
                                                    new_key = format(saved_offsets.temp_src_key, mapping.name.get_substr(id_.len(), mapping.name.len()))
                                                } else {
                                                    new_key = mapping.name.clone()
                                                }
                                                mut lf9_idx := context.scope_stack.frames.len().sub(1)
                                                mut lf9 := ScopeFrame()
                                                context.scope_stack.frames.get(lf9_idx, lf9)
                                                lf9.arena_index.insert(new_key, mapping.offset)
                                                context.scope_stack.frames.set(lf9_idx, lf9)
                                                mi = mi.add(1)
                                            }

                                            Arena.copy_fields(context, custom_type_name, saved_offsets.temp_src_key, arg.name, e)

                                            // Clean up temp keys
                                            mut ci := 0
                                            while ci.lt(saved_offsets.offsets.len()) {
                                                mut mapping := ArenaMapping()
                                                saved_offsets.offsets.get(ci, mapping)
                                                mut new_key := ""
                                                if mapping.name.eq(id_) {
                                                    new_key = saved_offsets.temp_src_key.clone()
                                                } else if mapping.name.starts_with(format(id_, ".")) {
                                                    new_key = format(saved_offsets.temp_src_key, mapping.name.get_substr(id_.len(), mapping.name.len()))
                                                } else {
                                                    new_key = mapping.name.clone()
                                                }
                                                _ := context.scope_stack.remove_var(new_key)
                                                ci = ci.add(1)
                                            }
                                        } else {
                                            // Temporarily register source struct's base offset and symbol
                                            // so that copy_fields() can calculate field offsets dynamically
                                            mut src_offset := 0
                                            mut src_offset_found := false
                                            src_offset = context.scope_stack.lookup_var(id_)
                                            src_offset_found = true
                                            catch (err: KeyNotFoundError) { }
                                            if not(src_offset_found) {
                                                if id_.contains(".") {
                                                    // Field path - calculate offset dynamically
                                                    src_offset = context.get_field_offset(id_)
                                                } else {
                                                    throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context arena_index"))
                                                }
                                            }
                                            mut src_symbol := SymbolInfo()
                                            mut src_symbol_found := false
                                            src_symbol = context.scope_stack.lookup_symbol(id_)
                                            src_symbol_found = true
                                            catch (err: KeyNotFoundError) { }
                                            if not(src_symbol_found) {
                                                throw e.lang_error(context.path, "eval", format("Source struct '", id_, "' not found in caller context symbols"))
                                            }

                                            mut lf10_idx := context.scope_stack.frames.len().sub(1)
                                            mut lf10 := ScopeFrame()
                                            context.scope_stack.frames.get(lf10_idx, lf10)
                                            lf10.arena_index.insert(id_.clone(), src_offset)
                                            context.scope_stack.frames.set(lf10_idx, lf10)
                                            context.scope_stack.declare_symbol(id_.clone(), src_symbol.clone())
                                            Arena.copy_fields(context, custom_type_name, id_, arg.name, e)
                                            _ := context.scope_stack.remove_var(id_)
                                            _ := context.scope_stack.remove_symbol(id_)
                                        }

                                        // Pop frame back for remaining arg processing
                                        function_frame = context.scope_stack.pop()
                                    }
                                } else {
                                    // For expression arguments (like Vec.new(Expr)), the struct is already
                                    // allocated and evaluated in result_str. We need to copy it to the parameter.
                                    insert_struct_instance_into_frame(context, function_frame, arg.name, custom_type_name, e)

                                    // Push frame temporarily for copy_fields
                                    context.scope_stack.frames.push(function_frame)

                                    // Temporarily register source for copy_fields
                                    mut src_offset := 0
                                    catch (err: KeyNotFoundError) {
                                        src_offset = context.scope_stack.lookup_var(source_id)
                                    }
                                    mut src_symbol := SymbolInfo()
                                    mut src_symbol_found := false
                                    catch (err: KeyNotFoundError) {
                                        src_symbol = context.scope_stack.lookup_symbol(source_id)
                                        src_symbol_found = true
                                    }
                                    if not(src_symbol_found) {
                                        throw e.lang_error(context.path, "eval", format("Source symbol '", source_id, "' not found"))
                                    }

                                    mut lf11_idx := context.scope_stack.frames.len().sub(1)
                                    mut lf11 := ScopeFrame()
                                    context.scope_stack.frames.get(lf11_idx, lf11)
                                    lf11.arena_index.insert(source_id.clone(), src_offset)
                                    context.scope_stack.frames.set(lf11_idx, lf11)
                                    context.scope_stack.declare_symbol(source_id.clone(), src_symbol.clone())
                                    Arena.copy_fields(context, custom_type_name, source_id, arg.name, e)
                                    _ := context.scope_stack.remove_var(source_id)
                                    _ := context.scope_stack.remove_symbol(source_id)

                                    // Pop frame back for remaining arg processing
                                    function_frame = context.scope_stack.pop()

                                    // For own parameters, remove the source from caller's context (ownership transferred)
                                    if arg.is_own {
                                        _ := context.scope_stack.remove_var(source_id)
                                        _ := context.scope_stack.remove_symbol(source_id)
                                        // Also remove field entries
                                        prefix := format(source_id, ".")
                                        mut keys_to_remove := Vec.new(Str)
                                        lf7 := context.scope_stack.last_frame()
                                        arena_keys := lf7.arena_index.keys
                                        mut ki := 0
                                        while ki.lt(arena_keys.len()) {
                                            mut key := ""
                                            arena_keys.get(ki, key)
                                            if key.starts_with(prefix) {
                                                keys_to_remove.push(key.clone())
                                            }
                                            ki = ki.add(1)
                                        }
                                        mut ri := 0
                                        while ri.lt(keys_to_remove.len()) {
                                            mut key := ""
                                            keys_to_remove.get(ri, key)
                                            _ := context.scope_stack.remove_var(key)
                                            _ := context.scope_stack.remove_symbol(key)
                                            ri = ri.add(1)
                                        }
                                    }
                                }
                            } else {
                                throw e.lang_error(context.path, "eval", format("Cannot use '", arg.name, "' of type '", custom_type_name, "' as an argument. Custom types can only be struct or enum."))
                            }
                        }
                        } // end switch custom_type_name
                    } // end if not(pass_by_ref_done)
                } // end if not(own_handled)

            case:
                throw e.todo_error(context.path, "eval", format("Cannot use '", arg.name, "' of type '", value_type_to_str(arg.value_type), "' as an argument. Only enum custom types allowed for now."))
            }

            param_index = param_index.add(1)
        }
        arg_i = arg_i.add(1)
    }

    // Push the populated frame and set function path
    context.scope_stack.frames.push(function_frame)
    context.path = func_def.source_path.clone()

    result := eval_body(context, func_def.body)
    if result.is_throw {
        // When throwing from a method, we need to copy the thrown struct's arena_index entries
        // from the function frame to the caller frame so that catch blocks can access fields
        if not(result.thrown_type.eq("")) {
            thrown_type_name := result.thrown_type
            // Check if this is a custom type (struct)
            mut type_symbol := SymbolInfo()
            mut type_symbol_found := false
            type_symbol = context.scope_stack.lookup_symbol(thrown_type_name)
            type_symbol_found = true
            catch (err: KeyNotFoundError) { }
            if type_symbol_found {
                mut is_struct_def := false
                switch type_symbol.value_type {
                case ValueType.TType(ttype_val2):
                    switch ttype_val2 {
                    case TTypeDef.TStructDef:
                        is_struct_def = true
                    case:
                    }
                case:
                }
                if is_struct_def {
                    // Copy the base variable entry first (from function frame to caller frame)
                    mut base_offset := 0
                    mut base_offset_found := false
                    base_offset = context.scope_stack.lookup_var(result.value)
                    base_offset_found = true
                    catch (err: KeyNotFoundError) { }
                    if base_offset_found {
                        // Get the second-to-last frame (caller's frame)
                        frame_count := context.scope_stack.frames.len()
                        if frame_count.gteq(2) {
                            mut caller_frame := ScopeFrame()
                            context.scope_stack.frames.get(frame_count.sub(2), caller_frame)
                            caller_frame.arena_index.insert(result.value.clone(), base_offset)
                            context.scope_stack.frames.set(frame_count.sub(2), caller_frame)
                        }
                    }

                    // Copy arena_index and symbol entries for the thrown instance's fields
                    source_prefix := format(result.value, ".")

                    // Copy arena_index entries (including nested fields like .msg.c_string)
                    mut keys_to_copy := Vec.new(Str)
                    lf8 := context.scope_stack.last_frame()
                    arena_keys := lf8.arena_index.keys
                    mut ki := 0
                    while ki.lt(arena_keys.len()) {
                        mut key := ""
                        arena_keys.get(ki, key)
                        if key.starts_with(source_prefix) {
                            keys_to_copy.push(key.clone())
                        }
                        ki = ki.add(1)
                    }
                    frame_count := context.scope_stack.frames.len()
                    mut kci := 0
                    while kci.lt(keys_to_copy.len()) {
                        mut src_key := ""
                        keys_to_copy.get(kci, src_key)
                        mut src_offset := 0
                        mut src_offset_found := false
                        src_offset = context.scope_stack.lookup_var(src_key)
                        src_offset_found = true
                        catch (err: KeyNotFoundError) { }
                        if src_offset_found {
                            if frame_count.gteq(2) {
                                mut caller_frame := ScopeFrame()
                                context.scope_stack.frames.get(frame_count.sub(2), caller_frame)
                                caller_frame.arena_index.insert(src_key.clone(), src_offset)
                                context.scope_stack.frames.set(frame_count.sub(2), caller_frame)
                            }
                        }
                        kci = kci.add(1)
                    }

                    // Copy symbol entries for fields
                    symbol_keys_to_copy := context.scope_stack.get_symbols_with_prefix(source_prefix)
                    mut ski := 0
                    while ski.lt(symbol_keys_to_copy.len()) {
                        mut src_key := ""
                        symbol_keys_to_copy.get(ski, src_key)
                        mut src_symbol := SymbolInfo()
                        mut src_symbol_found := false
                        src_symbol = context.scope_stack.lookup_symbol(src_key)
                        src_symbol_found = true
                        catch (err: KeyNotFoundError) { }
                        if src_symbol_found {
                            context.scope_stack.declare_symbol(src_key.clone(), src_symbol.clone())
                        }
                        ski = ski.add(1)
                    }
                }
            }
        }
        // Pop frame and restore path before returning
        _ := context.scope_stack.pop()
        context.path = saved_path
        return result // CLEANUP SITE 3: Propagate throw from function body
    }
    result_str := result.value

    // Save struct/enum return value info BEFORE popping (needed for return handling)
    mut saved_return_offset := 0
    mut has_saved_return_offset := false
    if func_def.return_types.len().eq(1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)
        mut is_tcustom := false
        mut custom_type_name := ""
        switch return_type {
        case ValueType.TCustom(custom_name):
            is_tcustom = true
            custom_type_name = custom_name
        case:
        }
        if is_tcustom {
            switch custom_type_name {
            case "I64":
            case "U8":
            case "Str":
                // None for primitives
            case:
                saved_return_offset = context.scope_stack.lookup_var(result_str)
                has_saved_return_offset = true
                catch (err: KeyNotFoundError) { }
            }
        }
    }

    // Save enum value if returning an enum variable (not constructor)
    mut saved_enum_value := EnumVal()
    mut has_saved_enum_value := false
    if func_def.return_types.len().eq(1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)
        mut is_tcustom := false
        mut custom_type_name := ""
        switch return_type {
        case ValueType.TCustom(custom_name):
            is_tcustom = true
            custom_type_name = custom_name
        case:
        }
        if is_tcustom {
            mut custom_symbol := SymbolInfo()
            mut custom_symbol_found := false
            custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)
            custom_symbol_found = true
            catch (err: KeyNotFoundError) { }
            if custom_symbol_found {
                mut is_enum_def := false
                switch custom_symbol.value_type {
                case ValueType.TType(ttype_val3):
                    switch ttype_val3 {
                    case TTypeDef.TEnumDef:
                        is_enum_def = true
                    case:
                    }
                case:
                }
                if is_enum_def {
                    if not(result_str.contains(".")) {
                        // This is a variable, not a constructor - save the enum value
                        saved_enum_value = Arena.get_enum(context, result_str, e)
                        has_saved_enum_value = true
                        catch (err: Str) { }
                    }
                }
            }
        }
    }

    // Collect mut_args values BEFORE popping the function frame
    // (we need to read from the function frame where the args live)
    // NOTE: MutArgValueType, MutArgValue, CollectedMutArg structs defined earlier
    mut collected_mut_args := Vec.new(CollectedMutArg)

    mut mi := 0
    while mi.lt(mut_args.len()) {
        mut m := MutArgEntry()
        mut_args.get(mi, m)
        // Check if this arg was passed by ref
        mut was_passed_by_ref := false
        mut ref_check_i := 0
        while ref_check_i.lt(pass_by_ref_params.len()) {
            mut ref_param := ""
            pass_by_ref_params.get(ref_check_i, ref_param)
            if ref_param.eq(m.arg_name) {
                was_passed_by_ref = true
            }
            ref_check_i = ref_check_i.add(1)
        }

        mut is_tcustom := false
        mut type_name := ""
        switch m.value_type {
        case ValueType.TCustom:
            is_tcustom = true
            type_name = m.value_type.TCustom.name
        case:
        }

        if is_tcustom {
            switch type_name {
            case "I64":
                i64_val := Arena.get_i64(context, m.arg_name, e)
                collected_mut_args.push(CollectedMutArg.new(m.source_name.clone(), MutArgValue.I64(i64_val)))
            case "U8":
                u8_val : U8 = Arena.get_u8(context, m.arg_name, e)
                collected_mut_args.push(CollectedMutArg.new(m.source_name.clone(), MutArgValue.U8(u8_val)))
            case "Str":
                val := string_from_context(context, m.arg_name, e)
                collected_mut_args.push(CollectedMutArg.new(m.source_name.clone(), MutArgValue.Str(val)))
            case:
                // Custom type (enum or struct)
                mut symbol_info := SymbolInfo()
                mut symbol_info_found := false
                symbol_info = context.scope_stack.lookup_symbol(type_name)
                symbol_info_found = true
                catch (err: KeyNotFoundError) { }
                if not(symbol_info_found) {
                    _ := context.scope_stack.pop()
                    context.path = saved_path
                    throw e.lang_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", type_name, "' as an mut argument. Undefined symbol."))
                }
                mut is_enum_def := false
                mut is_struct_def := false
                switch symbol_info.value_type {
                case ValueType.TType(ttype_val4):
                    switch ttype_val4 {
                    case TTypeDef.TEnumDef:
                        is_enum_def = true
                    case TTypeDef.TStructDef:
                        is_struct_def = true
                    }
                case:
                }
                if is_enum_def {
                    enum_val := Arena.get_enum(context, m.arg_name, e)
                    collected_mut_args.push(CollectedMutArg.new(m.source_name.clone(), MutArgValue.Enum(enum_val)))
                } else if is_struct_def {
                    mut offset := 0
                    mut offset_found := false
                    offset = context.scope_stack.lookup_var(m.arg_name)
                    offset_found = true
                    catch (err: KeyNotFoundError) { }
                    if offset_found {
                        collected_mut_args.push(CollectedMutArg.new(m.source_name.clone(), MutArgValue.Struct(MutArgStructData.new(offset, type_name.clone(), was_passed_by_ref))))
                    } else {
                        _ := context.scope_stack.pop()
                        context.path = saved_path
                        throw e.lang_error(context.path, "eval", format("Missing struct arena index for argument '", m.arg_name, "'"))
                    }
                } else {
                    _ := context.scope_stack.pop()
                    context.path = saved_path
                    throw e.lang_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", type_name, "' as a mut argument. Not an enum or struct, but a '", value_type_to_str(symbol_info.value_type), "'."))
                }
            }
        } else {
            _ := context.scope_stack.pop()
            context.path = saved_path
            throw e.todo_error(context.path, "eval", format("Cannot use '", m.arg_name, "' of type '", value_type_to_str(m.value_type), "' as a mut argument. Only structs and enums allowed for now."))
        }
        mi = mi.add(1)
    }

    // Pop function frame BEFORE writing mut args back to caller
    _ := context.scope_stack.pop()
    context.path = saved_path.clone()

    // Write collected mut_args values to caller's frame (now on top)
    mut ci := 0
    while ci.lt(collected_mut_args.len()) {
        mut c := CollectedMutArg()
        collected_mut_args.get(ci, c)
        switch c.value {
        case MutArgValue.I64(val):
            _ := Arena.insert_i64(context, c.source_name, I64.to_str(val), e)
        case MutArgValue.U8(val):
            _ := Arena.insert_u8(context, c.source_name, U8.to_str(val), e)
        case MutArgValue.Str(val):
            _ := Arena.insert_string(context, c.source_name, val, e)
        case MutArgValue.Enum(enum_val):
            _ := Arena.insert_enum(context, c.source_name, enum_val.enum_type, format(enum_val.enum_type, ".", enum_val.enum_name), e)
        case MutArgValue.Struct(struct_data):
            mut lf12_idx := context.scope_stack.frames.len().sub(1)
            mut lf12 := ScopeFrame()
            context.scope_stack.frames.get(lf12_idx, lf12)
            lf12.arena_index.insert(c.source_name.clone(), struct_data.offset)
            context.scope_stack.frames.set(lf12_idx, lf12)
            if not(struct_data.was_passed_by_ref) {
                context.map_instance_fields(struct_data.type_name, c.source_name, e)
            }
        }
        ci = ci.add(1)
    }

    // If function returns a user-defined struct or enum, copy it back to caller frame as temp return val
    // NOTE: Frame already popped above, using saved_return_offset and saved_enum_value
    if func_def.return_types.len().eq(1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)
        mut is_tcustom := false
        mut custom_type_name := ""
        switch return_type {
        case ValueType.TCustom(custom_name):
            is_tcustom = true
            custom_type_name = custom_name
        case:
        }
        if is_tcustom {
            // Skip primitive types I64, U8, Str - they return values directly
            switch custom_type_name {
            case "I64":
            case "U8":
            case "Str":
                // Do nothing for primitive types
            case:
                mut custom_symbol := SymbolInfo()
                mut custom_symbol_found := false
                custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)
                custom_symbol_found = true
                catch (err: KeyNotFoundError) { }
                if custom_symbol_found {
                    mut is_struct_def := false
                    mut is_enum_def := false
                    switch custom_symbol.value_type {
                    case ValueType.TType(ttype_val5):
                        switch ttype_val5 {
                        case TTypeDef.TStructDef:
                            is_struct_def = true
                        case TTypeDef.TEnumDef:
                            is_enum_def = true
                        }
                    case:
                    }
                    if is_struct_def {
                        return_instance := format(RETURN_INSTANCE_NAME, I64.to_str(arena.temp_id_counter))
                        arena.temp_id_counter = arena.temp_id_counter.add(1)

                        // Use saved offset (saved before popping)
                        if not(has_saved_return_offset) {
                            throw e.lang_error(context.path, "eval", format("Missing arena index for return value '", result_str, "'"))
                        }
                        offset := saved_return_offset

                        // Insert the temporary return variable into the caller's frame
                        context.scope_stack.declare_symbol(return_instance.clone(), SymbolInfo.new(ValueType.TCustom(custom_type_name.clone()), true, false, false))

                        // Share the base offset in caller's frame
                        mut lf13_idx := context.scope_stack.frames.len().sub(1)
                        mut lf13 := ScopeFrame()
                        context.scope_stack.frames.get(lf13_idx, lf13)
                        lf13.arena_index.insert(return_instance.clone(), offset)
                        context.scope_stack.frames.set(lf13_idx, lf13)

                        return EvalResult.new_return(return_instance) // CLEANUP SITE 4: Return struct instance
                    } else if is_enum_def {
                        // For enum returns, check if result_str is a constructor expression or a variable
                        if result_str.contains(".") {
                            // This is a constructor expression - just return as-is
                            return EvalResult.new(result_str) // CLEANUP SITE 5: Return enum constructor
                        }

                        // This is a variable, use saved enum value
                        if not(has_saved_enum_value) {
                            throw e.lang_error(context.path, "eval", format("Missing enum value for return value '", result_str, "'"))
                        }

                        return_instance := format(RETURN_INSTANCE_NAME, I64.to_str(arena.temp_id_counter))
                        arena.temp_id_counter = arena.temp_id_counter.add(1)

                        // Set temp_enum_payload if the enum has a payload
                        if not(NULL.eq(saved_enum_value.payload.data)) {
                            mut payload_vec := Vec.new(U8)
                            memcpy(to_ptr(payload_vec), saved_enum_value.payload.data, size_of(Vec))
                            if not(NULL.eq(saved_enum_value.payload_type.data)) {
                                mut payload_type := ValueType.TCustom("")
                                memcpy(to_ptr(payload_type), saved_enum_value.payload_type.data, size_of(ValueType))
                                mut temp_payload := EnumPayload.new(payload_vec.clone(), payload_type)
                                context.temp_enum_payload.data = to_ptr(temp_payload)
                            }
                        }

                        _ := Arena.insert_enum(context, return_instance, saved_enum_value.enum_type, format(saved_enum_value.enum_type, ".", saved_enum_value.enum_name), e)
                        return EvalResult.new_return(return_instance) // CLEANUP SITE 6: Return enum variable
                    }
                }
            }
        }
    }

    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: DuplicatedKeyError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }

    // Frame already popped above
    return EvalResult.new(result_str) // CLEANUP SITE 7: Return normal value (final return)
}

// ---------- Core function/procedure dispatcher

eval_core_func_proc_call := proc(name: Str, mut context: Context, e: Expr, is_proc: Bool) returns EvalResult throws Str {
    if name.eq("loc") {
        return func_loc(context, e)
    } else if name.eq("_file") {
        return func_file(context, e)
    } else if name.eq("_line") {
        return func_line(context, e)
    } else if name.eq("_col") {
        return func_col(context, e)
    } else if name.eq("size_of") {
        return func_size_of(context, e)
    } else if name.eq("type_as_str") {
        return func_type_as_str(context, e)
    } else if name.eq("to_ptr") {
        return func_to_ptr(context, e)
    } else if name.eq("malloc") {
        return func_malloc(context, e)
    } else if name.eq("free") {
        return func_free(context, e)
    } else if name.eq("memset") {
        return func_memset(context, e)
    } else if name.eq("memcpy") {
        return func_memcpy(context, e)
    } else if name.eq("memcmp") {
        return func_memcmp(context, e)
    } else if name.eq("lt") {
        return func_lt(context, e)
    } else if name.eq("gt") {
        return func_gt(context, e)
    } else if name.eq("add") {
        return func_add(context, e)
    } else if name.eq("sub") {
        return func_sub(context, e)
    } else if name.eq("mul") {
        return func_mul(context, e)
    } else if name.eq("div") {
        return func_div(context, e)
    } else if name.eq("mod") {
        return func_mod(context, e)
    } else if name.eq("str_to_i64") {
        return func_str_to_i64(context, e)
    } else if name.eq("i64_to_str") {
        return func_i64_to_str(context, e)
    } else if name.eq("enum_to_str") {
        return func_enum_to_str(context, e)
    } else if name.eq("u8_to_i64") {
        return func_u8_to_i64(context, e)
    } else if name.eq("i64_to_u8") {
        return func_i64_to_u8(context, e)
    } else if name.eq("eval_to_str") {
        return proc_eval_to_str(context, e)
    } else if name.eq("exit") {
        return func_exit(context, e)
    } else if name.eq("import") {
        return proc_import(context, e)
    } else if name.eq("input_read_line") {
        return proc_input_read_line(context, e)
    } else if name.eq("single_print") {
        return proc_single_print(context, e)
    } else if name.eq("print_flush") {
        return proc_print_flush(context, e)
    } else if name.eq("readfile") {
        return proc_readfile(context, e)
    } else if name.eq("run_cmd") {
        return proc_run_cmd(context, e)
    } else if name.eq("runfile") {
        return proc_runfile(context, e)
    } else if name.eq("has_const") {
        return func_has_const(context, e)
    } else if name.eq("has_field") {
        return func_has_field(context, e)
    } else {
        if is_proc {
            throw e.lang_error(context.path, "eval", format("Core procedure '", name, "' not implemented."))
        } else {
            throw e.lang_error(context.path, "eval", format("Core function '", name, "' not implemented."))
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: U8_OverflowError) { throw err.msg }
    return EvalResult.new("")
}

// ---------- main_run, run_file_with_context, run_file (like rstil.rs)

/// Main run function - lexes, parses, inits, typechecks, and evaluates source code
/// Follows rstil.rs main_run implementation
main_run := proc(print_extra: Bool, skip_init_and_typecheck: Bool, mut context: Context, path: Str, source: Str, main_args: Vec) returns EvalResult throws Str {
    // Mark main file as "done" to prevent re-processing via circular imports
    _ := context.imports_init_done.insert(path.clone())
    _ := context.imports_typer_done.insert(path.clone())
    _ := context.imports_eval_done.insert(path.clone())
    catch (err: AllocError) { throw err.msg }

    // Lex source
    mut lexer := lexer_from_source(path, source)
    catch (err: Str) {
        throw format(path, ":", err)
    }
    catch (err: IndexOutOfBoundsError) {
        throw format(path, ":", err.msg)
    }

    // Parse mode
    mut parsed_mode := parse_mode(path, lexer)
    catch (err: Str) {
        throw format(path, ":", err)
    }
    context.mode_def = parsed_mode
    if print_extra {
        println("Mode: ", context.mode_def.name)
    }

    // Process mode imports (e.g., test mode auto-imports test helpers)
    mut import_idx := 0
    while import_idx.lt(context.mode_def.imports.len()) {
        mut import_str := ""
        context.mode_def.imports.get(import_idx, import_str)

        // Create synthetic import expression
        mut import_func_name_expr := Expr()
        import_func_name_expr.node_type = NodeType.Identifier("import")
        import_func_name_expr.line = 0
        import_func_name_expr.col = 0

        mut import_path_expr := Expr()
        import_path_expr.node_type = NodeType.LLiteral(Literal.Str(import_str))
        import_path_expr.line = 0
        import_path_expr.col = 0

        mut import_fcall_expr := Expr()
        import_fcall_expr.node_type = NodeType.FCall
        import_fcall_expr.params.push(import_func_name_expr)
        import_fcall_expr.params.push(import_path_expr)
        import_fcall_expr.line = 0
        import_fcall_expr.col = 0

        // Mode imports need full processing: init, typer, eval
        init_import_declarations(context, import_fcall_expr, import_str)
        catch (err: Str) {
            throw format(path, ":", err)
        }

        typer_errors := typer_import_declarations(context, import_str)
        if typer_errors.len().gt(0) {
            mut err_idx := 0
            while err_idx.lt(typer_errors.len()) {
                mut err_msg := ""
                typer_errors.get(err_idx, err_msg)
                println(path, ":", err_msg)
                err_idx = err_idx.add(1)
            }
            throw format("Compiler errors: ", typer_errors.len().to_str(), " type errors found")
        }

        // Eval the import
        _ := proc_import(context, import_fcall_expr)
        catch (err: Str) {
            throw format(path, ":", err)
        }

        import_idx = import_idx.add(1)
    }

    // Parse the body
    mut e := parse_tokens(lexer)
    catch (err: Str) {
        throw format(path, ":", err)
    }
    catch (err: IndexOutOfBoundsError) {
        throw format(path, ":", err.msg)
    }

    // Skip init and type checking if this is Phase 2 of a two-phase import
    if not(skip_init_and_typecheck) {
        mut errors := init_context(context, e)
        catch (err: Str) {
            throw format(path, ":", err)
        }

        if errors.len().gt(0) {
            mut err_idx := 0
            while err_idx.lt(errors.len()) {
                mut err_msg := ""
                errors.get(err_idx, err_msg)
                println(path, ":", err_msg)
                err_idx = err_idx.add(1)
            }
            throw format("Compiler errors: ", errors.len().to_str(), " declaration errors found")
        }

        mode_errors := basic_mode_checks(context, e)
        catch (err: Str) {
            throw format(path, ":", err)
        }
        mut mode_err_idx := 0
        while mode_err_idx.lt(mode_errors.len()) {
            mut mode_err := ""
            mode_errors.get(mode_err_idx, mode_err)
            errors.push(mode_err)
            mode_err_idx = mode_err_idx.add(1)
        }

        // For modes that require a main proc, add an implicit call to main
        if context.mode_def.needs_main_proc {
            mut main_ident_expr := Expr()
            main_ident_expr.node_type = NodeType.Identifier("main")
            main_ident_expr.line = 0
            main_ident_expr.col = 0

            mut main_call_expr := Expr()
            main_call_expr.node_type = NodeType.FCall
            main_call_expr.params.push(main_ident_expr)
            main_call_expr.line = 0
            main_call_expr.col = 0

            // Add string args
            mut arg_idx := 0
            while arg_idx.lt(main_args.len()) {
                mut arg_str := ""
                main_args.get(arg_idx, arg_str)
                mut arg_expr := Expr()
                arg_expr.node_type = NodeType.LLiteral(Literal.Str(arg_str))
                arg_expr.line = 0
                arg_expr.col = 0
                main_call_expr.params.push(arg_expr)
                arg_idx = arg_idx.add(1)
            }

            e.params.push(main_call_expr)
        }

        type_errors := check_types(context, e)
        catch (err: Str) {
            throw format(path, ":", err)
        }
        mut type_err_idx := 0
        while type_err_idx.lt(type_errors.len()) {
            mut type_err := ""
            type_errors.get(type_err_idx, type_err)
            errors.push(type_err)
            type_err_idx = type_err_idx.add(1)
        }

        // TODO: check_body_returns_throws for root body - needs SFuncDef and ThrownType
        // For now, skip this check (can be added post-self-hosting)

        if errors.len().gt(0) {
            mut err_idx := 0
            while err_idx.lt(errors.len()) {
                mut err_msg := ""
                errors.get(err_idx, err_msg)
                println(path, ":", err_msg)
                err_idx = err_idx.add(1)
            }
            throw format("Compiler errors: ", errors.len().to_str(), " type errors found")
        }

        // Precomputation phase: Transform UFCS calls into regular function calls
        e = precomp_expr(context, e)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    // Evaluate the expression
    eval_result := eval_expr(context, e)
    if eval_result.is_throw {
        throw format(path, ":", eval_result.value)
    }
    return eval_result
}

/// Run a file with an existing context (for imports)
/// Follows rstil.rs run_file_with_context implementation
run_file_with_context := proc(is_import: Bool, skip_init: Bool, mut context: Context, path: Str, main_args: Vec) returns EvalResult throws Str {
    mut previous_mode := context.mode_def
    if not(is_import) {
        println("Running file '", path, "'")
    }

    source := readfile(path)
    // Note: readfile is ext_proc - if it fails, the error propagates automatically

    run_result := main_run(not(is_import), skip_init, context, path, source, main_args)

    if is_import {
        if not(can_be_imported(context.mode_def)) {
            throw format("file '", path, "' of mode '", context.mode_def.name, "' cannot be imported")
        }
    }

    context.mode_def = previous_mode  // restore the context mode of the calling file
    return run_result
}

/// Run a file from scratch (creates new context, imports core.til first)
/// Follows rstil.rs run_file implementation
run_file := proc(path: Str, main_args: Vec) returns EvalResult throws Str {
    mut context := Context.new(path, "lib")  // default mode, will be overwritten by file's mode
    // Context.new throws Str on error

    if not(path.eq("src/core/core.til")) {
        // Automatically import core.til (needs full init and eval, skip_init=false)
        core_path := "src/core/core.til"
        mut empty_args := Vec.new(Str)
        catch (err: AllocError) {
            throw err.msg
        }
        _ := run_file_with_context(true, false, context, core_path, empty_args)
    }

    return run_file_with_context(false, false, context, path, main_args)
}

// ---------- proc_eval_to_str, proc_runfile, proc_import (moved from ext.til)

proc_eval_to_str := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "eval_to_str", 1, true)

    path := "eval"  // Placeholder path
    source_expr := eval_expr(context, e.get(1))
    if source_expr.is_throw { return source_expr }

    str_source := format("mode script; ", source_expr.value)
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return main_run(false, false, context, path, str_source, Vec.new(Str))
}

proc_runfile := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    if e.params.len().lt(2) {
        throw e.lang_error(context.path, "eval", "Core proc 'runfile' expects at least 1 parameter")
    }

    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    path := result.value

    mut main_args := Vec.new(Str)
    for i in 2..e.params.len() {
        arg_result := eval_expr(context, e.get(i))
        if arg_result.is_throw { return arg_result }
        main_args.push(arg_result.value)
    }

    catch (err: AllocError) { throw err.msg }
    _ := run_file(path, main_args)
    return EvalResult.new("")
}

// import_path_to_file_path is defined in init.til

proc_import := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "import", 1, true)

    result := eval_expr(context, e.get(1))
    if result.is_throw {
        return result // Propagate throw
    }

    original_path := context.path.clone()
    path := import_path_to_file_path(result.value)

    // Already done (or in progress)? Skip.
    // Adding to done at START handles both circular imports and re-imports.
    if context.imports_eval_done.contains(path) {
        return EvalResult.new("")
    }

    // Mark as done immediately - before processing - to handle circular imports
    _ := context.imports_eval_done.insert(path.clone())

    // Get stored AST from init phase
    mut ast := Expr()
    if not(context.imported_asts.contains_key(path)) {
        throw e.error(context.path, "eval", format(
            "Import ", path, " not found in stored ASTs - init phase should have stored it"))
    }
    context.imported_asts.get(path, ast)
    catch (err: KeyNotFoundError) {
        throw e.error(context.path, "eval", format(
            "Import ", path, " not found in stored ASTs - init phase should have stored it"))
    }

    context.path = path.clone()

    // Just eval the stored AST - no re-parsing needed
    eval_result := eval_expr(context, ast)

    context.path = original_path

    if eval_result.is_throw {
        throw e.error(context.path, "eval", format(
            "While importing ", path, ":\n", eval_result.value))
    }
    catch (err: AllocError) { throw err.msg }
    return EvalResult.new("")
}
