// Target and Lang definitions for cross-compilation support
// Mirrors src/self/target.til

mode liba

// ---------- Lang enum - codegen backend languages

Lang := enum {
    C,
    HolyC,
    TIL,  // TIL-to-TIL (for debugging: shows desugared, dead-code-eliminated output)
    // Future: Mojo, WASM, etc.
}

lang_from_str := func(s: Str) returns Lang throws Str {
    switch s.to_lowercase() {
    case "c":
        return Lang.C
    case "holyc":
        return Lang.HolyC
    case "til":
        return Lang.TIL
    case:
        throw format("Unknown lang '", s, "'. Supported langs: c, holyc, til")
    }
}

lang_to_str := func(lang: Lang) returns Str {
    switch lang {
    case Lang.C:
        return "c"
    case Lang.HolyC:
        return "holyc"
    case Lang.TIL:
        return "til"
    }
}

lang_file_extension := func(lang: Lang) returns Str {
    switch lang {
    case Lang.C:
        return "c"
    case Lang.HolyC:
        return "hc"
    case Lang.TIL:
        return "til"
    }
}

// ---------- Target enum - supported platforms

Target := enum {
    LinuxX64,
    LinuxArm64,
    LinuxRiscv64,
    WindowsX64,
    MacosX64,
    MacosArm64,
    Wasm32,
    TempleosX86,
}

target_from_str := func(s: Str) returns Target throws Str {
    switch s.to_lowercase() {
    case "linux-x64":
        return Target.LinuxX64
    case "linux-x86_64":
        return Target.LinuxX64
    case "linux-amd64":
        return Target.LinuxX64
    case "linux-arm64":
        return Target.LinuxArm64
    case "linux-aarch64":
        return Target.LinuxArm64
    case "linux-riscv64":
        return Target.LinuxRiscv64
    case "linux-riscv":
        return Target.LinuxRiscv64
    case "riscv64":
        return Target.LinuxRiscv64
    case "windows-x64":
        return Target.WindowsX64
    case "windows-x86_64":
        return Target.WindowsX64
    case "win64":
        return Target.WindowsX64
    case "macos-x64":
        return Target.MacosX64
    case "macos-x86_64":
        return Target.MacosX64
    case "darwin-x64":
        return Target.MacosX64
    case "macos-arm64":
        return Target.MacosArm64
    case "macos-aarch64":
        return Target.MacosArm64
    case "darwin-arm64":
        return Target.MacosArm64
    case "wasm32":
        return Target.Wasm32
    case "wasm":
        return Target.Wasm32
    case "webassembly":
        return Target.Wasm32
    case "templeos-x86":
        return Target.TempleosX86
    case "templeos":
        return Target.TempleosX86
    case:
        throw format(
            "Unknown target '", s, "'. Supported targets: linux-x64, linux-arm64, linux-riscv64, windows-x64, macos-x64, macos-arm64, wasm32, templeos-x86"
        )
    }
}

target_to_str := func(target: Target) returns Str {
    switch target {
    case Target.LinuxX64:
        return "linux-x64"
    case Target.LinuxArm64:
        return "linux-arm64"
    case Target.LinuxRiscv64:
        return "linux-riscv64"
    case Target.WindowsX64:
        return "windows-x64"
    case Target.MacosX64:
        return "macos-x64"
    case Target.MacosArm64:
        return "macos-arm64"
    case Target.Wasm32:
        return "wasm32"
    case Target.TempleosX86:
        return "templeos-x86"
    }
}

// ---------- Target/Lang compatibility

default_lang_for_target := func(target: Target) returns Lang {
    switch target {
    case Target.TempleosX86:
        return Lang.HolyC
    case Target.LinuxX64:
        return Lang.C
    case Target.LinuxArm64:
        return Lang.C
    case Target.LinuxRiscv64:
        return Lang.C
    case Target.WindowsX64:
        return Lang.C
    case Target.MacosX64:
        return Lang.C
    case Target.MacosArm64:
        return Lang.C
    case Target.Wasm32:
        return Lang.C
    }
}

supported_langs_for_target := func(target: Target) returns Vec {
    mut result := Vec.new(Lang)
    switch target {
    case Target.TempleosX86:
        result.push(Lang.HolyC)
        result.push(Lang.TIL)
    case:
        result.push(Lang.C)
        result.push(Lang.TIL)  // TIL is always supported (for debugging)
    }
    return result
}

is_lang_supported_for_target := func(lang: Lang, target: Target) returns Bool {
    supported := supported_langs_for_target(target)
    lang_str := lang_to_str(lang)
    for l: Lang in supported {
        if lang_to_str(l).eq(lang_str) {
            return true
        }
    }
    return false
}

validate_lang_for_target := func(lang: Lang, target: Target) throws Str {
    if is_lang_supported_for_target(lang, target) {
        return
    }
    supported := supported_langs_for_target(target)
    mut supported_strs := Vec.new(Str)
    for l: Lang in supported {
        supported_strs.push(lang_to_str(l))
    }

    throw format(
        "Lang '", lang_to_str(lang), "' is not supported for target '", target_to_str(target),
        "'. Supported langs for this target: ", supported_strs.join(", ")
    )
}

// ---------- Toolchain commands

// Check if a compiler command is clang (for warning flag selection)
is_clang := func(cmd: Str) returns Bool {
    return cmd.contains("clang")
}

toolchain_command := func(target: Target, lang: Lang) returns Str throws Str {
    // TODO Issue #131: Add TIL_CC environment variable support when TIL has getenv()
    switch target {
    // Linux: gcc by default
    case Target.LinuxX64:
        switch lang {
        case Lang.C:
            return "gcc"
        case:
        }
    case Target.LinuxArm64:
        switch lang {
        case Lang.C:
            return "aarch64-linux-gnu-gcc"
        case:
        }
    case Target.LinuxRiscv64:
        switch lang {
        case Lang.C:
            return "riscv64-linux-gnu-gcc"
        case:
        }
    // Windows: mingw-gcc by default
    case Target.WindowsX64:
        switch lang {
        case Lang.C:
            return "x86_64-w64-mingw32-gcc"
        case:
        }
    // macOS: clang only (Apple's default, gcc is symlink to clang)
    case Target.MacosX64:
        switch lang {
        case Lang.C:
            return "clang"
        case:
        }
    case Target.MacosArm64:
        switch lang {
        case Lang.C:
            return "clang"
        case:
        }
    case Target.Wasm32:
        switch lang {
        case Lang.C:
            return "clang"
        case:
        }
    case Target.TempleosX86:
        switch lang {
        case Lang.HolyC:
            return "holyc"
        case:
        }
    }
    // Invalid combinations
    throw format(
        "No toolchain available for target '", target_to_str(target), "' with lang '", lang_to_str(lang), "'"
    )
}

// TODO: Bug #133 workaround - using proc instead of func to prevent precomputation
// of heap values. The returned Vec has pointers that are invalid at compile time.
toolchain_extra_args := proc(target: Target, _lang: Lang, compiler: Str) returns Vec {
    // Bug #99: -Wall -Wextra -Werror with suppressions for unfixed warnings.
    // Remove suppressions as warnings get fixed.
    // Note: Some flags are compiler-specific (gcc vs clang)
    mut result := Vec.new(Str)
    // Issue #131: Use compiler command to determine which flags to use
    use_clang := is_clang(compiler)
    switch target {
    // macOS and wasm always use clang target flags
    case Target.MacosArm64:
        result.push("-target")
        result.push("arm64-apple-macos11")
        push_common_flags(result)
        push_clang_flags(result)
        return result
    case Target.MacosX64:
        result.push("-target")
        result.push("x86_64-apple-macos10.12")
        push_common_flags(result)
        push_clang_flags(result)
        return result
    case Target.Wasm32:
        result.push("--target=wasm32")
        result.push("-nostdlib")
        result.push("-Wl,--no-entry")
        result.push("-Wl,--export-all")
        push_common_flags(result)
        push_clang_flags(result)
        return result
    case Target.TempleosX86:
        panic(loc(), "HolyC doesn't support these flags")
    case:
        // Linux/Windows - use compiler-specific flags based on --cc flag
        push_common_flags(result)
        if use_clang {
            push_clang_flags(result)
        } else {
            push_gcc_flags(result)
        }
        return result
    }
}

// Helper: push common warning flags (work on both gcc and clang)
push_common_flags := proc(mut result: Vec) {
    result.push("-Wall")
    result.push("-Wextra")
    result.push("-Werror")
    // Suppressions for unfixed warnings (Bug #99):
    result.push("-Wno-unused-variable")           // 1514 occurrences
    result.push("-Wno-unused-but-set-variable")   // 386 occurrences
    result.push("-Wno-unused-label")              // 153 occurrences
    result.push("-Wno-unused-parameter")          // underscore-prefixed params are intentionally unused
}

// Helper: push clang-specific flags
push_clang_flags := proc(mut result: Vec) {
    result.push("-Wno-sometimes-uninitialized")   // clang-specific warning about exception control flow
    result.push("-Wno-self-assign")               // til_result = til_result patterns in generated code
    // REMOVED: -Wno-c23-extensions - fixed by always emitting parameter names
    result.push("-Wno-uninitialized")             // variable used before initialization in some paths
    result.push("-Wno-unused-function")           // enum to_str functions generated but not always used
}

// Helper: push GCC-specific flags
push_gcc_flags := proc(mut result: Vec) {
    result.push("-Wno-dangling-pointer")          // 971 occurrences (high priority to fix) - GCC only
}

executable_extension := func(target: Target) returns Str {
    switch target {
    case Target.WindowsX64:
        return ".exe"
    case Target.Wasm32:
        return ".wasm"
    case:
        return ""
    }
}

// ---------- Detect current platform

detect_current_target := func() returns Target {
    // Use uname to detect OS and architecture (TIL has no cfg macros like Rust)
    mut uname_s := ""
    _ := uname_s.run_cmd("uname", "-s")
    mut uname_m := ""
    _ := uname_m.run_cmd("uname", "-m")

    // Strip trailing newlines
    os := uname_s.replace("\n", "")
    arch := uname_m.replace("\n", "")

    // Detect based on OS and architecture
    if os.eq("Darwin") {
        if arch.eq("arm64") {
            return Target.MacosArm64
        }
        return Target.MacosX64
    }
    if os.eq("Linux") {
        if arch.eq("aarch64") {
            return Target.LinuxArm64
        }
        if arch.eq("riscv64") {
            return Target.LinuxRiscv64
        }
        return Target.LinuxX64
    }
    // Windows would need different detection (MINGW, CYGWIN, etc.)
    // Default fallback
    return Target.LinuxX64
}
