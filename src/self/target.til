mode liba

// Target and Lang definitions for cross-compilation support
// Mirrors src/rs/target.rs

import("core.vec")

// ---------- Lang enum - codegen backend languages

Lang := enum {
    C,
    HolyC,
    TIL,  // TIL-to-TIL (for debugging: shows desugared, dead-code-eliminated output)
    // Future: Mojo, WASM, etc.
}

lang_from_str := func(s: Str) returns Lang throws Str {
    if s.eq("c") { return Lang.C }
    if s.eq("C") { return Lang.C }
    if s.eq("holyc") { return Lang.HolyC }
    if s.eq("HolyC") { return Lang.HolyC }
    if s.eq("HOLYC") { return Lang.HolyC }
    if s.eq("til") { return Lang.TIL }
    if s.eq("TIL") { return Lang.TIL }
    throw format("Unknown lang '", s, "'. Supported langs: c, holyc, til")
}

lang_to_str := func(lang: Lang) returns Str {
    switch lang {
    case Lang.C: return "c"
    case Lang.HolyC: return "holyc"
    case Lang.TIL: return "til"
    }
    return "c"
}

lang_file_extension := func(lang: Lang) returns Str {
    switch lang {
    case Lang.C: return "c"
    case Lang.HolyC: return "hc"
    case Lang.TIL: return "til"
    }
    return "c"
}

// ---------- Target enum - supported platforms

Target := enum {
    LinuxX64,
    LinuxArm64,
    LinuxRiscv64,
    WindowsX64,
    MacosX64,
    MacosArm64,
    Wasm32,
    TempleosX86,
}

target_from_str := func(s: Str) returns Target throws Str {
    if s.eq("linux-x64") { return Target.LinuxX64 }
    if s.eq("linux-x86_64") { return Target.LinuxX64 }
    if s.eq("linux-amd64") { return Target.LinuxX64 }
    if s.eq("linux-arm64") { return Target.LinuxArm64 }
    if s.eq("linux-aarch64") { return Target.LinuxArm64 }
    if s.eq("linux-riscv64") { return Target.LinuxRiscv64 }
    if s.eq("linux-riscv") { return Target.LinuxRiscv64 }
    if s.eq("riscv64") { return Target.LinuxRiscv64 }
    if s.eq("windows-x64") { return Target.WindowsX64 }
    if s.eq("windows-x86_64") { return Target.WindowsX64 }
    if s.eq("win64") { return Target.WindowsX64 }
    if s.eq("macos-x64") { return Target.MacosX64 }
    if s.eq("macos-x86_64") { return Target.MacosX64 }
    if s.eq("darwin-x64") { return Target.MacosX64 }
    if s.eq("macos-arm64") { return Target.MacosArm64 }
    if s.eq("macos-aarch64") { return Target.MacosArm64 }
    if s.eq("darwin-arm64") { return Target.MacosArm64 }
    if s.eq("wasm32") { return Target.Wasm32 }
    if s.eq("wasm") { return Target.Wasm32 }
    if s.eq("webassembly") { return Target.Wasm32 }
    if s.eq("templeos-x86") { return Target.TempleosX86 }
    if s.eq("templeos") { return Target.TempleosX86 }
    throw format("Unknown target '", s, "'. Supported targets: linux-x64, linux-arm64, linux-riscv64, windows-x64, macos-x64, macos-arm64, wasm32, templeos-x86")
}

target_to_str := func(target: Target) returns Str {
    switch target {
    case Target.LinuxX64: return "linux-x64"
    case Target.LinuxArm64: return "linux-arm64"
    case Target.LinuxRiscv64: return "linux-riscv64"
    case Target.WindowsX64: return "windows-x64"
    case Target.MacosX64: return "macos-x64"
    case Target.MacosArm64: return "macos-arm64"
    case Target.Wasm32: return "wasm32"
    case Target.TempleosX86: return "templeos-x86"
    }
    return "linux-x64"
}

// ---------- Target/Lang compatibility

default_lang_for_target := func(target: Target) returns Lang {
    switch target {
    case Target.TempleosX86: return Lang.HolyC
    case: return Lang.C
    }
}

supported_langs_for_target := func(target: Target) returns Vec throws AllocError {
    mut result := Vec.new(Lang)
    switch target {
    case Target.TempleosX86:
        result.push(Lang.HolyC)
        result.push(Lang.TIL)
    case:
        result.push(Lang.C)
        result.push(Lang.TIL)  // TIL is always supported (for debugging)
    }
    return result
}

is_lang_supported_for_target := func(lang: Lang, target: Target) returns Bool {
    // TIL is always supported (for debugging)
    switch lang {
    case Lang.TIL: return true
    case:
        // Check target-specific langs
        switch target {
        case Target.TempleosX86:
            switch lang {
            case Lang.HolyC: return true
            case: return false
            }
        case:
            switch lang {
            case Lang.C: return true
            case: return false
            }
        }
    }
}

validate_lang_for_target := func(lang: Lang, target: Target) throws Str {
    if is_lang_supported_for_target(lang, target) {
        return
    }
    throw format("Lang '", lang_to_str(lang), "' is not supported for target '", target_to_str(target), "'")
}

// ---------- Toolchain commands

toolchain_command := func(target: Target, lang: Lang) returns Str throws Str {
    switch target {
    case Target.LinuxX64:
        switch lang {
        case Lang.C: return "gcc"
        case: // fallthrough to error
        }
    case Target.LinuxArm64:
        switch lang {
        case Lang.C: return "aarch64-linux-gnu-gcc"
        case: // fallthrough to error
        }
    case Target.LinuxRiscv64:
        switch lang {
        case Lang.C: return "riscv64-linux-gnu-gcc"
        case: // fallthrough to error
        }
    case Target.WindowsX64:
        switch lang {
        case Lang.C: return "x86_64-w64-mingw32-gcc"
        case: // fallthrough to error
        }
    case Target.MacosX64:
        switch lang {
        case Lang.C: return "clang"
        case: // fallthrough to error
        }
    case Target.MacosArm64:
        switch lang {
        case Lang.C: return "clang"
        case: // fallthrough to error
        }
    case Target.Wasm32:
        switch lang {
        case Lang.C: return "clang"
        case: // fallthrough to error
        }
    case Target.TempleosX86:
        switch lang {
        case Lang.HolyC: return "holyc"
        case: // fallthrough to error
        }
    }
    throw format("No toolchain available for target '", target_to_str(target), "' with lang '", lang_to_str(lang), "'")
}

toolchain_extra_args := func(target: Target, lang: Lang) returns Vec throws AllocError {
    mut result := Vec.new(Str)
    switch target {
    case Target.MacosArm64:
        result.push("-target")
        result.push("arm64-apple-macos11")
    case Target.MacosX64:
        result.push("-target")
        result.push("x86_64-apple-macos10.12")
    case Target.Wasm32:
        result.push("--target=wasm32")
        result.push("-nostdlib")
        result.push("-Wl,--no-entry")
        result.push("-Wl,--export-all")
    case:
        // No extra args needed
    }
    return result
}

executable_extension := func(target: Target) returns Str {
    switch target {
    case Target.WindowsX64: return ".exe"
    case Target.Wasm32: return ".wasm"
    case: return ""
    }
}

// ---------- Detect current platform
// Note: In TIL, we detect at runtime via system calls

detect_current_target := func() returns Target {
    // For now, default to Linux x64
    // TODO: Implement actual detection using uname or similar
    return Target.LinuxX64
}
