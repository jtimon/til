mode liba

import("self.init")

// Scavenger phase: Removes unused function declarations from the AST.
// This phase runs after precomp (UFCS already resolved), before interpreter/builder.

// ---------- Type collection helpers

/// Extract type name from a ValueType, if it's a custom or multi type
extract_type_name : proc(vt: ValueType) returns Str = {
    switch vt {
    case ValueType.TCustom(name):
        return name.clone()
    case ValueType.TMulti(name):
        return name.clone()
    case:
        return ""
    }
}

/// Collect all type names used in an expression (declarations, constructors, etc.)
/// Uses context to look up whether names refer to structs/enums.
collect_used_types_from_expr : proc(context: Context, e: Expr, mut used_types: Set) throws Str = {
    switch e.node_type {
    case NodeType.Declaration(decl):
        type_name := extract_type_name(decl.value_type)
        if type_name.len().gt(0) {
            _ := used_types.insert(type_name)
        }
    case NodeType.FCall(_):
        // Constructor calls - check if the function name is a known struct
        if e.params.len().gt(0) {
            name := get_combined_name_from_identifier(e.get(0)?)?
            if name.len().gt(0).and(name.find(".").lt(0)) {
                // Check if this is a struct constructor
                mut fcall_found_struct := false
                _dummy := context.scope_stack.lookup_struct(name)?
                fcall_found_struct = true
                catch (err: KeyNotFoundError) { }
                if fcall_found_struct {
                    _ := used_types.insert(name)
                }
            }
        }
    case NodeType.Identifier(name):
        // Type references - check if this is a known struct or enum
        if name.len().gt(0).and(e.params.len().eq(0)) {
            mut ident_found_struct := false
            _dummy_struct := context.scope_stack.lookup_struct(name)?
            ident_found_struct = true
            catch (err: KeyNotFoundError) { }

            mut found_enum := false
            _dummy_enum := context.scope_stack.lookup_enum(name)?
            found_enum = true
            catch (err: KeyNotFoundError) { }

            if ident_found_struct.or(found_enum) {
                _ := used_types.insert(name.clone())
            }
        }
    case:
    }
    // Recurse into all params
    for param: Expr in e.params {
        collect_used_types_from_expr(context, param, used_types)?
    }
}

/// Collect all type names from a function definition (args, return types, throw types, body)
collect_used_types_from_func : proc(context: Context, func_def: SFuncDef, mut used_types: Set) throws Str = {
    // Collect from arguments
    for arg: Declaration in func_def.args {
        type_name := extract_type_name(arg.value_type)
        if type_name.len().gt(0) {
            _ := used_types.insert(type_name)
        }
    }
    // Collect from return types
    for ret_type: ValueType in func_def.return_types {
        ret_type_name := extract_type_name(ret_type)
        if ret_type_name.len().gt(0) {
            _ := used_types.insert(ret_type_name)
        }
    }
    // Collect from throw types
    for throw_type: ValueType in func_def.throw_types {
        throw_type_name := extract_type_name(throw_type)
        if throw_type_name.len().gt(0) {
            _ := used_types.insert(throw_type_name)
        }
    }
    // Collect from body
    for stmt: Expr in func_def.body {
        collect_used_types_from_expr(context, stmt, used_types)?
    }
}

// ---------- Helper functions

/// Issue #108: Rebuild a namespace definition, keeping only reachable methods
rebuild_namespace_without_unreachable_methods : proc(ns_def: SNamespaceDef, reachable: Set) returns Expr = {
    type_name := ns_def.type_name
    mut new_members := Vec.new(Declaration)
    mut new_default_values := Map.new(Str, Expr)

    for member_decl: Declaration in ns_def.members {
        full_name := format(type_name, ".", member_decl.name)

        default_expr := cast(Expr, ns_def.default_values.get(member_decl.name)?)

        switch default_expr.node_type {
        case NodeType.FuncDef(func_def):
            // Method - check if reachable or external
            if func_def.is_ext().or(reachable.contains(full_name)) {
                new_members.push(member_decl.clone())
                new_default_values.set(member_decl.name.clone(), default_expr.clone())
            }
        case:
            // Not a FuncDef - keep it (regular constant)
            new_members.push(member_decl.clone())
            new_default_values.set(member_decl.name.clone(), default_expr.clone())
        }

        catch (err: KeyNotFoundError) {
            // No default value - keep the member
            new_members.push(member_decl.clone())
        }
    }

    mut new_ns_def := SNamespaceDef()
    new_ns_def.type_name = type_name.clone()
    new_ns_def.members = new_members
    new_ns_def.default_values = new_default_values

    return Expr(node_type=NodeType.NamespaceDef(new_ns_def), params=Vec.new(Expr), line=0, col=0)
}

/// Rebuild a struct without unreachable methods
rebuild_struct_without_unreachable_methods : proc(decl: Declaration, struct_def: SStructDef, reachable: Set) returns Expr = {
    struct_name := decl.name
    mut new_members := Vec.new(Declaration)
    mut new_default_values := Map.new(Str, Expr)

    for member_decl: Declaration in struct_def.members {
        full_name := format(struct_name, ".", member_decl.name)

        default_expr := cast(Expr, struct_def.default_values.get(member_decl.name)?)

        switch default_expr.node_type {
        case NodeType.FuncDef(func_def):
            // Method - check if reachable or external
            if func_def.is_ext().or(reachable.contains(full_name)) {
                new_members.push(member_decl.clone())
                new_default_values.set(member_decl.name.clone(), default_expr.clone())
            }
        case:
            // Not a FuncDef - keep it (regular field with default value)
            new_members.push(member_decl.clone())
            new_default_values.set(member_decl.name.clone(), default_expr.clone())
        }

        catch (err: KeyNotFoundError) {
            // No default value - keep the member
            new_members.push(member_decl.clone())
        }
    }

    mut new_struct_def := SStructDef()
    new_struct_def.members = new_members
    new_struct_def.default_values = new_default_values
    new_struct_expr := Expr(node_type=NodeType.StructDef(new_struct_def), params=Vec.new(Expr), line=0, col=0)

    mut result_params := Vec.new(Expr)
    result_params.push(new_struct_expr)

    return Expr(node_type=NodeType.Declaration(decl.clone()), params=result_params, line=0, col=0)
}

/// Issue #91: Recursively collect function names passed as FuncSig arguments.
/// When `apply_op(add2, 3, 5)` is called and `apply_op`'s first param is FuncSig-typed,
/// `add2` is a function reference that must be marked reachable.
/// Also handles `return add2` where the return type is FuncSig.
collect_func_ptr_references : proc(e: Expr, context: Context, mut refs: Set) throws Str = {
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            fptr_func_name := get_combined_name_from_identifier(e.get(0)?)?
            if fptr_func_name.len().gt(0) {
                fptr_fd := context.scope_stack.lookup_func(fptr_func_name)?
                mut fptr_arg_i := 0
                for fptr_arg: Declaration in fptr_fd.args {
                    switch fptr_arg.value_type {
                    case ValueType.TCustom(fptr_type_name):
                        fptr_type_sym := context.scope_stack.lookup_symbol(fptr_type_name)?
                        switch fptr_type_sym.value_type {
                        case ValueType.TType(TTypeDef.TFuncSig):
                            // This parameter is a function pointer - check if the argument is a function name
                            if e.params.len().gt(fptr_arg_i.add(1)) {
                                fptr_arg_expr := e.get(fptr_arg_i.add(1))?
                                dont_delete(fptr_arg_expr)
                                fptr_arg_name := get_combined_name_from_identifier(fptr_arg_expr)?
                                if fptr_arg_name.len().gt(0) {
                                    _ := refs.insert(fptr_arg_name)
                                }
                            }
                        case:
                        }
                        catch (err: KeyNotFoundError) {
                            // REM: type symbol not found, not a FuncSig
                        }
                    case:
                    }
                    fptr_arg_i.inc()
                }
                catch (err: KeyNotFoundError) {
                    // REM: function not found in scope, skip
                }
            }
        }
        // Recurse into arguments
        mut fptr_i := 1
        while fptr_i.lt(e.params.len()) {
            collect_func_ptr_references(e.get(fptr_i)?, context, refs)?
            fptr_i.inc()
        }
    // Issue #91: `return add2` where add2 is a function name
    case NodeType.Return:
        if e.params.len().gt(0) {
            ret_expr := e.get(0)?
            dont_delete(ret_expr)
            ret_name := get_combined_name_from_identifier(ret_expr)?
            if ret_name.len().gt(0).and(context.scope_stack.has_func(ret_name)) {
                _ := refs.insert(ret_name)
            }
        }
    // Issue #91: `op := get_op(0)` - declaration with FuncSig type where
    // the initializer is an FCall that returns a function
    case NodeType.Declaration(_):
        for param: Expr in e.params {
            collect_func_ptr_references(param, context, refs)?
        }
    case NodeType.FuncDef(func_def):
        for stmt: Expr in func_def.body {
            collect_func_ptr_references(stmt, context, refs)?
        }
    case NodeType.Catch:
        if e.params.len().gteq(3) {
            collect_func_ptr_references(e.get(2)?, context, refs)?
        }
    case:
        for param: Expr in e.params {
            collect_func_ptr_references(param, context, refs)?
        }
    }
}

/// Recursively collect all function names called within an expression.
collect_called_functions : proc(e: Expr, mut called: Set) throws Str = {
    switch e.node_type {
    case NodeType.FCall(_):
        // After precomp, function calls have params[0] as Identifier(function_name)
        if e.params.len().gt(0) {
            full_name := get_combined_name_from_identifier(e.get(0)?)?
            if full_name.len().gt(0) {
                _ := called.insert(full_name)
            }
        }
        // Recurse into arguments
        mut i := 1
        while i.lt(e.params.len()) {
            collect_called_functions(e.get(i)?, called)?
            i.inc()
        }
    case NodeType.FuncDef(func_def):
        // Recurse into function body
        for stmt: Expr in func_def.body {
            collect_called_functions(stmt, called)?
        }
    case NodeType.Catch:
        // Catch has params[0]=name, params[1]=type, params[2]=body
        // Only recurse into body - type is not a function call
        if e.params.len().gteq(3) {
            collect_called_functions(e.get(2)?, called)?
        }
    case:
        // Recurse into all params
        for param: Expr in e.params {
            collect_called_functions(param, called)?
        }
    }

}

/// Get combined name from an identifier expression (handles a.b.c chains)
get_combined_name_from_identifier : proc(e: Expr) returns Str throws Str = {
    switch e.node_type {
    case NodeType.Identifier(name):
        if e.params.len().eq(0) {
            return name.clone()
        } else {
            // Has nested params like a.b.c
            mut parts := Vec.new(Str)
            parts.push(name.clone())
            for param: Expr in e.params {
                nested := get_combined_name_from_identifier(param)?
                if nested.len().gt(0) {
                    parts.push(nested)
                }
            }
            // Join with "."
            mut result := ""
            mut i := 0
            while i.lt(parts.len()) {
                part := cast(Str, parts.get(i)?)
                if i.gt(0) {
                    result = result.concat(".")
                }
                result = result.concat(part)
                i.inc()
            }
            return result
        }
    case:
        return ""
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

/// Helper to add a function to both reachable and worklist at the same time
mark_reachable : proc(func_name: Str, mut reachable: Set, mut worklist: Vec) = {
    if not(reachable.contains(func_name)) {
        _ := reachable.insert(func_name.clone())
        worklist.push(func_name.clone())
    }

}

/// Recursively register all functions and structs from the AST into context.scope_stack.
/// This mirrors what the interpreter does - it registers declarations as it walks the AST.
register_declarations_recursive : proc(mut context: Context, e: Expr) throws Str = {
    switch e.node_type {
    case NodeType.Declaration(decl):
        if e.params.len().gt(0) {
            inner := e.get(0)?
            switch inner.node_type {
            case NodeType.FuncDef(func_def):
                // Function declaration
                context.scope_stack.declare_func(decl.name.clone(), func_def.clone())?
                // Recurse into function body for local declarations
                for stmt: Expr in func_def.body {
                    register_declarations_recursive(context, stmt)?
                }
            case NodeType.StructDef(struct_def):
                // Struct declaration
                // Issue #108: Don't overwrite if struct already exists with merged namespace members
                if not(context.scope_stack.has_struct(decl.name)) {
                    context.scope_stack.declare_struct(decl.name.clone(), struct_def.clone())?
                }
                // Struct methods
                for member_name: Str in struct_def.default_values.keys {
                    default_expr := cast(Expr, struct_def.default_values.get(member_name)?)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        full_name := format(decl.name, ".", member_name)
                        context.scope_stack.declare_func(full_name, func_def.clone())?
                        // Recurse into method body for local declarations
                        for stmt: Expr in func_def.body {
                            register_declarations_recursive(context, stmt)?
                        }
                    case:
                    }
                }
            case:
            }
        }
    // Issue #108: Handle namespace definitions - register their functions
    case NodeType.NamespaceDef(ns_def):
        for member_name: Str in ns_def.default_values.keys {
            ns_default_expr := cast(Expr, ns_def.default_values.get(member_name)?)
            switch ns_default_expr.node_type {
            case NodeType.FuncDef(func_def):
                ns_full_name := format(ns_def.type_name, ".", member_name)
                context.scope_stack.declare_func(ns_full_name, func_def.clone())?
                // Recurse into method body for local declarations
                for stmt: Expr in func_def.body {
                    register_declarations_recursive(context, stmt)?
                }
            case:
            }
        }
    case NodeType.FuncDef(func_def):
        // Anonymous function - recurse into body
        for stmt: Expr in func_def.body {
            register_declarations_recursive(context, stmt)?
        }
    case:
    }
    // Recurse into all params
    for param: Expr in e.params {
        register_declarations_recursive(context, param)?
    }

    catch (err: KeyNotFoundError) { throw err.msg }
}

/// Register all functions and structs from the AST into context.scope_stack.
register_declarations : proc(mut context: Context, e: Expr) throws Str = {
    register_declarations_recursive(context, e)?
}

/// Types required by ext.c - these must be kept since ext.c is always included
get_ext_c_types : proc() returns Vec = {
    mut types := Vec.new(Str)
    types.push("Bool")
    types.push("Str")
    types.push("I64")
    types.push("U8")
    types.push("BadAlloc")
    types.push("Array")
    return types
}

/// Result type for compute_reachable (mimics Rust's tuple return)
ComputeReachableResult := struct {
    mut reachable: Set = Set.new(Str)
    mut used_types: Set = Set.new(Str)
    mut needs_variadic_support: Bool = false
}

/// Compute the transitive closure of reachable functions starting from roots.
/// Uses context.scope_stack.lookup_func() to find function bodies.
/// Returns (reachable_set, used_types_set, needs_variadic_support).
compute_reachable : proc(context: Context, roots: Set, e: Expr) returns ComputeReachableResult throws Str = {
    mut reachable := Set.new(Str)
    mut used_types := Set.new(Str)
    mut worklist := Vec.new(Str)
    mut needs_variadic_support := false

    // Add all roots
    for root: Str in roots {
        mark_reachable(root.clone(), reachable, worklist)
    }

    while worklist.len().gt(0) {
        mut func_name := ""
        worklist.pop(func_name)?

        // Find what this function calls using scope_stack
        mut found_func := false
        mut func_def := SFuncDef()
        func_def = context.scope_stack.lookup_func(func_name)?
        found_func = true
        catch (err: KeyNotFoundError) {
        }

        if found_func {
            // Collect types used by this function
            collect_used_types_from_func(context, func_def, used_types)?

            // Check if this function has variadic parameters (TMulti)
            for arg: Declaration in func_def.args {
                switch arg.value_type {
                case ValueType.TMulti(_):
                    needs_variadic_support = true
                    break
                case:
                }
            }

            if func_def.is_ext() {
                // External function - no body to walk
                continue
            }
            mut called := Set.new(Str)
            for stmt: Expr in func_def.body {
                collect_called_functions(stmt, called)?
            }
            // Issue #91: Remove parameter names from called set - they're variables, not functions
            // This handles function-pointer parameters like `op` in `func(op: BinaryIntOp, ...)`
            for cr_arg: Declaration in func_def.args {
                if cr_arg.name.len().gt(0) {
                    called.remove(cr_arg.name)
                }
            }
            // Issue #91: Collect function references passed as FuncSig arguments
            for stmt: Expr in func_def.body {
                collect_func_ptr_references(stmt, context, called)?
            }
            // Add newly discovered functions
            for called_func: Str in called {
                mark_reachable(called_func, reachable, worklist)
            }
        } else {
            // Check if it's a struct constructor
            mut found_struct := false
            mut struct_def := SStructDef()
            struct_def = context.scope_stack.lookup_struct(func_name)?
            found_struct = true
            catch (err: KeyNotFoundError) {
                // Not a struct
            }

            if found_struct {
                // Bug #150: Struct constructor is called, so the struct type is used
                _ := used_types.insert(func_name.clone())
                // Struct constructor - collect calls from field initializers only
                // (skip FuncDef values which are methods - their bodies should only be walked if the method itself is reachable)
                mut struct_called := Set.new(Str)
                for default_expr: Expr in struct_def.default_values.values {
                    switch default_expr.node_type {
                    case NodeType.FuncDef(_):
                        // Skip methods - they're handled separately via their qualified names
                        continue
                    case:
                    }
                    collect_called_functions(default_expr, struct_called)?
                }
                for called_func: Str in struct_called {
                    mark_reachable(called_func, reachable, worklist)
                }
            } else {
                // Check if this is an enum constructor (e.g., Color.Name)
                mut found_enum := false
                mut ctor_dot_pos := func_name.find(".")
                if ctor_dot_pos.gt(0) {
                    mut enum_name := func_name.get_substr(0, ctor_dot_pos)?
                    mut ctor_enum_def := SEnumDef()
                    ctor_enum_def = context.scope_stack.lookup_enum(enum_name)?
                    found_enum = true
                    catch (err: KeyNotFoundError) {
                    }
                    catch (err: IndexOutOfBoundsError) {
                    }
                }

                if found_enum {
                    continue
                }

                // Check if this is just an enum type name (e.g., ValueType without variant)
                if ctor_dot_pos.lt(0).or(ctor_dot_pos.eq(0)) {
                    mut type_enum_def := SEnumDef()
                    type_enum_def = context.scope_stack.lookup_enum(func_name)?
                    continue
                    catch (err: KeyNotFoundError) {
                    }
                }

                // Issue #91: Check if this is a function pointer variable (e.g., op := get_op(0))
                // Function pointer variables are symbols with TFunction type but no func def
                mut is_fptr_var := false
                fptr_sym := context.scope_stack.lookup_symbol(func_name)?
                switch fptr_sym.value_type {
                case ValueType.TFunction(_):
                    // Function pointer variable - the actual function it points to
                    // should already be reachable through the assignment source
                    is_fptr_var = true
                case:
                }
                catch (err: KeyNotFoundError) {
                    // REM: symbol not found
                }
                if is_fptr_var {
                    continue
                }

                {
                    // Check if this is an unresolved UFCS call (e.g., s.len or obj.field.len where s/obj is a variable)
                    // This happens when precomp couldn't determine the type (e.g., pattern bindings in switch)
                    // In this case, parts[0] is a variable name, not a type name
                    mut parts := func_name.split(".")?
                    method_name := cast(Str, parts.get(parts.len().sub(1))?) // Last part is the method name

                    mut is_unresolved_ufcs := false
                    if parts.len().gteq(2) {
                        maybe_var := cast(Str, parts.get(0)?)
                        // If first part is NOT a known struct/enum, it's likely a variable
                        mut found_struct_check := false
                        mut _dummy_struct := SStructDef()
                        _dummy_struct = context.scope_stack.lookup_struct(maybe_var)?
                        found_struct_check = true
                        catch (err: KeyNotFoundError) { }

                        mut found_enum_check := false
                        mut _dummy_enum := SEnumDef()
                        _dummy_enum = context.scope_stack.lookup_enum(maybe_var)?
                        found_enum_check = true
                        catch (err: KeyNotFoundError) { }

                        is_unresolved_ufcs = not(found_struct_check.or(found_enum_check))
                    } else {
                        // Single name - could be a method that precomp couldn't resolve
                        is_unresolved_ufcs = true
                    }

                    if is_unresolved_ufcs {
                        // Try to find the method on built-in types first
                        mut builtin_types := Vec.new(Str)
                        builtin_types.push("Str")
                        builtin_types.push("I64")
                        builtin_types.push("Bool")
                        builtin_types.push("U8")
                        builtin_types.push("F64")
                        builtin_types.push("Array")
                        builtin_types.push("Vec")
                        builtin_types.push("List")
                        builtin_types.push("Map")
                        builtin_types.push("Set")

                        mut found_method := false
                        for builtin: Str in builtin_types {
                            builtin_full_method := format(builtin, ".", method_name)
                            mut _builtin_dummy_fd := SFuncDef()
                            _builtin_dummy_fd = context.scope_stack.lookup_func(builtin_full_method)?
                            // Found a matching method - mark it reachable instead
                            mark_reachable(builtin_full_method, reachable, worklist)
                            found_method = true
                            break
                            catch (err: KeyNotFoundError) { }
                        }

                        // Also check user-defined structs for the method
                        if not(found_method) {
                            struct_names := context.scope_stack.get_all_struct_names()
                            for struct_name: Str in struct_names {
                                user_full_method := format(struct_name, ".", method_name)
                                mut _user_dummy_fd := SFuncDef()
                                _user_dummy_fd = context.scope_stack.lookup_func(user_full_method)?
                                mark_reachable(user_full_method, reachable, worklist)
                                found_method = true
                                break
                                catch (err: KeyNotFoundError) { }
                            }
                        }

                        if found_method {
                            continue
                        }
                        throw e.lang_error(context.path, "scavenger", format("no body found for '", func_name, "'"))
                    } else {
                        throw e.lang_error(context.path, "scavenger", format("no body found for '", func_name, "'"))
                    }
                }
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    // Always add ext.c required types since ext.c is always included in generated C
    ext_c_types := get_ext_c_types()
    for ext_type: Str in ext_c_types {
        _ := used_types.insert(ext_type.clone())
    }

    // HeapState functions called by ext.c (til_malloc/til_free/til_exit) - not visible in TIL source
    mark_reachable("HeapState.enable", reachable, worklist)
    mark_reachable("HeapState.disable", reachable, worklist)
    mark_reachable("HeapState.add", reachable, worklist)
    mark_reachable("HeapState.remove", reachable, worklist)
    mark_reachable("HeapState.report", reachable, worklist)
    _ := used_types.insert("HeapState")
    _ := used_types.insert("HeapEntry")

    // Add struct types when their methods are reachable (e.g., Foo.bar reachable -> Foo is used)
    for func_name: Str in reachable {
        method_dot_pos := func_name.find(".")
        if method_dot_pos.gt(0) {
            struct_name := func_name.get_substr(0, method_dot_pos)?
            // Only add if this is actually a struct (not an enum)
            mut method_found_struct := false
            _dummy := context.scope_stack.lookup_struct(struct_name)?
            method_found_struct = true
            catch (err: KeyNotFoundError) { }
            if method_found_struct {
                _ := used_types.insert(struct_name)
            }
        }
    }

    // Bug #136: Mark struct eq() methods as reachable when the struct type is used
    // This is needed because switch comparisons on struct types call eq() implicitly
    // (the call is generated by the codegen, not present in the source)
    mut used_types_snapshot := Vec.new(Str)
    for type_name: Str in used_types {
        used_types_snapshot.push(type_name.clone())
    }
    for eq_type_name: Str in used_types_snapshot {
        // Skip primitive types for eq method check (they don't need implicit eq for switch)
        // But continue processing for namespace functions below
        is_primitive := eq_type_name.eq("Str").or(eq_type_name.eq("I64")).or(eq_type_name.eq("U8")).or(eq_type_name.eq("Bool"))
        if not(is_primitive) {
            // Check if this is a struct with an eq method
            mut eq_found_struct := false
            _sd := context.scope_stack.lookup_struct(eq_type_name)?
            eq_found_struct = true
            catch (err: KeyNotFoundError) { }
            if eq_found_struct {
                eq_method_name := format(eq_type_name, ".eq")
                mut found_eq := false
                _fd := context.scope_stack.lookup_func(eq_method_name)?
                found_eq = true
                catch (err: KeyNotFoundError) { }
                if found_eq {
                    mark_reachable(eq_method_name, reachable, worklist)
                }
            }
        }

        // Issue #108: Mark all namespace methods as reachable when their type is used
        // This ensures that dependencies of namespace functions are tracked
        // Walk the AST to find NamespaceDef for this type
        for stmt: Expr in e.params {
            switch stmt.node_type {
            case NodeType.NamespaceDef(ns_def):
                if ns_def.type_name.eq(eq_type_name) {
                    for method_name: Str in ns_def.default_values.keys {
                        method_expr := cast(Expr, ns_def.default_values.get(method_name)?)
                        catch (err: KeyNotFoundError) {
                            panic(loc(), "scavenger: KeyNotFoundError iterating default_values.keys: ", err.msg)
                        }
                        switch method_expr.node_type {
                        case NodeType.FuncDef(_func_def):
                            full_name := format(eq_type_name, ".", method_name)
                            mark_reachable(full_name, reachable, worklist)
                        case:
                        }
                    }
                }
            case:
            }
        }
    }

    // Process any newly added eq methods and namespace methods
    while worklist.len().gt(0) {
        mut eq_func_name := ""
        worklist.pop(eq_func_name)?
        mut eq_found_func := false
        eq_func_def := context.scope_stack.lookup_func(eq_func_name)?
        eq_found_func = true
        catch (err: KeyNotFoundError) { }
        if eq_found_func {
            collect_used_types_from_func(context, eq_func_def, used_types)?

            // Issue #108: Also check for variadic params in second loop
            for arg: Declaration in eq_func_def.args {
                switch arg.value_type {
                case ValueType.TMulti(_):
                    needs_variadic_support = true
                case:
                }
            }

            if eq_func_def.is_ext() {
                continue
            }
            mut eq_called := Set.new(Str)
            for stmt: Expr in eq_func_def.body {
                collect_called_functions(stmt, eq_called)?
            }
            for called_func: Str in eq_called {
                mark_reachable(called_func, reachable, worklist)
            }
        }
    }

    // Now compute transitive closure of used types (struct field types, enum payload types)
    mut type_worklist := Vec.new(Str)
    for type_name: Str in used_types {
        type_worklist.push(type_name.clone())
    }
    while type_worklist.len().gt(0) {
        mut type_name := ""
        type_worklist.pop(type_name)?

        // Check struct field types
        mut closure_found_struct := false
        closure_struct_def := context.scope_stack.lookup_struct(type_name)?
        closure_found_struct = true
        catch (err: KeyNotFoundError) { }
        if closure_found_struct {
            for member: Declaration in closure_struct_def.members {
                field_type := extract_type_name(member.value_type)
                if field_type.len().gt(0) {
                    if not(used_types.contains(field_type)) {
                        _ := used_types.insert(field_type.clone())
                        type_worklist.push(field_type)
                    }
                }
            }
        }

        // Check enum payload types
        mut closure_found_enum := false
        closure_enum_def := context.scope_stack.lookup_enum(type_name)?
        closure_found_enum = true
        catch (err: KeyNotFoundError) { }
        if closure_found_enum {
            for variant: EnumVariant in closure_enum_def.variants {
                if not(variant.payload_type.is_null()) {
                    // Read the ValueType from the Ptr
                    mut vt := ValueType.TCustom("")
                    memcpy(to_ptr(vt), variant.payload_type.data, size_of(ValueType))
                    payload_type_name := extract_type_name(vt)
                    if payload_type_name.len().gt(0) {
                        if not(used_types.contains(payload_type_name)) {
                            _ := used_types.insert(payload_type_name.clone())
                            type_worklist.push(payload_type_name)
                        }
                    }
                }
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return ComputeReachableResult(reachable=reachable, used_types=used_types, needs_variadic_support=needs_variadic_support)
}

// ---------- Main entry point

/// Remove unused function declarations from the AST.
/// This runs after precomp, so UFCS is already resolved.
scavenger_expr : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    // DEBUG

    // Only process Body nodes at the top level
    switch e.node_type {
    case NodeType.Body:
        // DEBUG

        // Step 0: Register all functions and structs from the transformed AST into scope_stack
        // This mirrors what the interpreter does - it builds scope_stack as it walks the AST
        register_declarations(context, e)?

        // DEBUG

        // Step 1: Determine root functions based on mode
        mut roots := Set.new(Str)

        if context.mode_def.needs_main_proc {
            // CLI mode: root is main plus global variable initializers
            _ := roots.insert("main")
            // Global variable initializers are also executed in main(), so their calls are roots
            for stmt: Expr in e.params {
                switch stmt.node_type {
                case NodeType.Declaration(decl):
                    if stmt.params.len().gt(0) {
                        inner := stmt.get(0)?
                        switch inner.node_type {
                        case NodeType.FuncDef(_):
                            // Skip function declarations
                        case:
                            // Non-function declaration initializer - collect calls from it
                            collect_called_functions(inner, roots)?
                        }
                    }
                case:
                }
            }
        } else if context.mode_def.allows_base_calls.or(context.mode_def.allows_base_anything) {
            // script/safe_script/test: all top-level non-declaration statements are roots
            // Walk them to find called functions
            for stmt: Expr in e.params {
                switch stmt.node_type {
                case NodeType.Declaration(decl):
                    // Skip declarations - only their initializers matter if not functions
                    if stmt.params.len().gt(0) {
                        script_inner := stmt.get(0)?
                        switch script_inner.node_type {
                        case NodeType.FuncDef(_):
                            // Skip function declarations - they're not roots themselves
                        case:
                            // Non-function declaration initializer - collect calls from it
                            collect_called_functions(script_inner, roots)?
                        }
                    }
                case:
                    // Non-declaration statement (function call, assignment, etc.)
                    collect_called_functions(stmt, roots)?
                }
            }
        } else {
            // lib/pure mode - globals are still initialized in main(), so include those calls
            for stmt: Expr in e.params {
                switch stmt.node_type {
                case NodeType.Declaration(decl):
                    if stmt.params.len().gt(0) {
                        lib_inner := stmt.get(0)?
                        switch lib_inner.node_type {
                        case NodeType.FuncDef(_):
                            // Skip function declarations
                        case:
                            // Non-function declaration initializer - collect calls from it
                            collect_called_functions(lib_inner, roots)?
                        }
                    }
                case:
                }
            }
        }

        // Issue #91: Also collect function references passed as FuncSig arguments at top level
        for fptr_stmt: Expr in e.params {
            collect_func_ptr_references(fptr_stmt, context, roots)?
        }

        // Step 2: Compute reachable functions (transitive closure)
        // First pass: compute reachable and detect if variadic support is needed
        mut cr_result := compute_reachable(context, roots, e)?
        mut reachable := cr_result.reachable
        mut used_types := cr_result.used_types
        mut needs_variadic_support := cr_result.needs_variadic_support

        // If any variadic function was found, add Array methods and recompute closure
        // to include their dependencies (like U8.from_i64)
        if needs_variadic_support {
            mut extended_roots := roots.clone()
            // Add Array methods
            mut array_methods := Vec.new(Str)
            array_methods.push("Array.new")
            array_methods.push("Array.set")
            array_methods.push("Array.get")
            array_methods.push("Array.delete")
            array_methods.push("Array.len")
            for method: Str in array_methods {
                _ := extended_roots.insert(method.clone())
            }
            // Recompute
            mut new_cr_result := compute_reachable(context, extended_roots, e)?
            reachable = new_cr_result.reachable
            used_types = new_cr_result.used_types
            // Ignore needs_variadic_support on second pass
        }

        // Step 2b: Add enum payload types and their transitive dependencies to used_types
        // Bug #143: Enums are always kept, so their struct payload types must be kept too
        // We need to collect payload types AND compute transitive closure of those
        mut enum_payload_types := Vec.new(Str)
        for step2b_stmt: Expr in e.params {
            switch step2b_stmt.node_type {
            case NodeType.Declaration(_):
                if step2b_stmt.params.len().gt(0) {
                    step2b_inner := step2b_stmt.get(0)?
                    switch step2b_inner.node_type {
                    case NodeType.EnumDef(step2b_enum_def):
                        for step2b_variant: EnumVariant in step2b_enum_def.variants {
                            if not(step2b_variant.payload_type.is_null()) {
                                mut step2b_vt := ValueType.TCustom("")
                                memcpy(to_ptr(step2b_vt), step2b_variant.payload_type.data, size_of(ValueType))
                                step2b_payload_name := extract_type_name(step2b_vt)
                                if step2b_payload_name.len().gt(0) {
                                    if not(used_types.contains(step2b_payload_name)) {
                                        enum_payload_types.push(step2b_payload_name)
                                    }
                                }
                            }
                        }
                    case:
                    }
                }
            case:
            }
        }
        // Now compute transitive closure of enum payload types
        while enum_payload_types.len().gt(0) {
            mut step2b_type_name := ""
            enum_payload_types.pop(step2b_type_name)?
            if used_types.contains(step2b_type_name) {
                continue
            }
            _ := used_types.insert(step2b_type_name.clone())
            // Check struct field types
            mut step2b_found_struct := false
            step2b_struct_def := context.scope_stack.lookup_struct(step2b_type_name)?
            step2b_found_struct = true
            catch (err: KeyNotFoundError) { }
            if step2b_found_struct {
                for step2b_member: Declaration in step2b_struct_def.members {
                    step2b_field_type := extract_type_name(step2b_member.value_type)
                    if step2b_field_type.len().gt(0) {
                        if not(used_types.contains(step2b_field_type)) {
                            enum_payload_types.push(step2b_field_type)
                        }
                    }
                }
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        // Step 3: Build new AST - only include reachable function declarations
        // For structs, rebuild them without unreachable methods
        mut new_params := Vec.new(Expr)
        for stmt: Expr in e.params {
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                if stmt.params.len().gt(0) {
                    rebuild_inner := stmt.get(0)?
                    switch rebuild_inner.node_type {
                    case NodeType.FuncDef(func_def):
                        // Issue #91: FuncSig declarations (empty body, unnamed args)
                        // are type definitions, not functions - always keep them
                        mut is_func_sig := false
                        if func_def.body.is_empty().and(func_def.is_ext().not()) {
                            mut all_unnamed := true
                            for fs_arg: Declaration in func_def.args {
                                if fs_arg.name.len().gt(0) {
                                    all_unnamed = false
                                }
                            }
                            switch func_def.function_type {
                            case FunctionType.FTFunc:
                                is_func_sig = all_unnamed
                            case FunctionType.FTProc:
                                is_func_sig = all_unnamed
                            case:
                            }
                        }
                        // Function declaration - keep if reachable, external, or FuncSig
                        if func_def.is_ext().or(is_func_sig).or(reachable.contains(decl.name)) {
                            new_params.push(stmt.clone())
                        }
                    case NodeType.StructDef(struct_def):
                        // Struct - only keep if type is used, rebuild without unreachable methods
                        if used_types.contains(decl.name) {
                            new_struct := rebuild_struct_without_unreachable_methods(decl, struct_def, reachable)
                            new_params.push(new_struct)
                        }
                    case:
                        // Non-function, non-struct declaration - always keep
                        new_params.push(stmt.clone())
                    }
                } else {
                    // Declaration without initializer - always keep
                    new_params.push(stmt.clone())
                }
            // Issue #108: Handle namespace definitions
            case NodeType.NamespaceDef(ns_def):
                // Check if the namespace's type is used
                if used_types.contains(ns_def.type_name) {
                    new_ns := rebuild_namespace_without_unreachable_methods(ns_def, reachable)
                    new_params.push(new_ns)
                }
            case:
                // Non-declaration - always keep
                new_params.push(stmt.clone())
            }
        }

        mut result_node_type := node_type_clone(e.node_type)

        return Expr(node_type=result_node_type, params=new_params, line=e.line, col=e.col)
    case:
    }

    // Not a Body node - return unchanged
    mut result := e.clone()
    return result
}
