mode lib

import("self.init")

// Scavenger phase: Removes unused function declarations from the AST.
// This phase runs after precomp (UFCS already resolved), before interpreter/builder.

// ---------- Helper functions

/// Rebuild a struct without unreachable methods
rebuild_struct_without_unreachable_methods := proc(decl: Declaration, struct_def: SStructDef, reachable: Set) returns Expr throws Str {
    struct_name := decl.name
    mut new_members := Vec.new(Declaration)
    mut new_default_values := Map.new(Str, Expr)

    mut i := 0
    while i.lt(struct_def.members.len()) {
        mut member_decl := Declaration()
        struct_def.members.get(i, member_decl)
        full_name := format(struct_name, ".", member_decl.name)

        // Check if this member has a FuncDef default value (i.e., it's a method)
        mut has_default := false
        mut default_expr := Expr()
        if struct_def.default_values.contains_key(member_decl.name) {
            struct_def.default_values.get(member_decl.name, default_expr)
            has_default = true
        }

        if has_default {
            switch default_expr.node_type {
            case NodeType.FuncDef(func_def):
                // Method - check if reachable or external
                if or(func_def.is_ext(), reachable.contains(full_name)) {
                    new_members.push(member_decl)
                    new_default_values.set(member_decl.name, default_expr)
                }
            case:
                // Not a FuncDef - keep it (regular field with default value)
                new_members.push(member_decl)
                new_default_values.set(member_decl.name, default_expr)
            }
        } else {
            // No default value - keep the member
            new_members.push(member_decl)
        }

        i = i.add(1)
    }

    mut new_struct_def := SStructDef()
    new_struct_def.members = new_members
    new_struct_def.default_values = new_default_values
    new_struct_expr := Expr(node_type=NodeType.StructDef(new_struct_def), params=Vec.new(Expr), line=0, col=0)

    mut result_params := Vec.new(Expr)
    result_params.push(new_struct_expr)

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    return Expr(node_type=NodeType.Declaration(decl), params=result_params, line=0, col=0)
}

/// Recursively collect all function names called within an expression.
collect_called_functions := proc(e: Expr, mut called: Set) throws Str {
    switch e.node_type {
    case NodeType.FCall:
        // After precomp, function calls have params[0] as Identifier(function_name)
        if e.params.len().gt(0) {
            full_name := get_combined_name_from_identifier(e.get(0))
            if full_name.len().gt(0) {
                _ := called.insert(full_name)
            }
        }
        // Recurse into arguments
        mut i := 1
        while i.lt(e.params.len()) {
            collect_called_functions(e.get(i), called)
            i = i.add(1)
        }
    case NodeType.FuncDef(func_def):
        // Recurse into function body
        mut i := 0
        while i.lt(func_def.body.len()) {
            mut stmt := Expr()
            func_def.body.get(i, stmt)
            collect_called_functions(stmt, called)
            i = i.add(1)
        }
    case NodeType.Catch:
        // Catch has params[0]=name, params[1]=type, params[2]=body
        // Only recurse into body - type is not a function call
        if e.params.len().gteq(3) {
            collect_called_functions(e.get(2), called)
        }
    case:
        // Recurse into all params
        mut i := 0
        while i.lt(e.params.len()) {
            collect_called_functions(e.get(i), called)
            i = i.add(1)
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Get combined name from an identifier expression (handles a.b.c chains)
get_combined_name_from_identifier := proc(e: Expr) returns Str throws Str {
    switch e.node_type {
    case NodeType.Identifier(name):
        if e.params.len().eq(0) {
            return name
        } else {
            // Has nested params like a.b.c
            mut parts := Vec.new(Str)
            parts.push(name)
            mut i := 0
            while i.lt(e.params.len()) {
                nested := get_combined_name_from_identifier(e.get(i))
                if nested.len().gt(0) {
                    parts.push(nested)
                }
                i = i.add(1)
            }
            // Join with "."
            mut result := ""
            i = 0
            while i.lt(parts.len()) {
                mut part := ""
                parts.get(i, part)
                if i.gt(0) {
                    result = result.concat(".")
                }
                result = result.concat(part)
                i = i.add(1)
            }
            return result
        }
    case:
        return ""
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Helper to add a function to both reachable and worklist at the same time
mark_reachable := proc(func_name: Str, mut reachable: Set, mut worklist: Vec) throws Str {
    if not(reachable.contains(func_name)) {
        _ := reachable.insert(func_name)
        worklist.push(func_name)
    }

    catch (err: AllocError) { throw err.msg }
}

/// Recursively register all functions and structs from the AST into context.scope_stack.
/// This mirrors what the interpreter does - it registers declarations as it walks the AST.
register_declarations_recursive := proc(mut context: Context, e: Expr) throws Str {
    switch e.node_type {
    case NodeType.Declaration(decl):
        if e.params.len().gt(0) {
            inner := e.get(0)
            switch inner.node_type {
            case NodeType.FuncDef(func_def):
                // Function declaration
                context.scope_stack.declare_func(decl.name, func_def)
                // Recurse into function body for local declarations
                mut i := 0
                while i.lt(func_def.body.len()) {
                    mut stmt := Expr()
                    func_def.body.get(i, stmt)
                    register_declarations_recursive(context, stmt)
                    i = i.add(1)
                }
            case NodeType.StructDef(struct_def):
                // Struct declaration
                context.scope_stack.declare_struct(decl.name, struct_def)
                // Struct methods
                mut i := 0
                while i.lt(struct_def.default_values.keys.len()) {
                    mut member_name := ""
                    struct_def.default_values.keys.get(i, member_name)
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        full_name := format(decl.name, ".", member_name)
                        context.scope_stack.declare_func(full_name, func_def)
                        // Recurse into method body for local declarations
                        mut j := 0
                        while j.lt(func_def.body.len()) {
                            mut stmt := Expr()
                            func_def.body.get(j, stmt)
                            register_declarations_recursive(context, stmt)
                            j = j.add(1)
                        }
                    case:
                    }
                    i = i.add(1)
                }
            case:
            }
        }
    case NodeType.FuncDef(func_def):
        // Anonymous function - recurse into body
        mut i := 0
        while i.lt(func_def.body.len()) {
            mut stmt := Expr()
            func_def.body.get(i, stmt)
            register_declarations_recursive(context, stmt)
            i = i.add(1)
        }
    case:
    }
    // Recurse into all params
    mut i := 0
    while i.lt(e.params.len()) {
        register_declarations_recursive(context, e.get(i))
        i = i.add(1)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
}

/// Register all functions and structs from the AST into context.scope_stack.
register_declarations := proc(mut context: Context, e: Expr) throws Str {
    register_declarations_recursive(context, e)
}

/// Compute the transitive closure of reachable functions starting from roots.
/// Uses context.scope_stack.lookup_func() to find function bodies.
compute_reachable := proc(context: Context, roots: Set, e: Expr) returns Set throws Str {
    mut reachable := Set.new(Str)
    mut worklist := Vec.new(Str)
    mut needs_variadic_support := false

    // Add all roots
    mut ri := 0
    while ri.lt(roots.len()) {
        mut root := ""
        roots.get(ri, root)
        mark_reachable(root, reachable, worklist)
        ri = ri.add(1)
    }

    while worklist.len().gt(0) {
        mut func_name := ""
        worklist.pop(func_name)

        // Find what this function calls using scope_stack
        mut found_func := false
        mut func_def := SFuncDef()
        func_def = context.scope_stack.lookup_func(func_name)
        found_func = true
        catch (err: KeyNotFoundError) {
            // Not a function
        }

        if found_func {
            // Check if this function has variadic parameters (TMulti)
            mut ai := 0
            while ai.lt(func_def.args.len()) {
                mut arg := Declaration()
                func_def.args.get(ai, arg)
                switch arg.value_type {
                case ValueType.TMulti(_):
                    needs_variadic_support = true
                    ai = func_def.args.len() // break
                case:
                    ai = ai.add(1)
                }
            }

            if func_def.is_ext() {
                // External function - no body to walk
            } else {
                mut called := Set.new(Str)
                mut bi := 0
                while bi.lt(func_def.body.len()) {
                    mut stmt := Expr()
                    func_def.body.get(bi, stmt)
                    collect_called_functions(stmt, called)
                    bi = bi.add(1)
                }
                // Add newly discovered functions
                mut ci := 0
                while ci.lt(called.len()) {
                    mut called_func := ""
                    called.get(ci, called_func)
                    mark_reachable(called_func, reachable, worklist)
                    ci = ci.add(1)
                }
            }
        } else {
            // Check if it's a struct constructor
            mut found_struct := false
            mut struct_def := SStructDef()
            struct_def = context.scope_stack.lookup_struct(func_name)
            found_struct = true
            catch (err: KeyNotFoundError) {
                // Not a struct
            }

            if found_struct {
                // Struct constructor - collect calls from default values
                mut called := Set.new(Str)
                mut di := 0
                while di.lt(struct_def.default_values.keys.len()) {
                    mut key := ""
                    struct_def.default_values.keys.get(di, key)
                    mut default_expr := Expr()
                    struct_def.default_values.get(key, default_expr)
                    collect_called_functions(default_expr, called)
                    di = di.add(1)
                }
                mut ci := 0
                while ci.lt(called.len()) {
                    mut called_func := ""
                    called.get(ci, called_func)
                    mark_reachable(called_func, reachable, worklist)
                    ci = ci.add(1)
                }
            } else {
                // Check if this is an enum constructor (e.g., Color.Name)
                mut found_enum := false
                mut dot_pos := func_name.find(".")
                if dot_pos.gt(0) {
                    mut enum_name := func_name.get_substr(0, dot_pos)
                    mut enum_def := SEnumDef()
                    enum_def = context.scope_stack.lookup_enum(enum_name)
                    found_enum = true
                    catch (err: KeyNotFoundError) {
                        // Not an enum
                    }
                    catch (err: IndexOutOfBoundsError) {
                        // get_substr failed
                    }
                }

                if not(found_enum) {
                    // Check if this is an unresolved UFCS call (e.g., s.len or obj.field.len where s/obj is a variable)
                    // This happens when precomp couldn't determine the type (e.g., pattern bindings in switch)
                    // In this case, parts[0] is a variable name, not a type name
                    mut parts := func_name.split(".")
                    mut method_name := ""
                    if parts.len().gt(0) {
                        parts.get(parts.len().sub(1), method_name) // Last part is the method name
                    }

                    mut is_unresolved_ufcs := false
                    if parts.len().gteq(2) {
                        mut maybe_var := ""
                        parts.get(0, maybe_var)
                        // If first part is NOT a known struct/enum, it's likely a variable
                        mut found_struct_check := false
                        mut dummy_struct := SStructDef()
                        dummy_struct = context.scope_stack.lookup_struct(maybe_var)
                        found_struct_check = true
                        catch (err: KeyNotFoundError) { }

                        mut found_enum_check := false
                        mut dummy_enum := SEnumDef()
                        dummy_enum = context.scope_stack.lookup_enum(maybe_var)
                        found_enum_check = true
                        catch (err: KeyNotFoundError) { }

                        is_unresolved_ufcs = not(or(found_struct_check, found_enum_check))
                    } else {
                        // Single name - could be a method that precomp couldn't resolve
                        is_unresolved_ufcs = true
                    }

                    if is_unresolved_ufcs {
                        // Try to find the method on built-in types first
                        mut builtin_types := Vec.new(Str)
                        builtin_types.push("Str")
                        builtin_types.push("I64")
                        builtin_types.push("Bool")
                        builtin_types.push("U8")
                        builtin_types.push("F64")
                        builtin_types.push("Array")
                        builtin_types.push("Vec")
                        builtin_types.push("List")
                        builtin_types.push("Map")
                        builtin_types.push("Set")

                        mut found_method := false
                        mut bi := 0
                        while bi.lt(builtin_types.len()) {
                            mut builtin := ""
                            builtin_types.get(bi, builtin)
                            full_method := format(builtin, ".", method_name)
                            mut dummy_fd := SFuncDef()
                            dummy_fd = context.scope_stack.lookup_func(full_method)
                            // Found a matching method - mark it reachable instead
                            mark_reachable(full_method, reachable, worklist)
                            found_method = true
                            bi = builtin_types.len() // break
                            catch (err: KeyNotFoundError) {
                                bi = bi.add(1)
                            }
                        }

                        // Also check user-defined structs for the method
                        if not(found_method) {
                            struct_names := context.scope_stack.get_all_struct_names()
                            mut si := 0
                            while si.lt(struct_names.len()) {
                                mut struct_name := ""
                                struct_names.get(si, struct_name)
                                full_method := format(struct_name, ".", method_name)
                                mut dummy_fd := SFuncDef()
                                dummy_fd = context.scope_stack.lookup_func(full_method)
                                mark_reachable(full_method, reachable, worklist)
                                found_method = true
                                si = struct_names.len() // break
                                catch (err: KeyNotFoundError) {
                                    si = si.add(1)
                                }
                            }
                        }

                        if not(found_method) {
                            throw e.lang_error(context.path, "scavenger", format("no body found for '", func_name, "'"))
                        }
                    } else {
                        throw e.lang_error(context.path, "scavenger", format("no body found for '", func_name, "'"))
                    }
                }
                // Enum constructor or resolved UFCS - no body to walk
            }
        }
    }

    // If any variadic function was found, add Array methods and recompute closure
    if needs_variadic_support {
        mut extended_roots := Set.new(Str)
        // Copy original roots
        ri = 0
        while ri.lt(roots.len()) {
            mut root := ""
            roots.get(ri, root)
            _ := extended_roots.insert(root)
            ri = ri.add(1)
        }
        // Add Array methods
        _ := extended_roots.insert("Array.new")
        _ := extended_roots.insert("Array.set")
        _ := extended_roots.insert("Array.get")
        _ := extended_roots.insert("Array.delete")
        _ := extended_roots.insert("Array.len")
        // Recompute (recursive call, but needs_variadic_support will be ignored on second pass)
        return compute_reachable(context, extended_roots, e)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    return reachable
}

// ---------- Main entry point

/// Remove unused function declarations from the AST.
/// This runs after precomp, so UFCS is already resolved.
scavenger_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    // Only process Body nodes at the top level
    switch e.node_type {
    case NodeType.Body:
        // Step 0: Register all functions and structs from the transformed AST into scope_stack
        // This mirrors what the interpreter does - it builds scope_stack as it walks the AST
        register_declarations(context, e)

        // Step 1: Determine root functions based on mode
        mut roots := Set.new(Str)

        if context.mode_def.needs_main_proc {
            // CLI mode: root is main
            _ := roots.insert("main")
        } else {
            if or(context.mode_def.allows_base_calls, context.mode_def.allows_base_anything) {
                // script/safe_script/test: all top-level non-declaration statements are roots
                // Walk them to find called functions
                mut i := 0
                while i.lt(e.params.len()) {
                    stmt := e.get(i)
                    switch stmt.node_type {
                    case NodeType.Declaration(decl):
                        // Skip declarations - only their initializers matter if not functions
                        if stmt.params.len().gt(0) {
                            inner := stmt.get(0)
                            switch inner.node_type {
                            case NodeType.FuncDef(_):
                                // Skip function declarations - they're not roots themselves
                            case:
                                // Non-function declaration initializer - collect calls from it
                                collect_called_functions(inner, roots)
                            }
                        }
                    case:
                        // Non-declaration statement (function call, assignment, etc.)
                        collect_called_functions(stmt, roots)
                    }
                    i = i.add(1)
                }
            }
        }
        // else: lib/pure mode - no roots, all user functions get removed

        // Step 2: Compute reachable functions (transitive closure)
        reachable := compute_reachable(context, roots, e)

        // Step 3: Build new AST - only include reachable function declarations
        // For structs, rebuild them without unreachable methods
        mut new_params := Vec.new(Expr)
        mut i := 0
        while i.lt(e.params.len()) {
            stmt := e.get(i)
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                if stmt.params.len().gt(0) {
                    inner := stmt.get(0)
                    switch inner.node_type {
                    case NodeType.FuncDef(func_def):
                        // Function declaration - keep if reachable or external
                        if or(func_def.is_ext(), reachable.contains(decl.name)) {
                            new_params.push(stmt)
                        }
                    case NodeType.StructDef(struct_def):
                        // Struct - rebuild without unreachable methods
                        new_struct := rebuild_struct_without_unreachable_methods(decl, struct_def, reachable)
                        new_params.push(new_struct)
                    case:
                        // Non-function, non-struct declaration - always keep
                        new_params.push(stmt)
                    }
                } else {
                    // Declaration without initializer - always keep
                    new_params.push(stmt)
                }
            case:
                // Non-declaration - always keep
                new_params.push(stmt)
            }
            i = i.add(1)
        }

        catch (err: AllocError) { throw err.msg }

        return Expr(node_type=e.node_type, params=new_params, line=e.line, col=e.col)
    case:
    }

    // Not a Body node - return unchanged
    return e
}
