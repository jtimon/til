mode liba

// External/Core functions for TIL interpreter
// This module contains all built-in core functions and procedures.

import("self.parser")       // Expr, NodeType, Literal, ValueType, get_combined_name
import("self.init")         // Context
import("self.interpreter")  // EvalResult, eval_expr, string_from_context
import("self.eval_arena")   // g_arena (global)
import("std.sys")            // run_cmd
import("std.io")            // readfile, input_read_line

// ---------- Helper functions

/// Convert a single byte to a 1-character string
byte_to_str := func(byte: U8) returns Str throws AllocError {
    mut s := Str()
    s.c_string = malloc(2)  // 1 byte + null terminator
    s.cap = 1
    memcpy(s.c_string, to_ptr(byte), 1)
    mut zero : U8 = 0
    memcpy(add(s.c_string, 1), to_ptr(zero), 1)  // null terminator
    return s
}

// General whitelist for all modes
make_allowed_commands := proc() returns Array {
    mut arr := Array.new(Str, 9)
    arr.set(0, "ls")
    arr.set(1, "mkdir")
    arr.set(2, "find")
    arr.set(3, "gcc")
    arr.set(4, "./bin/rstil")
    arr.set(5, "diff")
    arr.set(6, "bash")
    arr.set(7, "rm")
    arr.set(8, "cp")
    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    return arr
}
ALLOWED_COMMANDS := make_allowed_commands()

// More restrictive whitelist for safe_script mode
make_safe_commands := proc() returns Array {
    mut arr := Array.new(Str, 2)
    arr.set(0, "ls")
    arr.set(1, "mkdir")
    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    return arr
}
SAFE_COMMANDS := make_safe_commands()

// Note: Rust's eval_or_throw! macro is replaced by inline pattern:
//   result := eval_expr(context, e.get(N))
//   if result.is_throw { return result }
//   // then use result.value

// Validates that a function/procedure call has the expected number of arguments.
// The e.params.len() includes the function name as the first parameter, so we subtract 1.
validate_arg_count := proc(path: Str, e: Expr, func_name: Str, expected: I64, is_proc: Bool) throws Str {
    actual := e.params.len().sub(1)  // First param is function name
    if not(actual.eq(expected)) {
        mut func_type := "func"
        if is_proc { func_type = "proc" }
        mut plural := "s"
        if expected.eq(1) { plural = "" }
        throw e.lang_error(path, "eval", format("Core ", func_type, " '", func_name, "' takes exactly ", expected.to_str(), " argument", plural))
    }
}

// Read a Str value from context (reads c_string and cap from arena)
string_from_context := proc(context: Context, id: Str, e: Expr) returns Str throws Str {
    // Read the c_string field (I64 pointer to string data in EvalArena)
    c_string_ptr := EvalArena.get_i64(context, format(id, ".c_string"), e)

    // Read the cap field (I64 length)
    length := EvalArena.get_i64(context, format(id, ".cap"), e)

    // Bounds check
    if c_string_ptr.add(length).gt(g_arena.len()) {
        throw e.lang_error(context.path, "string_from_context", format("string content out of bounds for '", id, "'"))
    }

    // Read string bytes from EvalArena and convert to String
    mut result := ""
    for i in 0..length {
        mut byte := U8.from_i64(0)
        memcpy(to_ptr(byte), g_arena.get(c_string_ptr.add(i), 1), 1)
        result = format(result, byte_to_str(byte))
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: U8_OverflowError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return result
}

// ---------- Core functions - called from interpreter dispatcher

func_loc := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "loc", 0, false)
    file := context.path
    line := e.line
    col := e.col
    return EvalResult.new(format(file, ":", line.to_str(), ":", col.to_str(), ":"))
}

func_file := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "_file", 0, false)
    return EvalResult.new(context.path)
}

func_line := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "_line", 0, false)
    return EvalResult.new(e.line.to_str())
}

func_col := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "_col", 0, false)
    return EvalResult.new(e.col.to_str())
}

// ---------- eval memory

func_malloc := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "malloc", 1, false)

    size_result := eval_expr(context, e.get(1))
    if size_result.is_throw { return size_result }
    size := I64.from_str(size_result.value)
    mut offset := 0
    if size.gt(0) {
        offset = g_arena.reserve(size)
    } else {
        offset = g_arena.len()
    }

    if offset.eq(0) {  // TODO: REM: throw AllocError instead of return NULL pointer
        throw e.lang_error(context.path, "eval", "Core func 'malloc' was about to produce a NULL pointer")
    }
    return EvalResult.new(offset.to_str())
}

func_free := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "free", 1, false)

    ptr_result := eval_expr(context, e.get(1))
    if ptr_result.is_throw { return ptr_result }
    // REM: Free does nothing in arena model (for now).

    return EvalResult.new("")
}

func_memset := proc(mut context: Context, e: Expr) returns EvalResult throws Str, U8_OverflowError {
    validate_arg_count(context.path, e, "memset", 3, false)

    dest_result := eval_expr(context, e.get(1))
    if dest_result.is_throw { return dest_result }
    value_result := eval_expr(context, e.get(2))
    if value_result.is_throw { return value_result }
    size_result := eval_expr(context, e.get(3))
    if size_result.is_throw { return size_result }

    dest := I64.from_str(dest_result.value)
    value := U8.from_str(value_result.value)
    size := I64.from_str(size_result.value)

    arena_len := g_arena.len()
    if dest.add(size).gt(arena_len) {
        throw e.error(context.path, "eval", format("memset out of bounds: dest=", dest.to_str(), " size=", size.to_str(), " arena_len=", arena_len.to_str()))
    }

    for i in 0..size {
        g_arena.set(dest.add(i), to_ptr(value), 1)
    }

    return EvalResult.new("")
}

func_memcpy := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "memcpy", 3, false)

    dest_result := eval_expr(context, e.get(1))
    if dest_result.is_throw { return dest_result }
    src_result := eval_expr(context, e.get(2))
    if src_result.is_throw { return src_result }
    size_result := eval_expr(context, e.get(3))
    if size_result.is_throw { return size_result }

    dest := I64.from_str(dest_result.value)
    src := I64.from_str(src_result.value)
    size := I64.from_str(size_result.value)

    arena_len := g_arena.len()
    if dest.add(size).gt(arena_len).or(src.add(size).gt(arena_len)) {
        throw e.error(context.path, "eval", format("memcpy out of bounds: src=", src.to_str(), " dest=", dest.to_str(), " size=", size.to_str(), " arena_len=", arena_len.to_str()))
    }

    for i in 0..size {
        mut src_byte := U8.from_i64(0)
        memcpy(to_ptr(src_byte), g_arena.get(src.add(i), 1), 1)
        g_arena.set(dest.add(i), to_ptr(src_byte), 1)
    }

    catch (err: U8_OverflowError) { throw err.msg }
    return EvalResult.new("")
}

func_memcmp := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "memcmp", 3, false)

    ptr1_result := eval_expr(context, e.get(1))
    if ptr1_result.is_throw { return ptr1_result }
    ptr2_result := eval_expr(context, e.get(2))
    if ptr2_result.is_throw { return ptr2_result }
    size_result := eval_expr(context, e.get(3))
    if size_result.is_throw { return size_result }

    ptr1 := I64.from_str(ptr1_result.value)
    ptr2 := I64.from_str(ptr2_result.value)
    size := I64.from_str(size_result.value)

    arena_len := g_arena.len()
    if ptr1.add(size).gt(arena_len).or(ptr2.add(size).gt(arena_len)) {
        throw e.error(context.path, "eval", format("memcmp out of bounds: ptr1=", ptr1.to_str(), " ptr2=", ptr2.to_str(), " size=", size.to_str(), " arena_len=", arena_len.to_str()))
    }

    // Compare bytes
    for i in 0..size {
        mut byte1 := U8.from_i64(0)
        mut byte2 := U8.from_i64(0)
        memcpy(to_ptr(byte1), g_arena.get(ptr1.add(i), 1), 1)
        memcpy(to_ptr(byte2), g_arena.get(ptr2.add(i), 1), 1)
        if U8.to_i64(byte1).lt(U8.to_i64(byte2)) {
            return EvalResult.new("-1")
        } else if U8.to_i64(byte1).gt(U8.to_i64(byte2)) {
            return EvalResult.new("1")
        }
    }

    // All bytes equal
    catch (err: U8_OverflowError) { throw err.msg }
    return EvalResult.new("0")
}

func_to_ptr := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "to_ptr", 1, false)

    identifier_expr := e.get(1)
    combined_name := get_combined_name(context.path, identifier_expr)
    addr := context.scope_stack.lookup_var(combined_name)
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("calling core func to_ptr, but '", combined_name, "' is not a known identifier."))
    }
    return EvalResult.new(addr.to_str())
}

func_size_of := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "size_of", 1, false)

    type_expr := e.get(1)
    switch type_expr.node_type {
        case Identifier(type_name):
            // Check if this identifier is a string variable (Dynamic parameter storing a type name)
            mut actual_type_name := type_name

            // Try to look up symbol - if found and is Str type, get string value
            mut found_str_type := false
            sym := context.scope_stack.lookup_symbol(type_name)
            switch sym.value_type {
                case TCustom(custom_type):
                    if custom_type.eq("Str") {
                        found_str_type = true
                    }
                case:
            }
            catch (err: KeyNotFoundError) {
                // Symbol not found, use type_name as-is
            }

            if found_str_type {
                // This might be a Dynamic parameter - try to get its string value
                actual_type_name = string_from_context(context, type_name, e)
                catch (err: Str) {
                    actual_type_name = type_name
                }
            }

            size := context.get_type_size(actual_type_name)
            return EvalResult.new(size.to_str())
        case:
            throw e.lang_error(context.path, "eval", "calling core func size_of, but found non-identifier instead of identifier.")
    }
}

func_type_as_str := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "type_as_str", 1, false)

    type_expr := e.get(1)
    switch type_expr.node_type {
        case Identifier(type_name):
            // Check if this identifier is a string variable (Dynamic parameter storing a type name)
            mut actual_type_name := type_name

            // Try to look up symbol - if found and is Str type, get string value
            mut found_str_type := false
            sym := context.scope_stack.lookup_symbol(type_name)
            switch sym.value_type {
                case TCustom(custom_type):
                    if custom_type.eq("Str") {
                        found_str_type = true
                    }
                case:
            }
            catch (err: KeyNotFoundError) {
                // Symbol not found, use type_name as-is
            }

            if found_str_type {
                // This might be a Dynamic parameter - try to get its string value
                actual_type_name = string_from_context(context, type_name, e)
                catch (err: Str) {
                    actual_type_name = type_name
                }
            }

            return EvalResult.new(actual_type_name)
        case:
            throw e.lang_error(context.path, "eval", "calling core func type_as_str, but found non-identifier instead of identifier.")
    }
}

func_lt := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "lt", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.lt(b).to_str())
}

func_gt := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "gt", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.gt(b).to_str())
}

func_add := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "add", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.add(b).to_str())
}

func_sub := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "sub", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.sub(b).to_str())
}

func_mul := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "mul", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.mul(b).to_str())
}

func_div := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "div", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Return 0 for division by zero (safe default, revisit post-self-hosting)
    if b.eq(0) {
        return EvalResult.new("0")
    }
    return EvalResult.new(a.div(b).to_str())
}

func_mod := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "mod", 2, false)
    a_result := eval_expr(context, e.get(1))
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2))
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Return 0 for modulo by zero (safe default, revisit post-self-hosting)
    if b.eq(0) {
        return EvalResult.new("0")
    }
    return EvalResult.new(a.mod(b).to_str())
}

func_str_to_i64 := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "str_to_i64", 1, false)
    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    a := I64.from_str(result.value)
    return EvalResult.new(a.to_str())
}

func_i64_to_str := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "i64_to_str", 1, false)
    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

func_enum_to_str := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "enum_to_str", 1, false)
    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

func_u8_to_i64 := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "u8_to_i64", 1, false)
    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    a := I64.from_str(result.value)
    return EvalResult.new(a.to_str())
}

func_i64_to_u8 := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "i64_to_u8", 1, false)
    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

// ---------- core procs implementations for eval

// Note: If this prints an Array instead of a Str, check that single_print is declared
// as `ext_proc(s: Str)` not `ext_proc(args: ..Str)` in core.til. Variadic wrapping
// bypasses validate_arg_count by passing args as a single Array. (Bug #30)
proc_single_print := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "single_print", 1, true)

    result := eval_expr(context, e.get(1))
    if result.is_throw { return result }

    print(result.value)
    return EvalResult.new("")
}

proc_print_flush := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "print_flush", 0, true)
    print_flush()
    return EvalResult.new("")
}

proc_input_read_line := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "input_read_line", 1, true)

    first_param := e.get(1)
    mut read_line_error_msg := ""
    switch first_param.node_type {
        case LLiteral(lit):
            switch lit {
                case Str(error_msg):
                    read_line_error_msg = error_msg
                case:
                    throw e.lang_error(context.path, "eval", "input_read_line() expects a literal string error message.")
            }
        case:
            throw e.lang_error(context.path, "eval", "input_read_line() expects a literal string error message.")
    }

    line := input_read_line(read_line_error_msg)
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", read_line_error_msg)
    }
    return EvalResult.new(line)
}

proc_readfile := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "readfile", 1, true)

    result := eval_expr(context, e.get(1))
    if result.is_throw {
        return result // Propagate throw
    }
    path := result.value

    // Call host-provided readfile (when running on rstil)
    source := readfile(path)
    catch (err: Str) {
        throw e.error(context.path, "eval", format("Problem reading file '", path, "': ", err))
    }
    return EvalResult.new(source)
}

// WARNING: run_cmd executes shell commands.
// In mode safe_script, only whitelisted commands are allowed (configurable).
// In other modes, arbitrary commands can be executed - use with caution.
// Returns exit code as I64, output is written to mut output_str arg
proc_run_cmd := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    // run_cmd(mut output_str, args...) - runs a command with arguments
    // First arg is mut output string, second is command, remaining are args
    // Returns exit code as I64
    if e.params.len().lt(3) {
        throw e.error(context.path, "eval", "run_cmd requires at least 2 arguments (mut output_str, command)")
    }

    // Get output variable name (must be identifier for mut assignment)
    output_var := e.get(1)

    cmd_result := eval_expr(context, e.get(2))
    if cmd_result.is_throw {
        return cmd_result
    }
    cmd := cmd_result.value

    // Check command against whitelists
    if context.mode_def.name.eq("safe_script") {
        if not(SAFE_COMMANDS.contains(cmd)) {
            throw e.error(context.path, "eval", format("Command '", cmd, "' not in safe_script whitelist"))
        }
    } else {
        if not(ALLOWED_COMMANDS.contains(cmd)) {
            throw e.error(context.path, "eval", format("Command '", cmd, "' not in allowed whitelist"))
        }
    }

    mut args := Vec.new(Str)
    for i in 3..e.params.len() {
        arg_result := eval_expr(context, e.get(i))
        if arg_result.is_throw {
            return arg_result
        }
        args.push(arg_result.value)
    }

    catch (err: AllocError) { throw err.msg }

    // TODO: Call run_cmd once we have Vec-to-variadic splat
    // run_cmd is imported from safe_script but expects variadic ..Str, not Vec
    throw e.error(context.path, "eval", "run_cmd not yet implemented in self-hosted interpreter (needs Vec-to-variadic)")
}

// ---------- Introspection functions

func_has_const := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "has_const", 2, false)

    result1 := eval_expr(context, e.get(1))
    if result1.is_throw { return result1 }
    type_name := result1.value

    result2 := eval_expr(context, e.get(2))
    if result2.is_throw { return result2 }
    const_name := result2.value

    // Check if type exists in struct_defs
    struct_def := context.scope_stack.lookup_struct(type_name)
    // Check for immutable field (!is_mut)
    decl := struct_def.get_member(const_name)
    if not(decl.is_mut) {
        return EvalResult.new("true")
    }
    catch (err: KeyNotFoundError) {
        // Type or member not found
    }

    return EvalResult.new("false")
}

func_has_field := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "has_field", 2, false)

    result1 := eval_expr(context, e.get(1))
    if result1.is_throw { return result1 }
    type_name := result1.value

    result2 := eval_expr(context, e.get(2))
    if result2.is_throw { return result2 }
    field_name := result2.value

    // Check if type exists in struct_defs
    struct_def := context.scope_stack.lookup_struct(type_name)
    // Check for mutable field (is_mut)
    decl := struct_def.get_member(field_name)
    if decl.is_mut {
        return EvalResult.new("true")
    }
    catch (err: KeyNotFoundError) {
        // Type or member not found
    }

    return EvalResult.new("false")
}

func_exit := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "exit", 1, false)

    e_exit_code := e.get(1)

    // Check if it's a number literal using pattern matching
    switch e_exit_code.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(num_str):
            exit_code := I64.from_str(num_str)
            exit(exit_code)
            return EvalResult.new("")  // unreachable, exit() never returns
        case:
            // Not a number literal
        }
    case:
        // Not a literal
    }
    throw e.lang_error(context.path, "eval", "calling core proc 'exit', but found non-literal instead of literal i64 exit code.")
}

// ---------- Process spawning functions

proc_spawn_cmd := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "spawn_cmd", 1, true)

    cmd_result := eval_expr(context, e.get(1))
    if cmd_result.is_throw { return cmd_result }
    cmd := cmd_result.value

    // Call host-provided spawn_cmd (when running on rstil)
    pid := spawn_cmd(cmd)

    catch (err: SpawnError) {
        throw e.error(context.path, "eval", format("spawn_cmd failed: ", err.msg))
    }

    return EvalResult.new(pid.to_str())
}

proc_check_cmd_status := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "check_cmd_status", 1, true)

    pid_result := eval_expr(context, e.get(1))
    if pid_result.is_throw { return pid_result }
    pid := I64.from_str(pid_result.value)

    // Call host-provided check_cmd_status (when running on rstil)
    status := check_cmd_status(pid)
    return EvalResult.new(status.to_str())
}

proc_sleep := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "sleep", 1, true)

    ms_result := eval_expr(context, e.get(1))
    if ms_result.is_throw { return ms_result }
    ms := I64.from_str(ms_result.value)

    // Call host-provided sleep (when running on rstil)
    sleep(ms)

    catch (err: SleepError) {
        throw e.error(context.path, "eval", format("sleep failed: ", err.msg))
    }

    return EvalResult.new("")
}

proc_get_thread_count := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "get_thread_count", 0, true)

    // Call host-provided get_thread_count (when running on rstil)
    count := get_thread_count()

    return EvalResult.new(count.to_str())
}

func_file_mtime := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "file_mtime", 1, false)

    path_result := eval_expr(context, e.get(1))
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided file_mtime (when running on rstil)
    mtime := file_mtime(path)

    return EvalResult.new(mtime.to_str())
}

func_list_dir_raw := proc(mut context: Context, e: Expr) returns EvalResult throws Str {
    validate_arg_count(context.path, e, "list_dir_raw", 1, false)

    path_result := eval_expr(context, e.get(1))
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided list_dir_raw (when running on rstil)
    raw := list_dir_raw(path)

    return EvalResult.new(raw)
}
