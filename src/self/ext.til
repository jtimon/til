mode liba

// External/Core functions for TIL interpreter
// This module contains all built-in core functions and procedures.

import("self.parser")       // Expr, NodeType, Literal, ValueType, get_combined_name
import("self.init")         // Context
import("self.interpreter")  // EvalResult, eval_expr, string_from_context
import("self.eval_heap")   // g_heap (global)
import("std.sys")            // run_cmd
import("std.io")            // readfile, input_read_line

// ---------- Helper functions

/// Convert a single byte to a 1-character string
byte_to_str : func(byte: U8) returns Str = {
    mut s := Str()
    s.c_string = Ptr.new_by_size(2)  // 1 byte + null terminator
    s.c_string.is_borrowed = 0
    s._len = 1
    s.cap = 2  // Allocated capacity
    memcpy(s.c_string.data, to_ptr(byte), 1)
    mut zero : U8 = 0
    memcpy(s.c_string.offset(1).data, to_ptr(zero), 1)  // null terminator
    return s
}

// General whitelist for all modes
make_allowed_commands : proc() returns Array = {
    mut arr := Array.new(Str, 9)
    arr.set(0, "ls")?
    arr.set(1, "mkdir")?
    arr.set(2, "find")?
    arr.set(3, "gcc")?
    arr.set(4, "./bin/rstil")?
    arr.set(5, "diff")?
    arr.set(6, "bash")?
    arr.set(7, "rm")?
    arr.set(8, "cp")?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    return arr
}
ALLOWED_COMMANDS := make_allowed_commands()

// More restrictive whitelist for safe_script mode
make_safe_commands : proc() returns Array = {
    mut arr := Array.new(Str, 2)
    arr.set(0, "ls")?
    arr.set(1, "mkdir")?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    return arr
}
SAFE_COMMANDS := make_safe_commands()

// Note: Rust's eval_or_throw! macro is replaced by inline pattern:
//   result := eval_expr(context, e.get(N))
//   if result.is_throw { return result }
//   // then use result.value

// Validates that a function/procedure call has the expected number of arguments.
// The e.params.len() includes the function name as the first parameter, so we subtract 1.
validate_arg_count : proc(path: Str, e: Expr, func_name: Str, expected: I64, is_proc: Bool) throws Str = {
    actual := e.params.len().sub(1)  // First param is function name
    if not(actual.eq(expected)) {
        mut func_type := "func"
        if is_proc { func_type = "proc" }
        mut plural := "s"
        if expected.eq(1) { plural = "" }
        throw e.lang_error(path, "eval", format("Core ", func_type, " '", func_name, "' takes exactly ", expected.to_str(), " argument", plural))
    }
}

// Read a Str value from context (reads c_string and _len from heap)
string_from_context : proc(context: Context, id: Str, e: Expr) returns Str throws Str = {
    // Read the c_string.data field (I64 pointer to string data in EvalHeap)
    // Note: c_string is a Ptr struct { data: I64, is_borrowed: I64 }, so we read .data
    c_string_ptr := EvalHeap.get_i64(context, format(id, ".c_string.data"), e)?

    // Read the _len field (I64 length)
    length := EvalHeap.get_i64(context, format(id, "._len"), e)?

    // Read string bytes from EvalHeap and convert to String
    mut result := ""
    for i in 0..length {
        mut byte := U8.from_i64(0)?
        memcpy(to_ptr(byte), g_heap.get(c_string_ptr.add(i), 1), 1)
        result = format(result, byte_to_str(byte))
    }
    catch (err: U8_Overflow) { throw err.msg }
    return result
}

// ---------- Core functions - called from interpreter dispatcher

func_loc : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "loc", 0, false)?
    file := context.path
    line := e.line
    col := e.col
    return EvalResult.new(format(file, ":", line.to_str(), ":", col.to_str(), ":"))
}

func_file : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "_file", 0, false)?
    return EvalResult.new(context.path)
}

func_line : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "_line", 0, false)?
    return EvalResult.new(e.line.to_str())
}

func_col : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "_col", 0, false)?
    return EvalResult.new(e.col.to_str())
}

// ---------- eval memory

func_malloc : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "malloc", 1, false)?

    size_result := eval_expr(context, e.get(1)?)?
    if size_result.is_throw { return size_result }
    size := I64.from_str(size_result.value)
    offset := g_heap.heap_alloc(size)?

    if offset.eq(0) {  // TODO: REM: throw AllocError instead of return NULL pointer
        throw e.lang_error(context.path, "eval", "Core func 'malloc' was about to produce a NULL pointer")
    }
    return EvalResult.new(offset.to_str())
}

func_free : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "free", 1, false)?

    ptr_result := eval_expr(context, e.get(1)?)?
    if ptr_result.is_throw { return ptr_result }
    // Issue #163: Actually free heap-allocated memory
    ptr := I64.from_str(ptr_result.value)
    g_heap.heap_free(ptr)

    return EvalResult.new("")
}

func_memset : proc(mut context: Context, e: Expr) returns EvalResult throws Str, U8_Overflow = {
    validate_arg_count(context.path, e, "memset", 3, false)?

    dest_result := eval_expr(context, e.get(1)?)?
    if dest_result.is_throw { return dest_result }
    value_result := eval_expr(context, e.get(2)?)?
    if value_result.is_throw { return value_result }
    size_result := eval_expr(context, e.get(3)?)?
    if size_result.is_throw { return size_result }

    dest := I64.from_str(dest_result.value)
    value := U8.from_str(value_result.value)?
    size := I64.from_str(size_result.value)

    for i in 0..size {
        g_heap.set(dest.add(i), to_ptr(value), 1)
    }

    return EvalResult.new("")
}

func_memcpy : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "memcpy", 3, false)?

    dest_result := eval_expr(context, e.get(1)?)?
    if dest_result.is_throw { return dest_result }
    src_result := eval_expr(context, e.get(2)?)?
    if src_result.is_throw { return src_result }
    size_result := eval_expr(context, e.get(3)?)?
    if size_result.is_throw { return size_result }

    dest := I64.from_str(dest_result.value)
    src := I64.from_str(src_result.value)
    size := I64.from_str(size_result.value)

    for i in 0..size {
        mut src_byte := U8.from_i64(0)?
        memcpy(to_ptr(src_byte), g_heap.get(src.add(i), 1), 1)
        g_heap.set(dest.add(i), to_ptr(src_byte), 1)
    }

    catch (err: U8_Overflow) { throw err.msg }
    return EvalResult.new("")
}

func_to_ptr : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "to_ptr", 1, false)?

    identifier_expr := e.get(1)?
    combined_name := get_combined_name(context.path, identifier_expr)?
    addr := context.scope_stack.lookup_var(combined_name)?
    catch (err: KeyNotFoundError) {
        throw e.lang_error(context.path, "eval", format("calling core func to_ptr, but '", combined_name, "' is not a known identifier."))
    }
    return EvalResult.new(addr.to_str())
}

func_size_of : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "size_of", 1, false)?

    type_expr := e.get(1)?
    switch type_expr.node_type {
        case Identifier(type_name):
            // Check if this identifier is a string variable (Dynamic parameter storing a type name)
            mut actual_type_name := type_name

            // Try to look up symbol - if found and is Str type, get string value
            mut found_str_type := false
            sym := context.scope_stack.lookup_symbol(type_name)?
            switch sym.value_type {
                case TCustom(custom_type):
                    if custom_type.eq("Str") {
                        found_str_type = true
                    }
                case:
            }
            catch (err: KeyNotFoundError) {
                // Symbol not found, use type_name as-is
            }

            if found_str_type {
                // This might be a Dynamic parameter - try to get its string value
                actual_type_name = string_from_context(context, type_name, e)?
                catch (err: Str) {
                    actual_type_name = type_name
                }
            }

            size := context.get_type_size(actual_type_name)?
            return EvalResult.new(size.to_str())
        case:
            throw e.lang_error(context.path, "eval", "calling core func size_of, but found non-identifier instead of identifier.")
    }
}

func_type_as_str : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "type_as_str", 1, false)?

    type_expr := e.get(1)?
    switch type_expr.node_type {
        case Identifier(type_name):
            // Check if this identifier is a string variable (Dynamic parameter storing a type name)
            mut actual_type_name := type_name

            // Try to look up symbol - if found and is Str type, get string value
            mut found_str_type := false
            sym := context.scope_stack.lookup_symbol(type_name)?
            switch sym.value_type {
                case TCustom(custom_type)?:
                    if custom_type.eq("Str") {
                        found_str_type = true
                    }
                case:
            }
            catch (err: KeyNotFoundError) {
                // Symbol not found, use type_name as-is
            }

            if found_str_type {
                // This might be a Dynamic parameter - try to get its string value
                actual_type_name = string_from_context(context, type_name, e)?
                catch (err: Str) {
                    actual_type_name = type_name
                }
            }

            return EvalResult.new(actual_type_name)
        case:
            throw e.lang_error(context.path, "eval", "calling core func type_as_str, but found non-identifier instead of identifier.")
    }
}

func_lt : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "lt", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.lt(b).to_str())
}

func_gt : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "gt", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.gt(b).to_str())
}

func_u8_lt : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_lt", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := U8.from_str(a_result.value)?
    b := U8.from_str(b_result.value)?
    result := EvalResult.new(U8.lt(a, b).to_str())

    catch (err: U8_Overflow) {
        throw e.lang_error(context.path, "eval", format("Invalid u8 for 'u8_lt': ", err.msg))
    }

    return result
}

func_u8_gt : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_gt", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := U8.from_str(a_result.value)?
    b := U8.from_str(b_result.value)?
    result := EvalResult.new(U8.gt(a, b).to_str())

    catch (err: U8_Overflow) {
        throw e.lang_error(context.path, "eval", format("Invalid u8 for 'u8_gt': ", err.msg))
    }

    return result
}

func_u8_xor : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_xor", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := U8.from_str(a_result.value)?
    b := U8.from_str(b_result.value)?
    result := EvalResult.new(U8.xor(a, b).to_str())

    catch (err: U8_Overflow) {
        throw e.lang_error(context.path, "eval", format("Invalid u8 for 'u8_xor': ", err.msg))
    }

    return result
}

func_u8_and : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_and", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := U8.from_str(a_result.value)?
    b := U8.from_str(b_result.value)?
    result := EvalResult.new(U8.and(a, b).to_str())

    catch (err: U8_Overflow) {
        throw e.lang_error(context.path, "eval", format("Invalid u8 for 'u8_and': ", err.msg))
    }

    return result
}

func_u8_or : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_or", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := U8.from_str(a_result.value)?
    b := U8.from_str(b_result.value)?
    result := EvalResult.new(U8.or(a, b).to_str())

    catch (err: U8_Overflow) {
        throw e.lang_error(context.path, "eval", format("Invalid u8 for 'u8_or': ", err.msg))
    }

    return result
}

func_add : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "add", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.add(b).to_str())
}

func_sub : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "sub", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.sub(b).to_str())
}

func_mul : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "mul", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(a.mul(b).to_str())
}

func_div : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "div", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Return 0 for division by zero (safe default, revisit post-self-hosting)
    if b.eq(0) {
        return EvalResult.new("0")
    }
    return EvalResult.new(a.div(b).to_str())
}

func_mod : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "mod", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Return 0 for modulo by zero (safe default, revisit post-self-hosting)
    if b.eq(0) {
        return EvalResult.new("0")
    }
    return EvalResult.new(a.mod(b).to_str())
}

// Bitwise operations - don't really belong in arithmetics, but here for now
func_i64_xor : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "i64_xor", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(I64.xor(a, b).to_str())
}

func_i64_and : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "i64_and", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(I64.and(a, b).to_str())
}

func_i64_or : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "i64_or", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    return EvalResult.new(I64.or(a, b).to_str())
}

func_str_to_i64 : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "str_to_i64", 1, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    a := I64.from_str(result.value)
    return EvalResult.new(a.to_str())
}

func_i64_to_str : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "i64_to_str", 1, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

func_enum_to_str : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "enum_to_str", 1, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

func_enum_get_payload : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "enum_get_payload", 3, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }

    // Get payload type from second argument
    type_arg := e.get(2)?
    mut type_name := ""
    switch type_arg.node_type {
    case NodeType.Identifier(name)?:
        type_name = name
    case:
        throw e.lang_error(context.path, "eval", "enum_get_payload: type argument must be a type name")
    }
    // Check if payload type is an enum (for nested enums)
    mut is_enum_payload := false
    _ := context.scope_stack.lookup_enum(type_name)?
    is_enum_payload = true
    catch (err: KeyNotFoundError) {
        is_enum_payload = false
    }
    // Get expected type size
    type_size := context.get_type_size(type_name)?
    catch (err: Str) {
        throw e.lang_error(context.path, "eval", err)
    }
    // After eval_expr, context.temp_enum_payload should contain the payload data
    if not(context.temp_enum_payload.is_null()) {
        // Read EnumPayload from heap
        mut payload := EnumPayload(data=Vec.new(U8), value_type=ValueType.TCustom(""))
        memcpy(to_ptr(payload), context.temp_enum_payload.data, size_of(EnumPayload))

        payload_bytes := payload.data
        out_arg := e.get(3)?

        switch out_arg.node_type {
        case NodeType.Identifier(out_name):
            // For enum payloads, the actual bytes may be less than max type size
            // (e.g., Option.None is just 8 bytes tag, Option.Some(x) is 8 + payload)
            // For struct payloads, bytes should match type size exactly
            mut bytes_to_copy := 0
            if is_enum_payload {
                // For enums, copy what we have (must have at least 8 bytes for tag)
                if payload_bytes.len().gteq(8) {
                    bytes_to_copy = payload_bytes.len()
                } else {
                    throw e.lang_error(context.path, "eval", "enum_get_payload: enum payload too small")
                }
            } else {
                // For structs/primitives, must have at least type_size bytes
                if payload_bytes.len().gteq(type_size) {
                    bytes_to_copy = type_size
                } else {
                    throw e.lang_error(context.path, "eval", format(
                        "enum_get_payload: payload size ", payload_bytes.len().to_str(), " < expected type size ", type_size.to_str()
                    ))
                }
            }
            // Get out variable offset
            offset := context.scope_stack.lookup_var(out_name)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "eval", format("Variable '", out_name, "' not found"))
            }
            // Copy payload bytes to out variable
            g_heap.set(offset, payload_bytes.ptr.data, bytes_to_copy)
            return EvalResult.new("")
        case:
            // Not an identifier
        }
    }
    throw e.lang_error(context.path, "eval", "enum_get_payload: enum has no payload or unsupported payload type")
}

/// Returns the payload's enum tag as a string (e.g., "TTypeDef.TEnumDef").
/// Used for nested enum pattern matching without extracting the full payload.
/// Args: enum_get_payload_type(enum_expr, VariantName, PayloadType)
/// - VariantName: the variant whose payload we're accessing (e.g., TType)
/// - PayloadType: the type of the payload (e.g., TTypeDef)
/// In interpreter, we just use temp_enum_payload. The extra args are for ccodegen.
func_enum_get_payload_type : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "enum_get_payload_type", 3, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }

    // Get payload type from third argument (for validation)
    type_arg := e.get(3)?
    mut expected_type_name := ""
    switch type_arg.node_type {
    case NodeType.Identifier(name):
        expected_type_name = name
    case:
        throw e.lang_error(context.path, "eval", "enum_get_payload_type: type argument must be a type name")
    }

    // After eval_expr, context.temp_enum_payload should contain the payload data
    if not(context.temp_enum_payload.is_null()) {
        // Read EnumPayload from heap
        mut payload := EnumPayload(data=Vec.new(U8), value_type=ValueType.TCustom(""))
        memcpy(to_ptr(payload), context.temp_enum_payload.data, size_of(EnumPayload))

        payload_bytes := payload.data

        // Check if payload type is an enum
        switch payload.value_type {
        case ValueType.TCustom(type_name):
            // Verify payload type matches expected
            if not(type_name.eq(expected_type_name)) {
                throw e.lang_error(context.path, "eval", format(
                    "enum_get_payload_type: expected payload type '", expected_type_name, "', got '", type_name, "'"
                ))
            }
            mut enum_def := context.scope_stack.lookup_enum(type_name)?
            catch (err: KeyNotFoundError) {
                // Not an enum, return empty string
                return EvalResult.new("")
            }
            // Read the first 8 bytes as the enum tag
            if payload_bytes.len().gteq(8) {
                // Read tag directly from payload bytes using memcpy
                mut tag := 0
                memcpy(to_ptr(tag), payload_bytes.ptr.data, 8)
                // Look up variant name from tag position
                variant_name := Context.variant_pos_to_str(enum_def, tag, context.path, e)?
                return EvalResult.new(format(type_name, ".", variant_name))
            }
        case:
        }
    }

    // No payload or not an enum payload - return empty string
    return EvalResult.new("")
}

func_u8_to_i64 : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "u8_to_i64", 1, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    a := I64.from_str(result.value)
    return EvalResult.new(a.to_str())
}

func_i64_to_u8 : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "i64_to_u8", 1, false)?
    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }
    return EvalResult.new(result.value)
}

func_u8_add : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "U8_add", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Wrapping add: (a + b) mod 256
    result := mod(a.add(b), 256)
    return EvalResult.new(result.to_str())
}

func_u8_sub : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "U8_sub", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Wrapping sub: (a - b + 256) mod 256
    result := mod(a.sub(b).add(256), 256)
    return EvalResult.new(result.to_str())
}

func_u8_mul : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "U8_mul", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Wrapping mul: (a * b) mod 256
    result := mod(a.mul(b), 256)
    return EvalResult.new(result.to_str())
}

func_u8_div : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "U8_div", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Division returns 0 on divide by zero
    mut result := 0
    if not(I64.eq(b, 0)) {
        result = div(a, b)
    }
    return EvalResult.new(result.to_str())
}

func_u8_mod : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "U8_mod", 2, false)?
    a_result := eval_expr(context, e.get(1)?)?
    if a_result.is_throw { return a_result }
    b_result := eval_expr(context, e.get(2)?)?
    if b_result.is_throw { return b_result }
    a := I64.from_str(a_result.value)
    b := I64.from_str(b_result.value)
    // Modulo returns 0 on divide by zero
    mut result := 0
    if not(I64.eq(b, 0)) {
        result = mod(a, b)
    }
    return EvalResult.new(result.to_str())
}

// ---------- core procs implementations for eval

// Note: If this prints an Array instead of a Str, check that single_print is declared
// as `ext_proc(s: Str)` not `ext_proc(args: ..Str)` in core.til. Variadic wrapping
// bypasses validate_arg_count by passing args as a single Array. (Bug #30)
proc_single_print : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "single_print", 1, true)?

    result := eval_expr(context, e.get(1)?)?
    if result.is_throw { return result }

    print(result.value)
    return EvalResult.new("")
}

proc_print_flush : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "print_flush", 0, true)?
    print_flush()
    return EvalResult.new("")
}

// Bug #98: Now throws ReadError instead of Str
proc_input_read_line : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "input_read_line", 1, true)?

    prompt_result := eval_expr(context, e.get(1)?)?
    if prompt_result.is_throw {
        return prompt_result
    }
    prompt := prompt_result.value

    line := input_read_line(prompt)?
    return EvalResult.new(line)

    catch (err: ReadError) {
        return EvalResult.new_throw(err.msg, ValueType.TCustom("ReadError"))
    }
}

// Bug #98: Now throws ReadError instead of returning empty string
proc_readfile : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "readfile", 1, true)?

    result := eval_expr(context, e.get(1)?)?
    if result.is_throw {
        return result // Propagate throw
    }
    path := result.value

    // Call host-provided readfile (when running on rstil)
    source := readfile(path)?
    return EvalResult.new(source)

    catch (err: ReadError) {
        return EvalResult.new_throw(err.msg, ValueType.TCustom("ReadError"))
    }
}

// Bug #98: Now throws WriteError instead of panicking
proc_writefile : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "writefile", 2, true)?

    path_result := eval_expr(context, e.get(1)?)?
    if path_result.is_throw {
        return path_result
    }
    path := path_result.value

    contents_result := eval_expr(context, e.get(2)?)?
    if contents_result.is_throw {
        return contents_result
    }
    contents := contents_result.value

    // Call host-provided writefile (when running on rstil)
    writefile(path, contents)?
    return EvalResult.new("")

    catch (err: WriteError) {
        return EvalResult.new_throw(err.msg, ValueType.TCustom("WriteError"))
    }
}

// WARNING: run_cmd executes shell commands.
// In mode safe_script, only whitelisted commands are allowed (configurable).
// In other modes, arbitrary commands can be executed - use with caution.
// Returns exit code as I64, output is written to mut output_str arg
proc_run_cmd : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    // run_cmd(mut output_str, args...) - runs a command with arguments
    // First arg is mut output string, second is command, remaining are args
    // Returns exit code as I64
    if e.params.len().lt(3) {
        throw e.error(context.path, "eval", "run_cmd requires at least 2 arguments (mut output_str, command)")
    }

    // Get output variable name (must be identifier for mut assignment)
    output_var := e.get(1)?

    cmd_result := eval_expr(context, e.get(2)?)?
    if cmd_result.is_throw {
        return cmd_result
    }
    cmd := cmd_result.value

    // Check command against whitelists
    if context.mode_def.name.eq("safe_script") {
        if not(SAFE_COMMANDS.contains(cmd)) {
            throw e.error(context.path, "eval", format("Command '", cmd, "' not in safe_script whitelist"))
        }
    } else {
        if not(ALLOWED_COMMANDS.contains(cmd)) {
            throw e.error(context.path, "eval", format("Command '", cmd, "' not in allowed whitelist"))
        }
    }

    // Build shell command string: cmd 'arg1' 'arg2' ...
    // Single quotes within args are escaped as '\''
    mut cmd_str := cmd
    for i in 3..e.params.len() {
        arg_result := eval_expr(context, e.get(i)?)?
        if arg_result.is_throw {
            return arg_result
        }
        arg := arg_result.value
        // Escape single quotes and wrap in single quotes
        escaped := arg.replace("'", "'\\''")
        cmd_str = cmd_str.concat(" '").concat(escaped).concat("'")
    }

    // Run via bash -c to execute the command string
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", cmd_str)

    // Assign output to mut output variable
    mut var_name := ""
    switch output_var.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        throw e.error(context.path, "eval", "run_cmd first argument must be an identifier")
    }
    EvalHeap.insert_primitive(context, var_name, ValueType.TCustom("Str"), output, e)?

    return EvalResult.new(exit_code.to_str())
}

// ---------- Introspection functions

func_has_const : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "has_const", 2, false)?

    result1 := eval_expr(context, e.get(1)?)?
    if result1.is_throw { return result1 }
    type_name := result1.value

    result2 := eval_expr(context, e.get(2)?)?
    if result2.is_throw { return result2 }
    const_name := result2.value

    // Check if type exists in struct_defs
    struct_def := context.scope_stack.lookup_struct(type_name)?
    // Check for immutable field (!is_mut)
    decl := struct_def.get_member(const_name)?
    if not(decl.is_mut) {
        return EvalResult.new("true")
    }
    catch (err: KeyNotFoundError) {
        // Type or member not found
    }

    return EvalResult.new("false")
}

func_has_field : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "has_field", 2, false)?

    result1 := eval_expr(context, e.get(1)?)?
    if result1.is_throw { return result1 }
    type_name := result1.value

    result2 := eval_expr(context, e.get(2)?)?
    if result2.is_throw { return result2 }
    field_name := result2.value

    // Check if type exists in struct_defs
    struct_def := context.scope_stack.lookup_struct(type_name)?
    // Check for mutable field (is_mut)
    decl := struct_def.get_member(field_name)?
    if decl.is_mut {
        return EvalResult.new("true")
    }
    catch (err: KeyNotFoundError) {
        // Type or member not found
    }

    return EvalResult.new("false")
}

func_exit : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "exit", 1, false)?

    e_exit_code := e.get(1)?

    // Check if it's a number literal using pattern matching
    switch e_exit_code.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(num_str):
            exit_code := I64.from_str(num_str)
            exit(exit_code)
            return EvalResult.new("")  // unreachable, exit() never returns
        case:
            // Not a number literal
        }
    case:
        // Not a literal
    }
    throw e.lang_error(context.path, "eval", "calling core proc 'exit', but found non-literal instead of literal i64 exit code.")
}

// ---------- Process spawning functions

proc_spawn_cmd : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "spawn_cmd", 1, true)?

    cmd_result := eval_expr(context, e.get(1)?)?
    if cmd_result.is_throw { return cmd_result }
    cmd := cmd_result.value

    // Call host-provided spawn_cmd (when running on rstil)
    pid := spawn_cmd(cmd)?

    catch (err: SpawnError) {
        throw e.error(context.path, "eval", format("spawn_cmd failed: ", err.msg))
    }

    return EvalResult.new(pid.to_str())
}

proc_check_cmd_status : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "check_cmd_status", 1, true)?

    pid_result := eval_expr(context, e.get(1)?)?
    if pid_result.is_throw { return pid_result }
    pid := I64.from_str(pid_result.value)

    // Call host-provided check_cmd_status (when running on rstil)
    status := check_cmd_status(pid)
    return EvalResult.new(status.to_str())
}

proc_sleep : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "sleep", 1, true)?

    ms_result := eval_expr(context, e.get(1)?)?
    if ms_result.is_throw { return ms_result }
    ms := I64.from_str(ms_result.value)

    // Call host-provided sleep (when running on rstil)
    sleep(ms)?

    catch (err: SleepError) {
        throw e.error(context.path, "eval", format("sleep failed: ", err.msg))
    }

    return EvalResult.new("")
}

proc_get_thread_count : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "get_thread_count", 0, true)?

    // Call host-provided get_thread_count (when running on rstil)
    count := get_thread_count()

    return EvalResult.new(count.to_str())
}

func_file_mtime : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "file_mtime", 1, false)?

    path_result := eval_expr(context, e.get(1)?)?
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided file_mtime (when running on rstil)
    mtime := file_mtime(path)

    return EvalResult.new(mtime.to_str())
}

// Bug #98: Now throws IOError instead of returning empty string
func_list_dir_raw : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "list_dir_raw", 1, false)?

    path_result := eval_expr(context, e.get(1)?)?
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided list_dir_raw (when running on rstil)
    raw := list_dir_raw(path)?
    return EvalResult.new(raw)

    catch (err: IOError) {
        return EvalResult.new_throw(err.msg, ValueType.TCustom("IOError"))
    }
}

func_fs_parent_dir : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "fs_parent_dir", 1, false)?

    path_result := eval_expr(context, e.get(1)?)?
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided fs_parent_dir (when running on rstil)
    parent := fs_parent_dir(path)

    return EvalResult.new(parent)
}

proc_fs_mkdir_p : proc(mut context: Context, e: Expr) returns EvalResult throws Str = {
    validate_arg_count(context.path, e, "fs_mkdir_p", 1, true)?

    path_result := eval_expr(context, e.get(1)?)?
    if path_result.is_throw { return path_result }
    path := path_result.value

    // Call host-provided fs_mkdir_p (when running on rstil)
    result := fs_mkdir_p(path)

    return EvalResult.new(result.to_str())
}
