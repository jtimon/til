mode liba

import("self.init")
import("self.parser")

// EvalHeap: Memory management for the TIL interpreter
// Extracted from interpreter.rs to enable incremental translation to TIL.


EvalHeapMapping := struct {
    mut name: Str = ""
    mut offset: I64 = 0
}

SymbolEntry := struct {
    mut name: Str = ""
    mut info: SymbolInfo = SymbolInfo()
}

// Result from insert_struct_core containing mappings to be stored
StructInsertResult := struct {
    mut heap_mappings: Vec = Vec.new(EvalHeapMapping)
    mut symbols: Vec = Vec.new(SymbolEntry)
}

// Result from insert_string_core containing string offset and length
StringInsertInfo := struct {
    mut string_offset: I64 = 0
    mut str_len: I64 = 0
}

// Result from insert_enum_core containing optional mapping and enum value
EnumInsertResult := struct {
    mut has_mapping: Bool = false
    mut mapping_name: Str = ""
    mut mapping_offset: I64 = 0
    mut enum_val: EnumVal = EnumVal()
}

// Bug #133: Structs for extracting heap contents for serialization to static arrays
/// Contents of a Vec for serialization to static C arrays
VecContents := struct {
    mut element_type_name: Str = ""
    mut type_size: I64 = 0
    mut element_bytes: Vec = Vec.new(Vec)  // Vec of Vec<U8>

namespace:
    clone : func(self: VecContents) returns VecContents = {
        return VecContents(element_type_name=self.element_type_name.clone(), type_size=self.type_size, element_bytes=self.element_bytes.clone())
    }
}

EvalHeap := struct {
    mut temp_id_counter: I64 = 0
    mut default_instances: Map = Map.new(Str, I64)  // type name -> heap pointer of default template
    mut _heap_bases: Vec = Vec.new(I64)  // heap block base ptrs
    mut _heap_sizes: Vec = Vec.new(I64)  // heap block sizes
    mut total_heap_bytes: I64 = 0  // running total of heap bytes allocated

namespace:
    new : proc() returns EvalHeap = {
        mut a := EvalHeap()
        return a
    }

    /// Total heap bytes allocated
    len : func(self: EvalHeap) returns I64 = {
        return self.total_heap_bytes
    }

    /// Read bytes at offset (raw pointer access, returns pointer to data)
    get : func(_self: EvalHeap, offset: I64, _num_bytes: I64) returns I64 = {
        return offset  // raw pointer IS the address
    }

    /// Write bytes at offset (raw memcpy)
    set : proc(mut _self: EvalHeap, offset: I64, src_ptr: I64, num_bytes: I64) = {
        memcpy(offset, src_ptr, num_bytes)
    }

    /// Issue #163: Allocate zeroed memory on the heap, return raw pointer as offset
    heap_alloc : proc(mut self: EvalHeap, size: I64) returns I64 throws Str = {
        // Zero-size structs get 1 byte so we have a unique address
        mut alloc_size := size
        if size.eq(0) {
            alloc_size = 1
        }
        alloc_ptr := malloc(alloc_size)?
        result_ptr := alloc_ptr
        loop_size := alloc_size
        self.total_heap_bytes = self.total_heap_bytes.add(alloc_size)
        self._heap_bases.push(alloc_ptr)
        self._heap_sizes.push(alloc_size)
        // Zero-initialize (reserve zeroes memory, so we must too for compatibility)
        mut zero : U8 = 0
        for i in 0..loop_size {
            memcpy(add(result_ptr, i), to_ptr(zero), 1)
        }
        return result_ptr

        catch (err: BadAlloc) {
            throw "heap_alloc: allocation failed"
        }
    }

    /// Issue #163: Free a heap-allocated block
    heap_free : proc(mut self: EvalHeap, ptr: I64) = {
        for i in 0..self._heap_bases.len() {
            base := cast(I64, self._heap_bases.get(i)?)
            if base.eq(ptr) {
                self._heap_bases.set(i, 0)?  // mark as freed
                self._heap_sizes.set(i, 0)?
                free(ptr)
                return
            }
        }
        catch (err: IndexOutOfBoundsError) { }
    }

    // === EVAL-PHASE MEMORY OPERATIONS ===
    // These methods manage runtime memory allocation and access
    // They take Context as parameter to access type info and heap_index

    // Check if id refers to an instance field (e.g., "myStruct.field") vs a type constant
    // Bug #160: Now checks if ANY prefix of the path exists in heap_index
    // This handles type constants like "MyNamespace.field_static_str.c_string.data"
    // where the base is "MyNamespace.field_static_str", not "MyNamespace"
    /// Check if id refers to an instance field (e.g., "myStruct.field") vs a type constant
    is_instance_field : func(ctx: Context, id: Str) returns Bool = {
        if not(id.contains(".")) {
            return false
        }
        parts := id.split(".")?
        base := cast(Str, parts.get(0)?)
        mut sym := ctx.scope_stack.lookup_symbol(base)?
        switch sym.value_type {
        case ValueType.TType(inner):
            return false
        case:
            return true
        }
        catch (err: KeyNotFoundError) {
            return false
        }
        catch (err: IndexOutOfBoundsError) {
            return false
        }
    }

    get_u8 : func(ctx: Context, id: Str, e: Expr) returns U8 throws Str = {
        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants (e.g., Ptr.NULL)
        mut offset := 0
        if EvalHeap.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_u8: ", err))
            }
        } else {
            // Variable or type constant - try direct lookup first
            // If not found and path has dots, use get_field_offset (for namespace field subpaths)
            mut found := false
            offset = ctx.scope_stack.lookup_var(id)?
            found = true
            catch (err: KeyNotFoundError) {
                if id.contains(".") {
                    offset = ctx.get_field_offset(id)?
                    found = true
                    catch (err2: Str) {
                        throw e.lang_error(ctx.path, "context", format("get_u8 fallback: ", err2))
                    }
                }
            }
            if not(found) {
                throw e.lang_error(ctx.path, "context", format("u8 not found for id '", id, "'"))
            }
        }

        mut val : U8 = 0
        memcpy(to_ptr(val), g_heap.get(offset, 1), 1)
        return val
    }

    get_i64 : func(ctx: Context, id: Str, e: Expr) returns I64 throws Str = {
        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants (e.g., Ptr.NULL)
        mut offset := 0
        if EvalHeap.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_i64: ", err))
            }
        } else {
            // Variable or type constant - try direct lookup first
            // If not found and path has dots, use get_field_offset (for namespace field subpaths)
            mut found := false
            offset = ctx.scope_stack.lookup_var(id)?
            found = true
            catch (err: KeyNotFoundError) {
                if id.contains(".") {
                    offset = ctx.get_field_offset(id)?
                    found = true
                    catch (err2: Str) {
                        throw e.lang_error(ctx.path, "context", format("get_i64 fallback: ", err2))
                    }
                }
            }
            if not(found) {
                throw e.lang_error(ctx.path, "context", format("i64 not found for id '", id, "'"))
            }
        }

        mut val : I64 = 0
        memcpy(to_ptr(val), g_heap.get(offset, 8), 8)
        return val
    }

    // Core logic for insert_i64 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_i64_core : func(ctx: Context, id: Str, i64_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError = {
        v := I64.from_str(i64_str)
        // Note: I64.from_str currently panics on invalid input, doesn't throw

        if EvalHeap.is_instance_field(ctx, id) {
            // Bug #160: Deterministic dispatch - field paths ALWAYS use get_field_offset
            field_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("insert_i64: ", err))
            }

            g_heap.set(field_offset, to_ptr(v), 8)
            throw KeyNotFoundError(msg="already handled")
        }

        // For non-instance fields (including struct constants like Vec.INIT_CAP), create new entry
        offset := g_heap.heap_alloc(8)?
        g_heap.set(offset, to_ptr(v), 8)
        return offset
    }

    insert_i64 : proc(mut ctx: Context, id: Str, i64_str: Str, e: Expr) throws Str = {
        offset := EvalHeap.insert_i64_core(ctx, id, i64_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_i64_into_frame : proc(ctx: Context, mut frame: ScopeFrame, id: Str, i64_str: Str, e: Expr) throws Str = {
        offset := EvalHeap.insert_i64_core(ctx, id, i64_str, e)?
        frame.heap_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // Core logic for insert_u8 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_u8_core : func(ctx: Context, id: Str, u8_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError = {
        v := U8.from_str(u8_str)?
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        if EvalHeap.is_instance_field(ctx, id) {
            // Bug #160: Deterministic dispatch - field paths ALWAYS use get_field_offset
            field_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("insert_u8: ", err))
            }
            g_heap.set(field_offset, to_ptr(v), 1)
            throw KeyNotFoundError(msg="already handled")
        }

        offset := g_heap.heap_alloc(1)?
        g_heap.set(offset, to_ptr(v), 1)
        return offset
    }

    insert_u8 : proc(mut ctx: Context, id: Str, u8_str: Str, e: Expr) throws Str = {
        offset := EvalHeap.insert_u8_core(ctx, id, u8_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_u8_into_frame : proc(ctx: Context, mut frame: ScopeFrame, id: Str, u8_str: Str, e: Expr) throws Str = {
        offset := EvalHeap.insert_u8_core(ctx, id, u8_str, e)?
        frame.heap_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // Core logic for insert_struct - does all the work but returns mappings instead of inserting them
    // existing_offset: -1 means None (allocate new), >= 0 means use that offset
    insert_struct_core : proc(mut ctx: Context, id: Str, custom_type_name: Str, existing_offset: I64, defaults: Map, e: Expr) returns StructInsertResult throws Str = {
        mut result := StructInsertResult()

        // Lookup the struct definition
        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: definition for '", custom_type_name, "' not found"))
        }

        // Determine mutability from symbols table
        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: id '", id, "' for struct '", custom_type_name, "' not found in symbols"))
        }
        is_mut := sym.is_mut

        // Calculate total size (for now no alignment)
        mut total_size := 0
        mut field_offsets := Map.new(Str, I64)

        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "context", "insert_struct: Unsupported value type in struct")
                }

                field_offsets.set(decl.name, total_size)
                total_size = add(total_size, field_size)
            }
        }

        // Either use existing offset (for nested structs) or allocate new memory
        mut offset := existing_offset
        if existing_offset.lt(0) {
            offset = g_heap.heap_alloc(total_size)?
        }
        mut base_mapping := EvalHeapMapping()
        base_mapping.name = id
        base_mapping.offset = offset
        result.heap_mappings.push(base_mapping)

        // Temporarily register base var so get_field_offset works during field initialization
        ctx.scope_stack.insert_var(id, offset)?
        ctx.scope_stack.declare_symbol(id, SymbolInfo(value_type=ValueType.TCustom(custom_type_name), is_mut=true))?

        // Store each field's default value
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                field_offset := cast(I64, field_offsets.get(decl.name)?)
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing field offset for '", decl.name, "'"))
                }

                default_value := cast(Str, defaults.get(decl.name)?)
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing pre-evaluated default for field '", decl.name, "'"))
                }

                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Check if it's an enum
                    mut is_enum := true
                    mut enum_def := ctx.scope_stack.lookup_enum(type_name)?
                    catch (err: KeyNotFoundError) {
                        is_enum = false
                    }

                    if is_enum {
                        parts := default_value.split(".")?
                        if not(parts.len().eq(2)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        part0 := cast(Str, parts.get(0)?)
                        if not(part0.eq(type_name)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        variant := cast(Str, parts.get(1)?)
                        // Find variant index - Bug #38 fix: use variants Vec
                        mut index : I64 = 0
                        mut found_variant := false
                        mut vi := 0
                        while vi.lt(enum_def.variants.len()) {
                            ev := cast(EnumVariant, enum_def.variants.get(vi)?)
                            if ev.name.eq(variant) {
                                index = vi
                                found_variant = true
                            }
                            vi = add(vi, 1)
                        }
                        if not(found_variant) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown enum variant '", variant, "' for field '", decl.name, "'"))
                        }
                        g_heap.set(add(offset, field_offset), to_ptr(index), 8)
                    } else {
                        if type_name.eq("U8") {
                            u8_val := U8.from_str(default_value)?
                            // Note: U8.from_str panics on invalid input, doesn't throw
                            mut dest_u8 : U8 = u8_val
                            g_heap.set(add(offset, field_offset), to_ptr(dest_u8), 1)
                        } else {
                            if type_name.eq("I64") {
                                i64_val := I64.from_str(default_value)
                                // Note: I64.from_str panics on invalid input, doesn't throw
                                g_heap.set(add(offset, field_offset), to_ptr(i64_val), 8)
                            } else if ctx.scope_stack.has_struct(type_name) {
                                // It's a struct
                                nested_combined_name := format(id, ".", decl.name)
                                nested_symbol := SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true)
                                // Must declare symbol BEFORE recursive call (needed for is_mut lookup)
                                ctx.scope_stack.declare_symbol(nested_combined_name, nested_symbol)?
                                mut sym_entry := SymbolEntry()
                                sym_entry.name = nested_combined_name
                                sym_entry.info = nested_symbol
                                result.symbols.push(sym_entry)

                                // Special case: Str field initialization
                                if type_name.eq("Str") {
                                    // Register inline offset BEFORE insert_string so it writes to the inline space
                                    str_field_offset := add(offset, field_offset)
                                    mut str_mapping := EvalHeapMapping()
                                    str_mapping.name = nested_combined_name
                                    str_mapping.offset = str_field_offset
                                    result.heap_mappings.push(str_mapping)
                                    EvalHeap.insert_string(ctx, nested_combined_name, default_value, e)?
                                } else {
                                    // Use existing offset for nested struct (inline allocation)
                                    nested_field_offset := add(offset, field_offset)
                                    mut nested_mapping := EvalHeapMapping()
                                    nested_mapping.name = nested_combined_name
                                    nested_mapping.offset = nested_field_offset
                                    result.heap_mappings.push(nested_mapping)
                                    // Extract nested defaults (field.subfield -> subfield)
                                    prefix := format(decl.name, ".")
                                    mut nested_defaults := Map.new(Str, Str)
                                    default_keys := defaults.keys
                                    for dk: Str in default_keys {
                                        if dk.starts_with(prefix) {
                                            rest := dk.strip_prefix(prefix)
                                            dv := cast(Str, defaults.get(dk)?)
                                            catch (err: KeyNotFoundError) {
                                                panic(loc(), "insert_struct_core: key not found in defaults")
                                            }
                                            nested_defaults.set(rest, dv)
                                        }
                                    }
                                    nested_result := EvalHeap.insert_struct_core(ctx, nested_combined_name, type_name, nested_field_offset, nested_defaults, e)?
                                    catch (err: Str) {
                                        throw e.lang_error(ctx.path, "context", format("insert_struct: Failed to initialize nested struct '", id, ".", decl.name, "'"))
                                    }
                                    // Collect nested mappings
                                    result.heap_mappings.extend(nested_result.heap_mappings)
                                    result.symbols.extend(nested_result.symbols)
                                }
                            } else {
                                throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown field type '", type_name, "'"))
                            }
                        }
                    }
                case:
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Unsupported field value type '", value_type_to_str(decl.value_type), "'"))
                }

                // Bug #160: Removed field heap_mappings.push - offsets are now calculated dynamically
                // Symbol still needed for type checking
                combined_name := format(id, ".", decl.name)
                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)
            }
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct_core: ", err.msg))
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        // Remove temp registration (caller will apply the final mappings)
        _ := ctx.scope_stack.remove_var(id)?
        _ := ctx.scope_stack.remove_symbol(id)?

        return result
    }

    // Generate heap mappings and symbols for a struct without writing bytes.
    // Used for template-based insertion where bytes are already memcpy'd.
    generate_struct_mappings : proc(mut ctx: Context, id: Str, custom_type_name: Str, base_offset: I64, e: Expr) returns StructInsertResult throws Str = {
        mut result := StructInsertResult()

        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("struct '", custom_type_name, "' not found"))
        }

        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("symbol '", id, "' not found"))
        }
        is_mut := sym.is_mut

        // Calculate field offsets (same as insert_struct_core)
        mut current_offset := 0
        mut field_offsets := Map.new(Str, I64)
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "generate_struct_mappings", "Unsupported value type")
                }
                field_offsets.set(decl.name, current_offset)
                current_offset = add(current_offset, field_size)
            }
        }

        // Add base struct mapping
        mut base_mapping := EvalHeapMapping()
        base_mapping.name = id
        base_mapping.offset = base_offset
        result.heap_mappings.push(base_mapping)

        // Generate symbols for each field (Bug #160: no longer generate field heap mappings)
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_rel_offset := 0
                if field_offsets.contains_key(decl.name) {
                    fro := cast(I64, field_offsets.get(decl.name)?)
                    field_rel_offset = fro
                }
                catch (err: KeyNotFoundError) {
                    panic(loc(), "field_offsets: guarded by contains_key: ", err.msg)
                }
                field_abs_offset := add(base_offset, field_rel_offset)
                combined_name := format(id, ".", decl.name)

                // Bug #160: Removed heap_mappings.push - offsets are now calculated dynamically
                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)

                // Handle nested structs recursively
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if not(type_name.eq("U8")) {
                        if not(type_name.eq("I64")) {
                            if ctx.scope_stack.has_struct(type_name) {
                                // Declare nested symbol first
                                ctx.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true))?
                                nested := EvalHeap.generate_struct_mappings(ctx, combined_name, type_name, field_abs_offset, e)?
                                result.symbols.extend(nested.symbols)
                            }
                        }
                    }
                case:
                }
            }
        }

        return result
    }

    // Insert a struct by copying from a cached template.
    // Much faster than insert_struct_core for subsequent instances of the same type.
    insert_struct : proc(mut ctx: Context, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str = {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the heap's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_heap.get(template_offset, struct_size), struct_size)

        // Allocate new memory on heap
        new_offset := g_heap.heap_alloc(struct_size)?

        // Copy from temporary buffer to new location
        g_heap.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Generate and apply mappings
        result := EvalHeap.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?
        for m: EvalHeapMapping in result.heap_mappings {
            ctx.scope_stack.insert_var(m.name, m.offset)?
        }
        for s: SymbolEntry in result.symbols {
            ctx.scope_stack.declare_symbol(s.name, s.info)?
        }

        catch (err: BadAlloc) {
            panic(loc(), "insert_struct: buy more ram")
        }
    }

    // Insert a struct from template into a specific frame (for function parameters).
    insert_struct_into_frame : proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str = {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the heap's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_heap.get(template_offset, struct_size), struct_size)

        // Allocate new memory on heap
        new_offset := g_heap.heap_alloc(struct_size)?

        // Copy from temporary buffer to new location
        g_heap.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Temporarily push frame for generate_struct_mappings
        ctx.scope_stack.frames.push(frame.clone())

        result := EvalHeap.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?

        // Pop frame back
        mut popped_frame := ScopeFrame()
        ctx.scope_stack.frames.pop(popped_frame)?
        frame = popped_frame

        for m: EvalHeapMapping in result.heap_mappings {
            frame.heap_index.set(m.name, m.offset)
        }
        for s: SymbolEntry in result.symbols {
            frame.symbols.set(s.name, s.info)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_struct_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: BadAlloc) {
            panic(loc(), "insert_struct_into_frame: buy more ram")
        }
    }

    // Core logic for insert_string - returns StringInsertInfo if caller needs to create struct, throws KeyNotFoundError if already handled
    insert_string_core : proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) returns StringInsertInfo throws Str, KeyNotFoundError = {
        is_field := EvalHeap.is_instance_field(ctx, id)

        // Allocate string data (heap_alloc returns zeroed memory, so null terminator is free)
        string_offset := g_heap.heap_alloc(add(value_str.len(), 1))?
        g_heap.set(string_offset, value_str.c_string.data, value_str.len())
        str_len := value_str.len()

        if is_field {
            mut have_base_offset := true
            mut base_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                have_base_offset = false
            }

            if have_base_offset {
                mut existing_str_def := ctx.scope_stack.lookup_struct("Str")?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", "ERROR: 'Str' struct definition not found")
                }

                mut existing_offset := 0
                for existing_decl: Declaration in existing_str_def.members {
                    if existing_decl.is_mut {
                        existing_type_size := ctx.get_type_size(value_type_to_str(existing_decl.value_type))?
                        absolute_offset := add(base_offset, existing_offset)

                        if existing_decl.name.eq("c_string") {
                            g_heap.set(absolute_offset, to_ptr(string_offset), 8)
                        } else {
                            if existing_decl.name.eq("_len") {
                                g_heap.set(absolute_offset, to_ptr(str_len), 8)
                            }
                        }

                        existing_offset = add(existing_offset, existing_type_size)
                    }
                }
                throw KeyNotFoundError(msg="already handled")
            }

            // Not yet inserted - insert fresh inlined Str
            mut str_def := ctx.scope_stack.lookup_struct("Str")?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", "'Str' struct definition not found")
            }

            // Calculate total Str struct size
            mut str_size := 0
            for decl: Declaration in str_def.members {
                if decl.is_mut {
                    str_size = add(str_size, ctx.get_type_size(value_type_to_str(decl.value_type))?)
                }
            }

            struct_offset := g_heap.heap_alloc(str_size)?
            mut current_offset := 0

            for decl: Declaration in str_def.members {
                if decl.is_mut {
                    type_size := ctx.get_type_size(value_type_to_str(decl.value_type))?

                    field_offset := add(struct_offset, current_offset)
                    if decl.name.eq("c_string") {
                        g_heap.set(field_offset, to_ptr(string_offset), 8)
                    } else {
                        if decl.name.eq("_len") {
                            g_heap.set(field_offset, to_ptr(str_len), 8)
                        }
                    }

                    current_offset = add(current_offset, type_size)
                }
            }

            ctx.scope_stack.insert_var(id, struct_offset)?
            throw KeyNotFoundError(msg="already handled")
        }

        mut result := StringInsertInfo()
        result.string_offset = string_offset
        result.str_len = str_len

        return result
    }

    insert_string : proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) throws Str = {
        info := EvalHeap.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        template_offset := cast(I64, g_heap.default_instances.get("Str")?)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string", "Str template not found - ensure str.til is imported")
        }
        EvalHeap.insert_struct(ctx, id, "Str", template_offset, e)?
        // Bug #160: Use get_field_offset instead of lookup_var for field paths
        c_string_offset := ctx.get_field_offset(format(id, ".c_string"))?
        catch (err: Str) {
            throw e.lang_error(ctx.path, "insert_string", format("missing '", id, ".c_string': ", err))
        }
        len_offset := ctx.get_field_offset(format(id, "._len"))?
        catch (err: Str) {
            throw e.lang_error(ctx.path, "insert_string", format("missing '", id, "._len': ", err))
        }
        g_heap.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_heap.set(len_offset, to_ptr(info.str_len), 8)

    }

    insert_string_into_frame : proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, value_str: Str, e: Expr) throws Str = {
        info := EvalHeap.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        // During compile-time evaluation (builder path), the Str template may not exist
        // because the interpreter never evaluated struct declarations. This is OK for
        // macros with Type parameters - the type name is only used in AST construction,
        // not read as a runtime Str value.
        template_offset := cast(I64, g_heap.default_instances.get("Str")?)
        catch (err: KeyNotFoundError) {
            return
        }
        EvalHeap.insert_struct_into_frame(ctx, frame, id, "Str", template_offset, e)?
        // Bug #160: Calculate field offsets from base offset in frame
        // The base struct was just inserted into frame.heap_index
        base_offset := cast(I64, frame.heap_index.get(id)?)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", format("missing '", id, "' in frame"))
        }
        // Str layout: c_string (Ptr), _len (I64), cap (I64)
        // Get field offsets from struct definition
        mut str_def := ctx.scope_stack.lookup_struct("Str")?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", "Str struct not found")
        }
        mut c_string_rel_offset := 0
        mut len_rel_offset := 0
        mut current_offset := 0
        for decl: Declaration in str_def.members {
            if decl.is_mut {
                if decl.name.eq("c_string") {
                    c_string_rel_offset = current_offset
                } else if decl.name.eq("_len") {
                    len_rel_offset = current_offset
                }
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "insert_string_into_frame", "unexpected field type")
                }
                current_offset = add(current_offset, field_size)
            }
        }
        c_string_offset := add(base_offset, c_string_rel_offset)
        len_offset := add(base_offset, len_rel_offset)
        g_heap.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_heap.set(len_offset, to_ptr(info.str_len), 8)
    }

    // Helper function to insert primitive types (I64, U8, Str) based on value_type
    insert_primitive : proc(mut ctx: Context, var_name: Str, value_type: ValueType, value: Str, e: Expr) throws Str = {
        switch value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                EvalHeap.insert_i64(ctx, var_name, value, e)?
            } else {
                if type_name.eq("U8") {
                    EvalHeap.insert_u8(ctx, var_name, value, e)?
                } else {
                    if type_name.eq("Str") {
                        EvalHeap.insert_string(ctx, var_name, value, e)?
                    } else {
                        throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
                    }
                }
            }
        case:
            throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
        }
    }

    get_enum_at_offset : func(ctx: Context, enum_type: Str, offset: I64, e: Expr) returns EnumVal throws Str = {
        // Read enum from a specific offset (used for nested enum payloads)
        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_heap.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum_at_offset: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut payload_type := ValueType.TCustom("")
            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
            switch payload_type {
            case ValueType.TCustom(inner_type):
                // This variant has a payload - recursively determine size
                payload_size := EvalHeap.get_payload_size_for_type(ctx, payload_type, add(offset, 8), e)?
                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    // Copy payload bytes
                    mut payload_bytes := Vec.new(U8)
                    mut pi := 0
                    while pi.lt(payload_size) {
                        mut byte_val : U8 = 0
                        memcpy(to_ptr(byte_val), g_heap.get(add(payload_offset, pi), 1), 1)
                        payload_bytes.push(byte_val)
                        pi = add(pi, 1)
                    }
                    // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                    heap_vec_ptr := malloc(size_of(Vec))?
                    memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                    result.payload.data = heap_vec_ptr
                    heap_type_ptr := malloc(size_of(ValueType))?
                    memcpy(heap_type_ptr, to_ptr(payload_type), size_of(ValueType))
                    result.payload_type.data = heap_type_ptr
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum_at_offset: buy more ram")
        }

        return result
    }

    get_payload_size_for_type : func(ctx: Context, vtype: ValueType, offset: I64, e: Expr) returns I64 throws Str = {
        switch vtype {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                return 8
            }
            mut type_symbol := ctx.scope_stack.lookup_symbol(type_name)?
            catch (err: KeyNotFoundError) {
                return 0
            }
            switch type_symbol.value_type {
            case ValueType.TType(type_def):
                switch type_def {
                case TTypeDef.TStructDef:
                    return ctx.get_type_size(type_name)?
                case TTypeDef.TEnumDef:
                    // Recursively get the inner enum's size
                    inner_enum := EvalHeap.get_enum_at_offset(ctx, type_name, offset, e)?
                    mut total_size := 8  // variant tag
                    if not(NULL.eq(inner_enum.payload.data)) {
                        mut payload_vec := Vec.new(U8)
                        memcpy(to_ptr(payload_vec), inner_enum.payload.data, size_of(Vec))
                        total_size = add(total_size, payload_vec.len())
                    }
                    return total_size
                case:
                    return 0
                }
            case:
                return 0
            }
        case:
            return 0
        }
        return 0
    }

    get_enum : func(ctx: Context, id: Str, e: Expr) returns EnumVal throws Str = {
        // For field paths (e.g., "s.color"), get the field's type, not the base struct's type
        mut enum_type := ""
        if id.contains(".") {
            field_type := ctx.get_field_type(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_enum: ", err))
            }
            switch field_type {
            case ValueType.TCustom(type_name):
                enum_type = type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: field '", id, "' is not a custom enum type"))
            }
        } else {
            mut symbol_info := ctx.scope_stack.lookup_symbol(id)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", format("get_enum: Symbol '", id, "' not found"))
            }

            switch symbol_info.value_type {
            case ValueType.TCustom(custom_type_name):
                enum_type = custom_type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: '", id, "' is not a custom enum type"))
            }
        }

        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants
        mut offset := 0
        if EvalHeap.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_enum: ", err))
            }
        } else {
            // Variable or type constant - ALWAYS direct lookup
            offset = ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", format("get_enum: EvalHeap index for '", id, "' not found"))
            }
        }

        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_heap.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload type
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut variant_payload_type := ValueType.TCustom("")
            memcpy(to_ptr(variant_payload_type), payload_ptr.data, size_of(ValueType))
            switch variant_payload_type {
            case ValueType.TCustom(vtype_name):
                // This variant has a payload, read it from heap
                mut payload_size := 0
                if vtype_name.eq("I64") {
                    payload_size = 8
                } else {
                    if vtype_name.eq("Str") {
                        payload_size = ctx.get_type_size("Str")?
                    } else {
                        // Check if this is a struct or enum type
                        mut type_symbol := ctx.scope_stack.lookup_symbol(vtype_name)?
                        catch (err: KeyNotFoundError) {
                            payload_size = 0
                        }
                        switch type_symbol.value_type {
                        case ValueType.TType(type_def):
                            switch type_def {
                            case TTypeDef.TStructDef:
                                payload_size = ctx.get_type_size(vtype_name)?
                                catch (err: Str) {
                                    payload_size = 0
                                }
                            case TTypeDef.TEnumDef:
                                // For enum payloads, recursively get the enum to determine size
                                inner_enum := EvalHeap.get_enum_at_offset(ctx, vtype_name, add(offset, 8), e)?
                                payload_size = 8  // variant tag
                                if not(NULL.eq(inner_enum.payload.data)) {
                                    mut inner_payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(inner_payload_vec), inner_enum.payload.data, size_of(Vec))
                                    payload_size = add(payload_size, inner_payload_vec.len())
                                }
                            case:
                                payload_size = 0
                            }
                        case:
                            payload_size = 0
                        }
                    }
                }

                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    mut payload_bytes := Vec.new(U8)
                    mut pi := 0
                    while pi.lt(payload_size) {
                        mut byte_val : U8 = 0
                        memcpy(to_ptr(byte_val), g_heap.get(add(payload_offset, pi), 1), 1)
                        payload_bytes.push(byte_val)
                        pi = add(pi, 1)
                    }
                    // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                    // (payload_bytes and variant_payload_type are stack-local, their pointers become stale)
                    heap_vec_ptr := malloc(size_of(Vec))?
                    memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                    result.payload.data = heap_vec_ptr
                    heap_type_ptr := malloc(size_of(ValueType))?
                    memcpy(heap_type_ptr, to_ptr(variant_payload_type), size_of(ValueType))
                    result.payload_type.data = heap_type_ptr
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum: buy more ram")
        }

        return result
    }

    // Core logic for insert_enum - returns EnumInsertResult with optional mapping info
    insert_enum_core : proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumInsertResult throws Str = {
        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Enum definition for '", enum_type, "' not found"))
        }

        // Get the last part after the last dot
        parts := pre_normalized_enum_name.split(".")?
        mut enum_name := ""
        if parts.len().gt(0) {
            enum_name_alias := cast(Str, parts.get(sub(parts.len(), 1))?)
            enum_name = enum_name_alias
        }
        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Invalid enum name format '", pre_normalized_enum_name, "'"))
        }

        enum_value := Context.get_variant_pos(enum_def, enum_name, ctx.path, e)?

        // Check if there's payload data to store (dereference Ptr to EnumPayload)
        mut payload_data := Vec.new(U8)
        mut payload_type := ValueType.TCustom("")
        if not(NULL.eq(ctx.temp_enum_payload.data)) {
            mut temp_payload := EnumPayload()
            memcpy(to_ptr(temp_payload), ctx.temp_enum_payload.data, size_of(EnumPayload))
            payload_data = temp_payload.data
            payload_type = temp_payload.value_type
        }

        // Bug #38 fix: Always allocate the maximum enum size to support memcpy of any variant
        max_enum_size := ctx.get_type_size(enum_type)?
        mut result := EnumInsertResult()
        result.has_mapping = false

        is_field := id.contains(".")
        if is_field {
            // Bug #160 fix: Try lookup_var first, then get_field_offset
            mut have_offset := true
            mut offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                // Field path not in heap_index - calculate from struct definition
                offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    have_offset = false
                }
            }

            if have_offset {
                // Update existing enum value (no new mapping needed)
                g_heap.set(offset, to_ptr(enum_value), 8)
                if payload_data.len().gt(0).and(add(payload_data.len(), 8).lteq(max_enum_size)) {
                    payload_offset := add(offset, 8)
                    mut pi := 0
                    while pi.lt(payload_data.len()) {
                        byte_val := cast(U8, payload_data.get(pi)?)
                        g_heap.set(add(payload_offset, pi), to_ptr(byte_val), 1)
                        pi = add(pi, 1)
                    }
                }
                result.has_mapping = false
            } else {
                // Allocate max enum size (zeroed), write tag and payload
                offset = g_heap.heap_alloc(max_enum_size)?
                g_heap.set(offset, to_ptr(enum_value), 8)
                if payload_data.len().gt(0).and(add(payload_data.len(), 8).lteq(max_enum_size)) {
                    g_heap.set(add(offset, 8), payload_data.ptr.data, payload_data.len())
                }
                // padding: heap_alloc returns zeroed memory
                result.has_mapping = true
                result.mapping_name = id
                result.mapping_offset = offset
            }
        } else {
            // Allocate max enum size (zeroed), write tag and payload
            new_enum_offset := g_heap.heap_alloc(max_enum_size)?
            g_heap.set(new_enum_offset, to_ptr(enum_value), 8)
            if payload_data.len().gt(0).and(add(payload_data.len(), 8).lteq(max_enum_size)) {
                g_heap.set(add(new_enum_offset, 8), payload_data.ptr.data, payload_data.len())
            }
            // padding: heap_alloc returns zeroed memory
            result.has_mapping = true
            result.mapping_name = id
            result.mapping_offset = new_enum_offset
        }

        // Clear the temp payload after using it (set to NULL Ptr)
        ctx.temp_enum_payload = Ptr()

        result.enum_val.enum_type = enum_type
        result.enum_val.enum_name = enum_name
        // Store payload as Ptr (Option pattern: NULL = None)
        // Note: Must store clone in variable - can't take address of function return value
        if payload_data.len().gt(0) {
            mut cloned_payload := payload_data.clone()
            result.enum_val.payload.data = to_ptr(cloned_payload)
            result.enum_val.payload_type.data = to_ptr(payload_type)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_core", "IndexOutOfBoundsError while processing payload")
        }

        return result
    }

    // TODO Context.insert_enum gets an Expr for errors, any Context method that can throw should too
    insert_enum : proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str = {
        result := EvalHeap.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?
        if result.has_mapping {
            ctx.scope_stack.insert_var(result.mapping_name, result.mapping_offset)?
        }

        return result.enum_val
    }

    insert_enum_into_frame : proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str = {
        // Temporarily push frame so symbol lookups work in core function
        ctx.scope_stack.frames.push(frame.clone())

        result := EvalHeap.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?

        // Pop frame back
        ctx.scope_stack.frames.pop(frame)?

        // Now apply result to the frame
        if result.has_mapping {
            frame.heap_index.set(result.mapping_name, result.mapping_offset)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_into_frame", "IndexOutOfBoundsError")
        }

        return result.enum_val
    }

    /** Insert an Array for variadic arguments into a function frame.
     *  Uses insert_struct_into_frame internally. */
    insert_array_into_frame : proc(mut ctx: Context, mut frame: ScopeFrame, name: Str, elem_type: Str, values: Vec, e: Expr) throws Str = {
        // Create Array struct using template
        template_offset := cast(I64, g_heap.default_instances.get("Array")?)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "Array template not found - ensure array.til is imported")
        }
        EvalHeap.insert_struct_into_frame(ctx, frame, name, "Array", template_offset, e)?

        len := values.len()
        elem_size := ctx.get_type_size(elem_type)?
        total_size := mul(len, elem_size)

        // Allocate memory for elements
        ptr := g_heap.heap_alloc(total_size)?

        // Write values into allocated buffer
        mut i := 0
        while i.lt(len) {
            offset := add(ptr, mul(i, elem_size))
            val := cast(Str, values.get(i)?)

            if Str.eq(elem_type, "U8") {
                byte := U8.from_str(val)?
                g_heap.set(offset, to_ptr(byte), 1)
            } else if Str.eq(elem_type, "I64") {
                n := I64.from_str(val)
                g_heap.set(offset, to_ptr(n), 8)
            } else if Str.eq(elem_type, "Str") {
                // For Str elements, create temp Str and copy bytes to array slot
                temp_id := format(name, "_", I64.to_str(i))
                temp_symbol := SymbolInfo(value_type=ValueType.TCustom("Str"), is_mut=false, is_copy=false, is_own=false)
                frame.symbols.set(temp_id.clone(), temp_symbol)

                EvalHeap.insert_string_into_frame(ctx, frame, temp_id, val, e)?

                str_offset := cast(I64, frame.heap_index.get(temp_id)?)
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("missing Str offset for '", temp_id, "'"))
                }
                g_heap.set(offset, g_heap.get(str_offset, elem_size), elem_size)
            } else {
                // Struct element - val is identifier, copy from source
                mut src_offset := 0
                src_offset = ctx.scope_stack.lookup_var(val)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("struct source '", val, "' not found"))
                }
                g_heap.set(offset, g_heap.get(src_offset, elem_size), elem_size)
            }

            i = add(i, 1)
        }

        // Bug #160: Calculate field offsets from base offset in frame
        base_offset := cast(I64, frame.heap_index.get(name)?)
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing base offset for '", name, "'"))
        }
        mut array_def := ctx.scope_stack.lookup_struct("Array")?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", "Array struct definition not found")
        }

        // Calculate relative offsets for each field
        mut ptr_rel_offset := 0
        mut len_rel_offset := 0
        mut current_field_offset := 0
        for decl: Declaration in array_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(t):
                    field_size = ctx.get_type_size(t)?
                case:
                    throw e.lang_error(ctx.path, "insert_array", "unsupported field type")
                }
                if Str.eq(decl.name, "ptr") {
                    ptr_rel_offset = current_field_offset
                } else if Str.eq(decl.name, "_len") {
                    len_rel_offset = current_field_offset
                }
                current_field_offset = add(current_field_offset, field_size)
            }
        }

        // Update Array fields using calculated offsets
        // ptr is a Ptr struct (40 bytes): data, is_borrowed, alloc_size, elem_type, elem_size
        ptr_offset := add(base_offset, ptr_rel_offset)
        mut ptr_val := ptr
        g_heap.set(ptr_offset, to_ptr(ptr_val), 8)                           // data
        mut is_borrowed_val := 0
        g_heap.set(add(ptr_offset, 8), to_ptr(is_borrowed_val), 8)           // is_borrowed = 0
        mut alloc_size_val := total_size
        g_heap.set(add(ptr_offset, 16), to_ptr(alloc_size_val), 8)           // alloc_size
        mut elem_type_val := 0
        g_heap.set(add(ptr_offset, 24), to_ptr(elem_type_val), 8)            // elem_type = NULL
        mut elem_size_val := elem_size
        g_heap.set(add(ptr_offset, 32), to_ptr(elem_size_val), 8)            // elem_size

        len_offset := add(base_offset, len_rel_offset)
        mut len_val := len
        g_heap.set(len_offset, to_ptr(len_val), 8)

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", err.msg)
        }
    }

    /// Convert a struct instance stored in EvalHeap to a struct literal Expr.
    /// Given instance "___temp_return_val_0" of type "Bool", produces:
    ///   Bool(data=1)
    /// The `e` parameter is only used for error reporting.
    to_struct_literal : func(ctx: Context, instance_name: Str, type_name: Str, e: Expr) returns Expr throws Str = {
        mut struct_def := ctx.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "heap", format("to_struct_literal: struct '", type_name, "' not found"))
        }

        // First param is the type identifier
        type_id := Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), 0, 0)
        mut params := Vec.new(Expr)
        params.push(type_id)

        // For each mutable field, read value and create NamedArg
        for member: Declaration in struct_def.members {
            if not(member.is_mut) {
                continue  // Skip static fields
            }
            field_id := format(instance_name, ".", member.name)
            field_value := EvalHeap.field_to_literal(ctx, field_id, member.value_type, e)?

            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(field_value)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, 0, 0)
            params.push(named_arg)
        }

        result := Expr.new_explicit(NodeType.FCall(false), params, 0, 0)


        return result
    }

    /// Helper: read a field value from EvalHeap and convert to literal Expr
    field_to_literal : func(ctx: Context, field_id: Str, value_type: ValueType, e: Expr) returns Expr throws Str = {
        mut result := Expr()
        switch value_type {
        case ValueType.TCustom(custom_type):
            if custom_type.eq("I64") {
                i64_val := EvalHeap.get_i64(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(i64_val.to_str())), Vec.new(Expr), 0, 0)
            } else if custom_type.eq("U8") {
                u8_val := EvalHeap.get_u8(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(u8_val.to_str())), Vec.new(Expr), 0, 0)
            } else if custom_type.eq("Str") {
                // Str needs special handling - reading raw Ptr fields would serialize
                // interpreter memory addresses as literal numbers (non-deterministic).
                // Instead, extract the actual string content.
                mut offset := 0
                if EvalHeap.is_instance_field(ctx, field_id) {
                    offset = ctx.get_field_offset(field_id)?
                } else {
                    offset = ctx.scope_stack.lookup_var(field_id)?
                    catch (err: KeyNotFoundError) {
                        throw e.lang_error(ctx.path, "heap", format("field_to_literal Str: '", field_id, "' not found"))
                    }
                }
                str_val := EvalHeap.extract_str_at_offset(ctx, offset)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Str(str_val)), Vec.new(Expr), 0, 0)
            } else {
                // Check if nested struct
                mut is_struct := false
                _struct_def := ctx.scope_stack.lookup_struct(custom_type)?
                is_struct = true
                catch (err: KeyNotFoundError) {
                    // Not a struct
                }
                if is_struct {
                    result = EvalHeap.to_struct_literal(ctx, field_id, custom_type, e)?
                } else {
                    throw e.lang_error(ctx.path, "heap", format("field_to_literal: unsupported nested type '", custom_type, "'"))
                }
            }
        case:
            throw e.lang_error(ctx.path, "heap", format("field_to_literal: unsupported field type '", value_type_to_str(value_type), "'"))
        }

        return result
    }

    /// Extract the contents of a Vec instance from heap memory.
    /// Returns the element type name, size, and raw bytes for each element.
    extract_vec_contents : func(ctx: Context, instance_name: Str) returns VecContents throws Str = {
        // Get Vec base offset
        mut vec_offset := 0
        vec_offset = ctx.scope_stack.lookup_var(instance_name)?
        catch (err: KeyNotFoundError) {
            throw format("extract_vec_contents: instance '", instance_name, "' not found")
        }

        // Vec layout: ptr (Ptr), _len (I64), cap (I64)
        ptr_size := ctx.get_type_size("Ptr")?

        // Read ptr.data (I64) - first field
        ptr_offset := vec_offset
        ptr_data_ptr := g_heap.get(ptr_offset, 8)
        mut data_ptr := 0
        Ptr(data=ptr_data_ptr).dereference(I64, data_ptr)

        // Read elem_type from Ptr (4th field at offset 24) -- C string pointer
        elem_type_data := g_heap.get(ptr_offset.add(24), 8)
        mut elem_type_ptr := 0
        Ptr(data=elem_type_data).dereference(I64, elem_type_ptr)
        type_name_str := EvalHeap.read_c_string(elem_type_ptr)

        // Read elem_size from Ptr (5th field at offset 32 within Ptr)
        elem_size_ptr := g_heap.get(ptr_offset.add(32), 8)
        mut type_size := 0
        Ptr(data=elem_size_ptr).dereference(I64, type_size)

        // Read _len (I64) - after ptr
        len_offset := ptr_offset.add(ptr_size)
        len_ptr := g_heap.get(len_offset, 8)
        mut len := 0
        Ptr(data=len_ptr).dereference(I64, len)

        // Extract element bytes
        mut element_bytes := Vec.new(Vec)
        for i in 0..len {
            elem_offset := data_ptr.add(i.mul(type_size))
            // Read bytes from heap
            mut bytes := Vec.new(U8)
            for j in 0..type_size {
                byte_ptr := g_heap.get(elem_offset.add(j), 1)
                mut byte_val : U8 = 0
                Ptr(data=byte_ptr).dereference(U8, byte_val)
                bytes.push(byte_val)
            }
            element_bytes.push(bytes)
        }

        return VecContents(element_type_name=type_name_str, type_size=type_size, element_bytes=element_bytes)
    }

    /// Extract string data from a Str at a given offset.
    /// Used by extract_vec_contents for type_name and for Vec<Str> elements.
    extract_str_at_offset : func(ctx: Context, str_offset: I64) returns Str throws Str = {
        // Str layout: c_string (Ptr), _len (I64), cap (I64)
        ptr_size := ctx.get_type_size("Ptr")?

        // Read c_string.data (first field of Ptr)
        c_string_ptr_ptr := g_heap.get(str_offset, 8)
        mut c_string_ptr := 0
        Ptr(data=c_string_ptr_ptr).dereference(I64, c_string_ptr)

        // Read _len (I64) - after c_string Ptr
        len_offset := str_offset.add(ptr_size)
        len_ptr := g_heap.get(len_offset, 8)
        mut len := 0
        Ptr(data=len_ptr).dereference(I64, len)

        // Read the actual string bytes
        if c_string_ptr.eq(0).or(len.eq(0)) {
            return ""
        }
        // Create string from bytes
        mut result := ""
        for i in 0..len {
            byte_ptr := g_heap.get(c_string_ptr.add(i), 1)
            mut byte_val : U8 = 0
            Ptr(data=byte_ptr).dereference(U8, byte_val)
            result = concat(result, Str.from_byte(byte_val))
        }
        return result
    }

    /// Extract string data from Str raw bytes (Vec<U8>).
    /// Used for nested types where we have the Str struct bytes directly.
    extract_str_from_bytes : func(ctx: Context, str_bytes: Vec) returns Str throws Str = {
        ptr_size := ctx.get_type_size("Ptr")?

        // Read c_string.data (first 8 bytes) - little endian
        mut c_string_ptr := 0
        mut multiplier := 1
        for i in 0..8 {
            if i.lt(str_bytes.len()) {
                b := cast(U8, str_bytes.get(i)?)
                c_string_ptr = c_string_ptr.add(b.to_i64().mul(multiplier))
                multiplier = multiplier.mul(256)
            }
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "str_bytes.get: bounds-checked by i < len: ", err.msg)
            }
        }

        // Read _len (I64) - after c_string Ptr
        mut len := 0
        mut multiplier2 := 1
        for i2 in 0..8 {
            idx := ptr_size.add(i2)
            if idx.lt(str_bytes.len()) {
                b2 := cast(U8, str_bytes.get(idx)?)
                len = len.add(b2.to_i64().mul(multiplier2))
                multiplier2 = multiplier2.mul(256)
            }
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "str_bytes.get: bounds-checked by idx < len: ", err.msg)
            }
        }

        // Read the actual string bytes from heap
        if c_string_ptr.eq(0).or(len.eq(0)) {
            return ""
        }
        mut result := ""
        for i3 in 0..len {
            byte_ptr := g_heap.get(c_string_ptr.add(i3), 1)
            mut byte_val : U8 = 0
            Ptr(data=byte_ptr).dereference(U8, byte_val)
            result = concat(result, Str.from_byte(byte_val))
        }
        return result
    }

    /// Read a null-terminated C string from a heap address.
    /// Used for reading elem_type (Ptr field) which stores a C string pointer.
    read_c_string : func(addr: I64) returns Str = {
        if addr.eq(0) {
            return ""
        }
        mut result := ""
        mut offset := addr
        while true {
            byte_ptr := g_heap.get(offset, 1)
            mut byte_val : U8 = 0
            Ptr(data=byte_ptr).dereference(U8, byte_val)
            if byte_val.to_i64().eq(0) {
                return result
            }
            result = concat(result, Str.from_byte(byte_val))
            offset = offset.add(1)
        }
        return result
    }

    /// Check if a type requires heap serialization (contains Ptr fields that point to heap data)
    type_needs_heap_serialization : func(ctx: Context, type_name: Str) returns Bool = {
        if type_name.eq("Vec").or(type_name.eq("List")) {
            return true
        }
        // Str doesn't need it because string literals are already static in C
        // (the c_string pointer points to string literal data)

        // Check if this is a struct with Vec/List fields
        mut struct_def := StructDef()
        struct_def = ctx.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        for member: Declaration in struct_def.members {
            if member.is_mut {
                switch member.value_type {
                case ValueType.TCustom(field_type):
                    if EvalHeap.type_needs_heap_serialization(ctx, field_type) {
                        return true
                    }
                case:
                }
            }
        }
        return false
    }
}

// Global heap instance
mut g_heap := EvalHeap.new()
