mode lib

import("self.parser")

// Preinit phase: Auto-generates delete() and clone() methods for structs/enums.
// Issue #108: Methods are generated into namespace blocks, not into struct definitions.
// This keeps structs clean (only storage fields) while still providing auto-generated methods.

/// Result of generating a method - contains the declaration and expression.
MethodResult := struct {
    mut decl: Declaration = Declaration()
    mut expr: Expr = Expr()
}

/// Check if a value type has no fields (no delete/clone needed).
/// - I64, U8: true built-in primitives
/// - Dynamic, Type: empty structs with no fields
is_primitive_type : func(vt: ValueType) returns Bool = {
    switch vt {
    case ValueType.TCustom(name):
        if name.eq("I64") { return true }
        if name.eq("U8") { return true }
        if name.eq("Dynamic") { return true }
        if name.eq("Type") { return true }
        return false
    case:
        return false
    }
}

/// Generate a delete() method for a struct.
/// The method calls field.delete() for each mutable field in reverse declaration order.
generate_delete_method : func(struct_name: Str, struct_def: StructDef, line: I64, col: I64) returns MethodResult = {
    // Build: delete : proc(mut self: StructName) = { self.field_n.delete(); ... self.field_0.delete(); }

    // Check if there will be any delete calls (determines if we use _self or self)
    mut has_non_primitive_fields := false
    for mf: Declaration in struct_def.members {
        if mf.is_mut {
            if not(is_primitive_type(mf.value_type)) {
                has_non_primitive_fields = true
            }
        }
    }

    mut self_param_name := "_self"
    if has_non_primitive_fields {
        self_param_name = "self"
    }

    self_decl := Declaration(
        name=self_param_name,
        value_type=ValueType.TCustom(struct_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut body_stmts := Vec.new(Expr)

    // Process fields in reverse order (like C++/Rust destructors)
    mut member_i := struct_def.members.len().sub(1)
    while member_i.gteq(0) {
        member := cast(Declaration, struct_def.members.get(member_i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "members.get: bounds-checked loop: ", err.msg)
        }

        // Skip non-mut fields and primitive types
        if member.is_mut {
            if not(is_primitive_type(member.value_type)) {
                // Build: self.field_name.delete()
                mut delete_access_params := Vec.new(Expr)
                delete_access_params.push(own Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                delete_access_params.push(own Expr.new_explicit(NodeType.Identifier("delete"), Vec.new(Expr), line, col))
                delete_access := Expr.new_explicit(NodeType.Identifier("self"), delete_access_params, line, col)

                mut delete_call_params := Vec.new(Expr)
                delete_call_params.push(own delete_access)
                delete_call := Expr.new_explicit(NodeType.FCall(FCallInfo()), delete_call_params, line, col)

                body_stmts.push(own delete_call)
            }
        }

        member_i.dec()
    }

    mut args := Vec.new(Declaration)
    args.push(own self_decl)
    mut arg_names := Vec.new(Str)
    arg_names.push(own self_param_name)
    func_def := FuncDef(
        sig=FuncSig(
            function_type=FunctionType.FTFunc,
            args=args,
            return_types=Vec.new(ValueType),
            throw_types=Vec.new(ValueType)
        ),
        arg_names=arg_names,
        body=body_stmts,
        source_path=""
    )

    method_decl := Declaration(
        name="delete",
        value_type=ValueType.TFunction(FunctionType.FTFunc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a clone() method for a struct.
/// The method returns a new instance with each mutable field cloned.
generate_clone_method : func(struct_name: Str, struct_def: StructDef, line: I64, col: I64) returns MethodResult = {
    // Build: clone : func(self: StructName) returns StructName = { return StructName(field1 = self.field1.clone(), ...) }

    // Use _self when no mut fields (body won't reference self)
    mut has_mut_fields := false
    for mf2: Declaration in struct_def.members {
        if mf2.is_mut {
            has_mut_fields = true
        }
    }

    mut self_param_name := "_self"
    if has_mut_fields {
        self_param_name = "self"
    }

    self_decl := Declaration(
        name=self_param_name,
        value_type=ValueType.TCustom(struct_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut named_args := Vec.new(Expr)

    for member: Declaration in struct_def.members {
        if member.is_mut {
            // For primitive types, just copy the value directly: self.field_name
            // For other types, call clone: self.field_name.clone()
            mut field_value := Expr()
            if is_primitive_type(member.value_type) {
                // Build: self.field_name
                mut access_params := Vec.new(Expr)
                access_params.push(own Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                field_value = Expr.new_explicit(NodeType.Identifier("self"), access_params, line, col)
            } else {
                // Build: self.field_name.clone()
                mut clone_access_params := Vec.new(Expr)
                clone_access_params.push(own Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                clone_access_params.push(own Expr.new_explicit(NodeType.Identifier("clone"), Vec.new(Expr), line, col))
                clone_access := Expr.new_explicit(NodeType.Identifier("self"), clone_access_params, line, col)

                mut clone_call_params := Vec.new(Expr)
                clone_call_params.push(own clone_access)
                field_value = Expr.new_explicit(NodeType.FCall(FCallInfo()), clone_call_params, line, col)
            }

            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(own field_value)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, line, col)
            named_args.push(own named_arg)
        }
    }

    struct_name_id := Expr.new_explicit(NodeType.Identifier(struct_name), Vec.new(Expr), line, col)

    mut struct_literal_params := Vec.new(Expr)
    struct_literal_params.push(own struct_name_id)
    for na: Expr in named_args {
        struct_literal_params.push(own na)
    }

    struct_literal := Expr.new_explicit(NodeType.FCall(FCallInfo()), struct_literal_params, line, col)

    mut return_params := Vec.new(Expr)
    return_params.push(own struct_literal)
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    mut args := Vec.new(Declaration)
    args.push(own self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(own ValueType.TCustom(struct_name))
    mut body := Vec.new(Expr)
    body.push(own return_stmt)
    mut arg_names := Vec.new(Str)
    arg_names.push(own self_param_name)
    func_def := FuncDef(
        sig=FuncSig(
            function_type=FunctionType.FTFunc,
            args=args,
            return_types=return_types,
            throw_types=Vec.new(ValueType)
        ),
        arg_names=arg_names,
        body=body,
        source_path=""
    )

    method_decl := Declaration(
        name="clone",
        value_type=ValueType.TFunction(FunctionType.FTFunc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a delete() method for an enum - no-op since enums are value types.
generate_enum_delete_method : func(enum_name: Str, line: I64, col: I64) returns Expr = {
    self_decl := Declaration(
        name="_self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut args := Vec.new(Declaration)
    args.push(own self_decl)
    mut arg_names := Vec.new(Str)
    arg_names.push(own "_self")
    func_def := FuncDef(
        sig=FuncSig(
            function_type=FunctionType.FTFunc,
            args=args,
            return_types=Vec.new(ValueType),
            throw_types=Vec.new(ValueType)
        ),
        arg_names=arg_names,
        body=Vec.new(Expr),
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Generate a clone() method for an enum - returns self since enums are value types.
generate_enum_clone_method : func(enum_name: Str, line: I64, col: I64) returns Expr = {
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut return_params := Vec.new(Expr)
    return_params.push(own Expr.new_explicit(NodeType.Identifier("self"), Vec.new(Expr), line, col))
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    mut args := Vec.new(Declaration)
    args.push(own self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(own ValueType.TCustom(enum_name))
    mut body := Vec.new(Expr)
    body.push(own return_stmt)
    mut arg_names := Vec.new(Str)
    arg_names.push(own "self")
    func_def := FuncDef(
        sig=FuncSig(
            function_type=FunctionType.FTFunc,
            args=args,
            return_types=return_types,
            throw_types=Vec.new(ValueType)
        ),
        arg_names=arg_names,
        body=body,
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Issue #106: Generate delete/clone methods for a macro-expanded enum.
/// Returns NamespaceDef with auto-generated methods, or empty NamespaceDef if none needed.
generate_enum_methods : func(enum_name: Str, ns_has_delete: Bool, ns_has_clone: Bool, line: I64, col: I64) returns NamespaceDef = {
    needs_delete := not(ns_has_delete)
    needs_clone := not(ns_has_clone)

    if needs_delete.or(needs_clone) {
        mut members := Vec.new(Declaration)
        mut default_values := Map.new(Str, Expr)

        if needs_delete {
            delete_decl := Declaration(
                name="delete",
                value_type=ValueType.TFunction(FunctionType.FTFunc),
                is_mut=false,
                is_copy=false,
                is_own=false,
                default_value=Ptr()
            )
            delete_expr := generate_enum_delete_method(enum_name, line, col)
            members.push(own delete_decl)
            default_values.set(own "delete", own delete_expr)
        }

        if needs_clone {
            clone_decl := Declaration(
                name="clone",
                value_type=ValueType.TFunction(FunctionType.FTFunc),
                is_mut=false,
                is_copy=false,
                is_own=false,
                default_value=Ptr()
            )
            clone_expr := generate_enum_clone_method(enum_name, line, col)
            members.push(own clone_decl)
            default_values.set(own "clone", own clone_expr)
        }

        return NamespaceDef(
            members=members,
            default_values=default_values
        )
    }
    return NamespaceDef()
}

/// Collect all methods defined in namespace blocks.
/// Returns a Set of "TypeName.methodName" strings.
collect_namespace_methods : func(ast: Expr) returns Set = {
    mut methods := Set.new(Str)

    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.Declaration(decl):
                if child.params.len().gt(0) {
                    value_expr := cast(Expr, child.params.get(0)?)
                    dont_delete(value_expr)
                    switch value_expr.node_type {
                    case NodeType.StructDef(struct_def):
                        for member: Declaration in struct_def.ns.members {
                            _ := methods.insert(own format(decl.name, ".", member.name))
                        }
                    case NodeType.EnumDef(enum_def):
                        for member: Declaration in enum_def.ns.members {
                            _ := methods.insert(own format(decl.name, ".", member.name))
                        }
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    return methods
}

/// Info about a struct that needs auto-generated methods.
StructNeedingMethods := struct {
    mut struct_name: Str = ""
    mut struct_def: StructDef = StructDef()
    mut line: I64 = 0
    mut col: I64 = 0
    mut needs_delete: Bool = false
    mut needs_clone: Bool = false
}

/// Collect all structs that need auto-generated methods.
collect_structs_needing_methods : func(ast: Expr, namespace_methods: Set) returns Vec = {
    mut structs := Vec.new(StructNeedingMethods)

    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.Declaration(decl):
                if child.params.len().gt(0) {
                    value_expr := cast(Expr, child.params.get(0)?)
                    dont_delete(value_expr)

                    switch value_expr.node_type {
                    case NodeType.StructDef(struct_def):
                        // Check if delete/clone are already defined (in struct, ns, or namespace_methods)
                        mut has_delete_inline := false
                        for dm: Declaration in struct_def.members {
                            if dm.name.eq("delete") {
                                has_delete_inline = true
                            }
                        }
                        if struct_def.default_values.contains_key("delete") {
                            has_delete_inline = true
                        }
                        // Also check ns members
                        for ns_m: Declaration in struct_def.ns.members {
                            if ns_m.name.eq("delete") {
                                has_delete_inline = true
                            }
                        }
                        mut delete_key := format(decl.name, ".delete")
                        has_delete_namespace := namespace_methods.contains(delete_key)
                        delete_key.delete()
                        has_delete := has_delete_inline.or(has_delete_namespace)

                        mut has_clone_inline := false
                        for clm: Declaration in struct_def.members {
                            if clm.name.eq("clone") {
                                has_clone_inline = true
                            }
                        }
                        if struct_def.default_values.contains_key("clone") {
                            has_clone_inline = true
                        }
                        // Also check ns members
                        for ns_m2: Declaration in struct_def.ns.members {
                            if ns_m2.name.eq("clone") {
                                has_clone_inline = true
                            }
                        }
                        mut clone_key := format(decl.name, ".clone")
                        has_clone_namespace := namespace_methods.contains(clone_key)
                        clone_key.delete()
                        has_clone := has_clone_inline.or(has_clone_namespace)

                        needs_delete := not(has_delete)
                        needs_clone := not(has_clone)

                        if needs_delete.or(needs_clone) {
                            mut info := StructNeedingMethods()
                            info.struct_name = decl.name.clone()
                            info.struct_def = struct_def.clone()
                            info.line = child.line
                            info.col = child.col
                            info.needs_delete = needs_delete
                            info.needs_clone = needs_clone
                            structs.push(own info)
                        }
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    return structs
}

/// Issue #105: Public API for generating delete/clone methods for a macro-expanded struct.
/// Returns NamespaceDef with auto-generated methods, or empty NamespaceDef if none needed.
generate_struct_methods : func(struct_name: Str, struct_def: StructDef, _line: I64, _col: I64) returns NamespaceDef = {
    // Check if delete/clone are already defined (inline or in ns)
    mut has_delete := false
    mut has_clone := false
    for member: Declaration in struct_def.members {
        if member.name.eq("delete") {
            has_delete = true
        }
        if member.name.eq("clone") {
            has_clone = true
        }
    }
    if struct_def.default_values.contains_key("delete") {
        has_delete = true
    }
    if struct_def.default_values.contains_key("clone") {
        has_clone = true
    }
    for ns_m: Declaration in struct_def.ns.members {
        if ns_m.name.eq("delete") {
            has_delete = true
        }
        if ns_m.name.eq("clone") {
            has_clone = true
        }
    }

    needs_delete := not(has_delete)
    needs_clone := not(has_clone)

    if needs_delete.or(needs_clone) {
        return generate_namespace_block(struct_name, struct_def, needs_delete, needs_clone)
    }
    return NamespaceDef()
}

/// Generate a NamespaceDef with auto-generated methods for a struct.
generate_namespace_block : func(struct_name: Str, struct_def: StructDef, needs_delete: Bool, needs_clone: Bool) returns NamespaceDef = {
    mut members := Vec.new(Declaration)
    mut default_values := Map.new(Str, Expr)

    if needs_delete {
        delete_result := generate_delete_method(struct_name, struct_def, 0, 0)
        members.push(own delete_result.decl)
        default_values.set(own "delete", own delete_result.expr)
    }

    if needs_clone {
        clone_result := generate_clone_method(struct_name, struct_def, 0, 0)
        members.push(own clone_result.decl)
        default_values.set(own "clone", own clone_result.expr)
    }

    return NamespaceDef(
        members=members,
        default_values=default_values
    )
}

/// Recursively process expression (for nested function bodies, etc.)
preinit_expr_inner : func(e: Expr) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.FuncDef(func_def):
        mut new_body := Vec.new(Expr)
        for stmt: Expr in func_def.body {
            new_body.push(own preinit_expr_inner(stmt)?)
        }
        new_func_def := FuncDef(
            sig=FuncSig(
                function_type=func_def.sig.function_type,
                args=func_def.sig.args,
                return_types=func_def.sig.return_types,
                throw_types=func_def.sig.throw_types
            ),
            arg_names=func_def.arg_names,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)

    case NodeType.StructDef(struct_def):
        // Recurse into default values but DON'T add delete/clone here
        mut new_default_values := Map.new(Str, Expr)
        for sd_name: Str in struct_def.default_values.keys {
            sd_value_expr := cast(Expr, struct_def.default_values.get(sd_name)?)
            new_default_values.set(own sd_name.clone(), own preinit_expr_inner(sd_value_expr)?)
        }
        catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
        // Process ns default_values
        mut ns_new_default_values := Map.new(Str, Expr)
        for ns_k: Str in struct_def.ns.default_values.keys {
            ns_v := cast(Expr, struct_def.ns.default_values.get(ns_k)?)
            ns_new_default_values.set(own ns_k.clone(), own preinit_expr_inner(ns_v)?)
        }
        catch (err2: KeyNotFoundError) { panic(loc(), err2.msg) }
        new_ns := NamespaceDef(
            members=struct_def.ns.members,
            default_values=ns_new_default_values
        )
        new_struct_def := StructDef(
            members=struct_def.members,
            default_values=new_default_values,
            ns=new_ns
        )
        return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params)

    case NodeType.Declaration(decl):
        // For enum definitions, still add delete/clone directly (enums don't use namespace blocks yet)
        if e.params.len().gt(0) {
            value_expr := cast(Expr, e.params.get(0)?)
            dont_delete(value_expr)

            switch value_expr.node_type {
            case NodeType.EnumDef(enum_def):
                has_delete := enum_def.methods.contains_key("delete")
                has_clone := enum_def.methods.contains_key("clone")

                if not(has_delete).or(not(has_clone)) {
                    mut new_methods := enum_def.methods.clone()

                    if not(has_delete) {
                        new_methods.set(own "delete", own generate_enum_delete_method(decl.name, e.line, e.col))
                    }

                    if not(has_clone) {
                        new_methods.set(own "clone", own generate_enum_clone_method(decl.name, e.line, e.col))
                    }

                    mut new_enum_def := EnumDef()
                    new_enum_def.variants = enum_def.variants.clone()
                    new_enum_def.methods = new_methods
                    new_enum_def.ns = enum_def.ns.clone()

                    new_enum_expr := Expr.new_clone(
                        NodeType.EnumDef(new_enum_def),
                        value_expr,
                        value_expr.params
                    )

                    mut enum_new_params := Vec.new(Expr)
                    enum_new_params.push(own new_enum_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, enum_new_params)
                }
            case:
            }
        }

        // Default: recurse into params
        mut decl_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            decl_new_params.push(own preinit_expr_inner(p)?)
        }
        return Expr.new_clone(e.node_type, e, decl_new_params)

    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut default_new_params := Vec.new(Expr)
            for op: Expr in e.params {
                default_new_params.push(own preinit_expr_inner(op)?)
            }
            return Expr.new_clone(e.node_type, e, default_new_params)
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

/// Preinit phase entry point.
/// For structs: generates namespace blocks with delete/clone methods.
/// For enums: adds delete/clone directly to the enum definition.
preinit_expr : func(e: Expr) returns Expr throws Str = {
    // For Body nodes (the AST root), do the two-pass approach
    switch e.node_type {
    case NodeType.Body:
        // Pass 1: Collect namespace-defined methods
        namespace_methods := collect_namespace_methods(e)

        // Pass 2: Find structs that need auto-generated methods
        structs_needing := collect_structs_needing_methods(e, namespace_methods)

        // Pass 3: Process all children, setting ns on struct defs that need auto-generated methods
        mut new_params := Vec.new(Expr)
        for child: Expr in e.params {
            mut processed := preinit_expr_inner(child)?

            // If this is a Declaration of a StructDef that needs methods, set the ns field
            switch processed.node_type {
            case NodeType.Declaration(p_decl):
                if processed.params.len().gt(0) {
                    p_value_expr := cast(Expr, processed.params.get(0)?)
                    dont_delete(p_value_expr)
                    switch p_value_expr.node_type {
                    case NodeType.StructDef(p_struct_def):
                        // Check if this struct needs methods
                        mut found_in_needing := false
                        mut sn_needs_delete := false
                        mut sn_needs_clone := false
                        for sn_info: StructNeedingMethods in structs_needing {
                            if sn_info.struct_name.eq(p_decl.name) {
                                found_in_needing = true
                                sn_needs_delete = sn_info.needs_delete
                                sn_needs_clone = sn_info.needs_clone
                            }
                        }
                        if found_in_needing {
                            auto_ns := generate_namespace_block(p_decl.name, p_struct_def, sn_needs_delete, sn_needs_clone)
                            // Merge auto-generated ns with any user-defined ns
                            mut merged_ns := p_struct_def.ns.clone()
                            for auto_m: Declaration in auto_ns.members {
                                mut already_exists := false
                                for existing_m: Declaration in merged_ns.members {
                                    if existing_m.name.eq(auto_m.name) {
                                        already_exists = true
                                    }
                                }
                                if not(already_exists) {
                                    merged_ns.members.push(own auto_m.clone())
                                }
                            }
                            for auto_k: Str in auto_ns.default_values.keys {
                                if not(merged_ns.default_values.contains_key(auto_k)) {
                                    auto_v := cast(Expr, auto_ns.default_values.get(auto_k)?)
                                    merged_ns.default_values.set(own auto_k.clone(), own auto_v.clone())
                                }
                            }
                            catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
                            new_struct_def := StructDef(
                                members=p_struct_def.members.clone(),
                                default_values=p_struct_def.default_values.clone(),
                                ns=merged_ns
                            )
                            new_value_expr := Expr.new_clone(NodeType.StructDef(new_struct_def), p_value_expr, p_value_expr.params.clone())
                            mut new_decl_params := Vec.new(Expr)
                            new_decl_params.push(own new_value_expr)
                            processed = Expr.new_clone(processed.node_type.clone(), processed, new_decl_params)
                        }
                    case:
                    }
                }
            case:
            }

            new_params.push(own processed)
        }

        catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

        return Expr.new_clone(e.node_type, e, new_params)
    case:
        // For non-Body nodes, just recurse
        return preinit_expr_inner(e)?
    }
}
