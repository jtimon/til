mode liba

import("self.parser")

// Preinit phase: Auto-generates delete() and clone() methods for structs and enums.
// This phase runs before init so the generated methods are visible during type checking.
// Future consolidation: May be merged into init phase.

/// Result of generating a method - contains the declaration and expression.
MethodResult := struct {
    mut decl: Declaration = Declaration()
    mut expr: Expr = Expr()
}

/// Generate a delete() method for a struct that doesn't have one.
/// The method calls field.delete() for each mutable field in reverse declaration order.
generate_delete_method := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns MethodResult {
    // Build: delete := proc(mut self: StructName) { self.field_n.delete(); ... self.field_0.delete(); }

    // Create the self parameter: mut self: StructName
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(struct_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    // Build the body: call delete() on each field in reverse order
    mut body_stmts := Vec.new(Expr)

    // Process fields in reverse order (like C++/Rust destructors)
    mut member_i := struct_def.members.len().sub(1)
    while member_i.gteq(0) {
        mut member := Declaration()
        struct_def.members.get(member_i, member)?
        catch (err: IndexOutOfBoundsError) {
            // Shouldn't happen
        }

        // Skip non-mut fields (constants/methods don't need delete)
        if member.is_mut {
            // Build: self.field_name.delete()
            // self.field_name.delete is: Identifier("self") [ Identifier("field_name"), Identifier("delete") ]
            mut delete_access_params := Vec.new(Expr)
            delete_access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
            delete_access_params.push(Expr.new_explicit(NodeType.Identifier("delete"), Vec.new(Expr), line, col))
            delete_access := Expr.new_explicit(NodeType.Identifier("self"), delete_access_params, line, col)

            // FCall for self.field_name.delete()
            mut delete_call_params := Vec.new(Expr)
            delete_call_params.push(delete_access)
            delete_call := Expr.new_explicit(NodeType.FCall(false), delete_call_params, line, col)

            body_stmts.push(delete_call)
        }

        member_i.dec()
    }

    // Create the FuncDef
    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=body_stmts,
        source_path=""
    )

    // Create the declaration for the method
    method_decl := Declaration(
        name="delete",
        value_type=ValueType.TFunction(FunctionType.FTProc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)

    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a clone() method for a struct that doesn't have one.
/// The method returns a new instance with each mutable field cloned.
generate_clone_method := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns MethodResult {
    // Build: clone := func(self: StructName) returns StructName { return StructName(field1 = self.field1.clone(), ...) }

    // Create the self parameter: self: StructName (not mut - we're reading from it)
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(struct_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    // Build named arguments for the struct literal: field1 = self.field1.clone(), field2 = self.field2.clone(), ...
    mut named_args := Vec.new(Expr)

    for member_i in 0..struct_def.members.len() {
        mut member := Declaration()
        struct_def.members.get(member_i, member)?
        catch (err: IndexOutOfBoundsError) {
            // Shouldn't happen
        }

        // Skip non-mut fields (constants/methods don't need cloning)
        if member.is_mut {
            // Build: self.field_name.clone()
            // This is: Identifier("self") [ Identifier("field_name"), Identifier("clone") ]
            mut clone_access_params := Vec.new(Expr)
            clone_access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
            clone_access_params.push(Expr.new_explicit(NodeType.Identifier("clone"), Vec.new(Expr), line, col))
            clone_access := Expr.new_explicit(NodeType.Identifier("self"), clone_access_params, line, col)

            // FCall for self.field_name.clone()
            mut clone_call_params := Vec.new(Expr)
            clone_call_params.push(clone_access)
            clone_call := Expr.new_explicit(NodeType.FCall(false), clone_call_params, line, col)

            // Build named argument: field_name = self.field_name.clone()
            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(clone_call)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, line, col)

            named_args.push(named_arg)
        }
    }

    // Build: StructName(field1 = ..., field2 = ...)
    // This is: Identifier("StructName") followed by named args
    struct_name_id := Expr.new_explicit(NodeType.Identifier(struct_name), Vec.new(Expr), line, col)

    mut struct_literal_params := Vec.new(Expr)
    struct_literal_params.push(struct_name_id)
    for na_i in 0..named_args.len() {
        mut na := Expr()
        named_args.get(na_i, na)?
        catch (err: IndexOutOfBoundsError) {}
        struct_literal_params.push(na)
    }

    struct_literal := Expr.new_explicit(NodeType.FCall(false), struct_literal_params, line, col)

    // Build: return StructName(...)
    mut return_params := Vec.new(Expr)
    return_params.push(struct_literal)
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    // Create the FuncDef
    mut args := Vec.new(Declaration)
    args.push(self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(ValueType.TCustom(struct_name))
    mut body := Vec.new(Expr)
    body.push(return_stmt)
    func_def := SFuncDef(
        function_type=FunctionType.FTFunc,
        args=args,
        return_types=return_types,
        throw_types=Vec.new(ValueType),
        body=body,
        source_path=""
    )

    // Create the declaration for the method
    method_decl := Declaration(
        name="clone",
        value_type=ValueType.TFunction(FunctionType.FTFunc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)

    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a delete() method for an enum - no-op since enums are value types.
generate_enum_delete_method := func(enum_name: Str, line: I64, col: I64) returns Expr {
    // Build: delete := proc(mut self: EnumName) {}
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=Vec.new(Expr),  // Empty body - no-op
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Generate a clone() method for an enum - returns self since enums are value types.
generate_enum_clone_method := func(enum_name: Str, line: I64, col: I64) returns Expr {
    // Build: clone := func(self: EnumName) returns EnumName { return self }
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    // Build: return self
    mut return_params := Vec.new(Expr)
    return_params.push(Expr.new_explicit(NodeType.Identifier("self"), Vec.new(Expr), line, col))
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(ValueType.TCustom(enum_name))
    mut body := Vec.new(Expr)
    body.push(return_stmt)
    func_def := SFuncDef(
        function_type=FunctionType.FTFunc,
        args=args,
        return_types=return_types,
        throw_types=Vec.new(ValueType),
        body=body,
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Preinit phase entry point: Recursively process AST to auto-generate delete and clone methods.
preinit_expr := func(e: Expr) returns Expr {
    switch e.node_type {
    // Handle Declaration nodes - check for struct definitions that need delete/clone methods
    case NodeType.Declaration(decl):
        // Check if this is a struct definition
        if e.params.len().gt(0) {
            mut value_expr := Expr()
            e.params.get(0, value_expr)?
            catch (err: IndexOutOfBoundsError) {
                // Shouldn't happen since we checked len > 0
            }

            switch value_expr.node_type {
            case NodeType.StructDef(struct_def):
                // Check if struct already has delete method (check both members and default_values)
                mut has_delete_in_members := false
                for mi in 0..struct_def.members.len() {
                    mut m := Declaration()
                    struct_def.members.get(mi, m)?
                    catch (err: IndexOutOfBoundsError) {}
                    if m.name.eq("delete") {
                        has_delete_in_members = true
                    }
                }
                mut has_delete_in_values := false
                mut dummy_expr := Expr()
                struct_def.default_values.get("delete", dummy_expr)?
                has_delete_in_values = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }
                has_delete := has_delete_in_members.or(has_delete_in_values)

                // Check if struct already has clone method
                mut has_clone_in_members := false
                for ci in 0..struct_def.members.len() {
                    mut cm := Declaration()
                    struct_def.members.get(ci, cm)?
                    catch (err: IndexOutOfBoundsError) {}
                    if cm.name.eq("clone") {
                        has_clone_in_members = true
                    }
                }
                mut has_clone_in_values := false
                mut dummy_expr2 := Expr()
                struct_def.default_values.get("clone", dummy_expr2)?
                has_clone_in_values = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }
                has_clone := has_clone_in_members.or(has_clone_in_values)

                // Check if struct has any mutable fields (skip methods for empty/constant-only structs)
                mut has_mut_fields := false
                for mfi in 0..struct_def.members.len() {
                    mut mf := Declaration()
                    struct_def.members.get(mfi, mf)?
                    catch (err: IndexOutOfBoundsError) {}
                    if mf.is_mut {
                        has_mut_fields = true
                    }
                }

                // Generate missing methods if struct has mutable fields
                needs_delete := not(has_delete).and(has_mut_fields)
                needs_clone := not(has_clone).and(has_mut_fields)

                if needs_delete.or(needs_clone) {
                    mut new_members := struct_def.members.clone()
                    mut new_default_values := Map.new(Str, Expr)

                    // Copy existing default values (recursively process them)
                    mut dvi := 0
                    while dvi.lt(struct_def.default_values.keys.len()) {
                        mut dv_name := ""
                        struct_def.default_values.keys.get(dvi, dv_name)?
                        catch (err: IndexOutOfBoundsError) {}
                        mut dv_val_expr := Expr()
                        struct_def.default_values.get(dv_name, dv_val_expr)?
                        catch (err: KeyNotFoundError) {}
                        new_default_values.set(dv_name, preinit_expr(dv_val_expr))
                        dvi.inc()
                    }

                    // Generate delete method if needed
                    if needs_delete {
                        delete_result := generate_delete_method(decl.name, struct_def, e.line, e.col)
                        new_members.push(delete_result.decl)
                        new_default_values.set("delete", delete_result.expr)
                    }

                    // Generate clone method if needed
                    if needs_clone {
                        clone_result := generate_clone_method(decl.name, struct_def, e.line, e.col)
                        new_members.push(clone_result.decl)
                        new_default_values.set("clone", clone_result.expr)
                    }

                    new_struct_def := SStructDef(
                        members=new_members,
                        default_values=new_default_values
                    )

                    new_struct_expr := Expr.new_clone(
                        NodeType.StructDef(new_struct_def),
                        value_expr,
                        value_expr.params
                    )

                    mut new_params := Vec.new(Expr)
                    new_params.push(new_struct_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, new_params)
                }

            case NodeType.EnumDef(enum_def):
                // Check if enum already has delete/clone methods
                mut has_enum_delete := false
                mut dummy_enum_del := Expr()
                enum_def.methods.get("delete", dummy_enum_del)?
                has_enum_delete = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }

                mut has_enum_clone := false
                mut dummy_enum_cln := Expr()
                enum_def.methods.get("clone", dummy_enum_cln)?
                has_enum_clone = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }

                if not(has_enum_delete).or(not(has_enum_clone)) {
                    mut new_methods := enum_def.methods.clone()

                    // Generate delete method if needed
                    if not(has_enum_delete) {
                        new_methods.set("delete", generate_enum_delete_method(decl.name, e.line, e.col))
                    }

                    // Generate clone method if needed
                    if not(has_enum_clone) {
                        new_methods.set("clone", generate_enum_clone_method(decl.name, e.line, e.col))
                    }

                    mut new_enum_def := SEnumDef()
                    new_enum_def.variants = enum_def.variants.clone()
                    new_enum_def.methods = new_methods

                    new_enum_expr := Expr.new_clone(
                        NodeType.EnumDef(new_enum_def),
                        value_expr,
                        value_expr.params
                    )

                    mut new_params := Vec.new(Expr)
                    new_params.push(new_enum_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, new_params)
                }

            case:
                // Not a struct or enum definition, fall through to default handling
            }
        }

        // Default: recurse into params
        mut new_params := Vec.new(Expr)
        for pi in 0..e.params.len() {
            mut p := Expr()
            e.params.get(pi, p)?
            catch (err: IndexOutOfBoundsError) {}
            new_params.push(preinit_expr(p))
        }
        return Expr.new_clone(e.node_type, e, new_params)

    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        mut new_body := Vec.new(Expr)
        for fi in 0..func_def.body.len() {
            mut stmt := Expr()
            func_def.body.get(fi, stmt)?
            catch (err: IndexOutOfBoundsError) {}
            new_body.push(preinit_expr(stmt))
        }
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args,
            return_types=func_def.return_types,
            throw_types=func_def.throw_types,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)

    // Recurse into StructDef default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        mut sdi := 0
        while sdi.lt(struct_def.default_values.keys.len()) {
            mut sd_name := ""
            struct_def.default_values.keys.get(sdi, sd_name)?
            catch (err: IndexOutOfBoundsError) {}
            mut sd_value_expr := Expr()
            struct_def.default_values.get(sd_name, sd_value_expr)?
            catch (err: KeyNotFoundError) {}
            new_default_values.set(sd_name, preinit_expr(sd_value_expr))
            sdi.inc()
        }
        new_struct_def := SStructDef(
            members=struct_def.members,
            default_values=new_default_values
        )
        return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params)

    // For all other nodes, recurse into params
    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut new_params := Vec.new(Expr)
            for opi in 0..e.params.len() {
                mut op := Expr()
                e.params.get(opi, op)?
                catch (err: IndexOutOfBoundsError) {}
                new_params.push(preinit_expr(op))
            }
            return Expr.new_clone(e.node_type, e, new_params)
        }
    }
}
