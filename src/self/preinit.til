mode lib

import("self.parser")

// Preinit phase: Auto-generates delete() and clone() methods for structs/enums.
// Issue #108: Methods are generated into namespace blocks, not into struct definitions.
// This keeps structs clean (only storage fields) while still providing auto-generated methods.

/// Result of generating a method - contains the declaration and expression.
MethodResult := struct {
    mut decl: Declaration = Declaration()
    mut expr: Expr = Expr()
}

/// Check if a value type has no fields (no delete/clone needed).
/// - I64, U8: true built-in primitives
/// - Dynamic, Type: empty structs with no fields
is_primitive_type := func(vt: ValueType) returns Bool {
    switch vt {
    case ValueType.TCustom(name):
        if name.eq("I64") { return true }
        if name.eq("U8") { return true }
        if name.eq("Dynamic") { return true }
        if name.eq("Type") { return true }
        return false
    case:
        return false
    }
}

/// Generate a delete() method for a struct.
/// The method calls field.delete() for each mutable field in reverse declaration order.
generate_delete_method := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns MethodResult {
    // Build: delete := proc(mut self: StructName) { self.field_n.delete(); ... self.field_0.delete(); }

    // Check if there will be any delete calls (determines if we use _self or self)
    mut has_non_primitive_fields := false
    for mf: Declaration in struct_def.members {
        if mf.is_mut {
            if not(is_primitive_type(mf.value_type)) {
                has_non_primitive_fields = true
            }
        }
    }

    mut self_param_name := "_self"
    if has_non_primitive_fields {
        self_param_name = "self"
    }

    self_decl := Declaration(
        name=self_param_name,
        value_type=ValueType.TCustom(struct_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut body_stmts := Vec.new(Expr)

    // Process fields in reverse order (like C++/Rust destructors)
    mut member_i := struct_def.members.len().sub(1)
    while member_i.gteq(0) {
        member := cast(Declaration, struct_def.members.get_by_ref(member_i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "members.get_by_ref: bounds-checked loop: ", err.msg)
        }

        // Skip non-mut fields and primitive types
        if member.is_mut {
            if not(is_primitive_type(member.value_type)) {
                // Build: self.field_name.delete()
                mut delete_access_params := Vec.new(Expr)
                delete_access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                delete_access_params.push(Expr.new_explicit(NodeType.Identifier("delete"), Vec.new(Expr), line, col))
                delete_access := Expr.new_explicit(NodeType.Identifier("self"), delete_access_params, line, col)

                mut delete_call_params := Vec.new(Expr)
                delete_call_params.push(delete_access)
                delete_call := Expr.new_explicit(NodeType.FCall(false), delete_call_params, line, col)

                body_stmts.push(delete_call)
            }
        }

        member_i.dec()
    }

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=body_stmts,
        source_path=""
    )

    method_decl := Declaration(
        name="delete",
        value_type=ValueType.TFunction(FunctionType.FTProc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a clone() method for a struct.
/// The method returns a new instance with each mutable field cloned.
generate_clone_method := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns MethodResult {
    // Build: clone := func(self: StructName) returns StructName { return StructName(field1 = self.field1.clone(), ...) }

    // Use _self when no mut fields (body won't reference self)
    mut has_mut_fields := false
    for mf2: Declaration in struct_def.members {
        if mf2.is_mut {
            has_mut_fields = true
        }
    }

    mut self_param_name := "_self"
    if has_mut_fields {
        self_param_name = "self"
    }

    self_decl := Declaration(
        name=self_param_name,
        value_type=ValueType.TCustom(struct_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut named_args := Vec.new(Expr)

    for member: Declaration in struct_def.members {
        if member.is_mut {
            // For primitive types, just copy the value directly: self.field_name
            // For other types, call clone: self.field_name.clone()
            mut field_value := Expr()
            if is_primitive_type(member.value_type) {
                // Build: self.field_name
                mut access_params := Vec.new(Expr)
                access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                field_value = Expr.new_explicit(NodeType.Identifier("self"), access_params, line, col)
            } else {
                // Build: self.field_name.clone()
                mut clone_access_params := Vec.new(Expr)
                clone_access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                clone_access_params.push(Expr.new_explicit(NodeType.Identifier("clone"), Vec.new(Expr), line, col))
                clone_access := Expr.new_explicit(NodeType.Identifier("self"), clone_access_params, line, col)

                mut clone_call_params := Vec.new(Expr)
                clone_call_params.push(clone_access)
                field_value = Expr.new_explicit(NodeType.FCall(false), clone_call_params, line, col)
            }

            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(field_value)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, line, col)
            named_args.push(named_arg)
        }
    }

    struct_name_id := Expr.new_explicit(NodeType.Identifier(struct_name), Vec.new(Expr), line, col)

    mut struct_literal_params := Vec.new(Expr)
    struct_literal_params.push(struct_name_id)
    for na: Expr in named_args {
        struct_literal_params.push(na)
    }

    struct_literal := Expr.new_explicit(NodeType.FCall(false), struct_literal_params, line, col)

    mut return_params := Vec.new(Expr)
    return_params.push(struct_literal)
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(ValueType.TCustom(struct_name))
    mut body := Vec.new(Expr)
    body.push(return_stmt)
    func_def := SFuncDef(
        function_type=FunctionType.FTFunc,
        args=args,
        return_types=return_types,
        throw_types=Vec.new(ValueType),
        body=body,
        source_path=""
    )

    method_decl := Declaration(
        name="clone",
        value_type=ValueType.TFunction(FunctionType.FTFunc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
    return MethodResult(decl=method_decl, expr=func_expr)
}

/// Generate a delete() method for an enum - no-op since enums are value types.
generate_enum_delete_method := func(enum_name: Str, line: I64, col: I64) returns Expr {
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=Vec.new(Expr),
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Generate a clone() method for an enum - returns self since enums are value types.
generate_enum_clone_method := func(enum_name: Str, line: I64, col: I64) returns Expr {
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(enum_name),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    mut return_params := Vec.new(Expr)
    return_params.push(Expr.new_explicit(NodeType.Identifier("self"), Vec.new(Expr), line, col))
    return_stmt := Expr.new_explicit(NodeType.Return, return_params, line, col)

    mut args := Vec.new(Declaration)
    args.push(self_decl)
    mut return_types := Vec.new(ValueType)
    return_types.push(ValueType.TCustom(enum_name))
    mut body := Vec.new(Expr)
    body.push(return_stmt)
    func_def := SFuncDef(
        function_type=FunctionType.FTFunc,
        args=args,
        return_types=return_types,
        throw_types=Vec.new(ValueType),
        body=body,
        source_path=""
    )

    return Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)
}

/// Collect all methods defined in namespace blocks.
/// Returns a Set of "TypeName.methodName" strings.
collect_namespace_methods := func(ast: Expr) returns Set {
    mut methods := Set.new(Str)

    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.NamespaceDef(ns_def):
                for member: Declaration in ns_def.members {
                    _ := methods.insert(format(ns_def.type_name, ".", member.name))
                }
            case:
            }
        }
    case:
    }

    return methods
}

/// Info about a struct that needs auto-generated methods.
StructNeedingMethods := struct {
    mut struct_name: Str = ""
    mut struct_def: SStructDef = SStructDef()
    mut line: I64 = 0
    mut col: I64 = 0
    mut needs_delete: Bool = false
    mut needs_clone: Bool = false
}

/// Collect all structs that need auto-generated methods.
collect_structs_needing_methods := func(ast: Expr, namespace_methods: Set) returns Vec throws Str {
    mut structs := Vec.new(StructNeedingMethods)

    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            switch child.node_type {
            case NodeType.Declaration(decl):
                if child.params.len().gt(0) {
                    value_expr := child.get(0)?
                    dont_delete(value_expr)

                    switch value_expr.node_type {
                    case NodeType.StructDef(struct_def):
                        // Check if delete/clone are already defined (in struct or namespace)
                        mut has_delete_inline := false
                        for dm: Declaration in struct_def.members {
                            if dm.name.eq("delete") {
                                has_delete_inline = true
                            }
                        }
                        if struct_def.default_values.contains_key("delete") {
                            has_delete_inline = true
                        }
                        has_delete_namespace := namespace_methods.contains(format(decl.name, ".delete"))
                        has_delete := has_delete_inline.or(has_delete_namespace)

                        mut has_clone_inline := false
                        for clm: Declaration in struct_def.members {
                            if clm.name.eq("clone") {
                                has_clone_inline = true
                            }
                        }
                        if struct_def.default_values.contains_key("clone") {
                            has_clone_inline = true
                        }
                        has_clone_namespace := namespace_methods.contains(format(decl.name, ".clone"))
                        has_clone := has_clone_inline.or(has_clone_namespace)

                        needs_delete := not(has_delete)
                        needs_clone := not(has_clone)

                        if needs_delete.or(needs_clone) {
                            mut info := StructNeedingMethods()
                            info.struct_name = decl.name.clone()
                            info.struct_def = struct_def.clone()
                            info.line = child.line
                            info.col = child.col
                            info.needs_delete = needs_delete
                            info.needs_clone = needs_clone
                            structs.push(info)
                        }
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    return structs
}

/// Issue #105: Result struct for generate_struct_methods
StructMethodsResult := struct {
    mut needs_methods: Bool = false
    mut ns_block: Expr = Expr()
}

/// Issue #105: Public API for generating delete/clone methods for a macro-expanded struct.
/// Returns StructMethodsResult with needs_methods=true and ns_block set if methods needed.
generate_struct_methods := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns StructMethodsResult {
    // Check if delete/clone are already defined inline
    mut has_delete := false
    mut has_clone := false
    for member: Declaration in struct_def.members {
        if member.name.eq("delete") {
            has_delete = true
        }
        if member.name.eq("clone") {
            has_clone = true
        }
    }
    if struct_def.default_values.contains_key("delete") {
        has_delete = true
    }
    if struct_def.default_values.contains_key("clone") {
        has_clone = true
    }

    needs_delete := not(has_delete)
    needs_clone := not(has_clone)

    if needs_delete.or(needs_clone) {
        mut result := StructMethodsResult()
        result.needs_methods = true
        result.ns_block = generate_namespace_block(struct_name, struct_def, line, col, needs_delete, needs_clone)
        return result
    }
    return StructMethodsResult()
}

/// Generate a namespace block with auto-generated methods for a struct.
generate_namespace_block := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64, needs_delete: Bool, needs_clone: Bool) returns Expr {
    mut members := Vec.new(Declaration)
    mut default_values := Map.new(Str, Expr)

    if needs_delete {
        delete_result := generate_delete_method(struct_name, struct_def, line, col)
        members.push(delete_result.decl)
        default_values.set("delete", delete_result.expr)
    }

    if needs_clone {
        clone_result := generate_clone_method(struct_name, struct_def, line, col)
        members.push(clone_result.decl)
        default_values.set("clone", clone_result.expr)
    }

    ns_def := SNamespaceDef(
        type_name=struct_name,
        members=members,
        default_values=default_values
    )

    return Expr.new_explicit(NodeType.NamespaceDef(ns_def), Vec.new(Expr), line, col)
}

/// Recursively process expression (for nested function bodies, etc.)
preinit_expr_inner := func(e: Expr) returns Expr throws Str {
    switch e.node_type {
    case NodeType.FuncDef(func_def):
        mut new_body := Vec.new(Expr)
        for stmt: Expr in func_def.body {
            new_body.push(preinit_expr_inner(stmt)?)
        }
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args,
            return_types=func_def.return_types,
            throw_types=func_def.throw_types,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)

    case NodeType.StructDef(struct_def):
        // Recurse into default values but DON'T add delete/clone here
        mut new_default_values := Map.new(Str, Expr)
        for sd_name: Str in struct_def.default_values.keys {
            sd_value_expr := cast(Expr, struct_def.default_values.get_by_ref(sd_name)?)
            new_default_values.set(sd_name.clone(), preinit_expr_inner(sd_value_expr)?)
        }
        catch (err: KeyNotFoundError) { panic(loc(), err.msg) }
        new_struct_def := SStructDef(
            members=struct_def.members,
            default_values=new_default_values
        )
        return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params)

    case NodeType.Declaration(decl):
        // For enum definitions, still add delete/clone directly (enums don't use namespace blocks yet)
        if e.params.len().gt(0) {
            value_expr := e.get(0)?
            dont_delete(value_expr)

            switch value_expr.node_type {
            case NodeType.EnumDef(enum_def):
                has_delete := enum_def.methods.contains_key("delete")
                has_clone := enum_def.methods.contains_key("clone")

                if not(has_delete).or(not(has_clone)) {
                    mut new_methods := enum_def.methods.clone()

                    if not(has_delete) {
                        new_methods.set("delete", generate_enum_delete_method(decl.name, e.line, e.col))
                    }

                    if not(has_clone) {
                        new_methods.set("clone", generate_enum_clone_method(decl.name, e.line, e.col))
                    }

                    mut new_enum_def := SEnumDef()
                    new_enum_def.variants = enum_def.variants.clone()
                    new_enum_def.methods = new_methods

                    new_enum_expr := Expr.new_clone(
                        NodeType.EnumDef(new_enum_def),
                        value_expr,
                        value_expr.params
                    )

                    mut enum_new_params := Vec.new(Expr)
                    enum_new_params.push(new_enum_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, enum_new_params)
                }
            case:
            }
        }

        // Default: recurse into params
        mut decl_new_params := Vec.new(Expr)
        for p: Expr in e.params {
            decl_new_params.push(preinit_expr_inner(p)?)
        }
        return Expr.new_clone(e.node_type, e, decl_new_params)

    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut default_new_params := Vec.new(Expr)
            for op: Expr in e.params {
                default_new_params.push(preinit_expr_inner(op)?)
            }
            return Expr.new_clone(e.node_type, e, default_new_params)
        }
    }
}

/// Preinit phase entry point.
/// For structs: generates namespace blocks with delete/clone methods.
/// For enums: adds delete/clone directly to the enum definition.
preinit_expr := func(e: Expr) returns Expr throws Str {
    // For Body nodes (the AST root), do the two-pass approach
    switch e.node_type {
    case NodeType.Body:
        // Pass 1: Collect namespace-defined methods
        namespace_methods := collect_namespace_methods(e)

        // Pass 2: Find structs that need auto-generated methods
        structs_needing := collect_structs_needing_methods(e, namespace_methods)?

        // Pass 3: Process all children and generate namespace blocks
        mut new_params := Vec.new(Expr)
        for child: Expr in e.params {
            new_params.push(preinit_expr_inner(child)?)
        }

        // Append generated namespace blocks for structs that need them
        for info: StructNeedingMethods in structs_needing {
            ns_block := generate_namespace_block(
                info.struct_name,
                info.struct_def,
                info.line,
                info.col,
                info.needs_delete,
                info.needs_clone
            )
            new_params.push(ns_block)
        }

        return Expr.new_clone(e.node_type, e, new_params)
    case:
        // For non-Body nodes, just recurse
        return preinit_expr_inner(e)?
    }
}
