mode liba

import("std.arena")
import("self.init")
import("self.parser")

// EvalArena: Memory management for the TIL interpreter
// Extracted from interpreter.rs to enable incremental translation to TIL.


EvalArenaMapping := struct {
    mut name: Str = ""
    mut offset: I64 = 0
}

SymbolEntry := struct {
    mut name: Str = ""
    mut info: SymbolInfo = SymbolInfo()
}

// Result from insert_struct_core containing mappings to be stored
StructInsertResult := struct {
    mut arena_mappings: Vec = Vec.new(EvalArenaMapping)
    mut symbols: Vec = Vec.new(SymbolEntry)
}

// Result from insert_string_core containing string offset and length
StringInsertInfo := struct {
    mut string_offset: I64 = 0
    mut str_len: I64 = 0
}

// Result from insert_enum_core containing optional mapping and enum value
EnumInsertResult := struct {
    mut has_mapping: Bool = false
    mut mapping_name: Str = ""
    mut mapping_offset: I64 = 0
    mut enum_val: EnumVal = EnumVal()
}

EvalArena := struct {
    mut _arena: Arena = Arena()
    mut temp_id_counter: I64 = 0
    mut default_instances: Map = Map.new(Str, I64)  // type name -> arena offset of default template

    new := proc() returns EvalArena {
        mut a := EvalArena()
        a._arena = Arena.new()
        return a
    }

    /// Get current used length of arena memory
    len := func(self: EvalArena) returns I64 {
        return self._arena.len()
    }

    /// Get size of arena memory (same as len for EvalArena)
    size := func(self: EvalArena) returns I64 {
        return self._arena.len()
    }

    /// Append bytes to arena, return offset where they were placed
    put := proc(mut self: EvalArena, src_ptr: I64, num_bytes: I64) returns I64 {
        offset := self._arena.put(src_ptr, num_bytes)
        return offset
    }

    /// Read bytes from arena at offset (returns pointer to data)
    get := func(self: EvalArena, offset: I64, num_bytes: I64) returns I64 {
        return self._arena.get(offset, num_bytes)
    }

    /// Write bytes to arena at offset
    set := proc(mut self: EvalArena, offset: I64, src_ptr: I64, num_bytes: I64) {
        self._arena.set(offset, src_ptr, num_bytes)
    }

    /// Reserve space in arena, return offset where space was allocated
    reserve := proc(mut self: EvalArena, size: I64) returns I64 {
        offset := self._arena.reserve(size)
        return offset
    }

    // === EVAL-PHASE MEMORY OPERATIONS ===
    // These methods manage runtime memory allocation and access
    // They take Context as parameter to access type info and arena_index

    // Check if id refers to an instance field (e.g., "myStruct.field") vs a type constant
    is_instance_field := func(ctx: Context, id: Str) returns Bool {
        if not(id.contains(".")) {
            return false
        }
        parts := id.split(".")?
        mut base := ""
        parts.get(0, base)?
        mut sym := ctx.scope_stack.lookup_symbol(base)?
        switch sym.value_type {
        case ValueType.TType(inner):
            return false
        case:
            return true
        }
        catch (err: KeyNotFoundError) {
            return false
        }
        catch (err: IndexOutOfBoundsError) {
            return false
        }
    }

    get_u8 := func(ctx: Context, id: Str, e: Expr) returns U8 throws Str {
        // Try direct lookup first (for base variables)
        mut offset := ctx.scope_stack.lookup_var(id)?
        catch (err: KeyNotFoundError) {
            if id.contains(".") {
                // For field paths, calculate offset dynamically
                offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    throw e.lang_error(ctx.path, "context", format("get_u8: ", err2))
                }
            } else {
                throw e.lang_error(ctx.path, "context", format("u8 not found for id '", id, "'"))
            }
        }

        mut val : U8 = 0
        memcpy(to_ptr(val), g_arena.get(offset, 1), 1)
        return val
    }

    get_i64 := func(ctx: Context, id: Str, e: Expr) returns I64 throws Str {
        // Try direct lookup first (for base variables)
        mut offset := ctx.scope_stack.lookup_var(id)?
        catch (err: KeyNotFoundError) {
            if id.contains(".") {
                // For field paths, calculate offset dynamically
                offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    throw e.lang_error(ctx.path, "context", format("get_i64: ", err2))
                }
            } else {
                throw e.lang_error(ctx.path, "context", format("i64 not found for id '", id, "'"))
            }
        }

        mut val : I64 = 0
        memcpy(to_ptr(val), g_arena.get(offset, 8), 8)
        return val
    }

    // Core logic for insert_i64 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_i64_core := func(ctx: Context, id: Str, i64_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError {
        v := I64.from_str(i64_str)
        // Note: I64.from_str currently panics on invalid input, doesn't throw

        if EvalArena.is_instance_field(ctx, id) {
            // For instance field paths, calculate offset dynamically
            // REM renamed to field_offset (vs Rust's offset) due to C scope flattening
            mut field_offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                // Calculate offset from struct definition
                field_offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    throw e.lang_error(ctx.path, "context", format("insert_i64: ", err2))
                }
            }

            // Ensure arena has enough space
            required_len := add(field_offset, 8)
            if g_arena.len().lt(required_len) {
                _ := g_arena.reserve(sub(required_len, g_arena.len()))
            }

            g_arena.set(field_offset, to_ptr(v), 8)
            throw KeyNotFoundError(msg="already handled")
        }

        // For non-instance fields (including struct constants like Vec.INIT_CAP), create new entry
        offset := g_arena.put(to_ptr(v), 8)
        return offset
    }

    insert_i64 := proc(mut ctx: Context, id: Str, i64_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_i64_core(ctx, id, i64_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_i64_into_frame := proc(ctx: Context, mut frame: ScopeFrame, id: Str, i64_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_i64_core(ctx, id, i64_str, e)?
        frame.arena_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // Core logic for insert_u8 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_u8_core := func(ctx: Context, id: Str, u8_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError {
        v := U8.from_str(u8_str)?
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        if EvalArena.is_instance_field(ctx, id) {
            // For instance field paths, calculate offset dynamically
            // REM renamed to field_offset (vs Rust's offset) due to C scope flattening
            mut field_offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                // Calculate offset from struct definition
                field_offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    throw e.lang_error(ctx.path, "context", format("insert_u8: ", err2))
                }
            }
            g_arena.set(field_offset, to_ptr(v), 1)
            throw KeyNotFoundError(msg="already handled")
        }

        offset := g_arena.put(to_ptr(v), 1)
        return offset
    }

    insert_u8 := proc(mut ctx: Context, id: Str, u8_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_u8_core(ctx, id, u8_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_u8_into_frame := proc(ctx: Context, mut frame: ScopeFrame, id: Str, u8_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_u8_core(ctx, id, u8_str, e)?
        frame.arena_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // TODO all args should be passed as pointers/references and we wouldn't need this
    copy_fields := proc(mut ctx: Context, custom_type_name: Str, src: Str, dest: Str, e: Expr) throws Str {
        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("copy_fields: definition for '", custom_type_name, "' not found"))
        }

        mut dest_sym := ctx.scope_stack.lookup_symbol(dest)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("copy_fields: destination symbol '", dest, "' not found"))
        }
        is_mut := dest_sym.is_mut

        mut dest_base_offset := ctx.scope_stack.lookup_var(dest)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("copy_fields: destination arena offset for '", dest, "' not found"))
        }

        mut current_offset := 0
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(name):
                    field_size = ctx.get_type_size(name)?
                case:
                    throw e.lang_error(ctx.path, "context", format("copy_fields: unsupported field type '", value_type_to_str(decl.value_type), "'"))
                }

                src_key := format(src, ".", decl.name)
                dest_key := format(dest, ".", decl.name)

                // Try to get source offset - first from arena_index, then calculate dynamically
                mut src_offset := 0
                mut have_src_offset := true
                src_offset = ctx.scope_stack.lookup_var(src_key)?
                catch (err: KeyNotFoundError) {
                    // Calculate offset dynamically from struct definition
                    src_offset = ctx.get_field_offset(src_key)?
                    catch (err2: Str) {
                        // Skip if source field doesn't exist (e.g., is_dyn in Array but not in Vec)
                        current_offset = add(current_offset, field_size)
                        have_src_offset = false
                    }
                }

                if have_src_offset {
                    dest_offset := add(dest_base_offset, current_offset)

                    ctx.scope_stack.insert_var(dest_key, dest_offset)?
                    ctx.scope_stack.declare_symbol(dest_key, SymbolInfo(value_type=decl.value_type, is_mut=is_mut))?

                    g_arena.set(dest_offset, g_arena.get(src_offset, field_size), field_size)

                    switch decl.value_type {
                    case ValueType.TCustom(type_name):
                        // Check if it's a struct (not enum)
                        mut is_struct := true
                        _ := ctx.scope_stack.lookup_struct(type_name)?
                        catch (err: KeyNotFoundError) {
                            is_struct = false
                        }
                        if is_struct {
                            EvalArena.copy_fields(ctx, type_name, src_key, dest_key, e)?
                            catch (err: Str) {
                                throw e.lang_error(ctx.path, "context", format("copy_fields: failed to recursively copy field '", dest_key, "'"))
                            }
                        }
                    case:
                    }

                    current_offset = add(current_offset, field_size)
                }
            }
        }
    }

    // Core logic for insert_struct - does all the work but returns mappings instead of inserting them
    // existing_offset: -1 means None (allocate new), >= 0 means use that offset
    insert_struct_core := proc(mut ctx: Context, id: Str, custom_type_name: Str, existing_offset: I64, defaults: Map, e: Expr) returns StructInsertResult throws Str {
        mut result := StructInsertResult()

        // Lookup the struct definition
        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: definition for '", custom_type_name, "' not found"))
        }

        // Determine mutability from symbols table
        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: id '", id, "' for struct '", custom_type_name, "' not found in symbols"))
        }
        is_mut := sym.is_mut

        // Calculate total size (for now no alignment)
        mut total_size := 0
        mut field_offsets := Map.new(Str, I64)

        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "context", "insert_struct: Unsupported value type in struct")
                }

                field_offsets.set(decl.name, total_size)
                total_size = add(total_size, field_size)
            }
        }

        // Either use existing offset (for nested structs) or allocate new memory
        mut offset := existing_offset
        if existing_offset.lt(0) {
            offset = g_arena.reserve(total_size)
        }
        mut base_mapping := EvalArenaMapping()
        base_mapping.name = id
        base_mapping.offset = offset
        result.arena_mappings.push(base_mapping)

        // Store each field's default value
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_offset := 0
                field_offsets.get(decl.name, field_offset)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing field offset for '", decl.name, "'"))
                }

                mut default_value := ""
                defaults.get(decl.name, default_value)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing pre-evaluated default for field '", decl.name, "'"))
                }

                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Check if it's an enum
                    mut is_enum := true
                    mut enum_def := ctx.scope_stack.lookup_enum(type_name)?
                    catch (err: KeyNotFoundError) {
                        is_enum = false
                    }

                    if is_enum {
                        parts := default_value.split(".")?
                        if not(parts.len().eq(2)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        mut part0 := ""
                        parts.get(0, part0)?
                        if not(part0.eq(type_name)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        mut variant := ""
                        parts.get(1, variant)?
                        // Find variant index - Bug #38 fix: use variants Vec
                        mut index : I64 = 0
                        mut found_variant := false
                        mut vi := 0
                        while vi.lt(enum_def.variants.len()) {
                            mut ev := EnumVariant()
                            enum_def.variants.get(vi, ev)?
                            if ev.name.eq(variant) {
                                index = vi
                                found_variant = true
                            }
                            vi = add(vi, 1)
                        }
                        if not(found_variant) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown enum variant '", variant, "' for field '", decl.name, "'"))
                        }
                        g_arena.set(add(offset, field_offset), to_ptr(index), 8)
                    } else {
                        if type_name.eq("U8") {
                            u8_val := U8.from_str(default_value)?
                            // Note: U8.from_str panics on invalid input, doesn't throw
                            mut dest_u8 : U8 = u8_val
                            g_arena.set(add(offset, field_offset), to_ptr(dest_u8), 1)
                        } else {
                            if type_name.eq("I64") {
                                i64_val := I64.from_str(default_value)
                                // Note: I64.from_str panics on invalid input, doesn't throw
                                g_arena.set(add(offset, field_offset), to_ptr(i64_val), 8)
                            } else {
                                // Check if it's a struct
                                mut is_struct := true
                                _ := ctx.scope_stack.lookup_struct(type_name)?
                                catch (err: KeyNotFoundError) {
                                    is_struct = false
                                }

                                if is_struct {
                                    nested_combined_name := format(id, ".", decl.name)
                                    nested_symbol := SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true)
                                    // Must declare symbol BEFORE recursive call (needed for is_mut lookup)
                                    ctx.scope_stack.declare_symbol(nested_combined_name, nested_symbol)?
                                    mut sym_entry := SymbolEntry()
                                    sym_entry.name = nested_combined_name
                                    sym_entry.info = nested_symbol
                                    result.symbols.push(sym_entry)

                                    // Special case: Str field initialization
                                    if type_name.eq("Str") {
                                        // Register inline offset BEFORE insert_string so it writes to the inline space
                                        str_field_offset := add(offset, field_offset)
                                        mut str_mapping := EvalArenaMapping()
                                        str_mapping.name = nested_combined_name
                                        str_mapping.offset = str_field_offset
                                        result.arena_mappings.push(str_mapping)
                                        // Need to temporarily insert for insert_string to work
                                        ctx.scope_stack.insert_var(nested_combined_name, str_field_offset)?
                                        EvalArena.insert_string(ctx, nested_combined_name, default_value, e)?
                                    } else {
                                        // Use existing offset for nested struct (inline allocation)
                                        nested_field_offset := add(offset, field_offset)
                                        mut nested_mapping := EvalArenaMapping()
                                        nested_mapping.name = nested_combined_name
                                        nested_mapping.offset = nested_field_offset
                                        result.arena_mappings.push(nested_mapping)
                                        // Need to temporarily insert for recursive call to work
                                        ctx.scope_stack.insert_var(nested_combined_name, nested_field_offset)?
                                        // Extract nested defaults (field.subfield -> subfield)
                                        prefix := format(decl.name, ".")
                                        mut nested_defaults := Map.new(Str, Str)
                                        default_keys := defaults.keys
                                        for dk: Str in default_keys {
                                            if dk.starts_with(prefix) {
                                                rest := dk.strip_prefix(prefix)
                                                mut dv := ""
                                                defaults.get(dk, dv)?
                                                catch (err: KeyNotFoundError) {
                                                    panic(loc(), "insert_struct_core: key not found in defaults")
                                                }
                                                nested_defaults.set(rest, dv)
                                            }
                                        }
                                        nested_result := EvalArena.insert_struct_core(ctx, nested_combined_name, type_name, nested_field_offset, nested_defaults, e)?
                                        catch (err: Str) {
                                            throw e.lang_error(ctx.path, "context", format("insert_struct: Failed to initialize nested struct '", id, ".", decl.name, "'"))
                                        }
                                        // Collect nested mappings
                                        result.arena_mappings.extend(nested_result.arena_mappings)
                                        result.symbols.extend(nested_result.symbols)
                                    }
                                } else {
                                    throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown field type '", type_name, "'"))
                                }
                            }
                        }
                    }
                case:
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Unsupported field value type '", value_type_to_str(decl.value_type), "'"))
                }

                combined_name := format(id, ".", decl.name)
                field_arena_offset := add(offset, field_offset)
                mut field_mapping := EvalArenaMapping()
                field_mapping.name = combined_name
                field_mapping.offset = field_arena_offset
                result.arena_mappings.push(field_mapping)
                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)
            }
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct_core: ", err.msg))
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        return result
    }

    // Generate arena mappings and symbols for a struct without writing bytes.
    // Used for template-based insertion where bytes are already memcpy'd.
    generate_struct_mappings := proc(mut ctx: Context, id: Str, custom_type_name: Str, base_offset: I64, e: Expr) returns StructInsertResult throws Str {
        mut result := StructInsertResult()

        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("struct '", custom_type_name, "' not found"))
        }

        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("symbol '", id, "' not found"))
        }
        is_mut := sym.is_mut

        // Calculate field offsets (same as insert_struct_core)
        mut current_offset := 0
        mut field_offsets := Map.new(Str, I64)
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "generate_struct_mappings", "Unsupported value type")
                }
                field_offsets.set(decl.name, current_offset)
                current_offset = add(current_offset, field_size)
            }
        }

        // Add base struct mapping
        mut base_mapping := EvalArenaMapping()
        base_mapping.name = id
        base_mapping.offset = base_offset
        result.arena_mappings.push(base_mapping)

        // Generate mappings for each field
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_rel_offset := 0
                field_offsets.get(decl.name, field_rel_offset)?
                catch (err: KeyNotFoundError) {
                    field_rel_offset = 0
                }
                field_abs_offset := add(base_offset, field_rel_offset)
                combined_name := format(id, ".", decl.name)

                mut field_mapping := EvalArenaMapping()
                field_mapping.name = combined_name
                field_mapping.offset = field_abs_offset
                result.arena_mappings.push(field_mapping)

                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)

                // Handle nested structs recursively
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if not(type_name.eq("U8")) {
                        if not(type_name.eq("I64")) {
                            mut is_struct := true
                            _ := ctx.scope_stack.lookup_struct(type_name)?
                            catch (err: KeyNotFoundError) {
                                is_struct = false
                            }
                            if is_struct {
                                // Declare nested symbol first
                                ctx.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true))?
                                nested := EvalArena.generate_struct_mappings(ctx, combined_name, type_name, field_abs_offset, e)?
                                result.arena_mappings.extend(nested.arena_mappings)
                                result.symbols.extend(nested.symbols)
                            }
                        }
                    }
                case:
                }
            }
        }

        return result
    }

    // Insert a struct by copying from a cached template.
    // Much faster than insert_struct_core for subsequent instances of the same type.
    insert_struct := proc(mut ctx: Context, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the arena's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_arena.get(template_offset, struct_size), struct_size)

        // Allocate new memory (may reallocate arena)
        new_offset := g_arena.reserve(struct_size)

        // Copy from temporary buffer to new location
        g_arena.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Generate and apply mappings
        result := EvalArena.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?
        for m: EvalArenaMapping in result.arena_mappings {
            ctx.scope_stack.insert_var(m.name, m.offset)?
        }
        for s: SymbolEntry in result.symbols {
            ctx.scope_stack.declare_symbol(s.name, s.info)?
        }

        catch (err: BadAlloc) {
            panic(loc(), "insert_struct: buy more ram")
        }
    }

    // Insert a struct from template into a specific frame (for function parameters).
    insert_struct_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the arena's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_arena.get(template_offset, struct_size), struct_size)

        // Allocate new memory (may reallocate arena)
        new_offset := g_arena.reserve(struct_size)

        // Copy from temporary buffer to new location
        g_arena.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Temporarily push frame for generate_struct_mappings
        ctx.scope_stack.frames.push(frame)

        result := EvalArena.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?

        // Pop frame back
        mut popped_frame := ScopeFrame()
        ctx.scope_stack.frames.pop(popped_frame)?
        frame = popped_frame

        for m: EvalArenaMapping in result.arena_mappings {
            frame.arena_index.set(m.name, m.offset)
        }
        for s: SymbolEntry in result.symbols {
            frame.symbols.set(s.name, s.info)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_struct_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: BadAlloc) {
            panic(loc(), "insert_struct_into_frame: buy more ram")
        }
    }

    // Core logic for insert_string - returns StringInsertInfo if caller needs to create struct, throws KeyNotFoundError if already handled
    insert_string_core := proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) returns StringInsertInfo throws Str, KeyNotFoundError {
        is_field := EvalArena.is_instance_field(ctx, id)

        // Allocate string data
        string_offset := g_arena.put(value_str.c_string, value_str.len())
        mut null_byte : U8 = 0
        _ := g_arena.put(to_ptr(null_byte), 1)  // null terminator
        str_len := value_str.len()

        if is_field {
            mut have_base_offset := true
            mut base_offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                have_base_offset = false
            }

            if have_base_offset {
                mut existing_str_def := ctx.scope_stack.lookup_struct("Str")?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", "ERROR: 'Str' struct definition not found")
                }

                mut existing_offset := 0
                for existing_decl: Declaration in existing_str_def.members {
                    if existing_decl.is_mut {
                        existing_type_size := ctx.get_type_size(value_type_to_str(existing_decl.value_type))?
                        absolute_offset := add(base_offset, existing_offset)

                        if existing_decl.name.eq("c_string") {
                            g_arena.set(absolute_offset, to_ptr(string_offset), 8)
                        } else {
                            if existing_decl.name.eq("cap") {
                                g_arena.set(absolute_offset, to_ptr(str_len), 8)
                            }
                        }

                        ctx.scope_stack.insert_var(format(id, ".", existing_decl.name), absolute_offset)?
                        existing_offset = add(existing_offset, existing_type_size)
                    }
                }
                throw KeyNotFoundError(msg="already handled")
            }

            // Not yet inserted - insert fresh inlined Str
            mut str_def := ctx.scope_stack.lookup_struct("Str")?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", "'Str' struct definition not found")
            }

            struct_offset := g_arena.len()
            mut current_offset := 0

            for decl: Declaration in str_def.members {
                if decl.is_mut {
                    type_size := ctx.get_type_size(value_type_to_str(decl.value_type))?
                    // Ensure space
                    required_len := add(add(struct_offset, current_offset), type_size)
                    if g_arena.len().lt(required_len) {
                        _ := g_arena.reserve(sub(required_len, g_arena.len()))
                    }

                    field_offset := add(struct_offset, current_offset)
                    if decl.name.eq("c_string") {
                        g_arena.set(field_offset, to_ptr(string_offset), 8)
                    } else {
                        if decl.name.eq("cap") {
                            g_arena.set(field_offset, to_ptr(str_len), 8)
                        }
                    }

                    ctx.scope_stack.insert_var(format(id, ".", decl.name), field_offset)?
                    current_offset = add(current_offset, type_size)
                }
            }

            ctx.scope_stack.insert_var(id, struct_offset)?
            throw KeyNotFoundError(msg="already handled")
        }

        mut result := StringInsertInfo()
        result.string_offset = string_offset
        result.str_len = str_len

        return result
    }

    insert_string := proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) throws Str {
        info := EvalArena.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        mut template_offset := 0
        g_arena.default_instances.get("Str", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string", "Str template not found - ensure str.til is imported")
        }
        EvalArena.insert_struct(ctx, id, "Str", template_offset, e)?
        c_string_offset := ctx.scope_stack.lookup_var(format(id, ".c_string"))?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_string: missing '", id, ".c_string'"))
        }
        cap_offset := ctx.scope_stack.lookup_var(format(id, ".cap"))?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_string: missing '", id, ".cap'"))
        }
        g_arena.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_arena.set(cap_offset, to_ptr(info.str_len), 8)

    }

    insert_string_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, value_str: Str, e: Expr) throws Str {
        info := EvalArena.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        mut template_offset := 0
        g_arena.default_instances.get("Str", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", "Str template not found - ensure str.til is imported")
        }
        EvalArena.insert_struct_into_frame(ctx, frame, id, "Str", template_offset, e)?
        mut c_string_offset := 0
        frame.arena_index.get(format(id, ".c_string"), c_string_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_string_into_frame: missing '", id, ".c_string'"))
        }
        mut cap_offset := 0
        frame.arena_index.get(format(id, ".cap"), cap_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_string_into_frame: missing '", id, ".cap'"))
        }
        g_arena.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_arena.set(cap_offset, to_ptr(info.str_len), 8)
    }

    // Helper function to insert primitive types (I64, U8, Str) based on value_type
    insert_primitive := proc(mut ctx: Context, var_name: Str, value_type: ValueType, value: Str, e: Expr) throws Str {
        switch value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                EvalArena.insert_i64(ctx, var_name, value, e)?
            } else {
                if type_name.eq("U8") {
                    EvalArena.insert_u8(ctx, var_name, value, e)?
                } else {
                    if type_name.eq("Str") {
                        EvalArena.insert_string(ctx, var_name, value, e)?
                    } else {
                        throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
                    }
                }
            }
        case:
            throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
        }
    }

    get_enum_at_offset := func(ctx: Context, enum_type: Str, offset: I64, e: Expr) returns EnumVal throws Str {
        // Read enum from a specific offset (used for nested enum payloads)
        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_arena.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum_at_offset: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload
        }
        catch (err: IndexOutOfBoundsError) {
            // Should never happen
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut payload_type := ValueType.TCustom("")
            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
            switch payload_type {
            case ValueType.TCustom(inner_type):
                // This variant has a payload - recursively determine size
                payload_size := EvalArena.get_payload_size_for_type(ctx, payload_type, add(offset, 8), e)?
                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_size)
                    if payload_end.lteq(g_arena.len()) {
                        // Copy payload bytes
                        mut payload_bytes := Vec.new(U8)
                        mut pi := 0
                        while pi.lt(payload_size) {
                            mut byte_val : U8 = 0
                            memcpy(to_ptr(byte_val), g_arena.get(add(payload_offset, pi), 1), 1)
                            payload_bytes.push(byte_val)
                            pi = add(pi, 1)
                        }
                        // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                        heap_vec_ptr := malloc(size_of(Vec))?
                        memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                        result.payload.data = heap_vec_ptr
                        heap_type_ptr := malloc(size_of(ValueType))?
                        memcpy(heap_type_ptr, to_ptr(payload_type), size_of(ValueType))
                        result.payload_type.data = heap_type_ptr
                    }
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum_at_offset: buy more ram")
        }

        return result
    }

    get_payload_size_for_type := func(ctx: Context, vtype: ValueType, offset: I64, e: Expr) returns I64 throws Str {
        switch vtype {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                return 8
            }
            mut type_symbol := ctx.scope_stack.lookup_symbol(type_name)?
            catch (err: KeyNotFoundError) {
                return 0
            }
            switch type_symbol.value_type {
            case ValueType.TType(type_def):
                switch type_def {
                case TTypeDef.TStructDef:
                    return ctx.get_type_size(type_name)?
                case TTypeDef.TEnumDef:
                    // Recursively get the inner enum's size
                    inner_enum := EvalArena.get_enum_at_offset(ctx, type_name, offset, e)?
                    mut total_size := 8  // variant tag
                    if not(NULL.eq(inner_enum.payload.data)) {
                        mut payload_vec := Vec.new(U8)
                        memcpy(to_ptr(payload_vec), inner_enum.payload.data, size_of(Vec))
                        total_size = add(total_size, payload_vec.len())
                    }
                    return total_size
                case:
                    return 0
                }
            case:
                return 0
            }
        case:
            return 0
        }
        return 0
    }

    get_enum := func(ctx: Context, id: Str, e: Expr) returns EnumVal throws Str {
        // For field paths (e.g., "s.color"), get the field's type, not the base struct's type
        mut enum_type := ""
        if id.contains(".") {
            field_type := ctx.get_field_type(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_enum: ", err))
            }
            switch field_type {
            case ValueType.TCustom(type_name):
                enum_type = type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: field '", id, "' is not a custom enum type"))
            }
        } else {
            mut symbol_info := ctx.scope_stack.lookup_symbol(id)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", format("get_enum: Symbol '", id, "' not found"))
            }

            switch symbol_info.value_type {
            case ValueType.TCustom(custom_type_name):
                enum_type = custom_type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: '", id, "' is not a custom enum type"))
            }
        }

        // Try to get offset - first from arena_index, then calculate dynamically for fields
        mut offset := ctx.scope_stack.lookup_var(id)?
        catch (err: KeyNotFoundError) {
            if id.contains(".") {
                // Field path - calculate offset dynamically
                offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    throw e.lang_error(ctx.path, "context", format("get_enum: ", err2))
                }
            } else {
                throw e.lang_error(ctx.path, "context", format("get_enum: EvalArena index for '", id, "' not found"))
            }
        }

        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_arena.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload type
        }
        catch (err: IndexOutOfBoundsError) {
            // Should never happen
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut variant_payload_type := ValueType.TCustom("")
            memcpy(to_ptr(variant_payload_type), payload_ptr.data, size_of(ValueType))
            switch variant_payload_type {
            case ValueType.TCustom(vtype_name):
                // This variant has a payload, read it from arena
                mut payload_size := 0
                if vtype_name.eq("I64") {
                    payload_size = 8
                } else {
                    if vtype_name.eq("Str") {
                        payload_size = 16  // Str is always 16 bytes (pointer + size)
                    } else {
                        // Check if this is a struct or enum type
                        mut type_symbol := ctx.scope_stack.lookup_symbol(vtype_name)?
                        catch (err: KeyNotFoundError) {
                            payload_size = 0
                        }
                        switch type_symbol.value_type {
                        case ValueType.TType(type_def):
                            switch type_def {
                            case TTypeDef.TStructDef:
                                payload_size = ctx.get_type_size(vtype_name)?
                                catch (err: Str) {
                                    payload_size = 0
                                }
                            case TTypeDef.TEnumDef:
                                // For enum payloads, recursively get the enum to determine size
                                inner_enum := EvalArena.get_enum_at_offset(ctx, vtype_name, add(offset, 8), e)?
                                payload_size = 8  // variant tag
                                if not(NULL.eq(inner_enum.payload.data)) {
                                    mut inner_payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(inner_payload_vec), inner_enum.payload.data, size_of(Vec))
                                    payload_size = add(payload_size, inner_payload_vec.len())
                                }
                            case:
                                payload_size = 0
                            }
                        case:
                            payload_size = 0
                        }
                    }
                }

                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_size)
                    if payload_end.lteq(g_arena.len()) {
                        mut payload_bytes := Vec.new(U8)
                        mut pi := 0
                        while pi.lt(payload_size) {
                            mut byte_val : U8 = 0
                            memcpy(to_ptr(byte_val), g_arena.get(add(payload_offset, pi), 1), 1)
                            payload_bytes.push(byte_val)
                            pi = add(pi, 1)
                        }
                        // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                        // (payload_bytes and variant_payload_type are stack-local, their pointers become stale)
                        heap_vec_ptr := malloc(size_of(Vec))?
                        memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                        result.payload.data = heap_vec_ptr
                        heap_type_ptr := malloc(size_of(ValueType))?
                        memcpy(heap_type_ptr, to_ptr(variant_payload_type), size_of(ValueType))
                        result.payload_type.data = heap_type_ptr
                    }
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum: buy more ram")
        }

        return result
    }

    // Core logic for insert_enum - returns EnumInsertResult with optional mapping info
    insert_enum_core := proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumInsertResult throws Str {
        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Enum definition for '", enum_type, "' not found"))
        }

        // Get the last part after the last dot
        parts := pre_normalized_enum_name.split(".")?
        mut enum_name := ""
        if parts.len().gt(0) {
            parts.get(sub(parts.len(), 1), enum_name)?
        }
        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Invalid enum name format '", pre_normalized_enum_name, "'"))
        }

        enum_value := Context.get_variant_pos(enum_def, enum_name, ctx.path, e)?

        // Check if there's payload data to store (dereference Ptr to EnumPayload)
        mut payload_data := Vec.new(U8)
        mut payload_type := ValueType.TCustom("")
        if not(NULL.eq(ctx.temp_enum_payload.data)) {
            mut temp_payload := EnumPayload()
            memcpy(to_ptr(temp_payload), ctx.temp_enum_payload.data, size_of(EnumPayload))
            payload_data = temp_payload.data
            payload_type = temp_payload.value_type
        }

        // Bug #38 fix: Always allocate the maximum enum size to support memcpy of any variant
        max_enum_size := ctx.get_type_size(enum_type)?
        payload_size := payload_data.len()
        actual_size := add(8, payload_size)  // tag + current payload

        mut result := EnumInsertResult()
        result.has_mapping = false

        is_field := id.contains(".")
        if is_field {
            mut have_offset := true
            mut offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                have_offset = false
            }

            if have_offset {
                // Update existing enum value (no new mapping needed)
                g_arena.set(offset, to_ptr(enum_value), 8)
                if payload_data.len().gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_data.len())
                    if g_arena.len().lt(payload_end) {
                        _ := g_arena.reserve(sub(payload_end, g_arena.len()))
                    }
                    mut pi := 0
                    while pi.lt(payload_data.len()) {
                        mut byte_val : U8 = 0
                        payload_data.get(pi, byte_val)?
                        g_arena.set(add(payload_offset, pi), to_ptr(byte_val), 1)
                        pi = add(pi, 1)
                    }
                }
                result.has_mapping = false
            } else {
                // Allocate max enum size, write tag and payload, then zero-pad remaining
                offset = g_arena.put(to_ptr(enum_value), 8)
                if payload_data.len().gt(0) {
                    _ := g_arena.put(payload_data.ptr, payload_data.len())
                }
                // Bug #38 fix: Pad with zeros to reach max_enum_size
                if actual_size.lt(max_enum_size) {
                    _ := g_arena.reserve(sub(max_enum_size, actual_size))
                }
                result.has_mapping = true
                result.mapping_name = id
                result.mapping_offset = offset
            }
        } else {
            // Allocate max enum size, write tag and payload, then zero-pad remaining
            new_enum_offset := g_arena.put(to_ptr(enum_value), 8)
            if payload_data.len().gt(0) {
                _ := g_arena.put(payload_data.ptr, payload_data.len())
            }
            // Bug #38 fix: Pad with zeros to reach max_enum_size
            if actual_size.lt(max_enum_size) {
                _ := g_arena.reserve(sub(max_enum_size, actual_size))
            }
            result.has_mapping = true
            result.mapping_name = id
            result.mapping_offset = new_enum_offset
        }

        // Clear the temp payload after using it (set to NULL Ptr)
        ctx.temp_enum_payload = Ptr()

        result.enum_val.enum_type = enum_type
        result.enum_val.enum_name = enum_name
        // Store payload as Ptr (Option pattern: NULL = None)
        // Note: Must store clone in variable - can't take address of function return value
        if payload_data.len().gt(0) {
            mut cloned_payload := payload_data.clone()
            result.enum_val.payload.data = to_ptr(cloned_payload)
            result.enum_val.payload_type.data = to_ptr(payload_type)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_core", "IndexOutOfBoundsError while processing payload")
        }

        return result
    }

    // TODO Context.insert_enum gets an Expr for errors, any Context method that can throw should too
    insert_enum := proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str {
        result := EvalArena.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?
        if result.has_mapping {
            ctx.scope_stack.insert_var(result.mapping_name, result.mapping_offset)?
        }

        return result.enum_val
    }

    insert_enum_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str {
        // Temporarily push frame so symbol lookups work in core function
        ctx.scope_stack.frames.push(frame)

        result := EvalArena.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?

        // Pop frame back
        ctx.scope_stack.frames.pop(frame)?

        // Now apply result to the frame
        if result.has_mapping {
            frame.arena_index.set(result.mapping_name, result.mapping_offset)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_into_frame", "IndexOutOfBoundsError")
        }

        return result.enum_val
    }

    /** Insert an Array for variadic arguments into a function frame.
     *  Uses insert_struct_into_frame internally. */
    insert_array_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, name: Str, elem_type: Str, values: Vec, e: Expr) throws Str {
        // Create Array struct using template
        mut template_offset := 0
        g_arena.default_instances.get("Array", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "Array template not found - ensure array.til is imported")
        }
        EvalArena.insert_struct_into_frame(ctx, frame, name, "Array", template_offset, e)?

        len := values.len()
        elem_size := ctx.get_type_size(elem_type)?
        total_size := mul(len, elem_size)

        // Allocate memory for elements
        ptr := g_arena.reserve(total_size)

        // Write values into allocated buffer
        mut i := 0
        while i.lt(len) {
            offset := add(ptr, mul(i, elem_size))
            mut val := ""
            values.get(i, val)?

            if Str.eq(elem_type, "U8") {
                byte := U8.from_str(val)?
                g_arena.set(offset, to_ptr(byte), 1)
            } else if Str.eq(elem_type, "I64") {
                n := I64.from_str(val)
                g_arena.set(offset, to_ptr(n), 8)
            } else if Str.eq(elem_type, "Str") {
                // For Str elements, create temp Str and copy bytes to array slot
                temp_id := format(name, "_", I64.to_str(i))
                temp_symbol := SymbolInfo(value_type=ValueType.TCustom("Str"), is_mut=false, is_copy=false, is_own=false)
                frame.symbols.set(temp_id, temp_symbol)

                EvalArena.insert_string_into_frame(ctx, frame, temp_id, val, e)?

                mut str_offset := 0
                frame.arena_index.get(temp_id, str_offset)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("missing Str offset for '", temp_id, "'"))
                }
                g_arena.set(offset, g_arena.get(str_offset, elem_size), elem_size)
            } else {
                // Struct element - val is identifier, copy from source
                mut src_offset := 0
                src_offset = ctx.scope_stack.lookup_var(val)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("struct source '", val, "' not found"))
                }
                g_arena.set(offset, g_arena.get(src_offset, elem_size), elem_size)
            }

            i = add(i, 1)
        }

        // Update Array fields from frame.arena_index
        mut ptr_offset := 0
        frame.arena_index.get(format(name, ".ptr"), ptr_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing '", name, ".ptr'"))
        }
        mut ptr_val := ptr
        g_arena.set(ptr_offset, to_ptr(ptr_val), 8)

        mut len_offset := 0
        frame.arena_index.get(format(name, "._len"), len_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing '", name, "._len'"))
        }
        mut len_val := len
        g_arena.set(len_offset, to_ptr(len_val), 8)

        mut type_size_offset := 0
        frame.arena_index.get(format(name, ".type_size"), type_size_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing '", name, ".type_size'"))
        }
        mut elem_size_val := elem_size
        g_arena.set(type_size_offset, to_ptr(elem_size_val), 8)

        // Set type_name field (it's a Str)
        type_name_field := format(name, ".type_name")
        temp_type_name_id := format(name, "_type_name_temp")
        temp_symbol2 := SymbolInfo(value_type=ValueType.TCustom("Str"), is_mut=false, is_copy=false, is_own=false)
        frame.symbols.set(temp_type_name_id, temp_symbol2)

        EvalArena.insert_string_into_frame(ctx, frame, temp_type_name_id, elem_type, e)?

        mut temp_str_offset := 0
        frame.arena_index.get(temp_type_name_id, temp_str_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", "missing type_name temp Str offset")
        }

        mut type_name_offset := 0
        frame.arena_index.get(type_name_field, type_name_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing '", type_name_field, "'"))
        }

        str_size := ctx.get_type_size("Str")?
        g_arena.set(type_name_offset, g_arena.get(temp_str_offset, str_size), str_size)

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", err.msg)
        }
    }

    /// Convert a struct instance stored in EvalArena to a struct literal Expr.
    /// Given instance "___temp_return_val_0" of type "Bool", produces:
    ///   Bool(data=1)
    /// The `e` parameter is only used for error reporting.
    to_struct_literal := func(ctx: Context, instance_name: Str, type_name: Str, e: Expr) returns Expr throws Str {
        mut struct_def := ctx.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "arena", format("to_struct_literal: struct '", type_name, "' not found"))
        }

        // First param is the type identifier
        type_id := Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), 0, 0)
        mut params := Vec.new(Expr)
        params.push(type_id)

        // For each mutable field, read value and create NamedArg
        for member: Declaration in struct_def.members {
            if not(member.is_mut) {
                continue  // Skip static fields
            }
            field_id := format(instance_name, ".", member.name)
            field_value := EvalArena.field_to_literal(ctx, field_id, member.value_type, e)?

            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(field_value)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, 0, 0)
            params.push(named_arg)
        }

        result := Expr.new_explicit(NodeType.FCall(false), params, 0, 0)


        return result
    }

    /// Helper: read a field value from EvalArena and convert to literal Expr
    field_to_literal := func(ctx: Context, field_id: Str, value_type: ValueType, e: Expr) returns Expr throws Str {
        mut result := Expr()
        switch value_type {
        case ValueType.TCustom(custom_type):
            if custom_type.eq("I64") {
                i64_val := EvalArena.get_i64(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(i64_val.to_str())), Vec.new(Expr), 0, 0)
            } else if custom_type.eq("U8") {
                u8_val := EvalArena.get_u8(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(u8_val.to_str())), Vec.new(Expr), 0, 0)
            } else {
                // Check if nested struct
                mut is_struct := false
                _struct_def := ctx.scope_stack.lookup_struct(custom_type)?
                is_struct = true
                catch (err: KeyNotFoundError) {
                    // Not a struct
                }
                if is_struct {
                    result = EvalArena.to_struct_literal(ctx, field_id, custom_type, e)?
                } else {
                    throw e.lang_error(ctx.path, "arena", format("field_to_literal: unsupported nested type '", custom_type, "'"))
                }
            }
        case:
            throw e.lang_error(ctx.path, "arena", format("field_to_literal: unsupported field type '", value_type_to_str(value_type), "'"))
        }

        return result
    }
}

// Global arena instance
mut g_arena := EvalArena.new()
