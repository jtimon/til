mode liba

import("std.arena")
import("self.init")
import("self.parser")

// EvalArena: Memory management for the TIL interpreter
// Extracted from interpreter.rs to enable incremental translation to TIL.


EvalArenaMapping := struct {
    mut name: Str = ""
    mut offset: I64 = 0
}

SymbolEntry := struct {
    mut name: Str = ""
    mut info: SymbolInfo = SymbolInfo()
}

// Result from insert_struct_core containing mappings to be stored
StructInsertResult := struct {
    mut arena_mappings: Vec = Vec.new(EvalArenaMapping)
    mut symbols: Vec = Vec.new(SymbolEntry)
}

// Result from insert_string_core containing string offset and length
StringInsertInfo := struct {
    mut string_offset: I64 = 0
    mut str_len: I64 = 0
}

// Result from insert_enum_core containing optional mapping and enum value
EnumInsertResult := struct {
    mut has_mapping: Bool = false
    mut mapping_name: Str = ""
    mut mapping_offset: I64 = 0
    mut enum_val: EnumVal = EnumVal()
}

// Bug #133: Structs for extracting heap contents for serialization to static arrays
/// Contents of a Vec for serialization to static C arrays
VecContents := struct {
    mut element_type_name: Str = ""
    mut type_size: I64 = 0
    mut element_bytes: Vec = Vec.new(Vec)  // Vec of Vec<U8>
}

namespace VecContents {
    clone := func(self: VecContents) returns VecContents {
        return VecContents(element_type_name=self.element_type_name.clone(), type_size=self.type_size, element_bytes=self.element_bytes.clone())
    }
}

/// Contents of a Str for serialization
StrContents := struct {
    mut string_data: Str = ""
}

EvalArena := struct {
    mut _arena: Arena = Arena()
    mut temp_id_counter: I64 = 0
    mut default_instances: Map = Map.new(Str, I64)  // type name -> arena offset of default template
    mut _heap_bases: Vec = Vec.new(I64)  // Issue #163: heap block base ptrs
    mut _heap_sizes: Vec = Vec.new(I64)  // Issue #163: heap block sizes
}

namespace EvalArena {
    new := proc() returns EvalArena {
        mut a := EvalArena()
        a._arena = Arena.new()
        return a
    }

    /// Get current used length of arena memory
    len := func(self: EvalArena) returns I64 {
        return self._arena.len()
    }

    /// Get size of arena memory (same as len for EvalArena)
    size := func(self: EvalArena) returns I64 {
        return self._arena.len()
    }

    /// Append bytes to arena, return offset where they were placed
    put := proc(mut self: EvalArena, src_ptr: I64, num_bytes: I64) returns I64 {
        offset := self._arena.put(src_ptr, num_bytes)
        return offset
    }

    /// Read bytes from arena or heap at offset (returns pointer to data)
    get := func(self: EvalArena, offset: I64, num_bytes: I64) returns I64 {
        // Issue #163: Dispatch to heap for heap-allocated memory
        if self.is_in_heap(offset) {
            return offset  // heap pointer IS the raw address
        }
        return self._arena.get(offset, num_bytes)
    }

    /// Write bytes to arena or heap at offset
    set := proc(mut self: EvalArena, offset: I64, src_ptr: I64, num_bytes: I64) {
        // Issue #163: Dispatch to heap for heap-allocated memory
        if self.is_in_heap(offset) {
            memcpy(offset, src_ptr, num_bytes)
            return
        }
        self._arena.set(offset, src_ptr, num_bytes)
    }

    /// Reserve space in arena, return offset where space was allocated
    reserve := proc(mut self: EvalArena, size: I64) returns I64 {
        offset := self._arena.reserve(size)
        return offset
    }

    /// Issue #163: Allocate zeroed memory on the heap, return raw pointer as offset
    heap_alloc := proc(mut self: EvalArena, size: I64) returns I64 throws Str {
        alloc_size := add(size, 0)
        alloc_ptr := malloc(alloc_size)?
        result_ptr := alloc_ptr
        loop_size := alloc_size
        self._heap_bases.push(alloc_ptr)
        self._heap_sizes.push(alloc_size)
        // Zero-initialize (arena's reserve zeroes, so we must too for compatibility)
        mut zero : U8 = 0
        for i in 0..loop_size {
            memcpy(add(result_ptr, i), to_ptr(zero), 1)
        }
        return result_ptr

        catch (err: BadAlloc) {
            throw "heap_alloc: allocation failed"
        }
    }

    /// Issue #163: Free a heap-allocated block
    heap_free := proc(mut self: EvalArena, ptr: I64) {
        for i in 0..self._heap_bases.len() {
            mut base := 0
            self._heap_bases.get(i, base)?
            if base.eq(ptr) {
                self._heap_bases.set(i, 0)?  // mark as freed
                self._heap_sizes.set(i, 0)?
                free(ptr)
                return
            }
        }
        catch (err: IndexOutOfBoundsError) { }
    }

    /// Issue #163: Check if an offset is a heap pointer (not an arena offset).
    /// Uses a simple heuristic: any address > arena length is outside the arena
    /// and must be a heap pointer. This matches the arena's original behavior of
    /// not enforcing per-allocation bounds.
    is_in_heap := func(self: EvalArena, offset: I64) returns Bool {
        return offset.gt(self.len())
    }

    // === EVAL-PHASE MEMORY OPERATIONS ===
    // These methods manage runtime memory allocation and access
    // They take Context as parameter to access type info and arena_index

    // Check if id refers to an instance field (e.g., "myStruct.field") vs a type constant
    // Bug #160: Now checks if ANY prefix of the path exists in arena_index
    // This handles type constants like "MyNamespace.field_static_str.c_string.data"
    // where the base is "MyNamespace.field_static_str", not "MyNamespace"
    /// Check if id refers to an instance field (e.g., "myStruct.field") vs a type constant
    is_instance_field := func(ctx: Context, id: Str) returns Bool {
        if not(id.contains(".")) {
            return false
        }
        parts := id.split(".")?
        mut base := ""
        parts.get(0, base)?
        mut sym := ctx.scope_stack.lookup_symbol(base)?
        switch sym.value_type {
        case ValueType.TType(inner):
            return false
        case:
            return true
        }
        catch (err: KeyNotFoundError) {
            return false
        }
        catch (err: IndexOutOfBoundsError) {
            return false
        }
    }

    get_u8 := func(ctx: Context, id: Str, e: Expr) returns U8 throws Str {
        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants (e.g., Ptr.NULL)
        mut offset := 0
        if EvalArena.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_u8: ", err))
            }
        } else {
            // Variable or type constant - try direct lookup first
            // If not found and path has dots, use get_field_offset (for namespace field subpaths)
            mut found := false
            offset = ctx.scope_stack.lookup_var(id)?
            found = true
            catch (err: KeyNotFoundError) {
                if id.contains(".") {
                    offset = ctx.get_field_offset(id)?
                    found = true
                    catch (err2: Str) {
                        throw e.lang_error(ctx.path, "context", format("get_u8 fallback: ", err2))
                    }
                }
            }
            if not(found) {
                throw e.lang_error(ctx.path, "context", format("u8 not found for id '", id, "'"))
            }
        }

        mut val : U8 = 0
        memcpy(to_ptr(val), g_arena.get(offset, 1), 1)
        return val
    }

    get_i64 := func(ctx: Context, id: Str, e: Expr) returns I64 throws Str {
        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants (e.g., Ptr.NULL)
        mut offset := 0
        if EvalArena.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_i64: ", err))
            }
        } else {
            // Variable or type constant - try direct lookup first
            // If not found and path has dots, use get_field_offset (for namespace field subpaths)
            mut found := false
            offset = ctx.scope_stack.lookup_var(id)?
            found = true
            catch (err: KeyNotFoundError) {
                if id.contains(".") {
                    offset = ctx.get_field_offset(id)?
                    found = true
                    catch (err2: Str) {
                        throw e.lang_error(ctx.path, "context", format("get_i64 fallback: ", err2))
                    }
                }
            }
            if not(found) {
                throw e.lang_error(ctx.path, "context", format("i64 not found for id '", id, "'"))
            }
        }

        mut val : I64 = 0
        memcpy(to_ptr(val), g_arena.get(offset, 8), 8)
        return val
    }

    // Core logic for insert_i64 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_i64_core := func(ctx: Context, id: Str, i64_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError {
        v := I64.from_str(i64_str)
        // Note: I64.from_str currently panics on invalid input, doesn't throw

        if EvalArena.is_instance_field(ctx, id) {
            // Bug #160: Deterministic dispatch - field paths ALWAYS use get_field_offset
            field_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("insert_i64: ", err))
            }

            // Ensure arena has enough space
            required_len := add(field_offset, 8)
            if g_arena.len().lt(required_len) {
                _ := g_arena.reserve(sub(required_len, g_arena.len()))
            }

            g_arena.set(field_offset, to_ptr(v), 8)
            throw KeyNotFoundError(msg="already handled")
        }

        // For non-instance fields (including struct constants like Vec.INIT_CAP), create new entry
        offset := g_arena.put(to_ptr(v), 8)
        return offset
    }

    insert_i64 := proc(mut ctx: Context, id: Str, i64_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_i64_core(ctx, id, i64_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_i64_into_frame := proc(ctx: Context, mut frame: ScopeFrame, id: Str, i64_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_i64_core(ctx, id, i64_str, e)?
        frame.arena_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // Core logic for insert_u8 - returns offset if caller needs to store it, throws KeyNotFoundError if already handled
    insert_u8_core := func(ctx: Context, id: Str, u8_str: Str, e: Expr) returns I64 throws Str, KeyNotFoundError {
        v := U8.from_str(u8_str)?
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        if EvalArena.is_instance_field(ctx, id) {
            // Bug #160: Deterministic dispatch - field paths ALWAYS use get_field_offset
            field_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("insert_u8: ", err))
            }
            g_arena.set(field_offset, to_ptr(v), 1)
            throw KeyNotFoundError(msg="already handled")
        }

        offset := g_arena.put(to_ptr(v), 1)
        return offset
    }

    insert_u8 := proc(mut ctx: Context, id: Str, u8_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_u8_core(ctx, id, u8_str, e)?
        ctx.scope_stack.insert_var(id, offset)?
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    insert_u8_into_frame := proc(ctx: Context, mut frame: ScopeFrame, id: Str, u8_str: Str, e: Expr) throws Str {
        offset := EvalArena.insert_u8_core(ctx, id, u8_str, e)?
        frame.arena_index.set(id, offset)
        catch (err: KeyNotFoundError) {
            // Already handled, nothing to store
        }
    }

    // Core logic for insert_struct - does all the work but returns mappings instead of inserting them
    // existing_offset: -1 means None (allocate new), >= 0 means use that offset
    insert_struct_core := proc(mut ctx: Context, id: Str, custom_type_name: Str, existing_offset: I64, defaults: Map, e: Expr) returns StructInsertResult throws Str {
        mut result := StructInsertResult()

        // Lookup the struct definition
        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: definition for '", custom_type_name, "' not found"))
        }

        // Determine mutability from symbols table
        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct: id '", id, "' for struct '", custom_type_name, "' not found in symbols"))
        }
        is_mut := sym.is_mut

        // Calculate total size (for now no alignment)
        mut total_size := 0
        mut field_offsets := Map.new(Str, I64)

        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "context", "insert_struct: Unsupported value type in struct")
                }

                field_offsets.set(decl.name, total_size)
                total_size = add(total_size, field_size)
            }
        }

        // Either use existing offset (for nested structs) or allocate new memory
        mut offset := existing_offset
        if existing_offset.lt(0) {
            offset = g_arena.reserve(total_size)
        }
        mut base_mapping := EvalArenaMapping()
        base_mapping.name = id
        base_mapping.offset = offset
        result.arena_mappings.push(base_mapping)

        // Temporarily register base var so get_field_offset works during field initialization
        ctx.scope_stack.insert_var(id, offset)?
        ctx.scope_stack.declare_symbol(id, SymbolInfo(value_type=ValueType.TCustom(custom_type_name), is_mut=true))?

        // Store each field's default value
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_offset := 0
                field_offsets.get(decl.name, field_offset)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing field offset for '", decl.name, "'"))
                }

                mut default_value := ""
                defaults.get(decl.name, default_value)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Missing pre-evaluated default for field '", decl.name, "'"))
                }

                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Check if it's an enum
                    mut is_enum := true
                    mut enum_def := ctx.scope_stack.lookup_enum(type_name)?
                    catch (err: KeyNotFoundError) {
                        is_enum = false
                    }

                    if is_enum {
                        parts := default_value.split(".")?
                        if not(parts.len().eq(2)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        mut part0 := ""
                        parts.get(0, part0)?
                        if not(part0.eq(type_name)) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Invalid enum default value '", default_value, "' for field '", decl.name, "'"))
                        }
                        mut variant := ""
                        parts.get(1, variant)?
                        // Find variant index - Bug #38 fix: use variants Vec
                        mut index : I64 = 0
                        mut found_variant := false
                        mut vi := 0
                        while vi.lt(enum_def.variants.len()) {
                            mut ev := EnumVariant()
                            enum_def.variants.get(vi, ev)?
                            if ev.name.eq(variant) {
                                index = vi
                                found_variant = true
                            }
                            vi = add(vi, 1)
                        }
                        if not(found_variant) {
                            throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown enum variant '", variant, "' for field '", decl.name, "'"))
                        }
                        g_arena.set(add(offset, field_offset), to_ptr(index), 8)
                    } else {
                        if type_name.eq("U8") {
                            u8_val := U8.from_str(default_value)?
                            // Note: U8.from_str panics on invalid input, doesn't throw
                            mut dest_u8 : U8 = u8_val
                            g_arena.set(add(offset, field_offset), to_ptr(dest_u8), 1)
                        } else {
                            if type_name.eq("I64") {
                                i64_val := I64.from_str(default_value)
                                // Note: I64.from_str panics on invalid input, doesn't throw
                                g_arena.set(add(offset, field_offset), to_ptr(i64_val), 8)
                            } else if ctx.scope_stack.has_struct(type_name) {
                                // It's a struct
                                nested_combined_name := format(id, ".", decl.name)
                                nested_symbol := SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true)
                                // Must declare symbol BEFORE recursive call (needed for is_mut lookup)
                                ctx.scope_stack.declare_symbol(nested_combined_name, nested_symbol)?
                                mut sym_entry := SymbolEntry()
                                sym_entry.name = nested_combined_name
                                sym_entry.info = nested_symbol
                                result.symbols.push(sym_entry)

                                // Special case: Str field initialization
                                if type_name.eq("Str") {
                                    // Register inline offset BEFORE insert_string so it writes to the inline space
                                    str_field_offset := add(offset, field_offset)
                                    mut str_mapping := EvalArenaMapping()
                                    str_mapping.name = nested_combined_name
                                    str_mapping.offset = str_field_offset
                                    result.arena_mappings.push(str_mapping)
                                    EvalArena.insert_string(ctx, nested_combined_name, default_value, e)?
                                } else {
                                    // Use existing offset for nested struct (inline allocation)
                                    nested_field_offset := add(offset, field_offset)
                                    mut nested_mapping := EvalArenaMapping()
                                    nested_mapping.name = nested_combined_name
                                    nested_mapping.offset = nested_field_offset
                                    result.arena_mappings.push(nested_mapping)
                                    // Extract nested defaults (field.subfield -> subfield)
                                    prefix := format(decl.name, ".")
                                    mut nested_defaults := Map.new(Str, Str)
                                    default_keys := defaults.keys
                                    for dk: Str in default_keys {
                                        if dk.starts_with(prefix) {
                                            rest := dk.strip_prefix(prefix)
                                            mut dv := ""
                                            defaults.get(dk, dv)?
                                            catch (err: KeyNotFoundError) {
                                                panic(loc(), "insert_struct_core: key not found in defaults")
                                            }
                                            nested_defaults.set(rest, dv)
                                        }
                                    }
                                    nested_result := EvalArena.insert_struct_core(ctx, nested_combined_name, type_name, nested_field_offset, nested_defaults, e)?
                                    catch (err: Str) {
                                        throw e.lang_error(ctx.path, "context", format("insert_struct: Failed to initialize nested struct '", id, ".", decl.name, "'"))
                                    }
                                    // Collect nested mappings
                                    result.arena_mappings.extend(nested_result.arena_mappings)
                                    result.symbols.extend(nested_result.symbols)
                                }
                            } else {
                                throw e.lang_error(ctx.path, "context", format("insert_struct: Unknown field type '", type_name, "'"))
                            }
                        }
                    }
                case:
                    throw e.lang_error(ctx.path, "context", format("insert_struct: Unsupported field value type '", value_type_to_str(decl.value_type), "'"))
                }

                // Bug #160: Removed field arena_mappings.push - offsets are now calculated dynamically
                // Symbol still needed for type checking
                combined_name := format(id, ".", decl.name)
                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)
            }
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_struct_core: ", err.msg))
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "context", err.msg)
        }

        // Remove temp registration (caller will apply the final mappings)
        _ := ctx.scope_stack.remove_var(id)?
        _ := ctx.scope_stack.remove_symbol(id)?

        return result
    }

    // Generate arena mappings and symbols for a struct without writing bytes.
    // Used for template-based insertion where bytes are already memcpy'd.
    generate_struct_mappings := proc(mut ctx: Context, id: Str, custom_type_name: Str, base_offset: I64, e: Expr) returns StructInsertResult throws Str {
        mut result := StructInsertResult()

        mut struct_def := ctx.scope_stack.lookup_struct(custom_type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("struct '", custom_type_name, "' not found"))
        }

        mut sym := ctx.scope_stack.lookup_symbol(id)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "generate_struct_mappings", format("symbol '", id, "' not found"))
        }
        is_mut := sym.is_mut

        // Calculate field offsets (same as insert_struct_core)
        mut current_offset := 0
        mut field_offsets := Map.new(Str, I64)
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "generate_struct_mappings", "Unsupported value type")
                }
                field_offsets.set(decl.name, current_offset)
                current_offset = add(current_offset, field_size)
            }
        }

        // Add base struct mapping
        mut base_mapping := EvalArenaMapping()
        base_mapping.name = id
        base_mapping.offset = base_offset
        result.arena_mappings.push(base_mapping)

        // Generate symbols for each field (Bug #160: no longer generate field arena mappings)
        for decl: Declaration in struct_def.members {
            if decl.is_mut {
                mut field_rel_offset := 0
                field_offsets.get(decl.name, field_rel_offset)?
                catch (err: KeyNotFoundError) {
                    field_rel_offset = 0
                }
                field_abs_offset := add(base_offset, field_rel_offset)
                combined_name := format(id, ".", decl.name)

                // Bug #160: Removed arena_mappings.push - offsets are now calculated dynamically
                mut field_sym := SymbolEntry()
                field_sym.name = combined_name
                field_sym.info = SymbolInfo(value_type=decl.value_type, is_mut=is_mut)
                result.symbols.push(field_sym)

                // Handle nested structs recursively
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if not(type_name.eq("U8")) {
                        if not(type_name.eq("I64")) {
                            if ctx.scope_stack.has_struct(type_name) {
                                // Declare nested symbol first
                                ctx.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=ValueType.TCustom(type_name), is_mut=true))?
                                nested := EvalArena.generate_struct_mappings(ctx, combined_name, type_name, field_abs_offset, e)?
                                result.symbols.extend(nested.symbols)
                            }
                        }
                    }
                case:
                }
            }
        }

        return result
    }

    // Insert a struct by copying from a cached template.
    // Much faster than insert_struct_core for subsequent instances of the same type.
    insert_struct := proc(mut ctx: Context, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the arena's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_arena.get(template_offset, struct_size), struct_size)

        // Allocate new memory (may reallocate arena)
        new_offset := g_arena.reserve(struct_size)

        // Copy from temporary buffer to new location
        g_arena.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Generate and apply mappings
        result := EvalArena.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?
        for m: EvalArenaMapping in result.arena_mappings {
            ctx.scope_stack.insert_var(m.name, m.offset)?
        }
        for s: SymbolEntry in result.symbols {
            ctx.scope_stack.declare_symbol(s.name, s.info)?
        }

        catch (err: BadAlloc) {
            panic(loc(), "insert_struct: buy more ram")
        }
    }

    // Insert a struct from template into a specific frame (for function parameters).
    insert_struct_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, custom_type_name: Str, template_offset: I64, e: Expr) throws Str {
        // Get struct size
        struct_size := ctx.get_type_size(custom_type_name)?

        // CRITICAL: Copy template data BEFORE reserve() - reserve may reallocate
        // the arena's backing Vec, invalidating any pointers from get()
        tmp_buf := malloc(struct_size)?
        memcpy(tmp_buf, g_arena.get(template_offset, struct_size), struct_size)

        // Allocate new memory (may reallocate arena)
        new_offset := g_arena.reserve(struct_size)

        // Copy from temporary buffer to new location
        g_arena.set(new_offset, tmp_buf, struct_size)
        free(tmp_buf)

        // Temporarily push frame for generate_struct_mappings
        ctx.scope_stack.frames.push(frame.clone())

        result := EvalArena.generate_struct_mappings(ctx, id, custom_type_name, new_offset, e)?

        // Pop frame back
        mut popped_frame := ScopeFrame()
        ctx.scope_stack.frames.pop(popped_frame)?
        frame = popped_frame

        for m: EvalArenaMapping in result.arena_mappings {
            frame.arena_index.set(m.name, m.offset)
        }
        for s: SymbolEntry in result.symbols {
            frame.symbols.set(s.name, s.info)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_struct_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: BadAlloc) {
            panic(loc(), "insert_struct_into_frame: buy more ram")
        }
    }

    // Core logic for insert_string - returns StringInsertInfo if caller needs to create struct, throws KeyNotFoundError if already handled
    insert_string_core := proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) returns StringInsertInfo throws Str, KeyNotFoundError {
        is_field := EvalArena.is_instance_field(ctx, id)

        // Allocate string data
        string_offset := g_arena.put(value_str.c_string.data, value_str.len())
        mut null_byte : U8 = 0
        _ := g_arena.put(to_ptr(null_byte), 1)  // null terminator
        str_len := value_str.len()

        if is_field {
            mut have_base_offset := true
            mut base_offset := ctx.get_field_offset(id)?
            catch (err: Str) {
                have_base_offset = false
            }

            if have_base_offset {
                mut existing_str_def := ctx.scope_stack.lookup_struct("Str")?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "context", "ERROR: 'Str' struct definition not found")
                }

                mut existing_offset := 0
                for existing_decl: Declaration in existing_str_def.members {
                    if existing_decl.is_mut {
                        existing_type_size := ctx.get_type_size(value_type_to_str(existing_decl.value_type))?
                        absolute_offset := add(base_offset, existing_offset)

                        if existing_decl.name.eq("c_string") {
                            g_arena.set(absolute_offset, to_ptr(string_offset), 8)
                        } else {
                            if existing_decl.name.eq("_len") {
                                g_arena.set(absolute_offset, to_ptr(str_len), 8)
                            }
                        }

                        existing_offset = add(existing_offset, existing_type_size)
                    }
                }
                throw KeyNotFoundError(msg="already handled")
            }

            // Not yet inserted - insert fresh inlined Str
            mut str_def := ctx.scope_stack.lookup_struct("Str")?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", "'Str' struct definition not found")
            }

            struct_offset := g_arena.len()
            mut current_offset := 0

            for decl: Declaration in str_def.members {
                if decl.is_mut {
                    type_size := ctx.get_type_size(value_type_to_str(decl.value_type))?
                    // Ensure space
                    required_len := add(add(struct_offset, current_offset), type_size)
                    if g_arena.len().lt(required_len) {
                        _ := g_arena.reserve(sub(required_len, g_arena.len()))
                    }

                    field_offset := add(struct_offset, current_offset)
                    if decl.name.eq("c_string") {
                        g_arena.set(field_offset, to_ptr(string_offset), 8)
                    } else {
                        if decl.name.eq("_len") {
                            g_arena.set(field_offset, to_ptr(str_len), 8)
                        }
                    }

                    current_offset = add(current_offset, type_size)
                }
            }

            ctx.scope_stack.insert_var(id, struct_offset)?
            throw KeyNotFoundError(msg="already handled")
        }

        mut result := StringInsertInfo()
        result.string_offset = string_offset
        result.str_len = str_len

        return result
    }

    insert_string := proc(mut ctx: Context, id: Str, value_str: Str, e: Expr) throws Str {
        info := EvalArena.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        mut template_offset := 0
        g_arena.default_instances.get("Str", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string", "Str template not found - ensure str.til is imported")
        }
        EvalArena.insert_struct(ctx, id, "Str", template_offset, e)?
        // Bug #160: Use get_field_offset instead of lookup_var for field paths
        c_string_offset := ctx.get_field_offset(format(id, ".c_string"))?
        catch (err: Str) {
            throw e.lang_error(ctx.path, "insert_string", format("missing '", id, ".c_string': ", err))
        }
        len_offset := ctx.get_field_offset(format(id, "._len"))?
        catch (err: Str) {
            throw e.lang_error(ctx.path, "insert_string", format("missing '", id, "._len': ", err))
        }
        g_arena.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_arena.set(len_offset, to_ptr(info.str_len), 8)

    }

    insert_string_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, value_str: Str, e: Expr) throws Str {
        info := EvalArena.insert_string_core(ctx, id, value_str, e)?
        catch (err: KeyNotFoundError) {
            return
        }
        // Create Str struct from template
        mut template_offset := 0
        g_arena.default_instances.get("Str", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", "Str template not found - ensure str.til is imported")
        }
        EvalArena.insert_struct_into_frame(ctx, frame, id, "Str", template_offset, e)?
        // Bug #160: Calculate field offsets from base offset in frame
        // The base struct was just inserted into frame.arena_index
        mut base_offset := 0
        frame.arena_index.get(id, base_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", format("missing '", id, "' in frame"))
        }
        // Str layout: c_string (Ptr), _len (I64), cap (I64)
        // Get field offsets from struct definition
        mut str_def := ctx.scope_stack.lookup_struct("Str")?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_string_into_frame", "Str struct not found")
        }
        mut c_string_rel_offset := 0
        mut len_rel_offset := 0
        mut current_offset := 0
        for decl: Declaration in str_def.members {
            if decl.is_mut {
                if decl.name.eq("c_string") {
                    c_string_rel_offset = current_offset
                } else if decl.name.eq("_len") {
                    len_rel_offset = current_offset
                }
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    field_size = ctx.get_type_size(type_name)?
                case:
                    throw e.lang_error(ctx.path, "insert_string_into_frame", "unexpected field type")
                }
                current_offset = add(current_offset, field_size)
            }
        }
        c_string_offset := add(base_offset, c_string_rel_offset)
        len_offset := add(base_offset, len_rel_offset)
        g_arena.set(c_string_offset, to_ptr(info.string_offset), 8)
        g_arena.set(len_offset, to_ptr(info.str_len), 8)
    }

    // Helper function to insert primitive types (I64, U8, Str) based on value_type
    insert_primitive := proc(mut ctx: Context, var_name: Str, value_type: ValueType, value: Str, e: Expr) throws Str {
        switch value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                EvalArena.insert_i64(ctx, var_name, value, e)?
            } else {
                if type_name.eq("U8") {
                    EvalArena.insert_u8(ctx, var_name, value, e)?
                } else {
                    if type_name.eq("Str") {
                        EvalArena.insert_string(ctx, var_name, value, e)?
                    } else {
                        throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
                    }
                }
            }
        case:
            throw e.lang_error(ctx.path, "eval", format("insert_primitive: Unsupported type ", value_type_to_str(value_type)))
        }
    }

    get_enum_at_offset := func(ctx: Context, enum_type: Str, offset: I64, e: Expr) returns EnumVal throws Str {
        // Read enum from a specific offset (used for nested enum payloads)
        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_arena.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum_at_offset: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload
        }
        catch (err: IndexOutOfBoundsError) {
            // Should never happen
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut payload_type := ValueType.TCustom("")
            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
            switch payload_type {
            case ValueType.TCustom(inner_type):
                // This variant has a payload - recursively determine size
                payload_size := EvalArena.get_payload_size_for_type(ctx, payload_type, add(offset, 8), e)?
                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_size)
                    // Issue #163: Skip arena bounds check for heap pointers
                    if g_arena.is_in_heap(payload_offset).or(payload_end.lteq(g_arena.len())) {
                        // Copy payload bytes
                        mut payload_bytes := Vec.new(U8)
                        mut pi := 0
                        while pi.lt(payload_size) {
                            mut byte_val : U8 = 0
                            memcpy(to_ptr(byte_val), g_arena.get(add(payload_offset, pi), 1), 1)
                            payload_bytes.push(byte_val)
                            pi = add(pi, 1)
                        }
                        // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                        heap_vec_ptr := malloc(size_of(Vec))?
                        memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                        result.payload.data = heap_vec_ptr
                        heap_type_ptr := malloc(size_of(ValueType))?
                        memcpy(heap_type_ptr, to_ptr(payload_type), size_of(ValueType))
                        result.payload_type.data = heap_type_ptr
                    }
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum_at_offset: buy more ram")
        }

        return result
    }

    get_payload_size_for_type := func(ctx: Context, vtype: ValueType, offset: I64, e: Expr) returns I64 throws Str {
        switch vtype {
        case ValueType.TCustom(type_name):
            if type_name.eq("I64") {
                return 8
            }
            mut type_symbol := ctx.scope_stack.lookup_symbol(type_name)?
            catch (err: KeyNotFoundError) {
                return 0
            }
            switch type_symbol.value_type {
            case ValueType.TType(type_def):
                switch type_def {
                case TTypeDef.TStructDef:
                    return ctx.get_type_size(type_name)?
                case TTypeDef.TEnumDef:
                    // Recursively get the inner enum's size
                    inner_enum := EvalArena.get_enum_at_offset(ctx, type_name, offset, e)?
                    mut total_size := 8  // variant tag
                    if not(NULL.eq(inner_enum.payload.data)) {
                        mut payload_vec := Vec.new(U8)
                        memcpy(to_ptr(payload_vec), inner_enum.payload.data, size_of(Vec))
                        total_size = add(total_size, payload_vec.len())
                    }
                    return total_size
                case:
                    return 0
                }
            case:
                return 0
            }
        case:
            return 0
        }
        return 0
    }

    get_enum := func(ctx: Context, id: Str, e: Expr) returns EnumVal throws Str {
        // For field paths (e.g., "s.color"), get the field's type, not the base struct's type
        mut enum_type := ""
        if id.contains(".") {
            field_type := ctx.get_field_type(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_enum: ", err))
            }
            switch field_type {
            case ValueType.TCustom(type_name):
                enum_type = type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: field '", id, "' is not a custom enum type"))
            }
        } else {
            mut symbol_info := ctx.scope_stack.lookup_symbol(id)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", format("get_enum: Symbol '", id, "' not found"))
            }

            switch symbol_info.value_type {
            case ValueType.TCustom(custom_type_name):
                enum_type = custom_type_name
            case:
                throw e.lang_error(ctx.path, "context", format("get_enum: '", id, "' is not a custom enum type"))
            }
        }

        // Bug #160: Deterministic dispatch based on identifier structure
        // Use is_instance_field to distinguish field paths from type constants
        mut offset := 0
        if EvalArena.is_instance_field(ctx, id) {
            // Instance field path - ALWAYS calculate offset dynamically
            offset = ctx.get_field_offset(id)?
            catch (err: Str) {
                throw e.lang_error(ctx.path, "context", format("get_enum: ", err))
            }
        } else {
            // Variable or type constant - ALWAYS direct lookup
            offset = ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(ctx.path, "context", format("get_enum: EvalArena index for '", id, "' not found"))
            }
        }

        mut enum_value : I64 = 0
        memcpy(to_ptr(enum_value), g_arena.get(offset, 8), 8)

        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("get_enum: Enum definition for '", enum_type, "' not found"))
        }

        enum_name := Context.variant_pos_to_str(enum_def, enum_value, ctx.path, e)?

        // Check if this variant has a payload type (Ptr to ValueType, NULL = None)
        // Bug #38 fix: use helper method
        mut payload_ptr := enum_def.get(enum_name)?
        catch (err: KeyNotFoundError) {
            // No payload type
        }
        catch (err: IndexOutOfBoundsError) {
            // Should never happen
        }

        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name

        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut variant_payload_type := ValueType.TCustom("")
            memcpy(to_ptr(variant_payload_type), payload_ptr.data, size_of(ValueType))
            switch variant_payload_type {
            case ValueType.TCustom(vtype_name):
                // This variant has a payload, read it from arena
                mut payload_size := 0
                if vtype_name.eq("I64") {
                    payload_size = 8
                } else {
                    if vtype_name.eq("Str") {
                        payload_size = ctx.get_type_size("Str")?
                    } else {
                        // Check if this is a struct or enum type
                        mut type_symbol := ctx.scope_stack.lookup_symbol(vtype_name)?
                        catch (err: KeyNotFoundError) {
                            payload_size = 0
                        }
                        switch type_symbol.value_type {
                        case ValueType.TType(type_def):
                            switch type_def {
                            case TTypeDef.TStructDef:
                                payload_size = ctx.get_type_size(vtype_name)?
                                catch (err: Str) {
                                    payload_size = 0
                                }
                            case TTypeDef.TEnumDef:
                                // For enum payloads, recursively get the enum to determine size
                                inner_enum := EvalArena.get_enum_at_offset(ctx, vtype_name, add(offset, 8), e)?
                                payload_size = 8  // variant tag
                                if not(NULL.eq(inner_enum.payload.data)) {
                                    mut inner_payload_vec := Vec.new(U8)
                                    memcpy(to_ptr(inner_payload_vec), inner_enum.payload.data, size_of(Vec))
                                    payload_size = add(payload_size, inner_payload_vec.len())
                                }
                            case:
                                payload_size = 0
                            }
                        case:
                            payload_size = 0
                        }
                    }
                }

                if payload_size.gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_size)
                    // Issue #163: Skip arena bounds check for heap pointers
                    if g_arena.is_in_heap(payload_offset).or(payload_end.lteq(g_arena.len())) {
                        mut payload_bytes := Vec.new(U8)
                        mut pi := 0
                        while pi.lt(payload_size) {
                            mut byte_val : U8 = 0
                            memcpy(to_ptr(byte_val), g_arena.get(add(payload_offset, pi), 1), 1)
                            payload_bytes.push(byte_val)
                            pi = add(pi, 1)
                        }
                        // Bug #72 fix: Heap-allocate Vec and ValueType structs so they survive function return
                        // (payload_bytes and variant_payload_type are stack-local, their pointers become stale)
                        heap_vec_ptr := malloc(size_of(Vec))?
                        memcpy(heap_vec_ptr, to_ptr(payload_bytes), size_of(Vec))
                        result.payload.data = heap_vec_ptr
                        heap_type_ptr := malloc(size_of(ValueType))?
                        memcpy(heap_type_ptr, to_ptr(variant_payload_type), size_of(ValueType))
                        result.payload_type.data = heap_type_ptr
                    }
                }
            case:
            }
        }

        catch (err: BadAlloc) {
            panic(loc(), "get_enum: buy more ram")
        }

        return result
    }

    // Core logic for insert_enum - returns EnumInsertResult with optional mapping info
    insert_enum_core := proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumInsertResult throws Str {
        mut enum_def := ctx.scope_stack.lookup_enum(enum_type)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Enum definition for '", enum_type, "' not found"))
        }

        // Get the last part after the last dot
        parts := pre_normalized_enum_name.split(".")?
        mut enum_name := ""
        if parts.len().gt(0) {
            parts.get(sub(parts.len(), 1), enum_name)?
        }
        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "context", format("insert_enum: Invalid enum name format '", pre_normalized_enum_name, "'"))
        }

        enum_value := Context.get_variant_pos(enum_def, enum_name, ctx.path, e)?

        // Check if there's payload data to store (dereference Ptr to EnumPayload)
        mut payload_data := Vec.new(U8)
        mut payload_type := ValueType.TCustom("")
        if not(NULL.eq(ctx.temp_enum_payload.data)) {
            mut temp_payload := EnumPayload()
            memcpy(to_ptr(temp_payload), ctx.temp_enum_payload.data, size_of(EnumPayload))
            payload_data = temp_payload.data
            payload_type = temp_payload.value_type
        }

        // Bug #38 fix: Always allocate the maximum enum size to support memcpy of any variant
        max_enum_size := ctx.get_type_size(enum_type)?
        payload_size := payload_data.len()
        actual_size := add(8, payload_size)  // tag + current payload

        mut result := EnumInsertResult()
        result.has_mapping = false

        is_field := id.contains(".")
        if is_field {
            // Bug #160 fix: Try lookup_var first, then get_field_offset
            mut have_offset := true
            mut offset := ctx.scope_stack.lookup_var(id)?
            catch (err: KeyNotFoundError) {
                // Field path not in arena_index - calculate from struct definition
                offset = ctx.get_field_offset(id)?
                catch (err2: Str) {
                    have_offset = false
                }
            }

            if have_offset {
                // Update existing enum value (no new mapping needed)
                g_arena.set(offset, to_ptr(enum_value), 8)
                if payload_data.len().gt(0) {
                    payload_offset := add(offset, 8)
                    payload_end := add(payload_offset, payload_data.len())
                    // Issue #163: Only grow arena for non-heap offsets
                    if not(g_arena.is_in_heap(payload_offset)).and(g_arena.len().lt(payload_end)) {
                        _ := g_arena.reserve(sub(payload_end, g_arena.len()))
                    }
                    mut pi := 0
                    while pi.lt(payload_data.len()) {
                        mut byte_val : U8 = 0
                        payload_data.get(pi, byte_val)?
                        g_arena.set(add(payload_offset, pi), to_ptr(byte_val), 1)
                        pi = add(pi, 1)
                    }
                }
                result.has_mapping = false
            } else {
                // Allocate max enum size, write tag and payload, then zero-pad remaining
                offset = g_arena.put(to_ptr(enum_value), 8)
                if payload_data.len().gt(0) {
                    _ := g_arena.put(payload_data.ptr.data, payload_data.len())
                }
                // Bug #38 fix: Pad with zeros to reach max_enum_size
                if actual_size.lt(max_enum_size) {
                    _ := g_arena.reserve(max_enum_size.sub(actual_size))
                }
                result.has_mapping = true
                result.mapping_name = id
                result.mapping_offset = offset
            }
        } else {
            // Allocate max enum size, write tag and payload, then zero-pad remaining
            new_enum_offset := g_arena.put(to_ptr(enum_value), 8)
            if payload_data.len().gt(0) {
                _ := g_arena.put(payload_data.ptr.data, payload_data.len())
            }
            // Bug #38 fix: Pad with zeros to reach max_enum_size
            if actual_size.lt(max_enum_size) {
                _ := g_arena.reserve(max_enum_size.sub(actual_size))
            }
            result.has_mapping = true
            result.mapping_name = id
            result.mapping_offset = new_enum_offset
        }

        // Clear the temp payload after using it (set to NULL Ptr)
        ctx.temp_enum_payload = Ptr()

        result.enum_val.enum_type = enum_type
        result.enum_val.enum_name = enum_name
        // Store payload as Ptr (Option pattern: NULL = None)
        // Note: Must store clone in variable - can't take address of function return value
        if payload_data.len().gt(0) {
            mut cloned_payload := payload_data.clone()
            result.enum_val.payload.data = to_ptr(cloned_payload)
            result.enum_val.payload_type.data = to_ptr(payload_type)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_core", "IndexOutOfBoundsError while processing payload")
        }

        return result
    }

    // TODO Context.insert_enum gets an Expr for errors, any Context method that can throw should too
    insert_enum := proc(mut ctx: Context, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str {
        result := EvalArena.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?
        if result.has_mapping {
            ctx.scope_stack.insert_var(result.mapping_name, result.mapping_offset)?
        }

        return result.enum_val
    }

    insert_enum_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, id: Str, enum_type: Str, pre_normalized_enum_name: Str, e: Expr) returns EnumVal throws Str {
        // Temporarily push frame so symbol lookups work in core function
        ctx.scope_stack.frames.push(frame.clone())

        result := EvalArena.insert_enum_core(ctx, id, enum_type, pre_normalized_enum_name, e)?

        // Pop frame back
        ctx.scope_stack.frames.pop(frame)?

        // Now apply result to the frame
        if result.has_mapping {
            frame.arena_index.set(result.mapping_name, result.mapping_offset)
        }

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_enum_into_frame", "IndexOutOfBoundsError")
        }

        return result.enum_val
    }

    /** Insert an Array for variadic arguments into a function frame.
     *  Uses insert_struct_into_frame internally. */
    insert_array_into_frame := proc(mut ctx: Context, mut frame: ScopeFrame, name: Str, elem_type: Str, values: Vec, e: Expr) throws Str {
        // Create Array struct using template
        mut template_offset := 0
        g_arena.default_instances.get("Array", template_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "Array template not found - ensure array.til is imported")
        }
        EvalArena.insert_struct_into_frame(ctx, frame, name, "Array", template_offset, e)?

        len := values.len()
        elem_size := ctx.get_type_size(elem_type)?
        total_size := mul(len, elem_size)

        // Allocate memory for elements
        ptr := g_arena.reserve(total_size)

        // Write values into allocated buffer
        mut i := 0
        while i.lt(len) {
            offset := add(ptr, mul(i, elem_size))
            mut val := ""
            values.get(i, val)?

            if Str.eq(elem_type, "U8") {
                byte := U8.from_str(val)?
                g_arena.set(offset, to_ptr(byte), 1)
            } else if Str.eq(elem_type, "I64") {
                n := I64.from_str(val)
                g_arena.set(offset, to_ptr(n), 8)
            } else if Str.eq(elem_type, "Str") {
                // For Str elements, create temp Str and copy bytes to array slot
                temp_id := format(name, "_", I64.to_str(i))
                temp_symbol := SymbolInfo(value_type=ValueType.TCustom("Str"), is_mut=false, is_copy=false, is_own=false)
                frame.symbols.set(temp_id.clone(), temp_symbol)

                EvalArena.insert_string_into_frame(ctx, frame, temp_id, val, e)?

                mut str_offset := 0
                frame.arena_index.get(temp_id, str_offset)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("missing Str offset for '", temp_id, "'"))
                }
                g_arena.set(offset, g_arena.get(str_offset, elem_size), elem_size)
            } else {
                // Struct element - val is identifier, copy from source
                mut src_offset := 0
                src_offset = ctx.scope_stack.lookup_var(val)?
                catch (err: KeyNotFoundError) {
                    throw e.lang_error(ctx.path, "insert_array", format("struct source '", val, "' not found"))
                }
                g_arena.set(offset, g_arena.get(src_offset, elem_size), elem_size)
            }

            i = add(i, 1)
        }

        // Bug #160: Calculate field offsets from base offset in frame
        mut base_offset := 0
        frame.arena_index.get(name, base_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", format("missing base offset for '", name, "'"))
        }
        mut array_def := ctx.scope_stack.lookup_struct("Array")?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", "Array struct definition not found")
        }

        // Calculate relative offsets for each field
        mut type_name_rel_offset := 0
        mut type_size_rel_offset := 0
        mut ptr_rel_offset := 0
        mut len_rel_offset := 0
        mut current_field_offset := 0
        for decl: Declaration in array_def.members {
            if decl.is_mut {
                mut field_size := 0
                switch decl.value_type {
                case ValueType.TCustom(t):
                    field_size = ctx.get_type_size(t)?
                case:
                    throw e.lang_error(ctx.path, "insert_array", "unsupported field type")
                }
                if Str.eq(decl.name, "type_name") {
                    type_name_rel_offset = current_field_offset
                } else if Str.eq(decl.name, "type_size") {
                    type_size_rel_offset = current_field_offset
                } else if Str.eq(decl.name, "ptr") {
                    ptr_rel_offset = current_field_offset
                } else if Str.eq(decl.name, "_len") {
                    len_rel_offset = current_field_offset
                }
                current_field_offset = add(current_field_offset, field_size)
            }
        }

        // Update Array fields using calculated offsets
        ptr_offset := add(base_offset, ptr_rel_offset)
        mut ptr_val := ptr
        g_arena.set(ptr_offset, to_ptr(ptr_val), 8)

        len_offset := add(base_offset, len_rel_offset)
        mut len_val := len
        g_arena.set(len_offset, to_ptr(len_val), 8)

        type_size_offset := add(base_offset, type_size_rel_offset)
        mut elem_size_val := elem_size
        g_arena.set(type_size_offset, to_ptr(elem_size_val), 8)

        // Set type_name field (it's a Str)
        temp_type_name_id := format(name, "_type_name_temp")
        temp_symbol2 := SymbolInfo(value_type=ValueType.TCustom("Str"), is_mut=false, is_copy=false, is_own=false)
        frame.symbols.set(temp_type_name_id.clone(), temp_symbol2)

        EvalArena.insert_string_into_frame(ctx, frame, temp_type_name_id, elem_type, e)?

        mut temp_str_offset := 0
        frame.arena_index.get(temp_type_name_id, temp_str_offset)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "insert_array", "missing type_name temp Str offset")
        }

        type_name_offset := add(base_offset, type_name_rel_offset)
        str_size := ctx.get_type_size("Str")?
        g_arena.set(type_name_offset, g_arena.get(temp_str_offset, str_size), str_size)

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", "IndexOutOfBoundsError")
        }
        catch (err: U8_Overflow) {
            throw e.lang_error(ctx.path, "insert_array_into_frame", err.msg)
        }
    }

    /// Convert a struct instance stored in EvalArena to a struct literal Expr.
    /// Given instance "___temp_return_val_0" of type "Bool", produces:
    ///   Bool(data=1)
    /// The `e` parameter is only used for error reporting.
    to_struct_literal := func(ctx: Context, instance_name: Str, type_name: Str, e: Expr) returns Expr throws Str {
        mut struct_def := ctx.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            throw e.lang_error(ctx.path, "arena", format("to_struct_literal: struct '", type_name, "' not found"))
        }

        // First param is the type identifier
        type_id := Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), 0, 0)
        mut params := Vec.new(Expr)
        params.push(type_id)

        // For each mutable field, read value and create NamedArg
        for member: Declaration in struct_def.members {
            if not(member.is_mut) {
                continue  // Skip static fields
            }
            field_id := format(instance_name, ".", member.name)
            field_value := EvalArena.field_to_literal(ctx, field_id, member.value_type, e)?

            mut named_arg_params := Vec.new(Expr)
            named_arg_params.push(field_value)
            named_arg := Expr.new_explicit(NodeType.NamedArg(member.name), named_arg_params, 0, 0)
            params.push(named_arg)
        }

        result := Expr.new_explicit(NodeType.FCall(false), params, 0, 0)


        return result
    }

    /// Helper: read a field value from EvalArena and convert to literal Expr
    field_to_literal := func(ctx: Context, field_id: Str, value_type: ValueType, e: Expr) returns Expr throws Str {
        mut result := Expr()
        switch value_type {
        case ValueType.TCustom(custom_type):
            if custom_type.eq("I64") {
                i64_val := EvalArena.get_i64(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(i64_val.to_str())), Vec.new(Expr), 0, 0)
            } else if custom_type.eq("U8") {
                u8_val := EvalArena.get_u8(ctx, field_id, e)?
                result = Expr.new_explicit(NodeType.LLiteral(Literal.Number(u8_val.to_str())), Vec.new(Expr), 0, 0)
            } else {
                // Check if nested struct
                mut is_struct := false
                _struct_def := ctx.scope_stack.lookup_struct(custom_type)?
                is_struct = true
                catch (err: KeyNotFoundError) {
                    // Not a struct
                }
                if is_struct {
                    result = EvalArena.to_struct_literal(ctx, field_id, custom_type, e)?
                } else {
                    throw e.lang_error(ctx.path, "arena", format("field_to_literal: unsupported nested type '", custom_type, "'"))
                }
            }
        case:
            throw e.lang_error(ctx.path, "arena", format("field_to_literal: unsupported field type '", value_type_to_str(value_type), "'"))
        }

        return result
    }

    /// Extract the contents of a Vec instance from arena memory.
    /// Returns the element type name, size, and raw bytes for each element.
    extract_vec_contents := func(ctx: Context, instance_name: Str) returns VecContents throws Str {
        // Get Vec base offset
        mut vec_offset := 0
        vec_offset = ctx.scope_stack.lookup_var(instance_name)?
        catch (err: KeyNotFoundError) {
            throw format("extract_vec_contents: instance '", instance_name, "' not found")
        }

        // Vec layout: type_name (Str), type_size (I64), ptr (Ptr), _len (I64), cap (I64)
        // Get sizes
        str_size := ctx.get_type_size("Str")?
        ptr_size := ctx.get_type_size("Ptr")?

        // Read type_name (Str) - need to extract the string value
        type_name_offset := vec_offset
        type_name_str := EvalArena.extract_str_at_offset(ctx, type_name_offset)?

        // Read type_size (I64) - after Str
        type_size_offset := vec_offset.add(str_size)
        type_size_ptr := g_arena.get(type_size_offset, 8)
        mut type_size := 0
        Ptr(data=type_size_ptr).dereference(I64, type_size)

        // Read ptr.data (I64) - after type_size
        ptr_offset := type_size_offset.add(8)
        ptr_data_ptr := g_arena.get(ptr_offset, 8)
        mut data_ptr := 0
        Ptr(data=ptr_data_ptr).dereference(I64, data_ptr)

        // Read _len (I64) - after ptr (Ptr is 16 bytes: data + is_borrowed)
        len_offset := ptr_offset.add(ptr_size)
        len_ptr := g_arena.get(len_offset, 8)
        mut len := 0
        Ptr(data=len_ptr).dereference(I64, len)

        // Extract element bytes
        mut element_bytes := Vec.new(Vec)
        for i in 0..len {
            elem_offset := data_ptr.add(i.mul(type_size))
            // Read bytes from arena
            mut bytes := Vec.new(U8)
            for j in 0..type_size {
                byte_ptr := g_arena.get(elem_offset.add(j), 1)
                mut byte_val : U8 = 0
                Ptr(data=byte_ptr).dereference(U8, byte_val)
                bytes.push(byte_val)
            }
            element_bytes.push(bytes)
        }

        return VecContents(element_type_name=type_name_str, type_size=type_size, element_bytes=element_bytes)
    }

    /// Extract string data from a Str at a given offset.
    /// Used by extract_vec_contents for type_name and for Vec<Str> elements.
    extract_str_at_offset := func(ctx: Context, str_offset: I64) returns Str throws Str {
        // Str layout: c_string (Ptr), _len (I64), cap (I64)
        ptr_size := ctx.get_type_size("Ptr")?

        // Read c_string.data (first field of Ptr)
        c_string_ptr_ptr := g_arena.get(str_offset, 8)
        mut c_string_ptr := 0
        Ptr(data=c_string_ptr_ptr).dereference(I64, c_string_ptr)

        // Read _len (I64) - after c_string Ptr
        len_offset := str_offset.add(ptr_size)
        len_ptr := g_arena.get(len_offset, 8)
        mut len := 0
        Ptr(data=len_ptr).dereference(I64, len)

        // Read the actual string bytes
        if c_string_ptr.eq(0).or(len.eq(0)) {
            return ""
        }
        // Create string from bytes
        mut result := ""
        for i in 0..len {
            byte_ptr := g_arena.get(c_string_ptr.add(i), 1)
            mut byte_val : U8 = 0
            Ptr(data=byte_ptr).dereference(U8, byte_val)
            result = concat(result, Str.from_byte(byte_val))
        }
        return result
    }

    /// Extract string data from Str raw bytes (Vec<U8>).
    /// Used for nested types where we have the Str struct bytes directly.
    extract_str_from_bytes := func(ctx: Context, str_bytes: Vec) returns Str throws Str {
        ptr_size := ctx.get_type_size("Ptr")?

        // Read c_string.data (first 8 bytes) - little endian
        mut c_string_ptr := 0
        mut multiplier := 1
        for i in 0..8 {
            if i.lt(str_bytes.len()) {
                mut b : U8 = 0
                str_bytes.get(i, b)?
                c_string_ptr = c_string_ptr.add(b.to_i64().mul(multiplier))
                multiplier = multiplier.mul(256)
            }
            catch (err: IndexOutOfBoundsError) { }
        }

        // Read _len (I64) - after c_string Ptr
        mut len := 0
        mut multiplier2 := 1
        for i in 0..8 {
            idx := ptr_size.add(i)
            if idx.lt(str_bytes.len()) {
                mut b : U8 = 0
                str_bytes.get(idx, b)?
                len = len.add(b.to_i64().mul(multiplier2))
                multiplier2 = multiplier2.mul(256)
            }
            catch (err: IndexOutOfBoundsError) { }
        }

        // Read the actual string bytes from arena
        if c_string_ptr.eq(0).or(len.eq(0)) {
            return ""
        }
        mut result := ""
        for i in 0..len {
            byte_ptr := g_arena.get(c_string_ptr.add(i), 1)
            mut byte_val : U8 = 0
            Ptr(data=byte_ptr).dereference(U8, byte_val)
            result = concat(result, Str.from_byte(byte_val))
        }
        return result
    }

    /// Extract a Str value from an instance by name.
    extract_str_contents := func(ctx: Context, instance_name: Str) returns StrContents throws Str {
        mut str_offset := 0
        str_offset = ctx.scope_stack.lookup_var(instance_name)?
        catch (err: KeyNotFoundError) {
            throw format("extract_str_contents: instance '", instance_name, "' not found")
        }
        string_data := EvalArena.extract_str_at_offset(ctx, str_offset)?
        return StrContents(string_data=string_data)
    }

    /// Check if a type requires heap serialization (contains Ptr fields that point to heap data)
    type_needs_heap_serialization := func(ctx: Context, type_name: Str) returns Bool {
        if type_name.eq("Vec").or(type_name.eq("List")) {
            return true
        }
        // Str doesn't need it because string literals are already static in C
        // (the c_string pointer points to string literal data)

        // Check if this is a struct with Vec/List fields
        mut struct_def := SStructDef()
        struct_def = ctx.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        for member_idx in 0..struct_def.members.len() {
            mut member := Declaration()
            struct_def.members.get(member_idx, member)?
            catch (err: IndexOutOfBoundsError) {
                return false
            }
            if member.is_mut {
                switch member.value_type {
                case ValueType.TCustom(field_type):
                    if EvalArena.type_needs_heap_serialization(ctx, field_type) {
                        return true
                    }
                case:
                }
            }
        }
        return false
    }
}

// Global arena instance
mut g_arena := EvalArena.new()
