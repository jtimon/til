mode liba

import("self.init")
import("self.parser")

// Desugarer phase: Desugars ForIn loops to while loops with get() calls,
// and Switch statements to if/else chains.
// This phase runs after typer, before precomp.

// ---------- Helper struct for variant info extraction ----------

VariantInfo := struct {
    type_name: Str,
    variant_name: Str,
}

// ---------- Helper functions for switch desugaring ----------

/// Parse variant name from Pattern's variant_name field (e.g., "Color.Green" -> ("Color", "Green"))
parse_pattern_variant_name := func(variant_name_str: Str) returns VariantInfo {
    // Find the last dot
    mut dot_pos := variant_name_str.len().sub(1)
    mut found := false
    while dot_pos.gteq(0) {
        if variant_name_str.char_at(dot_pos).eq(".") {
            found = true
            break
        }
        dot_pos.dec()
    }
    if found {
        type_name := variant_name_str.substr(0, dot_pos)
        var_name := variant_name_str.substr(dot_pos.add(1), variant_name_str.len())
        return VariantInfo(type_name=type_name, variant_name=var_name)
    } else {
        // No dot - just variant name (shorthand syntax)
        return VariantInfo(type_name="", variant_name=variant_name_str)
    }
}

/// Extract variant info from a case pattern expression (Identifier with nested params)
get_case_variant_info := func(expr: Expr) returns VariantInfo {
    switch expr.node_type {
    case NodeType.FCall(_throws):
        // FCall for Type.Variant (without payload extraction)
        if expr.params.len().gt(0) {
            mut first_param := Expr()
            expr.params.get(0, first_param)
            switch first_param.node_type {
            case NodeType.Identifier(type_name):
                if first_param.params.len().gt(0) {
                    mut variant_param := Expr()
                    first_param.params.get(0, variant_param)
                    switch variant_param.node_type {
                    case NodeType.Identifier(variant_name):
                        return VariantInfo(type_name=type_name, variant_name=variant_name)
                    case:
                    }
                }
            case:
            }
            catch (err: IndexOutOfBoundsError) {
            }
        }
        return VariantInfo(type_name="", variant_name="")
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if expr.params.len().gt(0) {
            mut variant_param := Expr()
            expr.params.get(0, variant_param)
            switch variant_param.node_type {
            case NodeType.Identifier(variant_name):
                return VariantInfo(type_name=name, variant_name=variant_name)
            case:
            }
            catch (err: IndexOutOfBoundsError) {
            }
        }
        // Plain identifier without nested params - NOT an enum variant pattern
        return VariantInfo(type_name="", variant_name="")
    case:
        return VariantInfo(type_name="", variant_name="")
    }
}

/// Get the payload type from an enum definition for a given variant
get_payload_type_for_variant := func(context: Context, enum_name: Str, variant_name: Str) returns Ptr {
    mut enum_def := context.scope_stack.lookup_enum(enum_name)?
    for vi in 0..enum_def.variants.len() {
        mut v := EnumVariant()
        enum_def.variants.get(vi, v)?
        if v.name.eq(variant_name) {
            return v.payload_type
        }
    }
    catch (err: KeyNotFoundError) {
    }
    catch (err: IndexOutOfBoundsError) {
    }
    return Ptr()  // null pointer if not found
}

/// Search all enums in scope to find which one contains a variant with the given name
/// Returns the enum type name if found, empty string if not found
find_enum_for_variant := func(context: Context, variant_name: Str) returns Str {
    mut found_type := ""
    // Iterate through scope frames in reverse
    mut frame_i := context.scope_stack.frames.len().sub(1)
    while frame_i.gteq(0) {
        mut frame := ScopeFrame()
        context.scope_stack.frames.get(frame_i, frame)?
        // Check each enum in this frame
        for enum_i in 0..frame.enums.keys.len() {
            mut enum_name := ""
            frame.enums.keys.get(enum_i, enum_name)?
            mut enum_def := SEnumDef()
            frame.enums.get(enum_name, enum_def)?
            // Check if this enum has the variant
            for var_i in 0..enum_def.variants.len() {
                mut v := EnumVariant()
                enum_def.variants.get(var_i, v)?
                if v.name.eq(variant_name) {
                    if found_type.len().eq(0) {
                        found_type = enum_name
                    }
                    // If found in multiple enums, return first match
                    break
                }
            }
            if found_type.len().gt(0) {
                break
            }
        }
        if found_type.len().gt(0) {
            break
        }
        frame_i.dec()
    }
    catch (err: IndexOutOfBoundsError) {
    }
    catch (err: KeyNotFoundError) {
    }
    return found_type
}

/// Rename all occurrences of an identifier in an expression tree
/// Used to rename payload binding variables to unique names to avoid conflicts
/// Stops at shadowing constructs (inner Patterns, Declarations with same name)
/// IMPORTANT: Does NOT rename inside an Identifier's params - those are field names, not variable refs
rename_identifier_in_expr := func(e: Expr, old_name: Str, new_name: Str) returns Expr {
    switch e.node_type {
    case NodeType.Identifier(name):
        if name.eq(old_name) {
            // Identifier reference - rename it but DON'T recurse into params
            // Params of an Identifier are field names (e.g., x.field) or method calls,
            // NOT variable references. Renaming them would break field access.
            return Expr.new_clone(NodeType.Identifier(new_name), e, e.params)
        } else {
            // Different identifier - recurse into params to find nested expressions
            // But be careful: direct children that are Identifiers are likely field names
            if e.params.len().eq(0) {
                return e.clone()
            } else {
                mut new_params := Vec.new(Expr)
                for pi in 0..e.params.len() {
                    mut p := Expr()
                    e.params.get(pi, p)?
                    // Only recurse into non-Identifier params (like FCall, etc.)
                    switch p.node_type {
                    case NodeType.Identifier(_pname):
                        new_params.push(p.clone())
                    case:
                        new_params.push(rename_identifier_in_expr(p, old_name, new_name))
                    }
                }
                return Expr.new_clone(e.node_type, e, new_params)
            }
        }
    case NodeType.Assignment(name):
        if name.eq(old_name) {
            // Assignment to the variable - rename it
            mut new_params := Vec.new(Expr)
            for pi in 0..e.params.len() {
                mut p := Expr()
                e.params.get(pi, p)?
                new_params.push(rename_identifier_in_expr(p, old_name, new_name))
            }
            return Expr.new_clone(NodeType.Assignment(new_name), e, new_params)
        }
    case NodeType.Pattern(pattern_info):
        if pattern_info.binding_var.eq(old_name) {
            // Inner Pattern with same binding name - this shadows our variable
            // Don't rename anything inside
            return e.clone()
        }
    case NodeType.Declaration(decl):
        if decl.name.eq(old_name) {
            // Declaration shadows our variable - stop renaming in this scope
            // But still rename in the initializer
            if e.params.len().eq(0) {
                return e.clone()
            } else {
                mut new_params := Vec.new(Expr)
                mut init_expr := Expr()
                e.params.get(0, init_expr)?
                new_params.push(rename_identifier_in_expr(init_expr, old_name, new_name))
                // Any remaining params - don't rename
                for pi in 1..e.params.len() {
                    mut p := Expr()
                    e.params.get(pi, p)?
                    new_params.push(p.clone())
                }
                return Expr.new_clone(e.node_type, e, new_params)
            }
        }
    case:
    }

    // Default: Recurse into params
    if e.params.len().eq(0) {
        return e.clone()
    } else {
        mut new_params := Vec.new(Expr)
        for pi in 0..e.params.len() {
            mut p := Expr()
            e.params.get(pi, p)?
            new_params.push(rename_identifier_in_expr(p, old_name, new_name))
        }
        return Expr.new_clone(e.node_type, e, new_params)
    }

    catch (err: IndexOutOfBoundsError) {
        // Shouldn't happen
    }
    return e.clone()
}

/// Build: eq(var_name, literal_str) - string equality comparison
build_str_eq_call := func(var_name: Str, literal_str: Str, line: I64, col: I64) returns Expr {
    mut eq_params := Vec.new(Expr)
    eq_params.push(Expr.new_explicit(NodeType.Identifier("eq"), Vec.new(Expr), line, col))
    eq_params.push(Expr.new_explicit(NodeType.Identifier(var_name), Vec.new(Expr), line, col))
    eq_params.push(Expr.new_explicit(NodeType.LLiteral(Literal.Str(literal_str)), Vec.new(Expr), line, col))
    return Expr.new_explicit(NodeType.FCall(false), eq_params, line, col)
}

/// Build a default value expression for a given ValueType.
/// Used when generating placeholder values for enum variant payloads in for-in loops.
/// Bug #33: for-in loops don't work with enum collections
/// Bug #86: Handle enum payload types recursively
build_default_value := func(context: Context, vt: ValueType, line: I64, col: I64) returns Expr {
    switch vt {
    case ValueType.TCustom(type_name):
        if type_name.eq("I64") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
        }
        if type_name.eq("U8") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
        }
        if type_name.eq("Bool") {
            return Expr.new_explicit(NodeType.Identifier("false"), Vec.new(Expr), line, col)
        }
        if type_name.eq("Str") {
            return Expr.new_explicit(NodeType.LLiteral(Literal.Str("")), Vec.new(Expr), line, col)
        }
        // For other types (structs, other enums), check if it's an enum
        // Bug #86: Check if this type is an enum - enums need special constructor syntax
        mut is_enum := false
        mut enum_def := context.scope_stack.lookup_enum(type_name)?
        is_enum = true
        catch (err: KeyNotFoundError) {
            // Not an enum
        }
        if is_enum {
            // Build proper enum constructor: EnumType.FirstVariant or EnumType.FirstVariant(payload)
            if enum_def.variants.len().gt(0) {
                mut first_v := EnumVariant()
                enum_def.variants.get(0, first_v)?
                first_variant := first_v.name
                payload_type_ptr := first_v.payload_type
                catch (err: IndexOutOfBoundsError) {
                    // Shouldn't happen since we checked len > 0
                }
                variant_id := Expr.new_explicit(NodeType.Identifier(first_variant), Vec.new(Expr), line, col)
                mut variant_id_params := Vec.new(Expr)
                variant_id_params.push(variant_id)
                enum_id := Expr.new_explicit(NodeType.Identifier(type_name), variant_id_params, line, col)
                if not(NULL.eq(payload_type_ptr.data)) {
                    // Variant has a payload - need FCall with default value (recursive)
                    mut payload_vt := ValueType.TCustom("")
                    memcpy(to_ptr(payload_vt), payload_type_ptr.data, size_of(ValueType))
                    default_arg := build_default_value(context, payload_vt, line, col)
                    mut enum_payload_fcall_params := Vec.new(Expr)
                    enum_payload_fcall_params.push(enum_id)
                    enum_payload_fcall_params.push(default_arg)
                    return Expr.new_explicit(NodeType.FCall(false), enum_payload_fcall_params, line, col)
                } else {
                    // Variant has no payload - just the identifier chain
                    return enum_id
                }
            } else {
                // Empty enum - fall back to struct-like constructor (shouldn't happen)
                mut empty_enum_fcall_params := Vec.new(Expr)
                empty_enum_fcall_params.push(Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), line, col))
                return Expr.new_explicit(NodeType.FCall(false), empty_enum_fcall_params, line, col)
            }
        } else {
            // Not an enum - use struct-like constructor: TYPE()
            mut struct_fcall_params := Vec.new(Expr)
            struct_fcall_params.push(Expr.new_explicit(NodeType.Identifier(type_name), Vec.new(Expr), line, col))
            return Expr.new_explicit(NodeType.FCall(false), struct_fcall_params, line, col)
        }
    case:
        // For function types and other types, use a placeholder (shouldn't typically happen)
        return Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), Vec.new(Expr), line, col)
    }
}

/// Desugar ForIn to a range-based for loop with get() calls
// for VAR: TYPE in COLLECTION { body }
// becomes:
/// for _for_i in 0..collection.len() {
//     mut VAR := TYPE() or EnumType.FirstVariant(...) for enums
///     collection.get(_for_i, VAR)
//     catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
///     body
/// }
desugar_forin := proc(mut context: Context, e: Expr, var_type_name: Str) returns Expr throws Str {
    // Extract var_name from params[0]
    if e.params.len().lt(1) {
        throw e.lang_error(context.path, "desugar", "ForIn: missing loop variable")
    }
    mut var_expr := e.get(0)?
    mut var_name := ""
    switch var_expr.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        throw e.lang_error(context.path, "desugar", "ForIn: expected identifier for loop variable")
    }

    // Get collection expression (params[1])
    if e.params.len().lt(2) {
        throw e.lang_error(context.path, "desugar", "ForIn: missing collection expression")
    }
    collection_expr := desugar_expr(context, e.get(1)?)?

    // NOTE: We do NOT declare the loop variable in scope_stack here.
    // The desugarer just transforms AST; variable declaration will be handled
    // by the generated Declaration node in the desugared while loop.
    // Declaring here would leak variables across files during batch compilation.

    // Get body (params[2])
    if e.params.len().lt(3) {
        throw e.lang_error(context.path, "desugar", "ForIn: missing body")
    }
    body_expr := desugar_expr(context, e.get(2)?)?

    // Build: mut _for_i_funcname_N := 0 (unique name to avoid conflicts with nested loops)
    // Bug #40 fix: Use per-function counter and include function name for deterministic output
    forin_id := context.precomp_forin_counter
    context.precomp_forin_counter.inc()
    mut index_var_name := ""
    if context.current_precomp_func.len().gt(0) {
        index_var_name = format("_for_i_", context.current_precomp_func, "_", I64.to_str(forin_id))
    } else {
        index_var_name = format("_for_i_", I64.to_str(forin_id))
    }
    index_decl := Declaration(name=index_var_name, value_type=str_to_value_type("I64"), is_mut=true, is_copy=false, is_own=false, default_value=Ptr())
    mut zero_params := Vec.new(Expr)
    zero_literal := Expr.new_explicit(NodeType.LLiteral(Literal.Number("0")), zero_params, e.line, e.col)
    mut decl_params := Vec.new(Expr)
    decl_params.push(zero_literal)
    index_decl_expr := Expr.new_explicit(NodeType.Declaration(index_decl), decl_params, e.line, e.col)

    // Build len(collection) - already desugared form
    mut len_params := Vec.new(Expr)
    len_params.push(Expr.new_explicit(NodeType.Identifier("len"), Vec.new(Expr), e.line, e.col))
    len_params.push(collection_expr.clone())
    len_call_expr := Expr.new_explicit(NodeType.FCall(false), len_params, e.line, e.col)

    // Build lt(_for_i, len_result) - already desugared form
    mut cond_params := Vec.new(Expr)
    cond_params.push(Expr.new_explicit(NodeType.Identifier("lt"), Vec.new(Expr), e.line, e.col))
    cond_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    cond_params.push(len_call_expr)
    cond_expr := Expr.new_explicit(NodeType.FCall(false), cond_params, e.line, e.col)

    // Build: mut VAR := TYPE() or EnumType.FirstVariant(...) for enums
    var_decl := Declaration(name=var_name, value_type=ValueType.TCustom(var_type_name), is_mut=true, is_copy=false, is_own=false, default_value=Ptr())

    // Check if this is an enum type - enums need special handling since they don't have
    // a parameterless constructor. We need to use the first variant as a placeholder.
    // Bug #33: for-in loops don't work with enum collections
    mut type_call := Expr()
    mut is_enum := false
    mut enum_def := context.scope_stack.lookup_enum(var_type_name)?
    is_enum = true
    catch (err: KeyNotFoundError) {
        // Not an enum
    }

    if is_enum {
        // Get the first variant from the enum (arbitrary choice - value will be overwritten by get())
        // Bug #38 fix: use variants Vec
        if enum_def.variants.len().gt(0) {
            mut first_v := EnumVariant()
            enum_def.variants.get(0, first_v)?
            first_variant := first_v.name
            payload_type_ptr := first_v.payload_type
            catch (err: IndexOutOfBoundsError) {
                // Shouldn't happen since we checked len > 0
            }

            // Build the enum constructor:
            // - For variants WITHOUT payload: EnumType.Variant (just identifier chain)
            // - For variants WITH payload: EnumType.Variant(default_payload) (FCall)
            variant_id := Expr.new_explicit(NodeType.Identifier(first_variant), Vec.new(Expr), e.line, e.col)
            mut variant_id_params := Vec.new(Expr)
            variant_id_params.push(variant_id)
            enum_id := Expr.new_explicit(NodeType.Identifier(var_type_name), variant_id_params, e.line, e.col)

            if not(NULL.eq(payload_type_ptr.data)) {
                // Variant has a payload - need FCall with default value
                mut payload_vt := ValueType.TCustom("")
                memcpy(to_ptr(payload_vt), payload_type_ptr.data, size_of(ValueType))
                default_arg := build_default_value(context, payload_vt, e.line, e.col)
                mut fcall_params := Vec.new(Expr)
                fcall_params.push(enum_id)
                fcall_params.push(default_arg)
                type_call = Expr.new_explicit(NodeType.FCall(false), fcall_params, e.line, e.col)
            } else {
                // Variant has no payload - just the identifier chain (NOT an FCall)
                type_call = enum_id
            }
        } else {
            // Empty enum - shouldn't happen, fall back to struct-like constructor
            mut empty_enum_type_call_params := Vec.new(Expr)
            empty_enum_type_call_params.push(Expr.new_explicit(NodeType.Identifier(var_type_name), Vec.new(Expr), e.line, e.col))
            type_call = Expr.new_explicit(NodeType.FCall(false), empty_enum_type_call_params, e.line, e.col)
        }
    } else {
        // Not an enum - use struct-like constructor: TYPE()
        mut struct_type_call_params := Vec.new(Expr)
        struct_type_call_params.push(Expr.new_explicit(NodeType.Identifier(var_type_name), Vec.new(Expr), e.line, e.col))
        type_call = Expr.new_explicit(NodeType.FCall(false), struct_type_call_params, e.line, e.col)
    }

    mut var_decl_params := Vec.new(Expr)
    var_decl_params.push(type_call)
    var_decl_expr := Expr.new_explicit(NodeType.Declaration(var_decl), var_decl_params, e.line, e.col)

    // Build: get(collection, _for_i, VAR) - already desugared form
    mut get_params := Vec.new(Expr)
    get_params.push(Expr.new_explicit(NodeType.Identifier("get"), Vec.new(Expr), e.line, e.col))
    get_params.push(collection_expr.clone())
    get_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    get_params.push(Expr.new_explicit(NodeType.Identifier(var_name), Vec.new(Expr), e.line, e.col))
    get_call := Expr.new_explicit(NodeType.FCall(false), get_params, e.line, e.col)

    // Build: catch (_err_forin_N: IndexOutOfBoundsError) { panic(loc(), _err_forin_N.msg) }
    // Bug #97: Use unique name to avoid shadowing loop variable if it's also named "err"
    catch_err_var := format("_err_forin_", I64.to_str(forin_id))

    // Build _err_forin_N.msg (identifier with field access)
    mut msg_field := Vec.new(Expr)
    msg_field.push(Expr.new_explicit(NodeType.Identifier("msg"), Vec.new(Expr), e.line, e.col))
    err_msg_expr := Expr.new_explicit(NodeType.Identifier(catch_err_var), msg_field, e.line, e.col)

    // Build loc() call
    mut loc_params := Vec.new(Expr)
    loc_params.push(Expr.new_explicit(NodeType.Identifier("loc"), Vec.new(Expr), e.line, e.col))
    loc_call := Expr.new_explicit(NodeType.FCall(false), loc_params, e.line, e.col)

    // Build panic(loc(), _err_forin_N.msg)
    mut panic_params := Vec.new(Expr)
    panic_params.push(Expr.new_explicit(NodeType.Identifier("panic"), Vec.new(Expr), e.line, e.col))
    panic_params.push(loc_call)
    panic_params.push(err_msg_expr)
    panic_call := Expr.new_explicit(NodeType.FCall(false), panic_params, e.line, e.col)

    // Build catch body
    mut catch_body_params := Vec.new(Expr)
    catch_body_params.push(panic_call)
    catch_body := Expr.new_explicit(NodeType.Body, catch_body_params, e.line, e.col)

    // Catch structure: [name_expr, type_expr, body_expr]
    mut catch_params := Vec.new(Expr)
    catch_params.push(Expr.new_explicit(NodeType.Identifier(catch_err_var), Vec.new(Expr), e.line, e.col))
    catch_params.push(Expr.new_explicit(NodeType.Identifier("IndexOutOfBoundsError"), Vec.new(Expr), e.line, e.col))
    catch_params.push(catch_body)
    catch_expr := Expr.new_explicit(NodeType.Catch, catch_params, e.line, e.col)

    // Build: _for_i = add(_for_i, 1)
    // Already desugared form - no UFCS resolution needed
    mut add_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.Identifier("add"), Vec.new(Expr), e.line, e.col))
    add_params.push(Expr.new_explicit(NodeType.Identifier(index_var_name), Vec.new(Expr), e.line, e.col))
    mut one_params := Vec.new(Expr)
    add_params.push(Expr.new_explicit(NodeType.LLiteral(Literal.Number("1")), one_params, e.line, e.col))
    add_call := Expr.new_explicit(NodeType.FCall(false), add_params, e.line, e.col)

    mut inc_params := Vec.new(Expr)
    inc_params.push(add_call)
    inc_stmt := Expr.new_explicit(NodeType.Assignment(index_var_name), inc_params, e.line, e.col)

    // Build while body: var_decl, get_call + catch (together), original body statements, inc
    // The catch must be right after get_call so it only catches IndexOutOfBoundsError from get,
    // not from user code in the loop body
    mut while_body_params := Vec.new(Expr)
    while_body_params.push(var_decl_expr)
    while_body_params.push(get_call)
    while_body_params.push(catch_expr)

    // Bug #57 fix: Transform continue statements to include increment before continue
    transformed_body := transform_continue_with_step(body_expr, inc_stmt)?
    // Add original body statements (transformed)
    switch transformed_body.node_type {
    case NodeType.Body:
        for i in 0..transformed_body.params.len() {
            mut p := Expr()
            transformed_body.params.get(i, p)?
            while_body_params.push(p.clone())
        }
    case:
        while_body_params.push(transformed_body)
    }
    while_body_params.push(inc_stmt.clone())
    while_body := Expr.new_explicit(NodeType.Body, while_body_params, e.line, e.col)

    // Build while: while _for_i.lt(collection.len()) { ... }
    mut while_params := Vec.new(Expr)
    while_params.push(cond_expr)
    while_params.push(while_body)
    while_expr := Expr.new_explicit(NodeType.While, while_params, e.line, e.col)

    // Build outer body: index_decl, while
    mut outer_body_params := Vec.new(Expr)
    outer_body_params.push(index_decl_expr)
    outer_body_params.push(while_expr)

    catch (err: IndexOutOfBoundsError) {
        throw format("desugar_forin: ", err.msg)
    }

    return Expr.new_explicit(NodeType.Body, outer_body_params, e.line, e.col)
}

/// Desugarer phase entry point: Recursively desugar ForIn loops in the AST.
desugar_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // ForIn desugaring: for VAR: TYPE in COLLECTION { body } -> while loop
    case NodeType.ForIn(var_type_name):
        return desugar_forin(context, e, var_type_name)?
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        // Bug #130 fix: Reset counter per-function for deterministic output
        saved_counter := context.precomp_forin_counter
        context.precomp_forin_counter = 0
        mut new_body := Vec.new(Expr)
        for func_i in 0..func_def.body.len() {
            mut stmt := Expr()
            func_def.body.get(func_i, stmt)?
            new_body.push(desugar_expr(context, stmt)?)
        }
        context.precomp_forin_counter = saved_counter
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args,
            return_types=func_def.return_types,
            throw_types=func_def.throw_types,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)
    // Recurse into StructDef default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        mut struct_i := 0
        while struct_i.lt(struct_def.default_values.keys.len()) {
            mut name := ""
            struct_def.default_values.keys.get(struct_i, name)?
            mut value_expr := Expr()
            struct_def.default_values.get(name, value_expr)?
            new_default_values.set(name, desugar_expr(context, value_expr)?)
            struct_i.inc()
        }
        new_struct_def := SStructDef(
            members=struct_def.members,
            default_values=new_default_values
        )
        return Expr.new_clone(NodeType.StructDef(new_struct_def), e, e.params)
    // For all other nodes, recurse into params
    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut new_params := Vec.new(Expr)
            for param_i in 0..e.params.len() {
                mut p := Expr()
                e.params.get(param_i, p)?
                new_params.push(desugar_expr(context, p)?)
            }
            return Expr.new_clone(e.node_type, e, new_params)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("desugar_expr: IndexOutOfBoundsError: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("desugar_expr: KeyNotFoundError: ", err.msg)
    }
}
