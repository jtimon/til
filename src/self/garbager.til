mode liba

import("self.init")
import("self.parser")

// Garbager phase: AST transformations for memory semantics.
// This phase runs after type checking, before UFCS.
// Issue #159: Insert clone() calls for deep copy semantics on struct assignments.

/// Garbager phase entry point: Transform AST for proper memory semantics.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    return garbager_recursive(context, e)?
}

/// Recursively transform the AST.
garbager_recursive := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        mut new_body := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                // Step 2: Collect create_alias var names
                alias_var := get_create_alias_var(stmt)
                if alias_var.len().gt(0) {
                    dont_delete_vars.push(alias_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 2.5: Collect catch error variable names (they shadow locals in ccodegen)
        for catch_stmt: Expr in new_body {
            switch catch_stmt.node_type {
            case NodeType.Catch:
                if catch_stmt.params.len().gt(0) {
                    mut catch_name_expr := Expr()
                    catch_stmt.params.get(0, catch_name_expr)?
                    switch catch_name_expr.node_type {
                    case NodeType.Identifier(err_var_name):
                        dont_delete_vars.push(err_var_name)
                    case:
                    }
                }
            case:
            }
        }

        // Build local name->type map for clone-after-get and own-transfer detection
        mut local_types := Map.new(Str, Str)
        for arg_def: Declaration in func_def.args {
            switch arg_def.value_type {
            case ValueType.TCustom(type_name):
                local_types.set(arg_def.name, type_name)
            case:
            }
        }
        // Also collect declarations from nested scopes (if/while/for bodies)
        collect_local_types_recursive(new_body, local_types)?

        // Step 2.7: Insert clone-after-get for container methods with shallow out-params.
        new_body = insert_clone_after_get(new_body, local_types, context)?

        // Step 2.8: Insert scope-exit deletes for inner-scope declarations.
        new_body = insert_scope_exit_deletes(new_body, local_types, context)?

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types.
        // Skip if function has any catch blocks: throws can skip declarations,
        // making unconditional deletes at function end unsafe.
        mut has_any_catch := false
        for catch_idx in 0..new_body.len() {
            mut catch_check_stmt := Expr()
            new_body.get(catch_idx, catch_check_stmt)?
            switch catch_check_stmt.node_type {
            case NodeType.Catch:
                has_any_catch = true
            case:
            }
        }
        if not(has_any_catch) {
            for stmt: Expr in new_body {
                switch stmt.node_type {
                case NodeType.Declaration(decl):
                    switch decl.value_type {
                    case ValueType.TCustom(type_name):
                        if is_deletable_type(type_name, context) {
                            cand_vars.push(decl.name)
                            cand_types.push(type_name)
                        }
                    case:
                    }
                case:
                }
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        own_transfers := collect_own_transfers(new_body, context, local_types)?
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            mut var_name := ""
            cand_vars.get(i, var_name)?
            mut type_name := ""
            cand_types.get(i, type_name)?
            mut excluded := var_name.eq("_")
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 5: Insert Type.delete(var) calls.
        // copy/own params: ASAP after last use (deep copies, no aliasing).
        // locals: at function end (shared offsets mean locals can alias).
        mut param_names := Vec.new(Str)
        for parg: Declaration in func_def.args {
            if parg.is_copy.or(parg.is_own) {
                param_names.push(parg.name)
            }
        }

        // Separate params (ASAP) from locals (end-of-function)
        mut asap_vars := Vec.new(Str)
        mut asap_types := Vec.new(Str)
        mut end_vars := Vec.new(Str)
        mut end_types := Vec.new(Str)
        for ci in 0..filtered_vars.len() {
            mut cv := ""
            filtered_vars.get(ci, cv)?
            mut ct := ""
            filtered_types.get(ci, ct)?
            mut is_param := false
            for pn: Str in param_names {
                if pn.eq(cv) { is_param = true }
            }
            if is_param {
                asap_vars.push(cv)
                asap_types.push(ct)
            } else {
                end_vars.push(cv)
                end_types.push(ct)
            }
        }

        // ASAP: insert after last use for copy/own params
        body_len := new_body.len()
        mut insert_positions := Vec.new(I64)
        mut insert_del_calls := Vec.new(Expr)
        mut ri := asap_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            mut del_var := ""
            asap_vars.get(ri, del_var)?
            mut del_type := ""
            asap_types.get(ri, del_type)?
            last_use := find_last_use_index(new_body, del_var)
            mut insert_pos := body_len
            if last_use.gteq(0) {
                insert_pos = last_use.add(1)
            }
            mut del_line := e.line
            mut del_col := e.col
            if insert_pos.gt(0).and(insert_pos.lteq(body_len)) {
                mut prev_stmt := Expr()
                new_body.get(insert_pos.sub(1), prev_stmt)?
                del_line = prev_stmt.line
                del_col = prev_stmt.col
            } else {
                if new_body.len().gt(0) {
                    mut last_s := Expr()
                    new_body.get(new_body.len().sub(1), last_s)?
                    del_line = last_s.line
                    del_col = last_s.col
                }
            }
            insert_positions.push(insert_pos)
            insert_del_calls.push(build_delete_call_expr(del_type, del_var, del_line, del_col))
        }

        // Build final_body: original statements with ASAP deletes interleaved
        mut final_body := Vec.new(Expr)
        for i in 0..body_len {
            mut body_stmt := Expr()
            new_body.get(i, body_stmt)?
            final_body.push(body_stmt)
            for di in 0..insert_positions.len() {
                mut dpos := 0
                insert_positions.get(di, dpos)?
                if dpos.eq(i.add(1)) {
                    mut dc := Expr()
                    insert_del_calls.get(di, dc)?
                    final_body.push(dc)
                }
            }
        }

        // End-of-function: append locals in reverse declaration order
        mut last_line := e.line
        mut last_col := e.col
        if final_body.len().gt(0) {
            mut last_s := Expr()
            final_body.get(final_body.len().sub(1), last_s)?
            last_line = last_s.line
            last_col = last_s.col
        }
        mut eri := end_vars.len()
        while eri.gt(0) {
            eri = eri.sub(1)
            mut ev := ""
            end_vars.get(eri, ev)?
            mut et := ""
            end_types.get(eri, et)?
            final_body.push(build_delete_call_expr(et, ev, last_line, last_col))
        }
        new_body = final_body

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)

    // Recurse into StructDef default values
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            mut value_expr := Expr()
            struct_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_struct_def := SStructDef(
            members=struct_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), new_params, e.line, e.col)

    // Recurse into NamespaceDef default values
    case NodeType.NamespaceDef(ns_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in ns_def.default_values.keys {
            mut value_expr := Expr()
            ns_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_ns_def := SNamespaceDef(
            type_name=ns_def.type_name,
            members=ns_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.NamespaceDef(new_ns_def), new_params, e.line, e.col)

    // Issue #159: Transform mut declarations with struct type where RHS is an identifier
    case NodeType.Declaration(decl):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }

        // Check if this is a mut declaration with struct type and identifier RHS
        // Identifier can have field access (x.y.z), we clone any identifier-based RHS
        if decl.is_mut.and(new_params.len().gt(0)) {
            mut first_param := Expr()
            new_params.get(0, first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch first_param.node_type {
            case NodeType.Identifier(_):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Exclude true primitive types - they don't need deep cloning
                    // Note: Bool is NOT excluded because true/false are global constants
                    // that would be corrupted if we just share offsets
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(new_params.len()) {
                            mut param := Expr()
                            new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159: Transform FCall copy params with struct type where arg is an identifier
    case NodeType.FCall(_):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        // Transform copy params: wrap struct identifier args in Type.clone()
        transform_fcall_copy_params(context, e, new_params)
        // Issue #159 Step 5: Transform struct literal fields
        transform_struct_literal_fields(context, e, new_params)
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159 Step 6: Transform assignments with struct type where RHS is an identifier
    case NodeType.Assignment(var_name):
        // First, recursively transform children
        mut assign_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            assign_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if RHS is a bare identifier (no field access children)
        // Field access expressions (x.y.z) are skipped - they read from memory directly
        if assign_new_params.len().gt(0) {
            mut assign_first_param := Expr()
            assign_new_params.get(0, assign_first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch assign_first_param.node_type {
            case NodeType.Identifier(rhs_name):
                if assign_first_param.params.len().eq(0) {
                // Look up identifier's symbol type
                assign_sym := context.scope_stack.lookup_symbol(rhs_name)?
                catch (err: KeyNotFoundError) {
                    // Symbol not found - no transformation needed
                    return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)
                }
                switch assign_sym.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := assign_first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(assign_new_params.len()) {
                            mut param := Expr()
                            assign_new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
                } // end if bare identifier
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)

    // Body: recurse into children
    case NodeType.Body:
        mut body_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            body_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, body_new_params, e.line, e.col)

    // Default: recurse into children
    case:
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Build AST for Type.clone(src_expr): FCall( Identifier("Type").Identifier("clone"), src_expr )
build_clone_call_expr := func(type_name: Str, src_expr: Expr, line: I64, col: I64) returns Expr {
    // Type.clone access: Identifier("Type") with child Identifier("clone")
    clone_ident := Expr(node_type=NodeType.Identifier("clone"), line=line, col=col)
    mut type_clone_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_clone_access.params.push(clone_ident)

    // FCall node with the source expression as argument
    mut clone_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    clone_call.params.push(type_clone_access)
    clone_call.params.push(src_expr)
    return clone_call
}

/// Recursively collect Declaration nodes with TCustom types from a statement list.
/// Recurses into all children (not just Body nodes), skips nested FuncDef bodies.
collect_local_types_recursive := proc(stmts: Vec, mut local_types: Map) throws Str {
    for stmt: Expr in stmts {
        switch stmt.node_type {
        case NodeType.Declaration(decl):
            switch decl.value_type {
            case ValueType.TCustom(type_name):
                if type_name.eq("auto") {
                    // Infer type from RHS: for FCall like Vec.new() or Expr(),
                    // the first element of the identifier chain is the type.
                    if stmt.params.len().gt(0) {
                        mut rhs := Expr()
                        stmt.params.get(0, rhs)?
                        mut chain := Vec.new(Str)
                        get_fcall_identifier_chain(rhs, chain)
                        if chain.len().gt(0) {
                            mut first := ""
                            chain.get(0, first)?
                            first_char := first.char_at(0)
                            if U8.to_i64(first_char).gteq(65).and(U8.to_i64(first_char).lteq(90)) {
                                local_types.set(decl.name, first)
                            }
                        }
                    }
                } else {
                    local_types.set(decl.name, type_name)
                }
            case:
            }
        case:
        }
        // Only recurse into Body children (if/while/for blocks), not every param.
        // Deep recursion into all params causes OOM in TIL due to for-in leak (Bug #144).
        switch stmt.node_type {
        case NodeType.FuncDef(_):
            // separate scope, skip
        case:
            for param: Expr in stmt.params {
                switch param.node_type {
                case NodeType.Body:
                    collect_local_types_recursive(param.params, local_types)?
                case:
                }
            }
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("collect_local_types_recursive: ", err.msg)
    }
}

/// Insert scope-exit deletes for declarations in inner-scope Body nodes.
/// Recurses into nested Body nodes but not into FuncDef bodies.
insert_scope_exit_deletes := proc(stmts: Vec, local_types: Map, context: Context) returns Vec throws Str {
    mut result := Vec.new(Expr)
    for stmt: Expr in stmts {
        processed := process_stmt_for_scope_exit(stmt, local_types, context)?
        result.push(processed)
    }
    return result
}

process_stmt_for_scope_exit := proc(e: Expr, local_types: Map, context: Context) returns Expr throws Str {
    switch e.node_type {
    case NodeType.FuncDef(_):
        return e // separate scope, don't touch
    case NodeType.Body:
        // First recurse into children (handles nested Body nodes)
        recursed := insert_scope_exit_deletes(e.params, local_types, context)?

        // Strip dont_delete, collect protected vars
        mut final_stmts := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in recursed {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                if get_create_alias_var(stmt).len().gt(0) {
                    dont_delete_vars.push(get_create_alias_var(stmt))
                }
                final_stmts.push(stmt)
            }
        }

        // Collect catch error var names
        for catch_stmt: Expr in final_stmts {
            switch catch_stmt.node_type {
            case NodeType.Catch:
                if catch_stmt.params.len().gt(0) {
                    mut catch_name_expr := Expr()
                    catch_stmt.params.get(0, catch_name_expr)?
                    switch catch_name_expr.node_type {
                    case NodeType.Identifier(err_var_name):
                        dont_delete_vars.push(err_var_name)
                    case:
                    }
                }
            case:
            }
        }

        // Check for catch blocks -- skip deletion if any
        mut has_any_catch := false
        for check_stmt: Expr in final_stmts {
            switch check_stmt.node_type {
            case NodeType.Catch:
                has_any_catch = true
            case:
            }
        }

        if not(has_any_catch) {
            // Whitelist approach: only collect declarations whose RHS is a
            // known-allocating expression (constructor, format, concat, to_str,
            // clone, new, split, etc.). Variables from container get/pop,
            // field access, or other sources may be aliased and unsafe to delete.
            mut cand_vars := Vec.new(Str)
            mut cand_types := Vec.new(Str)
            for decl_stmt: Expr in final_stmts {
                switch decl_stmt.node_type {
                case NodeType.Declaration(decl):
                    switch decl.value_type {
                    case ValueType.TCustom(type_name):
                        if is_deletable_type(type_name, context) {
                            if decl_stmt.params.len().gt(0) {
                                mut decl_rhs := Expr()
                                decl_stmt.params.get(0, decl_rhs)?
                                if is_owned_rhs(decl_rhs) {
                                    cand_vars.push(decl.name)
                                    cand_types.push(type_name)
                                }
                            }
                        }
                    case:
                    }
                case:
                }
            }

            // Collect own transfers
            own_transfers := collect_own_transfers(final_stmts, context, local_types)?

            // Collect vars used as function arguments (shallow-copy alias risk)
            mut func_arg_vars := Vec.new(Str)
            collect_func_arg_vars(final_stmts, func_arg_vars)

            // Filter
            mut filtered_vars := Vec.new(Str)
            mut filtered_types := Vec.new(Str)
            for fi in 0..cand_vars.len() {
                mut fv := ""
                cand_vars.get(fi, fv)?
                mut ft := ""
                cand_types.get(fi, ft)?
                mut excluded := fv.eq("_")
                for dd: Str in dont_delete_vars {
                    if dd.eq(fv) { excluded = true }
                }
                for ot: Str in own_transfers {
                    if ot.eq(fv) { excluded = true }
                }
                for fav: Str in func_arg_vars {
                    if fav.eq(fv) { excluded = true }
                }
                if not(excluded) {
                    filtered_vars.push(fv)
                    filtered_types.push(ft)
                }
            }

            // Append deletes at end of scope in reverse declaration order
            if filtered_vars.len().gt(0) {
                mut last_line := e.line
                mut last_col := e.col
                if final_stmts.len().gt(0) {
                    mut last_s := Expr()
                    final_stmts.get(final_stmts.len().sub(1), last_s)?
                    last_line = last_s.line
                    last_col = last_s.col
                }
                mut dri := filtered_vars.len()
                while dri.gt(0) {
                    dri = dri.sub(1)
                    mut dv := ""
                    filtered_vars.get(dri, dv)?
                    mut dt := ""
                    filtered_types.get(dri, dt)?
                    final_stmts.push(build_delete_call_expr(dt, dv, last_line, last_col))
                }
            }
        }

        return Expr.new_explicit(e.node_type, final_stmts, e.line, e.col)

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(context.path, "garbager", format("process_stmt_for_scope_exit: ", err.msg))
        }
    case:
        // Only recurse into Body children (if/while/for blocks), not all params.
        // Body nodes only appear as direct children of control flow statements.
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            switch param.node_type {
            case NodeType.Body:
                new_params.push(process_stmt_for_scope_exit(param, local_types, context)?)
            case:
                new_params.push(param)
            }
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Collect identifiers used as arguments to function calls in a list of statements.
/// Shallow scan only: checks each statement's top-level FCall, plus FCall in
/// Assignment RHS and Declaration RHS. Does NOT recurse into nested expressions
/// to avoid OOM from for-in leak (Bug #144).
/// Any variable passed as a function argument gets shallow-copied (memcpy) in TIL/C,
/// creating an alias that makes it unsafe to delete.
collect_func_arg_vars := proc(stmts: Vec, mut result: Vec) {
    for stmt: Expr in stmts {
        collect_fcall_arg_identifiers(stmt, result)
        // Also check one level deeper: Assignment RHS and Declaration RHS
        switch stmt.node_type {
        case NodeType.Assignment(_):
            if stmt.params.len().gt(0) {
                mut rhs := Expr()
                stmt.params.get(0, rhs)?
                catch (err: IndexOutOfBoundsError) { }
                collect_fcall_arg_identifiers(rhs, result)
            }
        case NodeType.Declaration(_):
            if stmt.params.len().gt(0) {
                mut rhs := Expr()
                stmt.params.get(0, rhs)?
                catch (err: IndexOutOfBoundsError) { }
                collect_fcall_arg_identifiers(rhs, result)
            }
        case:
        }
    }
}

/// Collect bare identifiers from FCall arguments (params[1..]).
/// Only collects from this single FCall node, no recursion.
collect_fcall_arg_identifiers := proc(e: Expr, mut result: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        for i in 1..e.params.len() {
            mut param_expr := Expr()
            e.params.get(i, param_expr)?
            catch (err: IndexOutOfBoundsError) { }
            switch param_expr.node_type {
            case NodeType.Identifier(var_name):
                if param_expr.params.len().eq(0) {
                    result.push(var_name)
                }
            case:
            }
        }
    case:
    }
}

/// Check if a Declaration RHS is a known-allocating expression.
/// Only these expressions produce truly owned data safe to delete:
/// - Constructor calls: Type(...), Type.new(...), Type.clone(...)
/// - String-allocating calls: format(...), concat(...), to_str(), to_lowercase()
/// - Collection constructors: Vec.new(...), Set.new(...), Map.new(...)
/// Variables from get/pop, field access, or other sources may be aliased.
is_owned_rhs := proc(rhs: Expr) returns Bool {
    switch rhs.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(rhs, chain)
        if chain.len().eq(0) {
            return false
        }
        mut last := ""
        chain.get(chain.len().sub(1), last)?
        catch (err: IndexOutOfBoundsError) {
            return false
        }
        // Known-allocating function names (last in chain)
        if last.eq("new").or(last.eq("clone")).or(last.eq("format")).or(last.eq("concat")).or(last.eq("to_str")).or(last.eq("to_lowercase")).or(last.eq("split")).or(last.eq("read_file")).or(last.eq("Str")).or(last.eq("Vec")).or(last.eq("Set")).or(last.eq("Map")).or(last.eq("Array")) {
            return true
        }
        // Constructor calls: single identifier matching a type name (e.g., MyStruct(...))
        // Skip namespace-qualified calls like "Lexer.peek" (contains dot).
        if chain.len().eq(1) {
            mut first := ""
            chain.get(0, first)?
            catch (err: IndexOutOfBoundsError) {
                return false
            }
            if not(first.contains(".")) {
                // Check if first character is uppercase (A=65, Z=90)
                first_char := first.char_at(0)
                if U8.to_i64(first_char).gteq(65).and(U8.to_i64(first_char).lteq(90)) {
                    return true
                }
            }
        }
        return false
    case:
        return false
    }
}

/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
/// Also excludes structs with no mutable fields (no heap data to free).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    if is_primitive {
        return false
    }
    mut struct_def := context.scope_stack.lookup_struct(type_name)?
    mut has_mut_fields := false
    for mi in 0..struct_def.members.len() {
        mut m := Declaration()
        struct_def.members.get(mi, m)?
        if m.is_mut {
            has_mut_fields = true
        }
    }
    return has_mut_fields

    catch (err: KeyNotFoundError) {
        return false
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in is_deletable_type: ", err.msg)
    }
}

/// Recursively check if any Identifier node in the expression tree matches var_name.
/// Recurses into e.params (covers if/while/for/switch bodies stored as params).
/// Does NOT recurse into nested FuncDef bodies (separate scope).
expr_references_var := func(e: Expr, var_name: Str) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(name):
        if name.eq(var_name) {
            return true
        }
    case:
    }
    // Recurse into params (but not into nested FuncDef bodies)
    for param: Expr in e.params {
        if expr_references_var(param, var_name) {
            return true
        }
    }
    // For FuncDef nodes, do NOT recurse into body (separate scope).
    // e.params on a FuncDef are only default arg values, already checked above.
    return false
}

/// Scan body from end to start, return index of last statement referencing the variable.
/// Returns -1 if not found.
find_last_use_index := func(body: Vec, var_name: Str) returns I64 {
    mut i := body.len().sub(1)
    while i.gteq(0) {
        mut stmt := Expr()
        body.get(i, stmt)?
        if expr_references_var(stmt, var_name) {
            return i
        }
        i = i.sub(1)
    }
    return I64.sub(0, 1)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in find_last_use_index: ", err.msg)
    }
}

/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}

/// Build AST for var = Type.clone(var): Assignment with RHS = clone FCall.
/// Used to break shallow-copy aliasing after container get/pop calls.
build_clone_assignment_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    clone_call := build_clone_call_expr(type_name, var_expr, line, col)
    mut assign := Expr(node_type=NodeType.Assignment(var_name), line=line, col=col)
    assign.params.push(clone_call)
    return assign
}

/// Check if stmt is a container get/pop call with a shallow-copy out-param.
/// Returns true if match, with var_name and type_name via out-params.
detect_shallow_copy_outparam := proc(stmt: Expr, local_types: Map, context: Context, mut out_var: Str, mut out_type: Str) returns Bool throws Str {
    switch stmt.node_type {
    case NodeType.FCall(_):
    case:
        return false
    }
    mut chain := Vec.new(Str)
    get_fcall_identifier_chain(stmt, chain)
    if chain.len().eq(0) {
        return false
    }
    mut resolved := ResolvedFCall()
    resolved = resolve_fcall_from_chain(chain, local_types, context)?
    catch (err: KeyNotFoundError) {
        return false
    }

    // Build "Type.method" name from resolved func_def's first arg type
    if resolved.func_def.args.len().eq(0) {
        return false
    }
    mut first_arg := Declaration()
    resolved.func_def.args.get(0, first_arg)?
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    mut self_type := ""
    switch first_arg.value_type {
    case ValueType.TCustom(t):
        self_type = t
    case:
        return false
    }
    mut method_name := ""
    chain.get(chain.len().sub(1), method_name)?
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    qualified := format(self_type, ".", method_name)

    // Check against whitelist
    mut whitelisted := false
    if qualified.eq("Vec.get").or(qualified.eq("Vec.pop")).or(qualified.eq("Array.get")).or(qualified.eq("Set.get")) {
        whitelisted = true
    }
    if qualified.eq("Map.get").or(qualified.eq("HashMap.get")).or(qualified.eq("List.get")).or(qualified.eq("List.pop")) {
        whitelisted = true
    }
    if not(whitelisted) {
        return false
    }

    // Find last mut arg (the out-param)
    last_arg_idx := resolved.func_def.args.len().sub(1)
    mut last_arg := Declaration()
    resolved.func_def.args.get(last_arg_idx, last_arg)?
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    if not(last_arg.is_mut) {
        return false
    }

    // Map to call-site param index
    mut param_idx := last_arg_idx.add(1)
    if resolved.is_ufcs {
        param_idx = last_arg_idx
    }
    if param_idx.gteq(stmt.params.len()) {
        return false
    }

    // Check if call-site param is a bare identifier
    mut param_expr := Expr()
    stmt.params.get(param_idx, param_expr)?
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    switch param_expr.node_type {
    case NodeType.Identifier(var_name):
        if param_expr.params.len().eq(0) {
            mut type_name := ""
            local_types.get(var_name, type_name)?
            catch (err: KeyNotFoundError) {
                return false
            }
            if is_deletable_type(type_name, context) {
                out_var = var_name
                out_type = type_name
                return true
            }
        }
    case:
    }
    return false
}

/// Insert clone assignments after container get/pop calls in a statement list.
/// Recurses into nested Body nodes but not into FuncDef bodies.
insert_clone_after_get := proc(stmts: Vec, local_types: Map, context: Context) returns Vec throws Str {
    mut result := Vec.new(Expr)
    for stmt: Expr in stmts {
        processed := process_stmt_for_clone_after_get(stmt, local_types, context)?
        mut det_var := ""
        mut det_type := ""
        needs_clone := detect_shallow_copy_outparam(processed, local_types, context, det_var, det_type)?
        det_line := processed.line
        det_col := processed.col
        result.push(processed)
        if needs_clone {
            result.push(build_clone_assignment_expr(det_type, det_var, det_line, det_col))
        }
    }
    return result
}

/// Process a single statement: recurse into Body children, leave FuncDef alone.
process_stmt_for_clone_after_get := proc(e: Expr, local_types: Map, context: Context) returns Expr throws Str {
    switch e.node_type {
    case NodeType.FuncDef(_):
        return e // separate scope, don't touch
    case NodeType.Body:
        new_children := insert_clone_after_get(e.params, local_types, context)?
        return Expr.new_explicit(e.node_type, new_children, e.line, e.col)
    case:
        // Recurse into params (covers if/while/for/switch which store bodies as params)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(process_stmt_for_clone_after_get(param, local_types, context)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Extract function name from FCall's first param (the name expression).
/// Returns "foo" for foo(x) or "Type.method" for Type.method(x).
get_func_name := func(e: Expr) returns Str {
    if e.params.len().eq(0) {
        return ""
    }
    mut name_expr := Expr()
    e.params.get(0, name_expr)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch name_expr.node_type {
    case NodeType.Identifier(name):
        // Check for Type.method pattern: Identifier("Type") with child Identifier("method")
        if name_expr.params.len().gt(0) {
            mut first_child := Expr()
            name_expr.params.get(0, first_child)?
            catch (err: IndexOutOfBoundsError) {
                return name
            }
            switch first_child.node_type {
            case NodeType.Identifier(method):
                return format(name, ".", method)
            case:
            }
        }
        return name
    case:
        return ""
    }
}

/// Check if an expression is an Identifier node.
is_identifier_expr := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(_):
        return true
    case:
        return false
    }
}

/// Transform FCall copy params: for each arg that is_copy, struct-typed, and an identifier,
/// wrap in Type.clone().
transform_fcall_copy_params := proc(context: Context, e: Expr, mut new_params: Vec) {
    func_name := get_func_name(e)
    if func_name.eq("") {
        return
    }

    // Skip .clone and .delete calls to avoid infinite recursion / double-free
    if func_name.ends_with(".clone").or(func_name.ends_with(".delete")) {
        return
    }

    // Early out: check if any args (params[1..]) are identifiers
    mut has_identifier_arg := false
    for check_i in 1..new_params.len() {
        mut check_param := Expr()
        new_params.get(check_i, check_param)?
        catch (err: IndexOutOfBoundsError) { }
        if is_identifier_expr(check_param) {
            has_identifier_arg = true
        }
    }
    if not(has_identifier_arg) {
        return
    }

    // Look up function definition to get arg metadata
    mut func_def := SFuncDef()
    mut found_func := false
    func_def = context.scope_stack.lookup_func(func_name)?
    found_func = true
    catch (err: KeyNotFoundError) { }
    if not(found_func) {
        return
    }

    // For each arg: if is_copy AND struct type AND identifier, wrap in Type.clone()
    for i in 0..func_def.args.len() {
        mut arg_def := Declaration()
        func_def.args.get(i, arg_def)?
        catch (err: IndexOutOfBoundsError) { }
        param_idx := i.add(1) // params[0] is the function name
        if param_idx.gteq(new_params.len()) {
            return
        }
        if not(arg_def.is_copy) {
            // skip
        } else {
            mut param_expr := Expr()
            new_params.get(param_idx, param_expr)?
            catch (err: IndexOutOfBoundsError) { }
            if not(is_identifier_expr(param_expr)) {
                // skip
            } else {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        arg_expr := param_expr.clone()
                        clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                        new_params.set(param_idx, clone_call)?
                        catch (err: IndexOutOfBoundsError) { }
                    }
                case:
                }
            }
        }
    }
}

/// Check if an expression is an FCall to `dont_delete`.
is_dont_delete_call := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        return func_name.eq("dont_delete")
    case:
        return false
    }
}

/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str {
    if e.params.len().lt(2) {
        return ""
    }
    mut param1 := Expr()
    e.params.get(1, param1)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}

/// Extract variable name from create_alias(var, type, addr) call.
get_create_alias_var := func(e: Expr) returns Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.eq("create_alias").and(e.params.len().gteq(3)) {
            mut param1 := Expr()
            e.params.get(1, param1)?
            catch (err: IndexOutOfBoundsError) {
                return ""
            }
            switch param1.node_type {
            case NodeType.Identifier(var_name):
                return var_name
            case:
            }
        }
    case:
    }
    return ""
}

/// Result of resolving a function call, including UFCS detection.
ResolvedFCall := struct {
    mut func_def: SFuncDef = SFuncDef()
    mut is_ufcs: Bool = false
}

/// Walk an FCall's name expression to extract the full identifier chain.
/// e.g., for `self.frames.push(frame)`, returns ["self", "frames", "push"]
get_fcall_identifier_chain := proc(e: Expr, mut chain: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            mut first := Expr()
            e.params.get(0, first)?
            collect_identifier_chain(first, chain)
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        // REM: empty params, no chain to extract
    }
}

collect_identifier_chain := proc(e: Expr, mut chain: Vec) {
    switch e.node_type {
    case NodeType.Identifier(name):
        chain.push(name)
        for child: Expr in e.params {
            collect_identifier_chain(child, chain)
        }
    case:
    }
}

/// Resolve a function call from its identifier chain, handling UFCS and chained field access.
/// For UFCS calls, self is implicit so arg-to-param mapping differs.
resolve_fcall_from_chain := proc(chain: Vec, local_types: Map, context: Context) returns ResolvedFCall throws Str, KeyNotFoundError {
    if chain.len().eq(0) {
        throw KeyNotFoundError(msg="resolve_fcall_from_chain: empty chain")
    }

    mut first := ""
    chain.get(0, first)?

    // Plain function call (no dots)
    if chain.len().eq(1) {
        mut result := ResolvedFCall()
        result.func_def = context.scope_stack.lookup_func(first)?
        return result
    }

    // Try direct lookup of the joined name (works for Type.method)
    mut full_name := ""
    for ji in 0..chain.len() {
        mut part := ""
        chain.get(ji, part)?
        if ji.gt(0) {
            full_name = format(full_name, ".")
        }
        full_name = format(full_name, part)
    }
    mut direct_result := ResolvedFCall()
    direct_result.func_def = context.scope_stack.lookup_func(full_name)?
    return direct_result

    catch (err: KeyNotFoundError) {
        // REM: Direct lookup failed, try UFCS resolution
    }

    // UFCS resolution: resolve type through the chain, last part is the method
    mut method_name := ""
    chain.get(chain.len().sub(1), method_name)?

    // Get initial type from struct name or local_types
    mut current_type := ""
    if context.scope_stack.has_struct(first) {
        current_type = first
    } else {
        local_types.get(first, current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: unknown first '", first, "'"))
        }
    }

    // Walk intermediate parts (chain[1..n-1]) via struct field type lookups
    for wi in 1..chain.len().sub(1) {
        mut field_name := ""
        chain.get(wi, field_name)?
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: struct not found '", current_type, "'"))
        }
        mut member := Declaration()
        member = struct_def.get_member(field_name)?
        switch member.value_type {
        case ValueType.TCustom(next_type):
            current_type = next_type
        case:
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: member '", field_name, "' is primitive"))
        }
    }

    resolved := format(current_type, ".", method_name)
    mut ufcs_result := ResolvedFCall(is_ufcs=true)
    ufcs_result.func_def = context.scope_stack.lookup_func(resolved)?
    return ufcs_result

    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: ", err.msg))
    }
}

collect_own_transfers := proc(stmts: Vec, context: Context, local_types: Map) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, local_types, result)?
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, local_types: Map, mut result: Vec) throws Str {
    switch e.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(e, chain)
        if chain.len().gt(0) {
            mut last := ""
            chain.get(chain.len().sub(1), last)?
            if not(last.eq("clone")).and(not(last.eq("delete"))) {
                mut resolved := ResolvedFCall()
                mut found := false
                resolved = resolve_fcall_from_chain(chain, local_types, context)?
                found = true
                catch (err: KeyNotFoundError) {
                    // REM: Function not found in scope - skip, not all calls are to known functions
                }
                if found {
                    // For UFCS calls (tokens.push(t)), self is implicit in the name,
                    // so skip args[0] (self) and map args[k] -> params[k] for k >= 1.
                    // For direct calls (Vec.push(tokens, t)), map args[i] -> params[i+1].
                    mut arg_start := 0
                    if resolved.is_ufcs {
                        arg_start = 1
                    }
                    for i in 0..resolved.func_def.args.len() {
                        if i.gteq(arg_start) {
                            mut arg_def := Declaration()
                            resolved.func_def.args.get(i, arg_def)?
                            mut param_idx := 0
                            if resolved.is_ufcs {
                                param_idx = i
                            } else {
                                param_idx = i.add(1)
                            }
                            if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                                mut param_expr := Expr()
                                e.params.get(param_idx, param_expr)?
                                switch param_expr.node_type {
                                case NodeType.Identifier(var_name):
                                    if param_expr.params.len().eq(0) {
                                        result.push(var_name)
                                    }
                                case:
                                }
                            }
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, local_types, result)?
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, local_types, result)?
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Issue #159 Step 5: Transform struct literal fields.
/// For struct literal constructors like Point(inner=some_var), if a NamedArg value
/// is an identifier pointing to a struct type, wrap it in Type.clone().
transform_struct_literal_fields := proc(context: Context, e: Expr, mut new_params: Vec) {
    // Extract the struct name from the original FCall (before child transforms)
    struct_name := get_func_name(e)
    if struct_name.eq("") {
        return
    }

    // Must be a plain struct name (no dots - not a method call)
    if struct_name.contains(".") {
        return
    }

    // Check if it's a struct
    mut struct_def := SStructDef()
    mut found_struct := false
    struct_def = context.scope_stack.lookup_struct(struct_name)?
    found_struct = true
    catch (err: KeyNotFoundError) { }
    if not(found_struct) {
        return
    }

    // For each child in new_params[1..] that is a NamedArg
    for param_idx in 1..new_params.len() {
        mut param := Expr()
        new_params.get(param_idx, param)?
        catch (err: IndexOutOfBoundsError) { }
        switch param.node_type {
        case NodeType.NamedArg(field_name):
            // Find matching field in struct def members
            mut field_decl := Declaration()
            mut found_field := false
            for member: Declaration in struct_def.members {
                if member.name.eq(field_name) {
                    field_decl = member
                    found_field = true
                }
            }
            if not(found_field) {
                // skip
            } else {
                // Check if field type is a non-primitive struct
                switch field_decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Check if the NamedArg's value (params[0]) is an identifier
                        if param.params.len().gt(0) {
                            mut value_expr := Expr()
                            param.params.get(0, value_expr)?
                            catch (err: IndexOutOfBoundsError) { }
                            if is_identifier_expr(value_expr) {
                                arg_expr := value_expr.clone()
                                clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                                param.params.set(0, clone_call)?
                                catch (err: IndexOutOfBoundsError) { }
                                new_params.set(param_idx, param)?
                                catch (err: IndexOutOfBoundsError) { }
                            }
                        }
                    }
                case:
                }
            }
        case:
        }
    }
}
