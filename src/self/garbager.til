mode liba

import("self.init")
import("self.parser")

// Garbager phase: AST transformations for memory semantics.
// This phase runs after type checking, before UFCS.
// Issue #159: Insert clone() calls for deep copy semantics on struct assignments.

/// Garbager phase entry point: Transform AST for proper memory semantics.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    return garbager_recursive(context, e)?
}

/// Recursively transform the AST.
garbager_recursive := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        mut new_body := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                // Step 2: Collect create_alias var names
                alias_var := get_create_alias_var(stmt)
                if alias_var.len().gt(0) {
                    dont_delete_vars.push(alias_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 2.5: Collect catch error variable names (they shadow locals in ccodegen)
        for catch_stmt: Expr in new_body {
            switch catch_stmt.node_type {
            case NodeType.Catch:
                if catch_stmt.params.len().gt(0) {
                    mut catch_name_expr := Expr()
                    catch_stmt.params.get(0, catch_name_expr)?
                    switch catch_name_expr.node_type {
                    case NodeType.Identifier(err_var_name):
                        dont_delete_vars.push(err_var_name)
                    case:
                    }
                }
            case:
            }
        }

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types.
        // Rule A: Only declarations whose initializer is a CONSTRUCTOR or
        // allocating static method (Type(), Type.new(), Type.clone()).
        // Regular function calls may return aliased (shallow-copied) data.
        for stmt: Expr in new_body {
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        if stmt.params.len().gt(0) {
                            mut init_expr := Expr()
                            stmt.params.get(0, init_expr)?
                            switch init_expr.node_type {
                            case NodeType.FCall(_):
                                if is_owned_return_fcall(init_expr, context)? {
                                    cand_vars.push(decl.name)
                                    cand_types.push(type_name)
                                }
                            case:
                            }
                        }
                    }
                case:
                }
            case:
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        // Build local name->type map for UFCS resolution in collect_own_transfers
        mut local_types := Map.new(Str, Str)
        for arg_def: Declaration in func_def.args {
            switch arg_def.value_type {
            case ValueType.TCustom(type_name):
                local_types.set(arg_def.name, type_name)
            case:
            }
        }
        for lt_stmt: Expr in new_body {
            switch lt_stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    local_types.set(decl.name, type_name)
                case:
                }
            case:
            }
        }
        own_transfers := collect_own_transfers(new_body, context, local_types)?
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            mut var_name := ""
            cand_vars.get(i, var_name)?
            mut type_name := ""
            cand_types.get(i, type_name)?
            mut excluded := var_name.eq("_")
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 4b: Rule B -- exclude reassigned candidates
        reassigned := collect_reassigned_vars(new_body, filtered_vars)?
        mut rb_vars := Vec.new(Str)
        mut rb_types := Vec.new(Str)
        for rbi in 0..filtered_vars.len() {
            mut rv := ""
            filtered_vars.get(rbi, rv)?
            mut rt := ""
            filtered_types.get(rbi, rt)?
            mut is_reassigned := false
            for ras: Str in reassigned {
                if ras.eq(rv) { is_reassigned = true }
            }
            if not(is_reassigned) {
                rb_vars.push(rv)
                rb_types.push(rt)
            }
        }
        filtered_vars = rb_vars
        filtered_types = rb_types

        // Step 4c: Rule C -- exclude escaped candidates
        escaped := collect_escaped_vars(new_body, filtered_vars, context, local_types)?
        mut rc_vars := Vec.new(Str)
        mut rc_types := Vec.new(Str)
        for rci in 0..filtered_vars.len() {
            mut rcv := ""
            filtered_vars.get(rci, rcv)?
            mut rct := ""
            filtered_types.get(rci, rct)?
            mut is_escaped := false
            for esc: Str in escaped {
                if esc.eq(rcv) { is_escaped = true }
            }
            if not(is_escaped) {
                rc_vars.push(rcv)
                rc_types.push(rct)
            }
        }
        filtered_vars = rc_vars
        filtered_types = rc_types

        // Step 5: ASAP delete after last use for all candidates
        body_len := new_body.len()
        mut insert_positions := Vec.new(I64)
        mut insert_del_calls := Vec.new(Expr)
        mut ri := filtered_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            mut del_var := ""
            filtered_vars.get(ri, del_var)?
            mut del_type := ""
            filtered_types.get(ri, del_type)?
            last_use := find_last_use_index(new_body, del_var)
            mut insert_pos := body_len
            if last_use.gteq(0) {
                insert_pos = last_use.add(1)
            }
            mut del_line := e.line
            mut del_col := e.col
            if insert_pos.gt(0).and(insert_pos.lteq(body_len)) {
                mut prev_stmt := Expr()
                new_body.get(insert_pos.sub(1), prev_stmt)?
                del_line = prev_stmt.line
                del_col = prev_stmt.col
            } else {
                if new_body.len().gt(0) {
                    mut last_s := Expr()
                    new_body.get(new_body.len().sub(1), last_s)?
                    del_line = last_s.line
                    del_col = last_s.col
                }
            }
            insert_positions.push(insert_pos)
            insert_del_calls.push(build_delete_call_expr(del_type, del_var, del_line, del_col))
        }

        // Build final_body: original statements with ASAP deletes interleaved
        mut final_body := Vec.new(Expr)
        for i in 0..body_len {
            mut body_stmt := Expr()
            new_body.get(i, body_stmt)?
            final_body.push(body_stmt)
            for di in 0..insert_positions.len() {
                mut dpos := 0
                insert_positions.get(di, dpos)?
                if dpos.eq(i.add(1)) {
                    mut dc := Expr()
                    insert_del_calls.get(di, dc)?
                    final_body.push(dc)
                }
            }
        }

        // TODO Bug #165: Process nested bodies for ASAP deletion within
        // if/while/for/switch blocks. Currently disabled because switch arm
        // payload variables and other complex aliasing patterns cause
        // double-frees. The function-level ASAP deletion already handles
        // the main memory leak cases.
        // final_body = process_nested_bodies(final_body, context, local_types)?
        new_body = final_body

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)

    // Recurse into StructDef default values
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            mut value_expr := Expr()
            struct_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_struct_def := SStructDef(
            members=struct_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), new_params, e.line, e.col)

    // Recurse into NamespaceDef default values
    case NodeType.NamespaceDef(ns_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in ns_def.default_values.keys {
            mut value_expr := Expr()
            ns_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_ns_def := SNamespaceDef(
            type_name=ns_def.type_name,
            members=ns_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.NamespaceDef(new_ns_def), new_params, e.line, e.col)

    // Issue #159: Transform mut declarations with struct type where RHS is an identifier
    case NodeType.Declaration(decl):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }

        // Check if this is a mut declaration with struct type and identifier RHS
        // Identifier can have field access (x.y.z), we clone any identifier-based RHS
        if decl.is_mut.and(new_params.len().gt(0)) {
            mut first_param := Expr()
            new_params.get(0, first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch first_param.node_type {
            case NodeType.Identifier(_):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Exclude true primitive types - they don't need deep cloning
                    // Note: Bool is NOT excluded because true/false are global constants
                    // that would be corrupted if we just share offsets
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(new_params.len()) {
                            mut param := Expr()
                            new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159: Transform FCall copy params with struct type where arg is an identifier
    case NodeType.FCall(_):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        // Transform copy params: wrap struct identifier args in Type.clone()
        transform_fcall_copy_params(context, e, new_params)
        // Issue #159 Step 5: Transform struct literal fields
        transform_struct_literal_fields(context, e, new_params)
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159 Step 6: Transform assignments with struct type where RHS is an identifier
    case NodeType.Assignment(var_name):
        // First, recursively transform children
        mut assign_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            assign_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if RHS is a bare identifier (no field access children)
        // Field access expressions (x.y.z) are skipped - they read from memory directly
        if assign_new_params.len().gt(0) {
            mut assign_first_param := Expr()
            assign_new_params.get(0, assign_first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch assign_first_param.node_type {
            case NodeType.Identifier(rhs_name):
                if assign_first_param.params.len().eq(0) {
                // Look up identifier's symbol type
                assign_sym := context.scope_stack.lookup_symbol(rhs_name)?
                catch (err: KeyNotFoundError) {
                    // Symbol not found - no transformation needed
                    return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)
                }
                switch assign_sym.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := assign_first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(assign_new_params.len()) {
                            mut param := Expr()
                            assign_new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
                } // end if bare identifier
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)

    // Body: recurse into children
    case NodeType.Body:
        mut body_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            body_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, body_new_params, e.line, e.col)

    // Default: recurse into children
    case:
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Build AST for Type.clone(src_expr): FCall( Identifier("Type").Identifier("clone"), src_expr )
build_clone_call_expr := func(type_name: Str, src_expr: Expr, line: I64, col: I64) returns Expr {
    // Type.clone access: Identifier("Type") with child Identifier("clone")
    clone_ident := Expr(node_type=NodeType.Identifier("clone"), line=line, col=col)
    mut type_clone_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_clone_access.params.push(clone_ident)

    // FCall node with the source expression as argument
    mut clone_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    clone_call.params.push(type_clone_access)
    clone_call.params.push(src_expr)
    return clone_call
}

/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
/// Also excludes structs with no mutable fields (no heap data to free).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    if is_primitive {
        return false
    }
    mut struct_def := context.scope_stack.lookup_struct(type_name)?
    mut has_mut_fields := false
    for mi in 0..struct_def.members.len() {
        mut m := Declaration()
        struct_def.members.get(mi, m)?
        if m.is_mut {
            has_mut_fields = true
        }
    }
    return has_mut_fields

    catch (err: KeyNotFoundError) {
        return false
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in is_deletable_type: ", err.msg)
    }
}

/// Check if an FCall expression returns owned (freshly-allocated) data safe to
/// ASAP-delete. In TIL/C, function returns are shallow memcpy -- the caller
/// gets a copy that may share heap pointers with data owned by someone else.
/// Only constructors, allocating static methods, and known-allocating instance
/// methods return truly owned data.
is_owned_return_fcall := proc(fcall_expr: Expr, context: Context) returns Bool throws Str {
    mut chain := Vec.new(Str)
    get_fcall_identifier_chain(fcall_expr, chain)
    if chain.len().eq(0) { return false }

    // Single-element chain: constructor call like SFuncDef() or Vec()
    if chain.len().eq(1) {
        mut first := ""
        chain.get(0, first)?
        return context.scope_stack.has_struct(first)
    }

    // Two-element chain: static method like Vec.new(T) or Type.clone(x)
    if chain.len().eq(2) {
        mut first := ""
        chain.get(0, first)?
        if context.scope_stack.has_struct(first) {
            mut method := ""
            chain.get(1, method)?
            return method.eq("new").or(method.starts_with("new_")).or(method.eq("clone"))
        }
    }

    // Known instance methods that always return freshly-allocated data.
    // These allocate new heap memory for their return value.
    mut last_idx := chain.len().sub(1)
    mut last := ""
    chain.get(last_idx, last)?
    if last.eq("to_str").or(last.eq("to_str_with_indent")).or(last.eq("lang_error")).or(last.eq("lang_error_with_path")).or(last.eq("format")).or(last.eq("concat")).or(last.eq("split")).or(last.eq("replace")).or(last.eq("trim")).or(last.eq("trim_start")).or(last.eq("trim_end")).or(last.eq("substring")).or(last.eq("substr")).or(last.eq("repeat")).or(last.eq("to_lower")).or(last.eq("to_upper")).or(last.eq("join")).or(last.eq("slice")) {
        return true
    }

    return false

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Recursively check if any Identifier node in the expression tree matches var_name.
/// Recurses into e.params (covers if/while/for/switch bodies stored as params).
/// Does NOT recurse into nested FuncDef bodies (separate scope).
expr_references_var := func(e: Expr, var_name: Str) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(name):
        if name.eq(var_name) {
            return true
        }
    case:
    }
    // Recurse into params (but not into nested FuncDef bodies)
    for param: Expr in e.params {
        if expr_references_var(param, var_name) {
            return true
        }
    }
    // For FuncDef nodes, do NOT recurse into body (separate scope).
    // e.params on a FuncDef are only default arg values, already checked above.
    return false
}

/// Scan body from end to start, return index of last statement referencing the variable.
/// Returns -1 if not found.
find_last_use_index := func(body: Vec, var_name: Str) returns I64 {
    mut i := body.len().sub(1)
    while i.gteq(0) {
        mut stmt := Expr()
        body.get(i, stmt)?
        if expr_references_var(stmt, var_name) {
            return i
        }
        i = i.sub(1)
    }
    return I64.sub(0, 1)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in find_last_use_index: ", err.msg)
    }
}

/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}

/// Extract function name from FCall's first param (the name expression).
/// Returns "foo" for foo(x) or "Type.method" for Type.method(x).
get_func_name := func(e: Expr) returns Str {
    if e.params.len().eq(0) {
        return ""
    }
    mut name_expr := Expr()
    e.params.get(0, name_expr)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch name_expr.node_type {
    case NodeType.Identifier(name):
        // Check for Type.method pattern: Identifier("Type") with child Identifier("method")
        if name_expr.params.len().gt(0) {
            mut first_child := Expr()
            name_expr.params.get(0, first_child)?
            catch (err: IndexOutOfBoundsError) {
                return name
            }
            switch first_child.node_type {
            case NodeType.Identifier(method):
                return format(name, ".", method)
            case:
            }
        }
        return name
    case:
        return ""
    }
}

/// Check if an expression is an Identifier node.
is_identifier_expr := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(_):
        return true
    case:
        return false
    }
}

/// Transform FCall copy params: for each arg that is_copy, struct-typed, and an identifier,
/// wrap in Type.clone().
transform_fcall_copy_params := proc(context: Context, e: Expr, mut new_params: Vec) {
    func_name := get_func_name(e)
    if func_name.eq("") {
        return
    }

    // Skip .clone and .delete calls to avoid infinite recursion / double-free
    if func_name.ends_with(".clone").or(func_name.ends_with(".delete")) {
        return
    }

    // Early out: check if any args (params[1..]) are identifiers
    mut has_identifier_arg := false
    for check_i in 1..new_params.len() {
        mut check_param := Expr()
        new_params.get(check_i, check_param)?
        catch (err: IndexOutOfBoundsError) { }
        if is_identifier_expr(check_param) {
            has_identifier_arg = true
        }
    }
    if not(has_identifier_arg) {
        return
    }

    // Look up function definition to get arg metadata
    mut func_def := SFuncDef()
    mut found_func := false
    func_def = context.scope_stack.lookup_func(func_name)?
    found_func = true
    catch (err: KeyNotFoundError) { }
    if not(found_func) {
        return
    }

    // For each arg: if is_copy AND struct type AND identifier, wrap in Type.clone()
    for i in 0..func_def.args.len() {
        mut arg_def := Declaration()
        func_def.args.get(i, arg_def)?
        catch (err: IndexOutOfBoundsError) { }
        param_idx := i.add(1) // params[0] is the function name
        if param_idx.gteq(new_params.len()) {
            return
        }
        if not(arg_def.is_copy) {
            // skip
        } else {
            mut param_expr := Expr()
            new_params.get(param_idx, param_expr)?
            catch (err: IndexOutOfBoundsError) { }
            if not(is_identifier_expr(param_expr)) {
                // skip
            } else {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        arg_expr := param_expr.clone()
                        clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                        new_params.set(param_idx, clone_call)?
                        catch (err: IndexOutOfBoundsError) { }
                    }
                case:
                }
            }
        }
    }
}

/// Check if an expression is an FCall to `dont_delete`.
is_dont_delete_call := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        return func_name.eq("dont_delete")
    case:
        return false
    }
}

/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str {
    if e.params.len().lt(2) {
        return ""
    }
    mut param1 := Expr()
    e.params.get(1, param1)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}

/// Extract variable name from create_alias(var, type, addr) call.
get_create_alias_var := func(e: Expr) returns Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.eq("create_alias").and(e.params.len().gteq(3)) {
            mut param1 := Expr()
            e.params.get(1, param1)?
            catch (err: IndexOutOfBoundsError) {
                return ""
            }
            switch param1.node_type {
            case NodeType.Identifier(var_name):
                return var_name
            case:
            }
        }
    case:
    }
    return ""
}

/// Result of resolving a function call, including UFCS detection.
ResolvedFCall := struct {
    mut func_def: SFuncDef = SFuncDef()
    mut is_ufcs: Bool = false
}

/// Walk an FCall's name expression to extract the full identifier chain.
/// e.g., for `self.frames.push(frame)`, returns ["self", "frames", "push"]
get_fcall_identifier_chain := proc(e: Expr, mut chain: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            mut first := Expr()
            e.params.get(0, first)?
            collect_identifier_chain(first, chain)
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        // REM: empty params, no chain to extract
    }
}

collect_identifier_chain := proc(e: Expr, mut chain: Vec) {
    switch e.node_type {
    case NodeType.Identifier(name):
        chain.push(name)
        for child: Expr in e.params {
            collect_identifier_chain(child, chain)
        }
    case:
    }
}

/// Resolve a function call from its identifier chain, handling UFCS and chained field access.
/// For UFCS calls, self is implicit so arg-to-param mapping differs.
resolve_fcall_from_chain := proc(chain: Vec, local_types: Map, context: Context) returns ResolvedFCall throws Str, KeyNotFoundError {
    if chain.len().eq(0) {
        throw KeyNotFoundError(msg="resolve_fcall_from_chain: empty chain")
    }

    mut first := ""
    chain.get(0, first)?

    // Plain function call (no dots)
    if chain.len().eq(1) {
        mut result := ResolvedFCall()
        result.func_def = context.scope_stack.lookup_func(first)?
        return result
    }

    // Try direct lookup of the joined name (works for Type.method)
    mut full_name := ""
    for ji in 0..chain.len() {
        mut part := ""
        chain.get(ji, part)?
        if ji.gt(0) {
            full_name = format(full_name, ".")
        }
        full_name = format(full_name, part)
    }
    mut direct_result := ResolvedFCall()
    direct_result.func_def = context.scope_stack.lookup_func(full_name)?
    return direct_result

    catch (err: KeyNotFoundError) {
        // REM: Direct lookup failed, try UFCS resolution
    }

    // UFCS resolution: resolve type through the chain, last part is the method
    mut method_name := ""
    chain.get(chain.len().sub(1), method_name)?

    // Get initial type from struct name or local_types
    mut current_type := ""
    if context.scope_stack.has_struct(first) {
        current_type = first
    } else {
        local_types.get(first, current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: unknown first '", first, "'"))
        }
    }

    // Walk intermediate parts (chain[1..n-1]) via struct field type lookups
    for wi in 1..chain.len().sub(1) {
        mut field_name := ""
        chain.get(wi, field_name)?
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: struct not found '", current_type, "'"))
        }
        mut member := Declaration()
        member = struct_def.get_member(field_name)?
        switch member.value_type {
        case ValueType.TCustom(next_type):
            current_type = next_type
        case:
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: member '", field_name, "' is primitive"))
        }
    }

    resolved := format(current_type, ".", method_name)
    mut ufcs_result := ResolvedFCall(is_ufcs=true)
    ufcs_result.func_def = context.scope_stack.lookup_func(resolved)?
    return ufcs_result

    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: ", err.msg))
    }
}

collect_own_transfers := proc(stmts: Vec, context: Context, local_types: Map) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, local_types, result)?
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, local_types: Map, mut result: Vec) throws Str {
    switch e.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(e, chain)
        if chain.len().gt(0) {
            mut last := ""
            chain.get(chain.len().sub(1), last)?
            if not(last.eq("clone")).and(not(last.eq("delete"))) {
                mut resolved := ResolvedFCall()
                mut found := false
                resolved = resolve_fcall_from_chain(chain, local_types, context)?
                found = true
                catch (err: KeyNotFoundError) {
                    // REM: Function not found in scope - skip, not all calls are to known functions
                }
                if found {
                    // For UFCS calls (tokens.push(t)), self is implicit in the name,
                    // so skip args[0] (self) and map args[k] -> params[k] for k >= 1.
                    // For direct calls (Vec.push(tokens, t)), map args[i] -> params[i+1].
                    mut arg_start := 0
                    if resolved.is_ufcs {
                        arg_start = 1
                    }
                    for i in 0..resolved.func_def.args.len() {
                        if i.gteq(arg_start) {
                            mut arg_def := Declaration()
                            resolved.func_def.args.get(i, arg_def)?
                            mut param_idx := 0
                            if resolved.is_ufcs {
                                param_idx = i
                            } else {
                                param_idx = i.add(1)
                            }
                            if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                                mut param_expr := Expr()
                                e.params.get(param_idx, param_expr)?
                                switch param_expr.node_type {
                                case NodeType.Identifier(var_name):
                                    if param_expr.params.len().eq(0) {
                                        result.push(var_name)
                                    }
                                case:
                                }
                            }
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, local_types, result)?
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, local_types, result)?
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Issue #159 Step 5: Transform struct literal fields.
/// For struct literal constructors like Point(inner=some_var), if a NamedArg value
/// is an identifier pointing to a struct type, wrap it in Type.clone().
transform_struct_literal_fields := proc(context: Context, e: Expr, mut new_params: Vec) {
    // Extract the struct name from the original FCall (before child transforms)
    struct_name := get_func_name(e)
    if struct_name.eq("") {
        return
    }

    // Must be a plain struct name (no dots - not a method call)
    if struct_name.contains(".") {
        return
    }

    // Check if it's a struct
    mut struct_def := SStructDef()
    mut found_struct := false
    struct_def = context.scope_stack.lookup_struct(struct_name)?
    found_struct = true
    catch (err: KeyNotFoundError) { }
    if not(found_struct) {
        return
    }

    // For each child in new_params[1..] that is a NamedArg
    for param_idx in 1..new_params.len() {
        mut param := Expr()
        new_params.get(param_idx, param)?
        catch (err: IndexOutOfBoundsError) { }
        switch param.node_type {
        case NodeType.NamedArg(field_name):
            // Find matching field in struct def members
            mut field_decl := Declaration()
            mut found_field := false
            for member: Declaration in struct_def.members {
                if member.name.eq(field_name) {
                    field_decl = member
                    found_field = true
                }
            }
            if not(found_field) {
                // skip
            } else {
                // Check if field type is a non-primitive struct
                switch field_decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Check if the NamedArg's value (params[0]) is an identifier
                        if param.params.len().gt(0) {
                            mut value_expr := Expr()
                            param.params.get(0, value_expr)?
                            catch (err: IndexOutOfBoundsError) { }
                            if is_identifier_expr(value_expr) {
                                arg_expr := value_expr.clone()
                                clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                                param.params.set(0, clone_call)?
                                catch (err: IndexOutOfBoundsError) { }
                                new_params.set(param_idx, param)?
                                catch (err: IndexOutOfBoundsError) { }
                            }
                        }
                    }
                case:
                }
            }
        case:
        }
    }
}

/// Rule B: Collect variables that are reassigned after declaration.
/// B1: candidate appears as last arg of .get() or .pop() (out-param overwrite)
/// B2: candidate is target of Assignment (no dot in target name)
collect_reassigned_vars := proc(body: Vec, cand_vars: Vec) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in body {
        collect_reassigned_vars_recursive(stmt, cand_vars, result)?
    }
    return result
}

collect_reassigned_vars_recursive := proc(e: Expr, cand_vars: Vec, mut result: Vec) throws Str {
    // B1: FCall where method chain ends with "get" or "pop"
    switch e.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(e, chain)
        if chain.len().gt(0) {
            mut last_method := ""
            chain.get(chain.len().sub(1), last_method)?
            if last_method.eq("get").or(last_method.eq("pop")).or(last_method.eq("enum_get_payload")) {
                // Last param (the out-param) is the one that gets overwritten
                if e.params.len().gteq(2) {
                    mut last_param := Expr()
                    e.params.get(e.params.len().sub(1), last_param)?
                    switch last_param.node_type {
                    case NodeType.Identifier(var_name):
                        if last_param.params.len().eq(0) {
                            for cv: Str in cand_vars {
                                if cv.eq(var_name) {
                                    // Check not already in result
                                    mut already := false
                                    for r: Str in result {
                                        if r.eq(var_name) { already = true }
                                    }
                                    if not(already) {
                                        result.push(var_name)
                                    }
                                }
                            }
                        }
                    case:
                    }
                }
            }
        }
    case:
    }
    // B2: Assignment(target) where target has no dot
    switch e.node_type {
    case NodeType.Assignment(target):
        if not(target.contains(".")) {
            for cv: Str in cand_vars {
                if cv.eq(target) {
                    mut already := false
                    for r: Str in result {
                        if r.eq(target) { already = true }
                    }
                    if not(already) {
                        result.push(target)
                    }
                }
            }
        }
    case:
    }
    // Recurse into params but NOT into FuncDef bodies
    for param: Expr in e.params {
        collect_reassigned_vars_recursive(param, cand_vars, result)?
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("collect_reassigned_vars: ", err.msg)
    }
}

/// Rule C: Collect variables whose data escapes to other variables.
/// C1: candidate passed as non-receiver arg to push/set/insert
/// C2: candidate referenced in initializer of a declaration with deletable type
/// C3: candidate is RHS of a field assignment (Assignment with dot in target)
collect_escaped_vars := proc(body: Vec, cand_vars: Vec, context: Context, local_types: Map) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in body {
        collect_escaped_vars_recursive(stmt, cand_vars, context, local_types, result)?
    }
    return result
}

collect_escaped_vars_recursive := proc(e: Expr, cand_vars: Vec, context: Context, local_types: Map, mut result: Vec) throws Str {
    // C1: FCall where method chain ends with "push"/"set"/"insert"
    switch e.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(e, chain)
        if chain.len().gt(0) {
            mut last_method := ""
            chain.get(chain.len().sub(1), last_method)?
            if last_method.eq("push").or(last_method.eq("set")).or(last_method.eq("insert")) {
                // Determine data arg start index
                mut first_in_chain := ""
                chain.get(0, first_in_chain)?
                mut data_start := 1
                if context.scope_stack.has_struct(first_in_chain) {
                    data_start = 2
                }
                for pi in data_start..e.params.len() {
                    mut param_expr := Expr()
                    e.params.get(pi, param_expr)?
                    switch param_expr.node_type {
                    case NodeType.Identifier(var_name):
                        if param_expr.params.len().eq(0) {
                            for cv: Str in cand_vars {
                                if cv.eq(var_name) {
                                    mut already := false
                                    for r: Str in result {
                                        if r.eq(var_name) { already = true }
                                    }
                                    if not(already) {
                                        result.push(var_name)
                                    }
                                }
                            }
                        }
                    case:
                    }
                }
            }
            // C4: get_by_ref returns a pointer into the receiver's storage
            if last_method.eq("get_by_ref") {
                if chain.len().gteq(2) {
                    mut receiver := ""
                    chain.get(0, receiver)?
                    if not(context.scope_stack.has_struct(receiver)) {
                        for cv: Str in cand_vars {
                            if cv.eq(receiver) {
                                mut already := false
                                for r: Str in result {
                                    if r.eq(receiver) { already = true }
                                }
                                if not(already) {
                                    result.push(receiver)
                                }
                            }
                        }
                    }
                }
            }
        }
    case:
    }
    // C2: Declaration with deletable type -- check if initializer references any candidate
    switch e.node_type {
    case NodeType.Declaration(decl):
        switch decl.value_type {
        case ValueType.TCustom(type_name):
            if is_deletable_type(type_name, context) {
                if e.params.len().gt(0) {
                    mut init_expr := Expr()
                    e.params.get(0, init_expr)?
                    for cv: Str in cand_vars {
                        if expr_references_var(init_expr, cv) {
                            mut already := false
                            for r: Str in result {
                                if r.eq(cv) { already = true }
                            }
                            if not(already) {
                                result.push(cv)
                            }
                        }
                    }
                }
            }
        case:
        }
    case:
    }
    // C3: Assignment(target) where target has a dot -- RHS is bare Identifier candidate
    switch e.node_type {
    case NodeType.Assignment(target):
        if target.contains(".") {
            if e.params.len().gt(0) {
                mut rhs := Expr()
                e.params.get(0, rhs)?
                switch rhs.node_type {
                case NodeType.Identifier(var_name):
                    if rhs.params.len().eq(0) {
                        for cv: Str in cand_vars {
                            if cv.eq(var_name) {
                                mut already := false
                                for r: Str in result {
                                    if r.eq(var_name) { already = true }
                                }
                                if not(already) {
                                    result.push(var_name)
                                }
                            }
                        }
                    }
                case:
                }
            }
        }
    case:
    }
    // Recurse into params but NOT into FuncDef bodies
    for param: Expr in e.params {
        collect_escaped_vars_recursive(param, cand_vars, context, local_types, result)?
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("collect_escaped_vars: ", err.msg)
    }
}

/// Process a Body node's params: collect candidates, apply rules, insert ASAP deletes.
/// Returns (processed_stmts, nested_local_types) via out-params.
process_body_params := proc(body_stmts: Vec, context: Context, local_types: Map,
        default_line: I64, default_col: I64,
        mut out_stmts: Vec, mut out_local_types: Map) throws Str {
    // Update local_types with declarations from this body
    out_local_types = local_types.clone()
    for stmt: Expr in body_stmts {
        switch stmt.node_type {
        case NodeType.Declaration(decl):
            switch decl.value_type {
            case ValueType.TCustom(type_name):
                out_local_types.set(decl.name, type_name)
            case:
            }
        case:
        }
    }

    // Collect dont_delete vars from this body
    mut dont_delete_vars := Vec.new(Str)
    mut filtered_stmts := Vec.new(Expr)
    for stmt: Expr in body_stmts {
        if is_dont_delete_call(stmt) {
            dd_var := get_dont_delete_var(stmt)
            if dd_var.len().gt(0) {
                dont_delete_vars.push(dd_var)
            }
        } else {
            alias_var := get_create_alias_var(stmt)
            if alias_var.len().gt(0) {
                dont_delete_vars.push(alias_var)
            }
            filtered_stmts.push(stmt)
        }
    }

    // Rule A: Collect candidates (constructor/allocating FCall + deletable type)
    mut cand_vars := Vec.new(Str)
    mut cand_types := Vec.new(Str)
    for stmt: Expr in filtered_stmts {
        switch stmt.node_type {
        case NodeType.Declaration(decl):
            switch decl.value_type {
            case ValueType.TCustom(type_name):
                if is_deletable_type(type_name, context) {
                    if stmt.params.len().gt(0) {
                        mut init_expr := Expr()
                        stmt.params.get(0, init_expr)?
                        switch init_expr.node_type {
                        case NodeType.FCall(_):
                            if is_owned_return_fcall(init_expr, context)? {
                                cand_vars.push(decl.name)
                                cand_types.push(type_name)
                            }
                        case:
                        }
                    }
                }
            case:
            }
        case:
        }
    }

    // Filter: _, dont_delete_vars, own_transfers
    own_transfers := collect_own_transfers(filtered_stmts, context, out_local_types)?
    mut filt_vars := Vec.new(Str)
    mut filt_types := Vec.new(Str)
    for fi in 0..cand_vars.len() {
        mut fv := ""
        cand_vars.get(fi, fv)?
        mut ft := ""
        cand_types.get(fi, ft)?
        mut excluded := fv.eq("_")
        for dd: Str in dont_delete_vars {
            if dd.eq(fv) { excluded = true }
        }
        for ot: Str in own_transfers {
            if ot.eq(fv) { excluded = true }
        }
        if not(excluded) {
            filt_vars.push(fv)
            filt_types.push(ft)
        }
    }

    // Rule B: exclude reassigned
    reassigned := collect_reassigned_vars(filtered_stmts, filt_vars)?
    mut rb_vars := Vec.new(Str)
    mut rb_types := Vec.new(Str)
    for rbi in 0..filt_vars.len() {
        mut rv := ""
        filt_vars.get(rbi, rv)?
        mut rt := ""
        filt_types.get(rbi, rt)?
        mut is_reassigned := false
        for ras: Str in reassigned {
            if ras.eq(rv) { is_reassigned = true }
        }
        if not(is_reassigned) {
            rb_vars.push(rv)
            rb_types.push(rt)
        }
    }
    filt_vars = rb_vars
    filt_types = rb_types

    // Rule C: exclude escaped
    escaped := collect_escaped_vars(filtered_stmts, filt_vars, context, out_local_types)?
    mut rc_vars := Vec.new(Str)
    mut rc_types := Vec.new(Str)
    for rci in 0..filt_vars.len() {
        mut rcv := ""
        filt_vars.get(rci, rcv)?
        mut rct := ""
        filt_types.get(rci, rct)?
        mut is_escaped := false
        for esc: Str in escaped {
            if esc.eq(rcv) { is_escaped = true }
        }
        if not(is_escaped) {
            rc_vars.push(rcv)
            rc_types.push(rct)
        }
    }
    filt_vars = rc_vars
    filt_types = rc_types

    // ASAP insert delete calls
    nb_body_len := filtered_stmts.len()
    mut insert_positions := Vec.new(I64)
    mut insert_del_calls := Vec.new(Expr)
    mut ri := filt_vars.len()
    while ri.gt(0) {
        ri = ri.sub(1)
        mut del_var := ""
        filt_vars.get(ri, del_var)?
        mut del_type := ""
        filt_types.get(ri, del_type)?
        last_use := find_last_use_index(filtered_stmts, del_var)
        mut insert_pos := nb_body_len
        if last_use.gteq(0) {
            insert_pos = last_use.add(1)
        }
        mut del_line := default_line
        mut del_col := default_col
        if insert_pos.gt(0).and(insert_pos.lteq(nb_body_len)) {
            mut prev_stmt := Expr()
            filtered_stmts.get(insert_pos.sub(1), prev_stmt)?
            del_line = prev_stmt.line
            del_col = prev_stmt.col
        } else {
            if filtered_stmts.len().gt(0) {
                mut last_s := Expr()
                filtered_stmts.get(filtered_stmts.len().sub(1), last_s)?
                del_line = last_s.line
                del_col = last_s.col
            }
        }
        insert_positions.push(insert_pos)
        insert_del_calls.push(build_delete_call_expr(del_type, del_var, del_line, del_col))
    }

    out_stmts = Vec.new(Expr)
    for i in 0..nb_body_len {
        mut body_stmt := Expr()
        filtered_stmts.get(i, body_stmt)?
        out_stmts.push(body_stmt)
        for di in 0..insert_positions.len() {
            mut dpos := 0
            insert_positions.get(di, dpos)?
            if dpos.eq(i.add(1)) {
                mut dc := Expr()
                insert_del_calls.get(di, dc)?
                out_stmts.push(dc)
            }
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw loc().concat("process_body_params: ").concat(err.msg)
    }
}

/// Process nested Body nodes for ASAP deletion within if/while/for/switch blocks.
/// Walks each statement's params. For Body nodes, processes them (candidates + ASAP)
/// then recurses. For non-Body nodes, recurses into their params.
process_nested_bodies := proc(stmts: Vec, context: Context, local_types: Map) returns Vec throws Str {
    mut result := Vec.new(Expr)
    for stmt: Expr in stmts {
        mut new_params := Vec.new(Expr)
        for param: Expr in stmt.params {
            switch param.node_type {
            case NodeType.Body:
                // Process this Body: candidates + ASAP deletes
                mut processed_stmts := Vec.new(Expr)
                mut nested_local_types := Map.new(Str, Str)
                process_body_params(param.params, context, local_types,
                    param.line, param.col, processed_stmts, nested_local_types)?
                // Recurse into the processed body's statements
                recursed_stmts := process_nested_bodies(processed_stmts, context, nested_local_types)?
                new_params.push(Expr.new_explicit(NodeType.Body, recursed_stmts, param.line, param.col))
            case:
                // Recurse into non-Body params to find deeper nested bodies
                inner_result := process_nested_bodies(param.params, context, local_types)?
                new_params.push(Expr.new_explicit(param.node_type, inner_result, param.line, param.col))
            }
        }
        result.push(Expr.new_explicit(stmt.node_type, new_params, stmt.line, stmt.col))
    }
    return result
}
