mode liba

import("self.init")
import("self.parser")

// Garbager phase: AST transformations for memory semantics.
// This phase runs after type checking, before UFCS.
// Issue #159: Insert clone() calls for deep copy semantics on struct assignments.

/// Garbager phase entry point: Transform AST for proper memory semantics.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    return garbager_recursive(context, e)?
}

/// Recursively transform the AST.
garbager_recursive := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        mut new_body := Vec.new(Expr)
        for stmt: Expr in func_def.body {
            new_body.push(garbager_recursive(context, stmt)?)
        }
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)

    // Recurse into StructDef default values
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            mut value_expr := Expr()
            struct_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_struct_def := SStructDef(
            members=struct_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), new_params, e.line, e.col)

    // Recurse into NamespaceDef default values
    case NodeType.NamespaceDef(ns_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in ns_def.default_values.keys {
            mut value_expr := Expr()
            ns_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_ns_def := SNamespaceDef(
            type_name=ns_def.type_name,
            members=ns_def.members.clone(),
            default_values=new_default_values
        )
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.NamespaceDef(new_ns_def), new_params, e.line, e.col)

    // Issue #159: Transform mut declarations with struct type where RHS is an identifier
    case NodeType.Declaration(decl):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }

        // Check if this is a mut declaration with struct type and identifier RHS
        // Identifier can have field access (x.y.z), we clone any identifier-based RHS
        if decl.is_mut.and(new_params.len().gt(0)) {
            mut first_param := Expr()
            new_params.get(0, first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch first_param.node_type {
            case NodeType.Identifier(_):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Exclude true primitive types - they don't need deep cloning
                    // Note: Bool is NOT excluded because true/false are global constants
                    // that would be corrupted if we just share offsets
                    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Str")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
                    if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(new_params.len()) {
                            mut param := Expr()
                            new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159: Transform FCall copy params with struct type where arg is an identifier
    case NodeType.FCall(_):
        // First, recursively transform children
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        // Transform copy params: wrap struct identifier args in Type.clone()
        transform_fcall_copy_params(context, e, new_params)
        // Issue #159 Step 5: Transform struct literal fields
        transform_struct_literal_fields(context, e, new_params)
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)

    // Issue #159 Step 6: Transform assignments with struct type where RHS is an identifier
    case NodeType.Assignment(var_name):
        // First, recursively transform children
        mut assign_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            assign_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if RHS is a bare identifier (no field access children)
        // Field access expressions (x.y.z) are skipped - they read from memory directly
        if assign_new_params.len().gt(0) {
            mut assign_first_param := Expr()
            assign_new_params.get(0, assign_first_param)?
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch assign_first_param.node_type {
            case NodeType.Identifier(rhs_name):
                if assign_first_param.params.len().eq(0) {
                // Look up identifier's symbol type
                assign_sym := context.scope_stack.lookup_symbol(rhs_name)?
                catch (err: KeyNotFoundError) {
                    // Symbol not found - no transformation needed
                    return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)
                }
                switch assign_sym.value_type {
                case ValueType.TCustom(type_name):
                    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Str")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
                    if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
                        // Build clone call: Type.clone(rhs_expr)
                        rhs_expr := assign_first_param.clone()
                        clone_call := build_clone_call_expr(type_name, rhs_expr, e.line, e.col)
                        mut transformed_params := Vec.new(Expr)
                        transformed_params.push(clone_call)
                        mut i := 1
                        while i.lt(assign_new_params.len()) {
                            mut param := Expr()
                            assign_new_params.get(i, param)?
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            transformed_params.push(param)
                            i = i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
                } // end if bare identifier
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)

    // Default: recurse into children
    case:
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Build AST for Type.clone(src_expr): FCall( Identifier("Type").Identifier("clone"), src_expr )
build_clone_call_expr := func(type_name: Str, src_expr: Expr, line: I64, col: I64) returns Expr {
    // Type.clone access: Identifier("Type") with child Identifier("clone")
    clone_ident := Expr(node_type=NodeType.Identifier("clone"), line=line, col=col)
    mut type_clone_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_clone_access.params.push(clone_ident)

    // FCall node with the source expression as argument
    mut clone_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    clone_call.params.push(type_clone_access)
    clone_call.params.push(src_expr)
    return clone_call
}

/// Extract function name from FCall's first param (the name expression).
/// Returns "foo" for foo(x) or "Type.method" for Type.method(x).
get_func_name := func(e: Expr) returns Str {
    if e.params.len().eq(0) {
        return ""
    }
    mut name_expr := Expr()
    e.params.get(0, name_expr)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch name_expr.node_type {
    case NodeType.Identifier(name):
        // Check for Type.method pattern: Identifier("Type") with child Identifier("method")
        if name_expr.params.len().gt(0) {
            mut first_child := Expr()
            name_expr.params.get(0, first_child)?
            catch (err: IndexOutOfBoundsError) {
                return name
            }
            switch first_child.node_type {
            case NodeType.Identifier(method):
                return format(name, ".", method)
            case:
            }
        }
        return name
    case:
        return ""
    }
}

/// Check if an expression is an Identifier node.
is_identifier_expr := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(_):
        return true
    case:
        return false
    }
}

/// Transform FCall copy params: for each arg that is_copy, struct-typed, and an identifier,
/// wrap in Type.clone().
transform_fcall_copy_params := proc(context: Context, e: Expr, mut new_params: Vec) {
    func_name := get_func_name(e)
    if func_name.eq("") {
        return
    }

    // Skip .clone and .delete calls to avoid infinite recursion / double-free
    if func_name.ends_with(".clone").or(func_name.ends_with(".delete")) {
        return
    }

    // Early out: check if any args (params[1..]) are identifiers
    mut has_identifier_arg := false
    for check_i in 1..new_params.len() {
        mut check_param := Expr()
        new_params.get(check_i, check_param)?
        catch (err: IndexOutOfBoundsError) { }
        if is_identifier_expr(check_param) {
            has_identifier_arg = true
        }
    }
    if not(has_identifier_arg) {
        return
    }

    // Look up function definition to get arg metadata
    mut func_def := SFuncDef()
    mut found_func := false
    func_def = context.scope_stack.lookup_func(func_name)?
    found_func = true
    catch (err: KeyNotFoundError) { }
    if not(found_func) {
        return
    }

    // For each arg: if is_copy AND struct type AND identifier, wrap in Type.clone()
    for i in 0..func_def.args.len() {
        mut arg_def := Declaration()
        func_def.args.get(i, arg_def)?
        catch (err: IndexOutOfBoundsError) { }
        param_idx := i.add(1) // params[0] is the function name
        if param_idx.gteq(new_params.len()) {
            return
        }
        if not(arg_def.is_copy) {
            // skip
        } else {
            mut param_expr := Expr()
            new_params.get(param_idx, param_expr)?
            catch (err: IndexOutOfBoundsError) { }
            if not(is_identifier_expr(param_expr)) {
                // skip
            } else {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Str")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
                    if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
                        arg_expr := param_expr.clone()
                        clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                        new_params.set(param_idx, clone_call)?
                        catch (err: IndexOutOfBoundsError) { }
                    }
                case:
                }
            }
        }
    }
}

/// Issue #159 Step 5: Transform struct literal fields.
/// For struct literal constructors like Point(inner=some_var), if a NamedArg value
/// is an identifier pointing to a struct type, wrap it in Type.clone().
transform_struct_literal_fields := proc(context: Context, e: Expr, mut new_params: Vec) {
    // Extract the struct name from the original FCall (before child transforms)
    struct_name := get_func_name(e)
    if struct_name.eq("") {
        return
    }

    // Must be a plain struct name (no dots - not a method call)
    if struct_name.contains(".") {
        return
    }

    // Check if it's a struct
    mut struct_def := SStructDef()
    mut found_struct := false
    struct_def = context.scope_stack.lookup_struct(struct_name)?
    found_struct = true
    catch (err: KeyNotFoundError) { }
    if not(found_struct) {
        return
    }

    // For each child in new_params[1..] that is a NamedArg
    for param_idx in 1..new_params.len() {
        mut param := Expr()
        new_params.get(param_idx, param)?
        catch (err: IndexOutOfBoundsError) { }
        switch param.node_type {
        case NodeType.NamedArg(field_name):
            // Find matching field in struct def members
            mut field_decl := Declaration()
            mut found_field := false
            for member: Declaration in struct_def.members {
                if member.name.eq(field_name) {
                    field_decl = member
                    found_field = true
                }
            }
            if not(found_field) {
                // skip
            } else {
                // Check if field type is a non-primitive struct
                switch field_decl.value_type {
                case ValueType.TCustom(type_name):
                    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Str")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
                    if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
                        // Check if the NamedArg's value (params[0]) is an identifier
                        if param.params.len().gt(0) {
                            mut value_expr := Expr()
                            param.params.get(0, value_expr)?
                            catch (err: IndexOutOfBoundsError) { }
                            if is_identifier_expr(value_expr) {
                                arg_expr := value_expr.clone()
                                clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                                param.params.set(0, clone_call)?
                                catch (err: IndexOutOfBoundsError) { }
                                new_params.set(param_idx, param)?
                                catch (err: IndexOutOfBoundsError) { }
                            }
                        }
                    }
                case:
                }
            }
        case:
        }
    }
}
