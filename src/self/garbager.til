mode liba

import("self.init")
import("self.parser")

// Garbager phase: Auto-generates delete() methods for structs and inserts
// automatic delete() calls for ASAP destruction.
// This phase runs after desugarer, before ufcs.

/// Check if a type needs delete() called on it.
/// Primitives (I64, U8, Bool) have no-op delete, but we skip them for efficiency.
/// Enums are also skipped since they don't have delete methods.
needs_delete := func(context: Context, vt: ValueType) returns Bool {
    switch vt {
    case ValueType.TCustom(name):
        // Skip primitives - their delete() is a no-op
        if name.eq("I64").or(name.eq("U8")).or(name.eq("Bool")).or(name.eq("Type")).or(name.eq("Dynamic")) {
            return false
        }
        // Skip enums - they don't have delete methods
        mut is_enum := false
        _enum_def := context.scope_stack.lookup_enum(name)?
        is_enum = true  // Found enum
        catch (err: KeyNotFoundError) {
            // Not an enum
        }
        if is_enum {
            return false
        }
        // All other types (Str, Vec, Array, Map, Set, List, Ptr, structs) need delete
        return true
    case ValueType.TFunction(_ft):
        return false
    case ValueType.TType(_t):
        return false
    case ValueType.TMulti(_elem):
        return false
    case:
        return false
    }
}

/// Result of generating a delete method - contains the declaration and expression.
/// Used instead of tuple to maintain Rust/TIL parity (TIL doesn't have tuples).
DeleteMethodResult := struct {
    mut decl: Declaration = Declaration()
    mut expr: Expr = Expr()
}

/// Generate a delete() method for a struct that doesn't have one.
/// The method calls Type.delete(self.field) for each mutable field in reverse declaration order.
/// Uses post-UFCS form since garbager runs after typer (generated nodes won't have type annotations).
generate_delete_method := func(context: Context, struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns DeleteMethodResult {
    // Build: delete := proc(mut self: StructName) { Type.delete(self.field_n); ... Type.delete(self.field_0); }

    // Create the self parameter: mut self: StructName
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(struct_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    // Build the body: call delete() on each field in reverse order
    mut body_stmts := Vec.new(Expr)

    // Process fields in reverse order (like C++/Rust destructors)
    mut member_i := struct_def.members.len().sub(1)
    while member_i.gteq(0) {
        mut member := Declaration()
        struct_def.members.get(member_i, member)?
        catch (err: IndexOutOfBoundsError) {
            // Shouldn't happen
        }

        // Skip non-mut fields (constants/methods don't need delete)
        if member.is_mut {
            // Skip fields that don't need delete (primitives, enums)
            if needs_delete(context, member.value_type) {
                // Get the field's type name for post-UFCS form
                mut field_type_name := ""
                switch member.value_type {
                case ValueType.TCustom(name):
                    field_type_name = name
                case:
                    // Skip non-TCustom types
                }

                if field_type_name.len().gt(0) {
                    // Build: Type.delete(self.field_name) - post-UFCS form
                    // because garbager runs after typer, generated nodes won't have type annotations
                    mut type_delete_params := Vec.new(Expr)
                    type_delete_params.push(Expr.new_explicit(NodeType.Identifier("delete"), Vec.new(Expr), line, col))
                    type_delete_access := Expr.new_explicit(NodeType.Identifier(field_type_name), type_delete_params, line, col)

                    mut self_field_params := Vec.new(Expr)
                    self_field_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
                    self_field_access := Expr.new_explicit(NodeType.Identifier("self"), self_field_params, line, col)

                    // FCall for Type.delete(self.field_name)
                    mut delete_call_params := Vec.new(Expr)
                    delete_call_params.push(type_delete_access)
                    delete_call_params.push(self_field_access)
                    delete_call := Expr.new_explicit(NodeType.FCall(false), delete_call_params, line, col)

                    body_stmts.push(delete_call)
                }
            }
        }

        member_i.dec()
    }

    // Create the FuncDef
    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=body_stmts,
        source_path=""
    )

    // Create the declaration for the method
    method_decl := Declaration(
        name="delete",
        value_type=ValueType.TFunction(FunctionType.FTProc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=Ptr()
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)

    return DeleteMethodResult(decl=method_decl, expr=func_expr)
}

/// Process a function body to insert delete() calls.
/// TODO: Implement liveness analysis for ASAP destruction.
/// For now, just recursively process statements without inserting deletes.
process_func_body := proc(mut context: Context, body: Vec, _line: I64, _col: I64) returns Vec throws Str {
    // Just recursively process all statements for now
    mut processed_body := Vec.new(Expr)
    for stmt_i in 0..body.len() {
        mut stmt := Expr()
        body.get(stmt_i, stmt)?
        catch (err: IndexOutOfBoundsError) {}
        garbager_result := garbager_expr(context, stmt)?
        processed_body.push(garbager_result)
    }
    return processed_body
}

/// Garbager phase entry point: Recursively process AST to auto-generate delete methods.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Handle Declaration nodes - check for struct definitions that need delete method
    case NodeType.Declaration(decl):
        // Check if this is a struct definition
        if e.params.len().gt(0) {
            mut value_expr := Expr()
            e.params.get(0, value_expr)?
            catch (err: IndexOutOfBoundsError) {
                // Shouldn't happen since we checked len > 0
            }
            switch value_expr.node_type {
            case NodeType.StructDef(struct_def):
                // Check if struct already has a delete method (check both members and default_values)
                mut has_delete_in_members := false
                for mi in 0..struct_def.members.len() {
                    mut m := Declaration()
                    struct_def.members.get(mi, m)?
                    catch (err: IndexOutOfBoundsError) {}
                    if m.name.eq("delete") {
                        has_delete_in_members = true
                    }
                }
                mut has_delete_in_values := false
                mut dummy_expr := Expr()
                struct_def.default_values.get("delete", dummy_expr)?
                has_delete_in_values = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }
                has_delete := has_delete_in_members.or(has_delete_in_values)

                // Check if struct has any mutable fields (skip delete for empty/constant-only structs)
                mut has_mut_fields := false
                for mfi in 0..struct_def.members.len() {
                    mut mf := Declaration()
                    struct_def.members.get(mfi, mf)?
                    catch (err: IndexOutOfBoundsError) {}
                    if mf.is_mut {
                        has_mut_fields = true
                    }
                }

                if not(has_delete).and(has_mut_fields) {
                    // Generate delete method
                    delete_result := generate_delete_method(context, decl.name, struct_def, e.line, e.col)

                    // Create new struct def with delete method added
                    mut decl_new_members := struct_def.members.clone()
                    decl_new_members.push(delete_result.decl)

                    mut decl_new_default_values := Map.new(Str, Expr)
                    mut dvi := 0
                    while dvi.lt(struct_def.default_values.keys.len()) {
                        mut decl_name := ""
                        struct_def.default_values.keys.get(dvi, decl_name)?
                        catch (err: IndexOutOfBoundsError) {}
                        mut decl_val_expr := Expr()
                        struct_def.default_values.get(decl_name, decl_val_expr)?
                        catch (err: KeyNotFoundError) {}
                        decl_new_default_values.set(decl_name, garbager_expr(context, decl_val_expr)?)
                        dvi.inc()
                    }
                    decl_new_default_values.set("delete", delete_result.expr)

                    decl_new_struct_def := SStructDef(
                        members=decl_new_members,
                        default_values=decl_new_default_values
                    )

                    // Update the Context so UFCS can find the new delete method
                    context.scope_stack.declare_struct(decl.name, decl_new_struct_def)?

                    decl_new_struct_expr := Expr.new_clone(
                        NodeType.StructDef(decl_new_struct_def),
                        value_expr,
                        value_expr.params
                    )

                    mut decl_new_params := Vec.new(Expr)
                    decl_new_params.push(decl_new_struct_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, decl_new_params)
                }
            case:
                // Not a struct definition, fall through to default handling
            }
        }

        // Default: recurse into params
        mut decl_new_params2 := Vec.new(Expr)
        for dpi in 0..e.params.len() {
            mut decl_p := Expr()
            e.params.get(dpi, decl_p)?
            catch (err: IndexOutOfBoundsError) {}
            decl_new_params2.push(garbager_expr(context, decl_p)?)
        }
        return Expr.new_clone(e.node_type, e, decl_new_params2)
    // Recurse into FuncDef bodies with proper scope management
    case NodeType.FuncDef(func_def):
        context.scope_stack.push(ScopeType.Function)
        new_body := process_func_body(context, func_def.body, e.line, e.col)?
        _ := context.scope_stack.pop()?
        catch (err: IndexOutOfBoundsError) {}
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args,
            return_types=func_def.return_types,
            throw_types=func_def.throw_types,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)
    // Handle block-creating nodes with proper scope management
    case NodeType.Body:
        context.scope_stack.push(ScopeType.Block)
        mut body_new_params := Vec.new(Expr)
        for body_pi in 0..e.params.len() {
            mut body_p := Expr()
            e.params.get(body_pi, body_p)?
            catch (err: IndexOutOfBoundsError) {}
            body_new_params.push(garbager_expr(context, body_p)?)
        }
        _ := context.scope_stack.pop()?
        catch (err: IndexOutOfBoundsError) {}
        return Expr.new_clone(e.node_type, e, body_new_params)
    case NodeType.If:
        context.scope_stack.push(ScopeType.Block)
        mut if_new_params := Vec.new(Expr)
        for if_pi in 0..e.params.len() {
            mut if_p := Expr()
            e.params.get(if_pi, if_p)?
            catch (err: IndexOutOfBoundsError) {}
            if_new_params.push(garbager_expr(context, if_p)?)
        }
        _ := context.scope_stack.pop()?
        catch (err: IndexOutOfBoundsError) {}
        return Expr.new_clone(e.node_type, e, if_new_params)
    case NodeType.While:
        context.scope_stack.push(ScopeType.Block)
        mut while_new_params := Vec.new(Expr)
        for while_pi in 0..e.params.len() {
            mut while_p := Expr()
            e.params.get(while_pi, while_p)?
            catch (err: IndexOutOfBoundsError) {}
            while_new_params.push(garbager_expr(context, while_p)?)
        }
        _ := context.scope_stack.pop()?
        catch (err: IndexOutOfBoundsError) {}
        return Expr.new_clone(e.node_type, e, while_new_params)
    case NodeType.ForIn(_var_type_name):
        context.scope_stack.push(ScopeType.Block)
        mut forin_new_params := Vec.new(Expr)
        for forin_pi in 0..e.params.len() {
            mut forin_p := Expr()
            e.params.get(forin_pi, forin_p)?
            catch (err: IndexOutOfBoundsError) {}
            forin_new_params.push(garbager_expr(context, forin_p)?)
        }
        _ := context.scope_stack.pop()?
        catch (err: IndexOutOfBoundsError) {}
        return Expr.new_clone(e.node_type, e, forin_new_params)
    // Recurse into StructDef default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        mut sdef_new_default_values := Map.new(Str, Expr)
        mut struct_i := 0
        while struct_i.lt(struct_def.default_values.keys.len()) {
            mut sdef_name := ""
            struct_def.default_values.keys.get(struct_i, sdef_name)?
            mut sdef_value_expr := Expr()
            struct_def.default_values.get(sdef_name, sdef_value_expr)?
            sdef_new_default_values.set(sdef_name, garbager_expr(context, sdef_value_expr)?)
            struct_i.inc()
        }
        sdef_new_struct_def := SStructDef(
            members=struct_def.members,
            default_values=sdef_new_default_values
        )
        return Expr.new_clone(NodeType.StructDef(sdef_new_struct_def), e, e.params)
    // For all other nodes, recurse into params
    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut default_new_params := Vec.new(Expr)
            for default_pi in 0..e.params.len() {
                mut default_p := Expr()
                e.params.get(default_pi, default_p)?
                default_new_params.push(garbager_expr(context, default_p)?)
            }
            return Expr.new_clone(e.node_type, e, default_new_params)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("garbager_expr: IndexOutOfBoundsError: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("garbager_expr: KeyNotFoundError: ", err.msg)
    }
}
