mode liba

import("self.init")
import("self.parser")

// Garbager phase: Auto-generates delete() methods for structs and (future) inserts
// automatic delete() calls for ASAP destruction.
// This phase runs after desugarer, before precomp.

/// Result of generating a delete method - contains the declaration and expression.
/// Used instead of tuple to maintain Rust/TIL parity (TIL doesn't have tuples).
DeleteMethodResult := struct {
    mut decl: Declaration = Declaration()
    mut expr: Expr = Expr()
}

/// Generate a delete() method for a struct that doesn't have one.
/// The method calls field.delete() for each mutable field in reverse declaration order.
generate_delete_method := func(struct_name: Str, struct_def: SStructDef, line: I64, col: I64) returns DeleteMethodResult {
    // Build: delete := proc(mut self: StructName) { self.field_n.delete(); ... self.field_0.delete(); }

    // Create the self parameter: mut self: StructName
    self_decl := Declaration(
        name="self",
        value_type=ValueType.TCustom(struct_name),
        is_mut=true,
        is_copy=false,
        is_own=false,
        default_value=NULL
    )

    // Build the body: call delete() on each field in reverse order
    mut body_stmts := Vec.new(Expr)

    // Process fields in reverse order (like C++/Rust destructors)
    mut member_i := struct_def.members.len().sub(1)
    while member_i.gteq(0) {
        mut member := Declaration()
        struct_def.members.get(member_i, member)?
        catch (err: IndexOutOfBoundsError) {
            // Shouldn't happen
        }

        // Skip non-mut fields (constants/methods don't need delete)
        if member.is_mut {
            // Build: self.field_name.delete()
            // self.field_name.delete is: Identifier("self") [ Identifier("field_name"), Identifier("delete") ]
            mut delete_access_params := Vec.new(Expr)
            delete_access_params.push(Expr.new_explicit(NodeType.Identifier(member.name), Vec.new(Expr), line, col))
            delete_access_params.push(Expr.new_explicit(NodeType.Identifier("delete"), Vec.new(Expr), line, col))
            delete_access := Expr.new_explicit(NodeType.Identifier("self"), delete_access_params, line, col)

            // FCall for self.field_name.delete()
            mut delete_call_params := Vec.new(Expr)
            delete_call_params.push(delete_access)
            delete_call := Expr.new_explicit(NodeType.FCall(false), delete_call_params, line, col)

            body_stmts.push(delete_call)
        }

        member_i.dec()
    }

    // Create the FuncDef
    mut args := Vec.new(Declaration)
    args.push(self_decl)
    func_def := SFuncDef(
        function_type=FunctionType.FTProc,
        args=args,
        return_types=Vec.new(ValueType),
        throw_types=Vec.new(ValueType),
        body=body_stmts,
        source_path=""
    )

    // Create the declaration for the method
    method_decl := Declaration(
        name="delete",
        value_type=ValueType.TFunction(FunctionType.FTProc),
        is_mut=false,
        is_copy=false,
        is_own=false,
        default_value=NULL
    )

    func_expr := Expr.new_explicit(NodeType.FuncDef(func_def), Vec.new(Expr), line, col)

    return DeleteMethodResult(decl=method_decl, expr=func_expr)
}

/// Garbager phase entry point: Recursively process AST to auto-generate delete methods.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Handle Declaration nodes - check for struct definitions that need delete method
    case NodeType.Declaration(decl):
        // Check if this is a struct definition
        if e.params.len().gt(0) {
            mut value_expr := Expr()
            e.params.get(0, value_expr)?
            catch (err: IndexOutOfBoundsError) {
                // Shouldn't happen since we checked len > 0
            }
            switch value_expr.node_type {
            case NodeType.StructDef(struct_def):
                // Check if struct already has a delete method (check both members and default_values)
                mut has_delete_in_members := false
                for mi in 0..struct_def.members.len() {
                    mut m := Declaration()
                    struct_def.members.get(mi, m)?
                    catch (err: IndexOutOfBoundsError) {}
                    if m.name.eq("delete") {
                        has_delete_in_members = true
                    }
                }
                mut has_delete_in_values := false
                mut dummy_expr := Expr()
                struct_def.default_values.get("delete", dummy_expr)?
                has_delete_in_values = true
                catch (err: KeyNotFoundError) {
                    // Not found
                }
                has_delete := has_delete_in_members.or(has_delete_in_values)

                // Check if struct has any mutable fields (skip delete for empty/constant-only structs)
                mut has_mut_fields := false
                for mfi in 0..struct_def.members.len() {
                    mut mf := Declaration()
                    struct_def.members.get(mfi, mf)?
                    catch (err: IndexOutOfBoundsError) {}
                    if mf.is_mut {
                        has_mut_fields = true
                    }
                }

                if not(has_delete).and(has_mut_fields) {
                    // Generate delete method
                    delete_result := generate_delete_method(decl.name, struct_def, e.line, e.col)

                    // Create new struct def with delete method added
                    mut decl_new_members := struct_def.members.clone()
                    decl_new_members.push(delete_result.decl)

                    mut decl_new_default_values := Map.new(Str, Expr)
                    mut dvi := 0
                    while dvi.lt(struct_def.default_values.keys.len()) {
                        mut decl_name := ""
                        struct_def.default_values.keys.get(dvi, decl_name)?
                        catch (err: IndexOutOfBoundsError) {}
                        mut decl_val_expr := Expr()
                        struct_def.default_values.get(decl_name, decl_val_expr)?
                        catch (err: KeyNotFoundError) {}
                        decl_new_default_values.set(decl_name, garbager_expr(context, decl_val_expr)?)
                        dvi.inc()
                    }
                    decl_new_default_values.set("delete", delete_result.expr)

                    decl_new_struct_def := SStructDef(
                        members=decl_new_members,
                        default_values=decl_new_default_values
                    )

                    decl_new_struct_expr := Expr.new_clone(
                        NodeType.StructDef(decl_new_struct_def),
                        value_expr,
                        value_expr.params
                    )

                    mut decl_new_params := Vec.new(Expr)
                    decl_new_params.push(decl_new_struct_expr)
                    return Expr.new_clone(NodeType.Declaration(decl), e, decl_new_params)
                }
            case:
                // Not a struct definition, fall through to default handling
            }
        }

        // Default: recurse into params
        mut decl_new_params2 := Vec.new(Expr)
        for dpi in 0..e.params.len() {
            mut decl_p := Expr()
            e.params.get(dpi, decl_p)?
            catch (err: IndexOutOfBoundsError) {}
            decl_new_params2.push(garbager_expr(context, decl_p)?)
        }
        return Expr.new_clone(e.node_type, e, decl_new_params2)
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        mut new_body := Vec.new(Expr)
        for func_i in 0..func_def.body.len() {
            mut stmt := Expr()
            func_def.body.get(func_i, stmt)?
            new_body.push(garbager_expr(context, stmt)?)
        }
        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args,
            return_types=func_def.return_types,
            throw_types=func_def.throw_types,
            body=new_body,
            source_path=func_def.source_path
        )
        return Expr.new_clone(NodeType.FuncDef(new_func_def), e, e.params)
    // Recurse into StructDef default values (which may contain function defs)
    case NodeType.StructDef(struct_def):
        mut sdef_new_default_values := Map.new(Str, Expr)
        mut struct_i := 0
        while struct_i.lt(struct_def.default_values.keys.len()) {
            mut sdef_name := ""
            struct_def.default_values.keys.get(struct_i, sdef_name)?
            mut sdef_value_expr := Expr()
            struct_def.default_values.get(sdef_name, sdef_value_expr)?
            sdef_new_default_values.set(sdef_name, garbager_expr(context, sdef_value_expr)?)
            struct_i.inc()
        }
        sdef_new_struct_def := SStructDef(
            members=struct_def.members,
            default_values=sdef_new_default_values
        )
        return Expr.new_clone(NodeType.StructDef(sdef_new_struct_def), e, e.params)
    // For all other nodes, recurse into params
    case:
        if e.params.len().eq(0) {
            return e.clone()
        } else {
            mut new_params := Vec.new(Expr)
            for param_i in 0..e.params.len() {
                mut p := Expr()
                e.params.get(param_i, p)?
                new_params.push(garbager_expr(context, p)?)
            }
            return Expr.new_clone(e.node_type, e, new_params)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw format("garbager_expr: IndexOutOfBoundsError: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("garbager_expr: KeyNotFoundError: ", err.msg)
    }
}
