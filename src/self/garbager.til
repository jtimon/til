mode liba

import("self.init")
import("self.parser")

// Garbager phase: AST transformations for memory semantics.
// This phase runs after type checking, before UFCS.
// Issue #159: Insert clone() calls for deep copy semantics on struct assignments.

/// Garbager phase entry point: Transform AST for proper memory semantics.
garbager_expr : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    return garbager_recursive(context, e)?
}

/// Recursively transform the AST.
garbager_recursive : proc(mut context: Context, e: Expr) returns Expr throws Str = {
    switch e.node_type {
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls from the AST
        mut new_body := Vec.new(Expr)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                // dont_delete() call, strip from AST
            } else {
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Build local name->type map for clone-after-get and own-transfer detection
        mut local_types := Map.new(Str, Str)
        for arg_def: Declaration in func_def.sig.args {
            switch arg_def.value_type {
            case ValueType.TCustom(type_name):
                local_types.set(arg_def.name, type_name)
            case:
            }
        }
        for lt_stmt: Expr in new_body {
            switch lt_stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    local_types.set(decl.name, type_name)
                case:
                }
            case:
            }
        }

        // Step 2.7: Insert clone-after-get for container methods with shallow out-params.
        new_body = insert_clone_after_get(new_body, local_types, context)?

        new_func_def := FuncDef(
            sig=FuncSig(
                function_type=func_def.sig.function_type,
                args=func_def.sig.args,
                return_types=func_def.sig.return_types,
                throw_types=func_def.sig.throw_types
            ),
            arg_names=func_def.arg_names,
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)

    // Recurse into StructDef default values
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            value_expr := cast(Expr, struct_def.default_values.get(name)?)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        // Recurse into ns default values
        mut ns_new_default_values := Map.new(Str, Expr)
        for ns_name: Str in struct_def.ns.default_values.keys {
            ns_value_expr := cast(Expr, struct_def.ns.default_values.get(ns_name)?)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            ns_new_default_values.set(ns_name.clone(), garbager_recursive(context, ns_value_expr)?)
        }
        new_ns := NamespaceDef(
            members=struct_def.ns.members.clone(),
            default_values=ns_new_default_values
        )
        new_struct_def := StructDef(
            members=struct_def.members.clone(),
            default_values=new_default_values,
            ns=new_ns
        )
        mut struct_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            struct_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), struct_new_params, e.line, e.col)

    case NodeType.EnumDef(enum_def):
        mut enum_ns_new_default_values := Map.new(Str, Expr)
        for enum_ns_name: Str in enum_def.ns.default_values.keys {
            enum_ns_value_expr := cast(Expr, enum_def.ns.default_values.get(enum_ns_name)?)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            enum_ns_new_default_values.set(enum_ns_name.clone(), garbager_recursive(context, enum_ns_value_expr)?)
        }
        enum_new_ns := NamespaceDef(
            members=enum_def.ns.members.clone(),
            default_values=enum_ns_new_default_values
        )
        new_enum_def := EnumDef(
            variants=enum_def.variants,
            methods=enum_def.methods,
            ns=enum_new_ns
        )
        return Expr.new_clone(NodeType.EnumDef(new_enum_def), e, e.params)

    // Issue #159: Transform mut declarations with struct type where RHS is an identifier
    case NodeType.Declaration(decl):
        // First, recursively transform children
        mut decl_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            decl_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if this is a mut declaration with struct type and identifier RHS
        // Identifier can have field access (x.y.z), we clone any identifier-based RHS
        if decl.is_mut.and(decl_new_params.len().gt(0)) {
            first_param := cast(Expr, decl_new_params.get(0)?)
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch first_param.node_type {
            case NodeType.Identifier(_):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Build clone call: Type.clone(rhs_expr)
                    decl_rhs_expr := first_param.clone()
                    decl_clone_call := build_clone_call_expr(type_name, decl_rhs_expr, e.line, e.col)
                    mut decl_transformed_params := Vec.new(Expr)
                    decl_transformed_params.push(decl_clone_call)
                    mut decl_i := 1
                    while decl_i.lt(decl_new_params.len()) {
                        decl_param := cast(Expr, decl_new_params.get(decl_i)?)
                        catch (err: IndexOutOfBoundsError) {
                            throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                        }
                        decl_transformed_params.push(decl_param)
                        decl_i = decl_i.add(1)
                    }
                    return Expr.new_explicit(e.node_type, decl_transformed_params, e.line, e.col)
                case:
                    // Not a TCustom type
                }
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, decl_new_params, e.line, e.col)

    // Issue #159: Transform FCall copy params with struct type where arg is an identifier
    case NodeType.FCall(_):
        // First, recursively transform children
        mut fcall_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            fcall_new_params.push(garbager_recursive(context, param)?)
        }
        // Transform copy params: wrap struct identifier args in Type.clone()
        transform_fcall_copy_params(context, e, fcall_new_params)
        // Issue #159 Step 5: Transform struct literal fields
        transform_struct_literal_fields(context, e, fcall_new_params)
        return Expr.new_explicit(e.node_type, fcall_new_params, e.line, e.col)

    // Issue #159 Step 6: Transform assignments with struct type where RHS is an identifier
    case NodeType.Assignment(var_name):
        // First, recursively transform children
        mut assign_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            assign_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if RHS is a bare identifier (no field access children)
        // Field access expressions (x.y.z) are skipped - they read from memory directly
        if assign_new_params.len().gt(0) {
            assign_first_param := cast(Expr, assign_new_params.get(0)?)
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch assign_first_param.node_type {
            case NodeType.Identifier(rhs_name):
                assign_first_param_len := assign_first_param.params.len()
                if assign_first_param_len.eq(0) {
                // Look up identifier's symbol type
                assign_sym := context.scope_stack.lookup_symbol(rhs_name)?
                catch (err: KeyNotFoundError) {
                    // Symbol not found - no transformation needed
                    return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)
                }
                switch assign_sym.value_type {
                case ValueType.TCustom(type_name):
                    // Build clone call: Type.clone(rhs_expr)
                    assign_rhs_expr := assign_first_param.clone()
                    assign_clone_call := build_clone_call_expr(type_name, assign_rhs_expr, e.line, e.col)
                    mut assign_transformed_params := Vec.new(Expr)
                    assign_transformed_params.push(assign_clone_call)
                    mut assign_i := 1
                    while assign_i.lt(assign_new_params.len()) {
                        assign_param := cast(Expr, assign_new_params.get(assign_i)?)
                        catch (err: IndexOutOfBoundsError) {
                            throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                        }
                        assign_transformed_params.push(assign_param)
                        assign_i = assign_i.add(1)
                    }
                    return Expr.new_explicit(e.node_type, assign_transformed_params, e.line, e.col)
                case:
                    // Not a TCustom type
                }
                } // end if bare identifier
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)

    // Body: recurse into children, stripping dont_delete calls
    case NodeType.Body:
        mut body_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            if is_dont_delete_call(param) {
                // strip dont_delete from nested bodies
            } else {
                body_new_params.push(garbager_recursive(context, param)?)
            }
        }
        return Expr.new_explicit(e.node_type, body_new_params, e.line, e.col)

    // Desugared-away node types: reject with lang_error
    case NodeType.Switch:
        throw e.lang_error(context.path, "garbager", "Switch should have been desugared to if/else by desugarer phase")
    case NodeType.DefaultCase:
        throw e.lang_error(context.path, "garbager", "DefaultCase should have been desugared with Switch")
    case NodeType.Pattern(_):
        throw e.lang_error(context.path, "garbager", "Pattern should have been desugared with Switch")
    case NodeType.ForIn(_):
        throw e.lang_error(context.path, "garbager", "ForIn should have been desugared before garbager phase")

    // Default: recurse into children
    case:
        mut default_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            default_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, default_new_params, e.line, e.col)
    }
}

/// Check if a declaration's RHS expression is provably owned (not an alias).
/// Only locals with owned init are safe to delete at function end.
/// Aliases from shallow copies (memcpy) would cause double-free if deleted.
/// Build AST for Type.clone(src_expr): FCall( Identifier("Type").Identifier("clone"), src_expr )
build_clone_call_expr : func(type_name: Str, src_expr: Expr, line: I64, col: I64) returns Expr = {
    // Type.clone access: Identifier("Type") with child Identifier("clone")
    clone_ident := Expr(node_type=NodeType.Identifier("clone"), line=line, col=col)
    mut type_clone_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_clone_access.params.push(clone_ident)

    // FCall node with the source expression as argument
    mut clone_call := Expr(node_type=NodeType.FCall(FCallInfo()), line=line, col=col)
    clone_call.params.push(type_clone_access)
    clone_call.params.push(src_expr)
    return clone_call
}

/// Build AST for var = Type.clone(var): Assignment with RHS = clone FCall.
/// Used to break shallow-copy aliasing after container get/pop calls.
build_clone_assignment_expr : func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr = {
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    clone_call := build_clone_call_expr(type_name, var_expr, line, col)
    mut assign := Expr(node_type=NodeType.Assignment(var_name), line=line, col=col)
    assign.params.push(clone_call)
    return assign
}

/// Check if stmt is a container get/pop call with a shallow-copy out-param.
/// Returns true if match, with var_name and type_name via out-params.
detect_shallow_copy_outparam : proc(stmt: Expr, local_types: Map, context: Context, mut out_var: Str, mut out_type: Str) returns Bool = {
    switch stmt.node_type {
    case NodeType.FCall(_):
    case:
        return false
    }
    mut chain := Vec.new(Str)
    get_fcall_identifier_chain(stmt, chain)
    if chain.len().eq(0) {
        return false
    }
    mut resolved := ResolvedFCall()
    resolved = resolve_fcall_from_chain(chain, local_types, context)?
    catch (err: KeyNotFoundError) {
        return false
    }

    // Build "Type.method" name from resolved func_def's first arg type
    if resolved.func_def.sig.args.len().eq(0) {
        return false
    }
    first_arg := cast(Declaration, resolved.func_def.sig.args.get(0)?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    mut self_type := ""
    switch first_arg.value_type {
    case ValueType.TCustom(t):
        self_type = t
    case:
        return false
    }
    method_name := cast(Str, chain.get(chain.len().sub(1))?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    mut qualified := format(self_type, ".", method_name)

    // Check against whitelist
    mut whitelisted := false
    if qualified.eq("Vec.pop") {
        whitelisted = true
    }
    if qualified.eq("List.pop") {
        whitelisted = true
    }
    qualified.delete()
    if not(whitelisted) {
        return false
    }

    // Find last mut arg (the out-param)
    last_arg_idx := resolved.func_def.sig.args.len().sub(1)
    last_arg := cast(Declaration, resolved.func_def.sig.args.get(last_arg_idx)?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    if not(last_arg.is_mut) {
        return false
    }

    // Map to call-site param index
    mut param_idx := last_arg_idx.add(1)
    if resolved.is_ufcs {
        param_idx = last_arg_idx
    }
    if param_idx.gteq(stmt.params.len()) {
        return false
    }

    // Check if call-site param is a bare identifier
    param_expr := cast(Expr, stmt.params.get(param_idx)?)
    dont_delete(param_expr)
    switch param_expr.node_type {
    case NodeType.Identifier(var_name):
        if param_expr.params.len().eq(0) {
            type_name := cast(Str, local_types.get(var_name)?)
            catch (err: KeyNotFoundError) {
                return false
            }
            out_var = var_name
            out_type = type_name
            return true
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    return false
}

/// Insert clone assignments after container get/pop calls in a statement list.
/// Recurses into nested Body nodes but not into FuncDef bodies.
insert_clone_after_get : proc(stmts: Vec, local_types: Map, context: Context) returns Vec throws Str = {
    mut result := Vec.new(Expr)
    for stmt: Expr in stmts {
        processed := process_stmt_for_clone_after_get(stmt, local_types, context)?
        mut det_var := ""
        mut det_type := ""
        needs_clone := detect_shallow_copy_outparam(processed, local_types, context, det_var, det_type)
        det_line := processed.line
        det_col := processed.col
        result.push(processed)
        if needs_clone {
            result.push(build_clone_assignment_expr(det_type, det_var, det_line, det_col))
        }
    }
    return result
}

/// Process a single statement: recurse into Body children, leave FuncDef alone.
process_stmt_for_clone_after_get : proc(e: Expr, local_types: Map, context: Context) returns Expr throws Str = {
    switch e.node_type {
    case NodeType.FuncDef(_):
        return e // separate scope, don't touch
    case NodeType.Body:
        new_children := insert_clone_after_get(e.params, local_types, context)?
        return Expr.new_explicit(e.node_type, new_children, e.line, e.col)
    case:
        // Recurse into params (covers if/while/for/switch which store bodies as params)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(process_stmt_for_clone_after_get(param, local_types, context)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Extract function name from FCall's first param (the name expression).
/// Returns "foo" for foo(x) or "Type.method" for Type.method(x).
get_func_name : func(e: Expr) returns Str = {
    if e.params.len().eq(0) {
        return ""
    }
    name_expr := cast(Expr, e.params.get(0)?)
    dont_delete(name_expr)
    switch name_expr.node_type {
    case NodeType.Identifier(name):
        // Check for Type.method pattern: Identifier("Type") with child Identifier("method")
        if name_expr.params.len().gt(0) {
            first_child := cast(Expr, name_expr.params.get(0)?)
            dont_delete(first_child)
            switch first_child.node_type {
            case NodeType.Identifier(method):
                return format(name, ".", method)
            case:
            }
        }
        return name
    case:
        return ""
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

/// Check if an expression is an Identifier node.
is_identifier_expr : func(e: Expr) returns Bool = {
    switch e.node_type {
    case NodeType.Identifier(_):
        return true
    case:
        return false
    }
}

/// Transform FCall copy params: for each arg that is_copy, struct-typed, and an identifier,
/// wrap in Type.clone().
transform_fcall_copy_params : proc(context: Context, e: Expr, mut new_params: Vec) = {
    func_name := get_func_name(e)
    if func_name.eq("") {
        return
    }

    // Skip .clone and .delete calls to avoid infinite recursion / double-free
    if func_name.ends_with(".clone").or(func_name.ends_with(".delete")) {
        return
    }

    // Early out: check if any args (params[1..]) are identifiers
    mut has_identifier_arg := false
    for check_i in 1..new_params.len() {
        check_param := cast(Expr, new_params.get(check_i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in check_i loop: ", err.msg)
        }
        if is_identifier_expr(check_param) {
            has_identifier_arg = true
        }
    }
    if not(has_identifier_arg) {
        return
    }

    // Look up function definition to get arg metadata
    mut func_def := FuncDef()
    mut found_func := false
    func_def = context.scope_stack.lookup_func(func_name)?
    found_func = true
    catch (err: KeyNotFoundError) { }
    if not(found_func) {
        return
    }

    // For each arg: if is_copy AND struct type AND identifier, wrap in Type.clone()
    for i in 0..func_def.sig.args.len() {
        arg_def := cast(Declaration, func_def.sig.args.get(i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in args loop: ", err.msg)
        }
        param_idx := i.add(1) // params[0] is the function name
        if param_idx.gteq(new_params.len()) {
            return
        }
        if not(arg_def.is_copy) {
            // skip
        } else {
            param_expr := cast(Expr, new_params.get(param_idx)?)
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "IndexOutOfBoundsError getting param_expr: ", err.msg)
            }
            if not(is_identifier_expr(param_expr)) {
                // skip
            } else {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    arg_expr := param_expr.clone()
                    clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                    new_params.set(param_idx, clone_call)?
                    catch (err: IndexOutOfBoundsError) { }
                case:
                }
            }
        }
    }
}

/// Check if an expression is an FCall to `dont_delete`.
is_dont_delete_call : func(e: Expr) returns Bool = {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        return func_name.eq("dont_delete")
    case:
        return false
    }
}

/// Result of resolving a function call, including UFCS detection.
ResolvedFCall := struct {
    mut func_def: FuncDef = FuncDef()
    mut is_ufcs: Bool = false
}

/// Walk an FCall's name expression to extract the full identifier chain.
/// e.g., for `self.frames.push(frame)`, returns ["self", "frames", "push"]
get_fcall_identifier_chain : proc(e: Expr, mut chain: Vec) = {
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            first := cast(Expr, e.params.get(0)?)
            dont_delete(first)
            collect_identifier_chain(first, chain)
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

collect_identifier_chain : proc(e: Expr, mut chain: Vec) = {
    switch e.node_type {
    case NodeType.Identifier(name):
        chain.push(name)
        for child: Expr in e.params {
            collect_identifier_chain(child, chain)
        }
    case:
    }
}

/// Resolve a function call from its identifier chain, handling UFCS and chained field access.
/// For UFCS calls, self is implicit so arg-to-param mapping differs.
resolve_fcall_from_chain : proc(chain: Vec, local_types: Map, context: Context) returns ResolvedFCall throws KeyNotFoundError = {
    if chain.len().eq(0) {
        throw KeyNotFoundError(msg="resolve_fcall_from_chain: empty chain")
    }

    first := cast(Str, chain.get(0)?)

    // Plain function call (no dots)
    if chain.len().eq(1) {
        mut result := ResolvedFCall()
        result.func_def = context.scope_stack.lookup_func(first)?
        return result
    }

    // Try direct lookup of the joined name (works for Type.method)
    mut full_name := ""
    mut full_name_owned := false
    for ji in 0..chain.len() {
        part := cast(Str, chain.get(ji)?)
        if ji.gt(0) {
            mut old_fn := full_name
            full_name = format(full_name, ".")
            if full_name_owned { old_fn.delete() }
            full_name_owned = true
        }
        mut old_fn2 := full_name
        full_name = format(full_name, part)
        if full_name_owned { old_fn2.delete() }
        full_name_owned = true
    }
    mut direct_result := ResolvedFCall()
    direct_result.func_def = context.scope_stack.lookup_func(full_name)?
    if full_name_owned { full_name.delete() }
    return direct_result

    catch (err: KeyNotFoundError) {
        // REM: Direct lookup failed, try UFCS resolution
    }
    if full_name_owned { full_name.delete() }

    // UFCS resolution: resolve type through the chain, last part is the method
    method_name := cast(Str, chain.get(chain.len().sub(1))?)

    // Get initial type from struct name or local_types
    mut current_type := ""
    if context.scope_stack.has_struct(first) {
        current_type = first
    } else {
        current_type_alias := cast(Str, local_types.get(first)?)
        current_type = current_type_alias.clone()
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: unknown first '", first, "'"))
        }
    }

    // Walk intermediate parts (chain[1..n-1]) via struct field type lookups
    for wi in 1..chain.len().sub(1) {
        field_name := cast(Str, chain.get(wi)?)
        mut struct_def := StructDef()
        struct_def = context.scope_stack.lookup_struct(current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: struct not found '", current_type, "'"))
        }
        mut member := Declaration()
        member = struct_def.get_member(field_name)?
        catch (member_err: Str) {
            // Member not found (e.g., namespace mutable) - can't resolve chain
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: member '", field_name, "' not found in '", current_type, "'"))
        }
        switch member.value_type {
        case ValueType.TCustom(next_type):
            current_type = next_type
        case:
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: member '", field_name, "' is primitive"))
        }
    }

    mut resolved := format(current_type, ".", method_name)
    mut ufcs_result := ResolvedFCall(is_ufcs=true)
    ufcs_result.func_def = context.scope_stack.lookup_func(resolved)?
    resolved.delete()
    return ufcs_result

    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: ", err.msg))
    }
}

/// Issue #159 Step 5: Transform struct literal fields.
/// For struct literal constructors like Point(inner=some_var), if a NamedArg value
/// is an identifier pointing to a struct type, wrap it in Type.clone().
transform_struct_literal_fields : proc(context: Context, e: Expr, mut new_params: Vec) = {
    // Extract the struct name from the original FCall (before child transforms)
    struct_name := get_func_name(e)
    if struct_name.eq("") {
        return
    }

    // Must be a plain struct name (no dots - not a method call)
    if struct_name.contains(".") {
        return
    }

    // Check if it's a struct
    mut struct_def := StructDef()
    mut found_struct := false
    struct_def = context.scope_stack.lookup_struct(struct_name)?
    found_struct = true
    catch (err: KeyNotFoundError) { }
    if not(found_struct) {
        return
    }

    // For each child in new_params[1..] that is a NamedArg
    for param_idx in 1..new_params.len() {
        mut param := cast(Expr, new_params.get(param_idx)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError getting named arg param: ", err.msg)
        }
        switch param.node_type {
        case NodeType.NamedArg(field_name):
            // Find matching field in struct def members
            mut field_decl := Declaration()
            mut found_field := false
            for member: Declaration in struct_def.members {
                if member.name.eq(field_name) {
                    field_decl = member
                    found_field = true
                }
            }
            if not(found_field) {
                // skip
            } else {
                // Check if field type is a non-primitive struct
                switch field_decl.value_type {
                case ValueType.TCustom(type_name):
                    // Check if the NamedArg's value (params[0]) is an identifier
                    if param.params.len().gt(0) {
                        value_expr := cast(Expr, param.params.get(0)?)
                        dont_delete(value_expr)
                        if is_identifier_expr(value_expr) {
                            arg_expr := value_expr.clone()
                            clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                            param.params.set(0, clone_call)?
                            catch (err: IndexOutOfBoundsError) { }
                            new_params.set(param_idx, param)?
                            catch (err: IndexOutOfBoundsError) { }
                        }
                    }
                case:
                }
            }
        case:
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
