mode liba

import("self.init")
import("self.parser")

// Garbager phase: AST transformations for memory semantics.
// This phase runs after type checking, before UFCS.
// Issue #159: Insert clone() calls for deep copy semantics on struct assignments.

/// Garbager phase entry point: Transform AST for proper memory semantics.
garbager_expr := proc(mut context: Context, e: Expr) returns Expr throws Str {
    return garbager_recursive(context, e)?
}

/// Recursively transform the AST.
garbager_recursive := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    // Recurse into FuncDef bodies
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        // Pre-scan entire body tree recursively for dont_delete var names
        mut dont_delete_vars := garb_collect_dont_delete_vars_recursive(func_def.body)?
        mut new_body := Vec.new(Expr)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt)? {
                // already collected above, just skip
            } else {
                // Step 2: Collect cast var names
                cast_var := get_cast_var(stmt)?
                if cast_var.len().gt(0) {
                    dont_delete_vars.push(cast_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 2.5: Collect catch error variable names (they shadow locals in ccodegen)
        for catch_stmt: Expr in new_body {
            switch catch_stmt.node_type {
            case NodeType.Catch:
                if catch_stmt.params.len().gt(0) {
                    catch_name_expr := catch_stmt.get(0)?
                    dont_delete(catch_name_expr)
                    switch catch_name_expr.node_type {
                    case NodeType.Identifier(err_var_name):
                        dont_delete_vars.push(err_var_name)
                    case:
                    }
                }
            case:
            }
        }

        // Build local name->type map for clone-after-get and own-transfer detection
        mut local_types := Map.new(Str, Str)
        for arg_def: Declaration in func_def.args {
            switch arg_def.value_type {
            case ValueType.TCustom(type_name):
                local_types.set(arg_def.name, type_name)
            case:
            }
        }
        for lt_stmt: Expr in new_body {
            switch lt_stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    local_types.set(decl.name, type_name)
                case:
                }
            case:
            }
        }

        // Step 2.7: Insert clone-after-get for container methods with shallow out-params.
        new_body = insert_clone_after_get(new_body, local_types, context)?

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types.
        // Skip if function has any catch blocks: throws can skip declarations,
        // making unconditional deletes at function end unsafe.
        mut has_any_catch := false
        for catch_check_stmt: Expr in new_body {
            switch catch_check_stmt.node_type {
            case NodeType.Catch:
                has_any_catch = true
            case:
            }
        }
        if not(has_any_catch) {
            for stmt: Expr in new_body {
                switch stmt.node_type {
                case NodeType.Declaration(decl):
                    switch decl.value_type {
                    case ValueType.TCustom(type_name):
                        if is_deletable_type(type_name, context) {
                            cand_vars.push(decl.name)
                            cand_types.push(type_name)
                        }
                    case:
                    }
                case:
                }
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        own_transfers := collect_own_transfers(new_body, context, local_types)?
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            var_name := cast(Str, cand_vars.get_by_ref(i)?)
            type_name := cast(Str, cand_types.get_by_ref(i)?)
            mut excluded := var_name.eq("_")
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 5: Insert Type.delete(var) calls.
        // copy/own params: ASAP after last use (deep copies, no aliasing).
        // locals: at function end (shared offsets mean locals can alias).
        mut param_names := Vec.new(Str)
        for parg: Declaration in func_def.args {
            if parg.is_copy.or(parg.is_own) {
                param_names.push(parg.name)
            }
        }

        // Separate params (ASAP) from locals (end-of-function)
        mut asap_vars := Vec.new(Str)
        mut asap_types := Vec.new(Str)
        mut end_vars := Vec.new(Str)
        mut end_types := Vec.new(Str)
        for ci in 0..filtered_vars.len() {
            cv := cast(Str, filtered_vars.get_by_ref(ci)?)
            ct := cast(Str, filtered_types.get_by_ref(ci)?)
            mut is_param := false
            for pn: Str in param_names {
                if pn.eq(cv) { is_param = true }
            }
            if is_param {
                asap_vars.push(cv)
                asap_types.push(ct)
            } else {
                end_vars.push(cv)
                end_types.push(ct)
            }
        }

        // ASAP: insert after last use for copy/own params
        body_len := new_body.len()
        mut insert_positions := Vec.new(I64)
        mut insert_del_calls := Vec.new(Expr)
        mut ri := asap_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            del_var := cast(Str, asap_vars.get_by_ref(ri)?)
            del_type := cast(Str, asap_types.get_by_ref(ri)?)
            last_use := find_last_use_index(new_body, del_var)
            mut insert_pos := body_len
            if last_use.gteq(0) {
                insert_pos = last_use.add(1)
            }
            mut del_line := e.line
            mut del_col := e.col
            if insert_pos.gt(0).and(insert_pos.lteq(body_len)) {
                prev_stmt := cast(Expr, new_body.get_by_ref(insert_pos.sub(1))?)
                del_line = prev_stmt.line
                del_col = prev_stmt.col
            } else {
                if new_body.len().gt(0) {
                    last_s := cast(Expr, new_body.get_by_ref(new_body.len().sub(1))?)
                    del_line = last_s.line
                    del_col = last_s.col
                }
            }
            insert_positions.push(insert_pos)
            insert_del_calls.push(build_delete_call_expr(del_type, del_var, del_line, del_col))
        }

        // Build final_body: original statements with ASAP deletes interleaved
        mut final_body := Vec.new(Expr)
        for bi in 0..body_len {
            body_stmt := cast(Expr, new_body.get_by_ref(bi)?)
            final_body.push(body_stmt)
            for di in 0..insert_positions.len() {
                dpos := cast(I64, insert_positions.get_by_ref(di)?)
                if I64.eq(dpos, bi.add(1)) { // TODO Bug #176: UFCS workaround for create_alias
                    dc := cast(Expr, insert_del_calls.get_by_ref(di)?)
                    final_body.push(dc)
                }
            }
        }

        // End-of-function: append locals in reverse declaration order
        mut last_line := e.line
        mut last_col := e.col
        if final_body.len().gt(0) {
            final_last_s := cast(Expr, final_body.get_by_ref(final_body.len().sub(1))?)
            last_line = final_last_s.line
            last_col = final_last_s.col
        }
        mut eri := end_vars.len()
        while eri.gt(0) {
            eri = eri.sub(1)
            ev := cast(Str, end_vars.get_by_ref(eri)?)
            et := cast(Str, end_types.get_by_ref(eri)?)
            final_body.push(build_delete_call_expr(et, ev, last_line, last_col))
        }
        new_body = final_body

        catch (err: IndexOutOfBoundsError) {
            throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)

    // Recurse into StructDef default values
    case NodeType.StructDef(struct_def):
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            value_expr := cast(Expr, struct_def.default_values.get_by_ref(name)?)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name.clone(), garbager_recursive(context, value_expr)?)
        }
        new_struct_def := SStructDef(
            members=struct_def.members.clone(),
            default_values=new_default_values
        )
        mut struct_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            struct_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), struct_new_params, e.line, e.col)

    // Recurse into NamespaceDef default values
    case NodeType.NamespaceDef(ns_def):
        mut ns_new_default_values := Map.new(Str, Expr)
        for name: Str in ns_def.default_values.keys {
            ns_value_expr := cast(Expr, ns_def.default_values.get_by_ref(name)?)
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "garbager", format("KeyNotFoundError: ", err.msg))
            }
            ns_new_default_values.set(name.clone(), garbager_recursive(context, ns_value_expr)?)
        }
        new_ns_def := SNamespaceDef(
            type_name=ns_def.type_name,
            members=ns_def.members.clone(),
            default_values=ns_new_default_values
        )
        mut ns_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            ns_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.NamespaceDef(new_ns_def), ns_new_params, e.line, e.col)

    // Issue #159: Transform mut declarations with struct type where RHS is an identifier
    case NodeType.Declaration(decl):
        // First, recursively transform children
        mut decl_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            decl_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if this is a mut declaration with struct type and identifier RHS
        // Identifier can have field access (x.y.z), we clone any identifier-based RHS
        if decl.is_mut.and(decl_new_params.len().gt(0)) {
            first_param := cast(Expr, decl_new_params.get_by_ref(0)?)
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch first_param.node_type {
            case NodeType.Identifier(_):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    // Exclude true primitive types - they don't need deep cloning
                    // Note: Bool is NOT excluded because true/false are global constants
                    // that would be corrupted if we just share offsets
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        decl_rhs_expr := first_param.clone()
                        decl_clone_call := build_clone_call_expr(type_name, decl_rhs_expr, e.line, e.col)
                        mut decl_transformed_params := Vec.new(Expr)
                        decl_transformed_params.push(decl_clone_call)
                        mut decl_i := 1
                        while decl_i.lt(decl_new_params.len()) {
                            decl_param := cast(Expr, decl_new_params.get_by_ref(decl_i)?)
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            decl_transformed_params.push(decl_param)
                            decl_i = decl_i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, decl_transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, decl_new_params, e.line, e.col)

    // Issue #159: Transform FCall copy params with struct type where arg is an identifier
    case NodeType.FCall(_):
        // First, recursively transform children
        mut fcall_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            fcall_new_params.push(garbager_recursive(context, param)?)
        }
        // Transform copy params: wrap struct identifier args in Type.clone()
        transform_fcall_copy_params(context, e, fcall_new_params)?
        // Issue #159 Step 5: Transform struct literal fields
        transform_struct_literal_fields(context, e, fcall_new_params)?
        return Expr.new_explicit(e.node_type, fcall_new_params, e.line, e.col)

    // Issue #159 Step 6: Transform assignments with struct type where RHS is an identifier
    case NodeType.Assignment(var_name):
        // First, recursively transform children
        mut assign_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            assign_new_params.push(garbager_recursive(context, param)?)
        }

        // Check if RHS is a bare identifier (no field access children)
        // Field access expressions (x.y.z) are skipped - they read from memory directly
        if assign_new_params.len().gt(0) {
            assign_first_param := cast(Expr, assign_new_params.get_by_ref(0)?)
            catch (err: IndexOutOfBoundsError) {
                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
            }
            switch assign_first_param.node_type {
            case NodeType.Identifier(rhs_name):
                // TODO Bug #176: UFCS workaround for create_alias
                assign_first_param_len := Vec.len(assign_first_param.params)
                if I64.eq(assign_first_param_len, 0) {
                // Look up identifier's symbol type
                assign_sym := context.scope_stack.lookup_symbol(rhs_name)?
                catch (err: KeyNotFoundError) {
                    // Symbol not found - no transformation needed
                    return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)
                }
                switch assign_sym.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Build clone call: Type.clone(rhs_expr)
                        assign_rhs_expr := assign_first_param.clone()
                        assign_clone_call := build_clone_call_expr(type_name, assign_rhs_expr, e.line, e.col)
                        mut assign_transformed_params := Vec.new(Expr)
                        assign_transformed_params.push(assign_clone_call)
                        mut assign_i := 1
                        while assign_i.lt(assign_new_params.len()) {
                            assign_param := cast(Expr, assign_new_params.get_by_ref(assign_i)?)
                            catch (err: IndexOutOfBoundsError) {
                                throw e.lang_error(context.path, "garbager", format("IndexOutOfBoundsError: ", err.msg))
                            }
                            assign_transformed_params.push(assign_param)
                            assign_i = assign_i.add(1)
                        }
                        return Expr.new_explicit(e.node_type, assign_transformed_params, e.line, e.col)
                    }
                case:
                    // Not a TCustom type
                }
                } // end if bare identifier
            case:
                // Not an identifier
            }
        }
        // No transformation needed
        return Expr.new_explicit(e.node_type, assign_new_params, e.line, e.col)

    // Body: recurse into children, stripping dont_delete calls
    case NodeType.Body:
        mut body_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            if is_dont_delete_call(param)? {
                // strip dont_delete from nested bodies
            } else {
                body_new_params.push(garbager_recursive(context, param)?)
            }
        }
        return Expr.new_explicit(e.node_type, body_new_params, e.line, e.col)

    // Desugared-away node types: reject with lang_error
    case NodeType.Switch:
        throw e.lang_error(context.path, "garbager", "Switch should have been desugared to if/else by desugarer phase")
    case NodeType.DefaultCase:
        throw e.lang_error(context.path, "garbager", "DefaultCase should have been desugared with Switch")
    case NodeType.Pattern(_):
        throw e.lang_error(context.path, "garbager", "Pattern should have been desugared with Switch")
    case NodeType.ForIn(_):
        throw e.lang_error(context.path, "garbager", "ForIn should have been desugared before garbager phase")

    // Default: recurse into children
    case:
        mut default_new_params := Vec.new(Expr)
        for param: Expr in e.params {
            default_new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(e.node_type, default_new_params, e.line, e.col)
    }
}

/// Build AST for Type.clone(src_expr): FCall( Identifier("Type").Identifier("clone"), src_expr )
build_clone_call_expr := func(type_name: Str, src_expr: Expr, line: I64, col: I64) returns Expr {
    // Type.clone access: Identifier("Type") with child Identifier("clone")
    clone_ident := Expr(node_type=NodeType.Identifier("clone"), line=line, col=col)
    mut type_clone_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_clone_access.params.push(clone_ident)

    // FCall node with the source expression as argument
    mut clone_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    clone_call.params.push(type_clone_access)
    clone_call.params.push(src_expr)
    return clone_call
}

/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
/// Also excludes structs with no mutable fields (no heap data to free).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    if is_primitive {
        return false
    }
    mut struct_def := context.scope_stack.lookup_struct(type_name)?
    mut has_mut_fields := false
    for m: Declaration in struct_def.members {
        if m.is_mut {
            has_mut_fields = true
        }
    }
    return has_mut_fields

    catch (err: KeyNotFoundError) {
        return false
    }
}

/// Recursively check if any Identifier node in the expression tree matches var_name.
/// Recurses into e.params (covers if/while/for/switch bodies stored as params).
/// Does NOT recurse into nested FuncDef bodies (separate scope).
expr_references_var := func(e: Expr, var_name: Str) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(name):
        if name.eq(var_name) {
            return true
        }
    case:
    }
    // Recurse into params (but not into nested FuncDef bodies)
    for param: Expr in e.params {
        if expr_references_var(param, var_name) {
            return true
        }
    }
    // For FuncDef nodes, do NOT recurse into body (separate scope).
    // e.params on a FuncDef are only default arg values, already checked above.
    return false
}

/// Scan body from end to start, return index of last statement referencing the variable.
/// Returns -1 if not found.
find_last_use_index := func(body: Vec, var_name: Str) returns I64 {
    mut i := body.len().sub(1)
    while i.gteq(0) {
        stmt := cast(Expr, body.get_by_ref(i)?)
        if expr_references_var(stmt, var_name) {
            return i
        }
        i = i.sub(1)
    }
    return I64.sub(0, 1)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in find_last_use_index: ", err.msg)
    }
}

/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}

/// Build AST for var = Type.clone(var): Assignment with RHS = clone FCall.
/// Used to break shallow-copy aliasing after container get/pop calls.
build_clone_assignment_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    clone_call := build_clone_call_expr(type_name, var_expr, line, col)
    mut assign := Expr(node_type=NodeType.Assignment(var_name), line=line, col=col)
    assign.params.push(clone_call)
    return assign
}

/// Check if stmt is a container get/pop call with a shallow-copy out-param.
/// Returns true if match, with var_name and type_name via out-params.
detect_shallow_copy_outparam := proc(stmt: Expr, local_types: Map, context: Context, mut out_var: Str, mut out_type: Str) returns Bool throws Str {
    switch stmt.node_type {
    case NodeType.FCall(_):
    case:
        return false
    }
    mut chain := Vec.new(Str)
    get_fcall_identifier_chain(stmt, chain)?
    if chain.len().eq(0) {
        return false
    }
    mut resolved := ResolvedFCall()
    resolved = resolve_fcall_from_chain(chain, local_types, context)?
    catch (err: KeyNotFoundError) {
        return false
    }

    // Build "Type.method" name from resolved func_def's first arg type
    if resolved.func_def.args.len().eq(0) {
        return false
    }
    first_arg := cast(Declaration, resolved.func_def.args.get_by_ref(0)?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    mut self_type := ""
    switch first_arg.value_type {
    case ValueType.TCustom(t):
        self_type = t
    case:
        return false
    }
    method_name := cast(Str, chain.get_by_ref(chain.len().sub(1))?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    qualified := format(self_type, ".", method_name)

    // Check against whitelist
    mut whitelisted := false
    if qualified.eq("Vec.pop") {
        whitelisted = true
    }
    if qualified.eq("Map.get").or(qualified.eq("List.pop")) {
        whitelisted = true
    }
    if not(whitelisted) {
        return false
    }

    // Find last mut arg (the out-param)
    last_arg_idx := resolved.func_def.args.len().sub(1)
    last_arg := cast(Declaration, resolved.func_def.args.get_by_ref(last_arg_idx)?)
    catch (err: IndexOutOfBoundsError) {
        return false
    }
    if not(last_arg.is_mut) {
        return false
    }

    // Map to call-site param index
    mut param_idx := last_arg_idx.add(1)
    if resolved.is_ufcs {
        param_idx = last_arg_idx
    }
    if param_idx.gteq(stmt.params.len()) {
        return false
    }

    // Check if call-site param is a bare identifier
    param_expr := stmt.get(param_idx)?
    dont_delete(param_expr)
    switch param_expr.node_type {
    case NodeType.Identifier(var_name):
        if param_expr.params.len().eq(0) {
            type_name := cast(Str, local_types.get_by_ref(var_name)?)
            catch (err: KeyNotFoundError) {
                return false
            }
            if is_deletable_type(type_name, context) {
                out_var = var_name
                out_type = type_name
                return true
            }
        }
    case:
    }
    return false
}

/// Insert clone assignments after container get/pop calls in a statement list.
/// Recurses into nested Body nodes but not into FuncDef bodies.
insert_clone_after_get := proc(stmts: Vec, local_types: Map, context: Context) returns Vec throws Str {
    mut result := Vec.new(Expr)
    for stmt: Expr in stmts {
        processed := process_stmt_for_clone_after_get(stmt, local_types, context)?
        mut det_var := ""
        mut det_type := ""
        needs_clone := detect_shallow_copy_outparam(processed, local_types, context, det_var, det_type)?
        det_line := processed.line
        det_col := processed.col
        result.push(processed)
        if needs_clone {
            result.push(build_clone_assignment_expr(det_type, det_var, det_line, det_col))
        }
    }
    return result
}

/// Process a single statement: recurse into Body children, leave FuncDef alone.
process_stmt_for_clone_after_get := proc(e: Expr, local_types: Map, context: Context) returns Expr throws Str {
    switch e.node_type {
    case NodeType.FuncDef(_):
        return e // separate scope, don't touch
    case NodeType.Body:
        new_children := insert_clone_after_get(e.params, local_types, context)?
        return Expr.new_explicit(e.node_type, new_children, e.line, e.col)
    case:
        // Recurse into params (covers if/while/for/switch which store bodies as params)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(process_stmt_for_clone_after_get(param, local_types, context)?)
        }
        return Expr.new_explicit(e.node_type, new_params, e.line, e.col)
    }
}

/// Extract function name from FCall's first param (the name expression).
/// Returns "foo" for foo(x) or "Type.method" for Type.method(x).
get_func_name := func(e: Expr) returns Str throws Str {
    if e.params.len().eq(0) {
        return ""
    }
    name_expr := e.get(0)?
    dont_delete(name_expr)
    switch name_expr.node_type {
    case NodeType.Identifier(name):
        // Check for Type.method pattern: Identifier("Type") with child Identifier("method")
        if name_expr.params.len().gt(0) {
            first_child := name_expr.get(0)?
            dont_delete(first_child)
            switch first_child.node_type {
            case NodeType.Identifier(method):
                return format(name, ".", method)
            case:
            }
        }
        return name
    case:
        return ""
    }
}

/// Check if an expression is an Identifier node.
is_identifier_expr := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.Identifier(_):
        return true
    case:
        return false
    }
}

/// Transform FCall copy params: for each arg that is_copy, struct-typed, and an identifier,
/// wrap in Type.clone().
transform_fcall_copy_params := proc(context: Context, e: Expr, mut new_params: Vec) throws Str {
    func_name := get_func_name(e)?
    if func_name.eq("") {
        return
    }

    // Skip .clone and .delete calls to avoid infinite recursion / double-free
    if func_name.ends_with(".clone").or(func_name.ends_with(".delete")) {
        return
    }

    // Early out: check if any args (params[1..]) are identifiers
    mut has_identifier_arg := false
    for check_i in 1..new_params.len() {
        check_param := cast(Expr, new_params.get_by_ref(check_i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in check_i loop: ", err.msg)
        }
        if is_identifier_expr(check_param) {
            has_identifier_arg = true
        }
    }
    if not(has_identifier_arg) {
        return
    }

    // Look up function definition to get arg metadata
    mut func_def := SFuncDef()
    mut found_func := false
    func_def = context.scope_stack.lookup_func(func_name)?
    found_func = true
    catch (err: KeyNotFoundError) { }
    if not(found_func) {
        return
    }

    // For each arg: if is_copy AND struct type AND identifier, wrap in Type.clone()
    for i in 0..func_def.args.len() {
        arg_def := cast(Declaration, func_def.args.get_by_ref(i)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError in args loop: ", err.msg)
        }
        param_idx := i.add(1) // params[0] is the function name
        if param_idx.gteq(new_params.len()) {
            return
        }
        if not(arg_def.is_copy) {
            // skip
        } else {
            param_expr := cast(Expr, new_params.get_by_ref(param_idx)?)
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "IndexOutOfBoundsError getting param_expr: ", err.msg)
            }
            if not(is_identifier_expr(param_expr)) {
                // skip
            } else {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        arg_expr := param_expr.clone()
                        clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                        new_params.set(param_idx, clone_call)?
                        catch (err: IndexOutOfBoundsError) { }
                    }
                case:
                }
            }
        }
    }
}

/// Check if an expression is an FCall to `dont_delete`.
is_dont_delete_call := func(e: Expr) returns Bool throws Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)?
        return func_name.eq("dont_delete")
    case:
        return false
    }
}

/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str throws Str {
    if e.params.len().lt(2) {
        return ""
    }
    param1 := e.get(1)?
    dont_delete(param1)
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}

/// Extract variable name from cast(Type, ptr) declaration: target := cast(Type, ptr)
get_cast_var := func(e: Expr) returns Str throws Str {
    switch e.node_type {
    case NodeType.Declaration(decl):
        if not(e.params.is_empty()) {
            init := e.get(0)?
            dont_delete(init)
            switch init.node_type {
            case NodeType.FCall(_):
                func_name := get_func_name(init)?
                if func_name.eq("cast") {
                    return decl.name
                }
            case:
            }
        }
    case:
    }
    return ""
}

/// Result of resolving a function call, including UFCS detection.
ResolvedFCall := struct {
    mut func_def: SFuncDef = SFuncDef()
    mut is_ufcs: Bool = false
}

/// Recursively collect dont_delete var names from the entire body tree.
/// Walks into Body, If, While, Catch children but not into nested FuncDef bodies.
garb_collect_dont_delete_vars_recursive := func(stmts: Vec) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        garb_collect_dont_delete_vars_recursive_inner(stmt, result)?
    }
    return result
}

garb_collect_dont_delete_vars_recursive_inner := func(e: Expr, mut result: Vec) throws Str {
    if is_dont_delete_call(e)? {
        dd_var := get_dont_delete_var(e)?
        if dd_var.len().gt(0) {
            result.push(dd_var)
        }
        return
    }
    // Recurse into params (covers Body, If, While, Catch children)
    // but NOT into nested FuncDef bodies (separate scope)
    switch e.node_type {
    case NodeType.FuncDef(_):
        return
    case:
    }
    for param: Expr in e.params {
        garb_collect_dont_delete_vars_recursive_inner(param, result)?
    }
}

/// Walk an FCall's name expression to extract the full identifier chain.
/// e.g., for `self.frames.push(frame)`, returns ["self", "frames", "push"]
get_fcall_identifier_chain := proc(e: Expr, mut chain: Vec) throws Str {
    switch e.node_type {
    case NodeType.FCall(_):
        if e.params.len().gt(0) {
            first := e.get(0)?
            dont_delete(first)
            collect_identifier_chain(first, chain)
        }
    case:
    }

}

collect_identifier_chain := proc(e: Expr, mut chain: Vec) {
    switch e.node_type {
    case NodeType.Identifier(name):
        chain.push(name)
        for child: Expr in e.params {
            collect_identifier_chain(child, chain)
        }
    case:
    }
}

/// Resolve a function call from its identifier chain, handling UFCS and chained field access.
/// For UFCS calls, self is implicit so arg-to-param mapping differs.
resolve_fcall_from_chain := proc(chain: Vec, local_types: Map, context: Context) returns ResolvedFCall throws Str, KeyNotFoundError {
    if chain.len().eq(0) {
        throw KeyNotFoundError(msg="resolve_fcall_from_chain: empty chain")
    }

    first := cast(Str, chain.get_by_ref(0)?)

    // Plain function call (no dots)
    if chain.len().eq(1) {
        mut result := ResolvedFCall()
        result.func_def = context.scope_stack.lookup_func(first)?
        return result
    }

    // Try direct lookup of the joined name (works for Type.method)
    mut full_name := ""
    for ji in 0..chain.len() {
        part := cast(Str, chain.get_by_ref(ji)?)
        if ji.gt(0) {
            full_name = format(full_name, ".")
        }
        full_name = format(full_name, part)
    }
    mut direct_result := ResolvedFCall()
    direct_result.func_def = context.scope_stack.lookup_func(full_name)?
    return direct_result

    catch (err: KeyNotFoundError) {
        // REM: Direct lookup failed, try UFCS resolution
    }

    // UFCS resolution: resolve type through the chain, last part is the method
    method_name := cast(Str, chain.get_by_ref(chain.len().sub(1))?)

    // Get initial type from struct name or local_types
    mut current_type := ""
    if context.scope_stack.has_struct(first) {
        current_type = first
    } else {
        current_type_alias := cast(Str, local_types.get_by_ref(first)?)
        current_type = Str.clone(current_type_alias) // TODO Bug #176: UFCS workaround for create_alias
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: unknown first '", first, "'"))
        }
    }

    // Walk intermediate parts (chain[1..n-1]) via struct field type lookups
    for wi in 1..chain.len().sub(1) {
        field_name := cast(Str, chain.get_by_ref(wi)?)
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(current_type)?
        catch (err: KeyNotFoundError) {
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: struct not found '", current_type, "'"))
        }
        mut member := Declaration()
        member = struct_def.get_member(field_name)?
        switch member.value_type {
        case ValueType.TCustom(next_type):
            current_type = next_type
        case:
            throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: member '", field_name, "' is primitive"))
        }
    }

    resolved := format(current_type, ".", method_name)
    mut ufcs_result := ResolvedFCall(is_ufcs=true)
    ufcs_result.func_def = context.scope_stack.lookup_func(resolved)?
    return ufcs_result

    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg=format("resolve_fcall_from_chain: ", err.msg))
    }
}

collect_own_transfers := proc(stmts: Vec, context: Context, local_types: Map) returns Vec throws Str {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, local_types, result)?
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, local_types: Map, mut result: Vec) throws Str {
    switch e.node_type {
    case NodeType.FCall(_):
        mut chain := Vec.new(Str)
        get_fcall_identifier_chain(e, chain)?
        if chain.len().gt(0) {
            last := cast(Str, chain.get_by_ref(chain.len().sub(1))?)
            // TODO Bug #176: UFCS workaround for create_alias
            if not(Str.eq(last, "clone")).and(not(Str.eq(last, "delete"))) {
                mut resolved := ResolvedFCall()
                mut found := false
                resolved = resolve_fcall_from_chain(chain, local_types, context)?
                found = true
                catch (err: KeyNotFoundError) {
                    // REM: Function not found in scope - skip, not all calls are to known functions
                }
                if found {
                    // For UFCS calls (tokens.push(t)), self is implicit in the name,
                    // so skip args[0] (self) and map args[k] -> params[k] for k >= 1.
                    // For direct calls (Vec.push(tokens, t)), map args[i] -> params[i+1].
                    mut arg_start := 0
                    if resolved.is_ufcs {
                        arg_start = 1
                    }
                    for i in 0..resolved.func_def.args.len() {
                        if i.gteq(arg_start) {
                            arg_def := cast(Declaration, resolved.func_def.args.get_by_ref(i)?)
                            mut param_idx := 0
                            if resolved.is_ufcs {
                                param_idx = i
                            } else {
                                param_idx = i.add(1)
                            }
                            if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                                param_expr := e.get(param_idx)?
                                dont_delete(param_expr)
                                switch param_expr.node_type {
                                case NodeType.Identifier(var_name):
                                    if param_expr.params.len().eq(0) {
                                        result.push(var_name)
                                    }
                                case:
                                }
                            }
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, local_types, result)?
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, local_types, result)?
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Issue #159 Step 5: Transform struct literal fields.
/// For struct literal constructors like Point(inner=some_var), if a NamedArg value
/// is an identifier pointing to a struct type, wrap it in Type.clone().
transform_struct_literal_fields := proc(context: Context, e: Expr, mut new_params: Vec) throws Str {
    // Extract the struct name from the original FCall (before child transforms)
    struct_name := get_func_name(e)?
    if struct_name.eq("") {
        return
    }

    // Must be a plain struct name (no dots - not a method call)
    if struct_name.contains(".") {
        return
    }

    // Check if it's a struct
    mut struct_def := SStructDef()
    mut found_struct := false
    struct_def = context.scope_stack.lookup_struct(struct_name)?
    found_struct = true
    catch (err: KeyNotFoundError) { }
    if not(found_struct) {
        return
    }

    // For each child in new_params[1..] that is a NamedArg
    for param_idx in 1..new_params.len() {
        mut param := cast(Expr, new_params.get_by_ref(param_idx)?)
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "IndexOutOfBoundsError getting named arg param: ", err.msg)
        }
        switch param.node_type {
        case NodeType.NamedArg(field_name):
            // Find matching field in struct def members
            mut field_decl := Declaration()
            mut found_field := false
            for member: Declaration in struct_def.members {
                if member.name.eq(field_name) {
                    field_decl = member
                    found_field = true
                }
            }
            if not(found_field) {
                // skip
            } else {
                // Check if field type is a non-primitive struct
                switch field_decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        // Check if the NamedArg's value (params[0]) is an identifier
                        if param.params.len().gt(0) {
                            value_expr := param.get(0)?
                            dont_delete(value_expr)
                            if is_identifier_expr(value_expr) {
                                arg_expr := value_expr.clone()
                                clone_call := build_clone_call_expr(type_name, arg_expr, e.line, e.col)
                                param.params.set(0, clone_call)?
                                catch (err: IndexOutOfBoundsError) { }
                                new_params.set(param_idx, param)?
                                catch (err: IndexOutOfBoundsError) { }
                            }
                        }
                    }
                case:
                }
            }
        case:
        }
    }
}
