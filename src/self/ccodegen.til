mode liba

// C code generator for TIL
// Translates TIL AST to C source code

import("self.parser")  // Expr, NodeType, Literal
import("self.init")    // Context, get_value_type, ScopeFrame, SymbolInfo, ScopeType
import("self.typer")   // get_func_def_for_fcall

// Prefix for all TIL-generated C names (structs, functions, etc.)
TIL_PREFIX := "til_"

// Info about a variadic parameter
VariadicParamInfo := struct {
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Info about a catch label for local throw/catch
CatchLabelInfo := struct {
    mut label: Str = ""
    mut temp_var: Str = ""
}

// Info about a catch block for code generation
// Note: TIL has extra catch_block field - removing it causes til_compiled to hang (Bug #80)
CatchLabelInfoEntry := struct {
    mut stmt_index: I64 = 0      // Index in stmts array
    mut type_name: Str = ""      // Error type being caught (e.g., "Str", "IndexOutOfBoundsError")
    mut label: Str = ""          // Goto label for this catch
    mut temp_var: Str = ""       // Temp variable holding the thrown value
    mut catch_block: Expr = Expr()  // DO NOT REMOVE - causes hangs in til_compiled
}

// Info about a function parameter's type and whether passed by reference
ParamTypeInfo := struct {
    mut value_type: Ptr = Ptr()  // Ptr to ValueType, NULL = None
    mut by_ref: Bool = false
}

// Info about a struct member with a throwing default value
ThrowingDefault := struct {
    mut member_name: Str = ""
    mut default_expr: Expr = Expr()
}

// Info about a collected variable declaration for hoisting
CollectedDeclaration := struct {
    mut name: Str = ""
    mut value_type: ValueType = ValueType.TCustom("")
}


// Codegen context for tracking function info during code generation
CodegenContext := struct {
    // Counter for generating unique temp variable names (deterministic per-compilation)
    mut mangling_counter: I64 = 0
    // Map function name -> variadic arg info (Map<Str, VariadicParamInfo>)
    mut func_variadic_args: Map = Map.new(Str, VariadicParamInfo)
    // Currently generating function's throw types (if any)
    mut current_throw_types: Vec = Vec.new(ValueType)
    // Currently generating function's return types (if any)
    mut current_return_types: Vec = Vec.new(ValueType)
    // Set of declared variable names in current function (to avoid redefinition)
    mut declared_vars: Set = Set.new(Str)
    // Set of by-ref param names in current function - for using -> instead of . for field access
    mut current_ref_params: Vec = Vec.new(Str)
    // Map of variadic param names to their element type (e.g., "args" -> "til_Bool")
    // Passed as til_Array* so need dereference, and need type info for Array.get casting
    mut current_variadic_params: Map = Map.new(Str, Str)
    // All known type names for generating til_size_of function
    mut known_types: Vec = Vec.new(Str)
    // Map of hoisted expression addresses to their temp variable names
    // Used to track deeply nested variadic/throwing calls that have been hoisted
    // Key is "line:col" string, value is temp var name (Str)
    mut hoisted_exprs: Map = Map.new(I64, Str)
    // Map of locally-caught error types to (catch label, temp variable name)
    // Used for throw statements and throwing calls when there's an outer catch block
    // Key is error type name, value is struct with label and temp_var
    mut local_catch_labels: Map = Map.new(Str, CatchLabelInfo)
    // Current function name for nested function name mangling (empty at top-level)
    mut current_function_name: Str = ""
    // C code for hoisted nested function definitions
    mut hoisted_functions: Vec = Vec.new(Str)
    // C code for hoisted nested function prototypes
    mut hoisted_prototypes: Vec = Vec.new(Str)
    // Map original function name -> mangled name for nested functions
    mut nested_func_names: Map = Map.new(Str, Str)
    // Map of hoisted struct default expressions ((struct_name, member_name) -> temp var name)
    // Used to track which struct literal defaults were hoisted as temp vars
    // Key is "struct_name:member_name" string, value is temp var name
    mut hoisted_struct_defaults: Map = Map.new(Str, Str)
}

next_mangled := proc(mut ctx: CodegenContext) returns Str {
    n := ctx.mangling_counter
    ctx.mangling_counter.inc()
    func_name := ctx.current_function_name
    if func_name.len().gt(0) {
        return concat("_tmp_", func_name).concat("_").concat(n.to_str())
    }
    return concat("_tmp_", n.to_str())
}

// Returns the C name for a TIL identifier - adds TIL_PREFIX
// Exceptions: C keywords (true, false), pointer deref (*name), and generated names (_ prefix)
til_name := func(name: Str) returns Str {
    // "true" | "false" => name.to_string()
    if name.eq("true").or(name.eq("false")) { return name }
    // _ if name.starts_with('*') || name.starts_with('_') => name.to_string()
    if name.starts_with("*").or(name.starts_with("_")) { return name }
    return concat(TIL_PREFIX, name)
}

// Emit a struct literal, using compound literal syntax if already_declared
// e.g., " = {0}" vs " = (til_TypeName){0}"
emit_struct_literal_assign := proc(mut output: Str, type_name: Str, already_declared: Bool, literal_content: Str) {
    output.push_str(" = ")
    if already_declared {
        output.push_str("(")
        output.push_str(til_name(type_name))
        output.push_str(")")
    }
    output.push_str(literal_content)
    output.push_str(";\n")
}

// Start a struct literal assignment - caller will emit content and closing brace
// e.g., " = " vs " = (til_TypeName)"
emit_struct_literal_start := proc(mut output: Str, type_name: Str, already_declared: Bool) {
    output.push_str(" = ")
    if already_declared {
        output.push_str("(")
        output.push_str(til_name(type_name))
        output.push_str(")")
    }
}

// Returns the C name for a TIL function - adds TIL_PREFIX and converts dots to underscores
// Used for function names like Array.len -> til_Array_len
til_func_name := func(name: Str) returns Str {
    return concat(TIL_PREFIX, name.replace(".", "_"))
}

// Get function name from FCall's first param, handling both AST patterns:
// - Identifier("func") with params = [] -> "func"
// - Identifier("I64.inc") with params = [] -> "I64_inc" (from precomp)
// - Identifier("Vec") with params = [Identifier("new")] -> "Vec_new" (from parser)
// Returns the C-ready name with underscores (not dots)
get_func_name_string := func(first_param: Expr) returns Str throws Str, KeyNotFoundError {
    switch first_param.node_type {
    case NodeType.Identifier(name):
        if first_param.params.len().eq(0) {
            return name.replace(".", "_")
        } else {
            mut parts := name
            for p: Expr in first_param.params {
                switch p.node_type {
                case NodeType.Identifier(part):
                    parts = parts.concat("_").concat(part)
                case:
                }
            }
            return parts
        }
    case:
    }

    catch (err: AllocError) { throw err.msg }
    throw KeyNotFoundError(msg="first param not Identifier")
}

// Get TIL function name from FCall's first param (for scope lookups)
// Returns the dot-separated name like "Vec.new" or "I64.inc"
// This avoids the fragile .replacen('_', ".", 1) hack which breaks on type names with underscores
get_til_func_name_string := func(first_param: Expr) returns Str throws KeyNotFoundError {
    switch first_param.node_type {
    case NodeType.Identifier(name):
        if first_param.params.len().eq(0) {
            // Already has dots (from precomp) or is a simple name
            return name
        } else {
            // Build dotted name from nested identifiers
            mut parts := name
            for p: Expr in first_param.params {
                switch p.node_type {
                case NodeType.Identifier(part):
                    parts = parts.concat(".").concat(part)
                case:
                }
            }
            return parts
        }
    case:
    }

    throw KeyNotFoundError(msg="first param not Identifier")
}

// Check if an expression is a type identifier (a Type parameter at call site)
// Returns the type name if it is, so it can be emitted as a string literal
// Matches interpreter.rs behavior (line 1703-1713)
// Only matches STANDALONE identifiers - not field access like Vec.INIT_CAP
get_type_arg_name := func(expr: Expr, context: Context) returns Str throws KeyNotFoundError {
    switch expr.node_type {
    case NodeType.Identifier(name):
        // Only match standalone identifiers (no field access)
        if expr.params.len().gt(0) {
            throw KeyNotFoundError(msg="field access, not type arg")
        }
        // Check if this identifier is a type name (struct, enum, or builtin type)
        mut symbol := context.scope_stack.lookup_symbol(name)
        switch symbol.value_type {
        case ValueType.TType(type_name):
            return name
        case:
            // Not a type
        }
    case:
        // Not an identifier
    }
    throw KeyNotFoundError(msg="not a type identifier")
}
// Check if an expression is a function call that uses out-params (i.e., the function throws)
// Such calls cannot be used inline in struct initializers - they need separate statements
is_throwing_fcall := proc(expr: Expr, context: Context) returns Bool {
    switch expr.node_type {
    case NodeType.FCall:
        mut got_fd := false
        mut fd := SFuncDef()
        fd = get_fcall_func_def(context, expr)
        got_fd = true
        catch (err: KeyNotFoundError) { /* REM None case in Rust */ }
        if got_fd {
            return fd.throw_types.len().gt(0)
        }
    case:
    }
    return false
}

// Convert TIL type to C type. Returns Err if the type can't be represented in C (e.g., functions, infer)
til_type_to_c := func(til_type: ValueType) returns Str throws Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq(INFER_TYPE) {
            throw "Cannot convert inferred type to C"
        } else {
            // All types get TIL_PREFIX
            return concat(TIL_PREFIX, name)
        }
    case ValueType.TFunction:
        throw "Cannot convert function type to C"
    case ValueType.TType:
        throw "Cannot convert Type to C"
    case ValueType.TMulti:
        throw "Cannot convert multi-type to C"
    }
}

// Get function definition for an FCall expression
// Uses get_func_def_for_fcall from typer.til which handles all cases correctly
// (regular functions, struct methods, UFCS - though UFCS is already resolved by precomp)
// Throws KeyNotFoundError for struct/enum constructors (Rust returns None)
get_fcall_func_def := proc(context: Context, fcall_expr: Expr) returns SFuncDef throws KeyNotFoundError {
    mut expr_clone := fcall_expr.clone()
    catch (err: AllocError) { throw KeyNotFoundError(msg=err.msg) }
    fd := get_func_def_for_fcall_with_expr(context, expr_clone)

    catch (err: Str) { throw KeyNotFoundError(msg=err) }
    catch (err: KeyNotFoundError) { throw err }

    return fd
}

// Bug #60: Determine if a parameter should be passed by reference (pointer)
// - copy params: pass by value (copy is made)
// - Type params: already pointers (const char*), pass by value
// - All other const/own/mut params (including Dynamic): pass by pointer
param_needs_by_ref := func(param: Declaration) returns Bool {
    if param.is_copy {
        return false
    }
    // Type is already a pointer type in C (const char*), no extra indirection needed
    switch param.value_type {
    case ValueType.TCustom(name):
        if name.eq("Type") {
            return false
        }
    case:
    }
    return true
}

// Helper to get C type name for a ValueType (same as til_type_to_c but for error struct definitions)
value_type_to_c_name := func(vt: ValueType) returns Str throws Str {
    switch vt {
    case ValueType.TCustom(name):
        // All types get TIL_PREFIX
        return concat(TIL_PREFIX, name)
    case:
        throw concat("Cannot convert ", value_type_to_str(vt)).concat(" to C type name")
    }
}

// Result type for detect_variadic_fcall
VariadicFCallInfo := struct {
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Detect if an expression is a variadic function call
// Returns VariadicFCallInfo if it's a variadic call
detect_variadic_fcall := proc(expr: Expr, ctx: CodegenContext) returns VariadicFCallInfo throws KeyNotFoundError {
    if expr.params.len().eq(0) {
        throw KeyNotFoundError(msg="not variadic")
    }

    // Get original TIL function name (with dots) for variadic map lookup
    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { throw KeyNotFoundError(msg="index out of bounds") }
    mut orig_func_name := get_til_func_name_string(first)

    mut info := VariadicParamInfo()
    ctx.func_variadic_args.get(orig_func_name, info)

    return VariadicFCallInfo(elem_type=info.elem_type, regular_count=info.regular_count)
}

// Result type for hoisted arguments
HoistedArg := struct {
    mut index: I64 = 0
    mut temp_var: Str = ""
}

// Hoist arguments that need to be passed by reference but are rvalues
// Returns a Vec of HoistedArg with the hoisted temp variables
// Note: output is mut and modified in-place (same pattern as hoist_for_dynamic_params)
hoist_for_ref_params := proc(args: Vec, param_by_ref: Vec, already_hoisted: Map, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Vec throws Str {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    for idx in 0..args.len() {
        mut arg := Expr()
        args.get(idx, arg)

        // Skip if already hoisted
        mut idx_str := idx.to_str()
        if already_hoisted.contains_key(idx_str) {
            continue
        }

        // Check if param is by-ref
        mut is_by_ref := false
        if idx.lt(param_by_ref.len()) {
            param_by_ref.get(idx, is_by_ref)
        }
        if not(is_by_ref) {
            continue
        }

        // Check if arg needs hoisting (rvalues that can't have & taken)
        mut needs_hoisting := false
        switch arg.node_type {
        case NodeType.Identifier(name):
            // Simple identifier is lvalue - doesn't need hoisting
            // But type-qualified calls like I64.to_str need hoisting
            if arg.params.len().eq(0) {
                needs_hoisting = false
            } else {
                // Check for UFCS placeholder "_" which is a chained expression
                if name.eq("_") {
                    // UFCS placeholder - this is a chained expression like get_foo().bar
                    // The result is an lvalue, doesn't need hoisting
                    needs_hoisting = false
                } else {
                    mut is_variable := false
                    mut is_function := false
                    mut sym := context.scope_stack.lookup_symbol(name)
                    is_variable = true
                    catch (err: KeyNotFoundError) {
                        // Not a variable
                    }
                    mut fd := context.scope_stack.lookup_func(name)
                    is_function = true
                    catch (err: KeyNotFoundError) {
                        // Not a function
                    }
                    // Only needs hoisting if it's not a variable AND not a function call
                    // (i.e., it's a Type.method call like I64.to_str)
                    needs_hoisting = not(is_variable).and(not(is_function))
                }
            }
        case NodeType.LLiteral(lit):
            switch lit {
            case Literal.Str(s):
                needs_hoisting = false  // Compound literal, can use &
            case Literal.Number(n):
                needs_hoisting = true   // Can't take address of integer literal
            case:
                needs_hoisting = false
            }
        case NodeType.FCall:
            // Check if this is an enum or struct constructor - those become compound literals
            // which CAN have & taken directly, so no hoisting needed
            if arg.params.len().gt(0) {
                mut first := Expr()
                arg.params.get(0, first)
                mut combined := get_combined_name(context.path, first)
                needs_hoisting = not(context.scope_stack.is_type_constructor(combined))
            } else {
                needs_hoisting = true
            }
        case:
            needs_hoisting = false
        }

        if not(needs_hoisting) {
            continue
        }

        // Determine the C type based on what the arg evaluates to
        mut c_type := ""
        switch arg.node_type {
        case NodeType.LLiteral(lit):
            switch lit {
            case Literal.Number(n):
                c_type = concat(TIL_PREFIX, "I64")
            case:
                throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for ref param hoisting")
            }
        case NodeType.FCall:
            // Look up the function's return type
            mut fd := get_fcall_func_def(context, arg)
            if fd.return_types.len().gt(0) {
                mut ret_type := ValueType.TCustom("")
                fd.return_types.get(0, ret_type)
                c_type = til_type_to_c(ret_type)
            } else {
                throw arg.lang_error(context.path, "ccodegen", "Function has no return type")
            }
            catch (err: KeyNotFoundError) {
                throw arg.lang_error(context.path, "ccodegen", "Cannot find function definition")
            }
        case NodeType.Identifier(var_name):
            if arg.params.len().gt(0) {
                // Type-qualified method call like I64.to_str(x) - look up return type
                mut first_param := Expr()
                arg.params.get(0, first_param)
                switch first_param.node_type {
                case NodeType.Identifier(method_name):
                    // Look up Type.method function
                    func_name := var_name.concat(".").concat(method_name)
                    mut fd := context.scope_stack.lookup_func(func_name)
                    if fd.return_types.len().gt(0) {
                        mut ret_type := ValueType.TCustom("")
                        fd.return_types.get(0, ret_type)
                        c_type = til_type_to_c(ret_type)
                    } else {
                        throw arg.lang_error(context.path, "ccodegen", concat("Function ", func_name).concat(" has no return type"))
                    }
                    catch (err: KeyNotFoundError) {
                        throw arg.lang_error(context.path, "ccodegen", concat("Cannot find function: ", func_name))
                    }
                case:
                    throw arg.lang_error(context.path, "ccodegen", "Expected method name")
                }
            } else {
                throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for ref param hoisting")
            }
        case:
            throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for ref param hoisting")
        }

        mut temp_var := next_mangled(ctx)

        // Emit: Type _tmpXX = <expression>;
        output = output.concat(indent_str)
        output = output.concat(c_type)
        output = output.concat(" ")
        output = output.concat(temp_var)
        output = output.concat(" = ")
        emit_expr(arg, output, 0, ctx, context)
        output = output.concat(";\n")

        mut hoisted_arg := HoistedArg()
        hoisted_arg.index = idx
        hoisted_arg.temp_var = temp_var
        hoisted.push(hoisted_arg)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return hoisted
}

/// Returns Some(temp_var_name) if the expression itself was hoisted, None otherwise.
/// The hoisted_exprs map in ctx is updated with any sub-expressions that were hoisted.
hoist_throwing_expr := proc(
    expr: Expr,
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) returns Str throws Str, KeyNotFoundError {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    // Check if this expression itself is a throwing call
    switch expr.node_type {
    case NodeType.FCall:
        mut has_throwing_fd := false
        mut throwing_fd := SFuncDef()
        throwing_fd = get_fcall_func_def(context, expr)
        has_throwing_fd = true
        catch (err: KeyNotFoundError) {
            // REM: None case - not a known function, skip throwing check
        }
        if has_throwing_fd.and(throwing_fd.throw_types.len().gt(0)) {
            // First, recursively hoist any throwing calls in this call's arguments
            mut nested_hoisted := Map.new(I64, Str)
            if expr.params.len().gt(1) {
                mut nested_args := Vec.new(Expr)
                for i in 1..expr.params.len() {
                    mut arg := Expr()
                    expr.params.get(i, arg)
                    nested_args.push(arg)
                }
                mut nested_vec := hoist_throwing_args(nested_args, output, indent, ctx, context)
                // Convert Vec<HoistedArg> to Map<I64, Str>
                for h: HoistedArg in nested_vec {
                    nested_hoisted.set(h.index, h.temp_var)
                }
            }

            temp_var := next_mangled(ctx)

            // Determine the C type for the temp variable
            mut c_type := ""
            if throwing_fd.return_types.is_empty() {
                throw expr.lang_error(context.path, "ccodegen", "Cannot hoist throwing call with no return type")
            }
            mut first_ret := ValueType.TCustom("")
            throwing_fd.return_types.get(0, first_ret)
            c_type = til_type_to_c(first_ret)

            // Declare temp variable
            output = output.concat(indent_str).concat(c_type).concat(" ").concat(temp_var).concat(";\n")

            // Declare error variables for each throw type
            temp_suffix := next_mangled(ctx)
            for err_idx in 0..throwing_fd.throw_types.len() {
                mut throw_type := ValueType.TCustom("")
                throwing_fd.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    output = output.concat(indent_str).concat(til_name(type_name)).concat(" _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix).concat(";\n")
                case:
                }
            }

            // Detect and construct variadic array if needed
            mut variadic_arr_var := ""
            mut variadic_info := detect_variadic_fcall(expr, ctx)
            mut variadic_args := Vec.new(Expr)
            for vi in add(1, variadic_info.regular_count)..expr.params.len() {
                mut varg := Expr()
                expr.params.get(vi, varg)
                variadic_args.push(varg)
            }
            variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
            catch (err: KeyNotFoundError) {
                // REM: Not a variadic function - variadic_arr_var stays empty
            }

            // Emit the function call with output pointers
            output = output.concat(indent_str).concat("int _status_").concat(temp_suffix).concat(" = ")

            // Emit the function name and args (using nested hoisted temps)
            emit_fcall_name_and_args_for_throwing(expr, temp_var, temp_suffix, throwing_fd.throw_types, nested_hoisted, variadic_arr_var, output, ctx, context)

            output = output.concat(";\n")

            // Emit error checking - propagate or goto based on context
            // Check if there are local catch labels for these error types
            mut has_local_catch := false
            for throw_idx in 0..throwing_fd.throw_types.len() {
                mut throw_type := ValueType.TCustom("")
                throwing_fd.throw_types.get(throw_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    if ctx.local_catch_labels.contains_key(type_name) {
                        has_local_catch = true
                        break
                    }
                case:
                }
            }

            if has_local_catch {
                // Use goto for local catches
                for err_idx in 0..throwing_fd.throw_types.len() {
                    mut throw_type := ValueType.TCustom("")
                    throwing_fd.throw_types.get(err_idx, throw_type)
                    switch throw_type {
                    case ValueType.TCustom(type_name):
                        if ctx.local_catch_labels.contains_key(type_name) {
                            mut catch_info := CatchLabelInfo()
                            ctx.local_catch_labels.get(type_name, catch_info)
                            output = output.concat(indent_str).concat("if (_status_").concat(temp_suffix).concat(" == ").concat(add(err_idx, 1).to_str()).concat(") { ").concat(catch_info.temp_var).concat(" = _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix).concat("; goto ").concat(catch_info.label).concat("; }\n")
                            catch (err: KeyNotFoundError) {
                                // REM: Should not happen since we checked contains_key
                            }
                        }
                    case:
                    }
                }
            } else {
                // Propagate errors
                output = output.concat(indent_str).concat("if (_status_").concat(temp_suffix).concat(" != 0) {\n")

                for err_idx in 0..throwing_fd.throw_types.len() {
                    mut throw_type := ValueType.TCustom("")
                    throwing_fd.throw_types.get(err_idx, throw_type)
                    switch throw_type {
                    case ValueType.TCustom(type_name):
                        for curr_idx in 0..ctx.current_throw_types.len() {
                            mut curr_throw := ValueType.TCustom("")
                            ctx.current_throw_types.get(curr_idx, curr_throw)
                            switch curr_throw {
                            case ValueType.TCustom(curr_type_name):
                                if curr_type_name.eq(type_name) {
                                    output = output.concat(indent_str).concat("    if (_status_").concat(temp_suffix).concat(" == ").concat(add(err_idx, 1).to_str()).concat(") { *_err").concat(add(curr_idx, 1).to_str()).concat(" = _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix).concat("; return ").concat(add(curr_idx, 1).to_str()).concat("; }\n")
                                    break
                                }
                            case:
                            }
                        }
                    case:
                    }
                }

                output = output.concat(indent_str).concat("}\n")
            }

            // Emit Array.delete if variadic array was constructed
            if variadic_arr_var.len().gt(0) {
                output = output.concat(indent_str).concat(TIL_PREFIX).concat("Array_delete(&").concat(variadic_arr_var).concat(");\n")
            }

            // Record in hoisted_exprs map using expression address
            expr_addr := to_ptr(expr)
            ctx.hoisted_exprs.set(expr_addr, temp_var)

            return temp_var
        }
    case:
    }

    // Check if this is a non-throwing variadic call - also needs hoisting
    switch expr.node_type {
    case NodeType.FCall:
        mut variadic_fcall_info := detect_variadic_fcall(expr, ctx)
        catch (err: KeyNotFoundError) {
            // REM: Not a variadic call, skip this block
        }
        // Recursively hoist any throwing/variadic calls in this call's arguments first
        mut nested_hoisted := Map.new(I64, Str)
        if expr.params.len().gt(1) {
            mut nested_args := Vec.new(Expr)
            for i in 1..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                nested_args.push(arg)
            }
            mut nested_vec := hoist_throwing_args(nested_args, output, indent, ctx, context)
            for h: HoistedArg in nested_vec {
                nested_hoisted.set(h.index, h.temp_var)
            }
        }

        temp_var := next_mangled(ctx)

        // Determine return type from function
        func_name := get_fcall_func_name(expr)
        mut fd := get_fcall_func_def(context, expr)
        catch (err: KeyNotFoundError) {
            throw expr.lang_error(context.path, "ccodegen", format("Function not found: ", func_name))
        }
        if fd.return_types.is_empty() {
            throw expr.lang_error(context.path, "ccodegen", "Function has no return type")
        }
        mut ret_type := ValueType.TCustom("")
        fd.return_types.get(0, ret_type)
        c_type := til_type_to_c(ret_type)

        // Declare temp variable
        output = output.concat(indent_str).concat(c_type).concat(" ").concat(temp_var).concat(";\n")

        // Construct variadic array
        mut variadic_args := Vec.new(Expr)
        for vi in add(1, variadic_fcall_info.regular_count)..expr.params.len() {
            mut varg := Expr()
            expr.params.get(vi, varg)
            variadic_args.push(varg)
        }
        variadic_arr_var := hoist_variadic_args(variadic_fcall_info.elem_type, variadic_args, nested_hoisted, variadic_fcall_info.regular_count, output, indent, ctx, context)

        // Calculate param_by_ref and param_types for proper by-ref handling
        mut param_by_ref := Vec.new(Bool)
        mut param_types := Vec.new(ValueType)
        for i in 0..fd.args.len() {
            mut arg_decl := Declaration()
            fd.args.get(i, arg_decl)
            param_by_ref.push(param_needs_by_ref(arg_decl))
            param_types.push(arg_decl.value_type)
        }

        // Emit the function call (non-throwing, so direct assignment)
        output = output.concat(indent_str).concat(temp_var).concat(" = ")

        // Emit function name
        mut emit_func_name := get_fcall_func_name(expr)
        catch (err: Str) {
            // REM: Should not fail since we already got it above
        }
        output = output.concat(til_func_name(emit_func_name)).concat("(")

        // Emit regular args (using nested hoisted temps)
        mut first := true
        for i in 0..variadic_fcall_info.regular_count {
            if not(first) {
                output = output.concat(", ")
            }
            first = false
            mut param := Expr()
            expr.params.get(add(i, 1), param)
            mut ptype := ValueType.TCustom("")
            mut ptype_ptr := Ptr()
            if i.lt(param_types.len()) {
                param_types.get(i, ptype)
                ptype_ptr.data = to_ptr(ptype)
            }
            mut by_ref := false
            if i.lt(param_by_ref.len()) {
                param_by_ref.get(i, by_ref)
            }
            emit_arg_with_param_type(param, i, nested_hoisted, ptype_ptr, by_ref, output, ctx, context)
        }

        // Emit variadic array pointer
        if not(first) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
        output.push_str(");\n")

        // Emit Array.delete for the variadic array
        output = output.concat(indent_str).concat(TIL_PREFIX).concat("Array_delete(&").concat(variadic_arr_var).concat(");\n")

        // Record in hoisted_exprs map using expression address
        expr_addr := to_ptr(expr)
        ctx.hoisted_exprs.set(expr_addr, temp_var)

        return temp_var
    case:
    }

    // Check if this is a struct literal with throwing default values
    switch expr.node_type {
    case NodeType.FCall:
        if expr.params.len().gt(0) {
            mut first_param := Expr()
            expr.params.get(0, first_param)
            mut func_name := get_func_name_string(first_param)
            catch (err: KeyNotFoundError) {
                // REM: Not a named function call, skip
            }
            catch (err: Str) {
                // REM: Error getting func name, skip
            }
            if func_name.len().gt(0) {
                mut has_named_args := false
                for i in 1..expr.params.len() {
                    mut arg := Expr()
                    expr.params.get(i, arg)
                    switch arg.node_type {
                    case NodeType.NamedArg(_):
                        has_named_args = true
                    case:
                    }
                }
                mut struct_def := context.scope_stack.lookup_struct(func_name)
                catch (err: KeyNotFoundError) {
                    // REM: Not a struct, skip
                }
                if expr.params.len().eq(1).or(has_named_args) {
                    // This is a struct literal - check for throwing defaults
                    // Build map of named arg names that are provided
                    mut provided_names := Map.new(Str, Bool)
                    for i in 1..expr.params.len() {
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        switch arg.node_type {
                        case NodeType.NamedArg(field_name):
                            provided_names.set(field_name, true)
                        case:
                        }
                    }

                    // For each member with a default that's a throwing call and not overridden, emit temp var
                    for member: Declaration in struct_def.members {
                        if not(member.is_mut) {
                            // skip non-mut members
                        } else if provided_names.contains_key(member.name) {
                            // Named arg overrides default
                        } else {
                            if struct_def.default_values.contains_key(member.name) {
                                mut default_expr := Expr()
                                struct_def.default_values.get(member.name, default_expr)
                                catch (err: KeyNotFoundError) {
                                    // REM: Should not happen
                                }
                                if is_throwing_fcall(default_expr, context) {
                                    // Get the function's throw types
                                    mut throw_types := Vec.new(ValueType)
                                    if default_expr.params.len().gt(0) {
                                        mut first_p := Expr()
                                        default_expr.params.get(0, first_p)
                                        mut lookup_name := get_til_func_name_string(first_p)
                                        catch (err: KeyNotFoundError) {
                                            // REM: Can't get func name
                                        }
                                        if lookup_name.len().gt(0) {
                                            mut fd := context.scope_stack.lookup_func(lookup_name)
                                            throw_types = fd.throw_types
                                            catch (err: KeyNotFoundError) {
                                                // REM: Function not found
                                            }
                                        }
                                    }

                                    temp_name := next_mangled(ctx)
                                    // Emit the function call with out-param using emit_throwing_call_propagate
                                    emit_throwing_call_propagate(default_expr, throw_types, temp_name, "", output, indent, ctx, context)
                                    // Record that this struct default was hoisted using "struct_name:member_name" key
                                    key := format(func_name, ":", member.name)
                                    ctx.hoisted_struct_defaults.set(key, temp_name)
                                } else {
                                    // Also recursively hoist any throwing expressions in the default
                                    // This handles nested struct constructors with throwing defaults
                                    _ := hoist_throwing_expr(default_expr, output, indent, ctx, context)
                                    catch (err: KeyNotFoundError) {
                                        // REM: None case, nothing was hoisted
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    case:
    }

    // Not a throwing call or variadic call - recursively check sub-expressions
    // For FCall, check all arguments
    switch expr.node_type {
    case NodeType.FCall:
        if expr.params.len().gt(1) {
            for i in 1..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                _ := hoist_throwing_expr(arg, output, indent, ctx, context)
                catch (err: KeyNotFoundError) {
                    // REM: None case, nothing was hoisted
                }
            }
        }
    case:
        // For other expression types with sub-expressions, recurse into them
        for param: Expr in expr.params {
            _ := hoist_throwing_expr(param, output, indent, ctx, context)
            catch (err: KeyNotFoundError) {
                // REM: None case, nothing was hoisted
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    throw KeyNotFoundError(msg="hoist_throwing_expr: expression was not hoisted")
}

/// Hoist throwing function calls from arguments (recursively)
/// Returns a vector of HoistedArg for arguments that were hoisted
hoist_throwing_args := proc(
    args: Vec,  // The arguments (skip first param which is function name)
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) returns Vec throws Str {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    for idx in 0..args.len() {
        mut arg := Expr()
        args.get(idx, arg)

        // Check if it's a throwing call
        mut found_throwing_fd := false
        mut throwing_fd := SFuncDef()
        switch arg.node_type {
        case NodeType.FCall:
            mut fd := get_fcall_func_def(context, arg)
            if fd.throw_types.len().gt(0) {
                throwing_fd = fd
                found_throwing_fd = true
            }
            catch (err: KeyNotFoundError) { }
        case:
        }

        // Check if it's a variadic call (even if not throwing)
        mut found_variadic := false
        mut variadic_info := VariadicFCallInfo()
        variadic_info = detect_variadic_fcall(arg, ctx)
        found_variadic = true
        catch (err: KeyNotFoundError) { }

        // Handle throwing calls (may also be variadic)
        if found_throwing_fd {
            // RECURSIVELY hoist any throwing calls in this call's arguments first
            mut nested_hoisted := Map.new(I64, Str)
            if arg.params.len().gt(1) {
                mut nested_args := Vec.new(Expr)
                for i in 1..arg.params.len() {
                    mut nested_arg := Expr()
                    arg.params.get(i, nested_arg)
                    nested_args.push(nested_arg)
                }
                nested_vec := hoist_throwing_args(nested_args, output, indent, ctx, context)
                for h_idx in 0..nested_vec.len() {
                    mut h := HoistedArg()
                    nested_vec.get(h_idx, h)
                    nested_hoisted.set(h.index, h.temp_var)
                }
            }

            temp_var := next_mangled(ctx)

            // Determine the C type for the temp variable
            mut c_type := ""
            if throwing_fd.return_types.len().gt(0) {
                mut first_ret := ValueType.TCustom("")
                throwing_fd.return_types.get(0, first_ret)
                c_type = til_type_to_c(first_ret)
                catch (err: Str) {
                    throw arg.lang_error(context.path, "ccodegen", err)
                }
            } else {
                throw arg.lang_error(context.path, "ccodegen", "Cannot hoist throwing call with no return type")
            }

            // Declare temp variable
            output.push_str(indent_str)
            output.push_str(c_type)
            output.push_str(" ")
            output.push_str(temp_var)
            output.push_str(";\n")

            // Declare error variables for each throw type
            temp_suffix := next_mangled(ctx)
            for err_idx in 0..throwing_fd.throw_types.len() {
                mut throw_type := ValueType.TCustom("")
                throwing_fd.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    output.push_str(indent_str)
                    output.push_str(til_name(type_name))
                    output.push_str(" _err")
                    output.push_str(err_idx.to_str())
                    output.push_str("_")
                    output.push_str(temp_suffix)
                    output.push_str(";\n")
                case:
                }
            }

            // Detect and construct variadic array if needed
            mut variadic_arr_var := ""
            if found_variadic {
                mut variadic_args := Vec.new(Expr)
                start_idx := add(1, variadic_info.regular_count)
                for i in start_idx..arg.params.len() {
                    mut variadic_arg := Expr()
                    arg.params.get(i, variadic_arg)
                    variadic_args.push(variadic_arg)
                }
                if variadic_args.len().gt(0) {
                    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
                } else {
                    // Empty variadic - still need an array (with 0 elements)
                    empty_args := Vec.new(Expr)
                    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, empty_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
                }
            }

            // Emit the function call with output pointers
            output.push_str(indent_str)
            output.push_str("int _status_")
            output.push_str(temp_suffix)
            output.push_str(" = ")

            // Emit the function name and args (using nested hoisted temps)
            emit_fcall_name_and_args_for_throwing(arg, temp_var, temp_suffix, throwing_fd.throw_types, nested_hoisted, variadic_arr_var, output, ctx, context)

            output.push_str(";\n")

            // Emit error checking - propagate if any error occurred
            output.push_str(indent_str)
            output.push_str("if (_status_")
            output.push_str(temp_suffix)
            output.push_str(" != 0) {\n")

            // Propagate error based on status value
            // For now, propagate to corresponding error pointer in current function
            for err_idx in 0..throwing_fd.throw_types.len() {
                mut throw_type := ValueType.TCustom("")
                throwing_fd.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    // Find matching throw type in current function
                    for curr_idx in 0..ctx.current_throw_types.len() {
                        mut curr_throw := ValueType.TCustom("")
                        ctx.current_throw_types.get(curr_idx, curr_throw)
                        switch curr_throw {
                        case ValueType.TCustom(curr_type_name):
                            if curr_type_name.eq(type_name) {
                                output.push_str(indent_str)
                                output.push_str("    if (_status_")
                                output.push_str(temp_suffix)
                                output.push_str(" == ")
                                output.push_str(err_idx.add(1).to_str())
                                output.push_str(") { *_err")
                                output.push_str(curr_idx.add(1).to_str())
                                output.push_str(" = _err")
                                output.push_str(err_idx.to_str())
                                output.push_str("_")
                                output.push_str(temp_suffix)
                                output.push_str("; return ")
                                output.push_str(curr_idx.add(1).to_str())
                                output.push_str("; }\n")
                                break
                            }
                        case:
                        }
                    }
                case:
                }
            }

            output.push_str(indent_str)
            output.push_str("}\n")

            // Emit Array.delete if variadic array was constructed
            if variadic_arr_var.len().gt(0) {
                output.push_str(indent_str)
                output.push_str(TIL_PREFIX)
                output.push_str("Array_delete(&")
                output.push_str(variadic_arr_var)
                output.push_str(");\n")
            }

            // Record in hoisted_exprs map using expression address
            expr_addr := to_ptr(arg)
            ctx.hoisted_exprs.set(expr_addr, temp_var)
            mut h := HoistedArg()
            h.index = idx
            h.temp_var = temp_var
            hoisted.push(h)
        } else {
            // Handle non-throwing variadic calls
            if found_variadic {
                // RECURSIVELY hoist any throwing/variadic calls in this call's arguments first
                mut nested_hoisted := Map.new(I64, Str)
                if arg.params.len().gt(1) {
                    mut nested_args := Vec.new(Expr)
                    for i in 1..arg.params.len() {
                        mut nested_arg := Expr()
                        arg.params.get(i, nested_arg)
                        nested_args.push(nested_arg)
                    }
                    nested_vec := hoist_throwing_args(nested_args, output, indent, ctx, context)
                    for h_idx in 0..nested_vec.len() {
                        mut h := HoistedArg()
                        nested_vec.get(h_idx, h)
                        nested_hoisted.set(h.index, h.temp_var)
                    }
                }

                temp_var := next_mangled(ctx)

                // Determine return type from function
                func_name := get_fcall_func_name(arg)
                catch (err: KeyNotFoundError) {
                    throw arg.lang_error(context.path, "ccodegen", "Cannot determine function name")
                }
                fd := get_fcall_func_def(context, arg)
                catch (err: KeyNotFoundError) {
                    throw arg.lang_error(context.path, "ccodegen", format("Function not found: ", func_name))
                }
                mut ret_type := ValueType.TCustom("")
                fd.return_types.get(0, ret_type)
                catch (err: IndexOutOfBoundsError) {
                    throw arg.lang_error(context.path, "ccodegen", "Function has no return type")
                }
                c_type := til_type_to_c(ret_type)
                catch (err: Str) {
                    throw arg.lang_error(context.path, "ccodegen", err)
                }

                // Declare temp variable
                output.push_str(indent_str)
                output.push_str(c_type)
                output.push_str(" ")
                output.push_str(temp_var)
                output.push_str(";\n")

                // Construct variadic array
                mut variadic_args := Vec.new(Expr)
                start_idx := add(1, variadic_info.regular_count)
                for i in start_idx..arg.params.len() {
                    mut variadic_arg := Expr()
                    arg.params.get(i, variadic_arg)
                    variadic_args.push(variadic_arg)
                }
                mut variadic_arr_var := ""
                if variadic_args.len().gt(0) {
                    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
                } else {
                    empty_args := Vec.new(Expr)
                    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, empty_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
                }

                // Calculate param_by_ref and param_types for proper by-ref handling
                mut param_by_ref := Vec.new(Bool)
                mut param_types := Vec.new(ValueType)
                mut has_param_type := Vec.new(Bool)
                for i in 0..arg.params.len().sub(1) {
                    mut decl := Declaration()
                    fd.args.get(i, decl)
                    param_by_ref.push(param_needs_by_ref(decl))
                    param_types.push(decl.value_type)
                    has_param_type.push(true)
                    catch (err: IndexOutOfBoundsError) {
                        param_by_ref.push(false)
                        param_types.push(ValueType.TCustom(""))
                        has_param_type.push(false)
                    }
                }

                // Emit the function call (non-throwing, so direct assignment)
                output.push_str(indent_str)
                output.push_str(temp_var)
                output.push_str(" = ")

                // Emit function name
                output.push_str(til_func_name(func_name))
                output.push_str("(")

                // Emit regular args with proper by-ref handling
                mut first := true
                for i in 0..variadic_info.regular_count {
                    if not(first) {
                        output.push_str(", ")
                    }
                    first = false
                    mut param := Expr()
                    arg.params.get(i.add(1), param)
                    mut ptype := ValueType.TCustom("")
                    mut has_ptype := false
                    param_types.get(i, ptype)
                    has_param_type.get(i, has_ptype)
                    catch (err: IndexOutOfBoundsError) { }
                    mut ptype_ptr := Ptr()
                    if has_ptype {
                        ptype_ptr.data = to_ptr(ptype)
                    }
                    mut by_ref := false
                    param_by_ref.get(i, by_ref)
                    catch (err: IndexOutOfBoundsError) { }
                    emit_arg_with_param_type(param, i, nested_hoisted, ptype_ptr, by_ref, output, ctx, context)
                }

                // Emit variadic array pointer
                if not(first) {
                    output.push_str(", ")
                }
                output.push_str("&")
                output.push_str(variadic_arr_var)

                output.push_str(");\n")

                // Delete the variadic array
                output.push_str(indent_str)
                output.push_str(TIL_PREFIX)
                output.push_str("Array_delete(&")
                output.push_str(variadic_arr_var)
                output.push_str(");\n")

                // Record in hoisted_exprs map using expression address
                expr_addr := to_ptr(arg)
                ctx.hoisted_exprs.set(expr_addr, temp_var)
                mut h := HoistedArg()
                h.index = idx
                h.temp_var = temp_var
                hoisted.push(h)

            } else {
                // Handle non-throwing, non-variadic FCalls - still need to recurse into their arguments
                // to find deeply nested variadic/throwing calls (e.g., not(or(false)))
                // and also to hoist Dynamic params (e.g., Vec.contains(v, "bar"))
                switch arg.node_type {
                case NodeType.FCall:
                    if arg.params.len().gt(1) {
                        mut nested_args := Vec.new(Expr)
                        for i in 1..arg.params.len() {
                            mut nested_arg := Expr()
                            arg.params.get(i, nested_arg)
                            nested_args.push(nested_arg)
                        }
                        // Recurse to hoist any nested throwing/variadic calls
                        _ := hoist_throwing_args(nested_args, output, indent, ctx, context)

                        // Also hoist Dynamic params for this nested FCall
                        mut fd := get_fcall_func_def(context, arg)
                        mut param_types := Vec.new(ValueType)
                        for i in 0..fd.args.len() {
                            mut decl := Declaration()
                            fd.args.get(i, decl)
                            param_types.push(decl.value_type)
                        }
                        empty_hoisted := Map.new(I64, Str)
                        dynamic_hoisted := hoist_for_dynamic_params(nested_args, param_types, empty_hoisted, output, indent, ctx, context)
                        // Record hoisted Dynamic params in hoisted_exprs with & prefix
                        // (needed because emit_expr won't know to add & for Dynamic params)
                        for h_idx in 0..dynamic_hoisted.len() {
                            mut dh := HoistedArg()
                            dynamic_hoisted.get(h_idx, dh)
                            mut nested_arg := Expr()
                            nested_args.get(dh.index, nested_arg)
                            expr_addr := to_ptr(nested_arg)
                            ctx.hoisted_exprs.set(expr_addr, format("&", dh.temp_var))
                            catch (err: IndexOutOfBoundsError) { }
                        }
                        catch (err: KeyNotFoundError) { }
                    }
                    // Handle struct literal arguments (no args, or only named args) - need to hoist their throwing defaults
                    // For struct literals like Expr() passed as arguments, their throwing default field values
                    // (e.g., params = Vec.new(Expr)) need to be hoisted BEFORE the struct literal is created
                    else {
                        func_name := get_fcall_func_name(arg)
                        // Check if this is a struct literal (lookup_struct throws KeyNotFoundError if not found)
                        _ := context.scope_stack.lookup_struct(func_name)
                        // If we get here, it IS a struct literal - hoist its throwing defaults
                        _ := hoist_throwing_expr(arg, output, indent, ctx, context)
                        catch (err: KeyNotFoundError) {
                            // REM: Not a struct, skip - equivalent to Rust's None case
                        }
                    }
                // Bug #55 fix: Handle non-FCall arguments (like NamedArg) by recursing via hoist_throwing_expr
                // This ensures throwing calls inside named args are hoisted properly
                case:
                    _ := hoist_throwing_expr(arg, output, indent, ctx, context)
                    catch (err: KeyNotFoundError) { }
                }
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return hoisted
}

/// Hoist variadic arguments into a til_Array
/// Returns the array variable name, or None if no variadic args
/// Also returns the element type for use in Array.delete
hoist_variadic_args := proc(
    elem_type: Str,
    variadic_args: Vec,
    already_hoisted: Map,
    regular_count: I64,  // Offset for indexing into already_hoisted
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) returns Str throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }
    arr_var := next_mangled(ctx)
    err_suffix := next_mangled(ctx)
    variadic_count := variadic_args.len()

    // Declare the array variable
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Array ")
    output.push_str(arr_var)
    output.push_str(";\n")

    // Declare error vars for Array.new (AllocError) and Array.set (IndexOutOfBoundsError)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("AllocError _err_alloc_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("IndexOutOfBoundsError _err_idx_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    // Hoist variadic args into temp vars (needed to pass address to Array.set)
    mut arg_temps := Vec.new(Str)
    c_elem_type := format(TIL_PREFIX, elem_type)
    for i in 0..variadic_args.len() {
        mut arg := Expr()
        variadic_args.get(i, arg)
        hoisted_idx := regular_count.add(i)
        mut temp := ""
        already_hoisted.get(hoisted_idx, temp)
        // Already hoisted, use that temp
        arg_temps.push(temp)
        catch (err: KeyNotFoundError) {
            // Need to hoist into a temp
            temp_var := next_mangled(ctx)
            output.push_str(indent_str)
            output.push_str(c_elem_type)
            output.push_str(" ")
            output.push_str(temp_var)
            output.push_str(" = ")
            emit_expr(arg, output, 0, ctx, context)
            output.push_str(";\n")
            arg_temps.push(temp_var)
        }
    }

    // Bug #60: Hoist Type and I64 literals for Array.new call
    // Type param needs hoisting because we can't take address of string literal for const char* const*
    type_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Type ")
    output.push_str(type_temp)
    output.push_str(" = \"")
    output.push_str(elem_type)
    output.push_str("\";\n")

    // Capacity param needs hoisting because we can't take address of integer literal
    count_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("I64 ")
    output.push_str(count_temp)
    output.push_str(" = ")
    output.push_str(variadic_count.to_str())
    output.push_str(";\n")

    // Emit Array.new call with error handling
    // int _status = til_Array_new(&arr, &_err_alloc, &type_temp, &count_temp);
    output.push_str(indent_str)
    output.push_str("int _arr_status_")
    output.push_str(err_suffix)
    output.push_str(" = ")
    output.push_str(TIL_PREFIX)
    output.push_str("Array_new(&")
    output.push_str(arr_var)
    output.push_str(", &_err_alloc_")
    output.push_str(err_suffix)
    // Bug #60: Type is already const char*, pass by value (no &)
    output.push_str(", ")
    output.push_str(type_temp)
    output.push_str(", &")
    output.push_str(count_temp)
    output.push_str(");\n")

    // Emit error check for Array.new (AllocError -> propagate if current function throws it)
    output.push_str(indent_str)
    output.push_str("if (_arr_status_")
    output.push_str(err_suffix)
    output.push_str(" != 0) {\n")
    // Propagate AllocError if current function throws it
    for curr_idx in 0..ctx.current_throw_types.len() {
        mut curr_throw := ValueType.TCustom("")
        ctx.current_throw_types.get(curr_idx, curr_throw)
        switch curr_throw {
        case ValueType.TCustom(curr_type_name):
            if curr_type_name.eq("AllocError") {
                output.push_str(indent_str)
                output.push_str("    *_err")
                output.push_str(curr_idx.add(1).to_str())
                output.push_str(" = _err_alloc_")
                output.push_str(err_suffix)
                output.push_str("; return ")
                output.push_str(curr_idx.add(1).to_str())
                output.push_str(";\n")
                break
            }
        case:
        }
    }
    output.push_str(indent_str)
    output.push_str("}\n")

    // Emit Array.set for each variadic arg
    for i in 0..arg_temps.len() {
        mut temp := ""
        arg_temps.get(i, temp)

        // Bug #60: Hoist index literal because we can't take address of integer literal
        idx_temp := next_mangled(ctx)
        output.push_str(indent_str)
        output.push_str(TIL_PREFIX)
        output.push_str("I64 ")
        output.push_str(idx_temp)
        output.push_str(" = ")
        output.push_str(i.to_str())
        output.push_str(";\n")

        // int _status = til_Array_set(&_err_idx, &arr, &idx_temp, (til_Dynamic*)&temp);
        output.push_str(indent_str)
        output.push_str("_arr_status_")
        output.push_str(err_suffix)
        output.push_str(" = ")
        output.push_str(TIL_PREFIX)
        output.push_str("Array_set(&_err_idx_")
        output.push_str(err_suffix)
        output.push_str(", &")
        output.push_str(arr_var)
        output.push_str(", &")
        output.push_str(idx_temp)
        output.push_str(", (")
        output.push_str(TIL_PREFIX)
        output.push_str("Dynamic*)&")
        output.push_str(temp)
        output.push_str(");\n")

        // Error check for Array.set (IndexOutOfBoundsError - shouldn't happen but propagate if thrown)
        output.push_str(indent_str)
        output.push_str("if (_arr_status_")
        output.push_str(err_suffix)
        output.push_str(" != 0) {\n")
        for curr_idx in 0..ctx.current_throw_types.len() {
            mut curr_throw := ValueType.TCustom("")
            ctx.current_throw_types.get(curr_idx, curr_throw)
            switch curr_throw {
            case ValueType.TCustom(curr_type_name):
                if curr_type_name.eq("IndexOutOfBoundsError") {
                    output.push_str(indent_str)
                    output.push_str("    *_err")
                    output.push_str(curr_idx.add(1).to_str())
                    output.push_str(" = _err_idx_")
                    output.push_str(err_suffix)
                    output.push_str("; return ")
                    output.push_str(curr_idx.add(1).to_str())
                    output.push_str(";\n")
                    break
                }
            case:
            }
        }
        output.push_str(indent_str)
        output.push_str("}\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    return arr_var
}

/// Emit a throwing function call's name and arguments for hoisting
/// Outputs: func_name(&temp_var, &err1, &err2, ..., args...)
/// If variadic_arr_var is Some, use that pre-constructed array instead of building one
emit_fcall_name_and_args_for_throwing := proc(
    expr: Expr,
    temp_var: Str,
    temp_suffix: Str,
    throw_types: Vec,
    nested_hoisted: Map,  // Hoisted temps for nested args
    variadic_arr_var: Str,  // Pre-constructed variadic array var ("" if none)
    mut output: Str,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    if expr.params.len().eq(0) {
        throw "emit_fcall_name_and_args_for_throwing: FCall with no params"
    }

    // Get function name (handles both nested identifiers and precomp'd "Type.method" strings)
    mut first_param := Expr()
    expr.params.get(0, first_param)
    mut func_name := get_func_name_string(first_param)
    catch (err: KeyNotFoundError) {
        throw "emit_fcall_name_and_args_for_throwing: FCall first param not Identifier"
    }

    // For lookups, we need the original name with dots
    mut orig_func_name := get_til_func_name_string(first_param)
    catch (err: KeyNotFoundError) {
        orig_func_name = func_name
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    if ctx.nested_func_names.contains_key(orig_func_name) {
        mut mangled_name := ""
        ctx.nested_func_names.get(orig_func_name, mangled_name)
        func_name = mangled_name
        catch (err: KeyNotFoundError) { }
    }

    // Emit function name (func_name already has underscores for type-qualified calls)
    output.push_str(TIL_PREFIX)
    output.push_str(func_name)
    output.push_str("(&")
    output.push_str(temp_var)

    // Add error output pointers
    for idx in 0..throw_types.len() {
        output.push_str(", &_err")
        output.push_str(idx.to_str())
        output.push_str("_")
        output.push_str(temp_suffix)
    }

    // Check if this is a variadic function call
    if ctx.func_variadic_args.contains_key(orig_func_name) {
        mut variadic_info := VariadicParamInfo()
        ctx.func_variadic_args.get(orig_func_name, variadic_info)
        regular_count := variadic_info.regular_count

        // Bug #60: Get function param info for proper by-ref handling of regular args
        mut param_info := Vec.new(ParamTypeInfo)
        mut found_func := get_fcall_func_def(context, expr)
        for i in 0..found_func.args.len() {
            mut p := Declaration()
            found_func.args.get(i, p)
            mut info := ParamTypeInfo()
            info.value_type = Ptr.new(ValueType)
            memcpy(info.value_type.data, to_ptr(p.value_type), size_of(ValueType))
            info.by_ref = param_needs_by_ref(p)
            param_info.push(info)
        }
        catch (err: KeyNotFoundError) { }

        // Emit regular args first (skip first param which is function name)
        for arg_idx in 0..regular_count {
            output.push_str(", ")
            mut arg := Expr()
            expr.params.get(arg_idx.add(1), arg)
            // Bug #60: Use emit_arg_with_param_type for proper by-ref handling
            mut info := ParamTypeInfo()
            param_info.get(arg_idx, info)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, nested_hoisted, info.value_type, info.by_ref, output, ctx, context)
        }

        // Emit variadic array pointer
        if variadic_arr_var.len().gt(0) {
            output.push_str(", &")
            output.push_str(variadic_arr_var)
        } else {
            // No pre-constructed array - this shouldn't happen for throwing calls
            throw "emit_fcall_name_and_args_for_throwing: variadic call without pre-constructed array"
        }
    } else {
        // Not a variadic function - emit all args normally
        // Get function param info for Dynamic casting, mut handling
        mut param_info2 := Vec.new(ParamTypeInfo)
        mut found_func2 := get_fcall_func_def(context, expr)
        for i in 0..found_func2.args.len() {
            mut p := Declaration()
            found_func2.args.get(i, p)
            mut info := ParamTypeInfo()
            info.value_type = Ptr.new(ValueType)
            memcpy(info.value_type.data, to_ptr(p.value_type), size_of(ValueType))
            info.by_ref = param_needs_by_ref(p)
            param_info2.push(info)
        }
        catch (err: KeyNotFoundError) { }

        // Emit remaining arguments (using hoisted temps where available)
        for arg_idx in 0..expr.params.len().sub(1) {
            output.push_str(", ")
            mut arg := Expr()
            expr.params.get(arg_idx.add(1), arg)

            // Get expected param type and mutability
            mut info := ParamTypeInfo()
            param_info2.get(arg_idx, info)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, nested_hoisted, info.value_type, info.by_ref, output, ctx, context)
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    output.push_str(")")
}

/// Emit an argument, using hoisted temp var if available
/// Also handles Type arguments by emitting them as string literals
emit_arg_or_hoisted := proc(
    arg: Expr,
    arg_idx: I64,
    hoisted: Map,
    mut output: Str,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    emit_arg_with_param_type(arg, arg_idx, hoisted, Ptr(), false, output, ctx, context)
}

/// Emit an argument with knowledge of expected parameter type and by-ref flag
/// Handles: Type args as string literals, Dynamic args with &, by-ref args with &
emit_arg_with_param_type := proc(
    arg: Expr,
    arg_idx: I64,
    hoisted: Map,
    param_type: Ptr,  // Ptr to ValueType, NULL = None
    param_by_ref: Bool,
    mut output: Str,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    if hoisted.contains_key(arg_idx) {
        mut temp_var := ""
        hoisted.get(arg_idx, temp_var)
        // Hoisted temp var is an lvalue - add & if param is Dynamic or by-ref
        if param_by_ref {
            output.push_str("&")
        } else {
            if not(param_type.is_null()) {
                mut pt := ValueType.TCustom("")
                memcpy(to_ptr(pt), param_type.data, size_of(ValueType))
                switch pt {
                case ValueType.TCustom(param_type_name):
                    if param_type_name.eq("Dynamic") {
                        output.push_str("&")
                    }
                case:
                }
            }
        }
        output.push_str(temp_var)
        return
    }

    // Also check ctx.hoisted_exprs for expressions hoisted via other mechanisms
    arg_addr := to_ptr(arg)
    if ctx.hoisted_exprs.contains_key(arg_addr) {
        mut temp_expr := ""
        ctx.hoisted_exprs.get(arg_addr, temp_expr)
        // hoisted_exprs may store just the temp var name or with & prefix
        // Add & if param is by-ref and temp_expr doesn't already start with &
        if param_by_ref {
            if not(temp_expr.starts_with("&")) {
                output.push_str("&")
            }
        }
        output.push_str(temp_expr)
        return
    }

    // Check if arg is a type identifier - emit as string literal (matches interpreter.rs)
    mut type_name := ""
    mut has_type_name := false
    type_name = get_type_arg_name(arg, context)
    has_type_name = true
    catch (err: KeyNotFoundError) { }
    if has_type_name {
        output.push_str("\"")
        output.push_str(type_name)
        output.push_str("\"")
        return
    }

    // Check if parameter type is Dynamic (including mut Dynamic)
    // Must check BEFORE the general mut check since Dynamic needs casting
    mut is_dynamic := false
    if not(param_type.is_null()) {
        mut pt := ValueType.TCustom("")
        memcpy(to_ptr(pt), param_type.data, size_of(ValueType))
        switch pt {
        case ValueType.TCustom(name):
            if name.eq("Dynamic") {
                is_dynamic = true
            }
        case:
        }
    }
    if is_dynamic {
        // Check if arg is a simple identifier (can take address directly)
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.len().eq(0) {
                // Check if this identifier is already a pointer:
                // - mut params are passed as pointers
                // - variadic params are passed as Array pointers
                // - Dynamic params are already void* (no need to take address)
                mut is_already_pointer := false
                if ctx.current_ref_params.contains(name) {
                    is_already_pointer = true
                } else {
                    if ctx.current_variadic_params.contains_key(name) {
                        is_already_pointer = true
                    } else {
                        sym := context.scope_stack.lookup_symbol(name)
                        switch sym.value_type {
                        case ValueType.TCustom(t):
                            if t.eq("Dynamic") {
                                is_already_pointer = true
                            }
                        case:
                        }
                        catch (err: KeyNotFoundError) { }
                    }
                }
                if is_already_pointer {
                    // Already a pointer - just cast without &
                    output.push_str("(")
                    output.push_str(TIL_PREFIX)
                    output.push_str("Dynamic*)")
                    output.push_str(til_name(name))
                } else {
                    // Simple variable - cast to til_Dynamic* (void**) and take address
                    output.push_str("(")
                    output.push_str(TIL_PREFIX)
                    output.push_str("Dynamic*)&")
                    output.push_str(til_name(name))
                }
                return
            } else {
                // Check if this is an enum constructor (Type.Variant) - need temp variable
                if arg.params.len().gt(0) {
                    mut first_param := Expr()
                    arg.params.get(0, first_param)
                    switch first_param.node_type {
                    case NodeType.Identifier(field_name):
                        combined := format(name, ".", field_name)
                        if context.scope_stack.is_enum_constructor(combined) {
                            // Enum constructor passed as Dynamic - need temp variable
                            c_type := format(TIL_PREFIX, name)
                            temp_var := next_mangled(ctx)
                            output.push_str("(")
                            output.push_str(TIL_PREFIX)
                            output.push_str("Dynamic*)({ ")
                            output.push_str(c_type)
                            output.push_str(" ")
                            output.push_str(temp_var)
                            output.push_str(" = ")
                            emit_expr(arg, output, 0, ctx, context)
                            output.push_str("; &")
                            output.push_str(temp_var)
                            output.push_str("; })")
                            return
                        }
                    case:
                    }
                }
                // Field access like member.name - need (til_Dynamic*)&(var.field)
                // Check if base is a mut param (pointer) or regular variable
                base_is_pointer := ctx.current_ref_params.contains(name)
                output.push_str("(")
                output.push_str(TIL_PREFIX)
                output.push_str("Dynamic*)&")
                output.push_str(til_name(name))
                for i in 0..arg.params.len() {
                    mut param := Expr()
                    arg.params.get(i, param)
                    switch param.node_type {
                    case NodeType.Identifier(field):
                        if base_is_pointer {
                            if i.eq(0) {
                                output.push_str("->")
                            } else {
                                output.push_str(".")
                            }
                        } else {
                            output.push_str(".")
                        }
                        // Field names don't get til_ prefix
                        output.push_str(field)
                    case:
                    }
                }
                return
            }
        case:
        }
        // For non-identifier args (literals, compound literals), emit with (til_Dynamic*)&
        // But first check if already hoisted (hoisted_exprs already includes & prefix)
        arg_addr := to_ptr(arg)
        if ctx.hoisted_exprs.contains_key(arg_addr) {
            // Already hoisted with & prefix - just emit it
            emit_expr(arg, output, 0, ctx, context)
        } else {
            switch arg.node_type {
            case NodeType.LLiteral(_):
                // Compound literals are lvalues in C99+, so &((til_Str){...}) works
                output.push_str("(")
                output.push_str(TIL_PREFIX)
                output.push_str("Dynamic*)&")
                emit_expr(arg, output, 0, ctx, context)
            case:
                // Other non-identifier args (function calls, etc.) - emit as-is
                emit_expr(arg, output, 0, ctx, context)
            }
        }
        return
    }

    // Check if param is mut (but not Dynamic) - emit &arg for pointer
    if param_by_ref {
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.len().eq(0) {
                // Check if this identifier is already a mut param (already a pointer)
                // or a variadic param (also a pointer) - don't add & again
                mut is_already_pointer := false
                if ctx.current_ref_params.contains(name) {
                    is_already_pointer = true
                } else {
                    if ctx.current_variadic_params.contains_key(name) {
                        is_already_pointer = true
                    }
                }
                if is_already_pointer {
                    // Already a pointer - just emit the name
                    output.push_str(til_name(name))
                } else {
                    // Simple variable - emit &var
                    output.push_str("&")
                    output.push_str(til_name(name))
                }
                return
            } else {
                // Check if this is a struct constant access (Type.CONSTANT) vs field access (var.field)
                if arg.params.len().gt(0) {
                    mut first_param := Expr()
                    arg.params.get(0, first_param)
                    switch first_param.node_type {
                    case NodeType.Identifier(field_name):
                        // Check if 'name' is a struct type and 'field_name' is a constant
                        struct_def := context.scope_stack.lookup_struct(name)
                        // Check if this field is a constant (in default_values and not mut)
                        if struct_def.default_values.contains_key(field_name) {
                            // Struct constant - emit &til_StructName_constant
                            output.push_str("&")
                            output.push_str(til_name(name))
                            output.push_str("_")
                            output.push_str(field_name)
                            return
                        }
                        catch (err: KeyNotFoundError) { }

                        // Bug #60: Check if this is an enum constructor (Type.Variant)
                        // Enum constructors need a temp variable to take address
                        combined := format(name, ".", field_name)
                        if context.scope_stack.is_enum_constructor(combined) {
                            // Get the enum type for C type name
                            c_type := format(TIL_PREFIX, name)
                            temp_var := next_mangled(ctx)
                            output.push_str("({ ")
                            output.push_str(c_type)
                            output.push_str(" ")
                            output.push_str(temp_var)
                            output.push_str(" = ")
                            emit_expr(arg, output, 0, ctx, context)
                            output.push_str("; &")
                            output.push_str(temp_var)
                            output.push_str("; })")
                            return
                        }
                    case:
                    }
                }
                // Handle UFCS placeholder "_" - chained expression like get_foo().bar
                // The base expression (params[0]) may be an rvalue (function call), so use temp var
                if name.eq("_") {
                    if arg.params.len().gt(0) {
                        // Get the type of the full expression for the temp var
                        mut c_type := "int"
                        vt := get_value_type(context, arg)
                        c_type = til_type_to_c(vt)
                        catch (err: Str) {
                            c_type = "int"
                        }
                        temp_var := next_mangled(ctx)
                        output.push_str("({ ")
                        output.push_str(c_type)
                        output.push_str(" ")
                        output.push_str(temp_var)
                        output.push_str(" = ")
                        emit_expr(arg, output, 0, ctx, context)
                        output.push_str("; &")
                        output.push_str(temp_var)
                        output.push_str("; })")
                        return
                    }
                }
                // Field access like self.type_names - need &(self->field) or &(var.field)
                // Check if base is a mut param (pointer) or regular variable
                base_is_pointer := ctx.current_ref_params.contains(name)
                output.push_str("&")
                output.push_str(til_name(name))
                for i in 0..arg.params.len() {
                    mut param := Expr()
                    arg.params.get(i, param)
                    switch param.node_type {
                    case NodeType.Identifier(field):
                        if base_is_pointer {
                            if i.eq(0) {
                                output.push_str("->")
                            } else {
                                output.push_str(".")
                            }
                        } else {
                            output.push_str(".")
                        }
                        output.push_str(field)
                    case:
                    }
                }
                return
            }
        case:
        }
        // For non-identifier args that need by-ref passing:
        // - Str literals become compound literals, can use &((til_Str){...})
        // - FCall results are rvalues, use compound literal: &(Type){fcall()}
        // - I64 literals use compound literal: &(til_I64){42}
        switch arg.node_type {
        case NodeType.LLiteral(lit):
            switch lit {
            case Literal.Str(_):
                output.push_str("&")
                emit_expr(arg, output, 0, ctx, context)
            case Literal.Number(_):
                // Bug #60: Number literal, use compound literal: &(til_I64){42}
                output.push_str("&(")
                output.push_str(TIL_PREFIX)
                output.push_str("I64){")
                emit_expr(arg, output, 0, ctx, context)
                output.push_str("}")
            case:
                emit_expr(arg, output, 0, ctx, context)
            }
        case NodeType.FCall:
            // Bug #60: FCall result is rvalue, can't take address directly
            // For simple typedefs like I64: use compound literal &(Type){fcall()}
            // For struct types: use GCC statement expression ({ Type _t = fcall(); &_t; })
            fd := get_fcall_func_def(context, arg)
            mut ret_type := ValueType.TCustom("")
            fd.return_types.get(0, ret_type)
            c_type := til_type_to_c(ret_type)
            // Check if return type is a simple typedef (I64) vs struct
            // I64 is the only simple typedef - all others are structs
            mut is_simple_type := false
            switch ret_type {
            case ValueType.TCustom(ret_name):
                if ret_name.eq("I64") {
                    is_simple_type = true
                }
            case:
            }
            if is_simple_type {
                output.push_str("&(")
                output.push_str(c_type)
                output.push_str("){")
                emit_expr(arg, output, 0, ctx, context)
                output.push_str("}")
            } else {
                // Struct type - use GCC statement expression
                temp_var := next_mangled(ctx)
                output.push_str("({ ")
                output.push_str(c_type)
                output.push_str(" ")
                output.push_str(temp_var)
                output.push_str(" = ")
                emit_expr(arg, output, 0, ctx, context)
                output.push_str("; &")
                output.push_str(temp_var)
                output.push_str("; })")
            }
            catch (err: Str) {
                emit_expr(arg, output, 0, ctx, context)
            }
            catch (err: IndexOutOfBoundsError) {
                emit_expr(arg, output, 0, ctx, context)
            }
            catch (err: KeyNotFoundError) {
                // Bug #60: No function def found - might be enum/struct constructor FCall
                // Use get_value_type to infer the result type
                vt := get_value_type(context, arg)
                switch vt {
                case ValueType.TCustom(type_name):
                    // Custom type constructor - use statement expression
                    c_type := format(TIL_PREFIX, type_name)
                    temp_var := next_mangled(ctx)
                    output.push_str("({ ")
                    output.push_str(c_type)
                    output.push_str(" ")
                    output.push_str(temp_var)
                    output.push_str(" = ")
                    emit_expr(arg, output, 0, ctx, context)
                    output.push_str("; &")
                    output.push_str(temp_var)
                    output.push_str("; })")
                case:
                    emit_expr(arg, output, 0, ctx, context)
                }
            }
        case:
            emit_expr(arg, output, 0, ctx, context)
        }
        return
    }

    // Check if arg is a variadic param (which is til_Array*) but expected param is NOT mut
    // In this case we need to dereference: (*til_args) to get til_Array by value
    switch arg.node_type {
    case NodeType.Identifier(name):
        if arg.params.len().eq(0) {
            if ctx.current_variadic_params.contains_key(name) {
                output.push_str("(*")
                output.push_str(til_name(name))
                output.push_str(")")
                return
            }
        }
    case:
    }

    emit_expr(arg, output, 0, ctx, context)

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
}

collect_func_info := proc(expr: Expr, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Top-level function - check for variadic args (TMulti)
                for idx in 0..func_def.args.len() {
                    mut arg := Declaration()
                    func_def.args.get(idx, arg)
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type):
                        mut info := VariadicParamInfo()
                        info.elem_type = elem_type
                        info.regular_count = idx
                        ctx.func_variadic_args.set(decl.name, info)
                        break  // Only one variadic arg per function
                    case:
                    }
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            case NodeType.StructDef(struct_def):
                // Struct methods - use mangled names (StructName_methodName)
                struct_name := decl.name
                for member_name: Str in struct_def.default_values.keys {
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        mangled_name := format(struct_name, "_", member_name)
                        // Check for variadic args (TMulti) in struct methods
                        for idx in 0..func_def.args.len() {
                            mut arg := Declaration()
                            func_def.args.get(idx, arg)
                            switch arg.value_type {
                            case ValueType.TMulti(elem_type):
                                mut info := VariadicParamInfo()
                                info.elem_type = elem_type
                                info.regular_count = idx
                                ctx.func_variadic_args.set(mangled_name, info)
                                break
                            case:
                            }
                        }
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                    case:
                    }
                    catch (err: KeyNotFoundError) { /* skip */ }
                    catch (err: AllocError) { throw err.msg }
                    catch (err: I64_OverflowError) { throw err.msg }
                }
            case:
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
    case:
    }
}

// Collect nested function info (for hoisting): scan function bodies for nested FuncDef declarations
// This populates ctx.nested_func_names and ctx.hoisted_prototypes before we emit function bodies
collect_nested_func_info := proc(expr: Expr, mut ctx: CodegenContext, parent_func_name: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                if parent_func_name.len().gt(0) {
                    // This is a nested function - record it for hoisting
                    mangled_name := parent_func_name.concat("_").concat(decl.name)
                    ctx.nested_func_names.set(decl.name, mangled_name)

                    // Generate prototype using emit_func_signature (handles throwing functions properly)
                    mut proto := ""
                    proto = emit_func_signature(til_name(mangled_name), func_def, proto)
                    proto = proto.concat(";\n")
                    ctx.hoisted_prototypes.push(proto)

                    // Recursively check for nested functions within this nested function
                    for body_expr: Expr in func_def.body {
                        collect_nested_func_info(body_expr, ctx, mangled_name)
                    }
                } else {
                    // Top-level function - scan its body for nested functions
                    for body_expr: Expr in func_def.body {
                        collect_nested_func_info(body_expr, ctx, decl.name)
                    }
                }
            case:
                // Not a FuncDef
            }
        }
    case NodeType.Body:
        for child: Expr in expr.params {
            collect_nested_func_info(child, ctx, parent_func_name)
        }
    case NodeType.If:
        // Check then and else branches (params[0] = condition, params[1] = then, params[2] = else)
        if expr.params.len().gt(1) {
            mut then_branch := Expr()
            expr.params.get(1, then_branch)
            collect_nested_func_info(then_branch, ctx, parent_func_name)
        }
        if expr.params.len().gt(2) {
            mut else_branch := Expr()
            expr.params.get(2, else_branch)
            collect_nested_func_info(else_branch, ctx, parent_func_name)
        }
    case NodeType.While:
        // Check loop body (params[0] = condition, params[1] = body)
        if expr.params.len().gt(1) {
            mut body := Expr()
            expr.params.get(1, body)
            collect_nested_func_info(body, ctx, parent_func_name)
        }
    case NodeType.Switch:
        // Check all case bodies (params[0] = value, rest are cases)
        for i in 1..expr.params.len() {
            mut case_expr := Expr()
            expr.params.get(i, case_expr)
            collect_nested_func_info(case_expr, ctx, parent_func_name)
        }
    case:
        // Recursively check all params for other node types
        for child: Expr in expr.params {
            collect_nested_func_info(child, ctx, parent_func_name)
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit function signature (used by both prototype and definition)
// For throwing functions:
//   int func_name(RetType* _ret, Error1* _err1, Error2* _err2, args...)
// For non-throwing:
//   RetType func_name(args...)
emit_func_signature := proc(func_name: Str, func_def: SFuncDef, mut output: Str) throws Str {
    mut is_throwing := func_def.throw_types.len().gt(0)

    if is_throwing {
        // Throwing function returns int status code
        output = output.concat("int ")
    } else {
        // Non-throwing function returns its actual type
        if func_def.return_types.len().eq(0) {
            output = output.concat("void ")
        } else {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            output = output.concat(til_type_to_c(ret_type))
            output = output.concat(" ")
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
    }

    output = output.concat(func_name).concat("(")

    mut param_count := 0

    if is_throwing {
        // Output params first: return value pointer, then error pointers
        if func_def.return_types.len().gt(0) {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            output = output.concat(til_type_to_c(ret_type)).concat("* _ret")
            param_count = param_count.add(1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        // Error output parameters
        for i in 0..func_def.throw_types.len() {
            if param_count.gt(0) {
                output = output.concat(", ")
            }
            mut throw_type := ValueType.TCustom("")
            func_def.throw_types.get(i, throw_type)
            mut err_type := value_type_to_c_name(throw_type)
            output = output.concat(err_type).concat("* _err").concat(i.add(1).to_str())
            param_count = param_count.add(1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
    }

    // Input parameters
    for j in 0..func_def.args.len() {
        if param_count.gt(0) {
            output = output.concat(", ")
        }
        mut arg := Declaration()
        func_def.args.get(j, arg)

        // Check for variadic arg (TMulti)
        switch arg.value_type {
        case ValueType.TMulti(elem_type_name):
            // Variadic args are passed as til_Array*
            output = output.concat(TIL_PREFIX).concat("Array* ").concat(TIL_PREFIX).concat(arg.name)
            param_count = param_count.add(1)
            // Variadic must be last, so break
            break
        case:
            // Regular arg - Bug #60: use param_needs_by_ref for pointer determination
            // Type is already const char*, don't add extra indirection
            mut is_type_param := false
            switch arg.value_type {
            case ValueType.TCustom(name):
                if name.eq("Type") {
                    is_type_param = true
                }
            case:
            }
            if arg.is_mut {
                // mut: pass by pointer so mutations are visible to caller
                output = output.concat(til_type_to_c(arg.value_type)).concat("* ")
            } else if arg.is_own {
                // own: pass by pointer, caller transfers ownership
                // Type is already a pointer, so pass by value
                if is_type_param {
                    output = output.concat(til_type_to_c(arg.value_type)).concat(" ")
                } else {
                    output = output.concat(til_type_to_c(arg.value_type)).concat("* ")
                }
            } else if arg.is_copy {
                // copy: pass by value, caller's copy is made
                output = output.concat(til_type_to_c(arg.value_type)).concat(" ")
            } else {
                // const (default): pass by const pointer, read-only
                // Type is already a pointer, so pass by value
                if is_type_param {
                    output = output.concat(til_type_to_c(arg.value_type)).concat(" ")
                } else {
                    output = output.concat("const ").concat(til_type_to_c(arg.value_type)).concat("* ")
                }
            }
            output = output.concat(TIL_PREFIX).concat(arg.name)
            param_count = param_count.add(1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    if param_count.eq(0) {
        output = output.concat("void")
    }

    output = output.concat(")")
}

/// Get the function name from an FCall expression (returns underscore format like Type_method)
/// This returns the name WITHOUT til_ prefix.
/// For C output, use til_name() on the result.
get_fcall_func_name := func(expr: Expr) returns Str throws Str, KeyNotFoundError {
    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg="get_fcall_func_name: no params")
    }

    // get_func_name_string already handles both nested identifiers (Type.method)
    // and precomp'd strings ("Type.method"), returning "Type_method" format
    return get_func_name_string(first)
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(_):
        if not(expr.params.is_empty()) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(_):
                return true
            case:
            }
        }
    case:
    }
    return false
}

// Get struct name from a struct declaration expression
// Returns empty string if not a struct declaration
get_struct_name := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.StructDef(_):
                return decl.name
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Extract struct field type dependencies for topological sorting
// Returns the type name if it's a custom type that needs to be defined first
// Returns empty string if no dependency (like Rust's Option::None)
get_field_type_dependency := func(value_type: ValueType) returns Str {
    switch value_type {
    case ValueType.TCustom(name):
        // I64 and U8 are primitives, not struct dependencies
        if name.eq("I64").or(name.eq("U8")).or(name.eq(INFER_TYPE)) {
            return ""
        }
        return name
    case:
        return ""
    }
}

// Get struct dependencies (other struct types used as fields)
get_struct_dependencies := func(expr: Expr) returns Vec throws Str {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return deps }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                for member: Declaration in struct_def.members {
                    if member.is_mut {
                        dep := get_field_type_dependency(member.value_type)
                        if dep.len().gt(0) {
                            deps.push(dep)
                        }
                    }
                }
            case:
            }
        }
    case:
    }
    catch (err: AllocError) { throw err.msg }
    return deps
}

// Get enum dependencies (types used in payloads) as a Vec
get_enum_dependencies := func(expr: Expr) returns Vec throws Str {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration(_):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return deps }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                for ev: EnumVariant in enum_def.variants {
                    payload_ptr := ev.payload_type
                    // Check if payload exists (not NULL)
                    if not(NULL.eq(payload_ptr.data)) {
                        mut payload_type := ValueType.TCustom("")
                        memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                        switch payload_type {
                        case ValueType.TCustom(type_name):
                            // Skip primitives (but NOT Str or Bool - they're structs)
                            if not(type_name.eq("I64")) {
                                if not(type_name.eq("U8")) {
                                    if not(type_name.eq("Dynamic")) {
                                        if not(type_name.eq("Type")) {
                                            deps.push(type_name)
                                        }
                                    }
                                }
                            }
                        case:
                        }
                    }
                }
            case:
            }
        }
    case:
    }
    catch (err: AllocError) { throw err.msg }
    return deps
}

// Get enum name from an enum-with-payloads declaration expression
get_enum_name := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.EnumDef(_):
                return decl.name
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Get dependencies for a type (struct or enum-with-payloads)
get_type_dependencies := func(expr: Expr) returns Vec throws Str {
    if is_struct_declaration(expr) {
        return get_struct_dependencies(expr)
    }
    if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_dependencies(expr)
    }
    return Vec.new(Str)
}

// Get name for a type (struct or enum-with-payloads)
get_type_name := func(expr: Expr) returns Str {
    if is_struct_declaration(expr) {
        return get_struct_name(expr)
    }
    if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_name(expr)
    }
    return ""
}

// Topologically sort type declarations (structs and enums-with-payloads) by their dependencies
// Returns indices into the original vector in sorted order
topological_sort_types := func(types: Vec) returns Vec throws Str {
    mut result := Vec.new(I64)
    mut n := types.len()

    // Build name -> index map
    mut name_to_idx := Map.new(Str, I64)
    for idx in 0..n {
        mut expr := Expr()
        types.get(idx, expr)
        mut name := get_type_name(expr)
        if name.len().gt(0) {
            name_to_idx.set(name, idx)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    }

    // Build adjacency list (dependencies)
    mut deps := Vec.new(Vec)
    for idx in 0..n {
        deps.push(Vec.new(I64))
        catch (err: AllocError) { throw err.msg }
    }
    for idx in 0..n {
        mut expr := Expr()
        types.get(idx, expr)
        mut type_deps := get_type_dependencies(expr)
        for dep_idx in 0..type_deps.len() {
            mut dep_name := ""
            type_deps.get(dep_idx, dep_name)
            if name_to_idx.contains_key(dep_name) {
                mut dep_type_idx := 0
                name_to_idx.get(dep_name, dep_type_idx)
                catch (err: KeyNotFoundError) { throw err.msg }
                if not(dep_type_idx.eq(idx)) {
                    mut idx_deps := Vec.new(I64)
                    deps.get(idx, idx_deps)
                    idx_deps.push(dep_type_idx)
                    deps.set(idx, idx_deps)
                }
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Kahn's algorithm for topological sort
    // If A depends on B, B must come first, so reverse the edges
    mut reverse_deps := Vec.new(Vec)
    for idx in 0..n {
        reverse_deps.push(Vec.new(I64))
        catch (err: AllocError) { throw err.msg }
    }
    for idx in 0..n {
        mut dep_list := Vec.new(I64)
        deps.get(idx, dep_list)
        for dep_idx in 0..dep_list.len() {
            mut dep := 0
            dep_list.get(dep_idx, dep)
            mut rev_deps := Vec.new(I64)
            reverse_deps.get(dep, rev_deps)
            rev_deps.push(idx)
            reverse_deps.set(dep, rev_deps)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Calculate in-degree for reversed graph
    mut in_degree := Vec.new(I64)
    for idx in 0..n {
        in_degree.push(0)
        catch (err: AllocError) { throw err.msg }
    }
    for idx in 0..n {
        mut dep_list := Vec.new(I64)
        reverse_deps.get(idx, dep_list)
        for dep_idx in 0..dep_list.len() {
            mut dep := 0
            dep_list.get(dep_idx, dep)
            mut degree := 0
            in_degree.get(dep, degree)
            in_degree.set(dep, degree.add(1))
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Start with nodes that have in-degree 0
    mut queue := Vec.new(I64)
    for idx in 0..n {
        mut degree := 0
        in_degree.get(idx, degree)
        if degree.eq(0) {
            queue.push(idx)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    }

    // Process queue
    while queue.len().gt(0) {
        mut current := 0
        queue.pop(current)
        result.push(current)

        // For each node that current points to, decrement in-degree
        mut edges := Vec.new(I64)
        reverse_deps.get(current, edges)
        for edge_idx in 0..edges.len() {
            mut next := 0
            edges.get(edge_idx, next)
            mut degree := 0
            in_degree.get(next, degree)
            in_degree.set(next, degree.sub(1))
            if degree.sub(1).eq(0) {
                queue.push(next)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    }

    // If we couldn't sort all (cycle), append remaining in original order
    if result.len().lt(n) {
        for idx in 0..n {
            mut found := false
            for i in 0..result.len() {
                mut val := 0
                result.get(i, val)
                if val.eq(idx) {
                    found = true
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }
            if not(found) {
                result.push(idx)
            }
            catch (err: AllocError) { throw err.msg }
        }
    }

    return result
}

// Check if an expression is an enum declaration (Name := enum {...})
is_enum_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(_):
        if not(expr.params.is_empty()) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(_):
                return true
            case:
            }
        }
    case:
    }
    return false
}

// Check if an expression is an enum declaration with payloads
is_enum_with_payloads := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(_):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return enum_has_payloads(enum_def)
            case:
            }
        }
    case:
    }
    return false
}

// Check if an expression is a top-level constant declaration (name := literal)
// Constants are non-mut declarations with literal values (numbers, strings, bools)
is_constant_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Must not be mutable
        if decl.is_mut {
            return false
        }
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            // Literal values are constants
            case NodeType.LLiteral(_):
                return true
            // Bool identifiers (true/false) are constants
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    return true
                }
            // Skip struct, enum, and function definitions
            case NodeType.StructDef(_):
            case NodeType.EnumDef(_):
            case NodeType.FuncDef(_):
            case:
            }
        }
    case:
    }
    return false
}

// Check if an expression is a non-constant top-level declaration that needs to be a global
// These are declarations that are NOT: functions, structs, enums, or literal constants
// but are still non-mut and could be referenced from function bodies
is_global_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip true/false declarations - they're handled specially
        if decl.name.eq("true").or(decl.name.eq("false")) {
            return false
        }
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            // Skip these - they have their own handling
            case NodeType.StructDef(_):
            case NodeType.EnumDef(_):
            case NodeType.FuncDef(_):
                return false
            // Skip literal constants - they're handled by is_constant_declaration
            // (only non-mut literals are constants)
            case NodeType.LLiteral(_):
                if not(decl.is_mut) {
                    return false
                }
                return true
            // Skip true/false RHS - they're handled by is_constant_declaration
            // (only non-mut booleans are constants)
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    if not(decl.is_mut) {
                        return false
                    }
                }
                // Everything else is a global
                return true
            case:
                // Everything else (function calls like EvalArena.new(), etc.) is a global
                return true
            }
        }
    case:
    }
    return false
}

// Emit a global declaration as a static variable at file scope (type only, no initializer)
// The initializer will be emitted in main()
emit_global_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            // Bug #35: Use unique name for "_" declarations to avoid C redefinition errors
            mut var_name := ""
            if decl.name.eq("_") {
                var_name = next_mangled(ctx)
            } else {
                var_name = til_name(decl.name)
            }

            mut first := Expr()
            expr.params.get(0, first)
            // Determine the type from the initializer expression using get_value_type
            mut c_type := "int"
            mut vt := get_value_type(context, first)
            c_type = til_type_to_c(vt)
            catch (err: Str) {
                // Either get_value_type or til_type_to_c failed - try decl.value_type
                c_type = til_type_to_c(decl.value_type)
                catch (err: Str) {
                    c_type = "int"
                }
            }

            // Emit static declaration (no initializer - will be set in main)
            output = output.concat("static ")
            output = output.concat(c_type)
            output = output.concat(" ")
            output = output.concat(var_name)
            output = output.concat(";\n")

            // Track that this variable has been declared globally
            _ := ctx.declared_vars.insert(var_name)
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit a top-level constant declaration at file scope
emit_constant_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            // Bug #35: Use unique name for "_" declarations to avoid C redefinition errors
            mut var_name := ""
            if decl.name.eq("_") {
                var_name = next_mangled(ctx)
            } else {
                var_name = til_name(decl.name)
            }

            mut first := Expr()
            expr.params.get(0, first)
            // Handle literal constants (numbers, strings)
            switch first.node_type {
            case NodeType.LLiteral(lit):
                mut has_str := false
                _ := context.scope_stack.lookup_struct("Str")
                has_str = true
                catch (err: KeyNotFoundError) { }
                mut c_type := ""
                switch lit {
                case Literal.Number(n):
                    c_type = format(TIL_PREFIX, "I64")
                case Literal.Str(s):
                    if has_str {
                        c_type = format(TIL_PREFIX, "Str")
                    } else {
                        c_type = "const char*"
                    }
                case Literal.List(l):
                    return // Skip list literals for now
                }
                // Non-mut declarations are constants
                if not(decl.is_mut) {
                    output = output.concat("const ")
                }
                output = output.concat(c_type)
                output = output.concat(" ")
                output = output.concat(var_name)
                output = output.concat(" = ")
                emit_literal(lit, output, context)
                output = output.concat(";\n")
            // Handle Bool constants (true/false identifiers)
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    if not(decl.is_mut) {
                        output = output.concat("const ")
                    }
                    output = output.concat(format(TIL_PREFIX, "Bool "))
                    output = output.concat(var_name)
                    output = output.concat(" = ")
                    // Use struct literal instead of macro (valid constant initializer)
                    if name.eq("true") {
                        output = output.concat(format("((", TIL_PREFIX, "Bool){1})"))
                    } else {
                        output = output.concat(format("((", TIL_PREFIX, "Bool){0})"))
                    }
                    output = output.concat(";\n")
                }
            case:
            }
        }
    case:
    }

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit a struct declaration as a C struct (only mut fields become struct fields)
// Forward declarations are emitted separately, so we use "struct Name { ... };" here
emit_struct_declaration := proc(expr: Expr, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs defined in boilerplate
        if decl.name.eq("I64").or(decl.name.eq("U8")).or(decl.name.eq("Bool")).or(decl.name.eq("Dynamic")).or(decl.name.eq("Type")) {
            return
        }
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                output = output.concat("struct ").concat(til_name(decl.name)).concat(" {\n")
                for member: Declaration in struct_def.members {
                    // Only emit mut fields as struct members
                    // Skip functions and non-mut fields (constants)
                    if member.is_mut {
                        output = output.concat("    ").concat(til_type_to_c(member.value_type)).concat(" ").concat(member.name).concat(";\n")
                    }
                }
                output = output.concat("};\n\n")
                return
            case:
                throw "emit_struct_declaration: not a struct"
            }
        }
        throw "emit_struct_declaration: empty params"
    case:
        throw "emit_struct_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
// Also emits size_of constant: til_size_of_StructName = sizeof(til_StructName)
emit_struct_constants := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        mut c_type := til_type_to_c(member.value_type)
                        // Get the default value
                        mut default_val := Expr()
                        struct_def.default_values.get(member.name, default_val)
                        output = output.concat("const ").concat(c_type).concat(" ").concat(struct_name).concat("_").concat(member.name).concat(" = ")
                        emit_expr(default_val, output, 0, ctx, context)
                        output = output.concat(";\n")
                        catch (err: Str) { /* til_type_to_c failed, skip */ }
                        catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    }
                }
                // Emit size_of constant for this struct
                output = output.concat("const ").concat(TIL_PREFIX).concat("I64 ").concat(TIL_PREFIX).concat("size_of_").concat(decl.name).concat(" = sizeof(").concat(struct_name).concat(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name)
                return
            case:
                return
            }
        }
        return
    case:
        return
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit size_of constant for an enum: til_size_of_EnumName = sizeof(til_EnumName)
emit_enum_size_of_constant := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := til_name(decl.name)
                output = output.concat("const ")
                output = output.concat(TIL_PREFIX)
                output = output.concat("I64 ")
                output = output.concat(TIL_PREFIX)
                output = output.concat("size_of_")
                output = output.concat(decl.name)
                output = output.concat(" = sizeof(")
                output = output.concat(enum_name)
                output = output.concat(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name)
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit til_size_of function for runtime type size lookup
emit_size_of_function := proc(mut output: Str, ctx: CodegenContext) {
    output = output.concat("\nstatic inline ").concat(TIL_PREFIX).concat("I64 ").concat(TIL_PREFIX).concat("size_of(const ").concat(TIL_PREFIX).concat("Str* type_name) {\n")

    // All known types from structs and enums
    for type_name: Str in ctx.known_types {
        output = output.concat("    if (strcmp((char*)type_name->c_string, \"").concat(type_name).concat("\") == 0) return ").concat(TIL_PREFIX).concat("size_of_").concat(type_name).concat(";\n")
    }

    output = output.concat("    fprintf(stderr, \"size_of: unknown type %s\\n\", (char*)type_name->c_string);\n").concat("    exit(1);\n}\n")
}

// Check if an enum has any payloads
enum_has_payloads := func(enum_def: SEnumDef) returns Bool {
    for ev: EnumVariant in enum_def.variants {
        if not(NULL.eq(ev.payload_type.data)) {
            return true
        }
    }
    return false
}

// Emit an enum with payloads as a tagged union
emit_enum_with_payloads := proc(enum_name: Str, enum_def: SEnumDef, mut output: Str) throws Str {
    // 1. Emit tag enum: typedef enum { Color_Unknown = 0, ... } Color_Tag;
    output = output.concat("typedef enum {\n")
    for i in 0..enum_def.variants.len() {
        mut ev := EnumVariant()
        enum_def.variants.get(i, ev)
        output = output.concat("    ").concat(enum_name).concat("_").concat(ev.name).concat(" = ").concat(i.to_str()).concat(",\n")
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    output = output.concat("} ").concat(enum_name).concat("_Tag;\n\n")

    // 2. Emit payload union (only for variants that have payloads)
    // typedef union { unsigned char Green; long long Number; } Color_Payload;
    mut has_any_payload := false
    for i in 0..enum_def.variants.len() {
        mut ev := EnumVariant()
        enum_def.variants.get(i, ev)
        if not(NULL.eq(ev.payload_type.data)) {
            has_any_payload = true
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    if has_any_payload {
        output = output.concat("typedef union {\n")
        for i in 0..enum_def.variants.len() {
            mut ev := EnumVariant()
            enum_def.variants.get(i, ev)
            if not(NULL.eq(ev.payload_type.data)) {
                mut payload_type := ValueType.TCustom("")
                memcpy(to_ptr(payload_type), ev.payload_type.data, size_of(ValueType))
                output = output.concat("    ").concat(til_type_to_c(payload_type)).concat(" ").concat(ev.name).concat(";\n")
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        output = output.concat("} ").concat(enum_name).concat("_Payload;\n\n")
    }

    // 3. Emit wrapper struct: struct Color { Color_Tag tag; Color_Payload payload; };
    // Note: typedef is already forward-declared, so we just define the struct body
    output = output.concat("struct ").concat(enum_name).concat(" {\n")
    output = output.concat("    ").concat(enum_name).concat("_Tag tag;\n")
    if has_any_payload {
        output = output.concat("    ").concat(enum_name).concat("_Payload payload;\n")
    }
    output = output.concat("};\n\n")

    // 4. Emit constructor functions for ALL variants (including no-payload ones)
    // This ensures consistent calling convention: Color_make_Red(42), Color_make_Unknown()
    for i in 0..enum_def.variants.len() {
        mut ev := EnumVariant()
        enum_def.variants.get(i, ev)
        payload_ptr := ev.payload_type

        output = output.concat("static inline ").concat(enum_name).concat(" ").concat(enum_name).concat("_make_").concat(ev.name).concat("(")

        // Parameter for payload (if any)
        if not(NULL.eq(payload_ptr.data)) {
            mut payload_type := ValueType.TCustom("")
            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
            output = output.concat(til_type_to_c(payload_type)).concat(" value) {\n")
        } else {
            output = output.concat("void) {\n")
        }

        // Constructor body
        output = output.concat("    ").concat(enum_name).concat(" result = { .tag = ").concat(enum_name).concat("_").concat(ev.name).concat(" };\n")

        // Set payload if present
        if not(NULL.eq(payload_ptr.data)) {
            output = output.concat("    result.payload.").concat(ev.name).concat(" = value;\n")
        }

        output = output.concat("    return result;\n}\n\n")
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit an enum declaration as a C typedef enum (for simple enums without payloads)
// or as a tagged union struct (for enums with payloads)
emit_enum_declaration := proc(expr: Expr, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := til_name(decl.name)

                if enum_has_payloads(enum_def) {
                    // Phase 2: Enums with payloads - tagged union
                    emit_enum_with_payloads(enum_name, enum_def, output)
                    return
                }

                // Phase 1: Simple enum without payloads
                // typedef enum { EnumName_Variant1 = 0, ... } EnumName;
                output = output.concat("typedef enum {\n")

                for i in 0..enum_def.variants.len() {
                    mut ev := EnumVariant()
                    enum_def.variants.get(i, ev)
                    output = output.concat("    ").concat(enum_name).concat("_").concat(ev.name).concat(" = ").concat(i.to_str()).concat(",\n")
                }

                output = output.concat("} ").concat(enum_name).concat(";\n\n")

                // Generate constructor functions for consistency with payload enums
                // static inline EnumName EnumName_make_Variant(void) { return EnumName_Variant; }
                for i in 0..enum_def.variants.len() {
                    mut ev := EnumVariant()
                    enum_def.variants.get(i, ev)
                    output = output.concat("static inline ").concat(enum_name).concat(" ").concat(enum_name).concat("_make_").concat(ev.name).concat("(void) { return ").concat(enum_name).concat("_").concat(ev.name).concat("; }\n")
                }
                output = output.concat("\n")

                return
            case:
                throw "emit_enum_declaration: not an enum"
            }
        }
        throw "emit_enum_declaration: empty params"
    case:
        throw "emit_enum_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit a _to_str function for an enum type
// Takes a pointer because enum_to_str(e: Dynamic) passes by reference
// For simple enums: til_Str til_EnumName_to_str(til_EnumName* e)
// For enums with payloads: til_Str til_EnumName_to_str(til_EnumName* e)
emit_enum_to_str_function := proc(enum_name: Str, enum_def: SEnumDef, mut output: Str) throws Str {
    has_payloads := enum_has_payloads(enum_def)

    // Function signature - takes pointer since Dynamic params are passed by reference
    output = output.concat("static inline til_Str ").concat(enum_name).concat("_to_str(").concat(enum_name).concat("* e) {\n    switch(")
    if has_payloads {
        output = output.concat("e->tag")
    } else {
        output = output.concat("*e")
    }
    output = output.concat(") {\n")

    // Cases - need the original (non-prefixed) enum name for the string
    mut original_name := enum_name
    if enum_name.starts_with(TIL_PREFIX) {
        original_name = get_substr(enum_name, TIL_PREFIX.len(), enum_name.len())
    }

    for i in 0..enum_def.variants.len() {
        mut ev := EnumVariant()
        enum_def.variants.get(i, ev)
        full_name := original_name.concat(".").concat(ev.name)
        output = output.concat("        case ").concat(enum_name).concat("_").concat(ev.name).concat(": return (til_Str){(til_I64)\"").concat(full_name).concat("\", ").concat(full_name.len().to_str()).concat("};\n")
    }

    // Default case (shouldn't happen but good for safety)
    unknown_name := original_name.concat(".?")
    output = output.concat("    }\n    return (til_Str){(til_I64)\"").concat(unknown_name).concat("\", ").concat(unknown_name.len().to_str()).concat("};\n}\n\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit _to_str function for an enum declaration node
emit_enum_to_str_for_declaration := proc(expr: Expr, mut output: Str, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        enum_name := decl.name
        enum_def := context.scope_stack.lookup_enum(enum_name)
        c_enum_name := til_name(enum_name)
        emit_enum_to_str_function(c_enum_name, enum_def, output)

        catch (err: KeyNotFoundError) {
            throw "emit_enum_to_str_for_declaration: enum not found in context"
        }
    case:
        throw "emit_enum_to_str_for_declaration: not an enum declaration"
    }
}

// Emit struct function prototypes with mangled names: StructName_funcname
emit_struct_func_prototypes := proc(expr: Expr, mut output: Str, ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Check if default_value is a function definition
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        mut mangled_name := struct_name.concat("_").concat(member.name)
                        emit_func_signature(mangled_name, func_def, output)
                        output = output.concat(";\n")
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                }
                return
            case:
                return
            }
        }
        return
    case:
        return
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit a struct function body with mangled name: StructName_funcname
emit_struct_func_body := proc(struct_name: Str, member: Declaration, func_def: SFuncDef, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Skip external functions
    if func_def.is_ext() {
        return
    }

    // Set current function context
    ctx.current_throw_types = func_def.throw_types
    ctx.current_return_types = func_def.return_types
    // Track mut params for pointer dereference (-> vs .)
    ctx.current_ref_params = Vec.new(Str)
    // Track variadic params - they're passed as til_Array* so need dereference
    ctx.current_variadic_params = Map.new(Str, Str)
    for arg: Declaration in func_def.args {
        // Bug #60: All non-copy args are passed by pointer (mut, own, and const/default)
        if not(arg.is_copy) {
            ctx.current_ref_params.push(arg.name)
        }
        switch arg.value_type {
        case ValueType.TMulti(elem_type_name):
            // elem_type is the type name string like "Bool"
            ctx.current_variadic_params.set(arg.name, til_name(elem_type_name))
        case:
        }
        catch (err: AllocError) { throw err.msg }
    }

    // Push a new scope frame for this function (like interpreter does)
    context.scope_stack.push(ScopeType.Function)
    // Register function parameters in the frame
    for arg: Declaration in func_def.args {
        mut value_type := arg.value_type
        switch arg.value_type {
        case ValueType.TMulti(elem_type):
            value_type = ValueType.TCustom("Array")
        case:
        }
        mut sym := SymbolInfo(value_type=value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
        context.scope_stack.declare_symbol(arg.name, sym)
    }

    // Clear declared_vars and hoisted_struct_defaults for new function scope
    ctx.declared_vars = Set.new(Str)
    ctx.hoisted_struct_defaults = Map.new(Str, Str)

    mangled_name := struct_name.concat("_").concat(member.name)

    // Save and set current function name for deterministic temp naming (Bug #42 fix)
    mut prev_function_name := ctx.current_function_name
    mut prev_mangling_counter := ctx.mangling_counter
    ctx.current_function_name = mangled_name
    ctx.mangling_counter = 0

    emit_func_signature(mangled_name, func_def, output)
    output = output.concat(" {\n")

    // Emit function body with catch pattern detection
    emit_stmts(func_def.body, output, 1, ctx, context)

    // For throwing void functions, add implicit return 0 at end
    if func_def.throw_types.len().gt(0) {
        if func_def.return_types.len().eq(0) {
            output = output.concat("    return 0;\n")
        }
    }

    output = output.concat("}\n\n")

    // Restore previous function name and counter
    ctx.current_function_name = prev_function_name
    ctx.mangling_counter = prev_mangling_counter

    // Pop the function scope frame
    _ := context.scope_stack.pop()

    // Clear current function context
    ctx.current_throw_types = Vec.new(ValueType)
    ctx.current_return_types = Vec.new(ValueType)
    ctx.current_ref_params = Vec.new(Str)

    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function bodies for all functions in a struct
emit_struct_func_bodies := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Check if default_value is a function definition
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        emit_struct_func_body(struct_name, member, func_def, output, ctx, context)
                    case:
                    }
                    catch (err: KeyNotFoundError) { /* skip member with no default */ }
                }
                return
            case:
                return
            }
        }
        return
    case:
        return
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr, mut context: Context) returns Str throws Str {
    mut output := ""
    mut ctx := CodegenContext()

    // C boilerplate
    output = output.concat("#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n")
    output = format(output, "typedef unsigned char ", TIL_PREFIX, "U8;\n")
    output = format(output, "typedef long long ", TIL_PREFIX, "I64;\n")
    output = format(output, "typedef struct ", TIL_PREFIX, "Bool { ", TIL_PREFIX, "U8 data; } ", TIL_PREFIX, "Bool;\n")
    // Dynamic and Type are special placeholder types
    output = format(output, "typedef void* ", TIL_PREFIX, "Dynamic;\n")
    output = format(output, "typedef const char* ", TIL_PREFIX, "Type;\n\n")

    // Pass 0: collect function info (throw types, return types) for call-site generation
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            collect_func_info(child, ctx)
        }
    case:
    }

    // Pass 0a: collect nested function info for hoisting (populates hoisted_prototypes and nested_func_names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            collect_nested_func_info(child, ctx, "")
        }
    case:
    }

    // Pass 0b: emit forward declarations for all structs and enums-with-payloads
    // (enums with payloads are implemented as structs in C, so they need forward declarations too)
    // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs defined in boilerplate
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    if decl.name.eq("I64").or(decl.name.eq("U8")).or(decl.name.eq("Bool")).or(decl.name.eq("Dynamic")).or(decl.name.eq("Type")) {
                        continue  // Skip - these are primitive typedefs
                    }
                    mut struct_name := til_name(decl.name)
                    output = output.concat("typedef struct ").concat(struct_name).concat(" ").concat(struct_name).concat(";\n")
                case:
                }
            }
            // Also forward-declare enums with payloads (they're implemented as structs)
            if is_enum_declaration(child).and(is_enum_with_payloads(child)) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    mut enum_name := til_name(decl.name)
                    output = output.concat("typedef struct ").concat(enum_name).concat(" ").concat(enum_name).concat(";\n")
                case:
                }
            }
        }
        output = output.concat("\n")
    case:
    }

    // Pass 1a: emit simple enums (no payloads) - safe to emit early, structs may use them as fields
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child).and(not(is_enum_with_payloads(child))) {
                emit_enum_declaration(child, output)
            }
        }
    case:
    }

    // Pass 1b: emit all structs and enums-with-payloads in topologically sorted order
    // Both are "complex types" that can depend on each other
    switch ast.node_type {
    case NodeType.Body:
        mut type_decls := Vec.new(Expr)
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                type_decls.push(child)
            } else if is_enum_declaration(child) {
                if is_enum_with_payloads(child) {
                    type_decls.push(child)
                }
            }
        }
        mut sorted_indices := topological_sort_types(type_decls)
        for idx: I64 in sorted_indices {
            mut child := Expr()
            type_decls.get(idx, child)
            if is_struct_declaration(child) {
                emit_struct_declaration(child, output)
            } else {
                emit_enum_declaration(child, output)
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    case:
    }

    // Pass 2: emit function prototypes (forward declarations)
    // 2a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_func_declaration(child) {
                emit_func_prototype(child, output)
            }
        }
    case:
    }
    // 2b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_func_prototypes(child, output, ctx)
            }
        }
    case:
    }
    // 2c: hoisted nested function prototypes (collected in Pass 0a)
    if ctx.hoisted_prototypes.len().gt(0) {
        output = output.concat("\n// Nested function prototypes (hoisted)\n")
        for proto: Str in ctx.hoisted_prototypes {
            output = output.concat(proto)
        }
    }
    output = output.concat("\n")

    // Pass 3: include external C interface (after structs and forward decls)
    // Use angle brackets to search only -I paths (src/), not the current directory
    // This avoids including generated c/self/ext.c instead of the hand-written src/ext.c
    output = output.concat("#include <ext.c>\n\n")

    // Pass 4: emit struct constants (non-mut, non-function fields with mangled names)
    // Also emits size_of constants for each struct
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_constants(child, output, ctx, context)
            }
        }
    case:
    }

    // Pass 4a: emit size_of constants for enums
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child) {
                emit_enum_size_of_constant(child, output, ctx)
            }
        }
    case:
    }

    // Pass 4a2: emit enum_to_str functions for all enums
    // This must come after structs are defined (Str is needed for return type)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child) {
                emit_enum_to_str_for_declaration(child, output, context)
            }
        }
    case:
    }

    // Pass 4b: emit top-level constants (non-mut declarations with literal values)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_constant_declaration(child) {
                emit_constant_declaration(child, output, ctx, context)
            }
        }
    case:
    }

    // Pass 4c: emit global declarations (non-constant, non-func/struct/enum declarations)
    // These need to be file-scope statics so functions can access them
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_global_declaration(child) {
                emit_global_declaration(child, output, ctx, context)
            }
        }
    case:
    }

    // Pass 4d: emit til_size_of function (runtime type size lookup)
    emit_size_of_function(output, ctx)

    output = output.concat("\n")

    // Pass 5: emit function definitions
    // 5a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_func_declaration(child) {
                emit_func_declaration(child, output, ctx, context)
            }
        }
    case:
    }
    // 5b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_func_bodies(child, output, ctx, context)
            }
        }
    case:
    }

    // 5c: hoisted nested function definitions
    // These were collected during emit_func_declaration when encountering nested functions
    // (prototypes were already emitted in Pass 2c)
    if ctx.hoisted_functions.len().gt(0) {
        output = output.concat("\n// Hoisted nested function definitions\n")
        for func_code: Str in ctx.hoisted_functions {
            output = output.concat(func_code)
        }
    }

    // Main function
    output = output.concat("int main(int argc, char** argv) {\n")

    // Clear hoisted_exprs to avoid cross-contamination from function passes
    ctx.hoisted_exprs = Map.new(I64, Str)

    // Re-populate declared_vars with global declarations (functions clear declared_vars)
    // This ensures global declarations emit only assignments in main(), not redeclarations
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_global_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    _ := ctx.declared_vars.insert(til_name(decl.name))
                    catch (err: AllocError) { throw err.msg }
                case:
                }
            }
        }
    case:
    }

    // Pass 6: emit non-struct, non-function, non-enum, non-constant statements
    // Collect them into a Vec and use emit_stmts for proper variadic/throwing call handling
    // Note: global declarations are still included but will emit only assignments since they're already declared
    switch ast.node_type {
    case NodeType.Body:
        mut main_stmts := Vec.new(Expr)
        for child: Expr in ast.params {
            // Skip true/false declarations - they're now #defines
            mut skip_true_false := false
            switch child.node_type {
            case NodeType.Declaration(decl):
                if decl.name.eq("true") { skip_true_false = true }
                if decl.name.eq("false") { skip_true_false = true }
            case:
            }
            if not(skip_true_false).and(not(is_func_declaration(child))).and(not(is_struct_declaration(child))).and(not(is_enum_declaration(child))).and(not(is_constant_declaration(child))) {
                main_stmts.push(child)
            }
        }
        emit_stmts(main_stmts, output, 1, ctx, context)
    case:
    }

    // Call til_main() for modes that require a main proc (like cli)
    if context.mode_def.needs_main_proc {
        // Check if main has variadic args by looking up the function
        // Variadic params have ValueType.TMulti as their type
        mut main_has_variadic := false
        mut fd := context.scope_stack.lookup_func("main")
        mut has_multi := false
        for arg: Declaration in fd.args {
            switch arg.value_type {
            case ValueType.TMulti(_):
                has_multi = true
                break
            case:
            }
        }
        main_has_variadic = has_multi
        catch (err: KeyNotFoundError) { }

        if main_has_variadic {
            // Convert argc/argv to til_Array and pass to til_main
            // Skip argv[0] (exe path) to match interpreter behavior
            output = output.concat("    til_Array _main_args;\n")
            output = output.concat("    til_AllocError _main_args_err;\n")
            output = output.concat("    til_Array_new(&_main_args, &_main_args_err, \"Str\", &(til_I64){argc - 1});\n")
            output = output.concat("    for (int i = 1; i < argc; i++) {\n")
            output = output.concat("        til_Str _arg = {(til_I64)argv[i], strlen(argv[i])};\n")
            output = output.concat("        til_IndexOutOfBoundsError _set_err;\n")
            output = output.concat("        til_Array_set(&_set_err, &_main_args, &(til_I64){i - 1}, &_arg);\n")
            output = output.concat("    }\n")
            output = output.concat("    til_main(&_main_args);\n")
        } else {
            output = output.concat("    til_main();\n")
        }
    }

    output = output.concat("    return 0;\n}\n")

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return output
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(_):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.FuncDef(_):
                return true
            case:
            }
        }
    case:
    }
    return false
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext() {
                    return
                }

                // Use emit_func_signature for both throwing and non-throwing functions
                mut func_name := til_name(decl.name)
                emit_func_signature(func_name, func_def, output)
                output = output.concat(";\n")
                return
            case:
                throw "emit_func_prototype: not a function"
            }
        }
        throw "emit_func_prototype: empty params"
    case:
        throw "emit_func_prototype: not a declaration"
    }
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions (ext_proc/ext_func) - they're just declarations
                if func_def.is_ext() {
                    return
                }

                // Set current function context for return/throw generation
                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types
                // Track ref params for pointer dereference (-> vs .)
                ctx.current_ref_params = Vec.new(Str)
                // Track variadic params - they're passed as til_Array* so need dereference
                ctx.current_variadic_params = Map.new(Str, Str)
                for arg: Declaration in func_def.args {
                    // Bug #60: All non-copy args are passed by pointer (mut, own, and const/default)
                    if not(arg.is_copy) {
                        ctx.current_ref_params.push(arg.name)
                    }
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type):
                        // elem_type is the type name string like "Bool"
                        ctx.current_variadic_params.set(arg.name, til_name(elem_type))
                    case:
                    }
                    catch (err: AllocError) { throw err.msg }
                }

                // Push a new scope frame for this function (like interpreter does)
                context.scope_stack.push(ScopeType.Function)
                // Register function parameters in the frame
                // For variadic params (TMulti), register as Array type
                for arg: Declaration in func_def.args {
                    mut value_type := arg.value_type
                    switch arg.value_type {
                    case ValueType.TMulti(_):
                        value_type = ValueType.TCustom("Array")
                    case:
                    }
                    mut sym := SymbolInfo(value_type=value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own)
                    context.scope_stack.declare_symbol(arg.name, sym)
                }

                // Clear declared_vars and hoisted_struct_defaults for new function scope
                ctx.declared_vars = Set.new(Str)
                ctx.hoisted_struct_defaults = Map.new(Str, Str)

                mut func_name := til_name(decl.name)

                // Save and set current function name for nested function mangling
                mut prev_function_name := ctx.current_function_name
                mut prev_mangling_counter := ctx.mangling_counter
                ctx.current_function_name = decl.name
                ctx.mangling_counter = 0  // Reset counter per-function for determinism

                emit_func_signature(func_name, func_def, output)
                output = output.concat(" {\n")

                // Emit function body with catch pattern detection
                emit_stmts(func_def.body, output, 1, ctx, context)

                // For throwing void functions, add implicit return 0 at end
                if func_def.throw_types.len().gt(0).and(func_def.return_types.len().eq(0)) {
                    output = output.concat("    return 0;\n")
                }

                output = output.concat("}\n\n")

                // Pop the function scope frame
                _ := context.scope_stack.pop()
                catch (err: IndexOutOfBoundsError) { throw err.msg }

                // Restore previous function name and counter
                ctx.current_function_name = prev_function_name
                ctx.mangling_counter = prev_mangling_counter

                // Clear current function context
                ctx.current_throw_types = Vec.new(ValueType)
                ctx.current_return_types = Vec.new(ValueType)

                return
            case:
            }
        }
    case:
    }
    throw "emit_func_declaration: not a function declaration"
}


emit_if := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if expr.params.len().lt(2) {
        throw "ccodegen: If requires condition and body"
    }

    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    // Hoist declarations from both branches to before the if statement
    // (TIL has function-level scoping, not block-level scoping)
    mut then_body := Expr()
    expr.params.get(1, then_body)
    then_decls := collect_declarations_in_body(then_body, context)
    for decl: CollectedDeclaration in then_decls {
        c_var_name := til_name(decl.name)
        if not(ctx.declared_vars.contains(c_var_name)) {
            c_type := til_type_to_c(decl.value_type)
            if c_type.len().gt(0) {
                output = output.concat(indent_str)
                output = output.concat(c_type)
                output = output.concat(" ")
                output = output.concat(c_var_name)
                output = output.concat(";\n")
                _ := ctx.declared_vars.insert(c_var_name)
                // Also register in scope_stack so get_value_type can find it
                context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=decl.value_type))
            }
        }
    }
    if expr.params.len().gt(2) {
        mut else_body := Expr()
        expr.params.get(2, else_body)
        else_decls := collect_declarations_in_body(else_body, context)
        for decl: CollectedDeclaration in else_decls {
            c_var_name := til_name(decl.name)
            if not(ctx.declared_vars.contains(c_var_name)) {
                c_type := til_type_to_c(decl.value_type)
                if c_type.len().gt(0) {
                    output = output.concat(indent_str)
                    output = output.concat(c_type)
                    output = output.concat(" ")
                    output = output.concat(c_var_name)
                    output = output.concat(";\n")
                    _ := ctx.declared_vars.insert(c_var_name)
                    // Also register in scope_stack so get_value_type can find it
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=decl.value_type))
                }
            }
        }
    }

    // Hoist any throwing function calls in the condition
    mut cond := Expr()
    expr.params.get(0, cond)
    _ := hoist_throwing_expr(cond, output, indent, ctx, context)

    output = output.concat(indent_str)
    output = output.concat("if (")
    emit_expr(cond, output, 0, ctx, context)
    // Bool is a struct with .data field - extract for C truthiness
    mut cond_type := get_value_type(context, cond)
    switch cond_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Bool") {
            output = output.concat(".data")
        }
    case:
    }
    catch (err: Str) { /* get_value_type failed, skip */ }
    output = output.concat(") {\n")

    // Don't save/restore declared_vars - TIL has function-level scoping
    // Variables declared in if branches stay declared for the rest of the function
    emit_body(then_body, output, indent.add(1), ctx, context)

    output = output.concat(indent_str)
    output = output.concat("}")

    // Else branch (optional)
    if expr.params.len().gt(2) {
        mut else_part := Expr()
        expr.params.get(2, else_part)
        switch else_part.node_type {
        case NodeType.If:
            // Always wrap else-if in braces to ensure hoisted temp vars
            // from nested if conditions have proper scope
            output = output.concat(" else {\n")
            emit_if(else_part, output, indent.add(1), ctx, context)
            output = output.concat(indent_str)
            output = output.concat("}\n")
        case:
            // else block
            output = output.concat(" else {\n")
            emit_body(else_part, output, indent.add(1), ctx, context)
            output = output.concat(indent_str)
            output = output.concat("}\n")
        }
    } else {
        output = output.concat("\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
}

emit_while := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // While: params[0] = condition, params[1] = body
    if expr.params.len().lt(2) {
        throw "ccodegen: While requires condition and body"
    }

    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    // Hoist declarations from loop body to before the while statement
    // (TIL has function-level scoping, not block-level scoping)
    mut body := Expr()
    expr.params.get(1, body)
    body_decls := collect_declarations_in_body(body, context)
    for decl: CollectedDeclaration in body_decls {
        c_var_name := til_name(decl.name)
        if not(ctx.declared_vars.contains(c_var_name)) {
            c_type := til_type_to_c(decl.value_type)
            if c_type.len().gt(0) {
                output = output.concat(indent_str)
                output = output.concat(c_type)
                output = output.concat(" ")
                output = output.concat(c_var_name)
                output = output.concat(";\n")
                _ := ctx.declared_vars.insert(c_var_name)
                // Also register in scope_stack so get_value_type can find it
                context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=decl.value_type))
            }
        }
    }

    // Check if condition contains throwing calls by trying to hoist to a temp buffer
    mut cond := Expr()
    expr.params.get(0, cond)
    mut hoist_output := ""
    _ := hoist_throwing_expr(cond, hoist_output, indent.add(1), ctx, context)

    if hoist_output.len().eq(0) {
        // No throwing calls in condition - use simple while
        output = output.concat(indent_str)
        output = output.concat("while (")
        emit_expr(cond, output, 0, ctx, context)
        // Bool is a struct with .data field - extract for C truthiness
        mut cond_type := get_value_type(context, cond)
        switch cond_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("Bool") {
                output = output.concat(".data")
            }
        case:
        }
        catch (err: Str) { /* get_value_type failed, skip */ }
        output = output.concat(") {\n")
    } else {
        // Throwing calls in condition - transform to while(1) with hoisted calls and break
        output = output.concat(indent_str)
        output = output.concat("while (1) {\n")

        // Emit hoisted throwing calls inside the loop
        output = output.concat(hoist_output)

        // Emit condition check with break
        mut inner_indent_str := ""
        for _ in 0..indent.add(1) {
            inner_indent_str = inner_indent_str.concat("    ")
        }
        output = output.concat(inner_indent_str)
        output = output.concat("if (!(")
        emit_expr(cond, output, 0, ctx, context)
        // Bool is a struct with .data field - extract for C truthiness
        mut cond_type := get_value_type(context, cond)
        switch cond_type {
        case ValueType.TCustom(type_name):
            if type_name.eq("Bool") {
                output = output.concat(".data")
            }
        case:
        }
        catch (err: Str) { /* get_value_type failed, skip */ }
        output = output.concat(")) break;\n")
    }

    // Don't save/restore declared_vars - TIL has function-level scoping
    // Variables declared in loops stay declared for the rest of the function
    emit_body(body, output, indent.add(1), ctx, context)

    output = output.concat(indent_str)
    output = output.concat("}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
}

emit_break := proc(_expr: Expr, mut output: Str, indent: I64) {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }
    output.push_str(indent_str)
    output.push_str("break;\n")
}

emit_continue := proc(_expr: Expr, mut output: Str, indent: I64) {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }
    output.push_str(indent_str)
    output.push_str("continue;\n")
}

// Result struct for variant info extraction
VariantInfo := struct {
    mut type_name: Str = ""
    mut variant_name: Str = ""
}

// Extract enum type and variant names from a case pattern expression
// For FCall: Type.Variant -> VariantInfo { type_name: "Type", variant_name: "Variant" }
get_case_variant_info := func(expr: Expr) returns VariantInfo {
    mut result := VariantInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // FCall for Type.Variant (without payload extraction)
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return result }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                if first.params.len().gt(0) {
                    mut nested := Expr()
                    first.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return result }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        result.type_name = type_name
                        result.variant_name = variant_name
                        return result
                    case:
                        return result
                    }
                }
                return result
            case:
                return result
            }
        }
        return result
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if expr.params.len().gt(0) {
            mut nested := Expr()
            expr.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) { return result }
            switch nested.node_type {
            case NodeType.Identifier(variant_name):
                result.type_name = name
                result.variant_name = variant_name
                return result
            case:
            }
        }
        // Plain identifier without nested params - NOT an enum variant pattern
        // Return empty to let emit_switch fall through to regular value comparison
        return result
    case:
        return result
    }
}

// Extract type name and variant name from a Pattern's variant_name (e.g., "Color.Green")
parse_pattern_variant_name := func(variant_name: Str) returns VariantInfo {
    mut result := VariantInfo()
    mut dot_pos := variant_name.rfind(".")
    if dot_pos.gteq(0) {
        result.type_name = variant_name.get_substr(0, dot_pos)
        result.variant_name = variant_name.get_substr(dot_pos.add(1), variant_name.len())
        catch (err: IndexOutOfBoundsError) {
            result.variant_name = variant_name
        }
        catch (err: AllocError) {
            result.variant_name = variant_name
        }
        return result
    }
    // No dot - just variant name (shouldn't happen in practice)
    result.variant_name = variant_name
    return result
}

/// Collect all variable declarations in a body (recursively) for hoisting
/// Returns Vec of CollectedDeclaration structs
collect_declarations_in_body := proc(body: Expr, mut context: Context) returns Vec throws Str {
    mut decls := Vec.new(CollectedDeclaration)
    // Track collected declarations for lookups during type inference
    mut collected := Map.new(Str, ValueType)

    switch body.node_type {
    case NodeType.Body:
        for stmt: Expr in body.params {
            collect_declarations_recursive(stmt, decls, collected, context)
        }
    case:
        collect_declarations_recursive(body, decls, collected, context)
    }

    return decls
}

collect_declarations_recursive := proc(expr: Expr, mut decls: Vec, mut collected: Map, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Add this declaration
        // If type is INFER_TYPE, try to infer from the expression
        mut value_type := decl.value_type
        switch decl.value_type {
        case ValueType.TCustom(name):
            if name.eq(INFER_TYPE).and(expr.params.len().gt(0)) {
                mut first := Expr()
                expr.params.get(0, first)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                value_type = get_value_type(context, first)
                catch (err: Str) {
                    value_type = decl.value_type
                }
            }
        case:
        }
        // Track this declaration for future lookups (both in collected and scope_stack)
        collected.set(decl.name, value_type)
        // Also add to scope_stack so get_value_type can find it for subsequent declarations
        context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut))
        mut collected_decl := CollectedDeclaration()
        collected_decl.name = decl.name
        collected_decl.value_type = value_type
        decls.push(collected_decl)
    case NodeType.Body:
        for stmt: Expr in expr.params {
            collect_declarations_recursive(stmt, decls, collected, context)
        }
    case NodeType.If:
        // Recurse into if branches
        if expr.params.len().gteq(2) {
            mut then_branch := Expr()
            expr.params.get(1, then_branch)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            collect_declarations_recursive(then_branch, decls, collected, context)
        }
        if expr.params.len().gteq(3) {
            mut else_branch := Expr()
            expr.params.get(2, else_branch)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            collect_declarations_recursive(else_branch, decls, collected, context)
        }
    case NodeType.Switch:
        // Recurse into switch case bodies
        mut i := 1
        while i.add(1).lt(expr.params.len()) {
            mut case_body := Expr()
            expr.params.get(i.add(1), case_body)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            collect_declarations_recursive(case_body, decls, collected, context)
            i = i.add(2)
        }
    case NodeType.While:
        // Recurse into while body
        if expr.params.len().gteq(2) {
            mut while_body := Expr()
            expr.params.get(1, while_body)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            collect_declarations_recursive(while_body, decls, collected, context)
        }
    case NodeType.Catch:
        // Recurse into catch body (params[2] is catch body)
        // params[0] = err_var, params[1] = err_type, params[2] = body
        if expr.params.len().gteq(3) {
            mut catch_body := Expr()
            expr.params.get(2, catch_body)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            collect_declarations_recursive(catch_body, decls, collected, context)
        }
    case:
    }
    catch (err: AllocError) { throw err.msg }
}

emit_switch := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Switch: params[0] = switch expression
    // params[1..] = alternating (case_pattern, body) pairs
    // We emit if/else chains instead of C switch because:
    // 1. C switch only works with integer types, not Str
    // 2. Avoids GCC-specific case range extension
    // 3. More portable and easier to handle all TIL switch patterns
    if expr.params.len().eq(0) {
        throw "ccodegen: Switch requires expression"
    }

    // Indentation strings
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    mut body_indent := ""
    for _ in 0..indent.add(1) {
        body_indent = body_indent.concat("    ")
    }

    // Get the switch expression
    mut switch_expr := Expr()
    expr.params.get(0, switch_expr)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Hoist any throwing function calls in the switch expression
    _ := hoist_throwing_expr(switch_expr, output, indent, ctx, context)

    // Determine the type of the switch expression for proper comparison
    mut switch_type := ValueType.TCustom("")
    switch_type = get_value_type(context, switch_expr)
    // Type inference may fail - that's okay, we'll use default empty type
    catch (err: Str) { }
    mut is_str_switch := false
    switch switch_type {
    case ValueType.TCustom(type_name):
        is_str_switch = type_name.eq("Str")
    case:
    }

    // Determine if this is an enum switch and if it has payloads
    mut is_enum_switch := false
    mut enum_has_payloads_flag := false
    mut scan_i := 1
    while scan_i.lt(expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(scan_i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            is_enum_switch = true
        case NodeType.Identifier(name):
            if case_pattern.params.len().gt(0) {
                is_enum_switch = true
            } else if name.contains(".") {
                is_enum_switch = true
            }
        case NodeType.FCall:
            is_enum_switch = true
            // FCall with arguments (e.g., ValueType.TType(TTypeDef.TEnumDef))
            // implies the enum has payloads
            if case_pattern.params.len().gt(1) {
                enum_has_payloads_flag = true
            }
        case:
        }
        scan_i = scan_i.add(2)
    }
    if is_enum_switch {
        switch switch_type {
        case ValueType.TCustom(enum_name):
            mut enum_def := context.scope_stack.lookup_enum(enum_name)
            enum_has_payloads_flag = enum_has_payloads(enum_def)
            catch (err: KeyNotFoundError) { /* not an enum or not found */ }
        case:
        }
    }

    // Store switch expression in a temp variable to avoid re-evaluation
    switch_var := next_mangled(ctx)
    output = output.concat(indent_str)
    output = output.concat("__auto_type ")
    output = output.concat(switch_var)
    output = output.concat(" = ")
    emit_expr(switch_expr, output, 0, ctx, context)
    output = output.concat(";\n")

    // Hoist declarations from all case bodies to before the if/else chain
    // This ensures variables declared in switch cases are visible after the switch
    // (TIL has function-level scoping, not block-level scoping)
    mut i := 1
    while i.add(1).lt(expr.params.len()) {
        mut body := Expr()
        expr.params.get(i.add(1), body)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        decls := collect_declarations_in_body(body, context)
        for decl: CollectedDeclaration in decls {
            c_var_name := til_name(decl.name)
            if not(ctx.declared_vars.contains(c_var_name)) {
                c_type := til_type_to_c(decl.value_type)
                if c_type.len().gt(0) {
                    output = output.concat(indent_str)
                    output = output.concat(c_type)
                    output = output.concat(" ")
                    output = output.concat(c_var_name)
                    output = output.concat(";\n")
                    _ := ctx.declared_vars.insert(c_var_name)
                    // Also register in scope_stack so get_value_type can find it
                    context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=decl.value_type))
                }
            }
        }
        catch (err: AllocError) { throw err.msg }
        i = i.add(2)
    }

    // Emit if/else if chain for cases
    // Default case (if present) is guaranteed to be last by parser
    i = 1
    mut first_case := true
    mut has_cases := false
    while i.add(1).lt(expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut case_body := Expr()
        expr.params.get(i.add(1), case_body)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        has_cases = true

        // Check if this is the default case (guaranteed last by parser)
        switch case_pattern.node_type {
        case NodeType.DefaultCase:
            // Default case - emit as else block
            if not(first_case) {
                output = output.concat(indent_str)
                output = output.concat("} else {\n")
            }
            saved_declared_vars := ctx.declared_vars.clone()
            catch (err: AllocError) { throw err.msg }
            emit_body(case_body, output, indent.add(1), ctx, context)
            ctx.declared_vars = saved_declared_vars
            i = i.add(2)
            continue
        case:
        }

        // Regular case - emit if/else if
        output = output.concat(indent_str)
        if first_case {
            output = output.concat("if (")
            first_case = false
        } else {
            output = output.concat("} else if (")
        }

        // Emit the condition based on pattern type
        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // Enum pattern with payload binding: compare tag
            info := parse_pattern_variant_name(pattern_info.variant_name)
            output = output.concat(switch_var)
            output = output.concat(".tag == til_")
            output = output.concat(info.type_name)
            output = output.concat("_")
            output = output.concat(info.variant_name)
            output = output.concat(") {\n")

            // Extract payload into binding variable
            output = output.concat(body_indent)
            output = output.concat("__auto_type ")
            output = output.concat(til_name(pattern_info.binding_var))
            output = output.concat(" = ")
            output = output.concat(switch_var)
            output = output.concat(".payload.")
            output = output.concat(info.variant_name)
            output = output.concat(";\n")
        case NodeType.Range:
            // Range: low <= val && val <= high
            if case_pattern.params.len().lt(2) {
                throw "ccodegen: Range requires start and end values"
            }
            mut range_start := Expr()
            case_pattern.params.get(0, range_start)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            mut range_end := Expr()
            case_pattern.params.get(1, range_end)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            if is_str_switch {
                // For string ranges, use strcmp: strcmp(low, val) <= 0 && strcmp(val, high) <= 0
                output = output.concat("strcmp((char*)")
                emit_expr(range_start, output, 0, ctx, context)
                output = output.concat(".c_string, (char*)")
                output = output.concat(switch_var)
                output = output.concat(".c_string) <= 0 && strcmp((char*)")
                output = output.concat(switch_var)
                output = output.concat(".c_string, (char*)")
                emit_expr(range_end, output, 0, ctx, context)
                output = output.concat(".c_string) <= 0")
            } else {
                emit_expr(range_start, output, 0, ctx, context)
                output = output.concat(" <= ")
                output = output.concat(switch_var)
                output = output.concat(" && ")
                output = output.concat(switch_var)
                output = output.concat(" <= ")
                emit_expr(range_end, output, 0, ctx, context)
            }
            output = output.concat(") {\n")
        case NodeType.Identifier(name):
            info := get_case_variant_info(case_pattern)
            if info.variant_name.len().gt(0) {
                // Enum variant without payload
                output = output.concat(switch_var)
                if enum_has_payloads_flag {
                    output = output.concat(".tag")
                }
                output = output.concat(" == ")
                if info.type_name.len().gt(0) {
                    output = output.concat("til_")
                    output = output.concat(info.type_name)
                    output = output.concat("_")
                }
                output = output.concat(info.variant_name)
            } else if is_str_switch {
                // String comparison
                output = output.concat("til_Str_eq(")
                output = output.concat(switch_var)
                output = output.concat(", ")
                emit_expr(case_pattern, output, 0, ctx, context)
                output = output.concat(").data")
            } else {
                // Regular value comparison
                output = output.concat(switch_var)
                output = output.concat(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)
            }
            output = output.concat(") {\n")
        case NodeType.LLiteral(lit):
            if is_str_switch {
                // String literal comparison
                output = output.concat("til_Str_eq(")
                output = output.concat(switch_var)
                output = output.concat(", ")
                emit_expr(case_pattern, output, 0, ctx, context)
                output = output.concat(").data")
            } else {
                // Regular literal comparison
                output = output.concat(switch_var)
                output = output.concat(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)
            }
            output = output.concat(") {\n")
        case NodeType.FCall:
            // FCall pattern: Type.Variant(payload) - enum variant with payload argument
            // For example: ValueType.TType(TTypeDef.TEnumDef)
            info := get_case_variant_info(case_pattern)
            if info.variant_name.len().gt(0).and(enum_has_payloads_flag) {
                // Compare tag first
                output = output.concat(switch_var)
                output = output.concat(".tag == til_")
                output = output.concat(info.type_name)
                output = output.concat("_")
                output = output.concat(info.variant_name)

                // Check if there's a payload argument to compare
                // params[0] is Type.Variant identifier, params[1+] are arguments
                if case_pattern.params.len().gt(1) {
                    mut payload_expr := Expr()
                    case_pattern.params.get(1, payload_expr)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    // Check if payload is also an enum variant (Type.Variant pattern)
                    payload_info := get_case_variant_info(payload_expr)
                    if payload_info.variant_name.len().gt(0) {
                        // Payload is an enum variant - compare payload field
                        output = output.concat(" && ")
                        output = output.concat(switch_var)
                        output = output.concat(".payload.")
                        output = output.concat(info.variant_name)
                        output = output.concat(" == til_")
                        output = output.concat(payload_info.type_name)
                        output = output.concat("_")
                        output = output.concat(payload_info.variant_name)
                    }
                    // TODO: handle non-enum payloads if needed
                }
                output = output.concat(") {\n")
            } else if info.variant_name.len().gt(0) {
                // Enum without payloads - simple tag comparison
                output = output.concat(switch_var)
                output = output.concat(" == til_")
                output = output.concat(info.type_name)
                output = output.concat("_")
                output = output.concat(info.variant_name)
                output = output.concat(") {\n")
            } else {
                // Not an enum pattern - fall through to generic comparison
                output = output.concat(switch_var)
                output = output.concat(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)
                output = output.concat(") {\n")
            }
        case:
            // Generic case: emit equality comparison
            if is_str_switch {
                output = output.concat("til_Str_eq(")
                output = output.concat(switch_var)
                output = output.concat(", ")
                emit_expr(case_pattern, output, 0, ctx, context)
                output = output.concat(").data")
            } else {
                output = output.concat(switch_var)
                output = output.concat(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)
            }
            output = output.concat(") {\n")
        }

        // Emit case body - with scope for pattern bindings
        // Save declared_vars for block scope - variables declared in this case body
        // should not affect other case bodies
        saved_declared_vars := ctx.declared_vars.clone()
        catch (err: AllocError) { throw err.msg }

        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // For pattern bindings, we need to declare the binding variable in scope
            // so that get_value_type can find it during body emission
            info := parse_pattern_variant_name(pattern_info.variant_name)

            // Look up the payload type from the enum definition
            mut payload_type := ValueType.TCustom("")
            mut have_payload_type := false
            switch switch_type {
            case ValueType.TCustom(enum_name):
                mut found_enum := false
                enum_def := context.scope_stack.lookup_enum(enum_name)
                found_enum = true
                catch (err: KeyNotFoundError) { }
                if found_enum {
                    // Found the enum, look up the variant's payload type (Ptr to ValueType, NULL = None)
                    // Bug #38 fix: use helper method
                    mut payload_ptr := Ptr()
                    payload_ptr = enum_def.get(info.variant_name)
                    catch (err: KeyNotFoundError) { }
                    // Check if payload exists (not NULL)
                    if not(NULL.eq(payload_ptr.data)) {
                        memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                        have_payload_type = true
                    }
                }
            case:
            }

            if have_payload_type {
                // Push a new scope and declare the binding variable
                context.scope_stack.push(ScopeType.Block)
                sym_info := SymbolInfo(
                    symbol_type = SymbolType.Variable,
                    value_type = payload_type,
                    is_mutable = false,
                )
                context.scope_stack.declare_symbol(pattern_info.binding_var, sym_info)
                emit_body(case_body, output, indent.add(1), ctx, context)
                _ := context.scope_stack.pop()
            } else {
                emit_body(case_body, output, indent.add(1), ctx, context)
            }
        case:
            emit_body(case_body, output, indent.add(1), ctx, context)
        }

        // Restore declared_vars after case body
        ctx.declared_vars = saved_declared_vars
        i = i.add(2)
    }

    // Close the if/else chain
    if has_cases {
        output = output.concat(indent_str)
        output = output.concat("}\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
}

emit_expr := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Check if this expression has been hoisted (for nested variadic/throwing calls)
    expr_addr := to_ptr(expr)
    if ctx.hoisted_exprs.contains_key(expr_addr) {
        mut temp_var := ""
        ctx.hoisted_exprs.get(expr_addr, temp_var)
        catch (err: KeyNotFoundError) { }
        output = output.concat(temp_var)
        return
    }

    switch expr.node_type {
    case NodeType.Body:
        emit_body(expr, output, indent, ctx, context)
        return
    case NodeType.FCall:
        emit_fcall(expr, output, indent, ctx, context)
        return
    case NodeType.LLiteral(lit):
        emit_literal(lit, output, context)
        return
    case NodeType.Declaration(decl):
        emit_declaration(decl, expr, output, indent, ctx, context)
        return
    case NodeType.Identifier(name):
        // Bug #32 fix: Handle field access on expression results
        // When name is "_", params[0] is an expression to emit first,
        // then params[1..] are the field chain
        if name.eq("_") {
            if expr.params.len().gt(0) {
                // Emit the base expression (params[0])
                emit_expr(expr.get(0), output, indent, ctx, context)
                // Then emit the field chain
                for i in 1..expr.params.len() {
                    field_expr := expr.get(i)
                    switch field_expr.node_type {
                    case NodeType.Identifier(field):
                        output = output.concat(".")
                        output = output.concat(field)
                    case:
                    }
                }
                return
            }
        }

        // Check for type-qualified access (Type.field or Type.Variant)
        if expr.params.len().gt(0) {
            mut param := Expr()
            expr.params.get(0, param)
            switch param.node_type {
            case NodeType.Identifier(field):
                // Check if this is an enum variant by looking up in context
                mut is_enum_variant := false
                mut enum_def := context.scope_stack.lookup_enum(name)
                is_enum_variant = enum_def.contains_key(field)
                catch (err: KeyNotFoundError) { }

                if is_enum_variant {
                    // Enum variant: Type.Variant -> til_Type_make_Variant()
                    output = concat(output, TIL_PREFIX)
                    output = output.concat(name)
                    output = output.concat("_make_")
                    output = output.concat(field)
                    output = output.concat("()")
                    return
                }
                // Check if this is a struct constant access
                mut is_struct := false
                _ := context.scope_stack.lookup_struct(name)
                is_struct = true
                catch (err: KeyNotFoundError) { }
                if is_struct {
                    // Struct constant: Type.constant -> til_Type_constant
                    output = concat(output, til_name(name))
                    output = output.concat("_")
                    output = output.concat(field)
                    return
                }
            case:
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
        // Regular identifier or field access (b.val -> til_b.val)
        // For ref params (which are pointers in C), use -> for field access
        mut is_ref_param := ctx.current_ref_params.contains(name)
        if is_ref_param.and(expr.params.len().gt(0)) {
            // Ref param with field access: til_self->field1.field2.field3
            // First field uses -> (self is a pointer), rest use . (struct values)
            output = concat(output, til_name(name))
            mut i := 0
            while i.lt(expr.params.len()) {
                mut param := Expr()
                expr.params.get(i, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    if i.eq(0) {
                        output = output.concat("->")
                    } else {
                        output = output.concat(".")
                    }
                    output = output.concat(field)
                case:
                }
                i = i.add(1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            return
        } else if is_ref_param {
            // Ref param used as value: dereference with *
            output = concat(output, "(*")
            output = output.concat(til_name(name))
            output = output.concat(")")
            return
        } else {
            // Regular identifier or field access
            output = concat(output, til_name(name))
            mut i := 0
            while i.lt(expr.params.len()) {
                mut param := Expr()
                expr.params.get(i, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    output = output.concat(".")
                    output = output.concat(field)  // Field names stay as-is (C struct fields)
                case:
                }
                i = i.add(1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            return
        }
    case NodeType.FuncDef(func_def):
        emit_funcdef(func_def, expr, output, indent, ctx, context)
        return
    case NodeType.Assignment(name):
        emit_assignment(name, expr, output, indent, ctx, context)
        return
    case NodeType.Return:
        emit_return(expr, output, indent, ctx, context)
        return
    case NodeType.If:
        emit_if(expr, output, indent, ctx, context)
        return
    case NodeType.While:
        emit_while(expr, output, indent, ctx, context)
        return
    case NodeType.Break:
        emit_break(expr, output, indent)
        return
    case NodeType.Continue:
        emit_continue(expr, output, indent)
        return
    case NodeType.Catch:
        // Catch blocks handled at call site
        return
    case NodeType.Throw:
        emit_throw(expr, output, indent, ctx, context)
        return
    case NodeType.StructDef(s):
        throw "ccodegen: StructDef should be handled at top level, not in emit_expr"
    case NodeType.EnumDef(e):
        throw "ccodegen: EnumDef should be handled at top level, not in emit_expr"
    case NodeType.Switch:
        emit_switch(expr, output, indent, ctx, context)
        return
    case NodeType.DefaultCase:
        throw "ccodegen: DefaultCase should be handled inside emit_switch"
    case NodeType.Range:
        throw "ccodegen: Range not yet supported"
    case NodeType.Pattern(p):
        throw "ccodegen: Pattern should be handled inside emit_switch"
    case NodeType.NamedArg(_):
        throw expr.error(context.path, "ccodegen", "NamedArg should be reordered before reaching emit_expr")
    case NodeType.ForIn(_):
        throw expr.lang_error(context.path, "ccodegen", "ForIn should be desugared in precomp before reaching ccodegen")
    }
}

/// Emit a sequence of statements with catch pattern detection
/// This is the core logic shared between emit_body and emit_func_declaration
emit_stmts := proc(stmts: Vec, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    mut i := 0
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Pre-scan for function-level catches (at the end of the block)
    func_level_catches := prescan_func_level_catches(stmts)
    catch (err: AllocError) { throw err.msg }

    // Hoist declarations from catch blocks to function level
    // (TIL has function-level scoping, not block-level scoping)
    for catch_idx in 0..func_level_catches.len() {
        mut catch_block := Expr()
        func_level_catches.get(catch_idx, catch_block)
        if catch_block.params.len().gteq(3) {
            // Temporarily add the catch error variable to scope for type inference
            // catch (err: ErrType) { body } -> err_var=params[0], err_type=params[1], body=params[2]
            mut param0 := Expr()
            mut param1 := Expr()
            catch_block.params.get(0, param0)
            catch_block.params.get(1, param1)
            switch param0.node_type {
            case NodeType.Identifier(err_var_name):
                switch param1.node_type {
                case NodeType.Identifier(err_type_name):
                    mut sym_info := SymbolInfo()
                    sym_info.value_type = ValueType.TCustom(err_type_name)
                    sym_info.is_mut = false
                    sym_info.is_copy = false
                    sym_info.is_own = false
                    sym_info.is_comptime_const = false
                    context.scope_stack.declare_symbol(err_var_name, sym_info)
                case:
                }
            case:
            }

            mut catch_body := Expr()
            catch_block.params.get(2, catch_body)
            decls := collect_declarations_in_body(catch_body, context)
            for decl_idx in 0..decls.len() {
                mut decl := Declaration()
                decls.get(decl_idx, decl)
                c_var_name := til_name(decl.name)
                if not(ctx.declared_vars.contains(c_var_name)) {
                    c_type := til_type_to_c(decl.value_type)
                    output.push_str(indent_str)
                    output.push_str(c_type)
                    output.push_str(" ")
                    output.push_str(c_var_name)
                    output.push_str(";\n")
                    _ := ctx.declared_vars.insert(c_var_name)
                    // Also register in scope_stack so get_value_type can find it
                    mut sym_info := SymbolInfo()
                    sym_info.value_type = decl.value_type
                    sym_info.is_mut = false
                    sym_info.is_copy = false
                    sym_info.is_own = false
                    sym_info.is_comptime_const = false
                    context.scope_stack.declare_symbol(decl.name, sym_info)
                    catch (err: Str) { }
                }
            }
        }
    }

    // Bug #39 fix: Give each catch block its own unique label using the global counter
    // Store catch info with statement index so we can match calls to their NEXT catch
    mut all_catch_info := Vec.new(CatchLabelInfoEntry)
    for scan_idx in 0..stmts.len() {
        mut scan_stmt := Expr()
        stmts.get(scan_idx, scan_stmt)
        switch scan_stmt.node_type {
        case NodeType.Catch:
            if scan_stmt.params.len().gteq(3) {
                mut param1 := Expr()
                scan_stmt.params.get(1, param1)
                switch param1.node_type {
                case NodeType.Identifier(err_type_name):
                    catch_suffix := next_mangled(ctx)
                    mut entry := CatchLabelInfoEntry()
                    entry.stmt_index = scan_idx
                    entry.type_name = err_type_name
                    entry.label = format("_catch_", err_type_name, "_", catch_suffix)
                    entry.temp_var = format("_thrown_", err_type_name, "_", catch_suffix)
                    all_catch_info.push(entry)
                case:
                }
            }
        case:
        }
    }

    // Declare temp variables for all catches at the start
    for entry_idx in 0..all_catch_info.len() {
        mut catch_entry := CatchLabelInfoEntry()
        all_catch_info.get(entry_idx, catch_entry)
        output.push_str(indent_str)
        output.push_str(til_name(catch_entry.type_name))
        output.push_str(" ")
        output.push_str(catch_entry.temp_var)
        output.push_str(";\n")
    }

    // For backward compatibility, also populate local_catch_labels with first catch of each type
    // This is used by throw statements and nested blocks
    mut registered_types := Set.new(Str)
    for entry_idx in 0..all_catch_info.len() {
        mut catch_entry := CatchLabelInfoEntry()
        all_catch_info.get(entry_idx, catch_entry)
        if not(registered_types.contains(catch_entry.type_name)) {
            _ := registered_types.insert(catch_entry.type_name)
            mut info := CatchLabelInfo()
            info.label = catch_entry.label
            info.temp_var = catch_entry.temp_var
            ctx.local_catch_labels.set(catch_entry.type_name, info)
        }
    }

    // Track which catch labels have been emitted to avoid duplicates
    // (when multiple catches of same type exist, only emit the label once)
    mut emitted_catch_labels := Set.new(Str)

    // Process all statements
    while i.lt(stmts.len()) {
        mut stmt := Expr()
        stmts.get(i, stmt)
        effective_indent := indent  // Use same indent for all statements (no if-block nesting)

        // Bug #39 fix: Handle catch blocks inline with if(0) { label: ... }
        // This keeps catches where they appear in source, and execution falls through after
        switch stmt.node_type {
        case NodeType.Catch:
            // Get the error type this catch handles
            if stmt.params.len().gteq(3) {
                mut param1 := Expr()
                stmt.params.get(1, param1)
                switch param1.node_type {
                case NodeType.Identifier(err_type_name):
                    // Look up this specific catch's label from all_catch_info by statement index
                    mut found_catch_entry := false
                    mut catch_entry := CatchLabelInfoEntry()
                    for e_idx in 0..all_catch_info.len() {
                        mut e := CatchLabelInfoEntry()
                        all_catch_info.get(e_idx, e)
                        if e.stmt_index.eq(i) {
                            found_catch_entry = true
                            catch_entry = e
                            break
                        }
                    }
                    if found_catch_entry {
                        // Only emit if we haven't already emitted this label
                        if not(emitted_catch_labels.contains(catch_entry.label)) {
                            _ := emitted_catch_labels.insert(catch_entry.label)
                            label := catch_entry.label
                            temp_var := catch_entry.temp_var

                            output.push_str(indent_str)
                            output.push_str("if (0) { ")
                            output.push_str(label)
                            output.push_str(":\n")

                            // Bind error variable
                            mut param0 := Expr()
                            stmt.params.get(0, param0)
                            switch param0.node_type {
                            case NodeType.Identifier(err_var_name):
                                mut inner_indent := ""
                                for _ in 0..indent.add(1) {
                                    inner_indent.push_str("    ")
                                }
                                output.push_str(inner_indent)
                                output.push_str(til_name(err_type_name))
                                output.push_str(" ")
                                output.push_str(til_name(err_var_name))
                                output.push_str(" = ")
                                output.push_str(temp_var)
                                output.push_str(";\n")

                                // Add error variable to scope for type resolution in catch body
                                mut sym_info := SymbolInfo()
                                sym_info.value_type = ValueType.TCustom(err_type_name)
                                sym_info.is_mut = false
                                sym_info.is_copy = false
                                sym_info.is_own = false
                                sym_info.is_comptime_const = false
                                context.scope_stack.declare_symbol(err_var_name, sym_info)
                            case:
                            }

                            // Emit catch body
                            // IMPORTANT: Temporarily clear local_catch_labels so throwing calls inside
                            // the catch body don't try to jump to catches - catches shouldn't catch
                            // errors from their own body, only from code before them
                            saved_catch_labels := ctx.local_catch_labels.clone()
                            ctx.local_catch_labels.clear()
                            mut param2 := Expr()
                            stmt.params.get(2, param2)
                            emit_expr(param2, output, indent.add(1), ctx, context)
                            ctx.local_catch_labels = saved_catch_labels
                            catch (err: AllocError) { throw err.msg }

                            // Close the if(0) block - execution falls through to code after
                            output.push_str(indent_str)
                            output.push_str("}\n")

                            // Bug #46 fix: Remove this catch from local_catch_labels
                            // Catches should only handle throws from BEFORE them, not after.
                            // This mirrors the interpreter's behavior where pending_throw is
                            // set by statements and only subsequent catches can handle it.
                            ctx.local_catch_labels.remove(err_type_name)
                        }
                    }
                case:
                }
            }
            i = i.add(1)
            continue
        case:
        }

        // Check if this statement is followed by catch blocks
        // And if it's a call to a throwing function (FCall, Declaration with FCall, or Assignment with FCall)
        mut has_fcall := false
        mut fcall_expr := Expr()
        mut decl_name := ""  // Empty string means None
        mut assign_name := ""  // Empty string means None

        switch stmt.node_type {
        case NodeType.FCall:
            has_fcall = true
            fcall_expr = stmt
        case NodeType.Declaration(decl):
            // Check if declaration has an FCall as initializer
            if stmt.params.len().gt(0) {
                mut first_param := Expr()
                stmt.params.get(0, first_param)
                switch first_param.node_type {
                case NodeType.FCall:
                    has_fcall = true
                    fcall_expr = first_param
                    decl_name = decl.name
                case:
                }
            }
        case NodeType.Assignment(name):
            // Check if assignment has an FCall as RHS
            if stmt.params.len().gt(0) {
                mut first_param := Expr()
                stmt.params.get(0, first_param)
                switch first_param.node_type {
                case NodeType.FCall:
                    has_fcall = true
                    fcall_expr = first_param
                    assign_name = name
                case:
                }
            }
        case:
        }

        if has_fcall {
            fcall := fcall_expr

            // eval functions from std.meta are only available in interpret mode
            if fcall.params.len().gt(0) {
                mut first_param := Expr()
                fcall.params.get(0, first_param)
                func_name := get_til_func_name_string(first_param)
                if func_name.eq("eval_file") {
                    throw fcall.error(context.path, "ccodegen", "eval_file() is only available in interpret mode, not in build/run")
                }
                if func_name.eq("eval_to_str") {
                    throw fcall.error(context.path, "ccodegen", "eval_to_str() is only available in interpret mode, not in build/run")
                }
                if func_name.eq("eval_to_ast_str") {
                    throw fcall.error(context.path, "ccodegen", "eval_to_ast_str() is only available in interpret mode, not in build/run")
                }
                if func_name.eq("eval_to_expr") {
                    throw fcall.error(context.path, "ccodegen", "eval_to_expr() is only available in interpret mode, not in build/run")
                }
                catch (err: KeyNotFoundError) { }
            }

            // Get function name from the FCall
            // Check if this function is a throwing function
            mut throw_types := Vec.new(ValueType)
            fd := get_fcall_func_def(context, fcall)
            throw_types = fd.throw_types.clone()
            catch (err: AllocError) { throw err.msg }
            if throw_types.len().gt(0) {
                // Collect subsequent catch blocks
                mut catch_blocks := Vec.new(Expr)
                mut j := i.add(1)
                while j.lt(stmts.len()) {
                    mut next_stmt := Expr()
                    stmts.get(j, next_stmt)
                    switch next_stmt.node_type {
                    case NodeType.Catch:
                        catch_blocks.push(next_stmt)
                        j = j.add(1)
                    case:
                        break
                    }
                }

                if catch_blocks.len().gt(0) {
                    if func_level_catches.len().eq(0) {
                        // Immediate catches AND no function-level catches - handle inline
                        // Only use this optimization if there are no earlier throwing calls that
                        // need the catch labels (func_level_catches tracks all catches in the block)
                        emit_throwing_call(fcall, throw_types, catch_blocks, decl_name, assign_name, output, effective_indent, ctx, context)
                        i = j  // Skip past catch blocks
                        continue
                    }
                }
                if ctx.current_throw_types.len().gt(0) {
                    if ctx.local_catch_labels.len().eq(0) {
                        if func_level_catches.len().eq(0) {
                            // Bug #68 fix: Also check func_level_catches.is_empty()
                            // Without this check, we might propagate even when there are catches in the block
                            // just because local_catch_labels was cleared after processing an earlier catch
                            // No catch blocks, we're inside a throwing function, and no catches in this block
                            // Emit error propagation pattern
                            emit_throwing_call_propagate(fcall, throw_types, decl_name, assign_name, output, effective_indent, ctx, context)
                            i = i.add(1)
                            continue
                        }
                    }
                }
                if func_level_catches.len().gt(0) {
                    // Has function-level catches or outer catches registered
                    // Bug #39 fix: Update local_catch_labels to point to NEXT catch for each type
                    // This ensures each call jumps to the correct catch, not always the first one
                    // Build map with only catches AFTER current position
                    mut next_catches := Map.new(Str, CatchLabelInfo)
                    for entry_idx in 0..all_catch_info.len() {
                        mut catch_entry := CatchLabelInfoEntry()
                        all_catch_info.get(entry_idx, catch_entry)
                        if catch_entry.stmt_index.gt(i) {
                            if not(next_catches.contains_key(catch_entry.type_name)) {
                                // First catch of this type after current position
                                mut info := CatchLabelInfo()
                                info.label = catch_entry.label
                                info.temp_var = catch_entry.temp_var
                                next_catches.set(catch_entry.type_name, info)
                            }
                        }
                    }
                    // Replace local_catch_labels with only the next catches
                    // This removes entries for types that have no more catches after this point
                    ctx.local_catch_labels.clear()
                    for type_name: Str in next_catches.keys {
                        mut catch_info := CatchLabelInfo()
                        next_catches.get(type_name, catch_info)
                        ctx.local_catch_labels.set(type_name, catch_info)
                    }
                    emit_throwing_call_with_goto(fcall, throw_types, decl_name, assign_name, output, effective_indent, ctx, context)
                    i = i.add(1)
                    continue
                }
                if ctx.local_catch_labels.len().gt(0) {
                    // Has outer catches
                    mut next_catches := Map.new(Str, CatchLabelInfo)
                    for entry_idx in 0..all_catch_info.len() {
                        mut catch_entry := CatchLabelInfoEntry()
                        all_catch_info.get(entry_idx, catch_entry)
                        if catch_entry.stmt_index.gt(i) {
                            if not(next_catches.contains_key(catch_entry.type_name)) {
                                mut info := CatchLabelInfo()
                                info.label = catch_entry.label
                                info.temp_var = catch_entry.temp_var
                                next_catches.set(catch_entry.type_name, info)
                            }
                        }
                    }
                    ctx.local_catch_labels.clear()
                    for type_name: Str in next_catches.keys {
                        mut catch_info := CatchLabelInfo()
                        next_catches.get(type_name, catch_info)
                        ctx.local_catch_labels.set(type_name, catch_info)
                    }
                    emit_throwing_call_with_goto(fcall, throw_types, decl_name, assign_name, output, effective_indent, ctx, context)
                    i = i.add(1)
                    continue
                } else {
                    // No catches - typer should have caught this if we're in non-throwing context
                    // Just use propagate (will silently succeed on error if we're not throwing)
                    emit_throwing_call_propagate(fcall, throw_types, decl_name, assign_name, output, effective_indent, ctx, context)
                    i = i.add(1)
                    continue
                }
            }
            catch (err: KeyNotFoundError) { }

            // Check for non-throwing variadic calls in declarations/assignments
            // These need special handling because variadic array must be constructed first
            variadic_fcall_info := detect_variadic_fcall(fcall, ctx)
            // Check that this is NOT a throwing function (those are handled above)
            mut is_throwing := false
            fd2 := get_fcall_func_def(context, fcall)
            if fd2.throw_types.len().gt(0) {
                is_throwing = true
            }
            catch (err: KeyNotFoundError) { }

            if not(is_throwing) {
                emit_variadic_call(fcall, variadic_fcall_info.elem_type, variadic_fcall_info.regular_count, decl_name, assign_name, output, effective_indent, ctx, context)
                i = i.add(1)
                continue
            }
        }

        // Regular statement handling
        emit_expr(stmt, output, effective_indent, ctx, context)
        i = i.add(1)
    }

    // Clean up local_catch_labels for this block
    for entry_idx in 0..all_catch_info.len() {
        mut catch_entry := CatchLabelInfoEntry()
        all_catch_info.get(entry_idx, catch_entry)
        ctx.local_catch_labels.remove(catch_entry.type_name)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
}

/// Emit a non-throwing variadic function call at statement level
/// Handles constructing the variadic array and cleaning it up after the call
emit_variadic_call := proc(
    fcall: Expr,
    elem_type: Str,
    regular_count: I64,
    decl_name: Str,
    assign_name: Str,
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Get function name
    func_name := get_fcall_func_name(fcall)
    catch (err: KeyNotFoundError) {
        throw "emit_variadic_call: could not get function name"
    }

    // Calculate param info for by-ref param handling
    mut param_by_ref := Vec.new(Bool)
    mut param_types := Vec.new(ValueType)
    func_def_opt := get_fcall_func_def(context, fcall)
    for i in 0..fcall.params.len().sub(1) {
        mut decl := Declaration()
        func_def_opt.args.get(i, decl)
        param_by_ref.push(param_needs_by_ref(decl))
        param_types.push(decl.value_type)
        catch (err: IndexOutOfBoundsError) {
            param_by_ref.push(false)
            // Don't push anything to param_types - callers use catch for IndexOutOfBoundsError
        }
    }
    catch (err: KeyNotFoundError) { }

    // Hoist any throwing function calls in arguments BEFORE constructing variadic array
    mut hoisted := Map.new(I64, Str)
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
        for h_idx in 0..hoisted_vec.len() {
            mut h := HoistedArg()
            hoisted_vec.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Construct variadic array
    mut variadic_args := Vec.new(Expr)
    start_idx := add(1, regular_count)
    for i in start_idx..fcall.params.len() {
        mut arg := Expr()
        fcall.params.get(i, arg)
        variadic_args.push(arg)
    }
    variadic_arr_var := hoist_variadic_args(elem_type, variadic_args, hoisted, regular_count, output, indent, ctx, context)

    // Determine return type if we need to declare a variable
    mut ret_type := "int"
    if decl_name.len().gt(0) {
        fd := get_fcall_func_def(context, fcall)
        mut first_ret := ValueType.TCustom("")
        fd.return_types.get(0, first_ret)
        ret_type = til_type_to_c(first_ret)
        catch (err: Str) { ret_type = "int" }
        catch (err: IndexOutOfBoundsError) { ret_type = "int" }
        catch (err: KeyNotFoundError) { ret_type = "int" }
    }
    if assign_name.len().gt(0) {
        if ret_type.eq("int") {
            fd := get_fcall_func_def(context, fcall)
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
            catch (err: Str) { ret_type = "int" }
            catch (err: IndexOutOfBoundsError) { ret_type = "int" }
            catch (err: KeyNotFoundError) { ret_type = "int" }
        }
    }

    // For declarations: declare the variable (skip for "_" - Bug #35)
    if decl_name.len().gt(0) {
        var_name := decl_name
        if var_name.eq("_") {
            // Bug #35: For underscore, just call the function (discard result)
            output.push_str(indent_str)
            output.push_str(TIL_PREFIX)
            output.push_str(func_name.replace(".", "_"))
            output.push_str("(")

            for i in 0..regular_count {
                if i.gt(0) {
                    output.push_str(", ")
                }
                mut arg := Expr()
                fcall.params.get(i.add(1), arg)
                mut pt := ValueType.TCustom("")
                mut pt_ptr := Ptr()
                param_types.get(i, pt)
                pt_ptr.data = to_ptr(pt)
                catch (err: IndexOutOfBoundsError) { }
                mut by_ref := false
                param_by_ref.get(i, by_ref)
                catch (err: IndexOutOfBoundsError) { }
                emit_arg_with_param_type(arg, i, hoisted, pt_ptr, by_ref, output, ctx, context)
            }

            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)
            output.push_str(");\n")
        } else {
            output.push_str(indent_str)
            output.push_str(ret_type)
            output.push_str(" ")
            output.push_str(til_name(var_name))
            output.push_str(" = ")

            // Emit function call
            output.push_str(TIL_PREFIX)
            output.push_str(func_name.replace(".", "_"))
            output.push_str("(")

            // Emit regular args first
            for i in 0..regular_count {
                if i.gt(0) {
                    output.push_str(", ")
                }
                mut arg := Expr()
                fcall.params.get(i.add(1), arg)
                mut pt := ValueType.TCustom("")
                mut pt_ptr := Ptr()
                param_types.get(i, pt)
                pt_ptr.data = to_ptr(pt)
                catch (err: IndexOutOfBoundsError) { }
                mut by_ref := false
                param_by_ref.get(i, by_ref)
                catch (err: IndexOutOfBoundsError) { }
                emit_arg_with_param_type(arg, i, hoisted, pt_ptr, by_ref, output, ctx, context)
            }

            // Emit variadic array pointer
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)

            output.push_str(");\n")

            // Add variable to scope
            fd := get_fcall_func_def(context, fcall)
            mut first_type := ValueType.TCustom("")
            fd.return_types.get(0, first_type)
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(var_name, sym_info)
            _ := ctx.declared_vars.insert(til_name(var_name))
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    } else {
        if assign_name.len().gt(0) {
            // Assignment
            var_name := assign_name
            output.push_str(indent_str)
            output.push_str(til_name(var_name))
            output.push_str(" = ")

            // Emit function call
            output.push_str(TIL_PREFIX)
            output.push_str(func_name.replace(".", "_"))
            output.push_str("(")

            // Emit regular args first
            for i in 0..regular_count {
                if i.gt(0) {
                    output.push_str(", ")
                }
                mut arg := Expr()
                fcall.params.get(i.add(1), arg)
                mut pt := ValueType.TCustom("")
                mut pt_ptr := Ptr()
                param_types.get(i, pt)
                pt_ptr.data = to_ptr(pt)
                catch (err: IndexOutOfBoundsError) { }
                mut by_ref := false
                param_by_ref.get(i, by_ref)
                catch (err: IndexOutOfBoundsError) { }
                emit_arg_with_param_type(arg, i, hoisted, pt_ptr, by_ref, output, ctx, context)
            }

            // Emit variadic array pointer
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)

            output.push_str(");\n")
        } else {
            // Standalone variadic call (no return value used)
            output.push_str(indent_str)
            output.push_str(TIL_PREFIX)
            output.push_str(func_name.replace(".", "_"))
            output.push_str("(")

            // Emit regular args first
            for i in 0..regular_count {
                if i.gt(0) {
                    output.push_str(", ")
                }
                mut arg := Expr()
                fcall.params.get(i.add(1), arg)
                mut pt := ValueType.TCustom("")
                mut pt_ptr := Ptr()
                param_types.get(i, pt)
                pt_ptr.data = to_ptr(pt)
                catch (err: IndexOutOfBoundsError) { }
                mut by_ref := false
                param_by_ref.get(i, by_ref)
                catch (err: IndexOutOfBoundsError) { }
                emit_arg_with_param_type(arg, i, hoisted, pt_ptr, by_ref, output, ctx, context)
            }

            // Emit variadic array pointer
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)

            output.push_str(");\n")
        }
    }

    // Clean up variadic array
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Array_delete(&")
    output.push_str(variadic_arr_var)
    output.push_str(");\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Emit a call to a throwing function with catch handling
emit_throwing_call := proc(
    fcall: Expr,
    throw_types: Vec,
    catch_blocks: Vec,
    decl_name: Str,  // Empty string means None
    assign_name: Str,  // Empty string means None
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    mut first_param := Expr()
    fcall.params.get(0, first_param)
    orig_func_name := get_til_func_name_string(first_param)
    mut mangled := ""
    ctx.nested_func_names.get(orig_func_name, mangled)
    func_name = mangled
    catch (err: KeyNotFoundError) { }

    // Generate unique temp names for this call
    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    func_def_opt := get_fcall_func_def(context, fcall)
    func_has_return := func_def_opt.return_types.len().gt(0)
    mut needs_ret := false
    if func_has_return {
        if decl_name.len().gt(0) {
            needs_ret = true
        }
        if assign_name.len().gt(0) {
            needs_ret = true
        }
    }
    catch (err: KeyNotFoundError) { }

    // Calculate param_types and param_by_ref
    mut param_types := Vec.new(ValueType)
    mut param_by_ref := Vec.new(Bool)
    fd := get_fcall_func_def(context, fcall)
    for i in 0..fcall.params.len().sub(1) {
        mut decl := Declaration()
        fd.args.get(i, decl)
        param_types.push(decl.value_type)
        param_by_ref.push(param_needs_by_ref(decl))
        catch (err: IndexOutOfBoundsError) {
            // No param type - push sentinel value (callers ignore param_type when arg is out of bounds)
            param_types.push(ValueType.TCustom(""))
            param_by_ref.push(false)
        }
    }
    catch (err: KeyNotFoundError) { }

    // Hoist any throwing function calls in arguments BEFORE emitting this call
    mut hoisted := Map.new(I64, Str)
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
        for h_idx in 0..hoisted_vec.len() {
            mut h := HoistedArg()
            hoisted_vec.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist non-lvalue args when param type is Dynamic
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        dynamic_hoisted := hoist_for_dynamic_params(args, param_types, hoisted, output, indent, ctx, context)
        for h_idx in 0..dynamic_hoisted.len() {
            mut h := HoistedArg()
            dynamic_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist struct-returning FCall args when param is by-ref
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted, output, indent, ctx, context)
        for h_idx in 0..ref_hoisted.len() {
            mut h := HoistedArg()
            ref_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Look up the actual return type
    mut ret_type := "int"
    if needs_ret {
        fd2 := get_fcall_func_def(context, fcall)
        mut first_ret := ValueType.TCustom("")
        fd2.return_types.get(0, first_ret)
        ret_type = til_type_to_c(first_ret)
        catch (err: Str) { ret_type = "int" }
        catch (err: IndexOutOfBoundsError) { ret_type = "int" }
        catch (err: KeyNotFoundError) { ret_type = "int" }
    }

    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable BEFORE the if block
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            output.push_str(indent_str)
            output.push_str(ret_type)
            output.push_str(" ")
            output.push_str(til_name(var_name))
            output.push_str(";\n")
            _ := ctx.declared_vars.insert(til_name(var_name))
            fd3 := get_fcall_func_def(context, fcall)
            mut first_type := ValueType.TCustom("")
            fd3.return_types.get(0, first_type)
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(var_name, sym_info)
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(idx, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(idx.to_str())
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Check if this is a variadic function call
    variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""  // Empty string means None
    mut variadic_args := Vec.new(Expr)
    start_idx := add(1, variadic_info.regular_count)
    for i in start_idx..fcall.params.len() {
        mut arg := Expr()
        fcall.params.get(i, arg)
        variadic_args.push(arg)
    }
    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, output, indent, ctx, context)
    catch (err: KeyNotFoundError) { }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers
    for idx in 0..throw_types.len() {
        if needs_ret {
            output.push_str(", ")
        } else {
            if idx.gt(0) {
                output.push_str(", ")
            }
        }
        output.push_str("&_err")
        output.push_str(idx.to_str())
        output.push_str("_")
        output.push_str(temp_suffix)
    }

    // Emit arguments
    if variadic_arr_var.len().gt(0) {
        // Variadic call: emit regular args first, then variadic array pointer
        for arg_idx in 0..variadic_info.regular_count {
            if needs_ret {
                output.push_str(", ")
            } else {
                if throw_types.len().gt(0) {
                    output.push_str(", ")
                } else {
                    if arg_idx.gt(0) {
                        output.push_str(", ")
                    }
                }
            }
            mut arg := Expr()
            fcall.params.get(arg_idx.add(1), arg)
            mut pt := ValueType.TCustom("")
            mut pt_ptr := Ptr()
            param_types.get(arg_idx, pt)
            pt_ptr.data = to_ptr(pt)
            catch (err: IndexOutOfBoundsError) { }
            mut by_ref := false
            param_by_ref.get(arg_idx, by_ref)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, hoisted, pt_ptr, by_ref, output, ctx, context)
        }
        // Emit variadic array pointer
        if needs_ret {
            output.push_str(", ")
        } else {
            if throw_types.len().gt(0) {
                output.push_str(", ")
            } else {
                if variadic_info.regular_count.gt(0) {
                    output.push_str(", ")
                }
            }
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    } else {
        // Non-variadic: emit all args directly
        mut args_started := false
        for arg_idx in 0..fcall.params.len().sub(1) {
            if needs_ret {
                output.push_str(", ")
            } else {
                if throw_types.len().gt(0) {
                    output.push_str(", ")
                } else {
                    if args_started {
                        output.push_str(", ")
                    }
                }
            }
            mut arg := Expr()
            fcall.params.get(arg_idx.add(1), arg)
            mut pt := ValueType.TCustom("")
            mut pt_ptr := Ptr()
            param_types.get(arg_idx, pt)
            pt_ptr.data = to_ptr(pt)
            catch (err: IndexOutOfBoundsError) { }
            mut by_ref := false
            param_by_ref.get(arg_idx, by_ref)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, hoisted, pt_ptr, by_ref, output, ctx, context)
            args_started = true
        }
    }

    output.push_str(");\n")

    // Generate if/else chain for error handling
    output.push_str(indent_str)
    output.push_str("if (_status_")
    output.push_str(temp_suffix)
    output.push_str(" == 0) {\n")

    // Success case: assign return value to target variable
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            mut inner_indent := ""
            for _ in 0..indent.add(1) {
                inner_indent.push_str("    ")
            }
            output.push_str(inner_indent)
            output.push_str(til_name(var_name))
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    } else {
        if assign_name.len().gt(0) {
            var_name := assign_name
            mut inner_indent := ""
            for _ in 0..indent.add(1) {
                inner_indent.push_str("    ")
            }
            output.push_str(inner_indent)
            // Check if assignment target is a field access on a mut param
            dot_pos := var_name.find(".")
            if dot_pos.gteq(0) {
                base := var_name.get_substr(0, dot_pos)
                rest := var_name.get_substr(dot_pos.add(1), var_name.len())
                if ctx.current_ref_params.contains(base) {
                    output.push_str(til_name(base))
                    output.push_str("->")
                    output.push_str(rest)
                } else {
                    output.push_str(til_name(var_name))
                }
            } else {
                if ctx.current_ref_params.contains(var_name) {
                    output.push_str("*")
                    output.push_str(til_name(var_name))
                } else {
                    output.push_str(til_name(var_name))
                }
            }
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    }

    output.push_str(indent_str)
    output.push_str("}")

    // Generate else-if branches for each catch block
    for cb_idx in 0..catch_blocks.len() {
        mut catch_block := Expr()
        catch_blocks.get(cb_idx, catch_block)
        if catch_block.params.len().gteq(3) {
            mut param1 := Expr()
            catch_block.params.get(1, param1)
            switch param1.node_type {
            case NodeType.Identifier(err_type_name):
                // Find index of this error type
                mut err_idx := sub(0, 1)
                for i in 0..throw_types.len() {
                    mut vt := ValueType.TCustom("")
                    throw_types.get(i, vt)
                    switch vt {
                    case ValueType.TCustom(name):
                        if name.eq(err_type_name) {
                            err_idx = i
                            break
                        }
                    case:
                    }
                }
                if err_idx.gteq(0) {
                    idx := err_idx
                    output.push_str(" else if (_status_")
                    output.push_str(temp_suffix)
                    output.push_str(" == ")
                    output.push_str(idx.add(1).to_str())
                    output.push_str(") {\n")

                    // Bind error variable
                    mut param0 := Expr()
                    catch_block.params.get(0, param0)
                    switch param0.node_type {
                    case NodeType.Identifier(err_var_name):
                        mut inner_indent := ""
                        for _ in 0..indent.add(1) {
                            inner_indent.push_str("    ")
                        }
                        output.push_str(inner_indent)
                        output.push_str(til_name(err_type_name))
                        output.push_str(" ")
                        output.push_str(til_name(err_var_name))
                        output.push_str(" = _err")
                        output.push_str(idx.to_str())
                        output.push_str("_")
                        output.push_str(temp_suffix)
                        output.push_str(";\n")

                        mut sym_info := SymbolInfo()
                        sym_info.value_type = ValueType.TCustom(err_type_name)
                        sym_info.is_mut = false
                        sym_info.is_copy = false
                        sym_info.is_own = false
                        sym_info.is_comptime_const = false
                        context.scope_stack.declare_symbol(err_var_name, sym_info)
                    case:
                    }

                    // Emit catch body
                    mut param2 := Expr()
                    catch_block.params.get(2, param2)
                    emit_expr(param2, output, indent.add(1), ctx, context)

                    output.push_str(indent_str)
                    output.push_str("}")
                }
            case:
            }
        }
    }

    output.push_str("\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Emit a throwing function call that propagates errors to the caller (no catch blocks)
emit_throwing_call_propagate := proc(
    fcall: Expr,
    throw_types: Vec,
    decl_name: Str,  // Empty string means None
    assign_name: Str,  // Empty string means None
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call_propagate: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    mut first_param := Expr()
    fcall.params.get(0, first_param)
    orig_func_name := get_til_func_name_string(first_param)
    mut mangled := ""
    ctx.nested_func_names.get(orig_func_name, mangled)
    func_name = mangled
    catch (err: KeyNotFoundError) { }

    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    func_def_opt := get_fcall_func_def(context, fcall)
    func_has_return := func_def_opt.return_types.len().gt(0)
    mut needs_ret := false
    if func_has_return {
        if decl_name.len().gt(0) {
            needs_ret = true
        }
        if assign_name.len().gt(0) {
            needs_ret = true
        }
    }
    catch (err: KeyNotFoundError) { }

    // Calculate param_types and param_by_ref
    mut param_types := Vec.new(ValueType)
    mut param_by_ref := Vec.new(Bool)
    fd := get_fcall_func_def(context, fcall)
    for i in 0..fcall.params.len().sub(1) {
        mut decl := Declaration()
        fd.args.get(i, decl)
        param_types.push(decl.value_type)
        param_by_ref.push(param_needs_by_ref(decl))
        catch (err: IndexOutOfBoundsError) {
            // No param type - push sentinel value (callers ignore param_type when arg is out of bounds)
            param_types.push(ValueType.TCustom(""))
            param_by_ref.push(false)
        }
    }
    catch (err: KeyNotFoundError) { }

    // Hoist any throwing function calls in arguments
    mut hoisted := Map.new(I64, Str)
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
        for h_idx in 0..hoisted_vec.len() {
            mut h := HoistedArg()
            hoisted_vec.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist non-lvalue args when param type is Dynamic
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        dynamic_hoisted := hoist_for_dynamic_params(args, param_types, hoisted, output, indent, ctx, context)
        for h_idx in 0..dynamic_hoisted.len() {
            mut h := HoistedArg()
            dynamic_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist struct-returning FCall args when param is by-ref
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted, output, indent, ctx, context)
        for h_idx in 0..ref_hoisted.len() {
            mut h := HoistedArg()
            ref_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Look up the actual return type
    mut ret_type := "int"
    if needs_ret {
        fd2 := get_fcall_func_def(context, fcall)
        mut first_ret := ValueType.TCustom("")
        fd2.return_types.get(0, first_ret)
        ret_type = til_type_to_c(first_ret)
        catch (err: Str) { ret_type = "int" }
        catch (err: IndexOutOfBoundsError) { ret_type = "int" }
        catch (err: KeyNotFoundError) { ret_type = "int" }
    }

    // Declare temp for return value if needed
    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable BEFORE the if block
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            output.push_str(indent_str)
            output.push_str(ret_type)
            output.push_str(" ")
            output.push_str(til_name(var_name))
            output.push_str(";\n")
            _ := ctx.declared_vars.insert(til_name(var_name))
            fd3 := get_fcall_func_def(context, fcall)
            mut first_type := ValueType.TCustom("")
            fd3.return_types.get(0, first_type)
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(var_name, sym_info)
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(idx, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(idx.to_str())
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Check for variadic function call
    variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""  // Empty string means None
    mut variadic_args := Vec.new(Expr)
    start_idx := add(1, variadic_info.regular_count)
    for i in start_idx..fcall.params.len() {
        mut arg := Expr()
        fcall.params.get(i, arg)
        variadic_args.push(arg)
    }
    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, output, indent, ctx, context)
    catch (err: KeyNotFoundError) { }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers
    for idx in 0..throw_types.len() {
        if needs_ret {
            output.push_str(", ")
        } else {
            if idx.gt(0) {
                output.push_str(", ")
            }
        }
        output.push_str("&_err")
        output.push_str(idx.to_str())
        output.push_str("_")
        output.push_str(temp_suffix)
    }

    // Emit arguments
    if variadic_arr_var.len().gt(0) {
        for arg_idx in 0..variadic_info.regular_count {
            if needs_ret {
                output.push_str(", ")
            } else {
                if throw_types.len().gt(0) {
                    output.push_str(", ")
                } else {
                    if arg_idx.gt(0) {
                        output.push_str(", ")
                    }
                }
            }
            mut arg := Expr()
            fcall.params.get(arg_idx.add(1), arg)
            mut pt := ValueType.TCustom("")
            mut pt_ptr := Ptr()
            param_types.get(arg_idx, pt)
            pt_ptr.data = to_ptr(pt)
            catch (err: IndexOutOfBoundsError) { }
            mut by_ref := false
            param_by_ref.get(arg_idx, by_ref)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, hoisted, pt_ptr, by_ref, output, ctx, context)
        }
        if needs_ret {
            output.push_str(", ")
        } else {
            if throw_types.len().gt(0) {
                output.push_str(", ")
            } else {
                if variadic_info.regular_count.gt(0) {
                    output.push_str(", ")
                }
            }
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    } else {
        mut args_started := false
        for arg_idx in 0..fcall.params.len().sub(1) {
            if needs_ret {
                output.push_str(", ")
            } else {
                if throw_types.len().gt(0) {
                    output.push_str(", ")
                } else {
                    if args_started {
                        output.push_str(", ")
                    }
                }
            }
            mut arg := Expr()
            fcall.params.get(arg_idx.add(1), arg)
            mut pt := ValueType.TCustom("")
            mut pt_ptr := Ptr()
            param_types.get(arg_idx, pt)
            pt_ptr.data = to_ptr(pt)
            catch (err: IndexOutOfBoundsError) { }
            mut by_ref := false
            param_by_ref.get(arg_idx, by_ref)
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, arg_idx, hoisted, pt_ptr, by_ref, output, ctx, context)
            args_started = true
        }
    }

    output.push_str(");\n")

    // Generate error propagation
    for called_idx in 0..throw_types.len() {
        mut called_throw_type := ValueType.TCustom("")
        throw_types.get(called_idx, called_throw_type)
        switch called_throw_type {
        case ValueType.TCustom(called_type_name):
            // Find matching error type in current function's throw types
            mut current_idx := sub(0, 1)
            for i in 0..ctx.current_throw_types.len() {
                mut vt := ValueType.TCustom("")
                ctx.current_throw_types.get(i, vt)
                switch vt {
                case ValueType.TCustom(name):
                    if name.eq(called_type_name) {
                        current_idx = i
                        break
                    }
                case:
                }
            }
            if current_idx.gteq(0) {
                cur_idx := current_idx
                output.push_str(indent_str)
                output.push_str("if (_status_")
                output.push_str(temp_suffix)
                output.push_str(" == ")
                output.push_str(called_idx.add(1).to_str())
                output.push_str(") { *_err")
                output.push_str(cur_idx.add(1).to_str())
                output.push_str(" = _err")
                output.push_str(called_idx.to_str())
                output.push_str("_")
                output.push_str(temp_suffix)
                output.push_str("; return ")
                output.push_str(cur_idx.add(1).to_str())
                output.push_str("; }\n")
            }
        case:
        }
    }

    // Success case: assign return value
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            output.push_str(indent_str)
            output.push_str(til_name(var_name))
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    } else {
        if assign_name.len().gt(0) {
            var_name := assign_name
            output.push_str(indent_str)
            dot_pos := var_name.find(".")
            if dot_pos.gteq(0) {
                base := var_name.get_substr(0, dot_pos)
                rest := var_name.get_substr(dot_pos.add(1), var_name.len())
                if ctx.current_ref_params.contains(base) {
                    output.push_str(til_name(base))
                    output.push_str("->")
                    output.push_str(rest)
                } else {
                    output.push_str(til_name(var_name))
                }
            } else {
                if ctx.current_ref_params.contains(var_name) {
                    output.push_str("*")
                    output.push_str(til_name(var_name))
                } else {
                    output.push_str(til_name(var_name))
                }
            }
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Emit a throwing function call that uses goto for error handling
emit_throwing_call_with_goto := proc(
    fcall: Expr,
    throw_types: Vec,
    decl_name: Str,  // Empty string means None
    assign_name: Str,  // Empty string means None
    mut output: Str,
    indent: I64,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call_with_goto: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function
    mut first_param := Expr()
    fcall.params.get(0, first_param)
    orig_func_name := get_til_func_name_string(first_param)
    mut mangled := ""
    ctx.nested_func_names.get(orig_func_name, mangled)
    func_name = mangled
    catch (err: KeyNotFoundError) { }

    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    func_def_opt := get_fcall_func_def(context, fcall)
    func_has_return := func_def_opt.return_types.len().gt(0)
    mut needs_ret := false
    if func_has_return {
        if decl_name.len().gt(0) {
            needs_ret = true
        }
        if assign_name.len().gt(0) {
            needs_ret = true
        }
    }
    catch (err: KeyNotFoundError) { }

    // Calculate param_types and param_by_ref
    mut param_types := Vec.new(ValueType)
    mut param_by_ref := Vec.new(Bool)
    fd := get_fcall_func_def(context, fcall)
    for i in 0..fcall.params.len().sub(1) {
        mut decl := Declaration()
        fd.args.get(i, decl)
        param_types.push(decl.value_type)
        param_by_ref.push(param_needs_by_ref(decl))
        catch (err: IndexOutOfBoundsError) {
            // No param type - push sentinel value (callers ignore param_type when arg is out of bounds)
            param_types.push(ValueType.TCustom(""))
            param_by_ref.push(false)
        }
    }
    catch (err: KeyNotFoundError) { }

    // Hoist any throwing function calls in arguments
    mut hoisted := Map.new(I64, Str)
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
        for h_idx in 0..hoisted_vec.len() {
            mut h := HoistedArg()
            hoisted_vec.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist non-lvalue args when param type is Dynamic
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        dynamic_hoisted := hoist_for_dynamic_params(args, param_types, hoisted, output, indent, ctx, context)
        for h_idx in 0..dynamic_hoisted.len() {
            mut h := HoistedArg()
            dynamic_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Hoist struct-returning FCall args when param is by-ref
    if fcall.params.len().gt(1) {
        mut args := Vec.new(Expr)
        for i in 1..fcall.params.len() {
            mut arg := Expr()
            fcall.params.get(i, arg)
            args.push(arg)
        }
        ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted, output, indent, ctx, context)
        for h_idx in 0..ref_hoisted.len() {
            mut h := HoistedArg()
            ref_hoisted.get(h_idx, h)
            hoisted.set(h.index, h.temp_var)
        }
    }

    // Look up the actual return type
    mut ret_type := "int"
    if needs_ret {
        fd2 := get_fcall_func_def(context, fcall)
        mut first_ret := ValueType.TCustom("")
        fd2.return_types.get(0, first_ret)
        ret_type = til_type_to_c(first_ret)
        catch (err: Str) { ret_type = "int" }
        catch (err: IndexOutOfBoundsError) { ret_type = "int" }
        catch (err: KeyNotFoundError) { ret_type = "int" }
    }

    // Declare temp for return value if needed
    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            output.push_str(indent_str)
            output.push_str(ret_type)
            output.push_str(" ")
            output.push_str(til_name(var_name))
            output.push_str(";\n")
            _ := ctx.declared_vars.insert(til_name(var_name))
            fd3 := get_fcall_func_def(context, fcall)
            mut first_type := ValueType.TCustom("")
            fd3.return_types.get(0, first_type)
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(var_name, sym_info)
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(idx, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(idx.to_str())
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Check for variadic function call
    variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""  // Empty string means None
    mut variadic_args := Vec.new(Expr)
    start_idx := add(1, variadic_info.regular_count)
    for i in start_idx..fcall.params.len() {
        mut arg := Expr()
        fcall.params.get(i, arg)
        variadic_args.push(arg)
    }
    variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, output, indent, ctx, context)
    catch (err: KeyNotFoundError) { }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers
    for idx in 0..throw_types.len() {
        if needs_ret {
            output.push_str(", ")
        } else {
            if idx.gt(0) {
                output.push_str(", ")
            }
        }
        output.push_str("&_err")
        output.push_str(idx.to_str())
        output.push_str("_")
        output.push_str(temp_suffix)
    }

    // Emit arguments
    mut args_started := false
    regular_arg_count := variadic_info.regular_count
    for arg_idx in 0..fcall.params.len().sub(1) {
        if arg_idx.gteq(regular_arg_count) {
            break
        }
        if needs_ret {
            output.push_str(", ")
        } else {
            if throw_types.len().gt(0) {
                output.push_str(", ")
            } else {
                if args_started {
                    output.push_str(", ")
                }
            }
        }
        mut arg := Expr()
        fcall.params.get(arg_idx.add(1), arg)
        mut pt := ValueType.TCustom("")
        mut pt_ptr := Ptr()
        param_types.get(arg_idx, pt)
        pt_ptr.data = to_ptr(pt)
        catch (err: IndexOutOfBoundsError) { }
        mut by_ref := false
        param_by_ref.get(arg_idx, by_ref)
        catch (err: IndexOutOfBoundsError) { }
        emit_arg_with_param_type(arg, arg_idx, hoisted, pt_ptr, by_ref, output, ctx, context)
        args_started = true
    }

    // Add variadic array if present
    if variadic_arr_var.len().gt(0) {
        if needs_ret {
            output.push_str(", ")
        } else {
            if throw_types.len().gt(0) {
                output.push_str(", ")
            } else {
                if args_started {
                    output.push_str(", ")
                }
            }
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    }

    output.push_str(");\n")

    // Use simple status checks with goto
    for err_idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(err_idx, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            // Check if there's a local catch for this error type
            mut catch_info := CatchLabelInfo()
            ctx.local_catch_labels.get(type_name, catch_info)
            // Jump to local catch
            output.push_str(indent_str)
            output.push_str("if (_status_")
            output.push_str(temp_suffix)
            output.push_str(" == ")
            output.push_str(err_idx.add(1).to_str())
            output.push_str(") { ")
            output.push_str(catch_info.temp_var)
            output.push_str(" = _err")
            output.push_str(err_idx.to_str())
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str("; goto ")
            output.push_str(catch_info.label)
            output.push_str("; }\n")
            catch (err: KeyNotFoundError) {
                // Check if this error type is in current_throw_types (propagate to caller)
                mut prop_idx := sub(0, 1)
                for i in 0..ctx.current_throw_types.len() {
                    mut t := ValueType.TCustom("")
                    ctx.current_throw_types.get(i, t)
                    switch t {
                    case ValueType.TCustom(n):
                        if n.eq(type_name) {
                            prop_idx = i
                            break
                        }
                    case:
                    }
                }
                if prop_idx.gteq(0) {
                    pidx := prop_idx
                    output.push_str(indent_str)
                    output.push_str("if (_status_")
                    output.push_str(temp_suffix)
                    output.push_str(" == ")
                    output.push_str(err_idx.add(1).to_str())
                    output.push_str(") { *_err")
                    output.push_str(pidx.add(1).to_str())
                    output.push_str(" = _err")
                    output.push_str(err_idx.to_str())
                    output.push_str("_")
                    output.push_str(temp_suffix)
                    output.push_str("; return ")
                    output.push_str(pidx.add(1).to_str())
                    output.push_str("; }\n")
                }
            }
        case:
        }
    }

    // Success case: assign return value
    if decl_name.len().gt(0) {
        var_name := decl_name
        if not(var_name.eq("_")) {
            output.push_str(indent_str)
            output.push_str(til_name(var_name))
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    } else {
        if assign_name.len().gt(0) {
            var_name := assign_name
            output.push_str(indent_str)
            dot_pos := var_name.find(".")
            if dot_pos.gteq(0) {
                base := var_name.get_substr(0, dot_pos)
                rest := var_name.get_substr(dot_pos.add(1), var_name.len())
                if ctx.current_ref_params.contains(base) {
                    output.push_str(til_name(base))
                    output.push_str("->")
                    output.push_str(rest)
                } else {
                    output.push_str(til_name(var_name))
                }
            } else {
                if ctx.current_ref_params.contains(var_name) {
                    output.push_str("*")
                    output.push_str(til_name(var_name))
                } else {
                    output.push_str(til_name(var_name))
                }
            }
            output.push_str(" = _ret_")
            output.push_str(temp_suffix)
            output.push_str(";\n")
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

/// Emit an FCall expression using pre-hoisted temp vars for arguments
emit_fcall_with_hoisted := proc(
    expr: Expr,
    hoisted: Map,
    mut output: Str,
    mut ctx: CodegenContext,
    mut context: Context
) throws Str {
    if expr.params.is_empty() {
        throw "emit_fcall_with_hoisted: FCall with no params"
    }

    // Get function name
    mut first_param := Expr()
    expr.params.get(0, first_param)
    func_name := get_func_name_string(first_param)
    catch (err: KeyNotFoundError) {
        throw "emit_fcall_with_hoisted: FCall first param not Identifier"
    }

    // Check for struct construction: TypeName() or TypeName(x=10, y=20)
    // Use lookup_struct to verify this is a known struct type
    mut has_named_args := false
    for i in 1..expr.params.len() {
        mut arg := Expr()
        expr.params.get(i, arg)
        switch arg.node_type {
        case NodeType.NamedArg(_):
            has_named_args = true
            break
        case:
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    mut struct_def := SStructDef()
    mut has_struct := false
    struct_def = context.scope_stack.lookup_struct(func_name)
    has_struct = true
    catch (err: KeyNotFoundError) {
        // REM: Not a struct, that's ok
    }

    if has_struct.and(expr.params.len().eq(1).or(has_named_args)) {
        output.push_str("(")
        output.push_str(TIL_PREFIX)
        output.push_str(func_name)
        output.push_str(")")

        if struct_def.members.is_empty().or(struct_def.default_values.keys.is_empty()) {
            output.push_str("{}")
        } else {
            // Build map of named arg values
            mut named_values := Map.new(Str, Expr)
            for i in 1..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                switch arg.node_type {
                case NodeType.NamedArg(field_name):
                    if arg.params.len().gt(0) {
                        mut value_expr := Expr()
                        arg.params.get(0, value_expr)
                        named_values.set(field_name, value_expr)
                    }
                case:
                }
            }

            // Check if any default value is a throwing function call
            // Such calls need out-params and can't be inlined in struct initializers
            mut throwing_defaults := Vec.new(ThrowingDefault)
            for m_idx in 0..struct_def.members.len() {
                mut member := Declaration()
                struct_def.members.get(m_idx, member)
                if not(member.is_mut) {
                    continue
                }
                if named_values.contains_key(member.name) {
                    continue  // Named arg overrides default
                }
                if struct_def.default_values.contains_key(member.name) {
                    mut default_expr := Expr()
                    struct_def.default_values.get(member.name, default_expr)
                    if is_throwing_fcall(default_expr, context) {
                        mut td := ThrowingDefault()
                        td.member_name = member.name
                        td.default_expr = default_expr
                        throwing_defaults.push(td)
                    }
                }
            }

            // If we have throwing defaults, emit them as separate statements first
            for td: ThrowingDefault in throwing_defaults {
                // Get the function's throw types
                mut throw_types := Vec.new(ValueType)
                if td.default_expr.params.len().gt(0) {
                    mut first_p := Expr()
                    td.default_expr.params.get(0, first_p)
                    lookup_name := get_til_func_name_string(first_p)
                    fd := context.scope_stack.lookup_func(lookup_name)
                    throw_types = fd.throw_types
                    catch (err: KeyNotFoundError) {
                        // REM: Either function not found or til_func_name not found - use empty throw_types
                    }
                }

                temp_name := format("_default_", td.member_name, "_", next_mangled(ctx))
                // Emit the function call with out-param
                emit_throwing_call_propagate(td.default_expr, throw_types, temp_name, "", output, 0, ctx, context)
                // Record that this struct default was hoisted
                key := format(func_name, ":", td.member_name)
                ctx.hoisted_struct_defaults.set(key, temp_name)
            }

            // Build set of throwing default member names for quick lookup
            mut throwing_default_names := Set.new(Str)
            for td: ThrowingDefault in throwing_defaults {
                _ := throwing_default_names.insert(td.member_name)
            }

            output.push_str("{")
            mut first := true
            for m_idx in 0..struct_def.members.len() {
                mut member := Declaration()
                struct_def.members.get(m_idx, member)
                if not(member.is_mut) {
                    continue
                }
                if not(first) {
                    output.push_str(", ")
                }
                first = false
                output.push_str(".")
                output.push_str(member.name)
                output.push_str(" = ")
                // Use named arg value if provided, otherwise use default
                if named_values.contains_key(member.name) {
                    mut value_expr := Expr()
                    named_values.get(member.name, value_expr)
                    emit_expr(value_expr, output, 0, ctx, context)
                } else if struct_def.default_values.contains_key(member.name) {
                    mut default_expr := Expr()
                    struct_def.default_values.get(member.name, default_expr)
                    // Check if this was a throwing default - use temp var instead
                    key := format(func_name, ":", member.name)
                    if ctx.hoisted_struct_defaults.contains_key(key) {
                        mut temp_name := ""
                        ctx.hoisted_struct_defaults.get(key, temp_name)
                        output.push_str(temp_name)
                    } else if throwing_default_names.contains(member.name).or(is_throwing_fcall(default_expr, context)) {
                        // Shouldn't happen - throwing defaults should be hoisted
                        output.push_str("/* ERROR: unhoisted throwing default */")
                    } else {
                        emit_expr(default_expr, output, 0, ctx, context)
                    }
                } else {
                    output.push_str("0")
                }
            }
            output.push_str("}")
        }
        return
    }

    // Function call
    output.push_str(TIL_PREFIX)
    output.push_str(func_name)
    output.push_str("(")

    // Look up param types for by-ref handling
    mut param_info := Vec.new(ParamTypeInfo)
    fd := get_fcall_func_def(context, expr)
    for i in 0..fd.args.len() {
        mut a := Declaration()
        fd.args.get(i, a)
        mut info := ParamTypeInfo()
        info.value_type = Ptr.new(ValueType)
        memcpy(info.value_type.data, to_ptr(a.value_type), size_of(ValueType))
        info.by_ref = param_needs_by_ref(a)
        param_info.push(info)
    }
    catch (err: KeyNotFoundError) { }

    for i in 0..expr.params.len().sub(1) {
        if i.gt(0) {
            output.push_str(", ")
        }
        mut arg := Expr()
        expr.params.get(i.add(1), arg)
        // Check if arg is a type identifier
        type_name := get_type_arg_name(arg, context)
        output.push_str("\"")
        output.push_str(type_name)
        output.push_str("\"")
        catch (err: KeyNotFoundError) {
            if param_info.len().gt(0) {
                mut info := ParamTypeInfo()
                param_info.get(i, info)
                emit_arg_with_param_type(arg, i, hoisted, info.value_type, info.by_ref, output, ctx, context)
                catch (err: IndexOutOfBoundsError) {
                    emit_arg_or_hoisted(arg, i, hoisted, output, ctx, context)
                }
            } else {
                emit_arg_or_hoisted(arg, i, hoisted, output, ctx, context)
            }
        }
    }
    output.push_str(")")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
}

emit_fcall := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    if expr.params.is_empty() {
        throw "ccodegen: FCall with no params"
    }

    // Get function name
    mut first_param := Expr()
    expr.params.get(0, first_param)
    mut func_name := get_func_name_string(first_param)
    catch (err: KeyNotFoundError) {
        throw "ccodegen: FCall first param not Identifier"
    }

    // For builtins, we need the original name with dots
    mut orig_func_name := get_til_func_name_string(first_param)
    catch (err: KeyNotFoundError) {
        orig_func_name = func_name
    }

    // Check if this is a call to a nested (hoisted) function
    if ctx.nested_func_names.contains_key(orig_func_name) {
        mut mangled := ""
        ctx.nested_func_names.get(orig_func_name, mangled)
        func_name = mangled
        catch (err: KeyNotFoundError) { }
    }

    // Check for struct literal with named args
    mut has_named_args := false
    for i in 1..expr.params.len() {
        mut arg := Expr()
        expr.params.get(i, arg)
        switch arg.node_type {
        case NodeType.NamedArg(_):
            has_named_args = true
            break
        case:
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    if has_named_args {
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(func_name)
        catch (err: KeyNotFoundError) {
            // REM: Not a struct, continue to regular function call below
        }

        output.push_str("(")
        output.push_str(TIL_PREFIX)
        output.push_str(func_name)
        output.push_str(")")

        // Build map of named arg values
        mut named_values := Map.new(Str, Expr)
        for i in 1..expr.params.len() {
            mut arg := Expr()
            expr.params.get(i, arg)
            switch arg.node_type {
            case NodeType.NamedArg(field_name):
                if arg.params.len().gt(0) {
                    mut value_expr := Expr()
                    arg.params.get(0, value_expr)
                    named_values.set(field_name, value_expr)
                }
            case:
            }
        }

        if struct_def.members.is_empty().or(struct_def.default_values.keys.is_empty()) {
            output.push_str("{}")
        } else {
            output.push_str("{")
            mut first := true
            for m_idx in 0..struct_def.members.len() {
                mut member := Declaration()
                struct_def.members.get(m_idx, member)
                if not(member.is_mut) {
                    continue
                }
                if not(first) {
                    output.push_str(", ")
                }
                first = false
                output.push_str(".")
                output.push_str(member.name)
                output.push_str(" = ")
                // Use named arg value if provided, otherwise use default
                if named_values.contains_key(member.name) {
                    mut value_expr := Expr()
                    named_values.get(member.name, value_expr)
                    catch (err: KeyNotFoundError) { }
                    emit_expr(value_expr, output, 0, ctx, context)
                } else if struct_def.default_values.contains_key(member.name) {
                    mut default_expr := Expr()
                    struct_def.default_values.get(member.name, default_expr)
                    catch (err: KeyNotFoundError) { }
                    // Check if this was a throwing default - use temp var instead
                    key := format(func_name, ":", member.name)
                    if ctx.hoisted_struct_defaults.contains_key(key) {
                        mut temp_name := ""
                        ctx.hoisted_struct_defaults.get(key, temp_name)
                        catch (err: KeyNotFoundError) { }
                        output.push_str(temp_name)
                    } else if is_throwing_fcall(default_expr, context) {
                        // Shouldn't happen - throwing defaults should be hoisted
                        output.push_str("/* ERROR: unhoisted throwing default */")
                    } else {
                        emit_expr(default_expr, output, 0, ctx, context)
                    }
                } else {
                    output.push_str("0")
                }
            }
            output.push_str("}")
        }
        return
    }

    mut indent_str := ""
    for _ in 0..indent {
        indent_str.push_str("    ")
    }

    // Statement level vs expression level
    is_stmt_level := indent.gt(0)

    // Hoist throwing function calls from arguments (only at statement level)
    mut hoisted := Map.new(I64, Str)
    if is_stmt_level {
        if expr.params.len().gt(1) {
            mut args := Vec.new(Expr)
            for i in 1..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                args.push(arg)
            }
            hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
            for h_idx in 0..hoisted_vec.len() {
                mut h := HoistedArg()
                hoisted_vec.get(h_idx, h)
                hoisted.set(h.index, h.temp_var)
            }
        }
    }

    // Hoist non-lvalue args when param type is Dynamic (only at statement level)
    if is_stmt_level {
        if expr.params.len().gt(1) {
            fd := get_fcall_func_def(context, expr)
            mut param_types := Vec.new(ValueType)
            mut param_by_ref := Vec.new(Bool)
            for i in 0..fd.args.len() {
                mut a := Declaration()
                fd.args.get(i, a)
                param_types.push(a.value_type)
                param_by_ref.push(param_needs_by_ref(a))
            }
            mut args := Vec.new(Expr)
            for i in 1..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                args.push(arg)
            }
            dynamic_hoisted := hoist_for_dynamic_params(args, param_types, hoisted, output, indent, ctx, context)
            for h_idx in 0..dynamic_hoisted.len() {
                mut h := HoistedArg()
                dynamic_hoisted.get(h_idx, h)
                hoisted.set(h.index, h.temp_var)
            }
            // Hoist struct-returning FCall args when param is by-ref
            ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted, output, indent, ctx, context)
            for h_idx in 0..ref_hoisted.len() {
                mut h := HoistedArg()
                ref_hoisted.get(h_idx, h)
                hoisted.set(h.index, h.temp_var)
            }
            catch (err: KeyNotFoundError) { }
        }
    }

    // Hardcoded builtins
    if orig_func_name.eq("type_as_str") {
        if expr.params.len().lt(2) {
            throw "ccodegen: type_as_str requires 1 argument"
        }
        mut param1 := Expr()
        expr.params.get(1, param1)
        switch param1.node_type {
        case NodeType.Identifier(type_name):
            sym := context.scope_stack.lookup_symbol(type_name)
            switch sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    output.push_str("((")
                    output.push_str(TIL_PREFIX)
                    output.push_str("Str){(")
                    output.push_str(TIL_PREFIX)
                    output.push_str("I64)")
                    output.push_str(TIL_PREFIX)
                    output.push_str(type_name)
                    output.push_str(", strlen(")
                    output.push_str(TIL_PREFIX)
                    output.push_str(type_name)
                    output.push_str(")})")
                    return
                }
            case:
            }
            catch (err: KeyNotFoundError) { }
            emit_str_literal(type_name, output)
            return
        case:
        }
        emit_str_literal("unknown", output)
        return
    }

    if orig_func_name.eq("enum_to_str") {
        if expr.params.len().lt(2) {
            throw "ccodegen: enum_to_str requires 1 argument"
        }
        mut arg := Expr()
        expr.params.get(1, arg)
        value_type := get_value_type(context, arg)
        switch value_type {
        case ValueType.TCustom(enum_type_name):
            _ := context.scope_stack.lookup_enum(enum_type_name)
            output.push_str(til_name(enum_type_name))
            output.push_str("_to_str(")
            arg_addr := to_ptr(arg)
            if ctx.hoisted_exprs.contains_key(arg_addr) {
                emit_expr(arg, output, 0, ctx, context)
            } else {
                output.push_str("&")
                emit_expr(arg, output, 0, ctx, context)
            }
            output.push_str(")")
            catch (err: KeyNotFoundError) {
                throw format("ccodegen: enum_to_str argument '", enum_type_name, "' is not an enum type")
            }
            return
        case:
            throw format("ccodegen: enum_to_str argument has non-custom type")
        }
    }

    if orig_func_name.eq("size_of") {
        if expr.params.len().lt(2) {
            throw "ccodegen: size_of requires 1 argument"
        }
        output.push_str(TIL_PREFIX)
        output.push_str("size_of(&")
        mut param1 := Expr()
        expr.params.get(1, param1)
        switch param1.node_type {
        case NodeType.Identifier(type_name):
            sym := context.scope_stack.lookup_symbol(type_name)
            switch sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    output.push_str("((")
                    output.push_str(TIL_PREFIX)
                    output.push_str("Str){(")
                    output.push_str(TIL_PREFIX)
                    output.push_str("I64)")
                    output.push_str(TIL_PREFIX)
                    output.push_str(type_name)
                    output.push_str(", strlen(")
                    output.push_str(TIL_PREFIX)
                    output.push_str(type_name)
                    output.push_str(")})")
                    output.push_str(")")
                    return
                }
            case:
            }
            catch (err: KeyNotFoundError) { }
            emit_str_literal(type_name, output)
        case:
            output.push_str("((")
            output.push_str(TIL_PREFIX)
            output.push_str("Str){(")
            output.push_str(TIL_PREFIX)
            output.push_str("I64)")
            emit_expr(param1, output, 0, ctx, context)
            output.push_str(", strlen(")
            emit_expr(param1, output, 0, ctx, context)
            output.push_str(")})")
        }
        output.push_str(")")
        return
    }

    // to_ptr(var) - get address of variable
    // For Dynamic params (already void*), just cast without taking address
    if orig_func_name.eq("to_ptr") {
        if expr.params.len().lt(2) {
            throw "ccodegen: to_ptr requires 1 argument"
        }
        mut arg := Expr()
        expr.params.get(1, arg)
        // Check if arg is a Dynamic parameter (void*) - just use the pointer directly
        // Both mut Dynamic (void**) and non-mut Dynamic (void*) don't need &
        mut is_dynamic_param := false
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.len().eq(0) {
                sym := context.scope_stack.lookup_symbol(name)
                switch sym.value_type {
                case ValueType.TCustom(t):
                    if t.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
                catch (err: KeyNotFoundError) { }
            }
        case:
        }
        output.push_str("(")
        output.push_str(TIL_PREFIX)
        output.push_str("I64)")
        if is_dynamic_param {
            // Dynamic param: just output the variable name (it's already a pointer)
            switch arg.node_type {
            case NodeType.Identifier(name):
                output.push_str(til_name(name))
            case:
            }
        } else {
            // Check if arg was hoisted with & prefix already
            arg_addr := to_ptr(arg)
            if ctx.hoisted_exprs.contains_key(arg_addr) {
                mut temp_var := ""
                ctx.hoisted_exprs.get(arg_addr, temp_var)
                catch (err: KeyNotFoundError) { }
                if temp_var.starts_with("&") {
                    // Already has & prefix, just emit it
                    output.push_str(temp_var)
                } else {
                    output.push_str("&")
                    output.push_str(temp_var)
                }
            } else {
                output.push_str("&")
                emit_arg_or_hoisted(arg, 0, hoisted, output, ctx, context)
            }
        }
        return
    }

    // Regular function call
    // func_name already has underscores from get_func_name_string
    // Detect and construct variadic array if needed (only at statement level)
    // At expression level, variadic calls are not supported directly
    mut variadic_arr_var := ""
    if is_stmt_level {
        if ctx.func_variadic_args.contains_key(orig_func_name) {
            mut variadic_info := VariadicParamInfo()
            ctx.func_variadic_args.get(orig_func_name, variadic_info)
            elem_type := variadic_info.elem_type
            regular_count := variadic_info.regular_count
            mut variadic_args := Vec.new(Expr)
            for i in regular_count.add(1)..expr.params.len() {
                mut arg := Expr()
                expr.params.get(i, arg)
                variadic_args.push(arg)
            }
            variadic_arr_var = hoist_variadic_args(elem_type, variadic_args, hoisted, regular_count, output, indent, ctx, context)
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    output.push_str(TIL_PREFIX)
    output.push_str(func_name)
    output.push_str("(")

    // Check if this is a variadic function call
    if ctx.func_variadic_args.contains_key(orig_func_name) {
        mut variadic_info := VariadicParamInfo()
        ctx.func_variadic_args.get(orig_func_name, variadic_info)
        regular_count := variadic_info.regular_count
        // Bug #60: Look up function param info for proper by-ref handling of regular args
        mut param_info := Vec.new(ParamTypeInfo)
        fd := get_fcall_func_def(context, expr)
        for i in 0..fd.args.len() {
            mut a := Declaration()
            fd.args.get(i, a)
            mut info := ParamTypeInfo()
            info.value_type = Ptr.new(ValueType)
            memcpy(info.value_type.data, to_ptr(a.value_type), size_of(ValueType))
            info.by_ref = param_needs_by_ref(a)
            param_info.push(info)
        }
        catch (err: KeyNotFoundError) {
            // Fallback: lookup via scope_stack directly
            fd2 := context.scope_stack.lookup_func(orig_func_name)
            for i in 0..fd2.args.len() {
                mut a := Declaration()
                fd2.args.get(i, a)
                mut info := ParamTypeInfo()
                info.value_type = Ptr.new(ValueType)
                memcpy(info.value_type.data, to_ptr(a.value_type), size_of(ValueType))
                info.by_ref = param_needs_by_ref(a)
                param_info.push(info)
            }
            catch (err: KeyNotFoundError) { }
        }
        // Emit regular args first (skip first param which is function name)
        for i in 0..regular_count {
            if i.gt(0) {
                output.push_str(", ")
            }
            mut arg := Expr()
            expr.params.get(i.add(1), arg)
            // Bug #60: If we couldn't find param info, default to by_ref=true
            mut pt_ptr := Ptr()
            mut by_ref := true
            mut info := ParamTypeInfo()
            param_info.get(i, info)
            pt_ptr = info.value_type
            by_ref = info.by_ref
            catch (err: IndexOutOfBoundsError) { }
            emit_arg_with_param_type(arg, i, hoisted, pt_ptr, by_ref, output, ctx, context)
        }
        // Emit variadic array pointer
        if variadic_arr_var.len().gt(0) {
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)
        }
    } else {
        // Regular non-variadic function call
        // Look up function to get parameter info (by_ref flags)
        mut param_info := Vec.new(ParamTypeInfo)
        fd := get_fcall_func_def(context, expr)
        for i in 0..fd.args.len() {
            mut a := Declaration()
            fd.args.get(i, a)
            mut info := ParamTypeInfo()
            info.value_type = Ptr.new(ValueType)
            memcpy(info.value_type.data, to_ptr(a.value_type), size_of(ValueType))
            info.by_ref = param_needs_by_ref(a)
            param_info.push(info)
        }
        catch (err: KeyNotFoundError) { }

        mut first_arg := true
        for i in 0..expr.params.len().sub(1) {
            if not(first_arg) {
                output.push_str(", ")
            }
            first_arg = false
            mut arg := Expr()
            expr.params.get(i.add(1), arg)
            // Check if arg is a type identifier - emit as string literal
            type_name := get_type_arg_name(arg, context)
            output.push_str("\"")
            output.push_str(type_name)
            output.push_str("\"")
            catch (err: KeyNotFoundError) {
                if param_info.len().gt(0) {
                    mut info := ParamTypeInfo()
                    param_info.get(i, info)
                    emit_arg_with_param_type(arg, i, hoisted, info.value_type, info.by_ref, output, ctx, context)
                    catch (err: IndexOutOfBoundsError) {
                        emit_arg_or_hoisted(arg, i, hoisted, output, ctx, context)
                    }
                } else {
                    emit_arg_or_hoisted(arg, i, hoisted, output, ctx, context)
                }
            }
        }
    }
    output.push_str(")")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
}

emit_body := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Bug #44 fix: Save and restore local_catch_labels around nested blocks
    // Without this, nested blocks clear the outer catches when processing their
    // own throwing calls, causing missing status checks for outer throwing calls.
    mut saved_catch_labels := ctx.local_catch_labels.clone()
    catch (err: AllocError) { throw "AllocError in emit_body" }
    emit_stmts(expr.params, output, indent, ctx, context)
    ctx.local_catch_labels = saved_catch_labels
}

prescan_func_level_catches := proc(stmts: Vec) returns Vec throws AllocError {
    mut catches := Vec.new(Expr)

    // Collect ALL catch blocks - we'll register them all for local throw handling
    // The emit_throwing_call handles immediate catch chains for function calls,
    // but we need labels for throw statements that jump to these catches
    for stmt: Expr in stmts {
        switch stmt.node_type {
        case NodeType.Catch:
            catches.push(stmt)
        case:
        }
    }

    return catches
}
emit_throw := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Throw: params[0] = the value to throw (typically a struct constructor like DivideByZero())
    if expr.params.is_empty() {
        throw "ccodegen: throw requires a value"
    }

    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }
    mut thrown_expr := Expr()
    expr.params.get(0, thrown_expr)

    // Check if the thrown expression itself is a throwing function call (e.g., throw format(...))
    // If so, we need to hoist it first to ensure proper error handling
    thrown_expr_addr := to_ptr(thrown_expr)
    _ := hoist_throwing_expr(thrown_expr, output, indent, ctx, context)
    // Check if thrown_expr was hoisted (its address is now in hoisted_exprs)
    if ctx.hoisted_exprs.contains_key(thrown_expr_addr) {
        // The thrown expression was hoisted to a temp variable
        // Now we just need to throw the temp variable value
        mut hoisted_temp := ""
        ctx.hoisted_exprs.get(thrown_expr_addr, hoisted_temp)
        catch (err: KeyNotFoundError) { throw "emit_throw: hoisted key not found" }

        // Get the type of the hoisted value
        mut thrown_type_name := ""
        mut lookup_fd := get_fcall_func_def(context, thrown_expr)
        catch (err: KeyNotFoundError) {
            throw thrown_expr.lang_error(context.path, "ccodegen", "could not find throwing function definition")
        }
        if lookup_fd.return_types.len().gt(0) {
            mut ret_type := ValueType.TCustom("")
            lookup_fd.return_types.get(0, ret_type)
            switch ret_type {
            case ValueType.TCustom(type_name):
                thrown_type_name = type_name
            case:
                thrown_type_name = value_type_to_str(ret_type)
            }
            catch (err: IndexOutOfBoundsError) { throw "emit_throw: index error getting return type" }
        } else {
            throw "ccodegen: throwing function has no return type"
        }

        // Check if this type is locally caught
        mut has_local_catch := false
        mut info := CatchLabelInfo()
        ctx.local_catch_labels.get(thrown_type_name, info)
        has_local_catch = true
        catch (err: KeyNotFoundError) { }

        if has_local_catch {
            output = output.concat(indent_str).concat(info.temp_var).concat(" = ").concat(hoisted_temp).concat(";\n")
            output = output.concat(indent_str).concat("goto ").concat(info.label).concat(";\n")
            return
        }

        // Find the index of this type in current_throw_types
        mut error_index := sub(0, 1)  // -1 = not found
        mut i := 0
        while i.lt(ctx.current_throw_types.len()) {
            mut vt := ValueType.TCustom("")
            ctx.current_throw_types.get(i, vt)
            switch vt {
            case ValueType.TCustom(name):
                if name.eq(thrown_type_name) {
                    error_index = i
                }
            case:
            }
            i = i.add(1)
        }
        catch (err: IndexOutOfBoundsError) { throw "emit_throw: index error in throw types" }

        if error_index.lt(0) {
            throw format("ccodegen: thrown type '", thrown_type_name, "' not found in function's throw types")
        }

        output = output.concat(indent_str).concat("*_err").concat(error_index.add(1).to_str()).concat(" = ").concat(hoisted_temp).concat(";\n")
        output = output.concat(indent_str).concat("return ").concat(error_index.add(1).to_str()).concat(";\n")
        return
    }

    // Get the thrown type name from the expression
    // For FCall, we need to determine if it's:
    // 1. A constructor like DivideByZero() - use the type name
    // 2. A function that returns an error type like format() - use the return type
    mut thrown_type_name := ""

    switch thrown_expr.node_type {
    case NodeType.FCall:
        if thrown_expr.params.len().gt(0) {
            mut first_param := Expr()
            thrown_expr.params.get(0, first_param)
            switch first_param.node_type {
            case NodeType.Identifier(name):
                // Check if this is a constructor (struct/enum) or a function call
                // If it's a function that returns a type, use the return type
                mut got_lookup := false
                mut lookup_fd := SFuncDef()
                lookup_fd = get_fcall_func_def(context, thrown_expr)
                got_lookup = true
                catch (err: KeyNotFoundError) { /* REM None case in Rust */ }
                if got_lookup {
                    // It's a function - use its return type as the thrown type
                    if lookup_fd.return_types.len().gt(0) {
                        mut ret_type := ValueType.TFunction(FunctionType.FTFunc)
                        lookup_fd.return_types.get(0, ret_type)
                        switch ret_type {
                        case ValueType.TCustom(type_name):
                            thrown_type_name = type_name
                        case:
                            thrown_type_name = value_type_to_str(ret_type)
                        }
                    } else {
                        // No return type, assume it's a constructor
                        thrown_type_name = name
                    }
                } else {
                    // Not a function, assume it's a constructor
                    thrown_type_name = name
                }
            case:
                throw "ccodegen: throw FCall must have identifier as first param"
            }
        } else {
            throw "ccodegen: throw FCall has no params"
        }
    case NodeType.Identifier(name):
        // Look up the type of the identifier (could be a variable or type name)
        mut value_type := get_value_type(context, thrown_expr)
        switch value_type {
        case ValueType.TCustom(type_name):
            thrown_type_name = type_name
        case:
            thrown_type_name = value_type_to_str(value_type)
        }
        catch (err: Str) {
            // Fallback: assume identifier is a type name (for struct constructors without args)
            thrown_type_name = name
        }
    case NodeType.LLiteral(lit):
        // Literal values - determine their type
        switch lit {
        case Literal.Str(s):
            thrown_type_name = "Str"
        case Literal.Number(n):
            thrown_type_name = "I64"
        case Literal.List(l):
            throw "ccodegen: cannot throw a list literal"
        }
    case:
        throw "ccodegen: throw expression must be a constructor, function call, identifier, or literal"
    }

    // Check if this type is locally caught (has a catch block at function level)
    mut has_local_catch := false
    mut label := ""
    mut temp_var := ""
    mut info := CatchLabelInfo()
    ctx.local_catch_labels.get(thrown_type_name, info)
    has_local_catch = true
    label = info.label
    temp_var = info.temp_var
    catch (err: KeyNotFoundError) { }

    if has_local_catch {
        // Hoist any throwing function calls in the thrown expression
        mut hoisted := Map.new(I64, Str)
        switch thrown_expr.node_type {
        case NodeType.FCall:
            if thrown_expr.params.len().gt(1) {
                // Create args Vec with elements starting from index 1 (skip function name)
                mut args := Vec.new(Expr)
                mut ai := 1
                while ai.lt(thrown_expr.params.len()) {
                    mut arg := Expr()
                    thrown_expr.params.get(ai, arg)
                    args.push(arg)
                    ai = ai.add(1)
                }
                mut hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
                for h: HoistedArg in hoisted_vec {
                    hoisted.set(h.index, h.temp_var)
                    catch (err: AllocError) { throw err.msg }
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }
        case:
        }

        // Store the error value in temp variable
        output = output.concat(indent_str)
        output = output.concat(temp_var)
        output = output.concat(" = ")

        // Emit the thrown expression
        switch thrown_expr.node_type {
        case NodeType.FCall:
            emit_fcall_with_hoisted(thrown_expr, hoisted, output, ctx, context)
        case:
            emit_expr(thrown_expr, output, 0, ctx, context)
        }
        output = output.concat(";\n")

        // Jump to the catch block
        output = output.concat(indent_str)
        output = output.concat("goto ")
        output = output.concat(label)
        output = output.concat(";\n")

        return
    }

    // Find the index of this type in current_throw_types
    // Note: Str is represented as TCustom("Str") in the type system
    mut error_index := sub(0, 1)  // -1 = not found
    mut i := 0
    while i.lt(ctx.current_throw_types.len()) {
        mut vt := ValueType.TFunction(FunctionType.FTFunc)
        ctx.current_throw_types.get(i, vt)
        switch vt {
        case ValueType.TCustom(name):
            if name.eq(thrown_type_name) {
                error_index = i
            }
        case:
        }
        i = i.add(1)
    }

    if error_index.lt(0) {
        throw format("ccodegen: thrown type '", thrown_type_name, "' not found in function's throw types")
    }

    // Hoist throwing function calls from arguments of the thrown expression
    // E.g., throw Error.new(format(...)) needs to hoist format() first
    mut hoisted := Map.new(I64, Str)
    switch thrown_expr.node_type {
    case NodeType.FCall:
        if thrown_expr.params.len().gt(1) {
            // Create args Vec with elements starting from index 1 (skip function name)
            mut args := Vec.new(Expr)
            mut ai := 1
            while ai.lt(thrown_expr.params.len()) {
                mut arg := Expr()
                thrown_expr.params.get(ai, arg)
                args.push(arg)
                ai = ai.add(1)
            }
            mut hoisted_vec := hoist_throwing_args(args, output, indent, ctx, context)
            for h: HoistedArg in hoisted_vec {
                hoisted.set(h.index, h.temp_var)
                catch (err: AllocError) { throw err.msg }
            }
        }
    case:
    }

    // Store the error value in the appropriate error pointer
    // Note: error params are 1-based (_err1, _err2, etc.)
    output = format(output, indent_str, "*_err", error_index.add(1).to_str(), " = ")

    // Emit the thrown expression, using hoisted temp vars for arguments
    switch thrown_expr.node_type {
    case NodeType.FCall:
        emit_fcall_with_hoisted(thrown_expr, hoisted, output, ctx, context)
    case:
        emit_expr(thrown_expr, output, 0, ctx, context)
    }
    output = output.concat(";\n")

    // Return the error index (1-based, since 0 = success)
    output = format(output, indent_str, "return ", error_index.add(1).to_str(), ";\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Check if an expression is a struct construction call (TypeName())
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr, context: Context) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                // Use lookup_struct to check if this is a known struct type
                if first.params.len().eq(0) {
                    mut struct_found := false
                    _ := context.scope_stack.lookup_struct(name)
                    struct_found = true
                    catch (err: KeyNotFoundError) { }
                    if struct_found {
                        mut only_named_args := true
                        if expr.params.len().gt(1) {
                            mut i := 1
                            while i.lt(expr.params.len()) {
                                mut arg := Expr()
                                expr.params.get(i, arg)
                                catch (err: IndexOutOfBoundsError) { only_named_args = false }
                                switch arg.node_type {
                                case NodeType.NamedArg(_):
                                    // OK
                                case:
                                    only_named_args = false
                                }
                                i.inc()
                            }
                        }
                        if only_named_args {
                            return name
                        }
                    }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Check if an expression is an enum construction (Type.Variant or Type.Variant(value))
// Returns the type name if it is, None otherwise
// AST structure for Color.Red(42): FCall -> [Identifier("Color") -> [Identifier("Red")], Literal(42)]
// AST structure for Color.Unknown: Identifier("Color") -> [Identifier("Unknown")]
get_enum_construction_type := func(expr: Expr, context: Context) returns Str throws Str {
    // Check FCall case: Type.Variant(value) or Type.Variant()
    switch expr.node_type {
    case NodeType.FCall:
        if expr.params.len().gt(0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                // Use lookup_enum to check if this is a known enum type
                mut enum_def := context.scope_stack.lookup_enum(type_name)
                // Check if there's a nested identifier (the variant)
                if first.params.len().gt(0) {
                    mut nested := Expr()
                    first.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        // Verify the variant exists in the enum
                        if enum_def.contains_key(variant_name) {
                            return type_name
                        }
                    case:
                        return ""
                    }
                }
                return ""
            case:
                return ""
            }
            catch (err: KeyNotFoundError) { return "" }
        }
        return ""
    case NodeType.Identifier(type_name):
        // Check Identifier case: Type.Variant (no parentheses, no payload)
        // Use lookup_enum to check if this is a known enum type
        mut enum_def := context.scope_stack.lookup_enum(type_name)
        if expr.params.len().gt(0) {
            mut nested := Expr()
            expr.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch nested.node_type {
            case NodeType.Identifier(variant_name):
                // Verify the variant exists in the enum
                if enum_def.contains_key(variant_name) {
                    return type_name
                }
            case:
                return ""
            }
        }
        catch (err: KeyNotFoundError) { return "" }
        return ""
    case:
        return ""
    }
}

emit_declaration := proc(decl: Declaration, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {

    // Skip inline ext_func/ext_proc declarations - they're just declaring external functions exist
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            if func_def.is_ext() {
                return
            }
        case:
            // Continue
        }
    }

    // Check if this is a function definition - skip or hoist depending on context
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            // Check if we're inside a function (nested function declaration)
            if ctx.current_function_name.len().gt(0) {
                // Nested function - hoist it to top level with mangled name
                mut mangled_name := ctx.current_function_name.concat("_").concat(decl.name)

                // Register the name mapping so function calls can find it
                ctx.nested_func_names.set(decl.name, mangled_name)

                // Register function definition so get_value_type can resolve return types
                context.scope_stack.declare_func(decl.name, func_def)

                // Generate the hoisted function prototype
                mut proto_output := ""
                emit_func_signature(til_name(mangled_name), func_def, proto_output)
                proto_output = proto_output.concat(";\n")
                ctx.hoisted_prototypes.push(proto_output)

                // Generate the hoisted function definition
                mut func_output := ""

                // Save and set context for nested function
                mut saved_throw_types := ctx.current_throw_types
                mut saved_return_types := ctx.current_return_types
                mut saved_mut_params := ctx.current_ref_params
                mut saved_variadic_params := ctx.current_variadic_params
                mut saved_declared_vars := ctx.declared_vars
                mut saved_function_name := ctx.current_function_name
                mut saved_mangling_counter := ctx.mangling_counter

                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types
                ctx.current_function_name = mangled_name
                ctx.mangling_counter = 0  // Reset counter per-function for determinism
                ctx.current_ref_params = Vec.new(Str)
                ctx.current_variadic_params = Map.new(Str, Str)
                // Clear declared_vars and hoisted_struct_defaults for new function scope
                ctx.declared_vars = Set.new(Str)
                ctx.hoisted_struct_defaults = Map.new(Str, Str)

                // Track mut params and variadic params
                mut arg_idx := 0
                while arg_idx.lt(func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(arg_idx, arg)
                    // Bug #60: All non-copy args are passed by pointer (mut, own, and const/default)
                    if not(arg.is_copy) {
                        ctx.current_ref_params.push(arg.name)
                    }
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        ctx.current_variadic_params.set(arg.name, til_name(elem_type_name))
                    case:
                    }
                    arg_idx = arg_idx.add(1)
                }

                // Push scope frame for function
                context.scope_stack.push(ScopeType.Function)
                mut param_idx := 0
                while param_idx.lt(func_def.args.len()) {
                    mut param := Declaration()
                    func_def.args.get(param_idx, param)
                    mut value_type := param.value_type
                    switch param.value_type {
                    case ValueType.TMulti(elem_type):
                        value_type = ValueType.TCustom("Array")
                    case:
                    }
                    mut sym := SymbolInfo(value_type=value_type, is_mut=param.is_mut, is_copy=param.is_copy, is_own=param.is_own)
                    context.scope_stack.declare_symbol(param.name, sym)
                    param_idx = param_idx.add(1)
                }

                // Emit signature with mangled name
                emit_func_signature(mangled_name, func_def, func_output)
                func_output = func_output.concat(" {\n")

                // Emit body
                emit_stmts(func_def.body, func_output, 1, ctx, context)

                // For throwing void functions, add implicit return 0
                if func_def.throw_types.len().gt(0) {
                    if func_def.return_types.len().eq(0) {
                        func_output = func_output.concat("    return 0;\n")
                    }
                }

                func_output = func_output.concat("}\n\n")

                // Pop scope frame
                _ := context.scope_stack.pop()
                catch (err: IndexOutOfBoundsError) { throw err.msg }

                // Store in hoisted_functions
                ctx.hoisted_functions.push(func_output)

                // Restore context
                ctx.current_throw_types = saved_throw_types
                ctx.current_return_types = saved_return_types
                ctx.current_ref_params = saved_mut_params
                ctx.current_variadic_params = saved_variadic_params
                ctx.declared_vars = saved_declared_vars
                ctx.current_function_name = saved_function_name
                ctx.mangling_counter = saved_mangling_counter

                catch (err: AllocError) { throw err.msg }

                // Don't emit anything at declaration site - function is hoisted
                return
            }
            // Top-level function - skip, already emitted before main
            return
        case NodeType.StructDef(_struct_def):
            // Skip - already emitted before functions
            return
        case:
            // Continue with normal declaration
        }
    }

    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    // Hoist any throwing function calls in the RHS expression before emitting the declaration
    // This ensures throwing calls are properly handled with error checking
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        _ := hoist_throwing_expr(first, output, indent, ctx, context)
    }

    // Bug #35: For underscore declarations, just emit the expression (discard output)
    // This avoids C redeclaration errors and matches the semantics of discarding
    if decl.name.eq("_") {
        if expr.params.len().gt(0) {
            output.push_str(indent_str)
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            // FCall at statement level (indent > 0) adds ";\n" itself
            // Other expressions need semicolon added explicitly
            switch first.node_type {
            case NodeType.FCall:
                emit_expr(first, output, indent, ctx, context)
            case:
                emit_expr(first, output, 0, ctx, context)
                output.push_str(";\n")
            }
        }
        return
    }

    name := decl.name
    is_mut := decl.is_mut

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        struct_type = get_struct_construction_type(first, context)
    }

    // Check if this is an enum construction (Type.Variant or Type.Variant(value))
    mut enum_type := ""
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        enum_type = get_enum_construction_type(first, context)
    }

    // Track variable type for method mangling
    // Use the inferred type from struct/enum construction if available,
    // or use get_value_type to get return type of function calls like Vec.new(Str)
    mut var_type := decl.value_type
    if struct_type.len().gt(0) {
        var_type = ValueType.TCustom(struct_type)
    } else if enum_type.len().gt(0) {
        var_type = ValueType.TCustom(enum_type)
    } else {
        switch decl.value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq(INFER_TYPE).and(expr.params.len().gt(0)) {
                // Try get_value_type (handles function calls like Vec.new)
                mut first := Expr()
                expr.params.get(0, first)
                var_type = get_value_type(context, first)
                catch (err: Str) {
                    // get_value_type failed, keep decl.value_type
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }
        case:
            // Keep default decl.value_type
        }
    }
    // Add to scope_stack so get_value_type can find it
    context.scope_stack.declare_symbol(name, SymbolInfo(value_type=var_type, is_mut=decl.is_mut))

    // Check if variable already declared in this function (avoid C redefinition errors)
    // Use til_name() since that's what hoisting code uses when inserting into declared_vars
    already_declared := ctx.declared_vars.contains(til_name(name))

    if struct_type.len().gt(0) {
        // Extract type_name from struct_type (like Rust's if let Some(type_name) = struct_type)
        type_name := struct_type

        // Struct variable declaration with values (defaults or named args)

        // Build map of named arg values from struct literal
        mut named_values := Map.new(Str, Expr)
        if expr.params.len().gt(0) {
            mut first_param := Expr()
            expr.params.get(0, first_param)
            mut literal_arg_idx := 1
            while literal_arg_idx.lt(first_param.params.len()) {
                mut literal_arg := Expr()
                first_param.params.get(literal_arg_idx, literal_arg)
                switch literal_arg.node_type {
                case NodeType.NamedArg(field_name):
                    if literal_arg.params.len().gt(0) {
                        mut value_expr := Expr()
                        literal_arg.params.get(0, value_expr)
                        named_values.set(field_name, value_expr)
                    }
                case:
                }
                literal_arg_idx.inc()
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }

        // Look up struct definition to get default values
        mut struct_def_found := false
        mut struct_def := context.scope_stack.lookup_struct(struct_type)
        struct_def_found = true
        catch (err: KeyNotFoundError) { }

        if struct_def_found {
            if struct_def.members.len().eq(0) {
                // Empty struct - use empty initializer
                if not(already_declared) {
                    if not(is_mut) {
                        output.push_str("const ")
                    }
                    output.push_str(til_name(struct_type))
                    output.push_str(" ")
                    _ := ctx.declared_vars.insert(til_name(name))
                }
                output.push_str(til_name(name))
                emit_struct_literal_assign(output, struct_type, already_declared, "{}")
            } else if struct_def.default_values.len().eq(0).and(named_values.len().eq(0)) {
                // No defaults and no named args - zero initialize
                if not(already_declared) {
                    if not(is_mut) {
                        output.push_str("const ")
                    }
                    output.push_str(til_name(struct_type))
                    output.push_str(" ")
                    _ := ctx.declared_vars.insert(til_name(name))
                }
                output.push_str(til_name(name))
                emit_struct_literal_assign(output, struct_type, already_declared, "{0}")
            } else {
                // Has default values or named args - emit designated initializer
                // First check if any default value is a throwing function call
                mut throwing_defaults := Vec.new(ThrowingDefault)
                for member: Declaration in struct_def.members {
                    if not(member.is_mut) {
                        continue
                    }
                    if named_values.contains_key(member.name) {
                        continue  // Named arg overrides default
                    }
                    mut default_expr := Expr()
                    mut has_default := false
                    struct_def.default_values.get(member.name, default_expr)
                    has_default = true
                    catch (err: KeyNotFoundError) { }
                    if has_default {
                        if is_throwing_fcall(default_expr, context) {
                            mut td := ThrowingDefault()
                            td.member_name = member.name
                            td.default_expr = default_expr
                            throwing_defaults.push(td)
                        }
                    }
                }
                catch (err: AllocError) { throw err.msg }

                // If we have throwing defaults, emit them as separate statements first
                // Only do inline hoisting at statement level (indent > 0)
                // At expression level, hoisting was already done by hoist_throwing_expr
                if indent.gt(0) {
                mut td_idx := 0
                while td_idx.lt(throwing_defaults.len()) {
                    mut td := ThrowingDefault()
                    throwing_defaults.get(td_idx, td)

                    // Get the function's throw types
                    mut throw_types := Vec.new(ValueType)
                    if td.default_expr.params.len().gt(0) {
                        mut first_param := Expr()
                        td.default_expr.params.get(0, first_param)
                        mut fcall_func_name := get_func_name_string(first_param)
                        mut lookup_name := fcall_func_name.replace("_", ".")
                        mut func_def := context.scope_stack.lookup_func(lookup_name)
                        throw_types = func_def.throw_types
                        catch (err: KeyNotFoundError) { /* REM None case in Rust */ }
                    }
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    catch (err: AllocError) { throw err.msg }

                    mut temp_name := "_default_"
                    temp_name = temp_name.concat(td.member_name).concat("_").concat(next_mangled(ctx))
                    // Emit the function call with out-param using emit_throwing_call_propagate
                    emit_throwing_call_propagate(td.default_expr, throw_types, temp_name, "", output, indent, ctx, context)
                    // Record that this struct default was hoisted using "struct_name:member_name" key
                    key := type_name.concat(":").concat(td.member_name)
                    ctx.hoisted_struct_defaults.set(key, temp_name)
                    catch (err: AllocError) { throw err.msg }

                    td_idx.inc()
                }
                }  // end if indent.gt(0)

                if not(already_declared) {
                    if not(is_mut) {
                        output.push_str("const ")
                    }
                    output.push_str(til_name(struct_type))
                    output.push_str(" ")
                    _ := ctx.declared_vars.insert(til_name(name))
                }
                output.push_str(til_name(name))
                emit_struct_literal_start(output, struct_type, already_declared)
                output.push_str("{")
                mut is_first := true
                for member: Declaration in struct_def.members {
                    // Only include mut fields (actual struct data members)
                    // Skip functions, constants, and non-mut fields
                    if not(member.is_mut) {
                        continue
                    }
                    if not(is_first) {
                        output.push_str(", ")
                    }
                    is_first = false
                    output.push_str(".")
                    output.push_str(member.name)
                    output.push_str(" = ")
                    // Use named arg value if provided, otherwise use default
                    mut value_expr := Expr()
                    mut has_named_value := false
                    named_values.get(member.name, value_expr)
                    has_named_value = true
                    catch (err: KeyNotFoundError) { }
                    if has_named_value.and(value_expr.params.len().gt(0).or(value_expr.line.gt(0))) {
                        emit_expr(value_expr, output, 0, ctx, context)
                    } else {
                        mut default_expr := Expr()
                        mut has_default := false
                        struct_def.default_values.get(member.name, default_expr)
                        has_default = true
                        catch (err: KeyNotFoundError) { }
                        if has_default {
                            // Check if this was a throwing default - use temp var instead
                            key := type_name.concat(":").concat(member.name)
                            mut temp_name := ""
                            ctx.hoisted_struct_defaults.get(key, temp_name)
                            output.push_str(temp_name)
                            catch (err: KeyNotFoundError) {
                                if is_throwing_fcall(default_expr, context) {
                                    // Shouldn't happen - throwing defaults should be hoisted
                                    output.push_str("/* ERROR: unhoisted throwing default */")
                                } else {
                                    emit_expr(default_expr, output, 0, ctx, context)
                                }
                            }
                        } else {
                            // No default - use zero
                            output.push_str("0")
                        }
                    }
                }
                output.push_str("};\n")
            }
        } else {
            // Struct not found - fall back to zero init
            if not(already_declared) {
                if not(is_mut) {
                    output.push_str("const ")
                }
                output.push_str(til_name(struct_type))
                output.push_str(" ")
                _ := ctx.declared_vars.insert(til_name(name))
            }
            output.push_str(til_name(name))
            emit_struct_literal_assign(output, struct_type, already_declared, "{0}")
        }
    } else if enum_type.len().gt(0) {
        // Enum variable declaration
        if not(already_declared) {
            if not(is_mut) {
                output.push_str("const ")
            }
            output.push_str(til_name(enum_type))
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        output.push_str(" = ")
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        emit_expr(first, output, 0, ctx, context)
        output.push_str(";\n")
    } else if is_mut {
        // Hoist Dynamic params in RHS if it's an FCall (needed for methods like Set.contains)
        if expr.params.len().gt(0) {
            mut rhs_fcall := Expr()
            expr.params.get(0, rhs_fcall)
            switch rhs_fcall.node_type {
            case NodeType.FCall:
                if rhs_fcall.params.len().gt(1) {
                    mut got_fd := false
                    mut fd := SFuncDef()
                    fd = get_fcall_func_def(context, rhs_fcall)
                    got_fd = true
                    catch (err: KeyNotFoundError) { /* REM None case in Rust */ }
                    if got_fd {
                        mut param_types := Vec.new(ValueType)
                        mut param_by_ref := Vec.new(Bool)
                        for arg: Declaration in fd.args {
                            param_types.push(arg.value_type)
                            param_by_ref.push(param_needs_by_ref(arg))
                        }
                        args := rhs_fcall.params
                        empty_hoisted := Map.new(I64, Str)
                        dynamic_hoisted := hoist_for_dynamic_params(args, param_types, empty_hoisted, output, indent, ctx, context)
                        // Record hoisted Dynamic params in hoisted_exprs with & prefix
                        mut hoisted_map := Map.new(I64, Str)
                        for h: HoistedArg in dynamic_hoisted {
                            if lt(h.index, args.len()) {
                                mut arg_for_key := Expr()
                                args.get(h.index, arg_for_key)
                                expr_addr := to_ptr(arg_for_key)
                                hoisted_val := concat("&", h.temp_var)
                                ctx.hoisted_exprs.set(expr_addr, hoisted_val)
                            }
                            hoisted_map.set(h.index, h.temp_var)
                        }
                        // Hoist struct-returning FCall args when param is by-ref
                        ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted_map, output, indent, ctx, context)
                        for rh: HoistedArg in ref_hoisted {
                            if lt(rh.index, args.len()) {
                                mut arg_for_key := Expr()
                                args.get(rh.index, arg_for_key)
                                expr_addr := to_ptr(arg_for_key)
                                hoisted_val := concat("&", rh.temp_var)
                                ctx.hoisted_exprs.set(expr_addr, hoisted_val)
                            }
                        }
                    }
                }
            case:
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        // Determine C type - use explicit type annotation if present, otherwise infer
        if not(already_declared) {
            mut is_infer := false
            switch decl.value_type {
            case ValueType.TCustom(s):
                is_infer = s.eq(INFER_TYPE)
            case:
            }
            mut c_type := ""
            if is_infer {
                // INFER_TYPE - infer from RHS
                mut first := Expr()
                expr.params.get(0, first)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                vt := get_value_type(context, first)
                c_type = til_type_to_c(vt)
            } else {
                // Explicit type annotation - use it
                c_type = til_type_to_c(decl.value_type)
            }
            output.push_str(c_type)
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        if expr.params.len().gt(0) {
            output.push_str(" = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            emit_expr(first, output, 0, ctx, context)
        }
        output.push_str(";\n")
    } else {
        // const declaration
        // Hoist Dynamic params in RHS if it's an FCall (needed for methods like Set.contains)
        if expr.params.len().gt(0) {
            mut rhs_fcall := Expr()
            expr.params.get(0, rhs_fcall)
            switch rhs_fcall.node_type {
            case NodeType.FCall:
                if rhs_fcall.params.len().gt(1) {
                    mut got_fd := false
                    mut fd := SFuncDef()
                    fd = get_fcall_func_def(context, rhs_fcall)
                    got_fd = true
                    catch (err: KeyNotFoundError) { /* REM None case in Rust */ }
                    if got_fd {
                        mut param_types := Vec.new(ValueType)
                        mut param_by_ref := Vec.new(Bool)
                        for arg: Declaration in fd.args {
                            param_types.push(arg.value_type)
                            param_by_ref.push(param_needs_by_ref(arg))
                        }
                        args := rhs_fcall.params
                        empty_hoisted := Map.new(I64, Str)
                        dynamic_hoisted := hoist_for_dynamic_params(args, param_types, empty_hoisted, output, indent, ctx, context)
                        // Record hoisted Dynamic params in hoisted_exprs with & prefix
                        mut hoisted_map := Map.new(I64, Str)
                        for h: HoistedArg in dynamic_hoisted {
                            if lt(h.index, args.len()) {
                                mut arg_for_key := Expr()
                                args.get(h.index, arg_for_key)
                                expr_addr := to_ptr(arg_for_key)
                                hoisted_val := concat("&", h.temp_var)
                                ctx.hoisted_exprs.set(expr_addr, hoisted_val)
                            }
                            hoisted_map.set(h.index, h.temp_var)
                        }
                        // Hoist struct-returning FCall args when param is by-ref
                        ref_hoisted := hoist_for_ref_params(args, param_by_ref, hoisted_map, output, indent, ctx, context)
                        for rh: HoistedArg in ref_hoisted {
                            if lt(rh.index, args.len()) {
                                mut arg_for_key := Expr()
                                args.get(rh.index, arg_for_key)
                                expr_addr := to_ptr(arg_for_key)
                                hoisted_val := concat("&", rh.temp_var)
                                ctx.hoisted_exprs.set(expr_addr, hoisted_val)
                            }
                        }
                    }
                }
            case:
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        if not(already_declared) {
            // Determine C type - use explicit type annotation if present, otherwise infer
            mut is_infer := false
            switch decl.value_type {
            case ValueType.TCustom(s):
                is_infer = s.eq(INFER_TYPE)
            case:
            }
            mut c_type := ""
            if is_infer {
                // INFER_TYPE - infer from RHS
                mut first := Expr()
                expr.params.get(0, first)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                vt := get_value_type(context, first)
                c_type = til_type_to_c(vt)
            } else {
                // Explicit type annotation - use it
                c_type = til_type_to_c(decl.value_type)
            }
            output.push_str("const ")
            output.push_str(c_type)
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        if expr.params.len().gt(0) {
            output.push_str(" = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            emit_expr(first, output, 0, ctx, context)
        }
        output.push_str(";\n")
    }

    catch (err: AllocError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }
}

emit_funcdef := proc(_func_def: SFuncDef, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // For now, just inline the function body (we're inside main anyway)
    // TODO: proper function generation with prototypes
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }
    output.push_str(indent_str)
    output.push_str("{\n")
    for stmt: Expr in expr.params {
        emit_expr(stmt, output, indent.add(1), ctx, context)
    }
    output.push_str(indent_str)
    output.push_str("}\n")
}

emit_assignment := proc(name: Str, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    if expr.params.len().gt(0) {
        mut rhs_expr := Expr()
        expr.params.get(0, rhs_expr)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        // Check if RHS is a call to a throwing function
        switch rhs_expr.node_type {
        case NodeType.FCall:
            mut got_func_def := false
            mut func_def := SFuncDef()
            func_def = get_fcall_func_def(context, rhs_expr)
            got_func_def = true
            catch (err: KeyNotFoundError) {
                // Not a known function - fall through
            }
            if got_func_def {
                throw_types := func_def.throw_types
                if throw_types.len().gt(0) {
                    // RHS is a throwing function call - emit with error propagation
                    // (typer should ensure non-throwing context doesn't call throwing functions without catch)
                    // Pass raw name so function can properly handle field access on mut params
                    emit_throwing_call_propagate(rhs_expr, throw_types, "", name, output, indent, ctx, context)
                    return
                }
            }
        case:
        }

        // Hoist any throwing function calls nested in the RHS expression
        _ := hoist_throwing_expr(rhs_expr, output, indent, ctx, context)
    }

    // Regular assignment
    output.push_str(indent_str)
    // Check if assignment target is a field access on a mut param (self.field)
    // If so, emit with -> instead of .
    if name.contains(".") {
        // Find dot position manually (no index_of in TIL Str)
        mut dot_pos := 0
        mut name_idx := 0
        while name_idx.lt(name.len()) {
            mut ch := name.get_char(name_idx)
            if ch.eq(".") {
                dot_pos = name_idx
                name_idx = name.len()  // break
            } else {
                name_idx = name_idx.add(1)
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
        mut base := name.get_substr(0, dot_pos)
        mut rest := name.get_substr(dot_pos.add(1), name.len())
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
        if ctx.current_ref_params.contains(base) {
            // Mut param field access: til_self->field
            output.push_str(til_name(base))
            output.push_str("->")
            output.push_str(rest)
        } else {
            output.push_str(til_name(name))
        }
    } else if ctx.current_ref_params.contains(name) {
        // Direct assignment to mut param: *til_self = value
        output.push_str("*")
        output.push_str(til_name(name))
    } else {
        output.push_str(til_name(name))
    }
    output.push_str(" = ")
    if expr.params.len().gt(0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        emit_expr(first, output, 0, ctx, context)
    }
    output.push_str(";\n")

    catch (err: KeyNotFoundError) { throw err.msg }
}

emit_return := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }
    is_throwing := ctx.current_throw_types.len().gt(0)

    if is_throwing {
        // Throwing function: store value through _ret pointer and return 0 (success)
        if expr.params.len().gt(0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            // Check if return expression is a call to a throwing function
            switch return_expr.node_type {
            case NodeType.FCall:
                mut got_func_def := false
                mut func_def := SFuncDef()
                func_def = get_fcall_func_def(context, return_expr)
                got_func_def = true
                catch (err: KeyNotFoundError) {
                    // Not a known function - fall through to regular handling
                }
                if got_func_def {
                    throw_types := func_def.throw_types
                    if throw_types.len().gt(0) {
                        // Return expression is a throwing function call - emit with error propagation
                        // The result will be stored via the assign_name "*_ret"
                        emit_throwing_call_propagate(return_expr, throw_types, "", "*_ret", output, indent, ctx, context)
                        output.push_str(indent_str)
                        output.push_str("return 0;\n")
                        return
                    }
                }
            case:
            }

            // Hoist any throwing function calls nested in the return expression
            _ := hoist_throwing_expr(return_expr, output, indent, ctx, context)

            // Regular return value - just emit it
            output.push_str(indent_str)
            output.push_str("*_ret = ")
            emit_expr(return_expr, output, 0, ctx, context)
            output.push_str(";\n")
        }
        output.push_str(indent_str)
        output.push_str("return 0;\n")
    } else {
        // Non-throwing function: normal return
        // Check if return expression is a variadic function call
        if expr.params.len().gt(0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            mut handled_variadic_return := false
            switch return_expr.node_type {
            case NodeType.FCall:
                mut variadic_info := detect_variadic_fcall(return_expr, ctx)
                // Variadic call in return - need to hoist it
                // First, hoist any nested throwing/variadic calls in the arguments
                mut hoisted_vec := hoist_throwing_args(return_expr.params, output, indent, ctx, context)
                // Convert Vec<HoistedArg> to Map<I64, Str>
                mut hoisted := Map.new(I64, Str)
                for entry: HoistedArg in hoisted_vec {
                    hoisted.set(entry.index, entry.temp_var)
                    catch (err: AllocError) { throw "emit_return: AllocError in hoist_throwing_args" }
                }

                mut variadic_args := Vec.new(Expr)
                mut vi := variadic_info.regular_count.add(1)
                while vi.lt(return_expr.params.len()) {
                    mut varg := Expr()
                    return_expr.params.get(vi, varg)
                    variadic_args.push(varg)
                    vi = vi.add(1)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    catch (err: AllocError) { throw err.msg }
                }
                mut arr_var := hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, output, indent, ctx, context)

                // Emit the function call storing output
                mut temp_var := next_mangled(ctx)
                mut ret_type := "int"
                mut ret_vt := get_value_type(context, return_expr)
                ret_type = til_type_to_c(ret_vt)
                output.push_str(indent_str)
                output.push_str(ret_type)
                output.push_str(" ")
                output.push_str(temp_var)
                output.push_str(" = ")

                // Emit the function name
                mut func_name := get_fcall_func_name(return_expr)
                if func_name.len().gt(0) {
                    output.push_str(til_func_name(func_name))
                }
                output.push_str("(")

                // Emit regular args
                mut first := true
                mut ri := 0
                while ri.lt(variadic_info.regular_count) {
                    if not(first) {
                        output.push_str(", ")
                    }
                    first = false
                    mut arg := Expr()
                    return_expr.params.get(ri.add(1), arg)
                    emit_expr(arg, output, 0, ctx, context)
                    ri = ri.add(1)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                }

                // Emit variadic array pointer
                if not(first) {
                    output.push_str(", ")
                }
                output.push_str("&")
                output.push_str(arr_var)
                output.push_str(");\n")

                // Delete array
                output.push_str(indent_str)
                output.push_str(TIL_PREFIX)
                output.push_str("Array_delete(&")
                output.push_str(arr_var)
                output.push_str(");\n")

                // Return the output
                output.push_str(indent_str)
                output.push_str("return ")
                output.push_str(temp_var)
                output.push_str(";\n")
                handled_variadic_return = true
                catch (err: KeyNotFoundError) {
                    // Not a variadic function - fall through to regular return
                }
            case:
            }
            if handled_variadic_return {
                return
            }
        }

        // Hoist any throwing function calls nested in the return expression
        if expr.params.len().gt(0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            _ := hoist_throwing_expr(return_expr, output, indent, ctx, context)
        }

        // Regular non-variadic return
        output.push_str(indent_str)
        output.push_str("return")
        if expr.params.len().gt(0) {
            output.push_str(" ")
            mut first_param := Expr()
            expr.params.get(0, first_param)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            emit_expr(first_param, output, 0, ctx, context)
        }
        output.push_str(";\n")
    }

    catch (err: KeyNotFoundError) { throw err.msg }
}
hoist_for_dynamic_params := proc(args: Vec, param_types: Vec, already_hoisted: Map, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Vec throws Str {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    for _ in 0..indent {
        indent_str = indent_str.concat("    ")
    }

    for idx in 0..args.len() {
        mut arg := Expr()
        args.get(idx, arg)

        // Skip if already hoisted by throwing args hoister or by a previous function call
        arg_addr := to_ptr(arg)
        if already_hoisted.contains_key(idx).or(ctx.hoisted_exprs.contains_key(arg_addr)) {
            continue
        }

        // Check if param type is Dynamic
        mut is_dynamic := false
        mut p := ValueType.TCustom("")
        param_types.get(idx, p)
        switch p {
        case ValueType.TCustom(name):
            if name.eq("Dynamic") {
                is_dynamic = true
            }
        case:
        }
        catch (err: IndexOutOfBoundsError) {
            // REM: param_types.get can fail if idx >= param_types.len(), means not Dynamic
        }

        if not(is_dynamic) {
            continue
        }

        // Check if arg is NOT a simple identifier (i.e., needs hoisting)
        mut needs_hoisting := false
        switch arg.node_type {
        case NodeType.Identifier(_):
            // Simple identifier with no params is an lvalue, doesn't need hoisting
            // But identifier with params (type-qualified call like I64.to_str) does need hoisting
            needs_hoisting = not(arg.params.is_empty())
        case NodeType.LLiteral(lit):
            switch lit {
            case Literal.Str(_):
                needs_hoisting = true  // String literals need hoisting
            case:
                needs_hoisting = true
            }
        case NodeType.FCall:
            needs_hoisting = true    // Function calls need hoisting
        case:
            needs_hoisting = true  // Default to hoisting for safety
        }

        if not(needs_hoisting) {
            continue
        }

        // Determine the C type of the arg based on what it is
        mut c_type := ""
        switch arg.node_type {
        case NodeType.LLiteral(lit):
            switch lit {
            case Literal.Str(_):
                c_type = TIL_PREFIX.concat("Str")
            case Literal.Number(_):
                c_type = "int64_t"
            case Literal.List(_):
                c_type = "int64_t"  // TODO: proper list type
            case:
                c_type = "int64_t"
            }
        case NodeType.Identifier(var_name):
            if not(arg.params.is_empty()) {
                // Could be: enum constructor (Type.Variant), field access (var.field), or method call
                mut first_param := Expr()
                arg.params.get(0, first_param)
                catch (err: IndexOutOfBoundsError) {
                    throw arg.lang_error(context.path, "ccodegen", "Expected param")
                }
                switch first_param.node_type {
                case NodeType.Identifier(field_or_variant):
                    // Check if this is an enum constructor
                    mut is_enum_constructor := false
                    mut enum_def := context.scope_stack.lookup_enum(var_name)
                    is_enum_constructor = enum_def.contains_key(field_or_variant)
                    catch (err: KeyNotFoundError) {
                        // REM: Not an enum, check for field access below
                    }
                    if is_enum_constructor {
                        // Enum constructor returns the enum type
                        c_type = til_name(var_name)
                    } else {
                        mut sym := context.scope_stack.lookup_symbol(var_name)
                        catch (err: KeyNotFoundError) {
                            throw arg.lang_error(context.path, "ccodegen", format("Symbol not found: ", var_name))
                        }
                        // Field access - look up variable's type, then field's type
                        switch sym.value_type {
                        case ValueType.TCustom(struct_name):
                            mut struct_def := context.scope_stack.lookup_struct(struct_name)
                            catch (err: KeyNotFoundError) {
                                throw arg.lang_error(context.path, "ccodegen", format("Struct not found: ", struct_name))
                            }
                            mut found_member := false
                            mut member := Declaration()
                            for m: Declaration in struct_def.members {
                                if m.name.eq(field_or_variant) {
                                    member = m
                                    found_member = true
                                    break
                                }
                            }
                            if not(found_member) {
                                throw arg.lang_error(context.path, "ccodegen", format("Field not found: ", field_or_variant))
                            }
                            c_type = til_type_to_c(member.value_type)
                        case:
                            throw arg.lang_error(context.path, "ccodegen", format("Expected struct type for field access on ", var_name))
                        }
                    }
                case:
                    throw arg.lang_error(context.path, "ccodegen", "Expected identifier for field/variant")
                }
            } else {
                // Struct constructor like Ptr - identifier with no params
                mut is_struct := false
                struct_def := context.scope_stack.lookup_struct(var_name)
                is_struct = true
                catch (err: KeyNotFoundError) {
                    // REM: Not a struct
                }
                if is_struct {
                    c_type = til_name(var_name)
                } else {
                    throw arg.lang_error(context.path, "ccodegen", format("Unknown type: ", var_name))
                }
            }
        case NodeType.FCall:
            // For function calls, try to determine return type
            mut has_fd := false
            mut fd := get_fcall_func_def(context, arg)
            has_fd = true
            catch (err: KeyNotFoundError) {
                // REM: get_fcall_func_def returned None
            }
            if has_fd {
                if not(fd.throw_types.is_empty()) {
                    // Throwing call
                    if fd.return_types.is_empty() {
                        throw arg.lang_error(context.path, "ccodegen", "Throwing call has no return type")
                    }
                    mut first_ret := ValueType.TCustom("")
                    fd.return_types.get(0, first_ret)
                    c_type = til_type_to_c(first_ret)
                } else {
                    // Non-throwing call
                    mut ret_type := ValueType.TCustom("")
                    fd.return_types.get(0, ret_type)
                    catch (err: IndexOutOfBoundsError) {
                        throw arg.lang_error(context.path, "ccodegen", "Function has no return type")
                    }
                    c_type = til_type_to_c(ret_type)
                }
            } else {
                mut has_func_name := false
                mut func_name := get_fcall_func_name(arg)
                has_func_name = true
                catch (err: KeyNotFoundError) {
                    // REM: get_fcall_func_name returned None
                }
                if has_func_name {
                    // get_fcall_func_def returned None - check for constructors
                    if func_name.contains("_") {
                        // Check if this is an enum constructor (Type_Variant)
                        parts := func_name.split("_")
                        if parts.len().eq(2) {
                            mut type_name := ""
                            parts.get(0, type_name)
                            mut variant_name := ""
                            parts.get(1, variant_name)
                            mut is_enum_variant := false
                            mut enum_def := context.scope_stack.lookup_enum(type_name)
                            is_enum_variant = enum_def.contains_key(variant_name)
                            catch (err: KeyNotFoundError) {
                                // REM: Not an enum
                            }
                            if is_enum_variant {
                                // Enum constructor returns the enum type
                                c_type = til_name(type_name)
                            } else {
                                throw arg.lang_error(context.path, "ccodegen", format("Unknown enum variant: ", func_name))
                            }
                        } else {
                            throw arg.lang_error(context.path, "ccodegen", format("Unknown function: ", func_name))
                        }
                    } else {
                        mut is_struct := false
                        struct_def := context.scope_stack.lookup_struct(func_name)
                        is_struct = true
                        catch (err: KeyNotFoundError) {
                            // REM: Not a struct
                        }
                        if is_struct {
                            // Struct constructor like Ptr - returns the struct type
                            c_type = til_name(func_name)
                        } else {
                            throw arg.lang_error(context.path, "ccodegen", format("Unknown function: ", func_name))
                        }
                    }
                } else {
                    throw arg.lang_error(context.path, "ccodegen", "Cannot determine function name")
                }
            }
        case:
            throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for dynamic param")
        }

        temp_var := next_mangled(ctx)

        // Emit: til_Str _tmpXX = <expression>;
        output = output.concat(indent_str)
        output = output.concat(c_type)
        output = output.concat(" ")
        output = output.concat(temp_var)
        output = output.concat(" = ")
        emit_expr(arg, output, 0, ctx, context)
        output = output.concat(";\n")

        hoisted.push(HoistedArg(index=idx, temp_var=temp_var))
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return hoisted
}



// Helper to emit a Str compound literal: ((til_Str){(til_I64)"...", len})
// This is valid in both constant initializers and expressions (unlike til_Str_from_literal)
emit_str_literal := proc(s: Str, mut output: Str) throws AllocError, IndexOutOfBoundsError {
    output.push_str("((")
    output.push_str(TIL_PREFIX)
    output.push_str("Str){(")
    output.push_str(TIL_PREFIX)
    output.push_str("I64)\"")
    // Escape special characters for C string literals
    for i in 0..s.len() {
        c := get_char(s, i)
        if c.eq("\n") {
            output.push_str("\\n")
        } else if c.eq("\r") {
            output.push_str("\\r")
        } else if c.eq("\t") {
            output.push_str("\\t")
        } else if c.eq("\\") {
            output.push_str("\\\\")
        } else if c.eq("\"") {
            output.push_str("\\\"")
        } else {
            output.push_str(c)
        }
    }
    output.push_str("\", ")
    output.push_str(s.len().to_str())
    output.push_str("})")
}

emit_literal := proc(lit: Literal, mut output: Str, context: Context) throws Str {
    switch lit {
    case Literal.Str(s):
        // Check if Str struct is defined (inline, like Rust)
        mut has_str := false
        _ := context.scope_stack.lookup_struct("Str")
        has_str = true
        catch (err: KeyNotFoundError) { }
        if has_str {
            emit_str_literal(s, output)
        } else {
            output.push_str("\"")
            // Escape special characters for C string literals
            for i in 0..s.len() {
                c := get_char(s, i)
                if c.eq("\n") {
                    output.push_str("\\n")
                } else if c.eq("\r") {
                    output.push_str("\\r")
                } else if c.eq("\t") {
                    output.push_str("\\t")
                } else if c.eq("\\") {
                    output.push_str("\\\\")
                } else if c.eq("\"") {
                    output.push_str("\\\"")
                } else {
                    output.push_str(c)
                }
            }
            output.push_str("\"")
        }
    case Literal.Number(n):
        output.push_str(n)
    case Literal.List(_l):
        throw "ccodegen: List literals not yet supported"
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}
