mode lib

// C code generator for TIL
// Translates TIL AST to C source code

import("self.parser")  // Expr, NodeType, Literal
import("self.init")    // Context, get_value_type, ScopeFrame, SymbolInfo, ScopeType

// Prefix for all TIL-generated C names (structs, functions, etc.)
TIL_PREFIX := "til_"

// Global counter for generating unique mangled names
mut MANGLING_COUNTER: I64 = 0

// Info about a variadic parameter
VariadicParamInfo := struct {
    mut arg_name: Str = ""
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Info about a catch label for local throw/catch
CatchLabelInfo := struct {
    mut label: Str = ""
    mut temp_var: Str = ""
}

// Full catch label info entry including the catch block
CatchLabelInfoEntry := struct {
    mut type_name: Str = ""
    mut label: Str = ""
    mut temp_var: Str = ""
    mut catch_block: Expr = Expr()
}

// Codegen context for tracking function info during code generation
CodegenContext := struct {
    // Map function name -> variadic arg info (Map<Str, VariadicParamInfo>)
    mut func_variadic_args: Map = Map.new(Str, VariadicParamInfo)
    // Currently generating function's throw types (if any)
    mut current_throw_types: Vec = Vec.new(ValueType)
    // Currently generating function's return types (if any)
    mut current_return_types: Vec = Vec.new(ValueType)
    // Set of declared variable names in current function (to avoid redefinition)
    mut declared_vars: Set = Set.new(Str)
    // Set of mut param names in current function - for using -> instead of . for field access
    mut current_mut_params: Vec = Vec.new(Str)
    // Map of variadic param names to their element type (e.g., "args" -> "til_Bool")
    // Passed as til_Array* so need dereference, and need type info for Array.get casting
    mut current_variadic_params: Map = Map.new(Str, Str)
    // All known type names for generating til_size_of function
    mut known_types: Vec = Vec.new(Str)
    // Map of hoisted expression addresses to their temp variable names
    // Used to track deeply nested variadic/throwing calls that have been hoisted
    // Key is "line:col" string, value is temp var name (Str)
    mut hoisted_exprs: Map = Map.new(Str, Str)
    // Map of locally-caught error types to (catch label, temp variable name)
    // Used for throw statements and throwing calls when there's an outer catch block
    // Key is error type name, value is struct with label and temp_var
    mut local_catch_labels: Map = Map.new(Str, CatchLabelInfo)
    // Current function name for nested function name mangling (empty at top-level)
    mut current_function_name: Str = ""
    // C code for hoisted nested function definitions
    mut hoisted_functions: Vec = Vec.new(Str)
    // C code for hoisted nested function prototypes
    mut hoisted_prototypes: Vec = Vec.new(Str)
    // Map original function name -> mangled name for nested functions
    mut nested_func_names: Map = Map.new(Str, Str)
}

// Helper to check if Str struct is defined in context
has_str := func(context: Context) returns Bool {
    mut found := false
    _ := context.scope_stack.lookup_struct("Str")
    found = true
    catch (err: KeyNotFoundError) { }
    return found
}

// Generate unique mangled name using global counter
next_mangled := proc() returns Str {
    mut name := concat("_tmp", MANGLING_COUNTER.to_str())
    MANGLING_COUNTER = add(MANGLING_COUNTER, 1)
    return name
}

// Returns the C name for a TIL identifier - adds TIL_PREFIX
// Exceptions: C keywords (true, false), pointer deref (*name), and generated names (_ prefix)
til_name := func(name: Str) returns Str {
    if name.eq("true") { return "true" }
    if name.eq("false") { return "false" }
    if name.starts_with("*") { return name }
    if name.starts_with("_") { return name }
    return concat(TIL_PREFIX, name)
}

// Returns the C name for a TIL function - adds TIL_PREFIX and converts dots to underscores
// Used for function names like Array.len -> til_Array_len
til_func_name := func(name: Str) returns Str {
    return concat(TIL_PREFIX, name.replace(".", "_"))
}

// Result type for get_func_name_string
FuncNameResult := struct {
    mut found: Bool = false
    mut name: Str = ""
}

// Get function name from FCall's first param, handling both AST patterns:
// - Identifier("func") with params = [] -> "func"
// - Identifier("I64.inc") with params = [] -> "I64_inc" (from precomp)
// - Identifier("Vec") with params = [Identifier("new")] -> "Vec_new" (from parser)
// Returns the C-ready name with underscores (not dots)
get_func_name_string := func(first_param: Expr) returns FuncNameResult {
    mut result := FuncNameResult()
    switch first_param.node_type {
    case NodeType.Identifier(name):
        if first_param.params.len().eq(0) {
            result.found = true
            result.name = name.replace(".", "_")
        } else {
            mut parts := name
            mut i := 0
            while lt(i, first_param.params.len()) {
                mut p := Expr()
                first_param.params.get(i, p)
                switch p.node_type {
                case NodeType.Identifier(part):
                    parts = parts.concat("_").concat(part)
                case:
                }
                i = add(i, 1)
            }
            result.found = true
            result.name = parts
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { }
    return result
}

// Result type for get_type_arg_name
TypeArgResult := struct {
    mut found: Bool = false
    mut type_name: Str = ""
}

// Check if an expression is a type identifier (a Type parameter at call site)
// Returns the type name if it is, so it can be emitted as a string literal
// Matches interpreter.rs behavior (line 1703-1713)
// Only matches STANDALONE identifiers - not field access like Vec.INIT_CAP
get_type_arg_name := func(expr: Expr, context: Context) returns TypeArgResult {
    mut result := TypeArgResult()
    switch expr.node_type {
    case NodeType.Identifier(name):
        // Only match standalone identifiers (no field access)
        if gt(expr.params.len(), 0) {
            return result  // This is field access like Vec.INIT_CAP, not a type arg
        }
        // Check if this identifier is a type name (struct, enum, or builtin type)
        mut symbol := context.scope_stack.lookup_symbol(name)
        switch symbol.value_type {
        case ValueType.TType(type_name):
            result.found = true
            result.type_name = name
        case:
            // Not a type
        }
        catch (err: KeyNotFoundError) { }
    case:
        // Not an identifier
    }
    return result
}

// Add a variable to declared_vars
add_var_declared := proc(mut ctx: CodegenContext, name: Str) throws AllocError {
    _ := ctx.declared_vars.insert(name)
}

// Check if an expression is a function call that uses out-params (i.e., the function throws)
// Such calls cannot be used inline in struct initializers - they need separate statements
is_throwing_fcall := func(expr: Expr, context: Context) returns Bool {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first_param := Expr()
            expr.params.get(0, first_param)
            mut func_name_result := get_func_name_string(first_param)
            if func_name_result.found {
                // Convert underscore to dot for lookup (e.g., "Vec_new" -> "Vec.new")
                mut lookup_name := func_name_result.name.replacen("_", ".", 1)
                mut func_lookup := lookup_func_by_name(context, lookup_name)
                if func_lookup.found {
                    return gt(func_lookup.func_def.throw_types.len(), 0)
                }
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { }
    return false
}

// Result type for receiver type lookup
ReceiverTypeResult := struct {
    mut found: Bool = false
    mut value_type: ValueType = ValueType.TCustom("")
}

// Look up receiver type from scope_stack
lookup_receiver_type := func(context: Context, name: Str) returns ReceiverTypeResult {
    mut result := ReceiverTypeResult()
    mut symbol := context.scope_stack.lookup_symbol(name)
    result.found = true
    result.value_type = symbol.value_type
    catch (err: KeyNotFoundError) { }
    return result
}

// Convert TIL type to C type
til_type_to_c := func(til_type: ValueType) returns Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq("Str") { return "const char*" }
        else { return concat(TIL_PREFIX, name) }  // All types get til_ prefix
    case:
        return "int"  // Default
    }
}

// Result type for lookup_func_by_name
FuncLookupResult := struct {
    mut found: Bool = false
    mut func_def: SFuncDef = SFuncDef()
}

// Lookup function in scope_stack, trying both underscore and dot notation
// get_fcall_func_name returns underscore format (Str_clone) but scope_stack uses dots (Str.clone)
lookup_func_by_name := func(context: Context, func_name: Str) returns FuncLookupResult {
    mut result := FuncLookupResult()
    // Try exact name first (for regular functions)
    mut fd := context.scope_stack.lookup_func(func_name)
    result.found = true
    result.func_def = fd

    catch (err: KeyNotFoundError) {
        // First lookup failed, try converting first underscore to dot (for struct methods)
        mut idx := func_name.find("_")
        if idx.gteq(0) {
            mut dot_name := func_name.get_substr(0, idx)
            dot_name = dot_name.concat(".")
            dot_name = dot_name.concat(func_name.get_substr(add(idx, 1), func_name.len()))
            mut fd2 := context.scope_stack.lookup_func(dot_name)
            result.found = true
            result.func_def = fd2

            catch (err2: KeyNotFoundError) { }
            catch (err2: IndexOutOfBoundsError) { }
            catch (err2: AllocError) { }
        }
    }

    return result
}

// Helper to get C type name for a ValueType (same as til_type_to_c but for error struct definitions)
value_type_to_c_name := func(vt: ValueType) returns Str {
    switch vt {
    case ValueType.TCustom(name):
        if name.eq("Str") { return "const char*" }
        else { return concat(TIL_PREFIX, name) }  // All types get til_ prefix
    case:
        return "int"
    }
}

// Result type for detect_variadic_fcall
VariadicFCallInfo := struct {
    mut is_variadic: Bool = false
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Detect if an expression is a variadic function call
// Returns (elem_type, regular_count) if it's a variadic call
detect_variadic_fcall := proc(expr: Expr, ctx: CodegenContext) returns VariadicFCallInfo {
    mut result := VariadicFCallInfo()
    if eq(expr.params.len(), 0) {
        return result
    }

    // Get function name with dots (for lookup in variadic map)
    mut first := Expr()
    expr.params.get(0, first)
    mut func_name_result := get_func_name_string(first)
    if not(func_name_result.found) {
        return result
    }
    // For simple identifiers (after precomp), use the name directly
    // For nested identifiers (Type.method), convert underscores back to dots
    mut orig_func_name := ""
    if eq(first.params.len(), 0) {
        switch first.node_type {
        case NodeType.Identifier(name):
            orig_func_name = name
        case:
            orig_func_name = func_name_result.name.replace("_", ".")
        }
    } else {
        orig_func_name = func_name_result.name.replace("_", ".")
    }

    // Look up in func_variadic_args
    mut variadic_info := VariadicParamInfo()
    ctx.func_variadic_args.get(orig_func_name, variadic_info)
    result.is_variadic = true
    result.elem_type = variadic_info.elem_type
    result.regular_count = variadic_info.regular_count

    catch (err: KeyNotFoundError) {
        // Not a variadic function
    }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { }

    return result
}

// Result type for check_throwing_fcall
ThrowingFCallInfo := struct {
    mut is_throwing: Bool = false
    mut func_name: Str = ""
    mut throw_types: Vec = Vec.new(ValueType)
    mut return_type: ValueType = ValueType.TCustom("")
    mut has_return_type: Bool = false
}

// Result type for hoisted arguments
HoistedArg := struct {
    mut index: I64 = 0
    mut temp_var: Str = ""
}

// Forward declaration - get_fcall_func_name is defined later in the file
// We'll use a simplified version here that just gets the basic name

// Check if an expression is a throwing function call
// Returns info about the throwing call if it is one
check_throwing_fcall := proc(expr: Expr, ctx: CodegenContext, context: Context) returns ThrowingFCallInfo {
    mut result := ThrowingFCallInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // Get function name (simplified - just basic name extraction)
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            mut func_name := ""
            switch first.node_type {
            case NodeType.Identifier(name):
                if gt(first.params.len(), 0) {
                    // Type-qualified: Type.method - method is the LAST param (AST is flat)
                    mut method_idx := sub(first.params.len(), 1)
                    mut method_expr := Expr()
                    first.params.get(method_idx, method_expr)
                    switch method_expr.node_type {
                    case NodeType.Identifier(method_name):
                        func_name = method_name
                    case:
                        // Not identifier
                    }
                    catch (err: IndexOutOfBoundsError) { }
                } else {
                    func_name = name
                }
            case:
                // Not identifier
            }
            catch (err: IndexOutOfBoundsError) { }

            if gt(func_name.len(), 0) {
                mut lookup_result := lookup_func_by_name(context, func_name)
                if lookup_result.found {
                    if gt(lookup_result.func_def.throw_types.len(), 0) {
                        result.is_throwing = true
                        result.func_name = func_name
                        result.throw_types = lookup_result.func_def.throw_types
                        if gt(lookup_result.func_def.return_types.len(), 0) {
                            mut first_ret := ValueType.TCustom("")
                            lookup_result.func_def.return_types.get(0, first_ret)
                            result.return_type = first_ret
                            result.has_return_type = true
                            catch (err: IndexOutOfBoundsError) { }
                        }
                    }
                }
            }
        }
    case:
        // Not an FCall
    }
    return result
}

// Hoist a single expression if it's a throwing call, or recursively hoist throwing calls within it.
// Returns the output string with hoisted code prepended.
hoist_throwing_expr := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str, AllocError, IndexOutOfBoundsError, KeyNotFoundError {
    mut result := output
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Check if this expression itself is a throwing call
    mut throwing_info := check_throwing_fcall(expr, ctx, context)
    if throwing_info.is_throwing {
        // First, recursively hoist any throwing calls in this call's arguments
        if gt(expr.params.len(), 1) {
            mut arg_idx := 1
            while lt(arg_idx, expr.params.len()) {
                mut arg := Expr()
                expr.params.get(arg_idx, arg)
                mut arg_info := check_throwing_fcall(arg, ctx, context)
                if arg_info.is_throwing {
                    // Recursively hoist this argument
                    result = hoist_throwing_expr(arg, result, indent, ctx, context)
                }
                arg_idx = add(arg_idx, 1)
            }
        }

        mut temp_var := next_mangled()

        // Determine the C type for the temp variable
        mut c_type := "int"
        if throwing_info.has_return_type {
            c_type = til_type_to_c(throwing_info.return_type)
        }

        // Declare temp variable
        result = result.concat(indent_str).concat(c_type).concat(" ").concat(temp_var).concat(";\n")

        // Declare error variables for each throw type
        mut temp_suffix := next_mangled()
        mut err_idx := 0
        while lt(err_idx, throwing_info.throw_types.len()) {
            mut throw_type := ValueType.TCustom("")
            throwing_info.throw_types.get(err_idx, throw_type)
            switch throw_type {
            case ValueType.TCustom(type_name):
                result = result.concat(indent_str).concat(til_name(type_name)).concat(" _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix).concat(";\n")
            case:
            }
            err_idx = add(err_idx, 1)
        }

        // Emit the function call with output pointers
        result = result.concat(indent_str).concat("int _status_").concat(temp_suffix).concat(" = ")

        // Emit the function name and args
        mut nested_hoisted := Map.new(I64, Str)
        result = emit_fcall_name_and_args_for_throwing(expr, temp_var, temp_suffix, throwing_info.throw_types, nested_hoisted, "", result, ctx, context)

        result = result.concat(";\n")

        // Emit error checking - propagate or goto based on context
        // Check if there are local catch labels for these error types
        mut has_local_catch := false
        err_idx = 0
        while lt(err_idx, throwing_info.throw_types.len()) {
            mut throw_type := ValueType.TCustom("")
            throwing_info.throw_types.get(err_idx, throw_type)
            switch throw_type {
            case ValueType.TCustom(type_name):
                if Map.contains_key(ctx.local_catch_labels, type_name) {
                    has_local_catch = true
                }
            case:
            }
            err_idx = add(err_idx, 1)
        }

        if has_local_catch {
            // Use goto for local catches
            err_idx = 0
            while lt(err_idx, throwing_info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                throwing_info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    if Map.contains_key(ctx.local_catch_labels, type_name) {
                        mut catch_info := CatchLabelInfo()
                        Map.get(ctx.local_catch_labels, type_name, catch_info)
                        result = result.concat(indent_str).concat("if (_status_").concat(temp_suffix).concat(" == ").concat(add(err_idx, 1).to_str()).concat(") { ")
                        result = result.concat(catch_info.temp_var).concat(" = _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix)
                        result = result.concat("; goto ").concat(catch_info.label).concat("; }\n")
                    }
                case:
                }
                err_idx = add(err_idx, 1)
            }
        } else {
            // Propagate errors
            result = result.concat(indent_str).concat("if (_status_").concat(temp_suffix).concat(" != 0) {\n")

            err_idx = 0
            while lt(err_idx, throwing_info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                throwing_info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    mut curr_idx := 0
                    while lt(curr_idx, ctx.current_throw_types.len()) {
                        mut curr_throw := ValueType.TCustom("")
                        ctx.current_throw_types.get(curr_idx, curr_throw)
                        switch curr_throw {
                        case ValueType.TCustom(curr_type_name):
                            if curr_type_name.eq(type_name) {
                                result = result.concat(indent_str).concat("    if (_status_").concat(temp_suffix).concat(" == ").concat(add(err_idx, 1).to_str())
                                result = result.concat(") { *_err").concat(add(curr_idx, 1).to_str()).concat(" = _err").concat(err_idx.to_str()).concat("_").concat(temp_suffix)
                                result = result.concat("; return ").concat(add(curr_idx, 1).to_str()).concat("; }\n")
                            }
                        case:
                        }
                        curr_idx = add(curr_idx, 1)
                    }
                case:
                }
                err_idx = add(err_idx, 1)
            }

            result = result.concat(indent_str).concat("}\n")
        }

        // Store temp var in hoisted_exprs for caller to use
        mut hoisted_key := ctx.hoisted_exprs.len()
        Map.set(ctx.hoisted_exprs, hoisted_key, temp_var)

        return result
    }

    // Not a throwing call - recursively check sub-expressions
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 1) {
            mut arg_idx := 1
            while lt(arg_idx, expr.params.len()) {
                mut arg := Expr()
                expr.params.get(arg_idx, arg)
                result = hoist_throwing_expr(arg, result, indent, ctx, context)
                arg_idx = add(arg_idx, 1)
            }
        }
    case:
        mut param_idx := 0
        while lt(param_idx, expr.params.len()) {
            mut param := Expr()
            expr.params.get(param_idx, param)
            result = hoist_throwing_expr(param, result, indent, ctx, context)
            param_idx = add(param_idx, 1)
        }
    }

    return result
}

// Collect function info (throw types and return types) from AST into context
// Handles both top-level functions and struct methods
collect_func_info := proc(expr: Expr, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Top-level function - check for variadic args
                mut ai := 0
                while lt(ai, func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(ai, arg)
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        mut info := VariadicParamInfo()
                        info.arg_name = arg.name
                        info.elem_type = elem_type_name
                        info.regular_count = ai  // number of args before variadic
                        ctx.func_variadic_args.insert(decl.name, info)
                    case:
                        // Not variadic, continue
                    }
                    ai = add(ai, 1)
                }
                catch (err: IndexOutOfBoundsError) { /* ignore */ }
            case NodeType.StructDef(struct_def):
                // Struct methods - use mangled names (StructName_methodName)
                mut struct_name := decl.name
                mut keys := struct_def.default_values.keys
                mut i := 0
                while lt(i, keys.len()) {
                    mut member_name := ""
                    keys.get(i, member_name)
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        mut mangled_name := concat(struct_name, "_")
                        mangled_name = mangled_name.concat(member_name)
                        // Check for variadic args
                        mut ai := 0
                        while lt(ai, func_def.args.len()) {
                            mut arg := Declaration()
                            func_def.args.get(ai, arg)
                            switch arg.value_type {
                            case ValueType.TMulti(elem_type_name):
                                mut info := VariadicParamInfo()
                                info.arg_name = arg.name
                                info.elem_type = elem_type_name
                                info.regular_count = ai
                                ctx.func_variadic_args.insert(mangled_name, info)
                            case:
                                // Not variadic, continue
                            }
                            ai = add(ai, 1)
                        }
                        catch (err: IndexOutOfBoundsError) { /* ignore */ }
                    case:
                        // Not a function, skip
                    }
                    catch (err: KeyNotFoundError) { /* skip */ }
                    catch (err: AllocError) { throw err.msg }
                    catch (err: DuplicatedKeyError) { /* skip duplicates */ }
                    i = add(i, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            case:
                // Not a function or struct, skip
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
            catch (err: DuplicatedKeyError) { /* skip duplicates */ }
        }
    case:
        // Not a declaration, skip
    }
}

// Collect nested function info (for hoisting): scan function bodies for nested FuncDef declarations
// This populates ctx.nested_func_names and ctx.hoisted_prototypes before we emit function bodies
collect_nested_func_info := proc(expr: Expr, mut ctx: CodegenContext, parent_func_name: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                if gt(parent_func_name.len(), 0) {
                    // This is a nested function - record it for hoisting
                    mut mangled_name := concat(parent_func_name, "_")
                    mangled_name = mangled_name.concat(decl.name)
                    ctx.nested_func_names.insert(decl.name, mangled_name)

                    // Generate prototype for this nested function
                    mut proto := ""
                    mut return_type := "void"
                    if gt(func_def.return_types.len(), 0) {
                        mut rt := ValueType.TCustom("")
                        func_def.return_types.get(0, rt)
                        mut maybe_type := til_type_to_c(rt)
                        if gt(maybe_type.len(), 0) {
                            return_type = maybe_type
                        }
                    }
                    proto = proto.concat(return_type)
                    proto = proto.concat(" ")
                    proto = proto.concat(til_name(mangled_name))
                    proto = proto.concat("(")

                    if func_def.args.len().eq(0) {
                        proto = proto.concat("void")
                    } else {
                        mut ai := 0
                        while lt(ai, func_def.args.len()) {
                            if gt(ai, 0) {
                                proto = proto.concat(", ")
                            }
                            mut arg := Declaration()
                            func_def.args.get(ai, arg)
                            // Handle variadic args (TMulti) - they become (type* ptr, int64_t count)
                            switch arg.value_type {
                            case ValueType.TMulti(elem_type_name):
                                mut c_type := til_type_to_c(ValueType.TCustom(elem_type_name))
                                if gt(c_type.len(), 0) {
                                    proto = proto.concat(c_type)
                                    proto = proto.concat("* ")
                                    proto = proto.concat(til_name(arg.name))
                                    proto = proto.concat("_arr, ")
                                    proto = proto.concat(TIL_PREFIX)
                                    proto = proto.concat("I64 ")
                                    proto = proto.concat(til_name(arg.name))
                                    proto = proto.concat("_count")
                                }
                            case:
                                mut c_type := til_type_to_c(arg.value_type)
                                if gt(c_type.len(), 0) {
                                    proto = proto.concat("const ")
                                    proto = proto.concat(c_type)
                                    proto = proto.concat(" ")
                                    proto = proto.concat(til_name(arg.name))
                                }
                            }
                            ai = add(ai, 1)
                        }
                    }
                    proto = proto.concat(");\n")
                    ctx.hoisted_prototypes.push(proto)

                    // Recursively check for nested functions within this nested function
                    mut bi := 0
                    while lt(bi, func_def.body.len()) {
                        mut body_expr := Expr()
                        func_def.body.get(bi, body_expr)
                        collect_nested_func_info(body_expr, ctx, mangled_name)
                        bi = add(bi, 1)
                    }
                } else {
                    // Top-level function - scan its body for nested functions
                    mut bi := 0
                    while lt(bi, func_def.body.len()) {
                        mut body_expr := Expr()
                        func_def.body.get(bi, body_expr)
                        collect_nested_func_info(body_expr, ctx, decl.name)
                        bi = add(bi, 1)
                    }
                }
            case:
                // Not a FuncDef
            }
        }
    case NodeType.Body:
        mut i := 0
        while lt(i, expr.params.len()) {
            mut child := Expr()
            expr.params.get(i, child)
            collect_nested_func_info(child, ctx, parent_func_name)
            i = add(i, 1)
        }
    case NodeType.If:
        // Check then and else branches (params[0] = condition, params[1] = then, params[2] = else)
        if gt(expr.params.len(), 1) {
            mut then_branch := Expr()
            expr.params.get(1, then_branch)
            collect_nested_func_info(then_branch, ctx, parent_func_name)
        }
        if gt(expr.params.len(), 2) {
            mut else_branch := Expr()
            expr.params.get(2, else_branch)
            collect_nested_func_info(else_branch, ctx, parent_func_name)
        }
    case NodeType.While:
        // Check loop body (params[0] = condition, params[1] = body)
        if gt(expr.params.len(), 1) {
            mut body := Expr()
            expr.params.get(1, body)
            collect_nested_func_info(body, ctx, parent_func_name)
        }
    case NodeType.Switch:
        // Check all case bodies (params[0] = value, rest are cases)
        mut i := 1
        while lt(i, expr.params.len()) {
            mut case_expr := Expr()
            expr.params.get(i, case_expr)
            collect_nested_func_info(case_expr, ctx, parent_func_name)
            i = add(i, 1)
        }
    case:
        // Recursively check all params for other node types
        mut i := 0
        while lt(i, expr.params.len()) {
            mut child := Expr()
            expr.params.get(i, child)
            collect_nested_func_info(child, ctx, parent_func_name)
            i = add(i, 1)
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: DuplicatedKeyError) { /* skip duplicates */ }
}

// Emit function signature (used by both prototype and definition)
// For throwing functions:
//   int func_name(RetType* _ret, Error1* _err1, Error2* _err2, args...)
// For non-throwing:
//   RetType func_name(args...)
emit_func_signature := proc(func_name: Str, func_def: SFuncDef, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut is_throwing := gt(func_def.throw_types.len(), 0)

    if is_throwing {
        // Throwing function returns int status code
        result = result.concat("int ")
    } else {
        // Non-throwing function returns its actual type
        if eq(func_def.return_types.len(), 0) {
            result = result.concat("void ")
        } else {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = result.concat(til_type_to_c(ret_type))
            result = result.concat(" ")
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
    }

    result = result.concat(func_name).concat("(")

    mut param_count := 0

    if is_throwing {
        // Output params first: return value pointer, then error pointers
        if gt(func_def.return_types.len(), 0) {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = result.concat(til_type_to_c(ret_type)).concat("* _ret")
            param_count = add(param_count, 1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        // Error output parameters
        mut i := 0
        while lt(i, func_def.throw_types.len()) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            mut throw_type := ValueType.TCustom("")
            func_def.throw_types.get(i, throw_type)
            mut err_type := value_type_to_c_name(throw_type)
            result = result.concat(err_type).concat("* _err").concat(add(i, 1).to_str())
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Input parameters
    mut j := 0
    while lt(j, func_def.args.len()) {
        if gt(param_count, 0) {
            result = result.concat(", ")
        }
        mut arg := Declaration()
        func_def.args.get(j, arg)

        // Check for variadic arg (TMulti)
        switch arg.value_type {
        case ValueType.TMulti(elem_type_name):
            // Variadic args are passed as til_Array*
            result = result.concat(TIL_PREFIX).concat("Array* ").concat(TIL_PREFIX).concat(arg.name)
            param_count = add(param_count, 1)
            // Variadic must be last, so break
            j = func_def.args.len()
        case:
            // Regular arg
            if arg.is_mut {
                // mut: use pointer so mutations are visible to caller
                result = result.concat(til_type_to_c(arg.value_type)).concat("* ")
            } else {
                // const or copy: pass by value
                result = result.concat("const ").concat(til_type_to_c(arg.value_type)).concat(" ")
            }
            result = result.concat(TIL_PREFIX).concat(arg.name)
            param_count = add(param_count, 1)
            j = add(j, 1)
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    if eq(param_count, 0) {
        result = result.concat("void")
    }

    result = result.concat(")")
    return result
}

/// Get the function name from an FCall expression (returns underscore format like Type_method)
/// This returns the name WITHOUT til_ prefix.
/// For C output, use til_name() on the result.
get_fcall_func_name := func(expr: Expr) returns Str {
    if eq(expr.params.len(), 0) {
        return ""
    }

    mut first := Expr()
    expr.params.get(0, first)

    // get_func_name_string already handles both nested identifiers (Type.method)
    // and precomp'd strings ("Type.method"), returning "Type_method" format
    mut func_name_result := get_func_name_string(first)
    if func_name_result.found {
        return func_name_result.name
    }

    catch (err: IndexOutOfBoundsError) { }

    return ""
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Get struct name from a struct declaration expression
// Returns empty string if not a struct declaration
get_struct_name := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return decl.name
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Get struct dependencies (other struct types used as mut fields)
// Returns a Vec of type names (Str) that this struct depends on
get_struct_dependencies := func(expr: Expr) returns Vec {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return deps }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    catch (err: IndexOutOfBoundsError) { return deps }
                    if member.is_mut {
                        switch member.value_type {
                        case ValueType.TCustom(type_name):
                            // I64 and U8 are primitives, not struct deps
                            if not(Str.eq(type_name, "I64")) {
                                if not(Str.eq(type_name, "U8")) {
                                    if not(Str.eq(type_name, "auto")) {
                                        deps.push(type_name)
                                    }
                                }
                            }
                        case:
                            // Other types are not struct deps
                        }
                    }
                    i = add(i, 1)
                }
            case:
            }
        }
    case:
    }
    catch (err: AllocError) { }
    return deps
}

// Get enum dependencies (types used in payloads) as a Vec
get_enum_dependencies := func(expr: Expr) returns Vec {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return deps }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                // enum_map stores variant_name -> Ptr to ValueType (NULL = no payload)
                mut i := 0
                while lt(i, enum_def.enum_map.keys.len()) {
                    mut variant_name := ""
                    enum_def.enum_map.keys.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { return deps }
                    mut payload_ptr := Ptr()
                    enum_def.enum_map.get(variant_name, payload_ptr)
                    catch (err: KeyNotFoundError) { }
                    // Check if payload exists (not NULL)
                    if not(NULL.eq(payload_ptr.data)) {
                        mut payload_type := ValueType.TCustom("")
                        memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                        switch payload_type {
                        case ValueType.TCustom(type_name):
                            // Skip primitives (but NOT Str or Bool - they're structs)
                            if not(Str.eq(type_name, "I64")) {
                                if not(Str.eq(type_name, "U8")) {
                                    if not(Str.eq(type_name, "Dynamic")) {
                                        if not(Str.eq(type_name, "Type")) {
                                            deps.push(type_name)
                                        }
                                    }
                                }
                            }
                        case:
                        }
                    }
                    i = add(i, 1)
                }
            case:
            }
        }
    case:
    }
    catch (err: AllocError) { }
    return deps
}

// Get enum name from an enum-with-payloads declaration expression
get_enum_name := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return decl.name
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Get dependencies for a type (struct or enum-with-payloads)
get_type_dependencies := func(expr: Expr) returns Vec {
    if is_struct_declaration(expr) {
        return get_struct_dependencies(expr)
    }
    if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_dependencies(expr)
    }
    mut empty := Vec.new(Str)
    catch (err: AllocError) { }
    return empty
}

// Get name for a type (struct or enum-with-payloads)
get_type_name := func(expr: Expr) returns Str {
    if is_struct_declaration(expr) {
        return get_struct_name(expr)
    }
    if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_name(expr)
    }
    return ""
}

// Topologically sort type declarations (structs and enums-with-payloads) by their dependencies
// Returns indices into the original vector in sorted order
topological_sort_types := func(types: List) returns Vec {
    mut result := Vec.new(I64)
    mut n := types.len()

    // Build name -> index map
    mut name_to_idx := Map.new(Str, I64)
    mut idx := 0
    while lt(idx, n) {
        mut expr := Expr()
        types.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut name := get_type_name(expr)
        if gt(name.len(), 0) {
            name_to_idx.set(name, idx)
        }
        idx = add(idx, 1)
    }

    // Build adjacency list (dependencies)
    mut deps_list := List.new()  // List of Vec(I64) - deps_list[i] = dependencies of type i
    idx = 0
    while lt(idx, n) {
        mut empty_vec := Vec.new(I64)
        deps_list.push(Vec, empty_vec)
        idx = add(idx, 1)
    }
    idx = 0
    while lt(idx, n) {
        mut expr := Expr()
        types.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut deps := get_type_dependencies(expr)
        mut dep_idx := 0
        while lt(dep_idx, deps.len()) {
            mut dep_name := ""
            deps.get(dep_idx, dep_name)
            if name_to_idx.contains_key(dep_name) {
                mut dep_type_idx := 0
                name_to_idx.get(dep_name, dep_type_idx)
                catch (err: KeyNotFoundError) { }
                if not(dep_type_idx.eq(idx)) {
                    mut type_deps := Vec.new(I64)
                    deps_list.get(idx, type_deps)
                    catch (err: IndexOutOfBoundsError) { return result }
                    type_deps.push(dep_type_idx)
                }
            }
            dep_idx = add(dep_idx, 1)
        }
        idx = add(idx, 1)
    }

    // Kahn's algorithm for topological sort
    // If A depends on B, B must come first, so reverse the edges
    mut reverse_deps := List.new()  // List of Vec(I64)
    idx = 0
    while lt(idx, n) {
        mut empty_vec := Vec.new(I64)
        reverse_deps.push(Vec, empty_vec)
        idx = add(idx, 1)
    }
    idx = 0
    while lt(idx, n) {
        mut dep_list := Vec.new(I64)
        deps_list.get(idx, dep_list)
        catch (err: IndexOutOfBoundsError) { return result }
        mut dep_idx := 0
        while lt(dep_idx, dep_list.len()) {
            mut dep := 0
            dep_list.get(dep_idx, dep)
            mut rev_deps := Vec.new(I64)
            reverse_deps.get(dep, rev_deps)
            catch (err: IndexOutOfBoundsError) { return result }
            rev_deps.push(idx)
            dep_idx = add(dep_idx, 1)
        }
        idx = add(idx, 1)
    }

    // Calculate in-degree for reversed graph
    mut in_degree := Vec.new(I64)
    idx = 0
    while lt(idx, n) {
        in_degree.push(0)
        idx = add(idx, 1)
    }
    idx = 0
    while lt(idx, n) {
        mut dep_list := Vec.new(I64)
        reverse_deps.get(idx, dep_list)
        catch (err: IndexOutOfBoundsError) { return result }
        mut dep_idx := 0
        while lt(dep_idx, dep_list.len()) {
            mut dep := 0
            dep_list.get(dep_idx, dep)
            mut degree := 0
            in_degree.get(dep, degree)
            in_degree.set(dep, add(degree, 1))
            dep_idx = add(dep_idx, 1)
        }
        idx = add(idx, 1)
    }

    // Start with nodes that have in-degree 0
    mut queue := Vec.new(I64)
    idx = 0
    while lt(idx, n) {
        mut degree := 0
        in_degree.get(idx, degree)
        if degree.eq(0) {
            queue.push(idx)
        }
        idx = add(idx, 1)
    }

    // Process queue
    while gt(queue.len(), 0) {
        mut current := 0
        queue.pop(current)
        result.push(current)

        // For each node that current points to, decrement in-degree
        mut edges := Vec.new(I64)
        reverse_deps.get(current, edges)
        catch (err: IndexOutOfBoundsError) { return result }
        mut edge_idx := 0
        while lt(edge_idx, edges.len()) {
            mut next := 0
            edges.get(edge_idx, next)
            mut degree := 0
            in_degree.get(next, degree)
            in_degree.set(next, sub(degree, 1))
            if sub(degree, 1).eq(0) {
                queue.push(next)
            }
            edge_idx = add(edge_idx, 1)
        }
    }

    // If we couldn't sort all (cycle), append remaining in original order
    if lt(result.len(), n) {
        idx = 0
        while lt(idx, n) {
            mut found := false
            mut i := 0
            while lt(i, result.len()) {
                mut val := 0
                result.get(i, val)
                if val.eq(idx) {
                    found = true
                }
                i = add(i, 1)
            }
            if not(found) {
                result.push(idx)
            }
            idx = add(idx, 1)
        }
    }

    catch (err: AllocError) { }
    catch (err: IndexOutOfBoundsError) { }
    return result
}

// Topologically sort struct declarations by their field dependencies
// Uses Kahn's algorithm. Returns Vec of indices in sorted order.
topological_sort_structs := func(structs: List) returns Vec {
    mut result := Vec.new(I64)
    mut n := structs.len()

    // Build name -> index map
    mut name_to_idx := Map.new(Str, I64)
    mut idx := 0
    while lt(idx, n) {
        mut expr := Expr()
        structs.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut name := get_struct_name(expr)
        if gt(name.len(), 0) {
            name_to_idx.set(name, idx)
        }
        idx = add(idx, 1)
    }

    // Build reverse adjacency list and calculate in-degrees
    // If A depends on B, then B has an edge to A (B must come before A)
    mut reverse_deps := List.new()  // List of Vec(I64)
    mut in_degree := Vec.new(I64)

    // Initialize
    idx = 0
    while lt(idx, n) {
        mut empty_vec := Vec.new(I64)
        reverse_deps.push(Vec, empty_vec)
        in_degree.push(0)
        idx = add(idx, 1)
    }

    // Build edges: for each struct, look at its dependencies
    idx = 0
    while lt(idx, n) {
        mut expr := Expr()
        structs.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut deps := get_struct_dependencies(expr)
        mut dep_idx := 0
        while lt(dep_idx, deps.len()) {
            mut dep_name := ""
            deps.get(dep_idx, dep_name)
            if name_to_idx.contains_key(dep_name) {
                mut dep_struct_idx := 0
                name_to_idx.get(dep_name, dep_struct_idx)
                catch (err: KeyNotFoundError) { }
                // Skip self-references
                if not(dep_struct_idx.eq(idx)) {
                    // dep_struct_idx has edge to idx (dep must come before this struct)
                    mut dep_edges := Vec.new(I64)
                    reverse_deps.get(dep_struct_idx, dep_edges)
                    catch (err: IndexOutOfBoundsError) { return result }
                    dep_edges.push(idx)
                    // Increment in-degree of idx
                    mut degree := 0
                    in_degree.get(idx, degree)
                    in_degree.set(idx, add(degree, 1))
                }
            }
            dep_idx = add(dep_idx, 1)
        }
        idx = add(idx, 1)
    }

    // Kahn's algorithm: start with nodes that have in-degree 0
    mut queue := Vec.new(I64)
    idx = 0
    while lt(idx, n) {
        mut degree := 0
        in_degree.get(idx, degree)
        if degree.eq(0) {
            queue.push(idx)
        }
        idx = add(idx, 1)
    }

    // Process queue
    while gt(queue.len(), 0) {
        mut current := 0
        queue.pop(current)
        catch (err: IndexOutOfBoundsError) { return result }
        result.push(current)

        // For each struct that depends on current, decrement in-degree
        mut edges := Vec.new(I64)
        reverse_deps.get(current, edges)
        catch (err: IndexOutOfBoundsError) { return result }
        mut edge_idx := 0
        while lt(edge_idx, edges.len()) {
            mut next := 0
            edges.get(edge_idx, next)
            mut degree := 0
            in_degree.get(next, degree)
            degree = sub(degree, 1)
            in_degree.set(next, degree)
            if degree.eq(0) {
                queue.push(next)
            }
            edge_idx = add(edge_idx, 1)
        }
    }

    // If cycle detected, append remaining in original order
    if lt(result.len(), n) {
        idx = 0
        while lt(idx, n) {
            // Check if idx is already in result
            mut found := false
            mut res_idx := 0
            while lt(res_idx, result.len()) {
                mut val := 0
                result.get(res_idx, val)
                if val.eq(idx) {
                    found = true
                }
                res_idx = add(res_idx, 1)
            }
            if not(found) {
                result.push(idx)
            }
            idx = add(idx, 1)
        }
    }

    catch (err: AllocError) { }
    catch (err: IndexOutOfBoundsError) { }
    return result
}

// Check if an expression is an enum declaration (Name := enum {...})
is_enum_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Check if an expression is an enum declaration with payloads
is_enum_with_payloads := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return enum_has_payloads(enum_def)
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Check if an expression is a top-level constant declaration (name := literal)
// Constants are non-mut declarations with literal values (numbers, strings, bools)
is_constant_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Must not be mutable
        if decl.is_mut {
            return false
        }
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.LLiteral(lit):
                return true
            // Bool identifiers (true/false) are constants
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    return true
                }
                return false
            case NodeType.StructDef(struct_def):
                return false
            case NodeType.EnumDef(enum_def):
                return false
            case NodeType.FuncDef(func_def):
                return false
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a top-level constant declaration at file scope
emit_constant_declaration := proc(expr: Expr, output: Str, ctx: CodegenContext, context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            // Handle literal constants (numbers, strings)
            case NodeType.LLiteral(lit):
                switch lit {
                case Literal.Number(n):
                    // Non-mut declarations are constants
                    if not(decl.is_mut) {
                        result = result.concat("const ")
                    }
                    result = result.concat("I64 ").concat(decl.name).concat(" = ").concat(n).concat(";\n")
                case Literal.Str(s):
                    if has_str(context) {
                        if not(decl.is_mut) {
                            result = result.concat("const ")
                        }
                        result = format(result, TIL_PREFIX, "Str ")
                        result = result.concat(decl.name).concat(" = ")
                        result = emit_str_literal(s, result)
                        result = result.concat(";\n")
                    } else {
                        result = result.concat("const char* ").concat(decl.name).concat(" = \"").concat(s).concat("\";\n")
                    }
                case:
                    // Skip list literals for now
                    result = result
                }
            // Handle Bool constants (true/false identifiers)
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    if not(decl.is_mut) {
                        result = result.concat("const ")
                    }
                    result = format(result, TIL_PREFIX, "Bool ", TIL_PREFIX, decl.name, " = ")
                    // Use struct literal instead of macro (valid constant initializer)
                    if name.eq("true") {
                        result = format(result, "((", TIL_PREFIX, "Bool){1});\n")
                    } else {
                        result = format(result, "((", TIL_PREFIX, "Bool){0});\n")
                    }
                }
            case:
                result = result
            }
        }
    case:
        result = result
    }

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

// Emit a struct declaration as a C typedef struct (only mut fields become struct fields)
emit_struct_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs, not structs
        if decl.name.eq("I64") { return result }
        if decl.name.eq("U8") { return result }
        if decl.name.eq("Bool") { return result }
        if decl.name.eq("Dynamic") { return result }
        if decl.name.eq("Type") { return result }
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                result = result.concat("typedef struct {\n")
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit mut fields as struct members
                    if member.is_mut {
                        result = result.concat("    ").concat(til_type_to_c(member.value_type)).concat(" ").concat(member.name).concat(";\n")
                    }
                    i = add(i, 1)
                }
                result = result.concat("} ").concat(decl.name).concat(";\n\n")
                return result
            case:
                throw "emit_struct_declaration: not a struct"
            }
        }
        throw "emit_struct_declaration: empty params"
    case:
        throw "emit_struct_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
// Also emits size_of constant: til_size_of_StructName = sizeof(til_StructName)
emit_struct_constants := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := til_name(decl.name)
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        // Check if default_value is NOT a function (constants only)
                        mut is_func := false
                        mut default_val := Expr()
                        struct_def.default_values.get(member.name, default_val)
                        switch default_val.node_type {
                        case NodeType.FuncDef(fd):
                            is_func = true
                        case:
                            is_func = false
                        }
                        if not(is_func) {
                            result = result.concat("const ").concat(til_type_to_c(member.value_type)).concat(" ").concat(struct_name).concat("_").concat(member.name).concat(" = ")
                            result = emit_expr(default_val, result, 0, ctx, context).concat(";\n")
                        }
                        catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    }
                    i = add(i, 1)
                }
                // Emit size_of constant for this struct
                result = result.concat("const ").concat(TIL_PREFIX).concat("I64 ").concat(TIL_PREFIX).concat("size_of_").concat(decl.name).concat(" = sizeof(").concat(struct_name).concat(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name)
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit size_of constant for an enum: til_size_of_EnumName = sizeof(til_EnumName)
emit_enum_size_of_constant := proc(expr: Expr, output: Str, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := til_name(decl.name)
                result = result.concat("const ")
                result = result.concat(TIL_PREFIX)
                result = result.concat("I64 ")
                result = result.concat(TIL_PREFIX)
                result = result.concat("size_of_")
                result = result.concat(decl.name)
                result = result.concat(" = sizeof(")
                result = result.concat(enum_name)
                result = result.concat(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name)
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

// Emit til_size_of function for runtime type size lookup
emit_size_of_function := proc(output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    result = result.concat("\nstatic inline ").concat(TIL_PREFIX).concat("I64 ").concat(TIL_PREFIX).concat("size_of(").concat(TIL_PREFIX).concat("Str type_name) {\n")

    // All known types from structs and enums
    mut i := 0
    while lt(i, ctx.known_types.len()) {
        mut type_name := ""
        ctx.known_types.get(i, type_name)
        result = result.concat("    if (strcmp((char*)type_name.c_string, \"").concat(type_name).concat("\") == 0) return ").concat(TIL_PREFIX).concat("size_of_").concat(type_name).concat(";\n")
        i = add(i, 1)
    }

    result = result.concat("    fprintf(stderr, \"size_of: unknown type %s\\n\", (char*)type_name.c_string);\n").concat("    exit(1);\n}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Check if an enum has any payloads
enum_has_payloads := func(enum_def: SEnumDef) returns Bool {
    mut keys := enum_def.enum_map.keys
    mut i := 0
    while lt(i, keys.len()) {
        mut key := ""
        keys.get(i, key)
        catch (err: IndexOutOfBoundsError) { return false }
        mut payload_ptr := Ptr()
        enum_def.enum_map.get(key, payload_ptr)
        catch (err: KeyNotFoundError) { }
        // Check if payload exists (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            return true
        }
        i = add(i, 1)
    }
    return false
}

// Check if a variant has a payload (non-empty type)
variant_has_payload := func(payload_type: ValueType) returns Bool {
    switch payload_type {
    case ValueType.TCustom(name):
        return gt(name.len(), 0)
    case:
        return true  // Any non-TCustom type means it has a payload
    }
}

// Emit an enum with payloads as a tagged union
emit_enum_with_payloads := proc(enum_name: Str, enum_def: SEnumDef, output: Str) returns Str throws Str {
    mut result := output
    mut variants := enum_def.enum_map.keys

    // 1. Emit tag enum: typedef enum { Color_Unknown = 0, ... } Color_Tag;
    result = result.concat("typedef enum {\n")
    mut i := 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = result.concat("    ").concat(enum_name).concat("_").concat(variant_name).concat(" = ").concat(i.to_str()).concat(",\n")
        i = add(i, 1)
    }
    result = result.concat("} ").concat(enum_name).concat("_Tag;\n\n")

    // 2. Emit payload union (only for variants that have payloads)
    // typedef union { unsigned char Green; long long Number; } Color_Payload;
    mut has_any_payload := false
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_ptr := Ptr()
        enum_def.enum_map.get(variant_name, payload_ptr)
        catch (err: KeyNotFoundError) { }
        if not(NULL.eq(payload_ptr.data)) {
            has_any_payload = true
        }
        i = add(i, 1)
    }

    if has_any_payload {
        result = result.concat("typedef union {\n")
        i = 0
        while lt(i, variants.len()) {
            mut variant_name := ""
            variants.get(i, variant_name)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            mut payload_ptr := Ptr()
            enum_def.enum_map.get(variant_name, payload_ptr)
            catch (err: KeyNotFoundError) { }
            if not(NULL.eq(payload_ptr.data)) {
                mut payload_type := ValueType.TCustom("")
                memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                result = result.concat("    ").concat(til_type_to_c(payload_type)).concat(" ").concat(variant_name).concat(";\n")
            }
            i = add(i, 1)
        }
        result = result.concat("} ").concat(enum_name).concat("_Payload;\n\n")
    }

    // 3. Emit wrapper struct: typedef struct { Color_Tag tag; Color_Payload payload; } Color;
    result = result.concat("typedef struct {\n    ").concat(enum_name).concat("_Tag tag;\n")
    if has_any_payload {
        result = result.concat("    ").concat(enum_name).concat("_Payload payload;\n")
    }
    result = result.concat("} ").concat(enum_name).concat(";\n\n")

    // 4. Emit constructor functions for ALL variants (including no-payload ones)
    // This ensures consistent calling convention: Color_make_Red(42), Color_make_Unknown()
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_ptr := Ptr()
        enum_def.enum_map.get(variant_name, payload_ptr)
        catch (err: KeyNotFoundError) { }

        result = result.concat("static inline ").concat(enum_name).concat(" ").concat(enum_name).concat("_make_").concat(variant_name).concat("(")

        // Parameter for payload (if any)
        if not(NULL.eq(payload_ptr.data)) {
            mut payload_type := ValueType.TCustom("")
            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
            result = result.concat(til_type_to_c(payload_type)).concat(" value) {\n")
        } else {
            result = result.concat("void) {\n")
        }

        // Constructor body
        result = result.concat("    ").concat(enum_name).concat(" result = { .tag = ").concat(enum_name).concat("_").concat(variant_name).concat(" };\n")

        // Set payload if present
        if not(NULL.eq(payload_ptr.data)) {
            result = result.concat("    result.payload.").concat(variant_name).concat(" = value;\n")
        }

        result = result.concat("    return result;\n}\n\n")

        i = add(i, 1)
    }

    return result
}

// Emit an enum declaration as a C typedef enum (for simple enums without payloads)
// or as a tagged union struct (for enums with payloads)
emit_enum_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := decl.name

                if enum_has_payloads(enum_def) {
                    // Phase 2: Enums with payloads - tagged union
                    return emit_enum_with_payloads(enum_name, enum_def, result)
                }

                // Phase 1: Simple enum without payloads
                // typedef enum { EnumName_Variant1 = 0, ... } EnumName;
                result = result.concat("typedef enum {\n")

                // Get variant names (order matches insertion order from parser)
                mut variants := enum_def.enum_map.keys

                mut i := 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = result.concat("    ").concat(enum_name).concat("_").concat(variant_name).concat(" = ").concat(i.to_str()).concat(",\n")
                    i = add(i, 1)
                }

                result = result.concat("} ").concat(enum_name).concat(";\n\n")

                // Generate constructor functions for consistency with payload enums
                // static inline EnumName EnumName_make_Variant(void) { return EnumName_Variant; }
                i = 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = result.concat("static inline ").concat(enum_name).concat(" ").concat(enum_name).concat("_make_").concat(variant_name).concat("(void) { return ").concat(enum_name).concat("_").concat(variant_name).concat("; }\n")
                    i = add(i, 1)
                }
                result = result.concat("\n")

                return result
            case:
                throw "emit_enum_declaration: not an enum"
            }
        }
        throw "emit_enum_declaration: empty params"
    case:
        throw "emit_enum_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit a _to_str function for an enum type
// Takes a pointer because enum_to_str(e: Dynamic) passes by reference
// For simple enums: til_Str til_EnumName_to_str(til_EnumName* e)
// For enums with payloads: til_Str til_EnumName_to_str(til_EnumName* e)
emit_enum_to_str_function := proc(enum_name: Str, enum_def: SEnumDef, output: Str) returns Str throws Str {
    mut result := output
    has_payloads := enum_has_payloads(enum_def)
    mut variants := enum_def.enum_map.keys

    // Function signature - takes pointer since Dynamic params are passed by reference
    result = result.concat("static inline til_Str ").concat(enum_name).concat("_to_str(").concat(enum_name).concat("* e) {\n    switch(")
    if has_payloads {
        result = result.concat("e->tag")
    } else {
        result = result.concat("*e")
    }
    result = result.concat(") {\n")

    // Cases - need the original (non-prefixed) enum name for the string
    mut original_name := enum_name
    if enum_name.starts_with(TIL_PREFIX) {
        original_name = get_substr(enum_name, TIL_PREFIX.len(), enum_name.len())
    }

    mut i := 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        full_name := original_name.concat(".").concat(variant_name)
        result = result.concat("        case ").concat(enum_name).concat("_").concat(variant_name).concat(": return (til_Str){(til_I64)\"").concat(full_name).concat("\", ").concat(full_name.len().to_str()).concat("};\n")
        i = add(i, 1)
    }

    // Default case (shouldn't happen but good for safety)
    unknown_name := original_name.concat(".?")
    result = result.concat("    }\n    return (til_Str){(til_I64)\"").concat(unknown_name).concat("\", ").concat(unknown_name.len().to_str()).concat("};\n}\n\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

// Emit _to_str function for an enum declaration node
emit_enum_to_str_for_declaration := proc(expr: Expr, output: Str, context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        enum_name := decl.name
        enum_def := context.scope_stack.lookup_enum(enum_name)
        c_enum_name := til_name(enum_name)
        result = emit_enum_to_str_function(c_enum_name, enum_def, result)

        catch (err: KeyNotFoundError) {
            throw "emit_enum_to_str_for_declaration: enum not found in context"
        }
        return result
    case:
        throw "emit_enum_to_str_for_declaration: not an enum declaration"
    }
}

// Emit struct function prototypes with mangled names: StructName_funcname
emit_struct_func_prototypes := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Use emit_func_signature with mangled name
                            mut mangled_name := struct_name.concat("_").concat(member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = result.concat(";\n")
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function bodies with mangled names: StructName_funcname
emit_struct_func_bodies := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Set current function context
                            ctx.current_throw_types = func_def.throw_types
                            ctx.current_return_types = func_def.return_types
                            // Track mut params for pointer dereference (-> vs .)
                            ctx.current_mut_params = Vec.new(Str)
                            // Track variadic params - they're passed as til_Array* so need dereference
                            ctx.current_variadic_params = Map.new(Str, Str)
                            mut arg_idx := 0
                            while lt(arg_idx, func_def.args.len()) {
                                mut arg := Declaration()
                                func_def.args.get(arg_idx, arg)
                                if arg.is_mut {
                                    ctx.current_mut_params.push(arg.name)
                                }
                                switch arg.value_type {
                                case ValueType.TMulti(elem_type_name):
                                    // elem_type is the type name string like "Bool"
                                    ctx.current_variadic_params.insert(arg.name, til_name(elem_type_name))
                                case:
                                }
                                arg_idx = add(arg_idx, 1)
                            }
                            catch (err: IndexOutOfBoundsError) { throw err.msg }
                            catch (err: AllocError) { throw err.msg }
                            catch (err: DuplicatedKeyError) { }  // Ignore duplicates

                            // Clear declared_vars for new function scope
                            ctx.declared_vars = Set.new(Str)
                            catch (err: AllocError) { throw err.msg }

                            // Use emit_func_signature with mangled name
                            mut mangled_name := struct_name.concat("_").concat(member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = result.concat(" {\n")

                            // Emit function body with catch pattern detection
                            result = emit_stmts(func_def.body, result, 1, ctx, context)

                            // For throwing void functions, add implicit return 0
                            if gt(func_def.throw_types.len(), 0) {
                                if eq(func_def.return_types.len(), 0) {
                                    result = result.concat("    return 0;\n")
                                }
                            }

                            result = result.concat("}\n\n")

                            // Clear current function context
                            ctx.current_throw_types = Vec.new(ValueType)
                            ctx.current_return_types = Vec.new(ValueType)
                            ctx.current_mut_params = Vec.new(Str)
                            catch (err: AllocError) { throw err.msg }
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* skip member with no default */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr, mut context: Context) returns Str throws Str {
    mut output := ""
    mut ctx := CodegenContext()

    // C boilerplate
    output = output.concat("#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n")
    output = format(output, "typedef unsigned char ", TIL_PREFIX, "U8;\n")
    output = format(output, "typedef long long ", TIL_PREFIX, "I64;\n")
    output = format(output, "typedef struct ", TIL_PREFIX, "Bool { ", TIL_PREFIX, "U8 data; } ", TIL_PREFIX, "Bool;\n")
    // Dynamic and Type are special placeholder types
    output = format(output, "typedef void* ", TIL_PREFIX, "Dynamic;\n")
    output = format(output, "typedef const char* ", TIL_PREFIX, "Type;\n\n")

    // Pass 0: collect function info (throw types, return types) for call-site generation
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            collect_func_info(child, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip collect pass
    }

    // Pass 0a: collect nested function info for hoisting (populates hoisted_prototypes and nested_func_names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            collect_nested_func_info(child, ctx, "")
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip nested func collect pass
    }

    // Pass 0b: emit forward declarations for all structs and enums-with-payloads
    // (enums with payloads are implemented as structs in C, so they need forward declarations too)
    // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs defined in boilerplate
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    if decl.name.eq("I64") { }
                    else if decl.name.eq("U8") { }
                    else if decl.name.eq("Bool") { }
                    else if decl.name.eq("Dynamic") { }
                    else if decl.name.eq("Type") { }
                    else {
                        mut struct_name := til_name(decl.name)
                        output = output.concat("typedef struct ").concat(struct_name).concat(" ").concat(struct_name).concat(";\n")
                    }
                case:
                }
            }
            // Also forward-declare enums with payloads (they're implemented as structs)
            if is_enum_declaration(child) {
                if is_enum_with_payloads(child) {
                    switch child.node_type {
                    case NodeType.Declaration(decl):
                        mut enum_name := til_name(decl.name)
                        output = output.concat("typedef struct ").concat(enum_name).concat(" ").concat(enum_name).concat(";\n")
                    case:
                    }
                }
            }
            i = add(i, 1)
        }
        output = output.concat("\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip forward declarations
    }

    // Pass 1a: emit simple enums (no payloads) - safe to emit early, structs may use them as fields
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_enum_declaration(child) {
                if not(is_enum_with_payloads(child)) {
                    output = emit_enum_declaration(child, output)
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip enum pass
    }

    // Pass 1b: emit all structs and enums-with-payloads in topologically sorted order
    // Both are "complex types" that can depend on each other
    switch ast.node_type {
    case NodeType.Body:
        // Collect all struct declarations and enums-with-payloads
        mut type_decls := List.new()
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                type_decls.push(Expr, child)
            } else if is_enum_declaration(child) {
                if is_enum_with_payloads(child) {
                    type_decls.push(Expr, child)
                }
            }
            i = add(i, 1)
        }

        // Sort by dependencies and emit in order
        mut sorted_indices := topological_sort_types(type_decls)
        i = 0
        while lt(i, sorted_indices.len()) {
            mut idx := 0
            sorted_indices.get(i, idx)
            mut type_expr := Expr()
            type_decls.get(idx, type_expr)
            if is_struct_declaration(type_expr) {
                output = emit_struct_declaration(type_expr, output)
            } else {
                output = emit_enum_declaration(type_expr, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw "AllocError in type pass" }
    case:
        // Not a body, skip type pass
    }

    // Pass 1c: emit helper functions (after structs are defined)
    output = output.concat("\n// Type conversion helpers\n")
    output = format(output, "static inline ", TIL_PREFIX, "I64 u8_to_i64(", TIL_PREFIX, "U8 v) { return (", TIL_PREFIX, "I64)v; }\n")
    output = format(output, "static inline ", TIL_PREFIX, "U8 i64_to_u8(", TIL_PREFIX, "I64 v) { return (", TIL_PREFIX, "U8)v; }\n")
    if has_str(context) {
        output = output.concat("// single_print: print a string without newline\n")
        output = format(output, "static inline void single_print(", TIL_PREFIX, "Str s) { printf(\"%s\", (char*)s.c_string); }\n")
    } else {
        output = output.concat("\n// single_print: print a string without newline (no Str defined)\n")
        output = output.concat("static inline void single_print(const char* s) { printf(\"%s\", s); }\n")
    }
    output = output.concat("// print_flush: flush stdout\n")
    output = output.concat("static inline void print_flush(void) { fflush(stdout); }\n")
    output = output.concat("// to_ptr: get pointer address as integer\n")
    output = format(output, "static inline ", TIL_PREFIX, "I64 to_ptr(", TIL_PREFIX, "I64* p) { return (", TIL_PREFIX, "I64)p; }\n\n")

    // Pass 2: emit struct constants (non-mut, non-function fields with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_constants(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip constants pass
    }

    // Pass 2a: emit size_of constants for enums
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_enum_declaration(child) {
                output = emit_enum_size_of_constant(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip enum size_of pass
    }

    // Pass 2a2: emit enum_to_str functions for all enums
    // This must come after structs are defined (Str is needed for return type)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_enum_declaration(child) {
                output = emit_enum_to_str_for_declaration(child, output, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip enum_to_str pass
    }

    // Pass 2b: emit top-level constants (non-mut declarations with literal values)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_constant_declaration(child) {
                output = emit_constant_declaration(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip top-level constants pass
    }

    // Pass 2c: emit til_size_of function (runtime type size lookup)
    output = emit_size_of_function(output, ctx)

    output = output.concat("\n")

    // Pass 3: emit function prototypes (forward declarations)
    // 3a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_prototype(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip prototype pass
    }
    // 3b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_prototypes(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func prototype pass
    }
    // 3c: hoisted nested function prototypes (collected in Pass 0a)
    if gt(ctx.hoisted_prototypes.len(), 0) {
        output = output.concat("\n// Nested function prototypes (hoisted)\n")
        mut pi := 0
        while lt(pi, ctx.hoisted_prototypes.len()) {
            mut proto := ""
            ctx.hoisted_prototypes.get(pi, proto)
            output = output.concat(proto)
            pi = add(pi, 1)
        }
        catch (err: IndexOutOfBoundsError) { /* ignore */ }
    }
    output = output.concat("\n")

    // Pass 4: emit function definitions
    // 4a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_declaration(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip function pass
    }
    // 4b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_bodies(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func body pass
    }

    // 4c: hoisted nested function definitions
    // These were collected during emit_func_declaration when encountering nested functions
    // (prototypes were already emitted in Pass 3c)
    if gt(ctx.hoisted_functions.len(), 0) {
        output = output.concat("\n// Hoisted nested function definitions\n")
        mut fi := 0
        while lt(fi, ctx.hoisted_functions.len()) {
            mut func_code := ""
            ctx.hoisted_functions.get(fi, func_code)
            output = output.concat(func_code)
            fi = add(fi, 1)
        }
        catch (err: IndexOutOfBoundsError) { /* ignore */ }
    }

    // Main function
    output = output.concat("int main() {\n")

    // Clear hoisted_exprs to avoid cross-contamination from function passes
    ctx.hoisted_exprs = Map.new(Str, Str)

    // Pass 5: emit non-struct, non-function, non-enum, non-constant statements
    // Collect them into a Vec and use emit_stmts for proper variadic/throwing call handling
    switch ast.node_type {
    case NodeType.Body:
        mut main_stmts := Vec.new(Expr)
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            // Skip true/false declarations - they're now #defines
            mut skip_true_false := false
            switch child.node_type {
            case NodeType.Declaration(decl):
                if decl.name.eq("true") { skip_true_false = true }
                if decl.name.eq("false") { skip_true_false = true }
            case:
            }
            if not(skip_true_false) {
                if not(is_func_declaration(child)) {
                    if not(is_struct_declaration(child)) {
                        if not(is_enum_declaration(child)) {
                            if not(is_constant_declaration(child)) {
                                main_stmts.push(child)
                            }
                        }
                    }
                }
            }
            i = add(i, 1)
        }
        output = emit_stmts(main_stmts, output, 1, ctx, context)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, emit directly
        output = emit_expr(ast, output, 1, ctx, context)
    }

    // Call til_main() for modes that require a main proc (like cli)
    if context.mode_def.needs_main_proc {
        output = output.concat("    til_main();\n")
    }

    output = output.concat("    return 0;\n}\n")

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return output
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = result.concat(";\n")
                return result
            case:
                throw "emit_func_prototype: not a function"
            }
        }
        throw "emit_func_prototype: empty params"
    case:
        throw "emit_func_prototype: not a declaration"
    }
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Save and set current function name for nested function mangling
                mut prev_function_name := ctx.current_function_name
                ctx.current_function_name = decl.name

                // Set current function context for return/throw generation
                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types
                // Track mut params for pointer dereference (-> vs .)
                ctx.current_mut_params = Vec.new(Str)
                // Track variadic params - they're passed as til_Array* so need dereference
                ctx.current_variadic_params = Map.new(Str, Str)

                // Clear declared_vars for new function scope
                ctx.declared_vars = Set.new(Str)
                // Check for variadic parameter and track mut params
                mut arg_idx := 0
                while lt(arg_idx, func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(arg_idx, arg)
                    // Track mut params
                    if arg.is_mut {
                        ctx.current_mut_params.push(arg.name)
                    }
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        // elem_type is the type name string like "Bool"
                        ctx.current_variadic_params.insert(arg.name, til_name(elem_type_name))
                    case:
                        // Not variadic, continue
                    }
                    arg_idx = add(arg_idx, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }
                catch (err: DuplicatedKeyError) { }  // Ignore duplicates

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = result.concat(" {\n")

                // Emit function body with catch pattern detection
                result = emit_stmts(func_def.body, result, 1, ctx, context)

                // For throwing void functions, add implicit return 0
                if gt(func_def.throw_types.len(), 0) {
                    if eq(func_def.return_types.len(), 0) {
                        result = result.concat("    return 0;\n")
                    }
                }

                result = result.concat("}\n\n")

                // Restore previous function name
                ctx.current_function_name = prev_function_name

                // Clear current function context
                ctx.current_throw_types = Vec.new(ValueType)
                ctx.current_return_types = Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }

                return result
            case:
                throw "emit_func_declaration: not a function"
            }
        }
        throw "emit_func_declaration: empty params"
    case:
        throw "emit_func_declaration: not a declaration"
    }
}

/// Emit an argument, using hoisted temp var if available
/// Also handles Type arguments by emitting them as string literals
emit_arg_or_hoisted := proc(arg: Expr, arg_idx: I64, hoisted: Map, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut no_param_type := ValueType.TCustom("")  // Empty TCustom represents None
    return emit_arg_with_param_type(arg, arg_idx, hoisted, no_param_type, false, false, output, ctx, context)
}

/// Emit an argument with knowledge of expected parameter type and mutability
/// Handles: Type args as string literals, Dynamic args with &, mut args with &
emit_arg_with_param_type := proc(arg: Expr, arg_idx: I64, hoisted: Map, param_type: ValueType, has_param_type: Bool, param_is_mut: Bool, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Check if hoisted temp var exists for this arg index
    mut idx_str := I64.to_str(arg_idx)
    if hoisted.contains_key(idx_str) {
        // Hoisted temp var is an lvalue - add & if param is Dynamic or mut
        if param_is_mut {
            result = result.concat("&")
        } else if has_param_type {
            switch param_type {
            case ValueType.TCustom(param_type_name):
                if param_type_name.eq("Dynamic") {
                    result = result.concat("&")
                }
            case:
            }
        }
        mut temp_var := ""
        hoisted.get(idx_str, temp_var)
        result = result.concat(temp_var)
        return result
    }

    // Check if arg is a type identifier - emit as string literal (matches interpreter.rs)
    mut type_arg_result := get_type_arg_name(arg, context)
    if type_arg_result.found {
        result = result.concat("\"").concat(type_arg_result.type_name).concat("\"")
        return result
    }

    // Check if parameter type is Dynamic (including mut Dynamic)
    // Must check BEFORE the general mut check since Dynamic needs casting
    mut is_dynamic := false
    if has_param_type {
        switch param_type {
        case ValueType.TCustom(name):
            if name.eq("Dynamic") {
                is_dynamic = true
            }
        case:
        }
    }
    if is_dynamic {
        // Check if arg is a simple identifier (can take address directly)
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.len().eq(0) {
                // Check if this identifier is already a pointer (from being a mut param)
                // If so, just cast it without taking address again
                mut is_already_pointer := ctx.current_mut_params.contains(name).or(Map.contains_key(ctx.current_variadic_params, name))
                if is_already_pointer {
                    // Already a pointer - just cast without &
                    result = result.concat("(").concat(TIL_PREFIX).concat("Dynamic*)").concat(til_name(name))
                } else {
                    // Simple variable - cast to til_Dynamic* (void**) and take address
                    result = result.concat("(").concat(TIL_PREFIX).concat("Dynamic*)&").concat(til_name(name))
                }
                return result
            }
        case:
        }
        // For non-identifier args (function calls, literals), they should have
        // been hoisted already. If not, just emit without & and let C handle it.
        result = emit_expr(arg, result, 0, ctx, context)
        return result
    }

    // Check if param is mut (but not Dynamic) - emit &arg for pointer
    if param_is_mut {
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.len().eq(0) {
                // Check if this identifier is already a mut param (already a pointer)
                // or a variadic param (also a pointer) - don't add & again
                mut is_already_pointer := ctx.current_mut_params.contains(name).or(Map.contains_key(ctx.current_variadic_params, name))
                if is_already_pointer {
                    // Already a pointer - just emit the name
                    result = result.concat(til_name(name))
                } else {
                    // Simple variable - emit &var
                    result = result.concat("&").concat(til_name(name))
                }
                return result
            } else {
                // Field access like self.type_names - need &(self->field) or &(var.field)
                // Check if base is a mut param (pointer) or regular variable
                mut base_is_pointer := ctx.current_mut_params.contains(name)
                result = result.concat("&").concat(til_name(name))
                mut i := 0
                while lt(i, arg.params.len()) {
                    mut param := Expr()
                    arg.params.get(i, param)
                    switch param.node_type {
                    case NodeType.Identifier(field):
                        if base_is_pointer.and(i.eq(0)) {
                            result = result.concat("->")
                        } else {
                            result = result.concat(".")
                        }
                        result = result.concat(field)
                    case:
                    }
                    i = add(i, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                return result
            }
        case:
        }
        // For non-identifier args, emit as-is (may cause compile error, but that's a user error)
        result = emit_expr(arg, result, 0, ctx, context)
        return result
    }

    // Check if arg is a variadic param (which is til_Array*) but expected param is NOT mut
    // In this case we need to dereference: (*til_args) to get til_Array by value
    switch arg.node_type {
    case NodeType.Identifier(name):
        if arg.params.len().eq(0) {
            if ctx.current_variadic_params.contains_key(name) {
                result = result.concat("(*").concat(til_name(name)).concat(")")
                return result
            }
        }
    case:
    }

    result = emit_expr(arg, result, 0, ctx, context)

    catch (err: KeyNotFoundError) { throw err.msg }

    return result
}

/// Emit an FCall expression using pre-hoisted temp vars for arguments
emit_fcall_with_hoisted := proc(expr: Expr, hoisted: Map, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    if expr.params.len().eq(0) {
        throw "emit_fcall_with_hoisted: FCall with no params"
    }

    // Get function name (handles both nested identifiers and precomp'd "Type.method" strings)
    mut first := Expr()
    expr.params.get(0, first)
    mut func_name_result := get_func_name_string(first)
    if not(func_name_result.found) {
        throw "emit_fcall_with_hoisted: FCall first param not Identifier"
    }
    mut func_name := func_name_result.name

    // Check for struct construction: TypeName() -> (til_TypeName){defaults...}
    // Struct names are PascalCase, no nested identifiers, no args
    mut first_char := func_name.char_at(0)
    // 65 = 'A', 90 = 'Z'
    mut char_A : U8 = 65
    mut char_Z : U8 = 90
    if not(U8.lt(first_char, char_A)).and(not(U8.gt(first_char, char_Z))) {
        // Uppercase letter
        if not(func_name.contains("_")) {
            // Not a Type_method call
            if expr.params.len().eq(1) {
                // No constructor args
                result = result.concat("(").concat(TIL_PREFIX).concat(func_name).concat(")")

                // Look up struct definition to get default values
                mut struct_found := false
                mut struct_def := context.scope_stack.lookup_struct(func_name)
                struct_found = true
                catch (err: KeyNotFoundError) { }

                if struct_found {
                    if struct_def.members.len().eq(0).or(struct_def.default_values.len().eq(0)) {
                        result = result.concat("{}")
                    } else {
                        result = result.concat("{")
                        mut is_first := true
                        mut member_idx := 0
                        while lt(member_idx, struct_def.members.len()) {
                            mut member := Declaration()
                            struct_def.members.get(member_idx, member)
                            catch (err: IndexOutOfBoundsError) { throw err.msg }
                            if not(member.is_mut) {
                                member_idx = add(member_idx, 1)
                            } else {
                                if not(is_first) {
                                    result = result.concat(", ")
                                }
                                is_first = false
                                result = result.concat(".").concat(member.name).concat(" = ")
                                mut default_found := false
                                mut default_expr := Expr()
                                struct_def.default_values.get(member.name, default_expr)
                                default_found = true
                                catch (err: KeyNotFoundError) { }
                                if default_found {
                                    result = emit_expr(default_expr, result, 0, ctx, context)
                                } else {
                                    result = result.concat("0")
                                }
                                member_idx = add(member_idx, 1)
                            }
                        }
                        result = result.concat("}")
                    }
                } else {
                    result = result.concat("{}")
                }
                return result
            }
        }
    }

    // Function call: til_func_name(args...)
    // func_name already has underscores (from get_func_name_string), just add prefix
    result = result.concat(TIL_PREFIX).concat(func_name).concat("(")

    // Look up param types for mut handling
    // Convert underscore back to dot for lookup (e.g., "I64_inc" -> "I64.inc")
    mut lookup_name := func_name.replacen("_", ".", 1)
    mut func_lookup := lookup_func_by_name(context, lookup_name)

    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, sub(params_len, 1)) {
        if gt(i, 0) {
            result = result.concat(", ")
        }
        mut arg := Expr()
        expr.params.get(add(i, 1), arg)

        // Check if arg is a type identifier - emit as string literal
        mut type_arg_result := get_type_arg_name(arg, context)
        if type_arg_result.found {
            result = result.concat("\"").concat(type_arg_result.type_name).concat("\"")
        } else if func_lookup.found {
            mut param_type := ValueType.TCustom("")  // Empty TCustom represents None
            mut has_param_type := false
            mut is_mut := false
            if lt(i, func_lookup.func_def.args.len()) {
                mut arg_def := Declaration()
                func_lookup.func_def.args.get(i, arg_def)
                param_type = arg_def.value_type
                has_param_type = true
                is_mut = arg_def.is_mut
            }
            result = emit_arg_with_param_type(arg, i, hoisted, param_type, has_param_type, is_mut, result, ctx, context)
        } else {
            result = emit_arg_or_hoisted(arg, i, hoisted, result, ctx, context)
        }
        i = add(i, 1)
    }
    result = result.concat(")")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    return result
}

emit_if := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if lt(expr.params.len(), 2) {
        throw "ccodegen: If requires condition and body"
    }

    mut result := output

    // Hoist any throwing function calls in the condition
    mut cond := Expr()
    expr.params.get(0, cond)
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    result = hoist_throwing_expr(cond, result, indent, ctx, context)
    catch (err: AllocError) { throw "emit_if: AllocError in hoist_throwing_expr" }
    catch (err: KeyNotFoundError) { throw "emit_if: KeyNotFoundError in hoist_throwing_expr" }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    mut i := 0
    while lt(i, indent) {
        result = result.concat("    ")
        i = add(i, 1)
    }
    result = result.concat("if (")
    result = emit_expr(cond, result, 0, ctx, context)
    // Bool is a struct with .data field - extract for C truthiness
    mut cond_type := get_value_type(context, cond)
    switch cond_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Bool") {
            result = result.concat(".data")
        }
    case:
    }
    catch (err: Str) { /* get_value_type failed, skip */ }
    result = result.concat(") {\n")

    // Save declared_vars before entering new scope
    mut saved_declared_vars := ctx.declared_vars.clone()
    catch (err: AllocError) { throw err.msg }

    // Then body
    mut then_body := Expr()
    expr.params.get(1, then_body)
    result = emit_body(then_body, result, add(indent, 1), ctx, context)

    // Restore declared_vars after exiting then scope
    ctx.declared_vars = saved_declared_vars

    i = 0
    while lt(i, indent) {
        result = result.concat("    ")
        i = add(i, 1)
    }
    result = result.concat("}")

    // Else branch (optional)
    if gt(expr.params.len(), 2) {
        mut else_part := Expr()
        expr.params.get(2, else_part)
        switch else_part.node_type {
        case NodeType.If:
            // Always wrap else-if in braces to ensure hoisted temp vars
            // from nested if conditions have proper scope
            result = result.concat(" else {\n")
            result = emit_if(else_part, result, add(indent, 1), ctx, context)
            i = 0
            while lt(i, indent) {
                result = result.concat("    ")
                i = add(i, 1)
            }
            result = result.concat("}\n")
        case:
            // else block
            result = result.concat(" else {\n")

            // Save declared_vars for else scope
            saved_declared_vars = ctx.declared_vars.clone()
            catch (err: AllocError) { throw err.msg }

            result = emit_body(else_part, result, add(indent, 1), ctx, context)

            // Restore declared_vars after exiting else scope
            ctx.declared_vars = saved_declared_vars

            i = 0
            while lt(i, indent) {
                result = result.concat("    ")
                i = add(i, 1)
            }
            result = result.concat("}\n")
        }
    } else {
        result = result.concat("\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

emit_while := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // While: params[0] = condition, params[1] = body
    if lt(expr.params.len(), 2) {
        throw "ccodegen: While requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = result.concat("    ")
        i = add(i, 1)
    }
    result = result.concat("while (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0, ctx, context)
    // Bool is a struct with .data field - extract for C truthiness
    mut cond_type := get_value_type(context, cond)
    switch cond_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Bool") {
            result = result.concat(".data")
        }
    case:
    }
    catch (err: Str) { /* get_value_type failed, skip */ }
    result = result.concat(") {\n")

    // Save declared_vars before entering new scope (C allows redeclaration in new blocks)
    mut saved_declared_vars := ctx.declared_vars.clone()
    catch (err: AllocError) { throw err.msg }

    // Body
    mut body := Expr()
    expr.params.get(1, body)
    result = emit_body(body, result, add(indent, 1), ctx, context)

    // Restore declared_vars after exiting scope
    ctx.declared_vars = saved_declared_vars

    i = 0
    while lt(i, indent) {
        result = result.concat("    ")
        i = add(i, 1)
    }
    result = result.concat("}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

// Result struct for variant info extraction
VariantInfo := struct {
    mut type_name: Str = ""
    mut variant_name: Str = ""
}

// Extract enum type and variant names from a case pattern expression
// For FCall: Type.Variant -> VariantInfo { type_name: "Type", variant_name: "Variant" }
get_case_variant_info := func(expr: Expr) returns VariantInfo {
    mut result := VariantInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // FCall for Type.Variant (without payload extraction)
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return result }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                if gt(first.params.len(), 0) {
                    mut nested := Expr()
                    first.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return result }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        result.type_name = type_name
                        result.variant_name = variant_name
                        return result
                    case:
                        return result
                    }
                }
                return result
            case:
                return result
            }
        }
        return result
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if gt(expr.params.len(), 0) {
            mut nested := Expr()
            expr.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) {
                result.variant_name = name
                return result
            }
            switch nested.node_type {
            case NodeType.Identifier(variant_name):
                result.type_name = name
                result.variant_name = variant_name
                return result
            case:
                result.variant_name = name
                return result
            }
        }
        result.variant_name = name
        return result
    case:
        return result
    }
}

// Extract type name and variant name from a Pattern's variant_name (e.g., "Color.Green")
parse_pattern_variant_name := func(variant_name: Str) returns VariantInfo {
    mut result := VariantInfo()
    mut dot_pos := variant_name.rfind(".")
    if gteq(dot_pos, 0) {
        result.type_name = variant_name.get_substr(0, dot_pos)
        result.variant_name = variant_name.get_substr(add(dot_pos, 1), variant_name.len())
        catch (err: IndexOutOfBoundsError) {
            result.variant_name = variant_name
        }
        catch (err: AllocError) {
            result.variant_name = variant_name
        }
        return result
    }
    // No dot - just variant name (shouldn't happen in practice)
    result.variant_name = variant_name
    return result
}

emit_switch := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Switch: params[0] = switch expression
    // params[1..] = alternating (case_pattern, body) pairs
    // We emit if/else chains instead of C switch because:
    // 1. C switch only works with integer types, not Str
    // 2. Avoids GCC-specific case range extension
    // 3. More portable and easier to handle all TIL switch patterns
    if eq(expr.params.len(), 0) {
        throw "ccodegen: Switch requires expression"
    }

    mut result := output

    // Indentation strings
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    mut body_indent := ""
    ind = 0
    while lt(ind, add(indent, 1)) {
        body_indent = body_indent.concat("    ")
        ind = add(ind, 1)
    }

    // Get the switch expression
    mut switch_expr := Expr()
    expr.params.get(0, switch_expr)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Hoist any throwing function calls in the switch expression
    result = hoist_throwing_expr(switch_expr, result, indent, ctx, context)
    catch (err: AllocError) { throw "emit_switch: AllocError in hoist_throwing_expr" }
    catch (err: KeyNotFoundError) { throw "emit_switch: KeyNotFoundError in hoist_throwing_expr" }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Determine the type of the switch expression for proper comparison
    switch_type := infer_type_from_expr(switch_expr, context)
    mut is_str_switch := false
    switch switch_type {
    case ValueType.TCustom(type_name):
        is_str_switch = type_name.eq("Str")
    case:
    }

    // Determine if this is an enum switch and if it has payloads
    mut is_enum_switch := false
    mut enum_has_payloads_flag := false
    mut scan_i := 1
    while lt(scan_i, expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(scan_i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            is_enum_switch = true
        case NodeType.Identifier(name):
            if gt(case_pattern.params.len(), 0) {
                is_enum_switch = true
            } else if name.contains(".") {
                is_enum_switch = true
            }
        case:
        }
        scan_i = add(scan_i, 2)
    }
    if is_enum_switch {
        switch switch_type {
        case ValueType.TCustom(enum_name):
            mut enum_def := context.scope_stack.lookup_enum(enum_name)
            enum_has_payloads_flag = enum_has_payloads(enum_def)
            catch (err: KeyNotFoundError) { /* not an enum or not found */ }
        case:
        }
    }

    // Store switch expression in a temp variable to avoid re-evaluation
    switch_var := next_mangled()
    result = result.concat(indent_str)
    result = result.concat("__auto_type ")
    result = result.concat(switch_var)
    result = result.concat(" = ")
    result = emit_expr(switch_expr, result, 0, ctx, context)
    result = result.concat(";\n")

    // Collect cases, separating default case
    // We use two lists: case patterns and case bodies, plus a separate default_body
    mut case_patterns := Vec.new(Expr)
    catch (err: AllocError) { throw err.msg }
    mut case_bodies := Vec.new(Expr)
    catch (err: AllocError) { throw err.msg }
    mut default_body := Expr()
    mut has_default := false

    mut i := 1
    while lt(i, expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        mut case_body := Expr()
        if lt(add(i, 1), expr.params.len()) {
            expr.params.get(add(i, 1), case_body)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        switch case_pattern.node_type {
        case NodeType.DefaultCase:
            default_body = case_body
            has_default = true
        case:
            case_patterns.push(case_pattern)
            catch (err: AllocError) { throw err.msg }
            case_bodies.push(case_body)
            catch (err: AllocError) { throw err.msg }
        }
        i = add(i, 2)
    }

    // Emit if/else if chain for non-default cases
    mut case_idx := 0
    while lt(case_idx, case_patterns.len()) {
        mut case_pattern := Expr()
        case_patterns.get(case_idx, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        mut case_body := Expr()
        case_bodies.get(case_idx, case_body)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        result = result.concat(indent_str)
        if eq(case_idx, 0) {
            result = result.concat("if (")
        } else {
            result = result.concat("} else if (")
        }

        // Emit the condition based on pattern type
        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // Enum pattern with payload binding: compare tag
            info := parse_pattern_variant_name(pattern_info.variant_name)
            result = result.concat(switch_var)
            result = result.concat(".tag == til_")
            result = result.concat(info.type_name)
            result = result.concat("_")
            result = result.concat(info.variant_name)
            result = result.concat(") {\n")

            // Extract payload into binding variable
            result = result.concat(body_indent)
            result = result.concat("__auto_type ")
            result = result.concat(til_name(pattern_info.binding_var))
            result = result.concat(" = ")
            result = result.concat(switch_var)
            result = result.concat(".payload.")
            result = result.concat(info.variant_name)
            result = result.concat(";\n")
        case NodeType.Range:
            // Range: low <= val && val <= high
            if lt(case_pattern.params.len(), 2) {
                throw "ccodegen: Range requires start and end values"
            }
            mut range_start := Expr()
            case_pattern.params.get(0, range_start)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            mut range_end := Expr()
            case_pattern.params.get(1, range_end)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            result = emit_expr(range_start, result, 0, ctx, context)
            result = result.concat(" <= ")
            result = result.concat(switch_var)
            result = result.concat(" && ")
            result = result.concat(switch_var)
            result = result.concat(" <= ")
            result = emit_expr(range_end, result, 0, ctx, context)
            result = result.concat(") {\n")
        case NodeType.Identifier(name):
            info := get_case_variant_info(case_pattern)
            if gt(info.variant_name.len(), 0) {
                // Enum variant without payload
                result = result.concat(switch_var)
                if enum_has_payloads_flag {
                    result = result.concat(".tag")
                }
                result = result.concat(" == ")
                if gt(info.type_name.len(), 0) {
                    result = result.concat("til_")
                    result = result.concat(info.type_name)
                    result = result.concat("_")
                }
                result = result.concat(info.variant_name)
            } else if is_str_switch {
                // String comparison
                result = result.concat("til_Str_eq(")
                result = result.concat(switch_var)
                result = result.concat(", ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
                result = result.concat(").data")
            } else {
                // Regular value comparison
                result = result.concat(switch_var)
                result = result.concat(" == ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
            }
            result = result.concat(") {\n")
        case NodeType.LLiteral(lit):
            if is_str_switch {
                // String literal comparison
                result = result.concat("til_Str_eq(")
                result = result.concat(switch_var)
                result = result.concat(", ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
                result = result.concat(").data")
            } else {
                // Regular literal comparison
                result = result.concat(switch_var)
                result = result.concat(" == ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
            }
            result = result.concat(") {\n")
        case:
            // Generic case: emit equality comparison
            if is_str_switch {
                result = result.concat("til_Str_eq(")
                result = result.concat(switch_var)
                result = result.concat(", ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
                result = result.concat(").data")
            } else {
                result = result.concat(switch_var)
                result = result.concat(" == ")
                result = emit_expr(case_pattern, result, 0, ctx, context)
            }
            result = result.concat(") {\n")
        }

        // Emit case body - with scope for pattern bindings
        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // For pattern bindings, we need to declare the binding variable in scope
            // so that get_value_type can find it during body emission
            info := parse_pattern_variant_name(pattern_info.variant_name)

            // Look up the payload type from the enum definition
            mut payload_type := ValueType.TCustom("")
            mut have_payload_type := false
            switch switch_type {
            case ValueType.TCustom(enum_name):
                mut found_enum := false
                enum_def := context.scope_stack.lookup_enum(enum_name)
                found_enum = true
                catch (err: KeyNotFoundError) { }
                if found_enum {
                    // Found the enum, look up the variant's payload type (Ptr to ValueType, NULL = None)
                    mut payload_ptr := Ptr()
                    enum_def.enum_map.get(info.variant_name, payload_ptr)
                    catch (err: KeyNotFoundError) { }
                    // Check if payload exists (not NULL)
                    if not(NULL.eq(payload_ptr.data)) {
                        memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                        have_payload_type = true
                    }
                }
            case:
            }

            if have_payload_type {
                // Push a new scope and declare the binding variable
                context.scope_stack.push(ScopeType.Block)
                sym_info := SymbolInfo(
                    symbol_type = SymbolType.Variable,
                    value_type = payload_type,
                    is_mutable = false,
                )
                context.scope_stack.declare_symbol(pattern_info.binding_var, sym_info)
                result = emit_body(case_body, result, add(indent, 1), ctx, context)
                _ := context.scope_stack.pop()
            } else {
                result = emit_body(case_body, result, add(indent, 1), ctx, context)
            }
        case:
            result = emit_body(case_body, result, add(indent, 1), ctx, context)
        }

        case_idx = add(case_idx, 1)
    }

    // Emit default case as final else (if present)
    if has_default {
        if gt(case_patterns.len(), 0) {
            result = result.concat(indent_str)
            result = result.concat("} else {\n")
        }
        result = emit_body(default_body, result, add(indent, 1), ctx, context)
    }

    // Close the if/else chain
    if gt(case_patterns.len(), 0).or(has_default) {
        result = result.concat(indent_str)
        result = result.concat("}\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

emit_expr := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Check if this expression has been hoisted (for nested variadic/throwing calls)
    // Use line:col as unique key
    mut expr_key := expr.line.to_str().concat(":").concat(expr.col.to_str())
    if ctx.hoisted_exprs.contains_key(expr_key) {
        mut temp_var := ""
        ctx.hoisted_exprs.get(expr_key, temp_var)
        catch (err: KeyNotFoundError) { /* should not happen since we just checked contains_key */ }
        return output.concat(temp_var)
    }

    switch expr.node_type {
    case NodeType.Body:
        return emit_body(expr, output, indent, ctx, context)
    case NodeType.FCall:
        return emit_fcall(expr, output, indent, ctx, context)
    case NodeType.LLiteral(lit):
        return emit_literal(lit, output, context)
    case NodeType.Declaration(decl):
        return emit_declaration(decl, expr, output, indent, ctx, context)
    case NodeType.Identifier(name):
        // Check for type-qualified access (Type.field)
        if gt(expr.params.len(), 0) {
            mut first_char := name.get_substr(0, 1)
            // TODO: Use proper type info from AST instead of uppercase hack (see interpreter.til)
            if first_char.is_uppercase() {
                mut param := Expr()
                expr.params.get(0, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    // Check if this is an enum variant by looking up in context
                    mut is_enum_variant := false
                    mut enum_def := context.scope_stack.lookup_enum(name)
                    is_enum_variant = enum_def.enum_map.contains_key(field)
                    catch (err: KeyNotFoundError) { /* not an enum */ }

                    if is_enum_variant {
                        // Enum variant: Type.Variant -> til_Type_make_Variant()
                        mut result := concat(output, TIL_PREFIX)
                        result = result.concat(name)
                        result = result.concat("_make_")
                        result = result.concat(field)
                        result = result.concat("()")
                        return result
                    } else {
                        // Struct constant: Type.constant -> til_Type_constant
                        mut result := concat(output, TIL_PREFIX)
                        result = result.concat(name)
                        result = result.concat("_")
                        result = result.concat(field)
                        return result
                    }
                case:
                    // Fall through to regular handling
                }
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        // Regular identifier or field access (b.val -> til_b.val)
        // For mut params (which are pointers in C), use -> for field access
        mut is_mut_param := ctx.current_mut_params.contains(name)
        if is_mut_param.and(gt(expr.params.len(), 0)) {
            // Mut param with field access: til_self->field1.field2.field3
            // First field uses -> (self is a pointer), rest use . (struct values)
            mut result := concat(output, til_name(name))
            mut i := 0
            while lt(i, expr.params.len()) {
                mut param := Expr()
                expr.params.get(i, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    if i.eq(0) {
                        result = result.concat("->")
                    } else {
                        result = result.concat(".")
                    }
                    result = result.concat(field)
                case:
                    // Not a field access
                }
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            return result
        } else if is_mut_param {
            // Mut param used as value: dereference with *
            mut result := concat(output, "(*")
            result = result.concat(til_name(name))
            result = result.concat(")")
            return result
        } else {
            // Regular identifier or field access
            mut result := concat(output, til_name(name))
            mut i := 0
            while lt(i, expr.params.len()) {
                mut param := Expr()
                expr.params.get(i, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    result = result.concat(".")
                    result = result.concat(field)  // Field names stay as-is (C struct fields)
                case:
                    // Not a field access
                }
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            return result
        }
    case NodeType.FuncDef(func_def):
        return emit_funcdef(func_def, expr, output, indent, ctx, context)
    case NodeType.Assignment(name):
        return emit_assignment(name, expr, output, indent, ctx, context)
    case NodeType.Return:
        return emit_return(expr, output, indent, ctx, context)
    case NodeType.If:
        return emit_if(expr, output, indent, ctx, context)
    case NodeType.While:
        return emit_while(expr, output, indent, ctx, context)
    case NodeType.Catch:
        // Catch blocks handled at call site in emit_stmts
        return output
    case NodeType.Throw:
        return emit_throw(expr, output, indent, ctx, context)
    case NodeType.StructDef(s):
        throw "ccodegen: StructDef should be handled at top level, not in emit_expr"
    case NodeType.EnumDef(e):
        throw "ccodegen: EnumDef should be handled at top level, not in emit_expr"
    case NodeType.Switch:
        return emit_switch(expr, output, indent, ctx, context)
    case NodeType.DefaultCase:
        throw "ccodegen: DefaultCase should be handled inside emit_switch"
    case NodeType.Range:
        throw "ccodegen: Range not yet supported"
    case NodeType.Pattern(p):
        throw "ccodegen: Pattern should be handled inside emit_switch"
    case NodeType.NamedArg(_):
        throw expr.error(context.path, "ccodegen", "NamedArg should be reordered before reaching emit_expr")
    }
}

emit_body := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    return emit_stmts(expr.params, output, indent, ctx, context)
}

// Pre-scan function body to collect function-level catch blocks
// Collect ALL catch blocks - we'll register them all for local throw handling
// The emit_throwing_call handles immediate catch chains for function calls,
// but we need labels for throw statements that jump to these catches
// Returns a Vec<Expr> of catch blocks
prescan_func_level_catches := proc(stmts: Vec) returns Vec throws AllocError {
    mut catches := Vec.new(Expr)

    // Collect ALL catch blocks
    for i in 0..stmts.len() {
        mut stmt := Expr()
        stmts.get(i, stmt)
        catch (err: IndexOutOfBoundsError) { return catches }

        switch stmt.node_type {
        case NodeType.Catch:
            catches.push(stmt)
        case:
            // Continue scanning
        }
    }

    return catches
}

// Emit a sequence of statements with catch pattern detection
// This is the core logic for handling throw/catch at call sites
emit_stmts := proc(stmts: Vec, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    mut i := 0

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Pre-scan for function-level catches (at the end of the block)
    mut func_level_catches := prescan_func_level_catches(stmts)
    catch (err: AllocError) { throw err.msg }

    // Register function-level catches in ctx.local_catch_labels for throw statements
    // Generate unique labels for each catch block
    // Only register the FIRST catch for each error type (later ones will be unreachable for explicit throws)
    mut catch_suffix := next_mangled()
    mut catch_label_info := Vec.new(CatchLabelInfoEntry)  // (type_name, label, temp_var, catch_block)
    mut registered_types := Vec.new(Str)
    mut ci := 0
    while lt(ci, func_level_catches.len()) {
        mut catch_block := Expr()
        func_level_catches.get(ci, catch_block)
        if gteq(catch_block.params.len(), 3) {
            mut err_type_expr := Expr()
            catch_block.params.get(1, err_type_expr)
            switch err_type_expr.node_type {
            case NodeType.Identifier(err_type_name):
                // Only register the first catch for each type
                mut already_registered := false
                mut ri := 0
                while lt(ri, registered_types.len()) {
                    mut rt := ""
                    registered_types.get(ri, rt)
                    if rt.eq(err_type_name) {
                        already_registered = true
                    }
                    ri = add(ri, 1)
                }
                if not(already_registered) {
                    registered_types.push(err_type_name)
                    mut label := format("_catch_", err_type_name, "_", catch_suffix)
                    mut temp_var := format("_thrown_", err_type_name, "_", catch_suffix)
                    mut info := CatchLabelInfo()
                    info.label = label
                    info.temp_var = temp_var
                    ctx.local_catch_labels.set(err_type_name, info)
                    mut entry := CatchLabelInfoEntry()
                    entry.type_name = err_type_name
                    entry.label = label
                    entry.temp_var = temp_var
                    entry.catch_block = catch_block
                    catch_label_info.push(entry)

                    // Declare temp variable to store thrown error value
                    result = result.concat(indent_str)
                    result = result.concat(til_name(err_type_name))
                    result = result.concat(" ")
                    result = result.concat(temp_var)
                    result = result.concat(";\n")
                }
            case:
                // Not an identifier, skip
            }
        }
        ci = add(ci, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }

    while lt(i, stmts.len()) {
        mut stmt := Expr()
        stmts.get(i, stmt)

        // Check if this statement is followed by catch blocks
        // And if it's a call to a throwing function (FCall, Declaration with FCall, or Assignment with FCall)
        mut maybe_fcall := Expr()
        mut has_fcall := false
        mut maybe_decl_name := ""
        mut has_decl := false
        mut maybe_assign_name := ""
        mut has_assign := false

        switch stmt.node_type {
        case NodeType.FCall:
            maybe_fcall = stmt
            has_fcall = true
        case NodeType.Declaration(decl):
            // Check if declaration has an FCall as initializer
            if gt(stmt.params.len(), 0) {
                mut first := Expr()
                stmt.params.get(0, first)
                switch first.node_type {
                case NodeType.FCall:
                    maybe_fcall = first
                    has_fcall = true
                    maybe_decl_name = decl.name
                    has_decl = true
                case:
                    // Not an FCall
                }
                catch (err: IndexOutOfBoundsError) { /* no initializer */ }
            }
        case NodeType.Assignment(name):
            // Check if assignment has an FCall as RHS
            if gt(stmt.params.len(), 0) {
                mut first := Expr()
                stmt.params.get(0, first)
                switch first.node_type {
                case NodeType.FCall:
                    maybe_fcall = first
                    has_fcall = true
                    maybe_assign_name = name
                    has_assign = true
                case:
                    // Not an FCall
                }
                catch (err: IndexOutOfBoundsError) { /* no RHS */ }
            }
        case:
            // Not FCall, Declaration, or Assignment
        }

        if has_fcall {
            // Get function name from the FCall
            mut func_name := get_fcall_func_name(maybe_fcall)

            // Check if this function is a throwing function
            if gt(func_name.len(), 0) {
                mut throw_types := Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }
                mut is_throwing := false
                mut lookup_result := lookup_func_by_name(context, func_name)
                if lookup_result.found {
                    if gt(lookup_result.func_def.throw_types.len(), 0) {
                        throw_types = lookup_result.func_def.throw_types
                        is_throwing = true
                    }
                }

                if is_throwing {
                    // Collect subsequent catch blocks
                    mut catch_blocks := Vec.new(Expr)
                    catch (err: AllocError) { throw err.msg }
                    mut j := add(i, 1)
                    while lt(j, stmts.len()) {
                        mut next_stmt := Expr()
                        stmts.get(j, next_stmt)
                        switch next_stmt.node_type {
                        case NodeType.Catch:
                            catch_blocks.push(next_stmt)
                            catch (err: AllocError) { throw err.msg }
                            j = add(j, 1)
                        case:
                            // Not a catch block, stop
                            j = stmts.len()  // break out of loop
                        }
                        catch (err: IndexOutOfBoundsError) { j = stmts.len() }
                    }

                    if gt(catch_blocks.len(), 0) {
                        // Emit throwing call with catch handling
                        if has_decl {
                            result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, maybe_decl_name, "", result, indent, ctx, context)
                        } else {
                            if has_assign {
                                result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, "", maybe_assign_name, result, indent, ctx, context)
                            } else {
                                result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, "", "", result, indent, ctx, context)
                            }
                        }
                        i = add(i, add(1, catch_blocks.len()))  // Skip past catch blocks
                    } else {
                        // No catch blocks - check if we're inside a throwing function
                        if gt(ctx.current_throw_types.len(), 0) {
                            // We're in a throwing function, propagate errors to caller
                            if has_decl {
                                result = emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                            } else {
                                if has_assign {
                                    result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                } else {
                                    result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                }
                            }
                        } else {
                            if gt(func_level_catches.len(), 0) {
                                // No immediate catch, not a throwing function, but has function-level catches
                                // Use goto to jump to the catch labels (already registered in local_catch_labels)
                                // This ensures that statements between the throwing call and the catch are skipped on error
                                if has_decl {
                                    result = emit_throwing_call_with_goto(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                                } else {
                                    if has_assign {
                                        result = emit_throwing_call_with_goto(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                    } else {
                                        result = emit_throwing_call_with_goto(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                    }
                                }
                            } else {
                                if gt(ctx.local_catch_labels.len(), 0) {
                                    // No catches in THIS block, but there are outer catches registered
                                    // Emit throwing call that jumps to catch labels on error
                                    if has_decl {
                                        result = emit_throwing_call_with_goto(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                                    } else {
                                        if has_assign {
                                            result = emit_throwing_call_with_goto(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                        } else {
                                            result = emit_throwing_call_with_goto(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                        }
                                    }
                                } else {
                                    // No catches - typer should have caught this if we're in non-throwing context
                                    // Just use propagate (will silently succeed on error if we're not throwing)
                                    if has_decl {
                                        result = emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                                    } else {
                                        if has_assign {
                                            result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                        } else {
                                            result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                        }
                                    }
                                }
                            }
                        }
                        i = add(i, 1)
                    }
                } else {
                    // Not a throwing function - check for variadic call
                    mut variadic_info := detect_variadic_fcall(maybe_fcall, ctx)
                    if variadic_info.is_variadic {
                        // Emit variadic call with proper array construction
                        if has_decl {
                            result = emit_variadic_call(maybe_fcall, variadic_info.elem_type, variadic_info.regular_count, maybe_decl_name, "", result, indent, ctx, context)
                        } else {
                            if has_assign {
                                result = emit_variadic_call(maybe_fcall, variadic_info.elem_type, variadic_info.regular_count, "", maybe_assign_name, result, indent, ctx, context)
                            } else {
                                result = emit_variadic_call(maybe_fcall, variadic_info.elem_type, variadic_info.regular_count, "", "", result, indent, ctx, context)
                            }
                        }
                    } else {
                        // Regular non-throwing, non-variadic statement
                        result = emit_expr(stmt, result, indent, ctx, context)
                    }
                    i = add(i, 1)
                }
            } else {
                // Couldn't get function name, emit regular statement
                result = emit_expr(stmt, result, indent, ctx, context)
                i = add(i, 1)
            }
        } else {
            // Regular statement handling
            result = emit_expr(stmt, result, indent, ctx, context)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Emit function-level catch blocks with labels
    // These are jumped to by explicit throw statements
    // Each catch is wrapped in a block {} to allow same error var name with different types
    if gt(catch_label_info.len(), 0) {
        // Jump over catch blocks in normal execution
        mut end_catches_label := format("_end_catches_", catch_suffix)
        result = result.concat(indent_str)
        result = result.concat("goto ")
        result = result.concat(end_catches_label)
        result = result.concat(";\n")

        mut cli := 0
        while lt(cli, catch_label_info.len()) {
            mut entry := CatchLabelInfoEntry()
            catch_label_info.get(cli, entry)

            // Emit label with a block scope to avoid C variable redefinition errors
            result = result.concat(entry.label)
            result = result.concat(": {\n")

            // Bind error variable from the temp storage
            if gt(entry.catch_block.params.len(), 0) {
                mut err_var_expr := Expr()
                entry.catch_block.params.get(0, err_var_expr)
                switch err_var_expr.node_type {
                case NodeType.Identifier(err_var_name):
                    result = result.concat(indent_str)
                    result = result.concat(til_name(entry.type_name))
                    result = result.concat(" ")
                    result = result.concat(til_name(err_var_name))
                    result = result.concat(" = ")
                    result = result.concat(entry.temp_var)
                    result = result.concat(";\n")

                    // Add error variable to scope for type resolution in catch body
                    context.scope_stack.declare_symbol(err_var_name, SymbolInfo.new(ValueType.TCustom(entry.type_name), false, false, false))
                case:
                    // Skip non-identifier
                }
            }

            // Emit catch body
            if gteq(entry.catch_block.params.len(), 3) {
                mut catch_body := Expr()
                entry.catch_block.params.get(2, catch_body)
                result = emit_expr(catch_body, result, indent, ctx, context)
            }

            // Jump to end of catches to avoid falling through to next catch
            result = result.concat(indent_str)
            result = result.concat("goto ")
            result = result.concat(end_catches_label)
            result = result.concat(";\n")

            // Close the block
            result = result.concat(indent_str)
            result = result.concat("}\n")

            cli = add(cli, 1)
        }

        // End of catch blocks label
        result = result.concat(end_catches_label)
        result = result.concat(":;\n")
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    // Clean up local_catch_labels for this block
    mut clean_i := 0
    while lt(clean_i, catch_label_info.len()) {
        mut entry := CatchLabelInfoEntry()
        catch_label_info.get(clean_i, entry)
        ctx.local_catch_labels.remove(entry.type_name)
        clean_i = add(clean_i, 1)
    }
    catch (err: IndexOutOfBoundsError) { /* ignore */ }

    return result
}

/// Emit a non-throwing variadic function call at statement level
/// Handles constructing the variadic array and cleaning it up after the call
emit_variadic_call := proc(fcall: Expr, elem_type: Str, regular_count: I64, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    if eq(func_name.len(), 0) {
        throw "emit_variadic_call: could not get function name"
    }

    // Calculate param info for mut param handling
    mut param_is_mut := Vec.new(Bool)
    mut lookup_result := lookup_func_by_name(context, func_name)
    mut pi := 0
    while lt(pi, sub(fcall.params.len(), 1)) {
        mut is_mut := false
        if lookup_result.found {
            if lt(pi, lookup_result.func_def.args.len()) {
                mut arg_decl := Declaration()
                lookup_result.func_def.args.get(pi, arg_decl)
                is_mut = arg_decl.is_mut
            }
        }
        param_is_mut.push(is_mut)
        pi = add(pi, 1)
    }

    // Hoist any throwing function calls in arguments BEFORE constructing variadic array
    mut hoisted := Map.new(I64, Str)
    if gt(fcall.params.len(), 1) {
        mut args := Vec.new(Expr)
        mut ai := 1
        while lt(ai, fcall.params.len()) {
            mut arg := Expr()
            fcall.params.get(ai, arg)
            args.push(arg)
            ai = add(ai, 1)
        }
        mut hoisted_vec := hoist_throwing_args(args, result, indent, ctx, context)
        // Convert Vec<HoistedArg> to Map<I64, Str>
        mut hi := 0
        while lt(hi, hoisted_vec.len()) {
            mut entry := HoistedArg()
            hoisted_vec.get(hi, entry)
            hoisted.set(entry.index, entry.temp_var)
            hi = add(hi, 1)
        }
    }

    // Construct variadic array
    mut variadic_args := Vec.new(Expr)
    mut vai := add(1, regular_count)
    while lt(vai, fcall.params.len()) {
        mut arg := Expr()
        fcall.params.get(vai, arg)
        variadic_args.push(arg)
        vai = add(vai, 1)
    }
    mut variadic_arr_var := hoist_variadic_args(elem_type, variadic_args, hoisted, regular_count, result, indent, ctx, context)

    // Determine return type if we need to declare a variable
    mut ret_type := "int"
    if gt(decl_name.len(), 0).or(gt(assign_name.len(), 0)) {
        if lookup_result.found {
            if gt(lookup_result.func_def.return_types.len(), 0) {
                mut first_ret := ValueType.TCustom("")
                lookup_result.func_def.return_types.get(0, first_ret)
                mut c_type := til_type_to_c(first_ret)
                if gt(c_type.len(), 0) {
                    ret_type = c_type
                }
            }
        }
    }

    // For declarations: declare the variable
    if gt(decl_name.len(), 0) {
        result = result.concat(indent_str)
        result = result.concat(ret_type)
        result = result.concat(" ")
        result = result.concat(til_name(decl_name))
        result = result.concat(" = ")

        // Emit function call
        result = result.concat(TIL_PREFIX)
        result = result.concat(func_name.replace(".", "_"))
        result = result.concat("(")

        // Emit regular args first
        mut rai := 0
        while lt(rai, regular_count) {
            if gt(rai, 0) {
                result = result.concat(", ")
            }
            mut is_mut := false
            param_is_mut.get(rai, is_mut)
            catch (err: IndexOutOfBoundsError) { }
            result = emit_arg_with_mut(fcall, add(rai, 1), hoisted, is_mut, result, ctx, context)
            rai = add(rai, 1)
        }

        // Emit variadic array pointer
        if gt(regular_count, 0) {
            result = result.concat(", ")
        }
        result = result.concat("&")
        result = result.concat(variadic_arr_var)
        result = result.concat(");\n")

        // Add variable to scope
        if lookup_result.found {
            if gt(lookup_result.func_def.return_types.len(), 0) {
                mut first_type := ValueType.TCustom("")
                lookup_result.func_def.return_types.get(0, first_type)
                context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
            }
        }
        _ := ctx.declared_vars.insert(til_name(decl_name))
    } else {
        if gt(assign_name.len(), 0) {
            // Assignment
            result = result.concat(indent_str)
            result = result.concat(til_name(assign_name))
            result = result.concat(" = ")

            // Emit function call
            result = result.concat(TIL_PREFIX)
            result = result.concat(func_name.replace(".", "_"))
            result = result.concat("(")

            // Emit regular args first
            mut rai := 0
            while lt(rai, regular_count) {
                if gt(rai, 0) {
                    result = result.concat(", ")
                }
                mut is_mut := false
                param_is_mut.get(rai, is_mut)
                catch (err: IndexOutOfBoundsError) { }
                result = emit_arg_with_mut(fcall, add(rai, 1), hoisted, is_mut, result, ctx, context)
                rai = add(rai, 1)
            }

            // Emit variadic array pointer
            if gt(regular_count, 0) {
                result = result.concat(", ")
            }
            result = result.concat("&")
            result = result.concat(variadic_arr_var)
            result = result.concat(");\n")
        } else {
            // Standalone variadic call (no return value used)
            result = result.concat(indent_str)
            result = result.concat(TIL_PREFIX)
            result = result.concat(func_name.replace(".", "_"))
            result = result.concat("(")

            // Emit regular args first
            mut rai := 0
            while lt(rai, regular_count) {
                if gt(rai, 0) {
                    result = result.concat(", ")
                }
                mut is_mut := false
                param_is_mut.get(rai, is_mut)
                catch (err: IndexOutOfBoundsError) { }
                result = emit_arg_with_mut(fcall, add(rai, 1), hoisted, is_mut, result, ctx, context)
                rai = add(rai, 1)
            }

            // Emit variadic array pointer
            if gt(regular_count, 0) {
                result = result.concat(", ")
            }
            result = result.concat("&")
            result = result.concat(variadic_arr_var)
            result = result.concat(");\n")
        }
    }

    // Clean up variadic array
    result = result.concat(indent_str)
    result = result.concat(TIL_PREFIX)
    result = result.concat("Array_delete(&")
    result = result.concat(variadic_arr_var)
    result = result.concat(");\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

/// Helper to emit an argument with mut parameter handling
emit_arg_with_mut := proc(fcall: Expr, arg_idx: I64, hoisted: Map, is_mut: Bool, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Check if this arg was hoisted
    mut hoisted_var := ""
    mut was_hoisted := false
    hoisted.get(sub(arg_idx, 1), hoisted_var)
    was_hoisted = true
    catch (err: KeyNotFoundError) { }

    if was_hoisted {
        // Use hoisted temp var
        if is_mut {
            result = result.concat("&")
        }
        result = result.concat(hoisted_var)
    } else {
        // Emit the argument expression
        mut arg := Expr()
        fcall.params.get(arg_idx, arg)
        if is_mut {
            result = result.concat("&")
        }
        result = emit_expr(arg, result, 0, ctx, context)
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Emit a call to a throwing function with catch handling
// Generates: declare temps, call func, if/else chain for error handling
emit_throwing_call := proc(fcall: Expr, throw_types: Vec, catch_blocks: Vec, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := next_mangled()

    // Determine if we need a return value temp variable
    mut needs_ret := false
    if gt(decl_name.len(), 0) { needs_ret = true }
    if gt(assign_name.len(), 0) { needs_ret = true }

    // Calculate param_types early for Dynamic hoisting
    mut param_types := Vec.new(ValueType)
    mut func_def_lookup := context.scope_stack.lookup_func(func_name)
    mut arg_i := 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_types.push(arg_decl.value_type)
        } else {
            param_types.push(ValueType.TCustom(""))
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call: AllocError in param_types" }

    // Calculate param_is_mut for pointer passing
    mut param_is_mut := Vec.new(Bool)
    func_def_lookup = context.scope_stack.lookup_func(func_name)
    arg_i = 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_is_mut.push(arg_decl.is_mut)
        } else {
            param_is_mut.push(false)
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call: AllocError in param_is_mut" }

    // Hoist any throwing function calls in arguments BEFORE emitting this call
    mut hoisted := Map.new(I64, Str)
    if gt(fcall.params.len(), 1) {
        mut hoisted_vec := hoist_throwing_args(fcall.params, result, indent, ctx, context)
        // Convert Vec<HoistedArg> to Map<I64, Str>
        mut hvi := 0
        while lt(hvi, hoisted_vec.len()) {
            mut entry := HoistedArg()
            hoisted_vec.get(hvi, entry)
            hoisted.set(entry.index, entry.temp_var)
            hvi = add(hvi, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call: AllocError in hoist_throwing_args" }

    // Hoist non-lvalue args (string literals, function calls) when param type is Dynamic
    if gt(fcall.params.len(), 1) {
        mut dynamic_hoisted := hoist_for_dynamic_params(fcall.params, param_types, hoisted, result, indent, ctx, context)
        // Merge dynamic_hoisted into hoisted
        mut dh_idx := 0
        while lt(dh_idx, dynamic_hoisted.len()) {
            mut dh := HoistedArg()
            dynamic_hoisted.get(dh_idx, dh)
            hoisted.set(dh.index, dh.temp_var)
            dh_idx = add(dh_idx, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call: AllocError in hoist_for_dynamic_params" }

    // Declare local variables for return value and errors
    // Look up the actual return type from scope_stack
    mut ret_type := "int"
    if needs_ret {
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
        }
        catch (err: KeyNotFoundError) { /* use default int */ }
        catch (err: IndexOutOfBoundsError) { /* use default int */ }
        result = result.concat(indent_str)
        result = result.concat(ret_type)
        result = result.concat(" _ret_")
        result = result.concat(temp_suffix)
        result = result.concat(";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            result = result.concat(indent_str)
            result = result.concat(ret_type)
            result = result.concat(" ")
            result = result.concat(decl_name)
            result = result.concat(";\n")
            // Add to scope_stack for type resolution
            mut fd := context.scope_stack.lookup_func(func_name)
            if gt(fd.return_types.len(), 0) {
                mut first_type := ValueType.TCustom("")
                fd.return_types.get(0, first_type)
                context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
            }
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type
    // Use = {} to avoid warning for empty structs
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = result.concat(indent_str)
            result = result.concat(type_name)
            result = result.concat(" _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = {};\n")
        case:
            // Non-custom type, use int
            result = result.concat(indent_str)
            result = result.concat("int _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Check if this is a variadic function call and construct array BEFORE the call
    mut variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""
    if variadic_info.is_variadic {
        mut variadic_args := Vec.new(Expr)
        mut va_idx := add(1, variadic_info.regular_count)
        while lt(va_idx, fcall.params.len()) {
            mut va_arg := Expr()
            fcall.params.get(va_idx, va_arg)
            variadic_args.push(va_arg)
            va_idx = add(va_idx, 1)
        }
        variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, result, indent, ctx, context)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw "emit_throwing_call: AllocError in variadic handling" }

    // Generate the function call with output parameters
    result = result.concat(indent_str)
    result = result.concat("int _status_")
    result = result.concat(temp_suffix)
    result = result.concat(" = ")
    result = result.concat(til_func_name(func_name))
    result = result.concat("(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if needs_ret {
        result = result.concat("&_ret_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = result.concat(", ")
        }
        result = result.concat("&_err")
        result = result.concat(i.to_str())
        result = result.concat("_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Emit arguments - handle variadic separately from regular args
    if variadic_info.is_variadic {
        // Variadic call: emit regular args first, then variadic array pointer
        i = 1
        while lt(i, add(1, variadic_info.regular_count)) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            mut arg := Expr()
            fcall.params.get(i, arg)
            mut arg_idx := sub(i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type and mutability for this argument
            mut is_dynamic_param := false
            mut is_mut := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }
            if lt(arg_idx, param_is_mut.len()) {
                param_is_mut.get(arg_idx, is_mut)
            }

            if found_hoisted {
                result = result.concat(hoisted_temp)
            } else if is_dynamic_param {
                result = result.concat("(til_Dynamic*)&")
                result = emit_expr(arg, result, 0, ctx, context)
            } else if is_mut {
                result = result.concat("&")
                result = emit_expr(arg, result, 0, ctx, context)
            } else {
                result = emit_expr(arg, result, 0, ctx, context)
            }
            param_count = add(param_count, 1)
            i = add(i, 1)
        }

        // Emit variadic array pointer
        if gt(variadic_arr_var.len(), 0) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            result = result.concat("&")
            result = result.concat(variadic_arr_var)
        }
    } else {
        // Non-variadic: emit all args directly
        mut args_started := false
        i = 1
        while lt(i, fcall.params.len()) {
            if args_started {
                result = result.concat(", ")
            } else {
                if gt(param_count, 0) {
                    result = result.concat(", ")
                }
            }
            mut arg := Expr()
            fcall.params.get(i, arg)
            mut arg_idx := sub(i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type for this argument
            mut is_dynamic_param := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }

            if found_hoisted {
                // Hoisted temp var is an lvalue - add & if param is Dynamic
                if is_dynamic_param {
                    result = result.concat("&")
                }
                result = result.concat(hoisted_temp)
            } else {
                // Check if arg is a type identifier - emit as string literal
                mut type_arg := get_type_arg_name(arg, context)
                if type_arg.found {
                    result = result.concat("\"")
                    result = result.concat(type_arg.type_name)
                    result = result.concat("\"")
                } else {
                    // Check if param is Dynamic and arg is simple identifier
                    if is_dynamic_param {
                        switch arg.node_type {
                        case NodeType.Identifier(name):
                            if eq(arg.params.len(), 0) {
                                // Simple variable - emit &var
                                result = result.concat("&")
                                result = result.concat(til_name(name))
                            } else {
                                // Not simple - emit as is
                                result = emit_expr(arg, result, 0, ctx, context)
                            }
                        case:
                            result = emit_expr(arg, result, 0, ctx, context)
                        }
                    } else {
                        result = emit_expr(arg, result, 0, ctx, context)
                    }
                }
            }
            args_started = true
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = result.concat(");\n")

    // Generate if/else chain for error handling
    result = result.concat(indent_str)
    result = result.concat("if (_status_")
    result = result.concat(temp_suffix)
    result = result.concat(" == 0) {\n")

    // Success case: assign return value to target variable
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            // Declaration: assign to newly declared variable (declared before if block)
            mut inner_indent := ""
            ind = 0
            while lt(ind, add(indent, 1)) {
                inner_indent = inner_indent.concat("    ")
                ind = add(ind, 1)
            }
            result = result.concat(inner_indent)
            result = result.concat(decl_name)
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    } else {
        if gt(assign_name.len(), 0) {
            // Assignment: assign to existing variable
            mut inner_indent := ""
            ind = 0
            while lt(ind, add(indent, 1)) {
                inner_indent = inner_indent.concat("    ")
                ind = add(ind, 1)
            }
            result = result.concat(inner_indent)
            result = result.concat(assign_name)
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    }

    result = result.concat(indent_str)
    result = result.concat("}")

    // Generate else-if branches for each catch block
    i = 0
    while lt(i, catch_blocks.len()) {
        mut catch_block := Expr()
        catch_blocks.get(i, catch_block)

        // catch block params: [0]=var_name, [1]=type_name, [2]=body
        if gteq(catch_block.params.len(), 3) {
            // Get error type name from catch block
            mut err_type_name := ""
            mut err_type_expr := Expr()
            catch_block.params.get(1, err_type_expr)
            switch err_type_expr.node_type {
            case NodeType.Identifier(type_name):
                err_type_name = type_name
            case:
                err_type_name = ""
            }

            if err_type_name.len().gt(0) {
                // Find index of this error type in throw_types
                mut err_idx := sub(0, 1)  // -1 = not found
                mut j := 0
                while lt(j, throw_types.len()) {
                    mut vt := ValueType.TFunction
                    throw_types.get(j, vt)
                    switch vt {
                    case ValueType.TCustom(type_name):
                        if type_name.eq(err_type_name) {
                            err_idx = j
                        }
                    case:
                        // Not a custom type
                    }
                    j = add(j, 1)
                }

                if gteq(err_idx, 0) {
                    result = result.concat(" else if (_status_")
                    result = result.concat(temp_suffix)
                    result = result.concat(" == ")
                    result = result.concat(add(err_idx, 1).to_str())
                    result = result.concat(") {\n")

                    // Bind error variable and add to scope for type resolution
                    mut err_var_name := ""
                    mut err_var_expr := Expr()
                    catch_block.params.get(0, err_var_expr)
                    switch err_var_expr.node_type {
                    case NodeType.Identifier(var_name):
                        err_var_name = var_name

                        mut inner_indent := ""
                        mut ind2 := 0
                        while lt(ind2, add(indent, 1)) {
                            inner_indent = inner_indent.concat("    ")
                            ind2 = add(ind2, 1)
                        }
                        result = result.concat(inner_indent)
                        result = result.concat(til_name(err_type_name))
                        result = result.concat(" ")
                        result = result.concat(til_name(err_var_name))
                        result = result.concat(" = _err")
                        result = result.concat(err_idx.to_str())
                        result = result.concat("_")
                        result = result.concat(temp_suffix)
                        result = result.concat(";\n")

                        // Add error variable to scope for type resolution in catch body
                        context.scope_stack.declare_symbol(err_var_name, SymbolInfo.new(ValueType.TCustom(err_type_name), false, false, false))
                    case:
                        // Not an identifier
                    }

                    // Emit catch body (params[2])
                    mut body_expr := Expr()
                    catch_block.params.get(2, body_expr)
                    result = emit_expr(body_expr, result, add(indent, 1), ctx, context)

                    result = result.concat(indent_str)
                    result = result.concat("}")
                }
            }
        }

        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = result.concat("\n")
    return result
}

// Emit a call to a throwing function WITHOUT catch blocks - propagate errors to caller
// Used when inside a throwing function that can forward the same error types
emit_throwing_call_propagate := proc(fcall: Expr, throw_types: Vec, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call_propagate: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := next_mangled()

    // Determine if we need a return value temp variable
    mut needs_ret := false
    if gt(decl_name.len(), 0) { needs_ret = true }
    if gt(assign_name.len(), 0) { needs_ret = true }

    // Calculate param_types early for Dynamic hoisting
    mut param_types := Vec.new(ValueType)
    mut func_def_lookup := context.scope_stack.lookup_func(func_name)
    mut arg_i := 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_types.push(arg_decl.value_type)
        } else {
            param_types.push(ValueType.TCustom(""))
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call_propagate: AllocError in param_types" }

    // Calculate param_is_mut for pointer passing
    mut param_is_mut := Vec.new(Bool)
    func_def_lookup = context.scope_stack.lookup_func(func_name)
    arg_i = 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_is_mut.push(arg_decl.is_mut)
        } else {
            param_is_mut.push(false)
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call_propagate: AllocError in param_is_mut" }

    // Hoist any throwing function calls in arguments BEFORE emitting this call
    mut hoisted := Map.new(I64, Str)
    if gt(fcall.params.len(), 1) {
        mut hoisted_vec := hoist_throwing_args(fcall.params, result, indent, ctx, context)
        // Convert Vec<HoistedArg> to Map<I64, Str>
        mut hvi := 0
        while lt(hvi, hoisted_vec.len()) {
            mut entry := HoistedArg()
            hoisted_vec.get(hvi, entry)
            hoisted.set(entry.index, entry.temp_var)
            hvi = add(hvi, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call_propagate: AllocError in hoist_throwing_args" }

    // Hoist non-lvalue args (string literals, function calls) when param type is Dynamic
    if gt(fcall.params.len(), 1) {
        mut dynamic_hoisted := hoist_for_dynamic_params(fcall.params, param_types, hoisted, result, indent, ctx, context)
        // Merge dynamic_hoisted into hoisted
        mut dh_idx := 0
        while lt(dh_idx, dynamic_hoisted.len()) {
            mut dh := HoistedArg()
            dynamic_hoisted.get(dh_idx, dh)
            hoisted.set(dh.index, dh.temp_var)
            dh_idx = add(dh_idx, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call_propagate: AllocError in hoist_for_dynamic_params" }

    // Look up the actual return type from scope_stack
    mut ret_type := "int"
    if needs_ret {
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
        }
        catch (err: KeyNotFoundError) { /* use default int */ }
        catch (err: IndexOutOfBoundsError) { /* use default int */ }
    }

    // Declare temp for return value if needed
    if needs_ret {
        result = result.concat(indent_str)
        result = result.concat(ret_type)
        result = result.concat(" _ret_")
        result = result.concat(temp_suffix)
        result = result.concat(";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            result = result.concat(indent_str)
            result = result.concat(ret_type)
            result = result.concat(" ")
            result = result.concat(decl_name)
            result = result.concat(";\n")
            // Add to scope_stack for type resolution
            mut fd := context.scope_stack.lookup_func(func_name)
            if gt(fd.return_types.len(), 0) {
                mut first_type := ValueType.TCustom("")
                fd.return_types.get(0, first_type)
                context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
            }
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type of the called function
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = result.concat(indent_str)
            result = result.concat(type_name)
            result = result.concat(" _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = {};\n")
        case:
            // Non-custom type, use int
            result = result.concat(indent_str)
            result = result.concat("int _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Check if this is a variadic function call and construct array BEFORE the call
    mut variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""
    if variadic_info.is_variadic {
        mut variadic_args := Vec.new(Expr)
        mut va_idx := add(1, variadic_info.regular_count)
        while lt(va_idx, fcall.params.len()) {
            mut va_arg := Expr()
            fcall.params.get(va_idx, va_arg)
            variadic_args.push(va_arg)
            va_idx = add(va_idx, 1)
        }
        variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, result, indent, ctx, context)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw "emit_throwing_call_propagate: AllocError in variadic handling" }

    // Generate the function call with output parameters
    result = result.concat(indent_str)
    result = result.concat("int _status_")
    result = result.concat(temp_suffix)
    result = result.concat(" = ")
    result = result.concat(til_func_name(func_name))
    result = result.concat("(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if needs_ret {
        result = result.concat("&_ret_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = result.concat(", ")
        }
        result = result.concat("&_err")
        result = result.concat(i.to_str())
        result = result.concat("_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Emit arguments - handle variadic separately from regular args
    if variadic_info.is_variadic {
        // Variadic call: emit regular args first, then variadic array pointer
        mut arg_i := 1
        while lt(arg_i, add(1, variadic_info.regular_count)) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            mut arg := Expr()
            fcall.params.get(arg_i, arg)
            mut arg_idx := sub(arg_i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type for this argument
            mut is_dynamic_param := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }

            if found_hoisted {
                if is_dynamic_param {
                    result = result.concat("&")
                }
                result = result.concat(hoisted_temp)
            } else {
                result = emit_expr(arg, result, 0, ctx, context)
            }
            param_count = add(param_count, 1)
            arg_i = add(arg_i, 1)
        }

        // Emit variadic array pointer
        if gt(variadic_arr_var.len(), 0) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            result = result.concat("&")
            result = result.concat(variadic_arr_var)
        }
    } else {
        // Non-variadic: emit all args directly
        mut args_started := false
        i = 1
        while lt(i, fcall.params.len()) {
            if args_started {
                result = result.concat(", ")
            } else {
                if gt(param_count, 0) {
                    result = result.concat(", ")
                }
            }
            mut arg := Expr()
            fcall.params.get(i, arg)
            mut arg_idx := sub(i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type for this argument
            mut is_dynamic_param := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }

            if found_hoisted {
                if is_dynamic_param {
                    result = result.concat("&")
                }
                result = result.concat(hoisted_temp)
            } else {
                // Check if arg is a type identifier - emit as string literal
                mut type_arg := get_type_arg_name(arg, context)
                if type_arg.found {
                    result = result.concat("\"")
                    result = result.concat(type_arg.type_name)
                    result = result.concat("\"")
                } else {
                    // Check if param is Dynamic and arg is simple identifier
                    if is_dynamic_param {
                        switch arg.node_type {
                        case NodeType.Identifier(name):
                            if eq(arg.params.len(), 0) {
                                // Simple variable - emit &var
                                result = result.concat("&")
                                result = result.concat(til_name(name))
                            } else {
                                // Not simple - emit as is
                                result = emit_expr(arg, result, 0, ctx, context)
                            }
                        case:
                            result = emit_expr(arg, result, 0, ctx, context)
                        }
                    } else {
                        result = emit_expr(arg, result, 0, ctx, context)
                    }
                }
            }
            args_started = true
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = result.concat(");\n")

    // Generate error propagation: if status != 0, copy error to caller's error param and return
    // Map error types from called function to current function's error params
    mut called_idx := 0
    while lt(called_idx, throw_types.len()) {
        mut called_throw_type := ValueType.TCustom("")
        throw_types.get(called_idx, called_throw_type)
        switch called_throw_type {
        case ValueType.TCustom(called_type_name):
            // Find matching error type in current function's throw types
            mut curr_idx := 0
            mut found := false
            while lt(curr_idx, ctx.current_throw_types.len()) {
                mut curr_throw := ValueType.TCustom("")
                ctx.current_throw_types.get(curr_idx, curr_throw)
                switch curr_throw {
                case ValueType.TCustom(curr_name):
                    if curr_name.eq(called_type_name) {
                        // Found matching error type, generate propagation
                        result = result.concat(indent_str)
                        result = result.concat("if (_status_")
                        result = result.concat(temp_suffix)
                        result = result.concat(" == ")
                        result = result.concat(add(called_idx, 1).to_str())
                        result = result.concat(") { *_err")
                        result = result.concat(add(curr_idx, 1).to_str())
                        result = result.concat(" = _err")
                        result = result.concat(called_idx.to_str())
                        result = result.concat("_")
                        result = result.concat(temp_suffix)
                        result = result.concat("; return ")
                        result = result.concat(add(curr_idx, 1).to_str())
                        result = result.concat("; }\n")
                        found = true
                        curr_idx = ctx.current_throw_types.len()  // break
                    }
                case:
                    // Non-TCustom, skip
                }
                curr_idx = add(curr_idx, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        case:
            // Non-custom throw type, skip
        }
        called_idx = add(called_idx, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Success case: assign return value to target variable if needed
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            result = result.concat(indent_str)
            result = result.concat(decl_name)
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    } else {
        if gt(assign_name.len(), 0) {
            result = result.concat(indent_str)
            result = result.concat(assign_name)
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    }

    return result
}

// Emit a throwing function call that uses goto for error handling
// Used when there are outer catch blocks registered in ctx.local_catch_labels
emit_throwing_call_with_goto := proc(fcall: Expr, throw_types: Vec, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call_with_goto: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := next_mangled()

    // Determine if we need a return value temp variable
    mut needs_ret := false
    if gt(decl_name.len(), 0) { needs_ret = true }
    if gt(assign_name.len(), 0) { needs_ret = true }

    // Calculate param_types early for Dynamic hoisting
    mut param_types := Vec.new(ValueType)
    mut func_def_lookup := context.scope_stack.lookup_func(func_name)
    mut arg_i := 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_types.push(arg_decl.value_type)
        } else {
            param_types.push(ValueType.TCustom(""))
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call_with_goto: AllocError in param_types" }

    // Calculate param_is_mut for pointer passing
    mut param_is_mut := Vec.new(Bool)
    func_def_lookup = context.scope_stack.lookup_func(func_name)
    arg_i = 0
    while lt(arg_i, sub(fcall.params.len(), 1)) {
        if lt(arg_i, func_def_lookup.args.len()) {
            mut arg_decl := Declaration()
            func_def_lookup.args.get(arg_i, arg_decl)
            param_is_mut.push(arg_decl.is_mut)
        } else {
            param_is_mut.push(false)
        }
        arg_i = add(arg_i, 1)
    }
    catch (err: KeyNotFoundError) { }
    catch (err: IndexOutOfBoundsError) { }
    catch (err: AllocError) { throw "emit_throwing_call_with_goto: AllocError in param_is_mut" }

    // Hoist any throwing function calls in arguments BEFORE emitting this call
    mut hoisted := Map.new(I64, Str)
    if gt(fcall.params.len(), 1) {
        mut hoisted_vec := hoist_throwing_args(fcall.params, result, indent, ctx, context)
        // Convert Vec<HoistedArg> to Map<I64, Str>
        mut hvi := 0
        while lt(hvi, hoisted_vec.len()) {
            mut entry := HoistedArg()
            hoisted_vec.get(hvi, entry)
            hoisted.set(entry.index, entry.temp_var)
            hvi = add(hvi, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call_with_goto: AllocError in hoist_throwing_args" }

    // Hoist non-lvalue args (string literals, function calls) when param type is Dynamic
    if gt(fcall.params.len(), 1) {
        mut dynamic_hoisted := hoist_for_dynamic_params(fcall.params, param_types, hoisted, result, indent, ctx, context)
        mut dh_idx := 0
        while lt(dh_idx, dynamic_hoisted.len()) {
            mut dh := HoistedArg()
            dynamic_hoisted.get(dh_idx, dh)
            hoisted.set(dh.index, dh.temp_var)
            dh_idx = add(dh_idx, 1)
        }
    }
    catch (err: AllocError) { throw "emit_throwing_call_with_goto: AllocError in hoist_for_dynamic_params" }

    // Look up the actual return type from scope_stack
    mut ret_type := "int"
    if needs_ret {
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
        }
        catch (err: KeyNotFoundError) { /* use default int */ }
        catch (err: IndexOutOfBoundsError) { /* use default int */ }
    }

    // Declare temp for return value if needed
    if needs_ret {
        result = result.concat(indent_str)
        result = result.concat(ret_type)
        result = result.concat(" _ret_")
        result = result.concat(temp_suffix)
        result = result.concat(";\n")
    }

    // For declarations: declare the variable BEFORE
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            result = result.concat(indent_str)
            result = result.concat(ret_type)
            result = result.concat(" ")
            result = result.concat(til_name(decl_name))
            result = result.concat(";\n")
            // Add to scope_stack for type resolution
            mut fd := context.scope_stack.lookup_func(func_name)
            if gt(fd.return_types.len(), 0) {
                mut first_type := ValueType.TCustom("")
                fd.return_types.get(0, first_type)
                context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
            }
            catch (err: KeyNotFoundError) { }
            catch (err: IndexOutOfBoundsError) { }
        }
    }

    // Declare error structs for each throw type of the called function
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = result.concat(indent_str)
            result = result.concat(til_name(type_name))
            result = result.concat(" _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = {};\n")
        case:
            result = result.concat(indent_str)
            result = result.concat("int _err")
            result = result.concat(i.to_str())
            result = result.concat("_")
            result = result.concat(temp_suffix)
            result = result.concat(" = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Check if this is a variadic function call and construct array BEFORE the call
    mut variadic_info := detect_variadic_fcall(fcall, ctx)
    mut variadic_arr_var := ""
    if variadic_info.is_variadic {
        mut variadic_args := Vec.new(Expr)
        mut va_idx := add(1, variadic_info.regular_count)
        while lt(va_idx, fcall.params.len()) {
            mut va_arg := Expr()
            fcall.params.get(va_idx, va_arg)
            variadic_args.push(va_arg)
            va_idx = add(va_idx, 1)
        }
        variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, result, indent, ctx, context)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw "emit_throwing_call_with_goto: AllocError in variadic handling" }

    // Generate the function call with output parameters
    result = result.concat(indent_str)
    result = result.concat("int _status_")
    result = result.concat(temp_suffix)
    result = result.concat(" = ")
    result = result.concat(til_func_name(func_name))
    result = result.concat("(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if needs_ret {
        result = result.concat("&_ret_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = result.concat(", ")
        }
        result = result.concat("&_err")
        result = result.concat(i.to_str())
        result = result.concat("_")
        result = result.concat(temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Emit arguments - handle variadic separately from regular args
    if variadic_info.is_variadic {
        // Variadic call: emit regular args first, then variadic array pointer
        arg_i = 1
        while lt(arg_i, add(1, variadic_info.regular_count)) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            mut arg := Expr()
            fcall.params.get(arg_i, arg)
            mut arg_idx := sub(arg_i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type for this argument
            mut is_dynamic_param := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }

            if found_hoisted {
                if is_dynamic_param {
                    result = result.concat("&")
                }
                result = result.concat(hoisted_temp)
            } else {
                result = emit_expr(arg, result, 0, ctx, context)
            }
            param_count = add(param_count, 1)
            arg_i = add(arg_i, 1)
        }

        // Emit variadic array pointer
        if gt(variadic_arr_var.len(), 0) {
            if gt(param_count, 0) {
                result = result.concat(", ")
            }
            result = result.concat("&")
            result = result.concat(variadic_arr_var)
        }
    } else {
        // Non-variadic: emit all args directly
        mut args_started := false
        i = 1
        while lt(i, fcall.params.len()) {
            if args_started {
                result = result.concat(", ")
            } else {
                if gt(param_count, 0) {
                    result = result.concat(", ")
                }
            }
            mut arg := Expr()
            fcall.params.get(i, arg)
            mut arg_idx := sub(i, 1)

            // Check if this arg was hoisted (Map lookup)
            mut found_hoisted := false
            mut hoisted_temp := ""
            hoisted.get(arg_idx, hoisted_temp)
            found_hoisted = true
            catch (err: KeyNotFoundError) { }

            // Get param type for this argument
            mut is_dynamic_param := false
            if lt(arg_idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(arg_idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
            }

            if found_hoisted {
                if is_dynamic_param {
                    result = result.concat("&")
                }
                result = result.concat(hoisted_temp)
            } else {
                // Check if arg is a type identifier - emit as string literal
                mut type_arg := get_type_arg_name(arg, context)
                if type_arg.found {
                    result = result.concat("\"")
                    result = result.concat(type_arg.type_name)
                    result = result.concat("\"")
                } else {
                    // Check if param is Dynamic and arg is simple identifier
                    if is_dynamic_param {
                        switch arg.node_type {
                        case NodeType.Identifier(name):
                            if eq(arg.params.len(), 0) {
                                // Simple variable - emit &var
                                result = result.concat("&")
                                result = result.concat(til_name(name))
                            } else {
                                // Not simple - emit as is
                                result = emit_expr(arg, result, 0, ctx, context)
                            }
                        case:
                            result = emit_expr(arg, result, 0, ctx, context)
                        }
                    } else {
                        result = emit_expr(arg, result, 0, ctx, context)
                    }
                }
            }
            args_started = true
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = result.concat(");\n")

    // Generate goto for each error type that has a registered catch label
    mut called_idx := 0
    while lt(called_idx, throw_types.len()) {
        mut called_throw_type := ValueType.TCustom("")
        throw_types.get(called_idx, called_throw_type)
        switch called_throw_type {
        case ValueType.TCustom(called_type_name):
            // Check if this type has a registered catch label
            mut has_label := false
            mut label := ""
            mut temp_var := ""
            mut info := CatchLabelInfo()
            ctx.local_catch_labels.get(called_type_name, info)
            has_label = true
            label = info.label
            temp_var = info.temp_var
            catch (err: KeyNotFoundError) { }

            if has_label {
                result = result.concat(indent_str)
                result = result.concat("if (_status_")
                result = result.concat(temp_suffix)
                result = result.concat(" == ")
                result = result.concat(add(called_idx, 1).to_str())
                result = result.concat(") { ")
                result = result.concat(temp_var)
                result = result.concat(" = _err")
                result = result.concat(called_idx.to_str())
                result = result.concat("_")
                result = result.concat(temp_suffix)
                result = result.concat("; goto ")
                result = result.concat(label)
                result = result.concat("; }\n")
            }
        case:
            // Non-custom throw type
        }
        called_idx = add(called_idx, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Success case: assign return value to target variable if needed
    // Skip for underscore _ which is just a discard
    if gt(decl_name.len(), 0) {
        if not(decl_name.eq("_")) {
            result = result.concat(indent_str)
            result = result.concat(til_name(decl_name))
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    } else {
        if gt(assign_name.len(), 0) {
            result = result.concat(indent_str)
            result = result.concat(til_name(assign_name))
            result = result.concat(" = _ret_")
            result = result.concat(temp_suffix)
            result = result.concat(";\n")
        }
    }

    return result
}

// Emit a throw statement
// For throwing functions: *_errN = value; return N;
// For local catches: temp_var = value; goto label;
emit_throw := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Throw: params[0] = the value to throw (typically a struct constructor like DivideByZero())
    if eq(expr.params.len(), 0) {
        throw "ccodegen: throw requires a value"
    }

    mut thrown_expr := Expr()
    expr.params.get(0, thrown_expr)

    // Check if the thrown expression itself is a throwing function call (e.g., throw format(...))
    // If so, we need to hoist it first to ensure proper error handling
    mut hoisted_key := ctx.hoisted_exprs.len()
    mut result := output
    result = hoist_throwing_expr(thrown_expr, result, indent, ctx, context)
    catch (err: AllocError) { throw "emit_throw: AllocError in hoist_throwing_expr" }
    catch (err: KeyNotFoundError) { throw "emit_throw: KeyNotFoundError in hoist_throwing_expr" }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    mut hoisted_temp := ""
    mut was_hoisted := gt(ctx.hoisted_exprs.len(), hoisted_key)
    if was_hoisted {
        // The thrown expression was hoisted to a temp variable
        Map.get(ctx.hoisted_exprs, hoisted_key, hoisted_temp)
    }

    // Get the thrown type name from the expression
    // For FCall, we need to determine if it's:
    // 1. A constructor like DivideByZero() - use the type name
    // 2. A function that returns an error type like format() - use the return type
    mut thrown_type_name := ""

    switch thrown_expr.node_type {
    case NodeType.FCall:
        if gt(thrown_expr.params.len(), 0) {
            mut first_param := Expr()
            thrown_expr.params.get(0, first_param)
            switch first_param.node_type {
            case NodeType.Identifier(name):
                // Check if this is a constructor (struct/enum) or a function call
                // If it's a function that returns a type, use the return type
                mut func_name := get_fcall_func_name(thrown_expr)
                if gt(func_name.len(), 0) {
                    mut lookup_result := lookup_func_by_name(context, func_name)
                    if lookup_result.found {
                        // It's a function - use its return type as the thrown type
                        if gt(lookup_result.func_def.return_types.len(), 0) {
                            mut ret_type := ValueType.TFunction
                            lookup_result.func_def.return_types.get(0, ret_type)
                            switch ret_type {
                            case ValueType.TCustom(type_name):
                                thrown_type_name = type_name
                            case:
                                thrown_type_name = value_type_to_str(ret_type)
                            }
                        } else {
                            // No return type, assume it's a constructor
                            thrown_type_name = name
                        }
                    } else {
                        // Not a function, assume it's a constructor
                        thrown_type_name = name
                    }
                } else {
                    thrown_type_name = name
                }
            case:
                throw "ccodegen: throw FCall must have identifier as first param"
            }
        } else {
            throw "ccodegen: throw FCall has no params"
        }
    case NodeType.Identifier(name):
        // Look up the type of the identifier (could be a variable or type name)
        mut value_type := get_value_type(context, thrown_expr)
        switch value_type {
        case ValueType.TCustom(type_name):
            thrown_type_name = type_name
        case:
            thrown_type_name = value_type_to_str(value_type)
        }
        catch (err: Str) {
            // Fallback: assume identifier is a type name (for struct constructors without args)
            thrown_type_name = name
        }
    case NodeType.LLiteral(lit):
        // Literal values - determine their type
        switch lit {
        case Literal.Str(s):
            thrown_type_name = "Str"
        case Literal.Number(n):
            thrown_type_name = "I64"
        case Literal.List(l):
            throw "ccodegen: cannot throw a list literal"
        }
    case:
        throw "ccodegen: throw expression must be a constructor, function call, identifier, or literal"
    }

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    mut result := output

    // Check if this type is locally caught (has a catch block at function level)
    mut has_local_catch := false
    mut local_label := ""
    mut local_temp_var := ""
    mut info := CatchLabelInfo()
    ctx.local_catch_labels.get(thrown_type_name, info)
    has_local_catch = true
    local_label = info.label
    local_temp_var = info.temp_var
    catch (err: KeyNotFoundError) { }

    if has_local_catch {
        // Store the error value in temp variable
        result = result.concat(indent_str)
        result = result.concat(local_temp_var)
        result = result.concat(" = ")
        if was_hoisted {
            result = result.concat(hoisted_temp)
        } else {
            result = emit_expr(thrown_expr, result, 0, ctx, context)
        }
        result = result.concat(";\n")

        // Jump to the catch block
        result = result.concat(indent_str)
        result = result.concat("goto ")
        result = result.concat(local_label)
        result = result.concat(";\n")

        return result
    }

    // Find the index of this type in current_throw_types
    // Note: Str is represented as TCustom("Str") in the type system
    mut error_index := sub(0, 1)  // -1 = not found
    mut i := 0
    while lt(i, ctx.current_throw_types.len()) {
        mut vt := ValueType.TFunction
        ctx.current_throw_types.get(i, vt)
        switch vt {
        case ValueType.TCustom(type_name):
            if type_name.eq(thrown_type_name) {
                error_index = i
            }
        case:
            // Not a custom type
        }
        i = add(i, 1)
    }

    if lt(error_index, 0) {
        throw format("ccodegen: thrown type '", thrown_type_name, "' not found in function's throw types")
    }

    // Store the error value in the appropriate error pointer
    // Note: error params are 1-based (_err1, _err2, etc.)
    result = format(result, indent_str, "*_err", add(error_index, 1).to_str(), " = ")
    if was_hoisted {
        result = result.concat(hoisted_temp)
    } else {
        result = emit_expr(thrown_expr, result, 0, ctx, context)
    }
    result = result.concat(";\n")

    // Return the error index (1-based, since 0 = success)
    result = format(result, indent_str, "return ", add(error_index, 1).to_str(), ";\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

// Check if an expression is a struct construction call (TypeName())
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                // If it's a PascalCase identifier with no nested params and no other args, assume struct
                if gt(name.len(), 0) {
                    // Check if first character is uppercase
                    // TODO: Use proper type info from AST instead of uppercase hack (see interpreter.til)
                    mut first_char := name.get_substr(0, 1)
                    if first_char.is_uppercase() {
                        if eq(expr.params.len(), 1) {
                            if eq(first.params.len(), 0) {
                                return name
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Check if an expression is an enum construction (Type.Variant or Type.Variant(value))
// Returns the type name if it is, empty string otherwise
// AST structure for Color.Red(42): FCall -> [Identifier("Color") -> [Identifier("Red")], Literal(42)]
// AST structure for Color.Unknown: Identifier("Color") -> [Identifier("Unknown")]
get_enum_construction_type := func(expr: Expr) returns Str {
    // Check FCall case: Type.Variant(value) or Type.Variant()
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                // Check if the type name is PascalCase
                // TODO: Use proper type info from AST instead of uppercase hack (see interpreter.til)
                if gt(type_name.len(), 0) {
                    mut type_first_char := type_name.get_substr(0, 1)
                    if type_first_char.is_uppercase() {
                        // Check if there's a nested identifier (the variant) that's also PascalCase
                        if gt(first.params.len(), 0) {
                            mut nested := Expr()
                            first.params.get(0, nested)
                            catch (err: IndexOutOfBoundsError) { return "" }
                            switch nested.node_type {
                            case NodeType.Identifier(variant_name):
                                if gt(variant_name.len(), 0) {
                                    mut variant_first_char := variant_name.get_substr(0, 1)
                                    if variant_first_char.is_uppercase() {
                                        return type_name
                                    }
                                    catch (err: IndexOutOfBoundsError) { return "" }
                                    catch (err: AllocError) { return "" }
                                }
                                return ""
                            case:
                                return ""
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case NodeType.Identifier(type_name):
        // Check Identifier case: Type.Variant (no parentheses, no payload)
        // TODO: Use proper type info from AST instead of uppercase hack (see interpreter.til)
        if gt(type_name.len(), 0) {
            mut type_first_char := type_name.get_substr(0, 1)
            if type_first_char.is_uppercase() {
                if gt(expr.params.len(), 0) {
                    mut nested := Expr()
                    expr.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        if gt(variant_name.len(), 0) {
                            mut variant_first_char := variant_name.get_substr(0, 1)
                            if variant_first_char.is_uppercase() {
                                return type_name
                            }
                            catch (err: IndexOutOfBoundsError) { return "" }
                            catch (err: AllocError) { return "" }
                        }
                        return ""
                    case:
                        return ""
                    }
                }
            }
            catch (err: IndexOutOfBoundsError) { return "" }
            catch (err: AllocError) { return "" }
        }
        return ""
    case:
        return ""
    }
}

// Infer type from an expression (literal, function call, or identifier)
// Returns the inferred ValueType, or ValueType.TCustom("") if unknown
infer_type_from_expr := func(expr: Expr, context: Context) returns ValueType {
    switch expr.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(n):
            return ValueType.TCustom("I64")
        case Literal.Str(s):
            return ValueType.TCustom("Str")
        case Literal.List(l):
            return ValueType.TCustom("")  // Can't infer list element type
        }
    case NodeType.FCall:
        // Look up function return type from scope_stack
        mut func_name := get_fcall_func_name(expr)
        if gt(func_name.len(), 0) {
            mut fd := context.scope_stack.lookup_func(func_name)
            if gt(fd.return_types.len(), 0) {
                mut first_ret := ValueType.TCustom("")
                fd.return_types.get(0, first_ret)
                catch (err: IndexOutOfBoundsError) { return ValueType.TCustom("") }
                return first_ret
            }
            catch (err: KeyNotFoundError) { return ValueType.TCustom("") }
        }
        return ValueType.TCustom("")
    case NodeType.Identifier(name):
        // Check for field access (var.field)
        if gt(expr.params.len(), 0) {
            mut first_param := Expr()
            expr.params.get(0, first_param)
            switch first_param.node_type {
            case NodeType.Identifier(field_name):
                // Look up the variable type first
                mut sym := context.scope_stack.lookup_symbol(name)
                switch sym.value_type {
                case ValueType.TCustom(struct_name):
                    // Look up the field type from the struct definition
                    mut struct_def := context.scope_stack.lookup_struct(struct_name)
                    // Check members for the field
                    mut m_idx := 0
                    while lt(m_idx, struct_def.members.len()) {
                        mut member := Declaration()
                        struct_def.members.get(m_idx, member)
                        if Str.eq(member.name, field_name) {
                            return member.value_type
                        }
                        m_idx = add(m_idx, 1)
                    }
                    catch (err: IndexOutOfBoundsError) { }
                    catch (err: KeyNotFoundError) { }
                case:
                }
                catch (err: KeyNotFoundError) { }
            case:
            }
            catch (err: IndexOutOfBoundsError) { }
            return ValueType.TCustom("")
        }
        // Look up variable type from scope_stack
        mut var_type := ValueType.TCustom("")
        mut symbol := context.scope_stack.lookup_symbol(name)
        var_type = symbol.value_type
        catch (err: KeyNotFoundError) { }
        return var_type
    case:
        return ValueType.TCustom("")
    }
    return ValueType.TCustom("")
}

emit_declaration := proc(decl: Declaration, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    name := decl.name
    is_mut := decl.is_mut

    // Skip inline ext_func/ext_proc declarations - they're just declaring external functions exist
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            if func_def.is_ext {
                return output
            }
        case:
            // Continue
        }
    }

    // Skip NULL - it's a C macro for 0
    if Str.eq(name, "NULL") { return output }

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = result.concat("    ")
        ind = add(ind, 1)
    }

    // Check if this is a function definition - skip or hoist depending on context
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            // Check if we're inside a function (nested function declaration)
            if gt(ctx.current_function_name.len(), 0) {
                // Nested function - hoist it to top level with mangled name
                mut mangled_name := ctx.current_function_name.concat("_").concat(name)

                // Register function definition so get_value_type can resolve return types
                context.scope_stack.declare_func(name, func_def)

                // Generate the function definition with mangled name
                mut func_output := ""

                // Save and set context for nested function
                mut saved_throw_types := ctx.current_throw_types
                mut saved_return_types := ctx.current_return_types
                mut saved_mut_params := ctx.current_mut_params
                mut saved_variadic_params := ctx.current_variadic_params
                mut saved_declared_vars := ctx.declared_vars
                mut saved_function_name := ctx.current_function_name

                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types
                ctx.current_function_name = mangled_name
                ctx.current_mut_params = Vec.new(Str)
                ctx.current_variadic_params = Map.new(Str, Str)
                ctx.declared_vars = Set.new(Str)

                // Track mut params and variadic params
                mut arg_idx := 0
                while lt(arg_idx, func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(arg_idx, arg)
                    if arg.is_mut {
                        ctx.current_mut_params.push(arg.name)
                    }
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        ctx.current_variadic_params.insert(arg.name, til_name(elem_type_name))
                    case:
                    }
                    arg_idx = add(arg_idx, 1)
                }

                // Emit signature with mangled name
                func_output = emit_func_signature(mangled_name, func_def, func_output, ctx)
                func_output = func_output.concat(" {\n")

                // Emit body
                func_output = emit_stmts(func_def.body, func_output, 1, ctx, context)

                // For throwing void functions, add implicit return 0
                if gt(func_def.throw_types.len(), 0) {
                    if eq(func_def.return_types.len(), 0) {
                        func_output = func_output.concat("    return 0;\n")
                    }
                }

                func_output = func_output.concat("}\n\n")

                // Store in hoisted_functions
                ctx.hoisted_functions.push(func_output)

                // Restore context
                ctx.current_throw_types = saved_throw_types
                ctx.current_return_types = saved_return_types
                ctx.current_mut_params = saved_mut_params
                ctx.current_variadic_params = saved_variadic_params
                ctx.declared_vars = saved_declared_vars
                ctx.current_function_name = saved_function_name

                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }
                catch (err: DuplicatedKeyError) { }

                // Don't emit anything at declaration site - function is hoisted
                return output
            }
            // Top-level function - skip, already emitted before main
            return output
        case NodeType.StructDef(struct_def):
            // Skip - already emitted before functions
            return output
        case:
            // Continue with normal declaration
        }
    }

    // Hoist any throwing function calls in the RHS expression before emitting the declaration
    // This ensures throwing calls are properly handled with error checking
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = hoist_throwing_expr(first, result, indent, ctx, context)
        catch (err: AllocError) { throw "emit_declaration: AllocError in hoist_throwing_expr" }
        catch (err: KeyNotFoundError) { throw "emit_declaration: KeyNotFoundError in hoist_throwing_expr" }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // For underscore declarations, just emit the expression (discard result)
    // This avoids C redeclaration errors and matches the semantics of discarding
    if name.eq("_") {
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            result = emit_expr(first, result, indent, ctx, context)
            // emit_expr at statement level (indent > 0) adds ";\n" for FCall
            // For other expressions, we may need to add it
            mut ends_with_semicolon := false
            if gteq(result.len(), 2) {
                mut last_two := result.get_substr(sub(result.len(), 2), result.len())
                ends_with_semicolon = last_two.eq(";\n")
            }
            if not(ends_with_semicolon) {
                result = result.concat(";\n")
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw "emit_declaration: AllocError in underscore check" }
        }
        return result
    }

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        struct_type = get_struct_construction_type(first)
    }

    // Check if this is an enum construction (Type.Variant or Type.Variant(value))
    mut enum_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        enum_type = get_enum_construction_type(first)
    }

    // Track variable type for method mangling
    // Use the inferred type from struct/enum construction if available,
    // or use get_value_type to get return type of function calls like Vec.new(Str)
    mut var_type := decl.value_type
    if gt(struct_type.len(), 0) {
        var_type = ValueType.TCustom(struct_type)
    } else if gt(enum_type.len(), 0) {
        var_type = ValueType.TCustom(enum_type)
    } else {
        switch decl.value_type {
        case ValueType.TCustom(type_name):
            if Str.eq(type_name, "auto").and(gt(expr.params.len(), 0)) {
                // Try get_value_type first (handles function calls like Vec.new)
                // then fall back to literal inference
                mut first := Expr()
                expr.params.get(0, first)
                mut got_type := false
                mut inferred_type := get_value_type(context, first)
                got_type = true
                var_type = inferred_type
                catch (err: Str) {
                    // get_value_type failed, try literal inference
                    var_type = infer_type_from_expr(first, context)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }
        case:
            // Keep default decl.value_type
        }
    }
    // Add to scope_stack so get_value_type can find it
    context.scope_stack.declare_symbol(name, SymbolInfo.new(var_type, decl.is_mut, false, false))

    if gt(struct_type.len(), 0) {
        // Struct variable declaration
        result = result.concat(struct_type)
        result = result.concat(" ")
        result = result.concat(name)
        result = result.concat(" = {0};\n")
    } else if gt(enum_type.len(), 0) {
        // Enum variable declaration
        result = result.concat(enum_type)
        result = result.concat(" ")
        result = result.concat(name)
        result = result.concat(" = ")
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx, context)
        result = result.concat(";\n")
    } else if is_mut {
        // Determine C type from inferred type or fall back to int
        mut c_type := "int"
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            inferred := infer_type_from_expr(first, context)
            switch inferred {
            case ValueType.TCustom(inf_type):
                if Str.eq(inf_type, "Str") {
                    c_type = "const char*"
                } else if gt(inf_type.len(), 0) {
                    c_type = inf_type  // I64, U8, etc. pass through
                }
            case:
                // Keep default "int"
            }
        }
        result = result.concat(c_type)
        result = result.concat(" ")
        result = result.concat(name)
        if gt(expr.params.len(), 0) {
            result = result.concat(" = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx, context)
        }
        result = result.concat(";\n")
    } else {
        // Determine C type from inferred type or fall back to int
        mut c_type := "int"
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            inferred := infer_type_from_expr(first, context)
            switch inferred {
            case ValueType.TCustom(inf_type):
                if Str.eq(inf_type, "Str") {
                    c_type = "const char*"
                } else if gt(inf_type.len(), 0) {
                    c_type = inf_type  // I64, U8, etc. pass through
                }
            case:
                // Keep default "int"
            }
        }
        result = result.concat("const ")
        result = result.concat(c_type)
        result = result.concat(" ")
        result = result.concat(name)
        if gt(expr.params.len(), 0) {
            result = result.concat(" = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx, context)
        }
        result = result.concat(";\n")
    }
    return result
}

emit_funcdef := proc(func_def: SFuncDef, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Inline function body (shouldn't be called for top-level funcs)
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = result.concat("    ")
        ind = add(ind, 1)
    }
    result = result.concat("{\n")
    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, params_len) {
        mut stmt := Expr()
        expr.params.get(i, stmt)
        result = emit_expr(stmt, result, add(indent, 1), ctx, context)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    ind = 0
    while lt(ind, indent) {
        result = result.concat("    ")
        ind = add(ind, 1)
    }
    result = result.concat("}\n")
    return result
}

emit_assignment := proc(name: Str, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Hoist any throwing function calls nested in the RHS expression
    if gt(expr.params.len(), 0) {
        mut rhs_expr := Expr()
        expr.params.get(0, rhs_expr)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = hoist_throwing_expr(rhs_expr, result, indent, ctx, context)
        catch (err: AllocError) { throw "emit_assignment: AllocError in hoist_throwing_expr" }
        catch (err: KeyNotFoundError) { throw "emit_assignment: KeyNotFoundError in hoist_throwing_expr" }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    mut ind := 0
    while lt(ind, indent) {
        result = result.concat("    ")
        ind = add(ind, 1)
    }
    // Check if assignment target is a field access on a mut param (self.field)
    // If so, emit with -> instead of .
    if name.contains(".") {
        // Find dot position manually (no index_of in TIL Str)
        mut dot_pos := 0
        mut name_idx := 0
        while lt(name_idx, name.len()) {
            mut ch := name.get_char(name_idx)
            if ch.eq(".") {
                dot_pos = name_idx
                name_idx = name.len()  // break
            } else {
                name_idx = add(name_idx, 1)
            }
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
        mut base := name.get_substr(0, dot_pos)
        mut rest := name.get_substr(add(dot_pos, 1), name.len())
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
        if ctx.current_mut_params.contains(base) {
            // Mut param field access: til_self->field
            result = result.concat(til_name(base))
            result = result.concat("->")
            result = result.concat(rest)
        } else {
            result = result.concat(til_name(name))
        }
    } else if ctx.current_mut_params.contains(name) {
        // Direct assignment to mut param: *til_self = value
        result = result.concat("*")
        result = result.concat(til_name(name))
    } else {
        result = result.concat(til_name(name))
    }
    result = result.concat(" = ")
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx, context)
    }
    result = result.concat(";\n")
    return result
}

emit_return := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    mut ind := 0
    mut indent_str := ""
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }
    result = result.concat(indent_str)

    // Check if we're in a throwing function
    if gt(ctx.current_throw_types.len(), 0) {
        // Throwing function: *_ret = value; return 0;
        if gt(expr.params.len(), 0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            // Check if return expression is a call to a throwing function
            mut handled_throw := false
            switch return_expr.node_type {
            case NodeType.FCall:
                mut func_name := get_fcall_func_name(return_expr)
                if gt(func_name.len(), 0) {
                    mut lookup_result := lookup_func_by_name(context, func_name)
                    if lookup_result.found {
                        if gt(lookup_result.func_def.throw_types.len(), 0) {
                            // Return expression is a throwing function call - emit with error propagation
                            // The result will be stored via the assign_name "*_ret"
                            result = emit_throwing_call_propagate(return_expr, lookup_result.func_def.throw_types, "", "*_ret", result, indent, ctx, context)
                            result = result.concat(indent_str)
                            result = result.concat("return 0;\n")
                            handled_throw = true
                        }
                    }
                }
            case:
                // Not an FCall, handle normally
            }

            if not(handled_throw) {
                // Hoist any throwing function calls nested in the return expression
                result = hoist_throwing_expr(return_expr, result, indent, ctx, context)
                catch (err: AllocError) { throw "emit_return: AllocError in hoist_throwing_expr" }
                catch (err: KeyNotFoundError) { throw "emit_return: KeyNotFoundError in hoist_throwing_expr" }
                catch (err: IndexOutOfBoundsError) { throw err.msg }

                // Regular return value - just emit it
                result = result.concat("*_ret = ")
                result = emit_expr(return_expr, result, 0, ctx, context)
                result = result.concat(";\n")
                result = result.concat(indent_str)
                result = result.concat("return 0;\n")
            }
        } else {
            result = result.concat("return 0;\n")
        }
    } else {
        // Non-throwing function: normal return
        // Check if return expression is a variadic function call
        if gt(expr.params.len(), 0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            switch return_expr.node_type {
            case NodeType.FCall:
                mut variadic_info := detect_variadic_fcall(return_expr, ctx)
                if variadic_info.is_variadic {
                    // Variadic call in return - need to hoist it
                    // First, hoist any nested throwing/variadic calls in the arguments
                    mut hoisted_vec := hoist_throwing_args(return_expr.params, result, indent, ctx, context)
                    // Convert Vec<HoistedArg> to Map<I64, Str>
                    mut hoisted := Map.new(I64, Str)
                    mut hvi := 0
                    while lt(hvi, hoisted_vec.len()) {
                        mut entry := HoistedArg()
                        hoisted_vec.get(hvi, entry)
                        hoisted.set(entry.index, entry.temp_var)
                        hvi = add(hvi, 1)
                    }
                    catch (err: AllocError) { throw "emit_return: AllocError in hoist_throwing_args" }

                    mut variadic_args := Vec.new(Expr)
                    mut vi := add(1, variadic_info.regular_count)
                    while lt(vi, return_expr.params.len()) {
                        mut varg := Expr()
                        return_expr.params.get(vi, varg)
                        variadic_args.push(varg)
                        vi = add(vi, 1)
                    }
                    mut arr_var := hoist_variadic_args(variadic_info.elem_type, variadic_args, hoisted, variadic_info.regular_count, result, indent, ctx, context)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    catch (err: AllocError) { throw err.msg }

                    // Emit the function call storing result
                    mut temp_var := next_mangled()
                    mut ret_type := "int"
                    mut ret_vt := get_value_type(context, return_expr)
                    ret_type = til_type_to_c(ret_vt)
                    result = result.concat(indent_str)
                    result = result.concat(ret_type)
                    result = result.concat(" ")
                    result = result.concat(temp_var)
                    result = result.concat(" = ")

                    // Emit the function name
                    mut func_name := get_fcall_func_name(return_expr)
                    if gt(func_name.len(), 0) {
                        result = result.concat(til_func_name(func_name))
                    }
                    result = result.concat("(")

                    // Emit regular args
                    mut first := true
                    mut ri := 0
                    while lt(ri, variadic_info.regular_count) {
                        if not(first) {
                            result = result.concat(", ")
                        }
                        first = false
                        mut arg := Expr()
                        return_expr.params.get(add(ri, 1), arg)
                        result = emit_expr(arg, result, 0, ctx, context)
                        ri = add(ri, 1)
                    }
                    catch (err: IndexOutOfBoundsError) { throw err.msg }

                    // Emit variadic array pointer
                    if not(first) {
                        result = result.concat(", ")
                    }
                    result = result.concat("&")
                    result = result.concat(arr_var)
                    result = result.concat(");\n")

                    // Delete array
                    result = result.concat(indent_str)
                    result = result.concat(TIL_PREFIX)
                    result = result.concat("Array_delete(&")
                    result = result.concat(arr_var)
                    result = result.concat(");\n")

                    // Return the result
                    result = result.concat(indent_str)
                    result = result.concat("return ")
                    result = result.concat(temp_var)
                    result = result.concat(";\n")
                    return result
                }
            case:
            }
        }

        // Hoist any throwing function calls nested in the return expression
        if gt(expr.params.len(), 0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = hoist_throwing_expr(return_expr, result, indent, ctx, context)
            catch (err: AllocError) { throw "emit_return: AllocError in hoist_throwing_expr (non-throwing)" }
            catch (err: KeyNotFoundError) { throw "emit_return: KeyNotFoundError in hoist_throwing_expr (non-throwing)" }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        // Regular non-variadic return
        result = result.concat("return")
        if gt(expr.params.len(), 0) {
            result = result.concat(" ")
            mut first_param := Expr()
            expr.params.get(0, first_param)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first_param, result, 0, ctx, context)
        }
        result = result.concat(";\n")
    }

    return result
}

// Emit a throwing function call's name and arguments for hoisting
// If variadic_arr_var is non-empty, use that pre-constructed array instead of building one
emit_fcall_name_and_args_for_throwing := proc(expr: Expr, temp_var: Str, temp_suffix: Str, throw_types: Vec, nested_hoisted: Map, variadic_arr_var: Str, mut output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    if lt(expr.params.len(), 1) {
        throw "emit_fcall_name_and_args_for_throwing: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)

    mut func_name := ""
    mut type_receiver_name := ""
    mut has_type_receiver := false
    mut type_depth := 0  // Number of params (for chained access like self._len.eq)

    switch first.node_type {
    case NodeType.Identifier(name):
        if gt(first.params.len(), 0) {
            // Type-qualified: Type.method()
            // AST is FLAT: a.b.c is Identifier("a") { params: [Identifier("b"), Identifier("c")] }
            // Method is the LAST param, not the first
            type_depth = first.params.len()
            mut method_idx := sub(type_depth, 1)
            mut method_expr := Expr()
            first.params.get(method_idx, method_expr)
            switch method_expr.node_type {
            case NodeType.Identifier(method_name):
                func_name = method_name
                type_receiver_name = name
                has_type_receiver = true
            case:
                throw "emit_fcall_name_and_args_for_throwing: type-qualified method not Identifier"
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        } else {
            func_name = name
        }
    case:
        throw "emit_fcall_name_and_args_for_throwing: first param not Identifier"
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Emit function name with potential type-qualified mangling (e.g., I64.to_str -> til_I64_to_str)
    // For struct methods, we already emitted til_Type_, so just add method name
    // For top-level functions, add til_ prefix via til_func_name
    mut is_struct_method := false
    if has_type_receiver {
        mut first_char := type_receiver_name.get_char(0)
        // TODO: Use proper type info from AST instead of uppercase hack (see interpreter.til)
        if first_char.is_uppercase() {
            // Type-qualified: Type.func -> til_Type_func
            output = output.concat(TIL_PREFIX)
            output = output.concat(type_receiver_name)
            output = output.concat("_")
            is_struct_method = true
        } else {
            // Instance call: instance.method -> til_Type_method (only if mangled name exists)
            mut receiver_type := ValueType.TCustom("")
            mut symbol := context.scope_stack.lookup_symbol(type_receiver_name)
            receiver_type = symbol.value_type
            switch receiver_type {
            case ValueType.TCustom(type_name):
                mut candidate := concat(type_name, ".")
                candidate = candidate.concat(func_name)
                _ := context.scope_stack.lookup_func(candidate)
                // If lookup succeeded, use mangled name
                output = output.concat(TIL_PREFIX)
                output = output.concat(type_name)
                output = output.concat("_")
                is_struct_method = true
            case:
                // Skip
            }
            catch (err: KeyNotFoundError) { }
        }
        catch (err: IndexOutOfBoundsError) { }
        catch (err: AllocError) { }
    }

    if is_struct_method {
        output = output.concat(func_name)
    } else {
        output = output.concat(til_func_name(func_name))
    }
    output = output.concat("(&")
    output = output.concat(temp_var)

    // Add error output pointers
    mut err_idx := 0
    while lt(err_idx, throw_types.len()) {
        output = output.concat(", &_err")
        output = output.concat(I64.to_str(err_idx))
        output = output.concat("_")
        output = output.concat(temp_suffix)
        err_idx = add(err_idx, 1)
    }

    // Emit receiver for instance call
    if has_type_receiver {
        mut first_char := type_receiver_name.get_char(0)
        if not(first_char.is_uppercase()) {
            output = output.concat(", ")
            // Check if called function's self param is mut and if receiver is a mut param
            mut called_self_is_mut := false
            mut type_name := ""
            mut symbol := context.scope_stack.lookup_symbol(type_receiver_name)
            switch symbol.value_type {
            case ValueType.TCustom(tname):
                type_name = tname
                mut mangled := concat(type_name, ".")
                mangled = mangled.concat(func_name)
                mut lookup_result := lookup_func_by_name(context, mangled)
                if lookup_result.found {
                    if gt(lookup_result.func_def.args.len(), 0) {
                        mut first_arg := Declaration()
                        lookup_result.func_def.args.get(0, first_arg)
                        called_self_is_mut = first_arg.is_mut
                    }
                    catch (err: IndexOutOfBoundsError) { }
                }
            case:
                // Not a custom type
            }
            catch (err: KeyNotFoundError) { }
            mut receiver_is_mut_param := ctx.current_mut_params.contains(type_receiver_name)
            mut receiver_is_variadic_param := Map.contains_key(ctx.current_variadic_params, type_receiver_name)
            mut receiver_is_pointer := receiver_is_mut_param.or(receiver_is_variadic_param)
            mut needs_deref_close := false
            if called_self_is_mut.and(not(receiver_is_pointer)) {
                // Called function takes mut self, receiver is not a pointer - add &
                output = output.concat("&")
            } else if not(called_self_is_mut).and(receiver_is_pointer).and(eq(type_depth, 1)) {
                // Called function takes non-mut self, but receiver is a pointer - dereference
                output = output.concat("(*")
                needs_deref_close = true
            }
            output = output.concat(til_name(type_receiver_name))
            // Emit intermediate field accesses (all except the last which is the method)
            mut field_idx := 0
            while lt(field_idx, sub(type_depth, 1)) {
                mut field_expr := Expr()
                first.params.get(field_idx, field_expr)
                switch field_expr.node_type {
                case NodeType.Identifier(field_name):
                    // Use -> for first field access if base is pointer (mut param or variadic param), . for rest
                    if eq(field_idx, 0).and(receiver_is_pointer) {
                        output = output.concat("->")
                    } else {
                        output = output.concat(".")
                    }
                    output = output.concat(field_name)
                case:
                    // skip
                }
                field_idx = add(field_idx, 1)
            }
            if needs_deref_close {
                output = output.concat(")")
            }
        }
        catch (err: IndexOutOfBoundsError) { }
        catch (err: AllocError) { }
    }

    // TODO: Check if this is a variadic function call and use variadic_arr_var
    // For now, emit remaining arguments (using hoisted temps where available)
    mut arg_idx := 0
    // Skip first param (function name), start from index 1
    mut i := 1
    while lt(i, expr.params.len()) {
        output = output.concat(", ")
        // Check if this arg was hoisted (Map lookup)
        mut hoisted_var := ""
        mut found_hoisted := false
        nested_hoisted.get(arg_idx, hoisted_var)
        found_hoisted = true
        catch (err: KeyNotFoundError) { }
        if found_hoisted {
            output = output.concat(hoisted_var)
        } else {
            mut arg := Expr()
            expr.params.get(i, arg)
            output = emit_expr(arg, output, 0, ctx, context)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
        arg_idx = add(arg_idx, 1)
        i = add(i, 1)
    }

    output = output.concat(")")
    return output
}

// Hoist throwing function calls from arguments (recursively)
// Returns a list of hoisted args with their temp var names
// Also modifies output to include hoisting code
hoist_throwing_args := proc(args: Vec, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Vec throws Str, AllocError {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    mut idx := 0
    while lt(idx, args.len()) {
        mut arg := Expr()
        args.get(idx, arg)

        // Check if it's a throwing call
        mut throwing_info := check_throwing_fcall(arg, ctx, context)
        // Check if it's a variadic call (even if not throwing)
        mut variadic_info := detect_variadic_fcall(arg, ctx)

        // Handle throwing calls (may also be variadic)
        if throwing_info.is_throwing {
            // RECURSIVELY hoist any throwing calls in this call's arguments first
            mut nested_hoisted := Map.new(I64, Str)
            if gt(arg.params.len(), 1) {
                mut nested_vec := hoist_throwing_args(arg.params, output, indent, ctx, context)
                // Convert Vec<HoistedArg> to Map<I64, Str>
                mut nhi := 0
                while lt(nhi, nested_vec.len()) {
                    mut entry := HoistedArg()
                    nested_vec.get(nhi, entry)
                    nested_hoisted.set(entry.index, entry.temp_var)
                    nhi = add(nhi, 1)
                }
            }

            mut temp_var := next_mangled()

            // Determine C type for temp variable
            mut c_type := "int"
            if throwing_info.has_return_type {
                c_type = til_type_to_c(throwing_info.return_type)
            }

            // Declare temp variable
            output = output.concat(indent_str)
            output = output.concat(c_type)
            output = output.concat(" ")
            output = output.concat(temp_var)
            output = output.concat(";\n")

            // Declare error variables for each throw type
            mut temp_suffix := next_mangled()
            mut err_idx := 0
            while lt(err_idx, throwing_info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                throwing_info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    output = output.concat(indent_str)
                    output = output.concat(type_name)
                    output = output.concat(" _err")
                    output = output.concat(I64.to_str(err_idx))
                    output = output.concat("_")
                    output = output.concat(temp_suffix)
                    output = output.concat(";\n")
                case:
                    // Skip non-custom types
                }
                err_idx = add(err_idx, 1)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            // Detect and construct variadic array if needed
            mut variadic_arr_var := ""
            mut has_variadic_arr := false
            if variadic_info.is_variadic {
                mut variadic_args := Vec.new(Expr)
                mut vi := add(1, variadic_info.regular_count)
                while lt(vi, arg.params.len()) {
                    mut varg := Expr()
                    arg.params.get(vi, varg)
                    variadic_args.push(varg)
                    vi = add(vi, 1)
                }
                variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)
                has_variadic_arr = true
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            // Emit the function call with output pointers
            output = output.concat(indent_str)
            output = output.concat("int _status_")
            output = output.concat(temp_suffix)
            output = output.concat(" = ")
            output = emit_fcall_name_and_args_for_throwing(arg, temp_var, temp_suffix, throwing_info.throw_types, nested_hoisted, variadic_arr_var, output, ctx, context)
            output = output.concat(";\n")

            // Emit error checking - propagate if any error occurred
            output = output.concat(indent_str)
            output = output.concat("if (_status_")
            output = output.concat(temp_suffix)
            output = output.concat(" != 0) {\n")

            // Propagate error to current function's error pointers
            err_idx = 0
            while lt(err_idx, throwing_info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                throwing_info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    // Find matching throw type in current function
                    mut curr_idx := 0
                    while lt(curr_idx, ctx.current_throw_types.len()) {
                        mut curr_throw := ValueType.TCustom("")
                        ctx.current_throw_types.get(curr_idx, curr_throw)
                        switch curr_throw {
                        case ValueType.TCustom(curr_type_name):
                            if curr_type_name.eq(type_name) {
                                output = output.concat(indent_str)
                                output = output.concat("    if (_status_")
                                output = output.concat(temp_suffix)
                                output = output.concat(" == ")
                                output = output.concat(I64.to_str(add(err_idx, 1)))
                                output = output.concat(") { *_err")
                                output = output.concat(I64.to_str(add(curr_idx, 1)))
                                output = output.concat(" = _err")
                                output = output.concat(I64.to_str(err_idx))
                                output = output.concat("_")
                                output = output.concat(temp_suffix)
                                output = output.concat("; return ")
                                output = output.concat(I64.to_str(add(curr_idx, 1)))
                                output = output.concat("; }\n")
                            }
                        case:
                            // Skip
                        }
                        curr_idx = add(curr_idx, 1)
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                    }
                case:
                    // Skip
                }
                err_idx = add(err_idx, 1)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            output = output.concat(indent_str)
            output = output.concat("}\n")

            // Emit Array.delete if variadic array was constructed
            if has_variadic_arr {
                output = output.concat(indent_str)
                output = output.concat(TIL_PREFIX)
                output = output.concat("Array_delete(&")
                output = output.concat(variadic_arr_var)
                output = output.concat(");\n")
            }

            // Record in hoisted_exprs map using line:col as key
            mut arg_key := arg.line.to_str().concat(":").concat(arg.col.to_str())
            ctx.hoisted_exprs.set(arg_key, temp_var)

            mut hoisted_arg := HoistedArg()
            hoisted_arg.index = idx
            hoisted_arg.temp_var = temp_var
            hoisted.push(hoisted_arg)
        }
        // Handle non-throwing variadic calls
        else if variadic_info.is_variadic {
            // RECURSIVELY hoist any throwing/variadic calls in this call's arguments first
            mut nested_hoisted := Map.new(I64, Str)
            if gt(arg.params.len(), 1) {
                mut nested_vec := hoist_throwing_args(arg.params, output, indent, ctx, context)
                // Convert Vec<HoistedArg> to Map<I64, Str>
                mut nhi := 0
                while lt(nhi, nested_vec.len()) {
                    mut entry := HoistedArg()
                    nested_vec.get(nhi, entry)
                    nested_hoisted.set(entry.index, entry.temp_var)
                    nhi = add(nhi, 1)
                }
            }

            mut temp_var := next_mangled()

            // Determine return type from function
            mut c_type := "int"
            mut func_name := get_fcall_func_name(arg)
            if gt(func_name.len(), 0) {
                mut fd_result := lookup_func_by_name(context, func_name)
                if fd_result.found {
                    if gt(fd_result.func_def.return_types.len(), 0) {
                        mut ret_type := ValueType.TCustom("")
                        fd_result.func_def.return_types.get(0, ret_type)
                        c_type = til_type_to_c(ret_type)
                        catch (err: IndexOutOfBoundsError) { }
                    }
                }
            }

            // Declare temp variable
            output = output.concat(indent_str)
            output = output.concat(c_type)
            output = output.concat(" ")
            output = output.concat(temp_var)
            output = output.concat(";\n")

            // Construct variadic array
            mut variadic_args := Vec.new(Expr)
            mut vi := add(1, variadic_info.regular_count)
            while lt(vi, arg.params.len()) {
                mut varg := Expr()
                arg.params.get(vi, varg)
                variadic_args.push(varg)
                vi = add(vi, 1)
            }
            mut variadic_arr_var := hoist_variadic_args(variadic_info.elem_type, variadic_args, nested_hoisted, variadic_info.regular_count, output, indent, ctx, context)

            // Emit the function call (non-throwing, so direct assignment)
            output = output.concat(indent_str)
            output = output.concat(temp_var)
            output = output.concat(" = ")

            // Emit function name
            if gt(func_name.len(), 0) {
                output = output.concat(til_func_name(func_name))
            }
            output = output.concat("(")

            // Emit regular args (using nested hoisted temps)
            mut first := true
            mut ri := 0
            while lt(ri, variadic_info.regular_count) {
                if not(first) {
                    output = output.concat(", ")
                }
                first = false
                // Check if this arg was hoisted (Map lookup)
                mut found_hoisted := false
                mut hoisted_temp := ""
                nested_hoisted.get(ri, hoisted_temp)
                found_hoisted = true
                catch (err: KeyNotFoundError) { }
                if found_hoisted {
                    output = output.concat(hoisted_temp)
                } else {
                    mut param := Expr()
                    arg.params.get(add(ri, 1), param)
                    output = emit_expr(param, output, 0, ctx, context)
                }
                ri = add(ri, 1)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            // Emit variadic array pointer
            if not(first) {
                output = output.concat(", ")
            }
            output = output.concat("&")
            output = output.concat(variadic_arr_var)

            output = output.concat(");\n")

            // Delete the variadic array
            output = output.concat(indent_str)
            output = output.concat(TIL_PREFIX)
            output = output.concat("Array_delete(&")
            output = output.concat(variadic_arr_var)
            output = output.concat(");\n")

            // Record in hoisted_exprs map using line:col as key
            mut arg_key := arg.line.to_str().concat(":").concat(arg.col.to_str())
            ctx.hoisted_exprs.set(arg_key, temp_var)

            mut hoisted_arg := HoistedArg()
            hoisted_arg.index = idx
            hoisted_arg.temp_var = temp_var
            hoisted.push(hoisted_arg)
        }
        // Handle non-throwing, non-variadic FCalls - still need to recurse into their arguments
        // to find deeply nested variadic/throwing calls (e.g., not(or(false)))
        else {
            switch arg.node_type {
            case NodeType.FCall:
                if gt(arg.params.len(), 1) {
                    // Recurse to hoist any nested throwing/variadic calls
                    _ := hoist_throwing_args(arg.params, output, indent, ctx, context)
                }
            case:
                // Not an FCall, nothing to do
            }
        }
        idx = add(idx, 1)

        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    }

    return hoisted
}

// Hoist non-lvalue args (string literals, function calls) when the param type is Dynamic
// Returns additional hoisted args to merge with throwing hoists
hoist_for_dynamic_params := proc(args: Vec, param_types: Vec, already_hoisted: Map, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Vec throws Str, AllocError {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    mut idx := 0
    while lt(idx, args.len()) {
        mut arg := Expr()
        args.get(idx, arg)

        // Skip if already hoisted by throwing args hoister (Map lookup)
        mut already := false
        mut tmp := ""
        already_hoisted.get(idx, tmp)
        already = true
        catch (err: KeyNotFoundError) { }

        if not(already) {
            // Check if param type is Dynamic
            mut is_dynamic := false
            if lt(idx, param_types.len()) {
                mut pt := ValueType.TCustom("")
                param_types.get(idx, pt)
                switch pt {
                case ValueType.TCustom(type_name):
                    if type_name.eq("Dynamic") {
                        is_dynamic = true
                    }
                case:
                }
            }

            if is_dynamic {
                // Check if arg needs hoisting (not a simple identifier)
                mut needs_hoisting := true
                switch arg.node_type {
                case NodeType.Identifier(name):
                    // Simple identifier with no params is an lvalue, doesn't need hoisting
                    if eq(arg.params.len(), 0) {
                        needs_hoisting = false
                    }
                case NodeType.LLiteral(lit):
                    // Literals need hoisting
                    needs_hoisting = true
                case NodeType.FCall:
                    // Function calls need hoisting
                    needs_hoisting = true
                case:
                    // Default to hoisting for safety
                    needs_hoisting = true
                }

                if needs_hoisting {
                    // Determine C type based on what the arg is
                    mut c_type := "int64_t"
                    switch arg.node_type {
                    case NodeType.LLiteral(lit):
                        switch lit {
                        case Literal.Str(s):
                            c_type = concat(TIL_PREFIX, "Str")
                        case Literal.Number(n):
                            c_type = "int64_t"
                        case Literal.List(l):
                            c_type = "int64_t"  // TODO: proper list type
                        }
                    case NodeType.FCall:
                        // For function calls, try to determine return type
                        mut info := check_throwing_fcall(arg, ctx, context)
                        if info.is_throwing {
                            if info.has_return_type {
                                c_type = til_type_to_c(info.return_type)
                            }
                        } else {
                            // Non-throwing function call - look up return type
                            mut func_name := get_fcall_func_name(arg)
                            if gt(func_name.len(), 0) {
                                mut fd_result := lookup_func_by_name(context, func_name)
                                if fd_result.found {
                                    if gt(fd_result.func_def.return_types.len(), 0) {
                                        mut ret_type := ValueType.TCustom("")
                                        fd_result.func_def.return_types.get(0, ret_type)
                                        c_type = til_type_to_c(ret_type)
                                        catch (err: IndexOutOfBoundsError) { }
                                    }
                                }
                            }
                        }
                    case:
                        c_type = "int64_t"  // Default to int64_t for unknown types
                    }

                    mut temp_var := next_mangled()

                    // Emit: til_Str _tmpXX = <expression>;
                    output = output.concat(indent_str)
                    output = output.concat(c_type)
                    output = output.concat(" ")
                    output = output.concat(temp_var)
                    output = output.concat(" = ")
                    output = emit_expr(arg, output, 0, ctx, context)
                    output = output.concat(";\n")

                    mut hoisted_arg := HoistedArg()
                    hoisted_arg.index = idx
                    hoisted_arg.temp_var = temp_var
                    hoisted.push(hoisted_arg)
                }
            }
        }

        idx = add(idx, 1)

        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    return hoisted
}

// Hoist variadic arguments into a til_Array
// Returns the array variable name
hoist_variadic_args := proc(elem_type: Str, variadic_args: Vec, already_hoisted: Map, regular_count: I64, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str, AllocError {
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = indent_str.concat("    ")
        ind = add(ind, 1)
    }

    mut arr_var := next_mangled()
    mut err_suffix := next_mangled()
    mut variadic_count := variadic_args.len()

    // Declare the array variable
    output = output.concat(indent_str)
    output = output.concat(TIL_PREFIX)
    output = output.concat("Array ")
    output = output.concat(arr_var)
    output = output.concat(";\n")

    // Declare error vars for Array.new (AllocError) and Array.set (IndexOutOfBoundsError)
    output = output.concat(indent_str)
    output = output.concat(TIL_PREFIX)
    output = output.concat("AllocError _err_alloc_")
    output = output.concat(err_suffix)
    output = output.concat(";\n")

    output = output.concat(indent_str)
    output = output.concat(TIL_PREFIX)
    output = output.concat("IndexOutOfBoundsError _err_idx_")
    output = output.concat(err_suffix)
    output = output.concat(";\n")

    // Hoist variadic args into temp vars (needed to pass address to Array.set)
    mut arg_temps := Vec.new(Str)
    mut c_elem_type := concat(TIL_PREFIX, elem_type)
    mut i := 0
    while lt(i, variadic_count) {
        mut arg := Expr()
        variadic_args.get(i, arg)
        mut hoisted_idx := add(regular_count, i)

        // Check if already hoisted (Map lookup)
        mut found_hoisted := false
        mut temp := ""
        already_hoisted.get(hoisted_idx, temp)
        found_hoisted = true
        catch (err: KeyNotFoundError) { }

        if found_hoisted {
            arg_temps.push(temp)
        } else {
            // Need to hoist into a temp
            mut temp_var := next_mangled()
            output = output.concat(indent_str)
            output = output.concat(c_elem_type)
            output = output.concat(" ")
            output = output.concat(temp_var)
            output = output.concat(" = ")
            output = emit_expr(arg, output, 0, ctx, context)
            output = output.concat(";\n")
            arg_temps.push(temp_var)
        }

        i = add(i, 1)
    }

    // Emit Array.new call with error handling
    output = output.concat(indent_str)
    output = output.concat("int _arr_status_")
    output = output.concat(err_suffix)
    output = output.concat(" = ")
    output = output.concat(TIL_PREFIX)
    output = output.concat("Array_new(&")
    output = output.concat(arr_var)
    output = output.concat(", &_err_alloc_")
    output = output.concat(err_suffix)
    output = output.concat(", \"")
    output = output.concat(elem_type)
    output = output.concat("\", ")
    output = output.concat(I64.to_str(variadic_count))
    output = output.concat(");\n")

    // Emit error check for Array.new
    output = output.concat(indent_str)
    output = output.concat("if (_arr_status_")
    output = output.concat(err_suffix)
    output = output.concat(" != 0) {\n")
    // Propagate AllocError if current function throws it
    mut curr_idx := 0
    while lt(curr_idx, ctx.current_throw_types.len()) {
        mut curr_throw := ValueType.TCustom("")
        ctx.current_throw_types.get(curr_idx, curr_throw)
        switch curr_throw {
        case ValueType.TCustom(curr_type_name):
            if curr_type_name.eq("AllocError") {
                output = output.concat(indent_str)
                output = output.concat("    *_err")
                output = output.concat(I64.to_str(add(curr_idx, 1)))
                output = output.concat(" = _err_alloc_")
                output = output.concat(err_suffix)
                output = output.concat("; return ")
                output = output.concat(I64.to_str(add(curr_idx, 1)))
                output = output.concat(";\n")
            }
        case:
            // Skip
        }
        curr_idx = add(curr_idx, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    output = output.concat(indent_str)
    output = output.concat("}\n")

    // Emit Array.set for each variadic arg
    i = 0
    while lt(i, arg_temps.len()) {
        mut temp := ""
        arg_temps.get(i, temp)

        output = output.concat(indent_str)
        output = output.concat("_arr_status_")
        output = output.concat(err_suffix)
        output = output.concat(" = ")
        output = output.concat(TIL_PREFIX)
        output = output.concat("Array_set(&_err_idx_")
        output = output.concat(err_suffix)
        output = output.concat(", &")
        output = output.concat(arr_var)
        output = output.concat(", ")
        output = output.concat(I64.to_str(i))
        output = output.concat(", &")
        output = output.concat(temp)
        output = output.concat(");\n")

        // Error check for Array.set
        output = output.concat(indent_str)
        output = output.concat("if (_arr_status_")
        output = output.concat(err_suffix)
        output = output.concat(" != 0) {\n")
        curr_idx = 0
        while lt(curr_idx, ctx.current_throw_types.len()) {
            mut curr_throw := ValueType.TCustom("")
            ctx.current_throw_types.get(curr_idx, curr_throw)
            switch curr_throw {
            case ValueType.TCustom(curr_type_name):
                if curr_type_name.eq("IndexOutOfBoundsError") {
                    output = output.concat(indent_str)
                    output = output.concat("    *_err")
                    output = output.concat(I64.to_str(add(curr_idx, 1)))
                    output = output.concat(" = _err_idx_")
                    output = output.concat(err_suffix)
                    output = output.concat("; return ")
                    output = output.concat(I64.to_str(add(curr_idx, 1)))
                    output = output.concat(";\n")
                }
            case:
                // Skip
            }
            curr_idx = add(curr_idx, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        output = output.concat(indent_str)
        output = output.concat("}\n")

        i = add(i, 1)
    }

    return arr_var
}

emit_fcall := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // First param is the function name (or Type.method for type-qualified calls)
    mut params_len := expr.params.len()
    if lt(params_len, 1) {
        throw "ccodegen: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Get function name (handles both nested identifiers and precomp'd "Type.method" strings)
    mut func_name_result := get_func_name_string(first)
    if not(func_name_result.found) {
        throw "ccodegen: FCall first param not Identifier"
    }
    mut func_name := func_name_result.name

    // For builtins, we need the original name without underscore conversion
    mut orig_func_name := ""
    switch first.node_type {
    case NodeType.Identifier(name):
        if first.params.len().eq(0) {
            orig_func_name = name
        } else {
            orig_func_name = func_name.replace("_", ".")
        }
    case:
        orig_func_name = func_name.replace("_", ".")
    }
    catch (err: AllocError) { throw err.msg }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    mut mangled_name := ""
    ctx.nested_func_names.get(orig_func_name, mangled_name)
    if gt(mangled_name.len(), 0) {
        func_name = mangled_name
    }
    catch (err: KeyNotFoundError) { /* not a nested function, use original name */ }

    // NOTE: Old variadic param method handling (args.len(), args.get()) removed
    // Variadic params are now til_Array* so standard Array methods work

    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = result.concat("    ")
        ind = add(ind, 1)
    }

    // Check for type-qualified call on FCall result: func_name(fcall_result, args...)
    // This happens for chained method calls like delimiter.len().eq(0)
    // Parser produces: FCall { params: [Identifier("eq"), FCall { ... }, LLiteral(0)] }
    // Only check this for simple func names (no nested identifiers)
    if first.params.len().eq(0).and(gteq(params_len, 2)) {
        mut second_param := Expr()
        expr.params.get(1, second_param)
        switch second_param.node_type {
        case NodeType.FCall:
            // The second param is an FCall result - use get_value_type to get its return type
            mut fcall_ret_type := get_value_type(context, second_param)
            switch fcall_ret_type {
            case ValueType.TCustom(type_name):
                mut candidate := format(type_name, ".", orig_func_name)
                // Try to lookup the function - if found, emit as Type_method
                mut func_info := context.scope_stack.lookup_func(candidate)
                // If we get here, the function was found (otherwise KeyNotFoundError)
                // Emit as Type_method(fcall_result, args...)
                result = result.concat(TIL_PREFIX)
                result = result.concat(type_name)
                result = result.concat("_")
                result = result.concat(orig_func_name)
                result = result.concat("(")
                // First arg is the fcall result
                result = emit_expr(second_param, result, 0, ctx, context)
                // Remaining args
                mut arg_i := 2
                while lt(arg_i, params_len) {
                    result = result.concat(", ")
                    mut arg := Expr()
                    expr.params.get(arg_i, arg)
                    result = emit_expr(arg, result, 0, ctx, context)
                    arg_i = add(arg_i, 1)
                }
                result = result.concat(")")
                if gt(indent, 0) {
                    result = result.concat(";\n")
                }
                return result
            case:
                // Not a custom type, skip
            }
            catch (err: Str) { /* get_value_type failed, fall through */ }
            catch (err: KeyNotFoundError) { /* function not found, fall through */ }
        case:
            // Not an FCall, skip
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Hardcoded builtins (compile-time intrinsics that can't be implemented in TIL)
    // loc() is now resolved in precomp phase, so it never reaches here

    // enum_to_str(e) - get enum variant name as string
    // Emits call to til_EnumType_to_str(e) which was generated during enum emission
    if orig_func_name.eq("enum_to_str") {
        if lt(params_len, 2) {
            throw "ccodegen: enum_to_str requires 1 argument"
        }
        mut arg := Expr()
        expr.params.get(1, arg)
        // Get the enum type from the argument
        value_type := get_value_type(context, arg)
        switch value_type {
        case ValueType.TCustom(enum_type_name):
            // Verify it's an enum type
            _ := context.scope_stack.lookup_enum(enum_type_name)
            result = result.concat(til_name(enum_type_name)).concat("_to_str(")
            result = emit_expr(arg, result, 0, ctx, context)
            result = result.concat(")")
            if gt(indent, 0) {
                result = result.concat(";\n")
            }

            catch (err: KeyNotFoundError) {
                throw format("ccodegen: enum_to_str argument '", enum_type_name, "' is not an enum type")
            }
            return result
        case:
            throw format("ccodegen: enum_to_str argument has non-custom type")
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    } else if orig_func_name.eq("size_of") {
        // size_of(T) - runtime type size lookup via til_size_of function
        // Can be called with a literal type name (size_of(Str)) or a Type variable (size_of(T))
        if lt(params_len, 2) {
            throw "ccodegen: size_of requires 1 argument"
        }
        mut arg := Expr()
        expr.params.get(1, arg)
        result = result.concat(TIL_PREFIX)
        result = result.concat("size_of(")
        // If it's a literal type name, emit compound literal
        // If it's a variable, the variable already holds a Type (which is const char*)
        switch arg.node_type {
        case NodeType.Identifier(type_name):
            // Check if this is a Type variable or a literal type name
            // Type variables are declared with value_type TCustom("Type")
            mut is_type_var := false
            mut sym := context.scope_stack.lookup_symbol(type_name)
            switch sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    is_type_var = true
                }
            case:
            }
            catch (err: KeyNotFoundError) { }
            if is_type_var {
                // Type variable - already a const char*, wrap in Str struct literal
                // Note: Type is const char*, so we construct Str at runtime
                result = format(result, "((", TIL_PREFIX, "Str){(", TIL_PREFIX, "I64)", TIL_PREFIX, type_name, ", strlen(", TIL_PREFIX, type_name, ")})")
            } else {
                // Literal type name - create Str compound literal
                result = emit_str_literal(type_name, result)
            }
        case:
            // Not an identifier - emit as expression (should be Type/const char*)
            result = format(result, "((", TIL_PREFIX, "Str){(", TIL_PREFIX, "I64)")
            result = emit_expr(arg, result, 0, ctx, context)
            result = result.concat(", strlen(")
            result = emit_expr(arg, result, 0, ctx, context)
            result = result.concat(")})")
        }
        result = result.concat(")")
        if gt(indent, 0) {
            result = result.concat(";\n")
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
        catch (err: I64_OverflowError) { throw err.msg }
        return result
    } else if orig_func_name.eq("to_ptr") {
        // to_ptr(var) - get address of variable
        // For Dynamic params (already void*), just cast without taking address
        if lt(params_len, 2) {
            throw "ccodegen: to_ptr requires 1 argument"
        }
        mut arg := Expr()
        expr.params.get(1, arg)
        // Check if arg is a Dynamic parameter (void*) - just use the pointer directly
        // Both mut Dynamic (void**) and non-mut Dynamic (void*) don't need &
        mut is_dynamic_param := false
        switch arg.node_type {
        case NodeType.Identifier(name):
            if eq(arg.params.len(), 0) {
                mut sym := context.scope_stack.lookup_symbol(name)
                switch sym.value_type {
                case ValueType.TCustom(t):
                    if t.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
                catch (err: KeyNotFoundError) { }
            }
        case:
        }
        result = result.concat("(")
        result = result.concat(TIL_PREFIX)
        result = result.concat("I64)")
        if is_dynamic_param {
            // Dynamic param: just output the variable name (it's already a pointer)
            switch arg.node_type {
            case NodeType.Identifier(name):
                result = result.concat(til_name(name))
            case:
            }
        } else {
            result = result.concat("&")
            result = emit_expr(arg, result, 0, ctx, context)
        }
        if gt(indent, 0) {
            result = result.concat(";\n")
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else {
        // User-defined function call
        // Check for struct construction: TypeName() -> (til_TypeName){defaults...}
        // Struct names are PascalCase, no underscore in func_name (meaning not Type_method), no args
        mut first_char := func_name.get_substr(0, 1)
        if first_char.is_uppercase().and(not(func_name.contains("_"))).and(params_len.eq(1)) {
            // Look up struct definition to get default values
            mut struct_found := false
            mut struct_def := context.scope_stack.lookup_struct(func_name)
            struct_found = true
            catch (err: KeyNotFoundError) { }

            if struct_found {
                if struct_def.members.len().eq(0).or(struct_def.default_values.len().eq(0)) {
                    result = result.concat("(").concat(TIL_PREFIX).concat(func_name).concat("){}")
                } else {
                    // Check if any default value is a throwing function call
                    // Such calls need out-params and can't be inlined in struct initializers
                    mut throwing_defaults := Map.new(Str, Str)  // member_name -> temp_var
                    mut member_idx := 0
                    while lt(member_idx, struct_def.members.len()) {
                        mut member := Declaration()
                        struct_def.members.get(member_idx, member)
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                        if member.is_mut {
                            mut default_expr := Expr()
                            struct_def.default_values.get(member.name, default_expr)
                            if is_throwing_fcall(default_expr, context) {
                                // Emit the throwing call as a separate statement
                                result = hoist_throwing_expr(default_expr, result, indent, ctx, context)
                                // Get the temp var that was just generated (it's in hoisted_exprs)
                                mut expr_key := default_expr.line.to_str().concat(":").concat(default_expr.col.to_str())
                                mut temp_var := ""
                                ctx.hoisted_exprs.get(expr_key, temp_var)
                                throwing_defaults.set(member.name, temp_var)
                                catch (err: KeyNotFoundError) { }
                            }
                            catch (err: KeyNotFoundError) { }
                        }
                        member_idx = add(member_idx, 1)
                    }

                    // Now emit the struct initializer
                    // Need to add indentation if we emitted throwing calls
                    if gt(throwing_defaults.len(), 0) {
                        mut ind := 0
                        while lt(ind, indent) {
                            result = result.concat("    ")
                            ind = add(ind, 1)
                        }
                    }
                    result = result.concat("(").concat(TIL_PREFIX).concat(func_name).concat("){")
                    mut is_first := true
                    member_idx = 0
                    while lt(member_idx, struct_def.members.len()) {
                        mut member := Declaration()
                        struct_def.members.get(member_idx, member)
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                        if not(member.is_mut) {
                            member_idx = add(member_idx, 1)
                        } else {
                            if not(is_first) {
                                result = result.concat(", ")
                            }
                            is_first = false
                            result = result.concat(".").concat(member.name).concat(" = ")
                            // Check if this was a throwing default - use temp var instead
                            mut temp_var := ""
                            throwing_defaults.get(member.name, temp_var)
                            if gt(temp_var.len(), 0) {
                                result = result.concat(temp_var)
                            } else {
                                mut default_found := false
                                mut default_expr := Expr()
                                struct_def.default_values.get(member.name, default_expr)
                                default_found = true
                                catch (err: KeyNotFoundError) { }
                                if default_found {
                                    result = emit_expr(default_expr, result, 0, ctx, context)
                                } else {
                                    result = result.concat("0")
                                }
                            }
                            catch (err: KeyNotFoundError) { }
                            member_idx = add(member_idx, 1)
                        }
                    }
                    result = result.concat("}")
                }
            } else {
                result = result.concat("(").concat(TIL_PREFIX).concat(func_name).concat("){}")
            }

            if gt(indent, 0) {
                result = result.concat(";\n")
            }
            return result
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        // Regular function call
        // func_name already has underscores from get_func_name_string

        // Check if this is an enum variant constructor (Type_Variant)
        // Need to emit til_Type_make_Variant instead of til_Type_Variant
        mut is_enum_constructor := false
        mut enum_type_name := ""
        mut enum_variant_name := ""
        if func_name.contains("_") {
            // Check if Type_Variant where Type is an enum and Variant is a variant
            parts := func_name.split("_")
            if parts.len().gteq(2) {
                mut type_name := ""
                parts.get(0, type_name)
                mut variant_name := ""
                parts.get(1, variant_name)
                mut found_enum := false
                enum_def := context.scope_stack.lookup_enum(type_name)
                found_enum = true
                catch (err: KeyNotFoundError) { }
                if found_enum {
                    // Check if this variant exists in the enum
                    if enum_def.enum_map.contains_key(variant_name) {
                        is_enum_constructor = true
                        enum_type_name = type_name
                        enum_variant_name = variant_name
                    }
                }
            }
        }

        result = result.concat(TIL_PREFIX)
        if is_enum_constructor {
            // Emit til_Type_make_Variant
            result = result.concat(enum_type_name)
            result = result.concat("_make_")
            result = result.concat(enum_variant_name)
        } else {
            result = result.concat(func_name)
        }
        result = result.concat("(")

        // Check if this is a variadic function
        mut variadic_info := VariadicParamInfo()
        mut is_variadic := false
        ctx.func_variadic_args.get(orig_func_name, variadic_info)
        is_variadic = true
        catch (err: KeyNotFoundError) {
            is_variadic = false
        }

        // Detect and construct variadic array if needed (only at statement level)
        mut variadic_arr_var := ""
        mut has_variadic_arr := false
        if is_variadic.and(gt(indent, 0)) {
            // Collect variadic args
            mut variadic_args := Vec.new(Expr)
            mut regular_end := add(variadic_info.regular_count, 1)  // +1 to skip func name
            mut vi := regular_end
            while lt(vi, params_len) {
                mut varg := Expr()
                expr.params.get(vi, varg)
                variadic_args.push(varg)
                vi = add(vi, 1)
            }
            // Use empty hoisted map since we're not hoisting args here
            mut empty_hoisted := Map.new(I64, Str)
            variadic_arr_var = hoist_variadic_args(variadic_info.elem_type, variadic_args, empty_hoisted, variadic_info.regular_count, result, indent, ctx, context)
            has_variadic_arr = true
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }

        if is_variadic {
            // Emit regular args first
            mut i := 1
            mut regular_end := add(variadic_info.regular_count, 1)  // +1 to skip func name
            while lt(i, regular_end) {
                if gt(i, 1) {
                    result = result.concat(", ")
                }
                mut arg := Expr()
                expr.params.get(i, arg)
                result = emit_expr(arg, result, 0, ctx, context)
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            // Emit variadic array pointer
            if has_variadic_arr {
                if gt(variadic_info.regular_count, 0) {
                    result = result.concat(", ")
                }
                result = result.concat("&")
                result = result.concat(variadic_arr_var)
            }
        } else {
            // Non-variadic: emit args normally
            // Look up function to get parameter info (is_mut flags)
            // Use orig_func_name which is the canonical name for scope lookup
            // For ext_func, don't pass mut params by reference (mut is just documentation)
            mut param_info := Vec.new(Declaration)
            mut is_ext_func := false
            mut lookup_result := lookup_func_by_name(context, orig_func_name)
            if lookup_result.found {
                param_info = lookup_result.func_def.args
                is_ext_func = lookup_result.func_def.is_ext
            }
            catch (err: AllocError) { throw err.msg }

            mut i := 1
            while lt(i, params_len) {
                if gt(i, 1) {
                    result = result.concat(", ")
                }
                mut arg := Expr()
                expr.params.get(i, arg)
                // Check if we should add & for mut param
                // For ext_func, don't treat mut as pass-by-reference
                mut arg_idx := sub(i, 1)
                mut should_add_ampersand := false
                if gt(param_info.len(), 0).and(not(is_ext_func)) {
                    if lt(arg_idx, param_info.len()) {
                        mut param_decl := Declaration()
                        param_info.get(arg_idx, param_decl)
                        if param_decl.is_mut {
                            // Check if arg is a simple identifier
                            switch arg.node_type {
                            case NodeType.Identifier(arg_name):
                                if eq(arg.params.len(), 0) {
                                    should_add_ampersand = true
                                }
                            case:
                            }
                        }
                    }
                }
                if should_add_ampersand {
                    result = result.concat("&")
                }
                result = emit_expr(arg, result, 0, ctx, context)
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        result = result.concat(")")
        // Only add statement terminator if this is a statement (indent > 0)
        if gt(indent, 0) {
            result = result.concat(";\n")
        }

        // Emit Array.delete if variadic array was constructed
        if has_variadic_arr {
            mut ind := 0
            while lt(ind, indent) {
                result = result.concat("    ")
                ind = add(ind, 1)
            }
            result = result.concat(TIL_PREFIX)
            result = result.concat("Array_delete(&")
            result = result.concat(variadic_arr_var)
            result = result.concat(");\n")
        }

        return result
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit identifier without its nested params (for type-qualified receiver)
emit_identifier_without_nested := proc(expr: Expr, output: Str) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Identifier(name):
        return concat(output, name)
    case:
        throw "ccodegen: expected identifier"
    }
}

// Helper to emit a Str compound literal: ((til_Str){(til_I64)"...", len})
// This is valid in both constant initializers and expressions (unlike til_Str_from_literal)
emit_str_literal := proc(s: Str, output: Str) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
    return format(output, "((", TIL_PREFIX, "Str){(", TIL_PREFIX, "I64)\"", s, "\", ", s.len().to_str(), "})")
}

emit_literal := proc(lit: Literal, output: Str, context: Context) returns Str throws Str {
    mut result := ""
    switch lit {
    case Literal.Str(s):
        if has_str(context) {
            result = emit_str_literal(s, output)
        } else {
            result = format(output, "\"", s, "\"")
        }
    case Literal.Number(n):
        result = concat(output, n)
    case Literal.List(l):
        throw "ccodegen: List literals not yet supported"
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return result
}
