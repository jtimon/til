// C code generator for TIL
// Translates TIL AST to C source code

mode liba

import("self.parser")
import("self.init")
import("self.typer")

// Prefix for all TIL-generated names in C code (structs, functions, types)
TIL_PREFIX := "til_"

// Helper: Sort Vec<EnumVariant> by name field in-place (simple bubble sort)
sort_enum_variants := proc(mut v: Vec) {
    mut n := v.len()
    while gt(n, 1) {
        mut new_n := 0
        for i in 1..n {
            mut prev := EnumVariant()
            mut curr := EnumVariant()
            v.get(i.sub(1), prev)?
            v.get(i, curr)?
            if gt(prev.name.cmp(curr.name), 0) {
                v.set(i.sub(1), curr)?
                v.set(i, prev)?
                new_n = i
            }
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "sort_enum_variants: ", err.msg)
            }
        }
        n = new_n
    }
}

// Codegen context for tracking function info
CodegenContext := struct {
    // Counter for generating unique temp variable names (deterministic per-compilation)
    mut mangling_counter: I64 = 0
    // Map function name -> variadic arg info
    mut func_variadic_args: Map = Map.new(Str, VariadicParamInfo)
    // Currently generating function's throw types (if any)
    mut current_throw_types: Vec = Vec.new(ValueType)
    // Currently generating function's return types (if any)
    mut current_return_types: Vec = Vec.new(ValueType)
    // Set of declared variable names in current function (to avoid redefinition)
    mut declared_vars: Set = Set.new(Str)
    // Set of by-ref param names in current function - for using -> instead of . for field access
    mut current_ref_params: Set = Set.new(Str)
    // Map of variadic param names to their element type (e.g., "args" -> "Bool")
    // Passed as til_Array* so need dereference, and need type info for Array.get casting
    mut current_variadic_params: Map = Map.new(Str, Str)
    // All known type names for generating til_size_of function
    mut known_types: Vec = Vec.new(Str)
    // Map of locally-caught error types to catch label info
    // For explicit throw statements that have a local catch block
    mut local_catch_labels: Map = Map.new(Str, CatchLabelInfo)
    // Current function name for nested function name mangling (empty at top-level)
    mut current_function_name: Str = ""
    // C code for hoisted nested function definitions
    mut hoisted_functions: Vec = Vec.new(Str)
    // C code for hoisted nested function prototypes
    mut hoisted_prototypes: Vec = Vec.new(Str)
    // Map original function name -> mangled name for nested functions
    mut nested_func_names: Map = Map.new(Str, Str)

    new := func() returns CodegenContext {
        return CodegenContext()
    }
}

// Generate unique mangled name using context counter (deterministic)
// Includes function name prefix for uniqueness across functions
next_mangled := func(mut ctx: CodegenContext) returns Str {
    n := ctx.mangling_counter
    ctx.mangling_counter = ctx.mangling_counter.add(1)
    func_name := ctx.current_function_name
    mut result := ""
    if not(func_name.is_empty()) {
        result = format("_tmp_", func_name, "_", n.to_str())
    } else {
        result = format("_tmp_", n.to_str())
    }

    return result
}

// Returns the C name for a TIL identifier - adds TIL_PREFIX
// Exceptions: C keywords (true, false), pointer deref (*name), and generated names (_ prefix)
til_name := func(name: Str) returns Str {
    mut result := name
    switch name {
    case "true":
    case "false":
    case:
        if name.starts_with("*").or(name.starts_with("_")) {
        } else {
            result = format(TIL_PREFIX, name)
        }
    }

    return result
}

// Emit a struct literal, using compound literal syntax if already_declared
// e.g., " = {0}" vs " = (til_TypeName){0}"
emit_struct_literal_assign := proc(mut output: Str, type_name: Str, already_declared: Bool, literal_content: Str) {
    output.push_str(" = ")
    if already_declared {
        output.push_str("(")
        output.push_str(til_name(type_name))
        output.push_str(")")
    }
    output.push_str(literal_content)
    output.push_str(";\n")
}

// Start a struct literal assignment - caller will emit content and closing brace
// e.g., " = " vs " = (til_TypeName)"
emit_struct_literal_start := proc(mut output: Str, type_name: Str, already_declared: Bool) {
    output.push_str(" = ")
    if already_declared {
        output.push_str("(")
        output.push_str(til_name(type_name))
        output.push_str(")")
    }
}

// Returns the C name for a TIL function - adds TIL_PREFIX and converts dots to underscores
// Used for function names like Array.len -> til_Array_len
til_func_name := func(name: Str) returns Str {
    result := format(TIL_PREFIX, name.replace(".", "_"))

    return result
}

// Get function name from FCall's first param, handling both AST patterns:
// - Identifier("func") with params = [] -> "func"
// - Identifier("I64.inc") with params = [] -> "I64_inc" (from precomp)
// - Identifier("Vec") with params = [Identifier("new")] -> "Vec_new" (from parser)
// Returns the C-ready name with underscores (not dots)
get_func_name_string := func(first_param: Expr) returns Str throws Str {
    switch first_param.node_type {
    case NodeType.Identifier(name):
        if first_param.params.is_empty() {
            return name.replace(".", "_")
        } else {
            mut parts := Vec.new(Str)
            parts.push(name)
            for p: Expr in first_param.params {
                switch p.node_type {
                case NodeType.Identifier(part_name):
                    parts.push(part_name)
                case:
                }
            }
            return parts.join("_")
        }
    case:
        throw "get_func_name_string: not an Identifier"
    }

}

// Get TIL function name from FCall's first param (for scope lookups)
// Returns the dot-separated name like "Vec.new" or "I64.inc"
// This avoids the fragile .replacen('_', ".", 1) hack which breaks on type names with underscores
get_til_func_name_string := func(first_param: Expr) returns Str throws Str {
    switch first_param.node_type {
    case NodeType.Identifier(name):
        if first_param.params.is_empty() {
            // Already has dots (from precomp) or is a simple name
            return name
        } else {
            // Build dotted name from nested identifiers
            mut parts := Vec.new(Str)
            parts.push(name)
            for p: Expr in first_param.params {
                switch p.node_type {
                case NodeType.Identifier(part_name):
                    parts.push(part_name)
                case:
                }
            }
            return parts.join(".")
        }
    case:
        throw "get_til_func_name_string: not an Identifier"
    }

}

/// Check if an expression is a type identifier (a Type parameter at call site)
/// Returns the type name if it is, so it can be emitted as a string literal
/// Matches interpreter.rs behavior (line 1703-1713)
/// Only matches STANDALONE identifiers - not field access like Vec.INIT_CAP
get_type_arg_name := func(expr: Expr, context: Context) returns Str throws KeyNotFoundError {
    switch expr.node_type {
    case NodeType.Identifier(name):
        // Only match standalone identifiers (no field access)
        if not(expr.params.is_empty()) {
            throw KeyNotFoundError(msg="field access, not type arg")
        }
        // Check if this identifier is a type name (struct, enum, or builtin type)
        sym := context.scope_stack.lookup_symbol(name)?
        switch sym.value_type {
        case ValueType.TType:
            return name
        case:
            throw KeyNotFoundError(msg="not a type")
        }
    case:
        throw KeyNotFoundError(msg="not an identifier")
    }
}

// Get function definition for an FCall expression
// Uses get_func_def_for_fcall_with_expr from typer.rs which handles all cases correctly
// (regular functions, struct methods, UFCS - though UFCS is already resolved by precomp)
// Returns None for struct/enum constructors
get_fcall_func_def := proc(context: Context, fcall_expr: Expr) returns SFuncDef throws KeyNotFoundError {
    mut expr_clone := fcall_expr.clone()
    result := get_func_def_for_fcall_with_expr(context, expr_clone)?

    catch (err: Str) { throw KeyNotFoundError(msg=err) }

    return result
}

/// Bug #60: Determine if a parameter should be passed by reference (pointer)
/// - copy params: pass by value (copy is made)
/// - Type params: already pointers (const char*), pass by value
/// - All other const/own/mut params (including Dynamic): pass by pointer
param_needs_by_ref := func(param: Declaration) returns Bool {
    if param.is_copy {
        return false
    }
    // Type is already a pointer type in C (const char*), no extra indirection needed
    switch param.value_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Type") {
            return false
        }
        return true
    case:
        return true
    }
}

/// Extract struct field type dependencies for topological sorting
/// Returns the type name if it's a custom type that needs to be defined first
get_field_type_dependency := func(value_type: ValueType) returns Str throws KeyNotFoundError {
    switch value_type {
    case ValueType.TCustom(name):
        // I64 and U8 are primitives, not struct dependencies
        switch name {
        case "I64":
            throw KeyNotFoundError(msg="primitive")
        case "U8":
            throw KeyNotFoundError(msg="primitive")
        case:
            if name.eq(INFER_TYPE) {
                panic(loc(), "INFER_TYPE in ccodegen - should have been resolved by typer")
            }
            return name
        }
    case:
        throw KeyNotFoundError(msg="not custom type")
    }
}

/// Get struct dependencies (other struct types used as fields)
get_struct_dependencies := func(expr: Expr) returns Vec throws Str {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration:
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef(struct_def):
                for member: Declaration in struct_def.members {
                    if member.is_mut {
                        dep := get_field_type_dependency(member.value_type)?
                        deps.push(dep)
                        catch (err: KeyNotFoundError) {
                            // REM: Not a custom type dependency, skip
                        }
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return deps
}

/// Get struct name from a struct declaration expression
get_struct_name := func(expr: Expr) returns Str throws KeyNotFoundError, Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef:
                return decl.name
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    throw KeyNotFoundError(msg="not a struct declaration")
}

/// Get enum dependencies (types used in payloads) as a Vec
get_enum_dependencies := func(expr: Expr) returns Vec throws Str {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration:
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef(enum_def):
                for variant: EnumVariant in enum_def.variants {
                    if not(variant.payload_type.is_null()) {
                        mut pt := ValueType.TCustom("")
                        memcpy(to_ptr(pt), variant.payload_type.data, size_of(ValueType))
                        switch pt {
                        case ValueType.TCustom(type_name):
                            // Skip primitives (but NOT Str or Bool - they're structs)
                            if not(type_name.eq("I64")).and(not(type_name.eq("U8"))).and(not(type_name.eq("Dynamic"))).and(not(type_name.eq("Type"))) {
                                deps.push(type_name.clone())
                            }
                        case:
                        }
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return deps
}

/// Get enum name from an enum-with-payloads declaration expression
get_enum_name := func(expr: Expr) returns Str throws KeyNotFoundError, Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef:
                return decl.name
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    throw KeyNotFoundError(msg="not an enum declaration")
}

/// Get dependencies for a type (struct or enum-with-payloads)
get_type_dependencies := func(expr: Expr) returns Vec throws Str {
    if is_struct_declaration(expr) {
        return get_struct_dependencies(expr)?
    } else if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_dependencies(expr)?
    } else {
        return Vec.new(Str)
    }
}

/// Get name for a type (struct or enum-with-payloads)
get_type_name := func(expr: Expr) returns Str throws KeyNotFoundError, Str {
    if is_struct_declaration(expr) {
        return get_struct_name(expr)?
    } else if is_enum_declaration(expr).and(is_enum_with_payloads(expr)) {
        return get_enum_name(expr)?
    } else {
        throw KeyNotFoundError(msg="not a type declaration")
    }
}

/// Topologically sort type declarations (structs and enums-with-payloads) by their dependencies
/// Returns indices into the original vector in sorted order
topological_sort_types := func(types: Vec) returns Vec throws Str {
    // Build name -> index map
    mut name_to_idx := Map.new(Str, I64)
    mut idx := 0
    while idx.lt(types.len()) {
        mut expr := Expr()
        types.get(idx, expr)?
        name := get_type_name(expr)?
        name_to_idx.set(name, idx)
        catch (err: KeyNotFoundError) {
            // REM: Not a type declaration, skip
        }
        idx.inc()
    }

    // Build adjacency list (dependencies)
    mut deps := Vec.new(Vec)
    mut i := 0
    while i.lt(types.len()) {
        deps.push(Vec.new(I64))
        i.inc()
    }
    idx = 0
    while idx.lt(types.len()) {
        mut dep_expr := Expr()
        types.get(idx, dep_expr)?
        dep_names := get_type_dependencies(dep_expr)?
        for dep_name: Str in dep_names {
            if name_to_idx.contains_key(dep_name) {
                mut dep_idx := 0
                name_to_idx.get(dep_name, dep_idx)?
                if not(dep_idx.eq(idx)) {
                    mut dep_vec := Vec.new(I64)
                    deps.get(idx, dep_vec)?
                    dep_vec.push(dep_idx)
                    deps.set(idx, dep_vec)?
                }
            }
        }
        idx.inc()
    }

    // Kahn's algorithm for topological sort
    // If A depends on B, B must come first, so reverse the edges
    mut reverse_deps := Vec.new(Vec)
    i = 0
    while i.lt(types.len()) {
        reverse_deps.push(Vec.new(I64))
        i.inc()
    }
    idx = 0
    while idx.lt(deps.len()) {
        mut dep_list := Vec.new(I64)
        deps.get(idx, dep_list)?
        for dep: I64 in dep_list {
            mut rev_dep_vec := Vec.new(I64)
            reverse_deps.get(dep, rev_dep_vec)?
            rev_dep_vec.push(idx)
            reverse_deps.set(dep, rev_dep_vec)?
        }
        idx.inc()
    }

    // Calculate in-degree for reversed graph
    mut in_degree := Vec.new(I64)
    i = 0
    while i.lt(types.len()) {
        in_degree.push(0)
        i.inc()
    }
    for dep_list: Vec in reverse_deps {
        for dep: I64 in dep_list {
            mut degree := 0
            in_degree.get(dep, degree)?
            in_degree.set(dep, degree.add(1))?
        }
    }

    mut queue := Vec.new(I64)
    idx = 0
    while idx.lt(in_degree.len()) {
        mut queue_degree := 0
        in_degree.get(idx, queue_degree)?
        if queue_degree.eq(0) {
            queue.push(idx)
        }
        idx.inc()
    }

    mut result := Vec.new(I64)
    while not(queue.is_empty()) {
        mut pop_idx := 0
        queue.pop(pop_idx)?
        result.push(pop_idx)
        mut rev_dep_list := Vec.new(I64)
        reverse_deps.get(pop_idx, rev_dep_list)?
        for next: I64 in rev_dep_list {
            mut next_degree := 0
            in_degree.get(next, next_degree)?
            next_degree = next_degree.sub(1)
            in_degree.set(next, next_degree)?
            if next_degree.eq(0) {
                queue.push(next)
            }
        }
    }

    // If we couldn't sort all (cycle), just append remaining in original order
    if result.len().lt(types.len()) {
        idx = 0
        while idx.lt(types.len()) {
            mut found := false
            for r: I64 in result {
                if r.eq(idx) {
                    found = true
                    break
                }
            }
            if not(found) {
                result.push(idx)
            }
            idx.inc()
        }
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw err.msg }

    return result
}

/// Hoist variadic arguments into a til_Array
/// Returns the array variable name, or None if no variadic args
/// Also returns the element type for use in Array.delete
hoist_variadic_args := proc(elem_type: Str, variadic_args: Vec, already_hoisted: Map, regular_count: I64, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    indent_str := repeat("    ", indent)
    arr_var := next_mangled(ctx)
    err_suffix := next_mangled(ctx)
    variadic_count := variadic_args.len()

    // Declare the array variable
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Array ")
    output.push_str(arr_var)
    output.push_str(";\n")

    // Declare error var for Array.set (IndexOutOfBoundsError)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("IndexOutOfBoundsError __attribute__((unused)) _err_idx_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    // Hoist variadic args into temp vars (needed to pass address to Array.set)
    mut arg_temps := Vec.new(Str)
    c_elem_type := format(TIL_PREFIX, elem_type)
    mut i := 0
    while i.lt(variadic_args.len()) {
        mut arg := Expr()
        variadic_args.get(i, arg)?
        hoisted_idx := add(regular_count, i)
        if already_hoisted.contains_key(hoisted_idx) {
            // Already hoisted, use that temp
            mut temp := ""
            already_hoisted.get(hoisted_idx, temp)?
            arg_temps.push(temp)
        } else {
            // Need to hoist into a temp
            // Bug #143: Use emit_arg_string to properly handle nested FCalls that need by-ref
            arg_str := emit_arg_string(arg, Ptr(), false, output, indent, ctx, context)?
            temp_var := next_mangled(ctx)
            output.push_str(indent_str)
            output.push_str(c_elem_type)
            output.push_str(" ")
            output.push_str(temp_var)
            output.push_str(" = ")
            output.push_str(arg_str)
            output.push_str(";\n")
            arg_temps.push(temp_var)
        }
        i.inc()
    }

    // Bug #60: Hoist Type and I64 literals for Array.new call
    // Type param needs hoisting because we can't take address of string literal for const char* const*
    type_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Type ")
    output.push_str(type_temp)
    output.push_str(" = \"")
    output.push_str(elem_type)
    output.push_str("\";\n")

    // Capacity param needs hoisting because we can't take address of integer literal
    count_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("I64 ")
    output.push_str(count_temp)
    output.push_str(" = ")
    output.push_str(variadic_count.to_str())
    output.push_str(";\n")

    // Emit Array.new call (non-throwing, panics internally on malloc failure)
    // til_Array arr = til_Array_new(type_temp, &count_temp);
    output.push_str(indent_str)
    output.push_str(arr_var)
    output.push_str(" = ")
    output.push_str(TIL_PREFIX)
    output.push_str("Array_new(")
    output.push_str(type_temp)
    output.push_str(", &")
    output.push_str(count_temp)
    output.push_str(");\n")

    // Declare status variable for Array.set calls
    output.push_str(indent_str)
    output.push_str("int __attribute__((unused)) _arr_status_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    // Emit Array.set for each variadic arg
    mut ti := 0
    while ti.lt(arg_temps.len()) {
        mut temp_item := ""
        arg_temps.get(ti, temp_item)?
        // Bug #60: Hoist index literal because we can't take address of integer literal
        idx_temp := next_mangled(ctx)
        output.push_str(indent_str)
        output.push_str(TIL_PREFIX)
        output.push_str("I64 ")
        output.push_str(idx_temp)
        output.push_str(" = ")
        output.push_str(ti.to_str())
        output.push_str(";\n")

        // int _status = til_Array_set(&_err_idx, &arr, &idx_temp, (til_Dynamic*)&temp);
        output.push_str(indent_str)
        output.push_str("_arr_status_")
        output.push_str(err_suffix)
        output.push_str(" = ")
        output.push_str(TIL_PREFIX)
        output.push_str("Array_set(&_err_idx_")
        output.push_str(err_suffix)
        output.push_str(", &")
        output.push_str(arr_var)
        output.push_str(", &")
        output.push_str(idx_temp)
        output.push_str(", (")
        output.push_str(TIL_PREFIX)
        output.push_str("Dynamic*)&")
        output.push_str(temp_item)
        output.push_str(");\n")

        // Error check for Array.set (IndexOutOfBoundsError - shouldn't happen but propagate if thrown)
        output.push_str(indent_str)
        output.push_str("if (_arr_status_")
        output.push_str(err_suffix)
        output.push_str(" != 0) {\n")
        mut curr_idx := 0
        for curr_throw: ValueType in ctx.current_throw_types {
            switch curr_throw {
            case ValueType.TCustom(curr_type_name):
                if curr_type_name.eq("IndexOutOfBoundsError") {
                    output.push_str(indent_str)
                    output.push_str("    *_err")
                    output.push_str(add(curr_idx, 1).to_str())
                    output.push_str(" = _err_idx_")
                    output.push_str(err_suffix)
                    output.push_str("; return ")
                    output.push_str(add(curr_idx, 1).to_str())
                    output.push_str(";\n")
                    break
                }
            case:
            }
            curr_idx.inc()
        }
        output.push_str(indent_str)
        output.push_str("}\n")
        ti.inc()
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw format("KeyNotFoundError: ", err.msg) }

    return arr_var
}

/// Detect if an expression is a variadic function call
/// Returns VariadicFCallInfo if it's a variadic call
detect_variadic_fcall := func(expr: Expr, ctx: CodegenContext) returns VariadicFCallInfo throws KeyNotFoundError {
    if expr.params.is_empty() {
        throw KeyNotFoundError(msg="Not variadic")
    }

    // Get original TIL function name (with dots) for variadic map lookup
    mut first_param := Expr()
    expr.params.get(0, first_param)?
    orig_func_name := get_til_func_name_string(first_param)?

    mut info := VariadicFCallInfo()
    ctx.func_variadic_args.get(orig_func_name, info)?

    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError(msg="Not variadic: index error")
    }
    catch (err: Str) {
        throw KeyNotFoundError(msg="Not variadic: name error")
    }

    return VariadicFCallInfo(elem_type=info.elem_type.clone(), regular_count=info.regular_count)
}

/// Check if an expression is a pure lvalue (simple identifier or field access chain)
/// A pure lvalue can use & directly without hoisting.
/// Returns false for FCall results, enum constructors, and struct constructors.
is_pure_lvalue := func(arg: Expr, context: Context) returns Bool {
    switch arg.node_type {
    case NodeType.Identifier(name):
        if arg.params.is_empty() {
            // Simple identifier is always an lvalue
            return true
        } else {
            // Could be field access OR enum/struct constructor
            // Check if name.first_param is an enum constructor
            if not(arg.params.is_empty()) {
                mut first_param := Expr()
                arg.params.get(0, first_param)?
                switch first_param.node_type {
                case NodeType.Identifier(variant):
                    combined := format(name, ".", variant)
                    is_enum := context.scope_stack.is_enum_constructor(combined)
                    if is_enum {
                        return false  // Enum constructor is NOT an lvalue
                    }
                    // Check if it's a struct type (struct constructor like Type.CONSTANT)
                    // Rust: if context.scope_stack.lookup_struct(name).is_some() { return false; }
                    // TIL: use flag pattern since lookup_struct throws on not found
                    mut is_struct := false
                    _ := context.scope_stack.lookup_struct(name)?
                    is_struct = true
                    catch (err: KeyNotFoundError) {
                        // REM: Not a struct, continue checking
                    }
                    if is_struct {
                        return false  // Struct constant access is NOT an lvalue (it's a global)
                    }
                case:
                }
                catch (err: IndexOutOfBoundsError) { return false }
            }
            // Field access chain: all params must also be pure identifiers (field names)
            for p: Expr in arg.params {
                switch p.node_type {
                case NodeType.Identifier(id):
                    if not(p.params.is_empty()) {
                        return false
                    }
                case:
                    return false
                }
            }
            return true
        }
    case:
        return false
    }
}

/// This is the core of the single-pass hoist+emit approach (Bug #143 fix).
/// By processing each arg once and returning the string directly, we avoid
/// the need for expression identity tracking.
emit_arg_string := proc(arg: Expr, param_type: Ptr, param_by_ref: Bool, mut hoist_output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    indent_str := repeat("    ", indent)

    // Check if arg is a type identifier - emit as string literal
    mut type_name_result := ""
    mut is_type_arg := false
    type_name_result = get_type_arg_name(arg, context)?
    is_type_arg = true
    catch (err: KeyNotFoundError) {
        // REM: Not a type arg, continue
    }
    if is_type_arg {
        return format("\"", type_name_result, "\"")
    }

    // Check if this is a throwing FCall - needs hoisting
    switch arg.node_type {
    case NodeType.FCall(_):
        mut fd_throwing := SFuncDef()
        mut is_throwing := false
        fd_throwing = get_fcall_func_def(context, arg)?
        if not(fd_throwing.throw_types.is_empty()) {
            is_throwing = true
        }
        catch (err: KeyNotFoundError) {
            // REM: Not a function call we can look up, continue
        }
        if is_throwing {
            return emit_throwing_arg_string(arg, fd_throwing, param_type, param_by_ref, hoist_output, indent, ctx, context)?
        }
    case:
    }

    // Check if this is a variadic FCall (even if not throwing) - needs hoisting
    switch arg.node_type {
    case NodeType.FCall(_):
        mut vi_check := VariadicFCallInfo()
        mut is_variadic := false
        vi_check = detect_variadic_fcall(arg, ctx)?
        is_variadic = true
        catch (err: KeyNotFoundError) {
            // REM: Not variadic, continue
        }
        if is_variadic {
            return emit_variadic_arg_string(arg, vi_check, param_type, param_by_ref, hoist_output, indent, ctx, context)?
        }
    case:
    }

    // Check if param type is Dynamic - need special handling
    mut is_dynamic := false
    if not(param_type.is_null()) {
        mut pt := ValueType.TCustom(INFER_TYPE)
        param_type.dereference(ValueType, pt)
        switch pt {
        case ValueType.TCustom(pt_name):
            if pt_name.eq("Dynamic") {
                is_dynamic = true
            }
        case:
        }
    }

    if is_dynamic {
        return emit_arg_string_dynamic(arg, hoist_output, indent, indent_str, ctx, context)?
    }

    // Check if param is by-ref (mut) - need & prefix
    if param_by_ref {
        return emit_arg_string_by_ref(arg, hoist_output, indent, indent_str, ctx, context)?
    }

    // For non-throwing, non-variadic FCalls, recursively process nested args
    switch arg.node_type {
    case NodeType.FCall(_):
        return emit_fcall_arg_string(arg, hoist_output, indent, ctx, context)?
    case:
    }

    // Handle UFCS result chains: Identifier("_")[FCall, field1, field2, ...]
    switch arg.node_type {
    case NodeType.Identifier(ufcs_name):
        if ufcs_name.eq("_").and(not(arg.params.is_empty())) {
            mut ufcs_first := Expr()
            arg.params.get(0, ufcs_first)?
            switch ufcs_first.node_type {
            case NodeType.FCall(_):
                base_str := emit_arg_string(ufcs_first, Ptr(), false, hoist_output, indent, ctx, context)?
                mut ufcs_result := base_str.clone()
                mut ufcs_i := 1
                while ufcs_i.lt(arg.params.len()) {
                    mut ufcs_field := Expr()
                    arg.params.get(ufcs_i, ufcs_field)?
                    switch ufcs_field.node_type {
                    case NodeType.Identifier(field_name):
                        ufcs_result.push_str(".")
                        ufcs_result.push_str(field_name)
                    case:
                    }
                    ufcs_i.inc()
                }
                return ufcs_result
            case:
            }
        }
    case:
    }

    // For other expressions, emit to a temp string and return
    mut final_expr_str := ""
    emit_expr(arg, final_expr_str, 0, ctx, context)?

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return final_expr_str
}

/// Helper for emit_arg_string: Handle Dynamic params
emit_arg_string_dynamic := proc(arg: Expr, mut hoist_output: Str, indent: I64, indent_str: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Check if it's a pure lvalue
    if is_pure_lvalue(arg, context) {
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.is_empty() {
                mut is_ptr := false
                if ctx.current_ref_params.contains(name) {
                    is_ptr = true
                } else if ctx.current_variadic_params.contains_key(name) {
                    is_ptr = true
                } else {
                    sym := context.scope_stack.lookup_symbol(name)?
                    switch sym.value_type {
                    case ValueType.TCustom(t):
                        if t.eq("Dynamic") {
                            is_ptr = true
                        }
                    case:
                    }
                    catch (err: KeyNotFoundError) {
                        // REM: Symbol not found
                    }
                }
                if is_ptr {
                    return format("(", TIL_PREFIX, "Dynamic*)", til_name(name))
                }
            }
        case:
        }
        mut lv_str := ""
        emit_expr(arg, lv_str, 0, ctx, context)?
        return format("(", TIL_PREFIX, "Dynamic*)&", lv_str)
    }

    // String literals
    switch arg.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Str(s):
            mut lit_str := ""
            emit_expr(arg, lit_str, 0, ctx, context)?
            return format("(", TIL_PREFIX, "Dynamic*)&", lit_str)
        case:
            // REM: not a string literal
        }
    case:
    }

    // Non-lvalue - need to hoist
    mut dyn_expr_str := ""
    switch arg.node_type {
    case NodeType.FCall(_):
        dyn_expr_str = emit_fcall_arg_string(arg, hoist_output, indent, ctx, context)?
    case:
        emit_expr(arg, dyn_expr_str, 0, ctx, context)?
    }

    dyn_c_type := get_c_type_for_expr(arg, context)?

    dyn_temp := next_mangled(ctx)
    hoist_output.push_str(indent_str)
    hoist_output.push_str(dyn_c_type)
    hoist_output.push_str(" ")
    hoist_output.push_str(dyn_temp)
    hoist_output.push_str(" = ")
    hoist_output.push_str(dyn_expr_str)
    hoist_output.push_str(";\n")
    return format("(", TIL_PREFIX, "Dynamic*)&", dyn_temp)
}

/// Helper for emit_arg_string: Handle by-ref params
emit_arg_string_by_ref := proc(arg: Expr, mut hoist_output: Str, indent: I64, indent_str: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Check if it's a pure lvalue
    if is_pure_lvalue(arg, context) {
        switch arg.node_type {
        case NodeType.Identifier(name):
            if arg.params.is_empty() {
                mut is_ptr := false
                if ctx.current_ref_params.contains(name) {
                    is_ptr = true
                } else if ctx.current_variadic_params.contains_key(name) {
                    is_ptr = true
                }
                if is_ptr {
                    return til_name(name)
                }
            }
        case:
        }
        mut lv_str := ""
        emit_expr(arg, lv_str, 0, ctx, context)?
        return format("&", lv_str)
    }

    // String literals
    switch arg.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Str(s):
            mut str_lit := ""
            emit_expr(arg, str_lit, 0, ctx, context)?
            return format("&", str_lit)
        case:
            // REM: not a string literal
        }
    case:
    }

    // Non-lvalue - need to hoist
    mut ref_expr_str := ""
    switch arg.node_type {
    case NodeType.FCall(_):
        ref_expr_str = emit_fcall_arg_string(arg, hoist_output, indent, ctx, context)?
    case NodeType.Identifier(id_name):
        // Handle UFCS chain: _[FCall, field...]
        if id_name.eq("_").and(not(arg.params.is_empty())) {
            mut ufcs_first := Expr()
            arg.params.get(0, ufcs_first)?
            switch ufcs_first.node_type {
            case NodeType.FCall(_):
                base_str := emit_arg_string(ufcs_first, Ptr(), false, hoist_output, indent, ctx, context)?
                mut chain_result := base_str.clone()
                mut chain_i := 1
                while chain_i.lt(arg.params.len()) {
                    mut chain_field := Expr()
                    arg.params.get(chain_i, chain_field)?
                    switch chain_field.node_type {
                    case NodeType.Identifier(field_name):
                        chain_result.push_str(".")
                        chain_result.push_str(field_name)
                    case:
                    }
                    chain_i.inc()
                }
                ref_expr_str = chain_result
            case:
                emit_expr(arg, ref_expr_str, 0, ctx, context)?
            }
        } else {
            emit_expr(arg, ref_expr_str, 0, ctx, context)?
        }
    case:
        emit_expr(arg, ref_expr_str, 0, ctx, context)?
    }

    ref_c_type := get_c_type_for_expr(arg, context)?

    ref_temp := next_mangled(ctx)
    hoist_output.push_str(indent_str)
    hoist_output.push_str(ref_c_type)
    hoist_output.push_str(" ")
    hoist_output.push_str(ref_temp)
    hoist_output.push_str(" = ")
    hoist_output.push_str(ref_expr_str)
    hoist_output.push_str(";\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return format("&", ref_temp)
}

/// Helper: Emit a throwing FCall arg, hoisting it and returning temp var string
emit_throwing_arg_string := proc(arg: Expr, fd: SFuncDef, param_type: Ptr, param_by_ref: Bool, mut hoist_output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    indent_str := repeat("    ", indent)

    // Check for variadic EARLY so we can use by_ref=false for variadic args
    mut variadic_info := VariadicFCallInfo()
    mut has_variadic := false
    variadic_info = detect_variadic_fcall(arg, ctx)?
    has_variadic = true
    catch (err: KeyNotFoundError) {
        // REM: Not variadic
    }
    mut variadic_regular_count := 999999999
    if has_variadic {
        variadic_regular_count = variadic_info.regular_count
    }

    // First, recursively process this call's arguments
    // For variadic args (i >= regular_count), use by_ref=false because they get stored in temp vars
    mut nested_arg_strings := Vec.new(Str)
    if arg.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(arg.params.len()) {
            mut nested_arg := Expr()
            arg.params.get(arg_idx, nested_arg)?
            is_variadic_arg := not(i.lt(variadic_regular_count))
            mut nested_param_type := Ptr()
            mut nested_by_ref := false
            if i.lt(fd.args.len()) {
                mut param_decl := Declaration()
                fd.args.get(i, param_decl)?
                nested_param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    nested_by_ref = param_needs_by_ref(param_decl)
                }
            }
            nested_str := emit_arg_string(nested_arg, nested_param_type, nested_by_ref, hoist_output, indent, ctx, context)?
            nested_arg_strings.push(nested_str)
            i.inc()
            arg_idx.inc()
        }
    }

    // Generate temp variable for result
    temp_var := next_mangled(ctx)
    temp_suffix := next_mangled(ctx)

    // Get return type
    if fd.return_types.is_empty() {
        throw arg.lang_error(context.path, "ccodegen", "Throwing call has no return type")
    }
    mut first_ret := ValueType.TCustom(INFER_TYPE)
    fd.return_types.get(0, first_ret)?
    c_type := til_type_to_c(first_ret)?

    // Declare temp variable
    hoist_output.push_str(indent_str)
    hoist_output.push_str(c_type)
    hoist_output.push_str(" ")
    hoist_output.push_str(temp_var)
    hoist_output.push_str(";\n")

    // Declare error variables for each throw type (skip empty struct errors)
    mut err_idx := 0
    for throw_type: ValueType in fd.throw_types {
        if is_empty_error_struct(context, throw_type) {
            err_idx.inc()
            continue
        }
        switch throw_type {
        case ValueType.TCustom(type_name):
            hoist_output.push_str(indent_str)
            hoist_output.push_str(til_name(type_name))
            hoist_output.push_str(" _err")
            hoist_output.push_str(err_idx.to_str())
            hoist_output.push_str("_")
            hoist_output.push_str(temp_suffix)
            hoist_output.push_str(";\n")
        case:
        }
        err_idx.inc()
    }

    // Build variadic array if needed (variadic_info was computed earlier)
    mut variadic_arr_var := ""
    if has_variadic {
        // Build variadic array using the nested arg strings
        mut variadic_arg_strings := Vec.new(Str)
        mut vi := variadic_info.regular_count
        while vi.lt(nested_arg_strings.len()) {
            mut vas := ""
            nested_arg_strings.get(vi, vas)?
            variadic_arg_strings.push(vas)
            vi.inc()
        }
        variadic_arr_var = emit_variadic_array_with_strings(variadic_info.elem_type, variadic_arg_strings, hoist_output, indent, ctx)?
    }

    // Emit the function call with output pointers
    hoist_output.push_str(indent_str)
    hoist_output.push_str("int __attribute__((unused)) _status_")
    hoist_output.push_str(temp_suffix)
    hoist_output.push_str(" = ")

    // Get function name
    if arg.params.is_empty() {
        throw arg.lang_error(context.path, "ccodegen", "Cannot determine function name")
    }
    mut ta_first_param := Expr()
    arg.params.get(0, ta_first_param)?
    func_name := get_func_name_string(ta_first_param)?
    mut orig_func_name := func_name.clone()
    orig_func_name = get_til_func_name_string(ta_first_param)?
    catch (err: Str) {
        // REM: Use func_name as fallback
    }
    mut mangled_name := func_name.clone()
    if ctx.nested_func_names.contains_key(orig_func_name) {
        ctx.nested_func_names.get(orig_func_name, mangled_name)?
    }

    // Emit function name
    hoist_output.push_str(TIL_PREFIX)
    hoist_output.push_str(mangled_name)
    hoist_output.push_str("(")

    // First arg: output pointer for return value
    hoist_output.push_str("&")
    hoist_output.push_str(temp_var)

    // Error output pointers (skip empty error structs - they don't have a param slot)
    err_idx = 0
    for throw_type: ValueType in fd.throw_types {
        if is_empty_error_struct(context, throw_type) {
            err_idx.inc()
            continue
        }
        hoist_output.push_str(", ")
        hoist_output.push_str("&_err")
        hoist_output.push_str(err_idx.to_str())
        hoist_output.push_str("_")
        hoist_output.push_str(temp_suffix)
        err_idx.inc()
    }

    // Regular arguments (using pre-computed strings)
    mut regular_count := nested_arg_strings.len()
    if has_variadic {
        regular_count = variadic_info.regular_count
    }
    mut ri := 0
    while ri.lt(regular_count) {
        mut arg_str := ""
        nested_arg_strings.get(ri, arg_str)?
        hoist_output.push_str(", ")
        hoist_output.push_str(arg_str)
        ri.inc()
    }

    // Variadic array pointer if present
    if not(variadic_arr_var.is_empty()) {
        hoist_output.push_str(", &")
        hoist_output.push_str(variadic_arr_var)
    }

    hoist_output.push_str(");\n")

    // Emit error handling - check for local catches first, then propagate
    emit_error_handling(fd.throw_types, temp_suffix, hoist_output, indent, ctx, context)?

    // Delete variadic array if constructed
    if not(variadic_arr_var.is_empty()) {
        hoist_output.push_str(indent_str)
        hoist_output.push_str(TIL_PREFIX)
        hoist_output.push_str("Array_delete(&")
        hoist_output.push_str(variadic_arr_var)
        hoist_output.push_str(");\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw format("KeyNotFoundError: ", err.msg) }

    // Return the temp var name with appropriate prefix
    return format_hoisted_result(temp_var, param_type, param_by_ref)
}

/// Helper: Emit error propagation code
emit_error_propagation := proc(throw_types: Vec, temp_suffix: Str, mut output: Str, indent: I64, ctx: CodegenContext, context: Context) {
    indent_str := repeat("    ", indent)

    output.push_str(indent_str)
    output.push_str("if (_status_")
    output.push_str(temp_suffix)
    output.push_str(" != 0) {\n")

    mut err_idx := 0
    for throw_type: ValueType in throw_types {
        switch throw_type {
        case ValueType.TCustom(type_name):
            // Find matching throw type in current function
            mut curr_idx := 0
            for curr_throw: ValueType in ctx.current_throw_types {
                switch curr_throw {
                case ValueType.TCustom(curr_type_name):
                    if curr_type_name.eq(type_name) {
                        output.push_str(indent_str)
                        output.push_str("    if (_status_")
                        output.push_str(temp_suffix)
                        output.push_str(" == ")
                        output.push_str(add(err_idx, 1).to_str())
                        output.push_str(") { ")
                        if not(is_empty_error_struct(context, throw_type)) {
                            output.push_str("*_err")
                            output.push_str(add(curr_idx, 1).to_str())
                            output.push_str(" = _err")
                            output.push_str(err_idx.to_str())
                            output.push_str("_")
                            output.push_str(temp_suffix)
                            output.push_str("; ")
                        }
                        output.push_str("return ")
                        output.push_str(add(curr_idx, 1).to_str())
                        output.push_str("; }\n")
                        break
                    }
                case:
                }
                curr_idx.inc()
            }
        case:
        }
        err_idx.inc()
    }

    output.push_str(indent_str)
    output.push_str("}\n")
}

/// Helper: Emit error handling - checks for local catches first, then propagates
/// This replaces emit_error_propagation for throwing calls that need catch support
emit_error_handling := proc(throw_types: Vec, temp_suffix: Str, mut output: Str, indent: I64, ctx: CodegenContext, context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Check if there are local catch labels for any of these error types
    mut has_local_catch := false
    for throw_type: ValueType in throw_types {
        switch throw_type {
        case ValueType.TCustom(type_name):
            if ctx.local_catch_labels.contains_key(type_name) {
                has_local_catch = true
                break
            }
        case:
        }
    }

    if has_local_catch {
        // Emit goto for each error type that has a local catch
        mut err_idx := 0
        for throw_type: ValueType in throw_types {
            switch throw_type {
            case ValueType.TCustom(type_name):
                if ctx.local_catch_labels.contains_key(type_name) {
                    mut catch_info := CatchLabelInfo()
                    ctx.local_catch_labels.get(type_name, catch_info)?
                    output.push_str(indent_str)
                    output.push_str("if (_status_")
                    output.push_str(temp_suffix)
                    output.push_str(" == ")
                    output.push_str(add(err_idx, 1).to_str())
                    output.push_str(") { ")
                    // Issue #119: Skip copying empty struct errors
                    if not(is_empty_error_struct(context, throw_type)) {
                        output.push_str(catch_info.temp_var)
                        output.push_str(" = _err")
                        output.push_str(err_idx.to_str())
                        output.push_str("_")
                        output.push_str(temp_suffix)
                        output.push_str("; ")
                    }
                    output.push_str("goto ")
                    output.push_str(catch_info.label)
                    output.push_str("; }\n")
                }
            case:
            }
            err_idx.inc()
        }
    } else {
        // No local catch - propagate errors
        emit_error_propagation(throw_types, temp_suffix, output, indent, ctx, context)
    }

    catch (err: KeyNotFoundError) { throw format("KeyNotFoundError: ", err.msg) }
}

/// Helper: Format a hoisted temp var with appropriate prefix for param type
format_hoisted_result := func(temp_var: Str, param_type: Ptr, param_by_ref: Bool) returns Str {
    mut is_dynamic := false
    if not(param_type.is_null()) {
        mut pt := ValueType.TCustom(INFER_TYPE)
        param_type.dereference(ValueType, pt)
        switch pt {
        case ValueType.TCustom(pt_name):
            if pt_name.eq("Dynamic") {
                is_dynamic = true
            }
        case:
        }
    }
    if is_dynamic {
        return format("(", TIL_PREFIX, "Dynamic*)&", temp_var)
    }
    if param_by_ref {
        return format("&", temp_var)
    }
    return temp_var.clone()
}

/// Helper: Emit a non-throwing variadic FCall arg
emit_variadic_arg_string := proc(arg: Expr, vi: VariadicFCallInfo, param_type: Ptr, param_by_ref: Bool, mut hoist_output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    indent_str := repeat("    ", indent)

    // Get function definition
    fd := get_fcall_func_def(context, arg)?
    catch (err: KeyNotFoundError) {
        throw arg.lang_error(context.path, "ccodegen", "Cannot find function definition for variadic call")
    }

    // First, recursively process this call's arguments
    // For variadic args (i >= regular_count), use by_ref=false because they get stored in temp vars
    mut nested_arg_strings := Vec.new(Str)
    if arg.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(arg.params.len()) {
            mut nested_arg := Expr()
            arg.params.get(arg_idx, nested_arg)?
            is_variadic_arg := not(i.lt(vi.regular_count))
            mut nested_param_type := Ptr()
            mut nested_by_ref := false
            if i.lt(fd.args.len()) {
                mut param_decl := Declaration()
                fd.args.get(i, param_decl)?
                nested_param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    nested_by_ref = param_needs_by_ref(param_decl)
                }
            }
            nested_str := emit_arg_string(nested_arg, nested_param_type, nested_by_ref, hoist_output, indent, ctx, context)?
            nested_arg_strings.push(nested_str)
            i.inc()
            arg_idx.inc()
        }
    }

    // Generate temp variable for result
    temp_var := next_mangled(ctx)

    // Get return type
    if fd.return_types.is_empty() {
        throw arg.lang_error(context.path, "ccodegen", "Function has no return type")
    }
    mut first_ret := ValueType.TCustom(INFER_TYPE)
    fd.return_types.get(0, first_ret)?
    c_type := til_type_to_c(first_ret)?

    // Declare temp variable
    hoist_output.push_str(indent_str)
    hoist_output.push_str(c_type)
    hoist_output.push_str(" ")
    hoist_output.push_str(temp_var)
    hoist_output.push_str(";\n")

    // Build variadic array using the nested arg strings
    mut variadic_arg_strings := Vec.new(Str)
    mut vai := vi.regular_count
    while vai.lt(nested_arg_strings.len()) {
        mut vas := ""
        nested_arg_strings.get(vai, vas)?
        variadic_arg_strings.push(vas)
        vai.inc()
    }
    variadic_arr_var := emit_variadic_array_with_strings(vi.elem_type, variadic_arg_strings, hoist_output, indent, ctx)?

    // Emit the function call
    hoist_output.push_str(indent_str)
    hoist_output.push_str(temp_var)
    hoist_output.push_str(" = ")

    // Get function name
    if arg.params.is_empty() {
        throw arg.lang_error(context.path, "ccodegen", "Cannot determine function name")
    }
    mut va_first_param := Expr()
    arg.params.get(0, va_first_param)?
    func_name := get_func_name_string(va_first_param)?
    mut orig_func_name := func_name.clone()
    orig_func_name = get_til_func_name_string(va_first_param)?
    catch (err: Str) {
        // REM: Use func_name as fallback
    }
    mut mangled_name := func_name.clone()
    if ctx.nested_func_names.contains_key(orig_func_name) {
        ctx.nested_func_names.get(orig_func_name, mangled_name)?
    }

    hoist_output.push_str(til_func_name(mangled_name))
    hoist_output.push_str("(")

    // Regular arguments
    mut first := true
    mut ri := 0
    while ri.lt(vi.regular_count) {
        mut arg_str := ""
        nested_arg_strings.get(ri, arg_str)?
        if not(first) {
            hoist_output.push_str(", ")
        }
        first = false
        hoist_output.push_str(arg_str)
        ri.inc()
    }

    // Variadic array pointer
    if not(first) {
        hoist_output.push_str(", ")
    }
    hoist_output.push_str("&")
    hoist_output.push_str(variadic_arr_var)
    hoist_output.push_str(");\n")

    // Delete variadic array
    hoist_output.push_str(indent_str)
    hoist_output.push_str(TIL_PREFIX)
    hoist_output.push_str("Array_delete(&")
    hoist_output.push_str(variadic_arr_var)
    hoist_output.push_str(");\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw format("KeyNotFoundError: ", err.msg) }

    // Return the temp var name with appropriate prefix
    return format_hoisted_result(temp_var, param_type, param_by_ref)
}

/// Helper: Build variadic array using pre-computed arg strings
/// Mirrors hoist_variadic_args but uses pre-computed arg_strings instead of emit_expr
emit_variadic_array_with_strings := proc(elem_type: Str, arg_strings: Vec, mut output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    indent_str := repeat("    ", indent)
    arr_var := next_mangled(ctx)
    err_suffix := next_mangled(ctx)

    elem_count := arg_strings.len()
    mut c_elem_type := format(TIL_PREFIX, "I64")
    c_elem_type = til_type_to_c(ValueType.TCustom(elem_type))?
    catch (err: Str) {
        // REM: Use default I64
    }

    // Declare the array variable
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Array ")
    output.push_str(arr_var)
    output.push_str(";\n")

    // Declare error var for Array.set (IndexOutOfBoundsError)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("IndexOutOfBoundsError __attribute__((unused)) _err_idx_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    // Hoist variadic args into temp vars (needed to pass address to Array.set)
    mut arg_temps := Vec.new(Str)
    mut asi := 0
    while asi.lt(arg_strings.len()) {
        mut arg_str := ""
        arg_strings.get(asi, arg_str)?
        temp_var := next_mangled(ctx)
        output.push_str(indent_str)
        output.push_str(c_elem_type)
        output.push_str(" ")
        output.push_str(temp_var)
        output.push_str(" = ")
        output.push_str(arg_str)
        output.push_str(";\n")
        arg_temps.push(temp_var)
        asi.inc()
    }

    // Hoist Type param for Array.new
    type_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Type ")
    output.push_str(type_temp)
    output.push_str(" = \"")
    output.push_str(elem_type)
    output.push_str("\";\n")

    // Hoist capacity param
    count_temp := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("I64 ")
    output.push_str(count_temp)
    output.push_str(" = ")
    output.push_str(elem_count.to_str())
    output.push_str(";\n")

    // Call Array.new (non-throwing)
    output.push_str(indent_str)
    output.push_str(arr_var)
    output.push_str(" = ")
    output.push_str(TIL_PREFIX)
    output.push_str("Array_new(")
    output.push_str(type_temp)
    output.push_str(", &")
    output.push_str(count_temp)
    output.push_str(");\n")

    // Declare status variable for Array.set calls
    output.push_str(indent_str)
    output.push_str("int __attribute__((unused)) _arr_status_")
    output.push_str(err_suffix)
    output.push_str(";\n")

    // Emit Array.set for each variadic arg
    mut ti := 0
    while ti.lt(arg_temps.len()) {
        mut temp_item := ""
        arg_temps.get(ti, temp_item)?
        // Hoist index literal
        idx_temp := next_mangled(ctx)
        output.push_str(indent_str)
        output.push_str(TIL_PREFIX)
        output.push_str("I64 ")
        output.push_str(idx_temp)
        output.push_str(" = ")
        output.push_str(ti.to_str())
        output.push_str(";\n")

        // int _status = til_Array_set(&_err_idx, &arr, &idx_temp, (til_Dynamic*)&temp);
        output.push_str(indent_str)
        output.push_str("_arr_status_")
        output.push_str(err_suffix)
        output.push_str(" = ")
        output.push_str(TIL_PREFIX)
        output.push_str("Array_set(&_err_idx_")
        output.push_str(err_suffix)
        output.push_str(", &")
        output.push_str(arr_var)
        output.push_str(", &")
        output.push_str(idx_temp)
        output.push_str(", (")
        output.push_str(TIL_PREFIX)
        output.push_str("Dynamic*)&")
        output.push_str(temp_item)
        output.push_str(");\n")
        ti.inc()
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return arr_var
}

/// Helper: Emit a non-throwing, non-variadic FCall, recursively processing args
emit_fcall_arg_string := proc(arg: Expr, mut hoist_output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Check if this is a struct constructor - emit directly via emit_expr
    // (emit_expr handles struct constructors properly as compound literals)
    if arg.params.is_empty() {
        throw arg.lang_error(context.path, "ccodegen", "Cannot determine function name")
    }
    mut first_param := Expr()
    arg.params.get(0, first_param)?
    func_name := get_func_name_string(first_param)?

    // Struct constructors should be emitted as compound literals
    // But we need to recursively process named args in case they contain variadic/throwing calls
    struct_def := context.scope_stack.lookup_struct(func_name)?
    // Process named args (field values) with emit_arg_string
    mut field_values := Map.new(Str, Str)
    mut ai := 1
    while ai.lt(arg.params.len()) {
        mut named_arg := Expr()
        arg.params.get(ai, named_arg)?
        switch named_arg.node_type {
        case NodeType.NamedArg(field_name):
            if not(named_arg.params.is_empty()) {
                mut value_expr := Expr()
                named_arg.params.get(0, value_expr)?
                // Find the field's expected type
                mut field_type := Ptr()
                for m: Declaration in struct_def.members {
                    if m.name.eq(field_name) {
                        field_type.data = to_ptr(m.value_type)
                        break
                    }
                }
                // Process the value with emit_arg_string
                value_str := emit_arg_string(value_expr, field_type, false, hoist_output, indent, ctx, context)?
                field_values.set(field_name, value_str)
            }
        case:
        }
        ai.inc()
    }

    // Build the compound literal
    mut result := format("(", TIL_PREFIX, func_name, ")")
    if struct_def.members.is_empty().or(struct_def.default_values.is_empty()) {
        result.push_str("{}")
    } else {
        result.push_str("{")
        mut first := true
        for member: Declaration in struct_def.members {
            if not(member.is_mut) {
                continue  // Skip static members
            }
            if not(first) {
                result.push_str(", ")
            }
            first = false
            result.push_str(".")
            result.push_str(member.name)
            result.push_str(" = ")
            if field_values.contains_key(member.name) {
                mut field_val := ""
                field_values.get(member.name, field_val)?
                result.push_str(field_val)
            } else if struct_def.default_values.contains_key(member.name) {
                mut default_expr := Expr()
                struct_def.default_values.get(member.name, default_expr)?
                // Use emit_arg_string for defaults too (may contain variadic/throwing calls)
                mut member_type := Ptr()
                member_type.data = to_ptr(member.value_type)
                default_str := emit_arg_string(default_expr, member_type, false, hoist_output, indent, ctx, context)?
                result.push_str(default_str)
            } else {
                // No value and no default - use zero
                result.push_str("0")
            }
        }
        result.push_str("}")
    }
    if true { // TODO Bug #96 workaround
        return result
    }
    catch (err: KeyNotFoundError) {
        // Not a struct constructor, continue with regular function call
    }

    mut orig_func_name := func_name.clone()
    orig_func_name = get_til_func_name_string(first_param)?
    catch (err: Str) {
        // REM: Use func_name as fallback
    }

    // Handle builtins that have inline codegen (don't use til_func_name prefix)
    if orig_func_name.eq("to_ptr") {
        // to_ptr: generates (til_I64)&arg, not a function call
        if arg.params.len().lt(2) {
            throw arg.lang_error(context.path, "ccodegen", "to_ptr requires 1 argument")
        }
        mut inner_arg := Expr()
        arg.params.get(1, inner_arg)?
        // Check if arg is a Dynamic parameter (already void*)
        mut is_dynamic_param := false
        switch inner_arg.node_type {
        case NodeType.Identifier(name):
            if inner_arg.params.is_empty() {
                sym := context.scope_stack.lookup_symbol(name)?
                switch sym.value_type {
                case ValueType.TCustom(t):
                    if t.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                }
                catch (err: KeyNotFoundError) {
                    // REM: Symbol not found
                }
            }
        case:
        }
        if is_dynamic_param {
            switch inner_arg.node_type {
            case NodeType.Identifier(name):
                if true { // TODO Bug #96 workaround
                    return format("(", TIL_PREFIX, "I64)", til_name(name))
                }
            case:
            }
        }
        // Process the inner arg (may need hoisting if nested)
        inner_str := emit_arg_string(inner_arg, Ptr(), false, hoist_output, indent, ctx, context)?
        if true { // TODO Bug #96 workaround
            return format("(", TIL_PREFIX, "I64)&", inner_str)
        }
    }

    if orig_func_name.eq("size_of") {
        // size_of: generates til_size_of(&Str), with special Str handling
        if arg.params.len().lt(2) {
            throw arg.lang_error(context.path, "ccodegen", "size_of requires 1 argument")
        }
        mut sizeof_arg := Expr()
        arg.params.get(1, sizeof_arg)?
        mut sizeof_result := ""
        sizeof_result.push_str(TIL_PREFIX)
        sizeof_result.push_str("size_of(&")
        switch sizeof_arg.node_type {
        case NodeType.Identifier(type_name):
            // Check if this is a Type variable or a literal type name
            mut sizeof_is_type_var := false
            sizeof_sym := context.scope_stack.lookup_symbol(type_name)?
            switch sizeof_sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    sizeof_is_type_var = true
                }
            case:
            }
            catch (err: KeyNotFoundError) {
                // REM: Not a Type variable
            }
            if sizeof_is_type_var {
                sizeof_result.push_str(format("((", TIL_PREFIX, "Str){((", TIL_PREFIX, "Ptr){(", TIL_PREFIX, "I64)", TIL_PREFIX, type_name, ", 1}), strlen(", TIL_PREFIX, type_name, "), 0})"))
            } else {
                // Literal type name
                sizeof_result.push_str(format("((", TIL_PREFIX, "Str){((", TIL_PREFIX, "Ptr){(", TIL_PREFIX, "I64)\"", type_name, "\", 1}), ", type_name.len().to_str(), ", 0})"))
            }
        case:
            throw arg.lang_error(context.path, "ccodegen", "size_of requires type name argument")
        }
        sizeof_result.push_str(")")
        if true { // TODO Bug #96 workaround
            return sizeof_result
        }
    }

    if orig_func_name.eq("enum_to_str") {
        // enum_to_str: generates EnumType_to_str(&arg)
        if arg.params.len().lt(2) {
            throw arg.lang_error(context.path, "ccodegen", "enum_to_str requires 1 argument")
        }
        mut ets_inner_arg := Expr()
        arg.params.get(1, ets_inner_arg)?
        value_type := get_value_type(context, ets_inner_arg)?
        switch value_type {
        case ValueType.TCustom(enum_type_name):
            _ := context.scope_stack.lookup_enum(enum_type_name)?
            // Pass Dynamic param type so enum constructors get hoisted properly
            dynamic_type := ValueType.TCustom("Dynamic")
            mut dynamic_ptr := Ptr()
            dynamic_ptr.data = to_ptr(dynamic_type)
            ets_inner_str := emit_arg_string(ets_inner_arg, dynamic_ptr, false, hoist_output, indent, ctx, context)?
            // ets_inner_str will be "(til_Dynamic*)&x" for lvalues or "(til_Dynamic*)&_tmpX" for hoisted
            // Strip the Dynamic prefix and keep just the &...
            dynamic_prefix := format("(", TIL_PREFIX, "Dynamic*)")
            mut ref_str := ""
            if ets_inner_str.starts_with(dynamic_prefix) {
                ref_str = ets_inner_str.get_substr(dynamic_prefix.len(), ets_inner_str.len())?
            } else {
                ref_str = format("&", ets_inner_str)
            }
            if true { // TODO Bug #96 workaround
                return format(til_name(enum_type_name), "_to_str(", ref_str, ")")
            }
            catch (err: KeyNotFoundError) {
                // REM: Not an enum, fall through
            }
        case:
        }
        // Fall through to emit_expr for non-enum case
        mut expr_str := ""
        emit_expr(arg, expr_str, 0, ctx, context)?
        if true { // TODO Bug #96 workaround
            return expr_str
        }
    }

    if orig_func_name.eq("type_as_str") {
        // type_as_str: generates Str literal or Str from Type variable
        if arg.params.len().lt(2) {
            throw arg.lang_error(context.path, "ccodegen", "type_as_str requires 1 argument")
        }
        mut tas_arg := Expr()
        arg.params.get(1, tas_arg)?
        switch tas_arg.node_type {
        case NodeType.Identifier(type_name):
            // Check if this is a Type variable or a literal type name
            mut tas_is_type_var := false
            tas_sym := context.scope_stack.lookup_symbol(type_name)?
            switch tas_sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    tas_is_type_var = true
                }
            case:
            }
            catch (err: KeyNotFoundError) {
                // REM: Not a Type variable
            }
            if tas_is_type_var {
                // Type variable - already a const char*, wrap in Str struct literal
                if true { // TODO Bug #96 workaround
                    return format("((", TIL_PREFIX, "Str){((", TIL_PREFIX, "Ptr){(", TIL_PREFIX, "I64)", TIL_PREFIX, type_name, ", 1}), strlen(", TIL_PREFIX, type_name, "), 0})")
                }
            } else {
                // Literal type name - create Str compound literal
                if true { // TODO Bug #96 workaround
                    return format("((", TIL_PREFIX, "Str){((", TIL_PREFIX, "Ptr){(", TIL_PREFIX, "I64)\"", type_name, "\", 1}), ", type_name.len().to_str(), ", 0})")
                }
            }
        case:
            if true { // TODO Bug #96 workaround
                return format("((", TIL_PREFIX, "Str){((", TIL_PREFIX, "Ptr){(", TIL_PREFIX, "I64)\"unknown\", 1}), 7, 0})")
            }
        }
    }

    // For non-throwing, non-variadic FCalls, we still need to recursively process args
    // to hoist any nested throwing/variadic calls

    mut fd_opt := SFuncDef()
    mut fd_found := false
    fd_opt = get_fcall_func_def(context, arg)?
    fd_found = true
    catch (err: KeyNotFoundError) {
        // REM: No function definition found
    }

    // Process nested args
    mut nested_arg_strings := Vec.new(Str)
    if arg.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(arg.params.len()) {
            mut nested_arg := Expr()
            arg.params.get(arg_idx, nested_arg)?
            mut nested_param_type := Ptr()
            mut nested_by_ref := false
            if fd_found.and(i.lt(fd_opt.args.len())) {
                mut param_decl := Declaration()
                fd_opt.args.get(i, param_decl)?
                nested_param_type.data = to_ptr(param_decl.value_type)
                nested_by_ref = param_needs_by_ref(param_decl)
            }
            nested_str := emit_arg_string(nested_arg, nested_param_type, nested_by_ref, hoist_output, indent, ctx, context)?
            nested_arg_strings.push(nested_str)
            i.inc()
            arg_idx.inc()
        }
    }

    // Build the call string
    mut mangled_name := func_name.clone()
    if ctx.nested_func_names.contains_key(orig_func_name) {
        ctx.nested_func_names.get(orig_func_name, mangled_name)?
    }

    // Check if this is an enum constructor (Type_Variant) - need til_Type_make_Variant
    mut is_enum_constructor := false
    mut enum_ctor_name := ""
    mut variant_ctor_name := ""
    underscore_pos := func_name.find("_")
    if underscore_pos.gt(0) {
        enum_ctor_name = func_name.get_substr(0, underscore_pos)?
        variant_ctor_name = func_name.get_substr(add(underscore_pos, 1), func_name.len())?
        enum_def := context.scope_stack.lookup_enum(enum_ctor_name)?
        if enum_def.contains_key(variant_ctor_name)? {
            is_enum_constructor = true
        }
        catch (err: KeyNotFoundError) {
            // REM: Not an enum
        }
    }

    mut call_str := ""
    if is_enum_constructor {
        call_str.push_str(TIL_PREFIX)
        call_str.push_str(enum_ctor_name)
        call_str.push_str("_make_")
        call_str.push_str(variant_ctor_name)
    } else {
        call_str.push_str(til_func_name(mangled_name))
    }
    call_str.push_str("(")

    mut ci := 0
    while ci.lt(nested_arg_strings.len()) {
        mut arg_str := ""
        nested_arg_strings.get(ci, arg_str)?
        if ci.gt(0) {
            call_str.push_str(", ")
        }
        call_str.push_str(arg_str)
        ci.inc()
    }

    call_str.push_str(")")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: KeyNotFoundError) { throw format("KeyNotFoundError: ", err.msg) }

    return call_str
}

/// Helper: Get C type for an expression (for hoisting declarations)
get_c_type_for_expr := proc(arg: Expr, context: Context) returns Str throws Str {
    switch arg.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Str(s):
            return format(TIL_PREFIX, "Str")
        case Literal.Number(n):
            return format(TIL_PREFIX, "I64")
        case:
            return format(TIL_PREFIX, "I64")  // Default for other literals
        }
    case NodeType.FCall(_):
        fd := get_fcall_func_def(context, arg)?
        if not(fd.return_types.is_empty()) {
            mut ret_type := ValueType.TCustom(INFER_TYPE)
            fd.return_types.get(0, ret_type)?
            return til_type_to_c(ret_type)?
        }
        catch (err: KeyNotFoundError) {
            // REM: No function definition, check for struct/enum constructor
        }
        // Check for struct/enum constructor
        func_name := get_fcall_func_name(arg)?
        _ := context.scope_stack.lookup_struct(func_name)?
        if true { // TODO Bug #96 workaround
            return til_name(func_name)
        }
        catch (err: KeyNotFoundError) {
            // REM: Not a struct, check enum
        }
        // Check enum constructor
        underscore_pos := func_name.find("_")
        if underscore_pos.gt(0) {
            enum_name := func_name.get_substr(0, underscore_pos)?
            _ := context.scope_stack.lookup_enum(enum_name)?
            if true { // TODO Bug #96 workaround
                return til_name(enum_name)
            }
            catch (err: KeyNotFoundError) {
                // REM: Not an enum
            }
        }
        throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for FCall")
    case NodeType.Identifier(name):
        if not(arg.params.is_empty()) {
            // Bug #143: Handle UFCS chain with field access: _[FCall, field1, field2, ...]
            // After UFCS desugaring, x.method().field1.field2 becomes _[FCall, field1, field2]
            if name.eq("_") {
                mut first_param := Expr()
                arg.params.get(0, first_param)?
                switch first_param.node_type {
                case NodeType.FCall(_):
                    // Get the return type of the FCall
                    fcall_type := get_c_type_for_expr(first_param, context)?
                    // Navigate through field access chain
                    if arg.params.len().eq(1) {
                        return fcall_type
                    }
                    // Get the struct name from the C type (strip til_ prefix)
                    mut struct_name := fcall_type.clone()
                    if fcall_type.starts_with(TIL_PREFIX) {
                        struct_name = fcall_type.get_substr(TIL_PREFIX.len(), fcall_type.len())?
                    }
                    mut current_type := struct_name.clone()
                    mut field_idx := 1
                    while field_idx.lt(arg.params.len()) {
                        mut field_param := Expr()
                        arg.params.get(field_idx, field_param)?
                        switch field_param.node_type {
                        case NodeType.Identifier(field_name):
                            chain_struct_def := context.scope_stack.lookup_struct(current_type)?
                            mut found := false
                            for m: Declaration in chain_struct_def.members {
                                if m.name.eq(field_name) {
                                    switch m.value_type {
                                    case ValueType.TCustom(next_struct):
                                        current_type = next_struct.clone()
                                    case:
                                        // Final type is not a struct - convert and return
                                        return til_type_to_c(m.value_type)?
                                    }
                                    found = true
                                    break
                                }
                            }
                            if not(found) {
                                throw arg.lang_error(context.path, "ccodegen", format("Field '", field_name, "' not found on struct '", current_type, "'"))
                            }
                            catch (err: KeyNotFoundError) {
                                throw arg.lang_error(context.path, "ccodegen", format("Expected struct type for field access, got '", current_type, "'"))
                            }
                        case:
                        }
                        field_idx.inc()
                    }
                    // If we ended on a struct type, return it
                    return til_name(current_type)
                case:
                }
            }
            // Type-qualified call or field access
            mut typeq_first_param := Expr()
            arg.params.get(0, typeq_first_param)?
            switch typeq_first_param.node_type {
            case NodeType.Identifier(field_or_variant):
                // Check enum constructor
                enum_def := context.scope_stack.lookup_enum(name)?
                if enum_def.contains_key(field_or_variant)? {
                    return til_name(name)
                }
                catch (err: KeyNotFoundError) {
                    // REM: Not an enum
                }
                // Check instance field access (variable.field)
                sym := context.scope_stack.lookup_symbol(name)?
                switch sym.value_type {
                case ValueType.TCustom(struct_name):
                    instance_struct_def := context.scope_stack.lookup_struct(struct_name)?
                    for m: Declaration in instance_struct_def.members {
                        if m.name.eq(field_or_variant) {
                            return til_type_to_c(m.value_type)?
                        }
                    }
                    catch (err: KeyNotFoundError) {
                        // REM: Not a struct
                    }
                case:
                }
                catch (err: KeyNotFoundError) {
                    // REM: Symbol not found
                }
                // Check static field access on struct/namespace (StructName.field)
                static_struct_def := context.scope_stack.lookup_struct(name)?
                for m: Declaration in static_struct_def.members {
                    if m.name.eq(field_or_variant) {
                        return til_type_to_c(m.value_type)?
                    }
                }
                catch (err: KeyNotFoundError) {
                    // REM: Not a struct
                }
            case:
            }
            throw arg.lang_error(context.path, "ccodegen", "Cannot determine type")
        }
    case:
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    throw arg.lang_error(context.path, "ccodegen", "Cannot determine type for expression")
}


// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr, mut context: Context) returns Str throws Str {
    mut output := ""
    mut ctx := CodegenContext.new()

    // C boilerplate
    output.push_str("#include <stdio.h>\n")
    output.push_str("#include <stdlib.h>\n")
    output.push_str("#include <string.h>\n\n")
    output.push_str(format("typedef unsigned char ", TIL_PREFIX, "U8;\n"))
    output.push_str(format("typedef long long ", TIL_PREFIX, "I64;\n"))
    output.push_str(format("typedef struct ", TIL_PREFIX, "Bool { ", TIL_PREFIX, "U8 data; } ", TIL_PREFIX, "Bool;\n"))
    // Dynamic and Type are special placeholder types
    output.push_str(format("typedef void* ", TIL_PREFIX, "Dynamic;\n"))
    output.push_str(format("typedef const char* ", TIL_PREFIX, "Type;\n\n"))

    // Pass 0: collect function info (throw types, return types) for call-site generation
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            collect_func_info(child, ctx)?
        }
    case:
    }

    // Pass 0a: collect nested function info for hoisting (populates hoisted_prototypes and nested_func_names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            collect_nested_func_info(child, ctx, context, "")?
        }
    case:
    }

    // Pass 0b: emit forward declarations for all structs and enums-with-payloads
    // (enums with payloads are implemented as structs in C, so they need forward declarations too)
    // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs defined in boilerplate
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    if decl.name.eq("I64").or(decl.name.eq("U8")).or(decl.name.eq("Bool")).or(decl.name.eq("Dynamic")).or(decl.name.eq("Type")) {
                        continue  // Skip - these are primitive typedefs
                    }
                    struct_name := til_name(decl.name)
                    output.push_str("typedef struct ")
                    output.push_str(struct_name)
                    output.push_str(" ")
                    output.push_str(struct_name)
                    output.push_str(";\n")
                case:
                }
            }
            // Also forward-declare enums with payloads (they're implemented as structs)
            if is_enum_declaration(child).and(is_enum_with_payloads(child)) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    enum_name := til_name(decl.name)
                    output.push_str("typedef struct ")
                    output.push_str(enum_name)
                    output.push_str(" ")
                    output.push_str(enum_name)
                    output.push_str(";\n")
                case:
                }
            }
        }
        output.push_str("\n")
    case:
    }

    // Pass 1a: emit simple enums (no payloads) - safe to emit early, structs may use them as fields
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child).and(not(is_enum_with_payloads(child))) {
                emit_enum_declaration(child, output)?
            }
        }
    case:
    }

    // Pass 1b: emit all structs and enums-with-payloads in topologically sorted order
    // Both are "complex types" that can depend on each other
    switch ast.node_type {
    case NodeType.Body:
        mut type_decls := Vec.new(Expr)
        for child: Expr in ast.params {
            if is_struct_declaration(child).or(is_enum_declaration(child).and(is_enum_with_payloads(child))) {
                type_decls.push(child)
            }
        }
        sorted_indices := topological_sort_types(type_decls)?
        for idx: I64 in sorted_indices {
            mut child := Expr()
            type_decls.get(idx, child)?
            if is_struct_declaration(child) {
                emit_struct_declaration(child, output)?
            } else {
                emit_enum_declaration(child, output)?
            }
        }
    case:
    }

    // Pass 2: emit function prototypes (forward declarations)
    // 2a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_func_declaration(child) {
                emit_func_prototype(child, context, output)?
            }
        }
    case:
    }
    // 2b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_func_prototypes(child, context, output)?
            }
        }
    case:
    }
    // 2c: hoisted nested function prototypes (collected in Pass 0a)
    if not(ctx.hoisted_prototypes.is_empty()) {
        output.push_str("\n// Nested function prototypes (hoisted)\n")
        for proto: Str in ctx.hoisted_prototypes {
            output.push_str(proto)
        }
    }
    output.push_str("\n")

    // Pass 3: include external C interface (after structs and forward decls)
    // Use angle brackets to search only -I paths (src/), not the current directory
    // This avoids including generated c/self/ext.c instead of the hand-written src/ext.c
    output.push_str("#include <ext.c>\n\n")

    // Pass 4: emit struct constants (non-mut, non-function fields with mangled names)
    // Also emits size_of constants for each struct
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_constants(child, output, ctx, context)?
            }
        }
    case:
    }

    // Pass 4a: emit size_of constants for enums
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child) {
                emit_enum_size_of_constant(child, output, ctx)?
            }
        }
    case:
    }

    // Pass 4a2: emit enum_to_str functions for all enums
    // This must come after structs are defined (Str is needed for return type)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_enum_declaration(child) {
                emit_enum_to_str_for_declaration(child, output, context)?
            }
        }
    case:
    }

    // Pass 4b: emit top-level constants (non-mut declarations with literal values)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_constant_declaration(child) {
                emit_constant_declaration(child, output, ctx, context)?
            }
        }
    case:
    }

    // Pass 4c: emit global declarations (non-constant, non-func/struct/enum declarations)
    // These need to be file-scope statics so functions can access them
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_global_declaration(child) {
                emit_global_declaration(child, output, ctx, context)?
            }
        }
    case:
    }

    // Pass 4d: emit til_size_of function (runtime type size lookup)
    emit_size_of_function(output, ctx)

    output.push_str("\n")

    // Pass 5: emit function definitions
    // 5a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_func_declaration(child) {
                emit_func_declaration(child, output, ctx, context)?
            }
        }
    case:
    }
    // 5b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_struct_declaration(child) {
                emit_struct_func_bodies(child, output, ctx, context)?
            }
        }
    case:
    }

    // 5c: hoisted nested function definitions
    // These were collected during emit_func_declaration when encountering nested functions
    // (prototypes were already emitted in Pass 2c)
    if not(ctx.hoisted_functions.is_empty()) {
        output.push_str("\n// Hoisted nested function definitions\n")
        for func_code: Str in ctx.hoisted_functions {
            output.push_str(func_code)
        }
    }

    // Check if main has variadic args (needs argc/argv)
    mut main_has_variadic := false
    if context.mode_def.needs_main_proc {
        fd := context.scope_stack.lookup_func("main")?
        catch (err: KeyNotFoundError) { }
        for fd_arg: Declaration in fd.args {
            switch fd_arg.value_type {
            case ValueType.TMulti:
                main_has_variadic = true
                break
            case:
            }
        }
    }

    // Main function - always name params (unnamed triggers -Wc23-extensions on clang)
    output.push_str("int main(int argc, char** argv) {\n")
    if not(main_has_variadic) {
        // Suppress -Wunused-parameter when argc/argv not used
        output.push_str("    (void)argc; (void)argv;\n")
    }

    // Re-populate declared_vars with global declarations (functions clear declared_vars)
    // This ensures global declarations emit only assignments in main(), not redeclarations
    switch ast.node_type {
    case NodeType.Body:
        for child: Expr in ast.params {
            if is_global_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    _ := ctx.declared_vars.insert(til_name(decl.name))
                case:
                }
            }
        }
    case:
    }

    // Pass 6: emit non-struct, non-function, non-enum, non-constant statements
    // Collect them into a Vec and use emit_stmts for proper variadic/throwing call handling
    // Note: global declarations are still included but will emit only assignments since they're already declared
    switch ast.node_type {
    case NodeType.Body:
        mut main_stmts := Vec.new(Expr)
        for child: Expr in ast.params {
            // Skip true/false declarations - they're now #defines
            mut skip := false
            switch child.node_type {
            case NodeType.Declaration(decl):
                if decl.name.eq("true").or(decl.name.eq("false")) {
                    skip = true
                }
            case:
            }
            if not(skip).and(not(is_func_declaration(child))).and(not(is_struct_declaration(child))).and(not(is_enum_declaration(child))).and(not(is_constant_declaration(child))) {
                main_stmts.push(child)
            }
        }
        emit_stmts(main_stmts, output, 1, ctx, context)?
    case:
    }

    // Call til_main() for modes that require a main proc (like cli)
    if context.mode_def.needs_main_proc {
        if main_has_variadic {
            // Convert argc/argv to til_Array and pass to til_main
            // Skip argv[0] (exe path) to match interpreter behavior
            output.push_str("    til_Array _main_args = til_Array_new(\"Str\", &(til_I64){argc - 1});\n")
            output.push_str("    for (int i = 1; i < argc; i++) {\n")
            output.push_str("        til_Str _arg = {((til_Ptr){(til_I64)argv[i], 1}), strlen(argv[i]), 0};\n")
            output.push_str("        til_IndexOutOfBoundsError _set_err;\n")
            output.push_str("        til_Array_set(&_set_err, &_main_args, &(til_I64){i - 1}, (til_Dynamic*)&_arg);\n")
            output.push_str("    }\n")
            output.push_str("    til_main(&_main_args);\n")
        } else {
            output.push_str("    til_main();\n")
        }
    }

    output.push_str("    return 0;\n")
    output.push_str("}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return output
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration:
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef:
                return true
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { }

    return false
}

// Check if an expression is an enum declaration (Name := enum {...})
is_enum_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration:
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef:
                return true
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { }

    return false
}

// Check if an expression is a top-level constant declaration (name := literal)
// Constants are non-mut declarations with literal values (numbers, strings, bools)
is_constant_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Must not be mutable
        if decl.is_mut {
            return false
        }
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.LLiteral:
                // Literal values are constants
                return true
            case NodeType.Identifier(name):
                // Bool identifiers (true/false) are constants
                if name.eq("true").or(name.eq("false")) {
                    return true
                }
            case NodeType.StructDef:
                // Skip struct definitions
                return false
            case NodeType.EnumDef:
                // Skip enum definitions
                return false
            case NodeType.FuncDef:
                // Skip function definitions
                return false
            case:
                return false
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) { }

    return false
}

// Check if an expression is a function call that uses out-params (i.e., the function throws)
// Such calls cannot be used inline in struct initializers - they need separate statements
// Emit a top-level constant declaration at file scope
emit_constant_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            // Bug #35: Use unique name for "_" declarations to avoid C redefinition errors
            mut var_name := ""
            if decl.name.eq("_") {
                var_name = next_mangled(ctx)
            } else {
                var_name = til_name(decl.name)
            }

            // Handle literal constants (numbers, strings)
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.LLiteral(lit):
                _has_str := context.scope_stack.lookup_struct("Str")?
                mut has_str_bool := true
                catch (err: KeyNotFoundError) {
                    has_str_bool = false
                }
                // Use the declaration's explicit type if available, otherwise infer from literal
                mut c_type := ""
                switch lit {
                case Literal.Number(n):
                    // Check if declaration has explicit type annotation
                    switch decl.value_type {
                    case ValueType.TCustom(const_type_name):
                        if const_type_name.eq(INFER_TYPE) {
                            throw expr.lang_error(context.path, "ccodegen", format("Declaration '", decl.name, "' has INFER_TYPE - should have been resolved by typer"))
                        }
                        c_type = TIL_PREFIX.concat(const_type_name)
                    case:
                        c_type = TIL_PREFIX.concat("I64")
                    }
                case Literal.Str(s):
                    if has_str_bool {
                        c_type = TIL_PREFIX.concat("Str")
                    } else {
                        c_type = "const char*"
                    }
                case Literal.List(l):
                    return // Skip list literals for now
                case:
                }
                // Non-mut declarations are constants
                if not(decl.is_mut) {
                    output.push_str("const ")
                }
                output.push_str(c_type)
                output.push_str(" ")
                output.push_str(var_name)
                output.push_str(" = ")
                emit_literal(lit, output, context)?
                output.push_str(";\n")
                // Handle Bool constants (true/false identifiers)
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")) {
                    if not(decl.is_mut) {
                        output.push_str("const ")
                    }
                    output.push_str(TIL_PREFIX)
                    output.push_str("Bool ")
                    output.push_str(var_name)
                    output.push_str(" = ")
                    // Use struct literal instead of macro (valid constant initializer)
                    if name.eq("true") {
                        output.push_str("((")
                        output.push_str(TIL_PREFIX)
                        output.push_str("Bool){1})")
                    } else {
                        output.push_str("((")
                        output.push_str(TIL_PREFIX)
                        output.push_str("Bool){0})")
                    }
                    output.push_str(";\n")
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Check if an expression is a non-constant top-level declaration that needs to be a global
// These are declarations that are NOT: functions, structs, enums, or literal constants
// but are still non-mut and could be referenced from function bodies
is_global_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip true/false declarations - they're handled specially
        if decl.name.eq("true").or(decl.name.eq("false")) {
            return false
        }
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
                // Skip these - they have their own handling
            case NodeType.StructDef(sd):
                return false
            case NodeType.EnumDef(ed):
                return false
            case NodeType.FuncDef(fd):
                return false
                // Skip literal constants - they're handled by is_constant_declaration
                // (only non-mut literals are constants)
            case NodeType.LLiteral(lit):
                if not(decl.is_mut) {
                    return false
                }
                return true
                // Skip true/false RHS - they're handled by is_constant_declaration
                // (only non-mut booleans are constants)
            case NodeType.Identifier(name):
                if name.eq("true").or(name.eq("false")).and(not(decl.is_mut)) {
                    return false
                }
                return true
                // Everything else (function calls like EvalArena.new(), etc.) is a global
            case:
                return true
            }
            catch (err: IndexOutOfBoundsError) { }
        }
    case:
    }
    return false
}

// Emit a global declaration as a static variable at file scope (type only, no initializer)
// The initializer will be emitted in main()
emit_global_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            // Bug #35: Use unique name for "_" declarations to avoid C redefinition errors
            mut var_name := ""
            if decl.name.eq("_") {
                var_name = next_mangled(ctx)
            } else {
                var_name = til_name(decl.name)
            }

            // Determine the type from the initializer expression using get_value_type
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            mut have_vt := true
            vt := get_value_type(context, first_param)?
            catch (err: Str) {
                have_vt = false
            }
            mut c_type := "int"
            if have_vt {
                c_type = til_type_to_c(vt)?
                catch (err: Str) {
                    c_type = til_type_to_c(decl.value_type)?
                    catch (err2: Str) {
                        c_type = "int"
                    }
                }
            } else {
                c_type = til_type_to_c(decl.value_type)?
                catch (err: Str) {
                    c_type = "int"
                }
            }

            // Emit static declaration (no initializer - will be set in main)
            output.push_str("static ")
            output.push_str(c_type)
            output.push_str(" ")
            output.push_str(var_name)
            output.push_str(";\n")

            // Track that this variable has been declared globally
            _ := ctx.declared_vars.insert(var_name)
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Collect function info (throw types, return types, names) from AST into context
// Handles both top-level functions and struct methods
collect_func_info := proc(expr: Expr, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.FuncDef(func_def):
                // Top-level function - check for variadic args (TMulti)
                mut idx := 0
                for func_def_arg: Declaration in func_def.args {
                    switch func_def_arg.value_type {
                    case ValueType.TMulti(elem_type):
                        mut info := VariadicParamInfo()
                        info.elem_type = elem_type.clone()
                        info.regular_count = idx
                        ctx.func_variadic_args.set(decl.name.clone(), info)
                        break // Only one variadic arg per function
                    case:
                    }
                    idx.inc()
                }
            case NodeType.StructDef(struct_def):
                // Struct methods - use mangled names (StructName_methodName)
                struct_name := decl.name
                for member_name: Str in struct_def.default_values.keys {
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)?
                    catch (err: KeyNotFoundError) {
                        panic(loc(), "KeyNotFoundError iterating keys: ", err.msg)
                    }
                    switch default_expr.node_type {
                    case NodeType.FuncDef(method_func_def):
                        mangled_name := struct_name.concat("_").concat(member_name)
                        // Check for variadic args (TMulti) in struct methods
                        mut method_idx := 0
                        for method_func_def_arg: Declaration in method_func_def.args {
                            switch method_func_def_arg.value_type {
                            case ValueType.TMulti(method_elem_type):
                                mut method_info := VariadicParamInfo()
                                method_info.elem_type = method_elem_type.clone()
                                method_info.regular_count = method_idx
                                ctx.func_variadic_args.set(mangled_name.clone(), method_info)
                                break
                            case:
                            }
                            method_idx.inc()
                        }
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Collect nested function info (for hoisting): scan function bodies for nested FuncDef declarations
// This populates ctx.nested_func_names and ctx.hoisted_prototypes before we emit function bodies
collect_nested_func_info := proc(expr: Expr, mut ctx: CodegenContext, context: Context, parent_func_name: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.FuncDef(func_def):
                if not(parent_func_name.eq("")) {
                    // This is a nested function - record it for hoisting
                    mangled_name := parent_func_name.concat("_").concat(decl.name)
                    ctx.nested_func_names.set(decl.name.clone(), mangled_name.clone())

                    // Generate prototype using emit_func_signature (handles throwing functions properly)
                    mut proto := ""
                    emit_func_signature(til_name(mangled_name), func_def, context, proto)?
                    proto.push_str(";\n")
                    ctx.hoisted_prototypes.push(proto)

                    // Recursively check for nested functions within this nested function
                    new_parent := mangled_name.clone()
                    for body_expr: Expr in func_def.body {
                        collect_nested_func_info(body_expr, ctx, context, new_parent)?
                    }
                } else {
                    // Top-level function - scan its body for nested functions
                    for body_expr: Expr in func_def.body {
                        collect_nested_func_info(body_expr, ctx, context, decl.name)?
                    }
                }
            case:
            }
        }
    case NodeType.Body:
        for child: Expr in expr.params {
            collect_nested_func_info(child, ctx, context, parent_func_name)?
        }
    case NodeType.If:
        // Check then and else branches (params[0] = condition, params[1] = then, params[2] = else)
        if expr.params.len().gt(1) {
            mut then_branch := Expr()
            expr.params.get(1, then_branch)?
            collect_nested_func_info(then_branch, ctx, context, parent_func_name)?
        }
        if expr.params.len().gt(2) {
            mut else_branch := Expr()
            expr.params.get(2, else_branch)?
            collect_nested_func_info(else_branch, ctx, context, parent_func_name)?
        }
    case NodeType.While:
        // Check loop body (params[0] = condition, params[1] = body)
        if expr.params.len().gt(1) {
            mut body := Expr()
            expr.params.get(1, body)?
            collect_nested_func_info(body, ctx, context, parent_func_name)?
        }
    case NodeType.Switch:
        // Check all case bodies (params[0] = value, rest are cases)
        mut i := 1
        while i.lt(expr.params.len()) {
            mut case_expr := Expr()
            expr.params.get(i, case_expr)?
            collect_nested_func_info(case_expr, ctx, context, parent_func_name)?
            i.inc()
        }
    case:
        // Recursively check all params for other node types
        for child: Expr in expr.params {
            collect_nested_func_info(child, ctx, context, parent_func_name)?
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit a struct declaration as a C struct (only mut fields become struct fields)
// Forward declarations are emitted separately, so we use "struct Name { ... };" here
emit_struct_declaration := proc(expr: Expr, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip I64, U8, Bool, Dynamic, Type - these are primitive typedefs defined in boilerplate
        if decl.name.eq("I64").or(decl.name.eq("U8")).or(decl.name.eq("Bool")).or(decl.name.eq("Dynamic")).or(decl.name.eq("Type")) {
            return
        }
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef(struct_def):
                output.push_str("struct ")
                output.push_str(til_name(decl.name))
                output.push_str(" {\n")
                for member: Declaration in struct_def.members {
                    // Only emit mut fields as struct members
                    // Skip functions and non-mut fields (constants)
                    if member.is_mut {
                        c_type := til_type_to_c(member.value_type)?
                        output.push_str("    ")
                        output.push_str(c_type)
                        output.push_str(" ")
                        output.push_str(member.name)
                        output.push_str(";\n")
                    }
                }
                output.push_str("};\n\n")
                return
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    throw "emit_struct_declaration: not a struct declaration"
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
// Also emits size_of constant: til_size_of_StructName = sizeof(til_StructName)
emit_struct_constants := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef(struct_def):
                struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        mut c_type_valid := false
                        mut c_type := ""
                        c_type = til_type_to_c(member.value_type)?
                        c_type_valid = true
                        catch (err: Str) {
                            // REM: Rust's Err case - til_type_to_c failed, skip this member
                        }

                        if c_type_valid {
                            mut default_val_valid := false
                            mut default_val := Expr()
                            struct_def.default_values.get(member.name, default_val)?
                            default_val_valid = true
                            catch (err: KeyNotFoundError) {
                                // REM: Rust's None case - member has no default value, skip
                            }

                            if default_val_valid {
                                output.push_str("const ")
                                output.push_str(c_type)
                                output.push_str(" ")
                                output.push_str(struct_name)
                                output.push_str("_")
                                output.push_str(member.name)
                                output.push_str(" = ")
                                emit_expr(default_val, output, 0, ctx, context)?
                                output.push_str(";\n")
                            }
                        }
                    }
                }
                // Emit size_of constant for this struct
                output.push_str("const ")
                output.push_str(TIL_PREFIX)
                output.push_str("I64 ")
                output.push_str(TIL_PREFIX)
                output.push_str("size_of_")
                output.push_str(decl.name)
                output.push_str(" = sizeof(")
                output.push_str(struct_name)
                output.push_str(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name.clone())
                return
            case:
            }
        }
    case:
    }
    // Not a struct, nothing to emit

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit size_of constant for an enum: til_size_of_EnumName = sizeof(til_EnumName)
emit_enum_size_of_constant := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef(enum_def):
                enum_name := til_name(decl.name)
                output.push_str("const ")
                output.push_str(TIL_PREFIX)
                output.push_str("I64 ")
                output.push_str(TIL_PREFIX)
                output.push_str("size_of_")
                output.push_str(decl.name)
                output.push_str(" = sizeof(")
                output.push_str(enum_name)
                output.push_str(");\n")
                // Track this type for til_size_of function generation
                ctx.known_types.push(decl.name.clone())
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit til_size_of function for runtime type size lookup
emit_size_of_function := proc(mut output: Str, ctx: CodegenContext) {
    output.push_str("\n")
    output.push_str("static inline ")
    output.push_str(TIL_PREFIX)
    output.push_str("I64 ")
    output.push_str(TIL_PREFIX)
    output.push_str("size_of(const ")
    output.push_str(TIL_PREFIX)
    output.push_str("Str* type_name) {\n")

    // All known types from structs and enums
    for type_name: Str in ctx.known_types {
        output.push_str("    if (strcmp((char*)type_name->c_string.data, \"")
        output.push_str(type_name)
        output.push_str("\") == 0) return ")
        output.push_str(TIL_PREFIX)
        output.push_str("size_of_")
        output.push_str(type_name)
        output.push_str(";\n")
    }

    output.push_str("    fprintf(stderr, \"size_of: unknown type %s\\n\", (char*)type_name->c_string.data);\n")
    output.push_str("    exit(1);\n")
    output.push_str("}\n")
}

// Check if an enum has any payloads
enum_has_payloads := func(enum_def: SEnumDef) returns Bool {
    for v: EnumVariant in enum_def.variants {
        if not(v.payload_type.is_null()) {
            return true
        }
    }
    return false
}

// Check if an expression is an enum declaration with payloads
is_enum_with_payloads := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef(enum_def):
                return enum_has_payloads(enum_def)
            case:
            }
            catch (err: IndexOutOfBoundsError) { }
        }
    case:
    }
    return false
}

// Emit an enum with payloads as a tagged union
emit_enum_with_payloads := proc(enum_name: Str, enum_def: SEnumDef, mut output: Str) throws Str {
    // Sort variants by name for deterministic output
    mut variants := Vec.new(EnumVariant)
    for v: EnumVariant in enum_def.variants {
        variants.push(v.clone())
    }
    sort_enum_variants(variants)

    // 1. Emit tag enum: typedef enum { Color_Unknown = 0, ... } Color_Tag;
    output.push_str("typedef enum {\n")
    mut index := 0
    for v: EnumVariant in variants {
        output.push_str("    ")
        output.push_str(enum_name)
        output.push_str("_")
        output.push_str(v.name)
        output.push_str(" = ")
        output.push_str(I64.to_str(index))
        output.push_str(",\n")
        index.inc()
    }
    output.push_str("} ")
    output.push_str(enum_name)
    output.push_str("_Tag;\n\n")

    // 2. Emit payload union (only for variants that have payloads)
    // typedef union { unsigned char Green; long long Number; } Color_Payload;
    mut has_any_payload := false
    for v: EnumVariant in variants {
        if not(v.payload_type.is_null()) {
            has_any_payload = true
            break
        }
    }
    if has_any_payload {
        output.push_str("typedef union {\n")
        for v: EnumVariant in variants {
            if not(v.payload_type.is_null()) {
                // Read payload_type from Ptr
                mut payload_vt := ValueType.TCustom("")
                memcpy(to_ptr(payload_vt), v.payload_type.data, size_of(ValueType))
                c_type := til_type_to_c(payload_vt)?
                output.push_str("    ")
                output.push_str(c_type)
                output.push_str(" ")
                output.push_str(v.name)
                output.push_str(";\n")
            }
        }
        output.push_str("} ")
        output.push_str(enum_name)
        output.push_str("_Payload;\n\n")
    }

    // 3. Emit wrapper struct: struct Color { til_I64 tag; Color_Payload payload; };
    // Note: typedef is already forward-declared, so we just define the struct body
    // Bug #137: Use til_I64 for tag to ensure consistent 8-byte offset for payload
    output.push_str("struct ")
    output.push_str(enum_name)
    output.push_str(" {\n")
    output.push_str("    ")
    output.push_str(TIL_PREFIX)
    output.push_str("I64 tag;\n")
    if has_any_payload {
        output.push_str("    ")
        output.push_str(enum_name)
        output.push_str("_Payload payload;\n")
    }
    output.push_str("};\n\n")

    // 4. Emit constructor functions for ALL variants (including no-payload ones)
    // This ensures consistent calling convention: Color_make_Red(42), Color_make_Unknown()
    for v: EnumVariant in variants {
        output.push_str("static inline ")
        output.push_str(enum_name)
        output.push_str(" ")
        output.push_str(enum_name)
        output.push_str("_make_")
        output.push_str(v.name)
        output.push_str("(")

        // Parameter for payload (if any)
        mut has_payload := false
        if not(v.payload_type.is_null()) {
            mut ctor_payload_vt := ValueType.TCustom("")
            memcpy(to_ptr(ctor_payload_vt), v.payload_type.data, size_of(ValueType))
            ctor_c_type := til_type_to_c(ctor_payload_vt)?
            output.push_str(ctor_c_type)
            output.push_str(" value")
            has_payload = true
        } else {
            output.push_str("void")
        }
        output.push_str(") {\n")

        // Constructor body
        output.push_str("    ")
        output.push_str(enum_name)
        output.push_str(" result = { .tag = ")
        output.push_str(enum_name)
        output.push_str("_")
        output.push_str(v.name)
        output.push_str(" };\n")

        // Set payload if present
        if has_payload {
            output.push_str("    result.payload.")
            output.push_str(v.name)
            output.push_str(" = value;\n")
        }

        output.push_str("    return result;\n")
        output.push_str("}\n\n")
    }

}

// Emit an enum declaration as a C typedef enum (for simple enums without payloads)
// or as a tagged union struct (for enums with payloads)
emit_enum_declaration := proc(expr: Expr, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.EnumDef(enum_def):
                enum_name := til_name(decl.name)

                if enum_has_payloads(enum_def) {
                    // Phase 2: Enums with payloads - tagged union
                    emit_enum_with_payloads(enum_name, enum_def, output)?
                    return
                }

                // Phase 1: Simple enum without payloads
                // typedef enum { EnumName_Variant1 = 0, ... } EnumName;
                output.push_str("typedef enum {\n")

                // Sort variants by name for deterministic output
                mut variants := Vec.new(Str)
                for v: EnumVariant in enum_def.variants {
                    variants.push(v.name)
                }
                sort_str_vec(variants)

                mut index := 0
                for variant_name: Str in variants {
                    output.push_str("    ")
                    output.push_str(enum_name)
                    output.push_str("_")
                    output.push_str(variant_name)
                    output.push_str(" = ")
                    output.push_str(I64.to_str(index))
                    output.push_str(",\n")
                    index.inc()
                }

                output.push_str("} ")
                output.push_str(enum_name)
                output.push_str(";\n\n")

                // Generate constructor functions for consistency with payload enums
                // static inline EnumName EnumName_make_Variant(void) { return EnumName_Variant; }
                for variant_name: Str in variants {
                    output.push_str("static inline ")
                    output.push_str(enum_name)
                    output.push_str(" ")
                    output.push_str(enum_name)
                    output.push_str("_make_")
                    output.push_str(variant_name)
                    output.push_str("(void) { return ")
                    output.push_str(enum_name)
                    output.push_str("_")
                    output.push_str(variant_name)
                    output.push_str("; }\n")
                }
                output.push_str("\n")

                return
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    throw "emit_enum_declaration: not an enum declaration"
}

// Emit a _to_str function for an enum type
// Takes a const pointer since we only read the enum
// For simple enums: til_Str til_EnumName_to_str(const til_EnumName* e)
// For enums with payloads: til_Str til_EnumName_to_str(const til_EnumName* e)
emit_enum_to_str_function := proc(enum_name: Str, enum_def: SEnumDef, mut output: Str) throws Str {
    has_payloads := enum_has_payloads(enum_def)
    mut variants := Vec.new(Str)
    for v: EnumVariant in enum_def.variants {
        variants.push(v.name)
    }
    sort_str_vec(variants)

    // Function signature - takes const pointer since we only read the enum
    output.push_str("static inline til_Str ")
    output.push_str(enum_name)
    output.push_str("_to_str(const ")
    output.push_str(enum_name)
    output.push_str("* e) {\n    switch(")
    if has_payloads {
        output.push_str("e->tag")
    } else {
        output.push_str("*e")
    }
    output.push_str(") {\n")

    // Cases - need the original (non-prefixed) enum name for the string
    mut original_name := enum_name
    if enum_name.starts_with(TIL_PREFIX) {
        original_name = enum_name.get_substr(TIL_PREFIX.len(), enum_name.len())?
    }

    for variant: Str in variants {
        full_name := original_name.concat(".").concat(variant)
        output.push_str("        case ")
        output.push_str(enum_name)
        output.push_str("_")
        output.push_str(variant)
        // Use new Str format with Ptr { data, is_borrowed=1 }, len, cap=0
        output.push_str(": return ((til_Str){((til_Ptr){(til_I64)\"")
        output.push_str(full_name)
        output.push_str("\", 1}), ")
        output.push_str(I64.to_str(full_name.len()))
        output.push_str(", 0});\n")
    }

    // Default case (shouldn't happen but good for safety)
    unknown_name := original_name.concat(".?")
    // Use new Str format with Ptr { data, is_borrowed=1 }, len, cap=0
    output.push_str("    }\n    return ((til_Str){((til_Ptr){(til_I64)\"")
    output.push_str(unknown_name)
    output.push_str("\", 1}), ")
    output.push_str(I64.to_str(unknown_name.len()))
    output.push_str(", 0});\n}\n\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit _to_str function for an enum declaration node
emit_enum_to_str_for_declaration := proc(expr: Expr, mut output: Str, context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        enum_name := decl.name
        mut have_enum_def := true
        enum_def := context.scope_stack.lookup_enum(enum_name)?
        catch (err: KeyNotFoundError) {
            have_enum_def = false
        }
        if have_enum_def {
            c_enum_name := til_name(enum_name)
            emit_enum_to_str_function(c_enum_name, enum_def, output)?
            return
        }
    case:
    }
    throw "emit_enum_to_str_for_declaration: not an enum declaration"
}

// Emit struct function prototypes for all functions in a struct
emit_struct_func_prototypes := proc(expr: Expr, context: Context, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef(struct_def):
                struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Check if default_value is a function definition
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)?
                    catch (err: KeyNotFoundError) {
                        // REM: member has no default value, skip
                    }
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        mangled_name := struct_name.concat("_").concat(member.name)
                        emit_func_signature(mangled_name, func_def, context, output)?
                        output.push_str(";\n")
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit a struct function body with mangled name: StructName_funcname
emit_struct_func_body := proc(struct_name: Str, member: Declaration, func_def: SFuncDef, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Skip external functions
    if func_def.is_ext() {
        return
    }

    // Set current function context
    ctx.current_throw_types = func_def.throw_types.clone()
    ctx.current_return_types = func_def.return_types.clone()
    // Track mut params for pointer dereference (-> vs .)
    ctx.current_ref_params.clear()
    // Track variadic params - they're passed as til_Array* so need dereference
    ctx.current_variadic_params.clear()
    for func_def_arg: Declaration in func_def.args {
        // Bug #60: All non-copy args are passed by pointer (mut, own, and const/default)
        if not(func_def_arg.is_copy) {
            _ := ctx.current_ref_params.insert(func_def_arg.name.clone())
        }
        switch func_def_arg.value_type {
        case ValueType.TMulti(elem_type):
            // elem_type is the type name string like "Bool"
            ctx.current_variadic_params.set(func_def_arg.name.clone(), til_name(elem_type))
        case:
        }
    }

    // Push a new scope frame for this function (like interpreter does)
    mut function_frame := ScopeFrame()
    function_frame.scope_type = ScopeType.Function
    // Register function parameters in the frame
    for func_def_arg: Declaration in func_def.args {
        mut info := SymbolInfo()
        info.value_type = func_def_arg.value_type
        info.is_mut = func_def_arg.is_mut
        info.is_copy = func_def_arg.is_copy
        info.is_own = func_def_arg.is_own
        info.is_comptime_const = false
        function_frame.symbols.set(func_def_arg.name.clone(), info)
    }
    context.scope_stack.frames.push(function_frame)

    // Clear declared_vars for new function scope
    ctx.declared_vars.clear()

    mangled_name := struct_name.concat("_").concat(member.name)

    // Save and set current function name for deterministic temp naming (Bug #42 fix)
    prev_function_name := ctx.current_function_name.clone()
    prev_mangling_counter := ctx.mangling_counter
    ctx.current_function_name = mangled_name.clone()
    ctx.mangling_counter = 0

    emit_func_signature(mangled_name, func_def, context, output)?
    output.push_str(" {\n")

    // Emit function body with catch pattern detection
    emit_stmts(func_def.body, output, 1, ctx, context)?

    // Add implicit return at end to silence gcc -Wreturn-type warnings
    // when all paths return inside branches but gcc can't prove exhaustiveness
    if not(func_def.throw_types.is_empty()) {
        // Throwing functions return int (0=success, 1+=error)
        output.push_str("    return 0;\n")
    } else if not(func_def.return_types.is_empty()) {
        // Non-throwing functions with return type - add zero-initialized fallback
        mut ret_type_vt := ValueType.TCustom("")
        func_def.return_types.get(0, ret_type_vt)?
        ret_type := til_type_to_c(ret_type_vt)?
        output.push_str("    return (")
        output.push_str(ret_type)
        output.push_str("){0};\n")
    }

    output.push_str("}\n\n")

    // Restore previous function name and counter
    ctx.current_function_name = prev_function_name
    ctx.mangling_counter = prev_mangling_counter

    // Pop the function scope frame
    mut _popped_frame := ScopeFrame()
    context.scope_stack.frames.pop(_popped_frame)?

    // Clear current function context
    ctx.current_throw_types.clear()
    ctx.current_return_types.clear()

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit struct function bodies for all functions in a struct
emit_struct_func_bodies := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.StructDef(struct_def):
                struct_name := til_name(decl.name)
                for member: Declaration in struct_def.members {
                    // Check if default_value is a function definition
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)?
                    catch (err: KeyNotFoundError) {
                        // REM: member has no default value, skip
                    }
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        emit_struct_func_body(struct_name, member, func_def, output, ctx, context)?
                    case:
                    }
                }
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Convert TIL type to C type. Returns Err if the type can't be represented in C (e.g., functions, infer)
til_type_to_c := func(til_type: ValueType) returns Str throws Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq(INFER_TYPE) {
            throw "Cannot convert inferred type to C"
        } else {
            // All types get TIL_PREFIX
            return TIL_PREFIX.concat(name)
        }
    case ValueType.TFunction(ft):
        throw "Cannot convert function type to C"
    case ValueType.TType(tt):
        throw "Cannot convert Type to C"
    case ValueType.TMulti(mt):
        throw "Cannot convert multi-type to C"
    }
}

// Helper to get C type name for a ValueType (for error struct definitions)
value_type_to_c_name := func(vt: ValueType) returns Str throws Str {
    switch vt {
    case ValueType.TCustom(name):
        // All types get TIL_PREFIX
        return TIL_PREFIX.concat(name)
    case:
        throw "Cannot convert to C type name"
    }
}

// Issue #119: Check if a throw type refers to an empty struct (no fields)
// For empty structs, we don't need to pass error parameters - just the status code
is_empty_error_struct := func(context: Context, throw_type: ValueType) returns Bool {
    switch throw_type {
    case ValueType.TCustom(type_name):
        struct_def_opt := context.scope_stack.lookup_struct(type_name)?
        catch (err: KeyNotFoundError) {
            return false
        }
        return struct_def_opt.members.is_empty()
    case:
        return false
    }
}

// Emit function signature (used by both prototype and definition)
// For throwing functions:
//   int func_name(RetType* _ret, Error1* _err1, Error2* _err2, args...)
// For non-throwing:
//   RetType func_name(args...)
// Issue #119: Empty struct errors don't get parameters - only status code matters
emit_func_signature := proc(func_name: Str, func_def: SFuncDef, context: Context, mut output: Str) throws Str {
    is_throwing := not(func_def.throw_types.is_empty())

    if is_throwing {
        // Throwing function returns int status code
        output.push_str("int ")
    } else {
        // Non-throwing function returns its actual type
        if func_def.return_types.is_empty() {
            output.push_str("void ")
        } else {
            mut ret_type_vt := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type_vt)?
            ret_type := til_type_to_c(ret_type_vt)?
            output.push_str(ret_type)
            output.push_str(" ")
        }
    }

    output.push_str(func_name)
    output.push_str("(")

    mut param_count := 0

    if is_throwing {
        // Output params first: return value pointer, then error pointers
        if not(func_def.return_types.is_empty()) {
            mut thr_ret_type_vt := ValueType.TCustom("")
            func_def.return_types.get(0, thr_ret_type_vt)?
            thr_ret_type := til_type_to_c(thr_ret_type_vt)?
            output.push_str(thr_ret_type)
            output.push_str("* _ret")
            param_count.inc()
        }

        // Issue #119: Skip empty struct errors - only status code matters
        for i in 0..func_def.throw_types.len() {
            mut throw_type := ValueType.TCustom(INFER_TYPE)
            func_def.throw_types.get(i, throw_type)?
            if is_empty_error_struct(context, throw_type) {
                // Skip this error parameter for empty struct
            } else {
                if param_count.gt(0) {
                    output.push_str(", ")
                }
                err_type := value_type_to_c_name(throw_type)?
                output.push_str(err_type)
                output.push_str("* _err")
                output.push_str(I64.to_str(i.add(1)))
                param_count.inc()
            }
        }
    }

    // Input parameters
    for func_def_arg: Declaration in func_def.args {
        if param_count.gt(0) {
            output.push_str(", ")
        }
        // Check for variadic arg (TMulti)
        switch func_def_arg.value_type {
        case ValueType.TMulti(elem_type):
            // Variadic args are passed as til_Array*
            output.push_str(TIL_PREFIX)
            output.push_str("Array* ")
            output.push_str(TIL_PREFIX)
            output.push_str(func_def_arg.name)
            param_count.inc()
            break // Variadic must be last
        case ValueType.TCustom(type_name):
            arg_type := til_type_to_c(func_def_arg.value_type)?

            // Bug #60: Type is already const char*, don't add extra indirection
            is_type_param := type_name.eq("Type")
            if func_def_arg.is_mut {
                // mut: pass by pointer so mutations are visible to caller
                output.push_str(arg_type)
                output.push_str("* ")
            } else if func_def_arg.is_own {
                // own: pass by pointer, caller transfers ownership
                // Type is already a pointer, so pass by value
                if is_type_param {
                    output.push_str(arg_type)
                    output.push_str(" ")
                } else {
                    output.push_str(arg_type)
                    output.push_str("* ")
                }
            } else if func_def_arg.is_copy {
                // copy: pass by value, caller's copy is made
                output.push_str(arg_type)
                output.push_str(" ")
            } else {
                // const (default): pass by const pointer, read-only
                // Type is already a pointer, so pass by value
                if is_type_param {
                    output.push_str(arg_type)
                    output.push_str(" ")
                } else {
                    output.push_str("const ")
                    output.push_str(arg_type)
                    output.push_str("* ")
                }
            }
            output.push_str(TIL_PREFIX)
            output.push_str(func_def_arg.name)
            param_count.inc()
        case:
        }
    }

    if param_count.eq(0) {
        output.push_str("void")
    }

    output.push_str(")")

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, context: Context, mut output: Str) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions (ext_proc/ext_func) - they're just declarations
                if func_def.is_ext() {
                    return
                }

                func_name := til_name(decl.name)
                emit_func_signature(func_name, func_def, context, output)?
                output.push_str(";\n")
                return
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    throw "emit_func_prototype: not a function declaration"
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.FuncDef(fd):
                return true
            case:
            }
            catch (err: IndexOutOfBoundsError) { }
        }
    case:
    }
    return false
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, mut output: Str, mut ctx: CodegenContext, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions (ext_proc/ext_func) - they're just declarations
                if func_def.is_ext() {
                    return
                }

                // Set current function context for return/throw generation
                ctx.current_throw_types = func_def.throw_types.clone()
                ctx.current_return_types = func_def.return_types.clone()
                // Track ref params for pointer dereference (-> vs .)
                ctx.current_ref_params.clear()
                // Track variadic params - they're passed as til_Array* so need dereference
                ctx.current_variadic_params.clear()
                for func_def_arg: Declaration in func_def.args {
                    // Bug #60: All non-copy args are passed by pointer (mut, own, and const/default)
                    if not(func_def_arg.is_copy) {
                        _ := ctx.current_ref_params.insert(func_def_arg.name.clone())
                    }
                    switch func_def_arg.value_type {
                    case ValueType.TMulti(elem_type):
                        // elem_type is the type name string like "Bool"
                        ctx.current_variadic_params.set(func_def_arg.name.clone(), til_name(elem_type))
                    case:
                    }
                }

                // Push a new scope frame for this function (like interpreter does)
                mut function_frame := ScopeFrame()
                function_frame.scope_type = ScopeType.Function
                // Register function parameters in the frame
                // For variadic params (TMulti), register as Array type
                for func_def_arg: Declaration in func_def.args {
                    mut value_type := func_def_arg.value_type
                    switch func_def_arg.value_type {
                    case ValueType.TMulti(elem):
                        value_type = ValueType.TCustom("Array")
                    case:
                    }
                    mut info := SymbolInfo()
                    info.value_type = value_type
                    info.is_mut = func_def_arg.is_mut
                    info.is_copy = func_def_arg.is_copy
                    info.is_own = func_def_arg.is_own
                    info.is_comptime_const = false
                    function_frame.symbols.set(func_def_arg.name.clone(), info)
                }
                context.scope_stack.frames.push(function_frame)

                // Clear declared_vars for new function scope
                ctx.declared_vars.clear()

                func_name := til_name(decl.name)

                // Save and set current function name for nested function mangling
                prev_function_name := ctx.current_function_name.clone()
                prev_mangling_counter := ctx.mangling_counter
                ctx.current_function_name = decl.name.clone()
                ctx.mangling_counter = 0  // Reset counter per-function for determinism

                emit_func_signature(func_name, func_def, context, output)?
                output.push_str(" {\n")

                // Emit function body with catch pattern detection
                emit_stmts(func_def.body, output, 1, ctx, context)?

                // Add implicit return at end to silence gcc -Wreturn-type warnings
                if not(func_def.throw_types.is_empty()) {
                    output.push_str("    return 0;\n")
                } else if not(func_def.return_types.is_empty()) {
                    mut ret_type_vt := ValueType.TCustom("")
                    func_def.return_types.get(0, ret_type_vt)?
                    ret_type := til_type_to_c(ret_type_vt)?
                    output.push_str("    return (")
                    output.push_str(ret_type)
                    output.push_str("){0};\n")
                }

                output.push_str("}\n\n")

                // Pop the function scope frame
                mut _popped_frame := ScopeFrame()
                context.scope_stack.frames.pop(_popped_frame)?

                // Restore previous function name and counter
                ctx.current_function_name = prev_function_name
                ctx.mangling_counter = prev_mangling_counter

                // Clear current function context
                ctx.current_throw_types.clear()
                ctx.current_return_types.clear()

                return
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    throw "emit_func_declaration: not a function declaration"
}

emit_expr := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Bug #143: Hoisting now happens via emit_arg_string at the call site
    // Expressions are processed once and the result is used directly

    switch expr.node_type {
    case NodeType.Body:
        emit_body(expr, output, indent, ctx, context)?
    case NodeType.FCall(_):
        emit_fcall(expr, output, indent, ctx, context)?
    case NodeType.LLiteral(lit):
        emit_literal(lit, output, context)?
    case NodeType.Declaration(decl):
        emit_declaration(decl, expr, output, indent, ctx, context)?
    case NodeType.Identifier(name):
        // Bug #32 fix: Handle field access on expression results
        // When name is "_", params[0] is an expression to emit first,
        // then params[1..] are the field chain
        if name.eq("_").and(not(expr.params.is_empty())) {
            // Emit the base expression (params[0])
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            emit_expr(first_param, output, indent, ctx, context)?
            // Then emit the field chain
            mut i := 1
            while i.lt(expr.params.len()) {
                mut param := Expr()
                expr.params.get(i, param)?
                switch param.node_type {
                case NodeType.Identifier(field):
                    output.push_str(".")
                    output.push_str(field)
                case:
                }
                i.inc()
            }
            return
        }

        // Check for type-qualified access (Type.field or Type.Variant)
        if not(expr.params.is_empty()) {
            mut type_first_param := Expr()
            expr.params.get(0, type_first_param)?
            switch type_first_param.node_type {
            case NodeType.Identifier(type_field):
                // Check if this is an enum variant by looking up in context
                mut type_have_enum_def := true
                type_enum_def := context.scope_stack.lookup_enum(name)?
                catch (err: KeyNotFoundError) {
                    type_have_enum_def = false
                }
                if type_have_enum_def {
                    if type_enum_def.contains_key(type_field)? {
                        // Enum variant: Type.Variant -> til_Type_make_Variant()
                        output.push_str(TIL_PREFIX)
                        output.push_str(name)
                        output.push_str("_make_")
                        output.push_str(type_field)
                        output.push_str("()")
                        return
                    }
                }
                // Check if this is a struct constant access
                _type_struct_def := context.scope_stack.lookup_struct(name)?
                if true { // TODO Bug #96 workaround
                    // Struct constant: Type.constant -> til_Type_constant
                    output.push_str(til_name(name))
                    output.push_str("_")
                    output.push_str(type_field)
                    return
                }
                catch (err: KeyNotFoundError) {
                    // Not a struct constant, continue
                }
            case:
            }
        }
        // Regular identifier or field access (b.val -> til_b.val)
        // For ref params (which are pointers in C), use -> for field access
        is_ref_param := ctx.current_ref_params.contains(name)
        if is_ref_param.and(not(expr.params.is_empty())) {
            // Ref param with field access: til_self->field1.field2.field3
            // First field uses -> (self is a pointer), rest use . (struct values)
            output.push_str(til_name(name))
            mut ref_field_i := 0
            for ref_field_param: Expr in expr.params {
                switch ref_field_param.node_type {
                case NodeType.Identifier(ref_field_name):
                    if ref_field_i.eq(0) {
                        output.push_str("->")
                    } else {
                        output.push_str(".")
                    }
                    output.push_str(ref_field_name)
                case:
                }
                ref_field_i.inc()
            }
        } else if is_ref_param {
            // Ref param used as value: dereference with *
            output.push_str("(*")
            output.push_str(til_name(name))
            output.push_str(")")
        } else {
            // Regular identifier or field access
            output.push_str(til_name(name))
            for param: Expr in expr.params {
                switch param.node_type {
                case NodeType.Identifier(field):
                    output.push_str(".")
                    output.push_str(field)  // Field names stay as-is (C struct fields)
                case:
                }
            }
        }
    case NodeType.FuncDef(func_def):
        emit_funcdef(func_def, expr, output, indent, ctx, context)?
    case NodeType.Assignment(name):
        emit_assignment(name, expr, output, indent, ctx, context)?
    case NodeType.Return:
        emit_return(expr, output, indent, ctx, context)?
    case NodeType.If:
        emit_if(expr, output, indent, ctx, context)?
    case NodeType.While:
        emit_while(expr, output, indent, ctx, context)?
    case NodeType.Break:
        emit_break(expr, output, indent)
    case NodeType.Continue:
        emit_continue(expr, output, indent)
    case NodeType.Catch:
        // Catch blocks handled at call site
    case NodeType.Throw:
        emit_throw(expr, output, indent, ctx, context)?
    case NodeType.StructDef(sd):
        throw "ccodegen: StructDef should be handled at top level, not in emit_expr"
    case NodeType.EnumDef(ed):
        throw "ccodegen: EnumDef should be handled at top level, not in emit_expr"
    case NodeType.Switch:
        emit_switch(expr, output, indent, ctx, context)?
    case NodeType.DefaultCase:
        throw "ccodegen: DefaultCase should be handled inside emit_switch"
    case NodeType.Range:
        throw "ccodegen: Range not yet supported"
    case NodeType.Pattern(p):
        throw "ccodegen: Pattern should be handled inside emit_switch"
    case NodeType.NamedArg(na):
        throw expr.error(context.path, "ccodegen", "NamedArg should be reordered before reaching emit_expr")
    case NodeType.ForIn(fi):
        throw expr.lang_error(context.path, "ccodegen", "ForIn should be desugared in precomp before reaching ccodegen")
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_body := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Bug #44 fix: Save and restore local_catch_labels around nested blocks
    // Without this, nested blocks clear the outer catches when processing their
    // own throwing calls, causing missing status checks for outer throwing calls.
    saved_catch_labels := ctx.local_catch_labels.clone()
    emit_stmts(expr.params, output, indent, ctx, context)?
    ctx.local_catch_labels = saved_catch_labels

}

/// Emit a sequence of statements with catch pattern detection
/// This is the core logic shared between emit_body and emit_func_declaration
emit_stmts := proc(stmts: Vec, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    mut i := 0
    indent_str := repeat("    ", indent)

    // Pre-scan for function-level catches (at the end of the block)
    func_level_catches := prescan_func_level_catches(stmts)

    // Hoist declarations from catch blocks to function level
    // (TIL has function-level scoping, not block-level scoping)
    for catch_block: Expr in func_level_catches {
        if catch_block.params.len().gteq(3) {
            // Temporarily add the catch error variable to scope for type inference
            // catch (err: ErrType) { body } -> err_var=params[0], err_type=params[1], body=params[2]
            mut err_var_param := Expr()
            catch_block.params.get(0, err_var_param)?
            mut err_type_param := Expr()
            catch_block.params.get(1, err_type_param)?
            switch err_var_param.node_type {
            case NodeType.Identifier(err_var_name):
                switch err_type_param.node_type {
                case NodeType.Identifier(err_type_name):
                    mut info := SymbolInfo()
                    info.value_type = ValueType.TCustom(err_type_name.clone())
                    info.is_mut = false
                    info.is_copy = false
                    info.is_own = false
                    info.is_comptime_const = false
                    context.scope_stack.declare_symbol(err_var_name.clone(), info)?
                case:
                }
            case:
            }

            mut catch_body := Expr()
            catch_block.params.get(2, catch_body)?
            decls := collect_declarations_in_body(catch_body, context)?
            for decl: CollectedDeclaration in decls {
                c_var_name := til_name(decl.name)
                if not(ctx.declared_vars.contains(c_var_name)) {
                    mut have_c_type := true
                    c_type := til_type_to_c(decl.value_type)?
                    catch (err: Str) {
                        have_c_type = false
                    }
                    if have_c_type {
                        output.push_str(indent_str)
                        output.push_str(c_type)
                        output.push_str(" ")
                        output.push_str(c_var_name)
                        output.push_str(";\n")
                        _ := ctx.declared_vars.insert(c_var_name)
                        // Also register in scope_stack so get_value_type can find it
                        mut sym_info := SymbolInfo()
                        sym_info.value_type = decl.value_type
                        sym_info.is_mut = false
                        sym_info.is_copy = false
                        sym_info.is_own = false
                        sym_info.is_comptime_const = false
                        context.scope_stack.declare_symbol(decl.name.clone(), sym_info)?
                    }
                }
            }
        }
    }

    // Bug #39 fix: Give each catch block its own unique label using the global counter
    // Store catch info with statement index so we can match calls to their NEXT catch
    mut all_catch_info := Vec.new(CatchLabelInfoEntry)
    mut scan_idx := 0
    for scan_stmt: Expr in stmts {
        switch scan_stmt.node_type {
        case NodeType.Catch:
            if scan_stmt.params.len().gteq(3) {
                mut scan_err_type_param := Expr()
                scan_stmt.params.get(1, scan_err_type_param)?
                switch scan_err_type_param.node_type {
                case NodeType.Identifier(scan_err_type_name):
                    catch_suffix := next_mangled(ctx)
                    mut entry := CatchLabelInfoEntry()
                    entry.stmt_index = scan_idx
                    entry.type_name = scan_err_type_name.clone()
                    entry.label = concat("_catch_", scan_err_type_name).concat("_").concat(catch_suffix)
                    entry.temp_var = concat("_thrown_", scan_err_type_name).concat("_").concat(catch_suffix)
                    all_catch_info.push(entry)
                case:
                }
            }
        case:
        }
        scan_idx.inc()
    }

    // Declare temp variables for all catches at the start
    for catch_entry: CatchLabelInfoEntry in all_catch_info {
        output.push_str(indent_str)
        output.push_str(til_name(catch_entry.type_name))
        output.push_str(" ")
        output.push_str(catch_entry.temp_var)
        output.push_str(";\n")
    }

    // For backward compatibility, also populate local_catch_labels with first catch of each type
    // This is used by throw statements and nested blocks
    mut registered_types := Set.new(Str)
    for catch_entry: CatchLabelInfoEntry in all_catch_info {
        if not(registered_types.contains(catch_entry.type_name)) {
            _ := registered_types.insert(catch_entry.type_name.clone())
            mut cli := CatchLabelInfo()
            cli.label = catch_entry.label.clone()
            cli.temp_var = catch_entry.temp_var.clone()
            ctx.local_catch_labels.set(catch_entry.type_name.clone(), cli)
        }
    }

    // Track which catch labels have been emitted to avoid duplicates
    // (when multiple catches of same type exist, only emit the label once)
    mut emitted_catch_labels := Set.new(Str)

    // Process all statements
    while i.lt(stmts.len()) {
        mut stmt := Expr()
        stmts.get(i, stmt)?
        effective_indent := indent  // Use same indent for all statements (no if-block nesting)

        // Bug #39 fix: Handle catch blocks inline with if(0) { label: ... }
        // This keeps catches where they appear in source, and execution falls through after
        switch stmt.node_type {
        case NodeType.Catch:
            // Get the error type this catch handles
            if stmt.params.len().gteq(3) {
                mut stmt_err_type_param := Expr()
                stmt.params.get(1, stmt_err_type_param)?
                switch stmt_err_type_param.node_type {
                case NodeType.Identifier(stmt_err_type_name):
                    // Look up this specific catch's label from all_catch_info by statement index
                    mut catch_entry_found := false
                    mut catch_entry_label := ""
                    mut catch_entry_temp_var := ""
                    for e: CatchLabelInfoEntry in all_catch_info {
                        if e.stmt_index.eq(i) {
                            catch_entry_found = true
                            catch_entry_label = e.label.clone()
                            catch_entry_temp_var = e.temp_var.clone()
                            break
                        }
                    }
                    if catch_entry_found {
                        // Only emit if we haven't already emitted this label
                        if not(emitted_catch_labels.contains(catch_entry_label)) {
                            _ := emitted_catch_labels.insert(catch_entry_label.clone())

                            output.push_str(indent_str)
                            output.push_str("if (0) { ")
                            output.push_str(catch_entry_label)
                            // Add empty statement after label - C11 requires statement after label, not declaration
                            output.push_str(":;\n")

                            // Bind error variable
                            mut emit_err_var_param := Expr()
                            stmt.params.get(0, emit_err_var_param)?
                            switch emit_err_var_param.node_type {
                            case NodeType.Identifier(emit_err_var_name):
                                emit_inner_indent := repeat("    ", indent.add(1))
                                output.push_str(emit_inner_indent)
                                output.push_str(til_name(stmt_err_type_name))
                                output.push_str(" ")
                                output.push_str(til_name(emit_err_var_name))
                                output.push_str(" = ")
                                output.push_str(catch_entry_temp_var)
                                output.push_str(";\n")

                                // Add error variable to scope for type resolution in catch body
                                mut emit_sym_info := SymbolInfo()
                                emit_sym_info.value_type = ValueType.TCustom(stmt_err_type_name.clone())
                                emit_sym_info.is_mut = false
                                emit_sym_info.is_copy = false
                                emit_sym_info.is_own = false
                                emit_sym_info.is_comptime_const = false
                                context.scope_stack.declare_symbol(emit_err_var_name.clone(), emit_sym_info)?
                            case:
                            }

                            // Emit catch body
                            // IMPORTANT: Temporarily clear local_catch_labels so throwing calls inside
                            // the catch body don't try to jump to catches - catches shouldn't catch
                            // errors from their own body, only from code before them
                            saved_catch_labels := ctx.local_catch_labels.clone()
                            ctx.local_catch_labels.clear()
                            mut catch_body_expr := Expr()
                            stmt.params.get(2, catch_body_expr)?
                            emit_expr(catch_body_expr, output, indent.add(1), ctx, context)?
                            ctx.local_catch_labels = saved_catch_labels

                            // Close the if(0) block - execution falls through to code after
                            output.push_str(indent_str)
                            output.push_str("}\n")

                            // Bug #46 fix: Remove this catch from local_catch_labels
                            // Catches should only handle throws from BEFORE them, not after.
                            ctx.local_catch_labels.remove(stmt_err_type_name)
                        }
                    }
                case:
                }
            }
            i.inc()
            continue
        case:
        }

        // Check if this statement is followed by catch blocks
        // And if it's a call to a throwing function (FCall, Declaration with FCall, or Assignment with FCall)
        mut maybe_fcall_found := false
        mut maybe_fcall := stmt
        mut maybe_decl_name := ""
        mut maybe_assign_name := ""

        switch stmt.node_type {
        case NodeType.FCall(_):
            maybe_fcall_found = true
            maybe_fcall = stmt
        case NodeType.Declaration(decl):
            // Check if declaration has an FCall as initializer
            if not(stmt.params.is_empty()) {
                mut first_param := Expr()
                stmt.params.get(0, first_param)?
                switch first_param.node_type {
                case NodeType.FCall(_):
                    maybe_fcall_found = true
                    maybe_fcall = first_param
                    maybe_decl_name = decl.name.clone()
                case:
                }
            }
        case NodeType.Assignment(assign_name):
            // Check if assignment has an FCall as RHS
            if not(stmt.params.is_empty()) {
                mut assign_first_param := Expr()
                stmt.params.get(0, assign_first_param)?
                switch assign_first_param.node_type {
                case NodeType.FCall(_):
                    maybe_fcall_found = true
                    maybe_fcall = assign_first_param
                    maybe_assign_name = assign_name.clone()
                case:
                }
            }
        case:
        }

        if maybe_fcall_found {
            // eval functions from std.meta are only available in interpret mode
            if not(maybe_fcall.params.is_empty()) {
                mut func_name_param := Expr()
                maybe_fcall.params.get(0, func_name_param)?
                func_name := get_til_func_name_string(func_name_param)?
                if func_name.eq("eval_file").or(func_name.eq("eval_to_str")).or(func_name.eq("eval_to_ast_str")).or(func_name.eq("eval_to_expr")) {
                    throw maybe_fcall.error(context.path, "ccodegen", func_name.concat("() is only available in interpret mode, not in build/run"))
                }
            }

            // Get function name from the FCall
            // Check if this function is a throwing function
            fd := get_fcall_func_def(context, maybe_fcall)?
            if not(fd.throw_types.is_empty()) {
                throw_types := fd.throw_types

                // Collect subsequent catch blocks
                mut catch_blocks := Vec.new(Expr)
                mut j := i.add(1)
                while j.lt(stmts.len()) {
                    mut next_stmt := Expr()
                    stmts.get(j, next_stmt)?
                    switch next_stmt.node_type {
                    case NodeType.Catch:
                        catch_blocks.push(next_stmt)
                        j.inc()
                    case:
                        break
                    }
                }

                if not(catch_blocks.is_empty()).and(func_level_catches.is_empty()) {
                    // Immediate catches AND no function-level catches - handle inline
                    emit_throwing_call(maybe_fcall, throw_types, catch_blocks, maybe_decl_name, maybe_assign_name, output, effective_indent, ctx, context)?
                    i = j  // Skip past catch blocks
                    continue
                } else if not(ctx.current_throw_types.is_empty()).and(ctx.local_catch_labels.is_empty()).and(func_level_catches.is_empty()) {
                    // Bug #68 fix: Also check func_level_catches.is_empty()
                    // No catch blocks, we're inside a throwing function, and no catches in this block
                    // Emit error propagation pattern
                    emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, maybe_assign_name, output, effective_indent, ctx, context)?
                    i.inc()
                    continue
                } else if not(func_level_catches.is_empty()).or(not(ctx.local_catch_labels.is_empty())) {
                    // Has function-level catches or outer catches registered
                    // Bug #39 fix: Update local_catch_labels to point to NEXT catch for each type
                    // Build map with only catches AFTER current position
                    mut next_catches := Map.new(Str, CatchLabelInfo)
                    for catch_entry: CatchLabelInfoEntry in all_catch_info {
                        if catch_entry.stmt_index.gt(i).and(not(next_catches.contains_key(catch_entry.type_name))) {
                            // First catch of this type after current position
                            mut next_cli := CatchLabelInfo()
                            next_cli.label = catch_entry.label.clone()
                            next_cli.temp_var = catch_entry.temp_var.clone()
                            next_catches.set(catch_entry.type_name.clone(), next_cli)
                        }
                    }
                    // Replace local_catch_labels with only the next catches
                    ctx.local_catch_labels.clear()
                    for type_name: Str in next_catches.keys {
                        mut catch_info := CatchLabelInfo()
                        next_catches.get(type_name, catch_info)?
                        catch (err: KeyNotFoundError) {
                            panic(loc(), "KeyNotFoundError iterating keys: ", err.msg)
                        }
                        mut local_cli := CatchLabelInfo()
                        local_cli.label = catch_info.label.clone()
                        local_cli.temp_var = catch_info.temp_var.clone()
                        ctx.local_catch_labels.set(type_name.clone(), local_cli)
                    }
                    emit_throwing_call_with_goto(maybe_fcall, throw_types, maybe_decl_name, maybe_assign_name, output, effective_indent, ctx, context)?
                    i.inc()
                    continue
                } else {
                    // No catches - typer should have caught this if we're in non-throwing context
                    // Just use propagate (will silently succeed on error if we're not throwing)
                    emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, maybe_assign_name, output, effective_indent, ctx, context)?
                    i.inc()
                    continue
                }
            }
            catch (err: KeyNotFoundError) {
                // Not a function call, continue
            }
        }

        // Check for non-throwing variadic calls in declarations/assignments
        // These need special handling because variadic array must be constructed first
        if maybe_fcall_found {
            mut variadic_fcall_info := VariadicFCallInfo()
            variadic_fcall_info = detect_variadic_fcall(maybe_fcall, ctx)?
            catch (err: KeyNotFoundError) {
                // REM: Not variadic - variadic_fcall_info stays at default
            }
            if not(variadic_fcall_info.elem_type.is_empty()) {
                // Check that this is NOT a throwing function (those are handled above)
                variadic_fd := get_fcall_func_def(context, maybe_fcall)?
                mut is_throwing := not(variadic_fd.throw_types.is_empty())
                catch (err: KeyNotFoundError) {
                    is_throwing = false
                }
                if not(is_throwing) {
                    emit_variadic_call(maybe_fcall, variadic_fcall_info.elem_type, variadic_fcall_info.regular_count, maybe_decl_name, maybe_assign_name, output, effective_indent, ctx, context)?
                    i.inc()
                    continue
                }
            }
        }

        // Regular statement handling
        emit_expr(stmt, output, effective_indent, ctx, context)?
        i.inc()
    }

    // Clean up local_catch_labels for this block
    for catch_entry: CatchLabelInfoEntry in all_catch_info {
        ctx.local_catch_labels.remove(catch_entry.type_name)
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Get the function name from an FCall expression (returns underscore format like Type_method)
/// This returns the name WITHOUT til_ prefix.
/// For C output, use til_name() on the result.
get_fcall_func_name := func(expr: Expr) returns Str throws KeyNotFoundError, Str {
    // get_func_name_string already handles both nested identifiers (Type.method)
    // and precomp'd strings ("Type.method"), returning "Type_method" format
    mut first_param := Expr()
    expr.params.get(0, first_param)?
    catch (err: IndexOutOfBoundsError) {
        throw KeyNotFoundError()
    }
    return get_func_name_string(first_param)?
}

/// Pre-scan function body to collect all catch blocks
/// Returns all catch blocks found in the statements
prescan_func_level_catches := func(stmts: Vec) returns Vec {
    mut catches := Vec.new(Expr)

    // Collect ALL catch blocks - we'll register them all for local throw handling
    // The emit_throwing_call handles immediate catch chains for function calls,
    // but we need labels for throw statements that jump to these catches
    for stmt: Expr in stmts {
        switch stmt.node_type {
        case NodeType.Catch:
            catches.push(stmt)
        case:
        }
    }
    return catches
}

/// Emit a non-throwing variadic function call at statement level
/// Handles constructing the variadic array and cleaning it up after the call
emit_variadic_call := proc(fcall: Expr, elem_type: Str, regular_count: I64, decl_name: Str, assign_name: Str, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Get function name
    func_name := get_fcall_func_name(fcall)?
    catch (err: KeyNotFoundError) {
        throw "emit_variadic_call: could not get function name"
    }

    // Calculate param info for by-ref param handling
    func_def_opt := get_fcall_func_def(context, fcall)?
    catch (err: KeyNotFoundError) {
        // REM: No function definition found
    }

    // Bug #143: Use emit_arg_string for each arg
    // For variadic args (i >= regular_count), use by_ref=false
    mut arg_strings := Vec.new(Str)
    if fcall.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(fcall.params.len()) {
            mut arg := Expr()
            fcall.params.get(arg_idx, arg)?
            is_variadic_arg := i.gteq(regular_count)
            mut param_type := Ptr()
            mut by_ref := false
            if i.lt(func_def_opt.args.len()) {
                mut param_decl := Declaration()
                func_def_opt.args.get(i, param_decl)?
                param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    by_ref = param_needs_by_ref(param_decl)
                }
            }
            arg_str := emit_arg_string(arg, param_type, by_ref, output, indent, ctx, context)?
            arg_strings.push(arg_str)
            i.inc()
            arg_idx.inc()
        }
    }

    // Construct variadic array using pre-computed arg_strings
    mut variadic_arg_strings := Vec.new(Str)
    mut vi := regular_count
    while vi.lt(arg_strings.len()) {
        mut vas := ""
        arg_strings.get(vi, vas)?
        variadic_arg_strings.push(vas)
        vi.inc()
    }
    variadic_arr_var := emit_variadic_array_with_strings(elem_type, variadic_arg_strings, output, indent, ctx)?

    // Determine return type if we need to declare a variable
    mut ret_type := "int"
    if not(decl_name.eq("")).or(not(assign_name.eq(""))) {
        fd2 := get_fcall_func_def(context, fcall)?
        if not(fd2.return_types.is_empty()) {
            mut first_ret := ValueType.TCustom(INFER_TYPE)
            fd2.return_types.get(0, first_ret)?
            ret_type = til_type_to_c(first_ret)?
            catch (err: Str) {
                ret_type = "int"
            }
            catch (err: IndexOutOfBoundsError) {
                ret_type = "int"
            }
        }
        catch (err: KeyNotFoundError) { }
    }

    func_name_c := func_name.replace(".", "_")

    // For declarations: declare the variable (skip for "_" - Bug #35)
    if not(decl_name.eq("")) {
        if decl_name.eq("_") {
            // Bug #35: For underscore, just call the function (discard result)
            output.push_str(indent_str)
            // Emit call inline
            output.push_str(TIL_PREFIX)
            output.push_str(func_name_c)
            output.push_str("(")
            mut ci := 0
            while ci.lt(regular_count) {
                if ci.gt(0) {
                    output.push_str(", ")
                }
                mut arg_str_discard := ""
                arg_strings.get(ci, arg_str_discard)?
                output.push_str(arg_str_discard)
                ci.inc()
            }
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)
            output.push_str(");\n")
        } else {
            output.push_str(indent_str)
            output.push_str(ret_type)
            output.push_str(" ")
            output.push_str(til_name(decl_name))
            output.push_str(" = ")
            // Emit call inline
            output.push_str(TIL_PREFIX)
            output.push_str(func_name_c)
            output.push_str("(")
            mut di := 0
            while di.lt(regular_count) {
                if di.gt(0) {
                    output.push_str(", ")
                }
                mut arg_str_decl := ""
                arg_strings.get(di, arg_str_decl)?
                output.push_str(arg_str_decl)
                di.inc()
            }
            if regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)
            output.push_str(");\n")

            // Add variable to scope
            fd3 := get_fcall_func_def(context, fcall)?
            if not(fd3.return_types.is_empty()) {
                mut first_type := ValueType.TCustom(INFER_TYPE)
                fd3.return_types.get(0, first_type)?
                mut sym_info := SymbolInfo()
                sym_info.value_type = first_type
                sym_info.is_mut = true
                sym_info.is_copy = false
                sym_info.is_own = false
                sym_info.is_comptime_const = false
                context.scope_stack.declare_symbol(decl_name.clone(), sym_info)?
            }
            _ := ctx.declared_vars.insert(til_name(decl_name))
            catch (err: KeyNotFoundError) { }
        }
    } else if not(assign_name.eq("")) {
        // Assignment
        output.push_str(indent_str)
        // Check if assignment target is a field access on a mut param (self.field)
        // If so, emit with -> instead of .
        dot_pos := assign_name.find(".")
        if dot_pos.gteq(0) {
            base := assign_name.get_substr(0, dot_pos)?
            rest := assign_name.get_substr(dot_pos.add(1), assign_name.len())?
            if ctx.current_ref_params.contains(base) {
                // Mut param field access: til_self->field
                output.push_str(til_name(base))
                output.push_str("->")
                output.push_str(rest)
            } else {
                output.push_str(til_name(assign_name))
            }
        } else if ctx.current_ref_params.contains(assign_name) {
            // Direct assignment to mut param: *til_self = value
            output.push_str("*")
            output.push_str(til_name(assign_name))
        } else {
            output.push_str(til_name(assign_name))
        }
        output.push_str(" = ")
        // Emit call inline
        output.push_str(TIL_PREFIX)
        output.push_str(func_name_c)
        output.push_str("(")
        mut ai := 0
        while ai.lt(regular_count) {
            if ai.gt(0) {
                output.push_str(", ")
            }
            mut arg_str_assign := ""
            arg_strings.get(ai, arg_str_assign)?
            output.push_str(arg_str_assign)
            ai.inc()
        }
        if regular_count.gt(0) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
        output.push_str(");\n")
    } else {
        // Standalone variadic call (no return value used)
        output.push_str(indent_str)
        // Emit call inline
        output.push_str(TIL_PREFIX)
        output.push_str(func_name_c)
        output.push_str("(")
        mut si := 0
        while si.lt(regular_count) {
            if si.gt(0) {
                output.push_str(", ")
            }
            mut arg_str_standalone := ""
            arg_strings.get(si, arg_str_standalone)?
            output.push_str(arg_str_standalone)
            si.inc()
        }
        if regular_count.gt(0) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
        output.push_str(");\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Clean up variadic array
    output.push_str(indent_str)
    output.push_str(TIL_PREFIX)
    output.push_str("Array_delete(&")
    output.push_str(variadic_arr_var)
    output.push_str(");\n")
}

/// Emit a call to a throwing function with catch handling
emit_throwing_call := proc(fcall: Expr, throw_types: Vec, catch_blocks: Vec, decl_name: Str, assign_name: Str, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Get function name
    mut func_name := get_fcall_func_name(fcall)?
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    if ctx.nested_func_names.contains_key(func_name) {
        mut mangled_name := ""
        ctx.nested_func_names.get(func_name, mangled_name)?
        func_name = mangled_name
    }

    // Generate unique temp names for this call
    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    // Only if function actually returns something AND we're capturing it
    fd := get_fcall_func_def(context, fcall)?
    mut func_has_return := not(fd.return_types.is_empty())
    mut needs_ret := func_has_return.and(not(decl_name.eq("")).or(not(assign_name.eq(""))))
    catch (err: KeyNotFoundError) {
        func_has_return = false
        needs_ret = false
    }

    // Check if this is a variadic function call
    mut variadic_regular_count := 9999999  // usize::MAX equivalent
    vi := detect_variadic_fcall(fcall, ctx)?
    variadic_regular_count = vi.regular_count
    catch (err: KeyNotFoundError) { }

    // Get function def for param info
    func_def_opt := get_fcall_func_def(context, fcall)?
    catch (err: KeyNotFoundError) {
        // REM: No function def
    }

    // Bug #143: Use emit_arg_string for each arg
    mut arg_strings := Vec.new(Str)
    if fcall.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(fcall.params.len()) {
            mut arg := Expr()
            fcall.params.get(arg_idx, arg)?
            is_variadic_arg := i.gteq(variadic_regular_count)
            mut param_type := Ptr()
            mut by_ref := false
            if i.lt(func_def_opt.args.len()) {
                mut param_decl := Declaration()
                func_def_opt.args.get(i, param_decl)?
                param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    by_ref = param_needs_by_ref(param_decl)
                }
            }
            arg_str := emit_arg_string(arg, param_type, by_ref, output, indent, ctx, context)?
            arg_strings.push(arg_str)
            i.inc()
            arg_idx.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Declare local variables for return value and errors
    mut ret_type := "int"
    if needs_ret {
        fd3 := get_fcall_func_def(context, fcall)?
        if not(fd3.return_types.is_empty()) {
            mut first_ret := ValueType.TCustom(INFER_TYPE)
            fd3.return_types.get(0, first_ret)?
            ret_type = til_type_to_c(first_ret)?
            catch (err: Str) {
                ret_type = "int"
            }
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    // Skip for underscore _ which is just a discard
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" ")
        output.push_str(til_name(decl_name))
        output.push_str(";\n")
        _ := ctx.declared_vars.insert(til_name(decl_name))
        // Add to scope_stack for type resolution
        fd4 := get_fcall_func_def(context, fcall)?
        if not(fd4.return_types.is_empty()) {
            mut first_type := ValueType.TCustom(INFER_TYPE)
            fd4.return_types.get(0, first_type)?
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(decl_name.clone(), sym_info)?
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare error structs for each throw type (Issue #119: skip empty struct errors)
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(idx, throw_type)?
        if is_empty_error_struct(context, throw_type) {
            continue
        }
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(I64.to_str(idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Construct variadic array if needed, using pre-computed arg_strings
    mut has_variadic := false
    mut variadic_arr_var := ""
    mut vi_regular_count := 0
    vi_info := detect_variadic_fcall(fcall, ctx)?
    vi_regular_count = vi_info.regular_count
    mut variadic_arg_strings := Vec.new(Str)
    mut vi_j := vi_regular_count
    while vi_j.lt(arg_strings.len()) {
        mut vi_as := ""
        arg_strings.get(vi_j, vi_as)?
        variadic_arg_strings.push(vi_as)
        vi_j.inc()
    }
    variadic_arr_var = emit_variadic_array_with_strings(vi_info.elem_type, variadic_arg_strings, output, indent, ctx)?
    has_variadic = true
    catch (err: KeyNotFoundError) {
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int __attribute__((unused)) _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer (if function returns something)
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers (Issue #119: skip empty struct errors)
    mut has_emitted_params := needs_ret
    mut err_idx := 0
    while err_idx.lt(throw_types.len()) {
        mut err_throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(err_idx, err_throw_type)?
        if not(is_empty_error_struct(context, err_throw_type)) {
            if has_emitted_params {
                output.push_str(", ")
            }
            output.push_str("&_err")
            output.push_str(I64.to_str(err_idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            has_emitted_params = true
        }
        err_idx.inc()
    }

    // Emit arguments using pre-computed arg_strings
    if has_variadic {
        // Variadic call: emit regular args first, then variadic array pointer
        mut vi_arg_idx := 0
        while vi_arg_idx.lt(vi_regular_count) {
            if has_emitted_params.or(vi_arg_idx.gt(0)) {
                output.push_str(", ")
            }
            mut vi_arg_str := ""
            arg_strings.get(vi_arg_idx, vi_arg_str)?
            output.push_str(vi_arg_str)
            vi_arg_idx.inc()
        }
        // Emit variadic array pointer
        if needs_ret.or(not(throw_types.is_empty())).or(vi_regular_count.gt(0)) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    } else {
        // Non-variadic: emit all args directly
        mut nv_arg_i := 0
        while nv_arg_i.lt(arg_strings.len()) {
            if has_emitted_params.or(nv_arg_i.gt(0)) {
                output.push_str(", ")
            }
            mut nv_arg_str := ""
            arg_strings.get(nv_arg_i, nv_arg_str)?
            output.push_str(nv_arg_str)
            nv_arg_i.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    output.push_str(");\n")

    // Generate if/else chain for error handling
    output.push_str(indent_str)
    output.push_str("if (_status_")
    output.push_str(temp_suffix)
    output.push_str(" == 0) {\n")

    // Success case: assign return value to target variable
    // Skip for underscore _ which is just a discard
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        decl_inner_indent := repeat("    ", indent.add(1))
        output.push_str(decl_inner_indent)
        output.push_str(til_name(decl_name))
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    } else if not(assign_name.eq("")) {
        // Assignment: assign to existing variable
        assign_inner_indent := repeat("    ", indent.add(1))
        output.push_str(assign_inner_indent)
        // Check if assignment target is a field access on a mut param (self.field)
        dot_pos := assign_name.find(".")
        if dot_pos.gteq(0) {
            base := assign_name.get_substr(0, dot_pos)?
            rest := assign_name.get_substr(dot_pos.add(1), assign_name.len())?
            if ctx.current_ref_params.contains(base) {
                // Mut param field access: til_self->field
                output.push_str(til_name(base))
                output.push_str("->")
                output.push_str(rest)
            } else {
                output.push_str(til_name(assign_name))
            }
        } else if ctx.current_ref_params.contains(assign_name) {
            // Direct assignment to mut param: *til_var = value
            output.push_str("*")
            output.push_str(til_name(assign_name))
        } else {
            output.push_str(til_name(assign_name))
        }
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    output.push_str(indent_str)
    output.push_str("}")

    // Generate else-if branches for each catch block
    for catch_block: Expr in catch_blocks {
        if catch_block.params.len().gteq(3) {
            // Get error type name from catch block
            mut err_type_param := Expr()
            catch_block.params.get(1, err_type_param)?
            switch err_type_param.node_type {
            case NodeType.Identifier(err_type_name):
                // Find index of this error type
                mut found_idx := 0
                mut found := false
                for catch_err_idx in 0..throw_types.len() {
                    mut vt := ValueType.TCustom(INFER_TYPE)
                    throw_types.get(catch_err_idx, vt)?
                    switch vt {
                    case ValueType.TCustom(name):
                        if name.eq(err_type_name) {
                            found = true
                            found_idx = catch_err_idx
                            break
                        }
                    case:
                    }
                }

                if found {
                    output.push_str(" else if (_status_")
                    output.push_str(temp_suffix)
                    output.push_str(" == ")
                    output.push_str(I64.to_str(found_idx.add(1)))
                    output.push_str(") {\n")

                    // Bind error variable and add to scope for type resolution
                    mut err_var_param := Expr()
                    catch_block.params.get(0, err_var_param)?
                    switch err_var_param.node_type {
                    case NodeType.Identifier(err_var_name):
                        inner_indent := repeat("    ", indent.add(1))
                        output.push_str(inner_indent)
                        output.push_str(til_name(err_type_name))
                        output.push_str(" ")
                        output.push_str(til_name(err_var_name))
                        // Issue #119: For empty struct errors, use empty initializer since _err var doesn't exist
                        catch_throw_type := ValueType.TCustom(err_type_name.clone())
                        if is_empty_error_struct(context, catch_throw_type) {
                            output.push_str(" = {};\n")
                        } else {
                            output.push_str(" = _err")
                            output.push_str(I64.to_str(found_idx))
                            output.push_str("_")
                            output.push_str(temp_suffix)
                            output.push_str(";\n")
                        }

                        // Add error variable to scope for type resolution in catch body
                        mut catch_sym_info := SymbolInfo()
                        catch_sym_info.value_type = ValueType.TCustom(err_type_name.clone())
                        catch_sym_info.is_mut = false
                        catch_sym_info.is_copy = false
                        catch_sym_info.is_own = false
                        catch_sym_info.is_comptime_const = false
                        context.scope_stack.declare_symbol(err_var_name.clone(), catch_sym_info)?
                    case:
                    }

                    // Emit catch body
                    mut catch_body := Expr()
                    catch_block.params.get(2, catch_body)?
                    emit_expr(catch_body, output, indent.add(1), ctx, context)?

                    output.push_str(indent_str)
                    output.push_str("}")
                }
            case:
            }
        }
    }

    output.push_str("\n")

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Emit a throwing function call that propagates errors to the caller (no catch blocks)
/// This is used when a throwing function calls another throwing function without catching
emit_throwing_call_propagate := proc(fcall: Expr, throw_types: Vec, decl_name: Str, assign_name: Str, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Get function name
    mut func_name := get_fcall_func_name(fcall)?
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call_propagate: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    if ctx.nested_func_names.contains_key(func_name) {
        mut mangled_name := ""
        ctx.nested_func_names.get(func_name, mangled_name)?
        func_name = mangled_name
    }

    // Generate unique temp names for this call
    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    // Only if function actually returns something AND we're capturing it
    func_def_opt := get_fcall_func_def(context, fcall)?
    mut have_func_def := true
    mut func_has_return := not(func_def_opt.return_types.is_empty())
    mut needs_ret := func_has_return.and(not(decl_name.eq("")).or(not(assign_name.eq(""))))
    catch (err: KeyNotFoundError) {
        have_func_def = false
        func_has_return = false
        needs_ret = false
    }

    // Check if this is a variadic function call
    mut prop_variadic_regular_count := 9999999  // usize::MAX equivalent
    prop_vi := detect_variadic_fcall(fcall, ctx)?
    prop_variadic_regular_count = prop_vi.regular_count
    catch (err: KeyNotFoundError) { }

    // Bug #143: Use emit_arg_string for each arg
    mut arg_strings := Vec.new(Str)
    if fcall.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(fcall.params.len()) {
            mut arg := Expr()
            fcall.params.get(arg_idx, arg)?
            is_variadic_arg := i.gteq(prop_variadic_regular_count)
            mut param_type := Ptr()
            mut by_ref := false
            if have_func_def.and(i.lt(func_def_opt.args.len())) {
                mut param_decl := Declaration()
                func_def_opt.args.get(i, param_decl)?
                param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    by_ref = param_needs_by_ref(param_decl)
                }
            }
            arg_str := emit_arg_string(arg, param_type, by_ref, output, indent, ctx, context)?
            arg_strings.push(arg_str)
            i.inc()
            arg_idx.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Look up the actual return type
    mut ret_type := "int"
    if needs_ret {
        fd3 := get_fcall_func_def(context, fcall)?
        if not(fd3.return_types.is_empty()) {
            mut first_ret := ValueType.TCustom("")
            fd3.return_types.get(0, first_ret)?
            ret_type = til_type_to_c(first_ret)?
            catch (err: Str) { ret_type = "int" }
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare temp for return value if needed
    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" ")
        output.push_str(til_name(decl_name))
        output.push_str(";\n")
        _ := ctx.declared_vars.insert(til_name(decl_name))
        fd4 := get_fcall_func_def(context, fcall)?
        if not(fd4.return_types.is_empty()) {
            mut first_type := ValueType.TCustom("")
            fd4.return_types.get(0, first_type)?
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(decl_name.clone(), sym_info)?
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare error structs for each throw type of the called function (Issue #119: skip empty struct errors)
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(idx, throw_type)?
        if is_empty_error_struct(context, throw_type) {
            continue
        }
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(I64.to_str(idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Construct variadic array if needed, using pre-computed arg_strings
    mut variadic_arr_var := ""
    mut has_variadic := false
    mut prop_vi_regular_count := 0
    prop_vi2 := detect_variadic_fcall(fcall, ctx)?
    has_variadic = true
    prop_vi_regular_count = prop_vi2.regular_count
    mut variadic_arg_strings := Vec.new(Str)
    mut va_j := prop_vi_regular_count
    while va_j.lt(arg_strings.len()) {
        mut va_s := ""
        arg_strings.get(va_j, va_s)?
        variadic_arg_strings.push(va_s)
        va_j.inc()
    }
    variadic_arr_var = emit_variadic_array_with_strings(prop_vi2.elem_type, variadic_arg_strings, output, indent, ctx)?
    catch (err: KeyNotFoundError) {
        // REM: Not variadic
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int __attribute__((unused)) _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers (Issue #119: skip empty struct errors)
    mut has_emitted_params := needs_ret
    mut err_idx := 0
    while err_idx.lt(throw_types.len()) {
        mut err_throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(err_idx, err_throw_type)?
        if not(is_empty_error_struct(context, err_throw_type)) {
            if has_emitted_params {
                output.push_str(", ")
            }
            output.push_str("&_err")
            output.push_str(I64.to_str(err_idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            has_emitted_params = true
        }
        err_idx.inc()
    }

    // Emit arguments using pre-computed arg_strings
    if has_variadic {
        mut var_arg_i := 0
        while var_arg_i.lt(prop_vi_regular_count) {
            if has_emitted_params.or(var_arg_i.gt(0)) {
                output.push_str(", ")
            }
            mut var_arg_str := ""
            arg_strings.get(var_arg_i, var_arg_str)?
            output.push_str(var_arg_str)
            var_arg_i.inc()
        }
        if has_emitted_params.or(prop_vi_regular_count.gt(0)) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    } else {
        // Non-variadic: emit all args directly
        mut nv_arg_i := 0
        while nv_arg_i.lt(arg_strings.len()) {
            if has_emitted_params.or(nv_arg_i.gt(0)) {
                output.push_str(", ")
            }
            mut nv_arg_str := ""
            arg_strings.get(nv_arg_i, nv_arg_str)?
            output.push_str(nv_arg_str)
            nv_arg_i.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    output.push_str(");\n")

    // Generate error propagation: if status != 0, copy error to caller's error param and return
    for called_idx in 0..throw_types.len() {
        mut called_throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(called_idx, called_throw_type)?
        switch called_throw_type {
        case ValueType.TCustom(called_type_name):
            // Find matching error type in current function's throw types
            mut current_idx := 0
            mut found := false
            for cur_throw_idx in 0..ctx.current_throw_types.len() {
                mut cur_vt := ValueType.TCustom(INFER_TYPE)
                ctx.current_throw_types.get(cur_throw_idx, cur_vt)?
                switch cur_vt {
                case ValueType.TCustom(cur_name):
                    if cur_name.eq(called_type_name) {
                        found = true
                        current_idx = cur_throw_idx
                        break
                    }
                case:
                }
            }
            if found {
                // Issue #119: For empty struct errors, don't copy - just return status
                is_empty := is_empty_error_struct(context, called_throw_type)
                output.push_str(indent_str)
                output.push_str("if (_status_")
                output.push_str(temp_suffix)
                output.push_str(" == ")
                output.push_str(I64.to_str(called_idx.add(1)))
                output.push_str(") { ")
                if not(is_empty) {
                    output.push_str("*_err")
                    output.push_str(I64.to_str(current_idx.add(1)))
                    output.push_str(" = _err")
                    output.push_str(I64.to_str(called_idx))
                    output.push_str("_")
                    output.push_str(temp_suffix)
                    output.push_str("; ")
                }
                output.push_str("return ")
                output.push_str(I64.to_str(current_idx.add(1)))
                output.push_str("; }\n")
            }
        case:
        }
    }

    // Success case: assign return value to target variable if needed
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        output.push_str(indent_str)
        output.push_str(til_name(decl_name))
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    } else if not(assign_name.eq("")) {
        output.push_str(indent_str)
        dot_pos := assign_name.find(".")
        if dot_pos.gteq(0) {
            base := assign_name.get_substr(0, dot_pos)?
            rest := assign_name.get_substr(dot_pos.add(1), assign_name.len())?
            if ctx.current_ref_params.contains(base) {
                output.push_str(til_name(base))
                output.push_str("->")
                output.push_str(rest)
            } else {
                output.push_str(til_name(assign_name))
            }
        } else if ctx.current_ref_params.contains(assign_name) {
            output.push_str("*")
            output.push_str(til_name(assign_name))
        } else {
            output.push_str(til_name(assign_name))
        }
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

/// Emit a throwing function call that uses goto for error handling
/// Used when there are outer catch blocks registered in ctx.local_catch_labels
emit_throwing_call_with_goto := proc(fcall: Expr, throw_types: Vec, decl_name: Str, assign_name: Str, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Get function name
    mut func_name := get_fcall_func_name(fcall)?
    catch (err: KeyNotFoundError) {
        throw "emit_throwing_call_with_goto: could not get function name"
    }

    // Check if this is a call to a nested (hoisted) function - use mangled name
    if ctx.nested_func_names.contains_key(func_name) {
        mut mangled_name := ""
        ctx.nested_func_names.get(func_name, mangled_name)?
        func_name = mangled_name
    }

    // Generate unique temp names for this call
    temp_suffix := next_mangled(ctx)

    // Determine if we need a return value temp variable
    // Only if function actually returns something AND we're capturing it
    func_def_opt := get_fcall_func_def(context, fcall)?
    mut have_func_def := true
    mut func_has_return := not(func_def_opt.return_types.is_empty())
    mut needs_ret := func_has_return.and(not(decl_name.eq("")).or(not(assign_name.eq(""))))
    catch (err: KeyNotFoundError) {
        have_func_def = false
        func_has_return = false
        needs_ret = false
    }

    // Check if this is a variadic function call
    mut goto_variadic_regular_count := 9999999
    goto_vi := detect_variadic_fcall(fcall, ctx)?
    goto_variadic_regular_count = goto_vi.regular_count
    catch (err: KeyNotFoundError) { }

    // Bug #143: Use emit_arg_string for each arg
    mut arg_strings := Vec.new(Str)
    if fcall.params.len().gt(1) {
        mut i := 0
        mut arg_idx := 1
        while arg_idx.lt(fcall.params.len()) {
            mut arg := Expr()
            fcall.params.get(arg_idx, arg)?
            is_variadic_arg := i.gteq(goto_variadic_regular_count)
            mut param_type := Ptr()
            mut by_ref := false
            if have_func_def.and(i.lt(func_def_opt.args.len())) {
                mut param_decl := Declaration()
                func_def_opt.args.get(i, param_decl)?
                param_type.data = to_ptr(param_decl.value_type)
                if not(is_variadic_arg) {
                    by_ref = param_needs_by_ref(param_decl)
                }
            }
            arg_str := emit_arg_string(arg, param_type, by_ref, output, indent, ctx, context)?
            arg_strings.push(arg_str)
            i.inc()
            arg_idx.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Look up the actual return type
    mut ret_type := "int"
    if needs_ret {
        fd3 := get_fcall_func_def(context, fcall)?
        if not(fd3.return_types.is_empty()) {
            mut first_ret := ValueType.TCustom("")
            fd3.return_types.get(0, first_ret)?
            ret_type = til_type_to_c(first_ret)?
            catch (err: Str) { ret_type = "int" }
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare temp for return value if needed
    if needs_ret {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        output.push_str(indent_str)
        output.push_str(ret_type)
        output.push_str(" ")
        output.push_str(til_name(decl_name))
        output.push_str(";\n")
        _ := ctx.declared_vars.insert(til_name(decl_name))
        fd4 := get_fcall_func_def(context, fcall)?
        if not(fd4.return_types.is_empty()) {
            mut first_type := ValueType.TCustom("")
            fd4.return_types.get(0, first_type)?
            mut sym_info := SymbolInfo()
            sym_info.value_type = first_type
            sym_info.is_mut = true
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(decl_name.clone(), sym_info)?
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare error structs for each throw type of the called function (Issue #119: skip empty struct errors)
    for idx in 0..throw_types.len() {
        mut throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(idx, throw_type)?
        if is_empty_error_struct(context, throw_type) {
            continue
        }
        switch throw_type {
        case ValueType.TCustom(type_name):
            output.push_str(indent_str)
            output.push_str(til_name(type_name))
            output.push_str(" _err")
            output.push_str(I64.to_str(idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            output.push_str(" = {};\n")
        case:
        }
    }

    // Construct variadic array if needed, using pre-computed arg_strings
    mut variadic_arr_var := ""
    mut has_variadic := false
    mut goto_vi_regular_count := 0
    goto_vi2 := detect_variadic_fcall(fcall, ctx)?
    has_variadic = true
    goto_vi_regular_count = goto_vi2.regular_count
    mut variadic_arg_strings := Vec.new(Str)
    mut va_j := goto_vi_regular_count
    while va_j.lt(arg_strings.len()) {
        mut va_s := ""
        arg_strings.get(va_j, va_s)?
        variadic_arg_strings.push(va_s)
        va_j.inc()
    }
    variadic_arr_var = emit_variadic_array_with_strings(goto_vi2.elem_type, variadic_arg_strings, output, indent, ctx)?
    catch (err: KeyNotFoundError) {
        // REM: Not variadic
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    output.push_str(indent_str)
    output.push_str("int __attribute__((unused)) _status_")
    output.push_str(temp_suffix)
    output.push_str(" = ")
    output.push_str(til_func_name(func_name))
    output.push_str("(")

    // First: return value pointer
    if needs_ret {
        output.push_str("&_ret_")
        output.push_str(temp_suffix)
    }

    // Then: error pointers (Issue #119: skip empty struct errors)
    mut has_emitted_params := needs_ret
    mut err_idx := 0
    while err_idx.lt(throw_types.len()) {
        mut err_throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(err_idx, err_throw_type)?
        if not(is_empty_error_struct(context, err_throw_type)) {
            if has_emitted_params {
                output.push_str(", ")
            }
            output.push_str("&_err")
            output.push_str(I64.to_str(err_idx))
            output.push_str("_")
            output.push_str(temp_suffix)
            has_emitted_params = true
        }
        err_idx.inc()
    }

    // Emit arguments using pre-computed arg_strings
    if has_variadic {
        mut var_arg_i := 0
        while var_arg_i.lt(goto_vi_regular_count) {
            if has_emitted_params.or(var_arg_i.gt(0)) {
                output.push_str(", ")
            }
            mut var_arg_str := ""
            arg_strings.get(var_arg_i, var_arg_str)?
            output.push_str(var_arg_str)
            var_arg_i.inc()
        }
        if has_emitted_params.or(goto_vi_regular_count.gt(0)) {
            output.push_str(", ")
        }
        output.push_str("&")
        output.push_str(variadic_arr_var)
    } else {
        // Non-variadic: emit all args directly
        mut nv_arg_i := 0
        while nv_arg_i.lt(arg_strings.len()) {
            if has_emitted_params.or(nv_arg_i.gt(0)) {
                output.push_str(", ")
            }
            mut nv_arg_str := ""
            arg_strings.get(nv_arg_i, nv_arg_str)?
            output.push_str(nv_arg_str)
            nv_arg_i.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    output.push_str(");\n")

    // Bug #39 fix: Use simple status checks with goto, not if-block nesting
    for goto_err_idx in 0..throw_types.len() {
        mut goto_throw_type := ValueType.TCustom(INFER_TYPE)
        throw_types.get(goto_err_idx, goto_throw_type)?
        switch goto_throw_type {
        case ValueType.TCustom(type_name):
            // Check if there's a local catch for this error type
            mut catch_info := CatchLabelInfo()
            ctx.local_catch_labels.get(type_name, catch_info)?
            // Jump to local catch: copy error to temp var, then goto label
            output.push_str(indent_str)
            output.push_str("if (_status_")
            output.push_str(temp_suffix)
            output.push_str(" == ")
            output.push_str(I64.to_str(goto_err_idx.add(1)))
            output.push_str(") { ")
            // Issue #119: Skip copy for empty struct errors
            if not(is_empty_error_struct(context, goto_throw_type)) {
                output.push_str(catch_info.temp_var)
                output.push_str(" = _err")
                output.push_str(I64.to_str(goto_err_idx))
                output.push_str("_")
                output.push_str(temp_suffix)
                output.push_str("; ")
            }
            output.push_str("goto ")
            output.push_str(catch_info.label)
            output.push_str("; }\n")
            catch (err: KeyNotFoundError) {
                // Check if this error type is in current_throw_types (propagate to caller)
                mut prop_idx := 0
                mut found_prop := false
                for prop_i in 0..ctx.current_throw_types.len() {
                    mut prop_vt := ValueType.TCustom(INFER_TYPE)
                    ctx.current_throw_types.get(prop_i, prop_vt)?
                    switch prop_vt {
                    case ValueType.TCustom(n):
                        if n.eq(type_name) {
                            found_prop = true
                            prop_idx = prop_i
                            break
                        }
                    case:
                    }
                }
                if found_prop {
                    output.push_str(indent_str)
                    output.push_str("if (_status_")
                    output.push_str(temp_suffix)
                    output.push_str(" == ")
                    output.push_str(I64.to_str(goto_err_idx.add(1)))
                    output.push_str(") { ")
                    // Issue #119: Skip copy for empty struct errors
                    if not(is_empty_error_struct(context, goto_throw_type)) {
                        output.push_str("*_err")
                        output.push_str(I64.to_str(prop_idx.add(1)))
                        output.push_str(" = _err")
                        output.push_str(I64.to_str(goto_err_idx))
                        output.push_str("_")
                        output.push_str(temp_suffix)
                        output.push_str("; ")
                    }
                    output.push_str("return ")
                    output.push_str(I64.to_str(prop_idx.add(1)))
                    output.push_str("; }\n")
                }
            }
        case:
        }
    }

    // Success case: assign return value to target variable if needed
    if not(decl_name.eq("")).and(not(decl_name.eq("_"))) {
        output.push_str(indent_str)
        output.push_str(til_name(decl_name))
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    } else if not(assign_name.eq("")) {
        output.push_str(indent_str)
        dot_pos := assign_name.find(".")
        if dot_pos.gteq(0) {
            base := assign_name.get_substr(0, dot_pos)?
            rest := assign_name.get_substr(dot_pos.add(1), assign_name.len())?
            if ctx.current_ref_params.contains(base) {
                output.push_str(til_name(base))
                output.push_str("->")
                output.push_str(rest)
            } else {
                output.push_str(til_name(assign_name))
            }
        } else if ctx.current_ref_params.contains(assign_name) {
            output.push_str("*")
            output.push_str(til_name(assign_name))
        } else {
            output.push_str(til_name(assign_name))
        }
        output.push_str(" = _ret_")
        output.push_str(temp_suffix)
        output.push_str(";\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_declaration := proc(decl: Declaration, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Skip inline ext_func/ext_proc declarations - they're just declaring external functions exist
    if not(expr.params.is_empty()) {
        mut first_param := Expr()
        expr.params.get(0, first_param)?
        switch first_param.node_type {
        case NodeType.FuncDef(func_def):
            if func_def.is_ext() {
                return
            }

            // Handle nested function declarations - hoist to top level with mangled name
            if not(ctx.current_function_name.is_empty()) {
                parent_name := ctx.current_function_name.clone()
                mut mangled_name := parent_name.clone()
                mangled_name.push_str("_")
                mangled_name.push_str(decl.name)

                // Register the name mapping so function calls can find it
                ctx.nested_func_names.set(decl.name.clone(), mangled_name.clone())

                // Register function definition so get_value_type can resolve return types
                context.scope_stack.declare_func(decl.name.clone(), func_def.clone())?

                // Generate the hoisted function prototype
                mut proto_output := ""
                emit_func_signature(til_name(mangled_name), func_def, context, proto_output)?
                proto_output.push_str(";\n")
                ctx.hoisted_prototypes.push(proto_output)

                // Generate the hoisted function definition
                mut func_output := ""

                // Save and set context for nested function
                prev_throw_types := ctx.current_throw_types.clone()
                prev_return_types := ctx.current_return_types.clone()
                prev_declared_vars := ctx.declared_vars.clone()
                prev_mut_params := ctx.current_ref_params.clone()
                prev_variadic_params := ctx.current_variadic_params.clone()
                prev_function_name := ctx.current_function_name.clone()
                prev_mangling_counter := ctx.mangling_counter

                ctx.current_throw_types = func_def.throw_types.clone()
                ctx.current_return_types = func_def.return_types.clone()
                ctx.current_function_name = mangled_name.clone()
                ctx.mangling_counter = 0  // Reset counter per-function for determinism

                // Bug #60: Track ref and variadic params - all non-copy args are by pointer
                for func_def_arg: Declaration in func_def.args {
                    if not(func_def_arg.is_copy) {
                        _ := ctx.current_ref_params.insert(func_def_arg.name.clone())
                    }
                    switch func_def_arg.value_type {
                    case ValueType.TMulti(elem_type):
                        ctx.current_variadic_params.set(func_def_arg.name.clone(), til_name(elem_type))
                    case:
                        // REM: not variadic
                    }
                }

                // Push scope frame for function
                mut function_frame := ScopeFrame()
                function_frame.scope_type = ScopeType.Function
                for func_def_arg: Declaration in func_def.args {
                    mut value_type := func_def_arg.value_type
                    switch func_def_arg.value_type {
                    case ValueType.TMulti(_):
                        value_type = ValueType.TCustom("Array")
                    case:
                        // REM: keep original type
                    }
                    mut nested_symbol_info := SymbolInfo()
                    nested_symbol_info.value_type = value_type
                    nested_symbol_info.is_mut = func_def_arg.is_mut
                    nested_symbol_info.is_copy = func_def_arg.is_copy
                    nested_symbol_info.is_own = func_def_arg.is_own
                    nested_symbol_info.is_comptime_const = false
                    function_frame.symbols.set(func_def_arg.name.clone(), nested_symbol_info)
                }
                context.scope_stack.frames.push(function_frame)

                // Emit the function
                emit_func_signature(til_name(mangled_name), func_def, context, func_output)?
                func_output.push_str(" {\n")
                emit_stmts(func_def.body, func_output, 1, ctx, context)?
                // Add implicit return at end to silence gcc -Wreturn-type warnings
                if not(func_def.throw_types.is_empty()) {
                    func_output.push_str("    return 0;\n")
                } else if not(func_def.return_types.is_empty()) {
                    mut ret_type_vt := ValueType.TCustom("")
                    func_def.return_types.get(0, ret_type_vt)?
                    ret_type := til_type_to_c(ret_type_vt)?
                    func_output.push_str("    return (")
                    func_output.push_str(ret_type)
                    func_output.push_str("){0};\n")
                }
                func_output.push_str("}\n\n")

                // Pop scope frame
                mut _popped_frame := ScopeFrame()
                context.scope_stack.frames.pop(_popped_frame)?

                // Restore context
                ctx.current_throw_types = prev_throw_types
                ctx.current_return_types = prev_return_types
                ctx.declared_vars = prev_declared_vars
                ctx.current_ref_params = prev_mut_params
                ctx.current_variadic_params = prev_variadic_params
                ctx.current_function_name = prev_function_name
                ctx.mangling_counter = prev_mangling_counter

                ctx.hoisted_functions.push(func_output)

                // Don't emit anything at the declaration site - the function is hoisted
                return
            }
        case:
            // REM: not a FuncDef
        }
    }

    indent_str := repeat("    ", indent)

    // Bug #143: Process RHS FCall with emit_arg_string
    // This handles builtins (to_ptr, size_of, etc.), throwing calls, by-ref params, and Dynamic params properly
    mut rhs_string := ""
    mut has_rhs_string := false
    if not(expr.params.is_empty()) {
        mut rhs := Expr()
        expr.params.get(0, rhs)?
        switch rhs.node_type {
        case NodeType.FCall(_):
            rhs_string = emit_arg_string(rhs, Ptr(), false, output, indent, ctx, context)?
            has_rhs_string = true
        case:
        }
    }

    // Bug #35: For underscore declarations, just emit the expression (discard result)
    // This avoids C redeclaration errors and matches the semantics of discarding
    if decl.name.eq("_") {
        if not(expr.params.is_empty()) {
            output.push_str(indent_str)
            // FCall at statement level (indent > 0) adds ";\n" itself
            // Other expressions need semicolon added explicitly
            mut discard_first_param := Expr()
            expr.params.get(0, discard_first_param)?
            switch discard_first_param.node_type {
            case NodeType.FCall(_):
                emit_expr(discard_first_param, output, indent, ctx, context)?
            case:
                emit_expr(discard_first_param, output, 0, ctx, context)?
                output.push_str(";\n")
            }
        }
        return
    }

    name := decl.name.clone()
    is_mut := decl.is_mut

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    mut has_struct_type := false
    if not(expr.params.is_empty()) {
        mut struct_first_param := Expr()
        expr.params.get(0, struct_first_param)?
        struct_type = get_struct_construction_type(struct_first_param, context)
        if not(struct_type.is_empty()) {
            has_struct_type = true
        }
    }

    // Check if this is an enum construction (Type.Variant or Type.Variant(value))
    mut enum_type := ""
    mut has_enum_type := false
    if not(expr.params.is_empty()) {
        mut enum_first_param := Expr()
        expr.params.get(0, enum_first_param)?
        enum_type = get_enum_construction_type(enum_first_param, context)?
        if not(enum_type.is_empty()) {
            has_enum_type = true
        }
    }

    // Track variable type for method mangling
    // Prioritize struct/enum constructor types, then use get_value_type for other cases
    mut var_type := decl.value_type
    if has_struct_type {
        var_type = ValueType.TCustom(struct_type.clone())
    } else if has_enum_type {
        var_type = ValueType.TCustom(enum_type.clone())
    } else if not(expr.params.is_empty()) {
        mut type_first_param := Expr()
        expr.params.get(0, type_first_param)?
        var_type = get_value_type(context, type_first_param)?
        catch (err: Str) {
            var_type = decl.value_type
        }
    }
    // Add to scope_stack so get_value_type can find it
    mut decl_symbol_info := SymbolInfo()
    decl_symbol_info.value_type = var_type
    decl_symbol_info.is_mut = decl.is_mut
    decl_symbol_info.is_copy = false
    decl_symbol_info.is_own = false
    decl_symbol_info.is_comptime_const = false
    context.scope_stack.declare_symbol(name.clone(), decl_symbol_info)?

    // Check if variable already declared in this function (avoid C redefinition errors)
    // Use til_name() since that's what hoisting code uses when inserting into declared_vars
    already_declared := ctx.declared_vars.contains(til_name(name))

    if has_struct_type {
        // Struct variable declaration with values (defaults or named args)

        // Build map of named arg values from struct literal
        mut named_values := Map.new(Str, Expr)
        if not(expr.params.is_empty()) {
            mut named_first_param := Expr()
            expr.params.get(0, named_first_param)?
            mut arg_idx := 1
            while arg_idx.lt(named_first_param.params.len()) {
                mut named_arg := Expr()
                named_first_param.params.get(arg_idx, named_arg)?
                switch named_arg.node_type {
                case NodeType.NamedArg(field_name):
                    if not(named_arg.params.is_empty()) {
                        mut named_value_expr := Expr()
                        named_arg.params.get(0, named_value_expr)?
                        named_values.set(field_name.clone(), named_value_expr.clone())
                    }
                case:
                    // REM: not a named arg
                }
                arg_idx.inc()
            }
        }

        // Look up struct definition to get default values
        // Clone to avoid borrow issues with emit_expr
        struct_def := context.scope_stack.lookup_struct(struct_type)?
        if struct_def.members.is_empty() {
            // Empty struct - use empty initializer
            output.push_str(indent_str)
            if not(already_declared) {
                if not(is_mut) {
                    output.push_str("const ")
                }
                output.push_str(til_name(struct_type))
                output.push_str(" ")
                _ := ctx.declared_vars.insert(til_name(name))
            }
            output.push_str(til_name(name))
            emit_struct_literal_assign(output, struct_type, already_declared, "{}")
        } else if struct_def.default_values.is_empty().and(named_values.is_empty()) {
            // No defaults and no named args - zero initialize
            output.push_str(indent_str)
            if not(already_declared) {
                if not(is_mut) {
                    output.push_str("const ")
                }
                output.push_str(til_name(struct_type))
                output.push_str(" ")
                _ := ctx.declared_vars.insert(til_name(name))
            }
            output.push_str(til_name(name))
            emit_struct_literal_assign(output, struct_type, already_declared, "{0}")
        } else {
            // Has default values or named args - emit designated initializer
            // Bug #143: emit_arg_string handles throwing/variadic calls inline

            output.push_str(indent_str)
            if not(already_declared) {
                if not(is_mut) {
                    output.push_str("const ")
                }
                output.push_str(til_name(struct_type))
                output.push_str(" ")
                _ := ctx.declared_vars.insert(til_name(name))
            }
            output.push_str(til_name(name))
            emit_struct_literal_start(output, struct_type, already_declared)
            output.push_str("{")
            mut first := true
            for member: Declaration in struct_def.members {
                // Only include mut fields (actual struct data members)
                // Skip functions, constants, and non-mut fields
                if not(member.is_mut) {
                    continue
                }
                if not(first) {
                    output.push_str(", ")
                }
                first = false
                output.push_str(".")
                output.push_str(member.name)
                output.push_str(" = ")
                // Use named arg value if provided, otherwise use default
                // Bug #143: Use emit_arg_string to handle throwing/variadic calls
                if named_values.contains_key(member.name) {
                    mut value_expr := Expr()
                    named_values.get(member.name, value_expr)?
                    mut member_type_ptr := Ptr()
                    member_type_ptr.data = to_ptr(member.value_type)
                    value_str := emit_arg_string(value_expr, member_type_ptr, false, output, indent, ctx, context)?
                    output.push_str(value_str)
                } else {
                    mut member_default_expr := Expr()
                    struct_def.default_values.get(member.name, member_default_expr)?
                    mut default_member_type_ptr := Ptr()
                    default_member_type_ptr.data = to_ptr(member.value_type)
                    default_str := emit_arg_string(member_default_expr, default_member_type_ptr, false, output, indent, ctx, context)?
                    output.push_str(default_str)
                    catch (err: KeyNotFoundError) {
                        // No default - use zero
                        output.push_str("0")
                    }
                }
            }
            output.push_str("};\n")
        }

        catch (err: KeyNotFoundError) {
            // Struct not found - fall back to zero init
            output.push_str(indent_str)
            if not(already_declared) {
                if not(is_mut) {
                    output.push_str("const ")
                }
                output.push_str(til_name(struct_type))
                output.push_str(" ")
                _ := ctx.declared_vars.insert(til_name(name))
            }
            output.push_str(til_name(name))
            emit_struct_literal_assign(output, struct_type, already_declared, "{0}")
        }
    } else if has_enum_type {
        // Enum variable declaration
        output.push_str(indent_str)
        if not(already_declared) {
            if not(is_mut) {
                output.push_str("const ")
            }
            output.push_str(til_name(enum_type))
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        output.push_str(" = ")
        mut enum_emit_first_param := Expr()
        expr.params.get(0, enum_emit_first_param)?
        emit_expr(enum_emit_first_param, output, 0, ctx, context)?
        output.push_str(";\n")
    } else if is_mut {
        // Bug #143: emit_fcall handles hoisting via emit_arg_string
        output.push_str(indent_str)
        if not(already_declared) {
            // INFER_TYPE should have been resolved by typer
            switch decl.value_type {
            case ValueType.TCustom(s):
                if s.eq(INFER_TYPE) {
                    throw expr.lang_error(context.path, "ccodegen", format("Declaration '", decl.name, "' has INFER_TYPE - should have been resolved by typer"))
                }
            case:
            }
            c_type := til_type_to_c(decl.value_type)?
            catch (err: Str) {
                throw expr.lang_error(context.path, "ccodegen", err)
            }
            output.push_str(c_type)
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        if not(expr.params.is_empty()) {
            output.push_str(" = ")
            // Bug #143: Use rhs_string if available (already hoisted args)
            if has_rhs_string {
                output.push_str(rhs_string)
            } else {
                mut mut_emit_first_param := Expr()
                expr.params.get(0, mut_emit_first_param)?
                emit_expr(mut_emit_first_param, output, 0, ctx, context)?
            }
        }
        output.push_str(";\n")
    } else {
        // const declaration - Bug #143: Use rhs_string if available (already hoisted args)
        output.push_str(indent_str)
        if not(already_declared) {
            // INFER_TYPE should have been resolved by typer
            switch decl.value_type {
            case ValueType.TCustom(s):
                if s.eq(INFER_TYPE) {
                    throw expr.lang_error(context.path, "ccodegen", format("Declaration '", decl.name, "' has INFER_TYPE - should have been resolved by typer"))
                }
            case:
            }
            const_c_type := til_type_to_c(decl.value_type)?
            catch (err: Str) {
                throw expr.lang_error(context.path, "ccodegen", err)
            }
            output.push_str("const ")
            output.push_str(const_c_type)
            output.push_str(" ")
            _ := ctx.declared_vars.insert(til_name(name))
        }
        output.push_str(til_name(name))
        if not(expr.params.is_empty()) {
            output.push_str(" = ")
            // Bug #143: Use rhs_string if available (already hoisted args)
            if has_rhs_string {
                output.push_str(rhs_string)
            } else {
                mut const_emit_first_param := Expr()
                expr.params.get(0, const_emit_first_param)?
                emit_expr(const_emit_first_param, output, 0, ctx, context)?
            }
        }
        output.push_str(";\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Check if an expression is a struct construction call (TypeName() or TypeName(x=1, y=2))
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr, context: Context) returns Str {
    switch expr.node_type {
    case NodeType.FCall(_):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.Identifier(name):
                // Use lookup_struct to check if this is a known struct type
                if first_param.params.is_empty() {
                    _ := context.scope_stack.lookup_struct(name)?
                    catch (err: KeyNotFoundError) {
                        return ""
                    }
                    mut only_named_args := expr.params.len().eq(1)
                    if not(only_named_args) {
                        only_named_args = true
                        mut i := 1
                        while i.lt(expr.params.len()) {
                            mut arg := Expr()
                            expr.params.get(i, arg)?
                            switch arg.node_type {
                            case NodeType.NamedArg(_):
                                // ok
                            case:
                                only_named_args = false
                            }
                            i.inc()
                        }
                    }
                    if only_named_args {
                        return name.clone()
                    }
                }
            case:
            }
        }
    case:
    }
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    return ""
}

// Check if an expression is an enum construction (Type.Variant or Type.Variant(value))
// Returns the type name if it is, empty string otherwise
// AST structure for Color.Red(42): FCall -> [Identifier("Color") -> [Identifier("Red")], Literal(42)]
// AST structure for Color.Unknown: Identifier("Color") -> [Identifier("Unknown")]
get_enum_construction_type := func(expr: Expr, context: Context) returns Str throws Str {
    // Check FCall case: Type.Variant(value) or Type.Variant()
    switch expr.node_type {
    case NodeType.FCall(_):
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.Identifier(type_name):
                // Use lookup_enum to check if this is a known enum type
                mut enum_def := SEnumDef()
                mut enum_def_found := false
                enum_def = context.scope_stack.lookup_enum(type_name)?
                enum_def_found = true
                catch (err: KeyNotFoundError) {
                    // REM: Not an enum - continue to check Identifier case below
                }
                if enum_def_found {
                    // Check if there's a nested identifier (the variant)
                    if not(first_param.params.is_empty()) {
                        mut variant_param := Expr()
                        first_param.params.get(0, variant_param)?
                        switch variant_param.node_type {
                        case NodeType.Identifier(variant_name):
                            // Verify the variant exists in the enum
                            if enum_def.contains_key(variant_name)? {
                                return type_name.clone()
                            }
                        case:
                        }
                    }
                }
            case:
            }
        }
    case NodeType.Identifier(type_name):
        // Check Identifier case: Type.Variant (no parentheses, no payload)
        // Use lookup_enum to check if this is a known enum type
        ident_enum_def := context.scope_stack.lookup_enum(type_name)?
        catch (err: KeyNotFoundError) {
            return ""
        }
        if not(expr.params.is_empty()) {
            mut ident_variant_param := Expr()
            expr.params.get(0, ident_variant_param)?
            switch ident_variant_param.node_type {
            case NodeType.Identifier(variant_name):
                // Verify the variant exists in the enum
                if ident_enum_def.contains_key(variant_name)? {
                    return type_name.clone()
                }
            case:
            }
        }
    case:
    }
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    return ""
}

emit_funcdef := proc(_func_def: SFuncDef, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // For now, just inline the function body (we're inside main anyway)
    // TODO: proper function generation with prototypes
    indent_str := repeat("    ", indent)
    output.push_str(indent_str)
    output.push_str("{\n")
    for stmt: Expr in expr.params {
        emit_expr(stmt, output, indent.add(1), ctx, context)?
    }
    output.push_str(indent_str)
    output.push_str("}\n")
}

emit_assignment := proc(name: Str, expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)

    // Bug #143: Use emit_arg_string to handle RHS hoisting
    mut rhs_str := ""
    mut has_rhs := false
    if not(expr.params.is_empty()) {
        mut rhs_expr := Expr()
        expr.params.get(0, rhs_expr)?

        // Check if RHS is a call to a throwing function
        switch rhs_expr.node_type {
        case NodeType.FCall(_):
            mut fd := SFuncDef()
            mut fd_found := true
            fd = get_fcall_func_def(context, rhs_expr)?
            catch (err: KeyNotFoundError) {
                fd_found = false
            }
            if fd_found {
            if not(fd.throw_types.is_empty()) {
                // RHS is a throwing function call - emit with error propagation
                // (typer should ensure non-throwing context doesn't call throwing functions without catch)
                // Pass raw name so function can properly handle field access on mut params
                emit_throwing_call_propagate(rhs_expr, fd.throw_types, "", name, output, indent, ctx, context)?
                return
            }
            }
        case:
        }

        // Process RHS with emit_arg_string (handles hoisting)
        rhs_str = emit_arg_string(rhs_expr, Ptr(), false, output, indent, ctx, context)?
        has_rhs = true
    }

    // Regular assignment
    output.push_str(indent_str)
    // Check if assignment target is a field access on a mut param (self.field)
    // If so, emit with -> instead of .
    dot_pos := name.find(".")
    if dot_pos.gteq(0) {
        base := name.get_substr(0, dot_pos)?
        rest := name.get_substr(dot_pos.add(1), name.len())?
        if ctx.current_ref_params.contains(base) {
            // Mut param field access: til_self->field
            output.push_str(til_name(base))
            output.push_str("->")
            output.push_str(rest)
        } else {
            output.push_str(til_name(name))
        }
    } else if ctx.current_ref_params.contains(name) {
        // Direct assignment to mut param: *til_self = value
        output.push_str("*")
        output.push_str(til_name(name))
    } else {
        output.push_str(til_name(name))
    }
    output.push_str(" = ")

    // Check if LHS is Dynamic type - need to cast RHS to avoid int-to-pointer warning
    mut is_dynamic_target := false
    sym := context.scope_stack.lookup_symbol(name)?
    switch sym.value_type {
    case ValueType.TCustom(t):
        if t.eq("Dynamic") {
            is_dynamic_target = true
        }
    case:
    }
    catch (err: KeyNotFoundError) {
        // REM: Symbol not found means we don't know its type, so is_dynamic_target stays false
    }

    if has_rhs {
        if is_dynamic_target {
            output.push_str("(")
            output.push_str(TIL_PREFIX)
            output.push_str("Dynamic)")
        }
        output.push_str(rhs_str)
    }
    output.push_str(";\n")

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_return := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    indent_str := repeat("    ", indent)
    is_throwing := not(ctx.current_throw_types.is_empty())

    if is_throwing {
        // Throwing function: store value through _ret pointer and return 0 (success)
        if not(expr.params.is_empty()) {
            mut thr_return_expr := Expr()
            expr.params.get(0, thr_return_expr)?

            // Check if return expression is a call to a throwing function
            switch thr_return_expr.node_type {
            case NodeType.FCall(_):
                // Bug #80: Use flag pattern for if-let-Some translation
                mut thr_fd := SFuncDef()
                mut thr_fd_found := false
                thr_fd = get_fcall_func_def(context, thr_return_expr)?
                thr_fd_found = true
                catch (err: KeyNotFoundError) {
                    // REM: no func def found
                }
                if thr_fd_found.and(not(thr_fd.throw_types.is_empty())) {
                    // Return expression is a throwing function call - emit with error propagation
                    // The result will be stored via the assign_name "*_ret"
                    emit_throwing_call_propagate(thr_return_expr, thr_fd.throw_types, "", "*_ret", output, indent, ctx, context)?
                    output.push_str(indent_str)
                    output.push_str("return 0;\n")
                    return
                }
            case:
            }

            // Bug #143: Use emit_arg_string to handle hoisting
            return_str := emit_arg_string(thr_return_expr, Ptr(), false, output, indent, ctx, context)?

            // Regular return value - just emit it
            output.push_str(indent_str)
            output.push_str("*_ret = ")
            output.push_str(return_str)
            output.push_str(";\n")
        }
        output.push_str(indent_str)
        output.push_str("return 0;\n")
    } else {
        // Non-throwing function: normal return
        // Check if return expression is a variadic function call
        if not(expr.params.is_empty()) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)?
            switch return_expr.node_type {
            case NodeType.FCall(_):
                mut variadic_fcall_info := VariadicFCallInfo()
                variadic_fcall_info = detect_variadic_fcall(return_expr, ctx)?
                catch (err: KeyNotFoundError) {
                    // REM: not variadic - variadic_fcall_info stays at default
                }
                if not(variadic_fcall_info.elem_type.is_empty()) {
                    // Variadic call in return - need to hoist it
                    // Bug #143: Use emit_arg_string for regular args, pass empty map to hoist_variadic_args
                    // (hoist_variadic_args already uses emit_arg_string internally)
                    mut variadic_args := Vec.new(Expr)
                    mut va_idx := add(1, variadic_fcall_info.regular_count)
                    while va_idx.lt(return_expr.params.len()) {
                        mut va_arg := Expr()
                        return_expr.params.get(va_idx, va_arg)?
                        variadic_args.push(va_arg)
                        va_idx.inc()
                    }
                    empty_hoisted := Map.new(I64, Str)
                    arr_var := hoist_variadic_args(variadic_fcall_info.elem_type, variadic_args, empty_hoisted, variadic_fcall_info.regular_count, output, indent, ctx, context)?

                    // Bug #143: Get regular arg strings using emit_arg_string
                    mut regular_args := Vec.new(Expr)
                    mut ra_idx := 1
                    while ra_idx.lt(add(1, variadic_fcall_info.regular_count)).and(ra_idx.lt(return_expr.params.len())) {
                        mut ra_arg := Expr()
                        return_expr.params.get(ra_idx, ra_arg)?
                        regular_args.push(ra_arg)
                        ra_idx.inc()
                    }
                    var_fd := get_fcall_func_def(context, return_expr)?
                    catch (err: KeyNotFoundError) { }
                    mut regular_arg_strings := Vec.new(Str)
                    mut i := 0
                    while i.lt(regular_args.len()) {
                        mut arg := Expr()
                        regular_args.get(i, arg)?
                        mut param_type := Ptr()
                        mut by_ref := true
                        if i.lt(var_fd.args.len()) {
                            mut param_decl := Declaration()
                            var_fd.args.get(i, param_decl)?
                            param_type.data = to_ptr(param_decl.value_type)
                            by_ref = param_needs_by_ref(param_decl)
                        }
                        arg_str := emit_arg_string(arg, param_type, by_ref, output, indent, ctx, context)?
                        regular_arg_strings.push(arg_str)
                        i.inc()
                    }

                    // Emit the function call storing result
                    temp_var := next_mangled(ctx)
                    ret_type_vt := get_value_type(context, return_expr)?
                    catch (err: Str) {
                        throw return_expr.lang_error(context.path, "ccodegen", err)
                    }
                    ret_type := til_type_to_c(ret_type_vt)?
                    catch (err2: Str) {
                        throw return_expr.lang_error(context.path, "ccodegen", err2)
                    }
                    output.push_str(indent_str)
                    output.push_str(ret_type)
                    output.push_str(" ")
                    output.push_str(temp_var)
                    output.push_str(" = ")
                    // Emit the function call
                    mut var_first_param := Expr()
                    return_expr.params.get(0, var_first_param)?
                    switch var_first_param.node_type {
                    case NodeType.Identifier(func_name):
                        output.push_str(til_func_name(func_name))
                    case:
                    }
                    output.push_str("(")
                    // Emit regular args
                    mut vret_arg_i := 0
                    while vret_arg_i.lt(regular_arg_strings.len()) {
                        if vret_arg_i.gt(0) {
                            output.push_str(", ")
                        }
                        mut vret_arg_str := ""
                        regular_arg_strings.get(vret_arg_i, vret_arg_str)?
                        output.push_str(vret_arg_str)
                        vret_arg_i.inc()
                    }
                    // Emit variadic array pointer
                    if variadic_fcall_info.regular_count.gt(0) {
                        output.push_str(", ")
                    }
                    output.push_str("&")
                    output.push_str(arr_var)
                    output.push_str(");\n")

                    // Delete array
                    output.push_str(indent_str)
                    output.push_str(TIL_PREFIX)
                    output.push_str("Array_delete(&")
                    output.push_str(arr_var)
                    output.push_str(");\n")

                    // Return the result
                    output.push_str(indent_str)
                    output.push_str("return ")
                    output.push_str(temp_var)
                    output.push_str(";\n")
                    return
                }
            case:
            }
        }

        // Bug #143: Use emit_arg_string to handle hoisting
        mut nv_return_str := ""
        mut has_nv_return := false
        if not(expr.params.is_empty()) {
            mut ret_first_param := Expr()
            expr.params.get(0, ret_first_param)?
            nv_return_str = emit_arg_string(ret_first_param, Ptr(), false, output, indent, ctx, context)?
            has_nv_return = true
        }

        // Regular non-variadic return
        output.push_str(indent_str)
        output.push_str("return")
        if has_nv_return {
            output.push_str(" ")
            output.push_str(nv_return_str)
        }
        output.push_str(";\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_throw := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Throw: params[0] = the value to throw (typically a struct constructor like DivideByZero())
    if expr.params.is_empty() {
        throw "ccodegen: throw requires a value"
    }

    indent_str := repeat("    ", indent)
    mut thrown_expr := Expr()
    expr.params.get(0, thrown_expr)?

    // Bug #143: Use emit_arg_string to handle hoisting of thrown expression
    thrown_str := emit_arg_string(thrown_expr, Ptr(), false, output, indent, ctx, context)?

    // Get the thrown type name from the expression
    // For FCall, we need to determine if it's:
    // 1. A constructor like DivideByZero() - use the type name
    // 2. A function that returns an error type like format() - use the return type
    mut nh_thrown_type_name := ""
    switch thrown_expr.node_type {
    case NodeType.FCall(_):
        if not(thrown_expr.params.is_empty()) {
            mut nh_first_param := Expr()
            thrown_expr.params.get(0, nh_first_param)?
            switch nh_first_param.node_type {
            case NodeType.Identifier(name):
                // Check if this is a constructor (struct/enum) or a function call
                // If it's a function that returns a type, use the return type
                mut func_def := SFuncDef()
                func_def = get_fcall_func_def(context, thrown_expr)?
                catch (err: KeyNotFoundError) {
                    // Not a function, assume it's a constructor
                    nh_thrown_type_name = name.clone()
                }
                // Only check func_def's return types if we successfully got it (nh_thrown_type_name still empty)
                if nh_thrown_type_name.is_empty() {
                    // It's a function - use its return type as the thrown type
                    if not(func_def.return_types.is_empty()) {
                        mut nh_ret_type := ValueType.TCustom("")
                        func_def.return_types.get(0, nh_ret_type)?
                        switch nh_ret_type {
                        case ValueType.TCustom(type_name):
                            nh_thrown_type_name = type_name.clone()
                        case:
                            // Return type is a primitive (like Str) - convert to name
                            nh_thrown_type_name = value_type_to_str(nh_ret_type)
                        }
                    } else {
                        // No return type, assume it's a constructor
                        nh_thrown_type_name = name.clone()
                    }
                }
            case:
                throw "ccodegen: throw FCall must have identifier as first param"
            }
        } else {
            throw "ccodegen: throw FCall has no params"
        }
    case NodeType.Identifier(name):
        // Look up the type of the identifier (could be a variable or type name)
        mut nh_have_value_type := true
        nh_value_type := get_value_type(context, thrown_expr)?
        catch (err: Str) {
            // Fallback: assume identifier is a type name (for struct constructors without args)
            nh_thrown_type_name = name.clone()
            nh_have_value_type = false
        }
        if nh_have_value_type {
            switch nh_value_type {
            case ValueType.TCustom(type_name):
                nh_thrown_type_name = type_name.clone()
            case:
                nh_thrown_type_name = value_type_to_str(nh_value_type)
            }
        }
    case NodeType.LLiteral(lit):
        // Literal values - determine their type
        switch lit {
        case Literal.Str(_):
            nh_thrown_type_name = "Str"
        case Literal.Number(_):
            nh_thrown_type_name = "I64"
        case Literal.List(_):
            throw "ccodegen: cannot throw a list literal"
        }
    case:
        throw "ccodegen: throw expression must be a constructor"
    }

    // Check if this type is locally caught (has a catch block at function level)
    mut nh_catch_info := CatchLabelInfo()
    ctx.local_catch_labels.get(nh_thrown_type_name.clone(), nh_catch_info)?
    catch (err: KeyNotFoundError) {
        // REM: Rust's None case - type not locally caught, continue to next check
    }
    if not(nh_catch_info.label.eq("")) {
        nh_label := nh_catch_info.label.clone()
        nh_temp_var := nh_catch_info.temp_var.clone()

        // Issue #119: Check if this is an empty struct error
        mut is_empty_local_err := false
        nh_struct_def := context.scope_stack.lookup_struct(nh_thrown_type_name.clone())?
        is_empty_local_err = nh_struct_def.members.is_empty()
        catch (err: KeyNotFoundError) {
            is_empty_local_err = false
        }

        // Issue #119: Skip storing value for empty struct errors - just goto
        if is_empty_local_err {
            output.push_str(indent_str)
            output.push_str("goto ")
            output.push_str(nh_label)
            output.push_str(";\n")
            return
        }

        // Bug #143: Use thrown_str (already hoisted by emit_arg_string)
        output.push_str(indent_str)
        output.push_str(nh_temp_var)
        output.push_str(" = ")
        output.push_str(thrown_str)
        output.push_str(";\n")

        // Jump to the catch block
        output.push_str(indent_str)
        output.push_str("goto ")
        output.push_str(nh_label)
        output.push_str(";\n")
        return
    }

    // Find the index of this type in current_throw_types
    // Note: Str is represented as TCustom("Str") in the type system
    mut nh_error_index := sub(0, 1)
    mut nh_i := 0
    while nh_i.lt(ctx.current_throw_types.len()) {
        mut nh_vt := ValueType.TCustom("")
        ctx.current_throw_types.get(nh_i, nh_vt)?
        switch nh_vt {
        case ValueType.TCustom(name):
            if name.eq(nh_thrown_type_name) {
                nh_error_index = nh_i
                break
            }
        case:
        }
        nh_i.inc()
    }

    if nh_error_index.gteq(0) {
        // Issue #119: Check if this is an empty struct error
        mut nh_prop_err_type := ValueType.TCustom("")
        ctx.current_throw_types.get(nh_error_index, nh_prop_err_type)?
        is_empty_err := is_empty_error_struct(context, nh_prop_err_type)

        // Issue #119: Skip storing error value for empty struct errors
        if not(is_empty_err) {
            // Bug #143: Use thrown_str (already hoisted by emit_arg_string)
            output.push_str(indent_str)
            output.push_str("*_err")
            output.push_str(I64.to_str(nh_error_index.add(1)))
            output.push_str(" = ")
            output.push_str(thrown_str)
            output.push_str(";\n")
        }

        // Return the error index (1-based, since 0 = success)
        output.push_str(indent_str)
        output.push_str("return ")
        output.push_str(I64.to_str(nh_error_index.add(1)))
        output.push_str(";\n")
    } else {
        throw concat("ccodegen: thrown type '", nh_thrown_type_name).concat("' not found in function's throw types")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_if := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if expr.params.len().lt(2) {
        throw "ccodegen: If requires condition and body"
    }

    indent_str := repeat("    ", indent)

    // Hoist declarations from both branches to before the if statement
    // (TIL has function-level scoping, not block-level scoping)
    mut then_body := Expr()
    expr.params.get(1, then_body)?
    then_decls := collect_declarations_in_body(then_body, context)?
    for decl: CollectedDeclaration in then_decls {
        c_var_name := til_name(decl.name)
        if not(ctx.declared_vars.contains(c_var_name)) {
            c_type := til_type_to_c(decl.value_type)?
            catch (err: Str) {
                continue
            }
            output.push_str(indent_str)
            output.push_str(c_type)
            output.push_str(" ")
            output.push_str(c_var_name.clone())
            output.push_str(";\n")
            _ := ctx.declared_vars.insert(c_var_name)
            // Also register in scope_stack so get_value_type can find it
            mut sym_info := SymbolInfo()
            sym_info.value_type = decl.value_type
            sym_info.is_mut = false
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(decl.name.clone(), sym_info)?
        }
    }
    if expr.params.len().gt(2) {
        mut hoist_else_body := Expr()
        expr.params.get(2, hoist_else_body)?
        else_decls := collect_declarations_in_body(hoist_else_body, context)?
        for else_decl: CollectedDeclaration in else_decls {
            else_c_var_name := til_name(else_decl.name)
            if not(ctx.declared_vars.contains(else_c_var_name)) {
                else_c_type := til_type_to_c(else_decl.value_type)?
                catch (err: Str) {
                    continue
                }
                output.push_str(indent_str)
                output.push_str(else_c_type)
                output.push_str(" ")
                output.push_str(else_c_var_name.clone())
                output.push_str(";\n")
                _ := ctx.declared_vars.insert(else_c_var_name)
                // Also register in scope_stack so get_value_type can find it
                mut else_sym_info := SymbolInfo()
                else_sym_info.value_type = else_decl.value_type
                else_sym_info.is_mut = false
                else_sym_info.is_copy = false
                else_sym_info.is_own = false
                else_sym_info.is_comptime_const = false
                context.scope_stack.declare_symbol(else_decl.name.clone(), else_sym_info)?
            }
        }
    }

    // Bug #143: Use emit_arg_string to handle hoisting in condition
    mut condition := Expr()
    expr.params.get(0, condition)?
    cond_str := emit_arg_string(condition, Ptr(), false, output, indent, ctx, context)?
    output.push_str(indent_str)
    output.push_str("if (")
    output.push_str(cond_str)
    // Bool is a struct with .data field - extract for C truthiness
    mut have_vt := true
    vt := get_value_type(context, condition)?
    catch (err: Str) {
        have_vt = false
    }
    if have_vt {
        switch vt {
        case ValueType.TCustom(type_name):
            if type_name.eq("Bool") {
                output.push_str(".data")
            }
        case:
        }
    }
    output.push_str(") {\n")

    // Don't save/restore declared_vars - TIL has function-level scoping
    // Variables declared in if branches stay declared for the rest of the function
    emit_body(then_body, output, indent.add(1), ctx, context)?

    output.push_str(indent_str)
    output.push_str("}")

    // Else branch (optional)
    if expr.params.len().gt(2) {
        mut emit_else_body := Expr()
        expr.params.get(2, emit_else_body)?
        // Check if it's an else-if (nested If) or else block
        switch emit_else_body.node_type {
        case NodeType.If:
            // Always wrap else-if in braces to ensure hoisted temp vars
            // from nested if conditions have proper scope
            output.push_str(" else {\n")
            emit_if(emit_else_body, output, indent.add(1), ctx, context)?
            output.push_str(indent_str)
            output.push_str("}\n")
        case:
            output.push_str(" else {\n")
            emit_body(emit_else_body, output, indent.add(1), ctx, context)?
            output.push_str(indent_str)
            output.push_str("}\n")
        }
    } else {
        output.push_str("\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_while := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // While: params[0] = condition, params[1] = body
    if expr.params.len().lt(2) {
        throw "ccodegen: While requires condition and body"
    }

    indent_str := repeat("    ", indent)

    // Hoist declarations from loop body to before the while statement
    // (TIL has function-level scoping, not block-level scoping)
    mut body := Expr()
    expr.params.get(1, body)?
    body_decls := collect_declarations_in_body(body, context)?
    for decl: CollectedDeclaration in body_decls {
        c_var_name := til_name(decl.name)
        if not(ctx.declared_vars.contains(c_var_name)) {
            c_type := til_type_to_c(decl.value_type)?
            catch (err: Str) {
                continue
            }
            output.push_str(indent_str)
            output.push_str(c_type)
            output.push_str(" ")
            output.push_str(c_var_name.clone())
            output.push_str(";\n")
            _ := ctx.declared_vars.insert(c_var_name)
            // Also register in scope_stack so get_value_type can find it
            mut sym_info := SymbolInfo()
            sym_info.value_type = decl.value_type
            sym_info.is_mut = false
            sym_info.is_copy = false
            sym_info.is_own = false
            sym_info.is_comptime_const = false
            context.scope_stack.declare_symbol(decl.name.clone(), sym_info)?
        }
    }

    // Bug #143: Use emit_arg_string to process condition (handles hoisting for by-ref/throwing)
    // Emit hoisting to a separate buffer first to detect if needed
    mut hoist_buffer := ""
    mut condition := Expr()
    expr.params.get(0, condition)?
    cond_str := emit_arg_string(condition, Ptr(), false, hoist_buffer, indent.add(1), ctx, context)?

    if hoist_buffer.is_empty() {
        // No hoisting needed - use simple while
        output.push_str(indent_str)
        output.push_str("while (")
        output.push_str(cond_str)
        // Bool is a struct with .data field - extract for C truthiness
        mut have_while_vt := true
        vt := get_value_type(context, condition)?
        catch (err: Str) {
            have_while_vt = false
        }
        if have_while_vt {
            switch vt {
            case ValueType.TCustom(type_name):
                if type_name.eq("Bool") {
                    output.push_str(".data")
                }
            case:
            }
        }
        output.push_str(") {\n")
    } else {
        // Hoisting needed in condition - transform to while(1) with hoisted calls and break
        output.push_str(indent_str)
        output.push_str("while (1) {\n")

        // Emit hoisted statements inside the loop
        output.push_str(hoist_buffer)

        // Emit condition check with break
        inner_indent_str := repeat("    ", indent.add(1))
        output.push_str(inner_indent_str)
        output.push_str("if (!(")
        output.push_str(cond_str)
        // Bool is a struct with .data field - extract for C truthiness
        mut have_inner_vt := true
        inner_vt := get_value_type(context, condition)?
        catch (err: Str) {
            have_inner_vt = false
        }
        if have_inner_vt {
            switch inner_vt {
            case ValueType.TCustom(type_name):
                if type_name.eq("Bool") {
                    output.push_str(".data")
                }
            case:
            }
        }
        output.push_str(")) break;\n")
    }

    // Don't save/restore declared_vars - TIL has function-level scoping
    // Variables declared in loops stay declared for the rest of the function
    emit_body(body, output, indent.add(1), ctx, context)?

    output.push_str(indent_str)
    output.push_str("}\n")

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_break := proc(_expr: Expr, mut output: Str, indent: I64) {
    indent_str := repeat("    ", indent)
    output.push_str(indent_str)
    output.push_str("break;\n")
}

emit_continue := proc(_expr: Expr, mut output: Str, indent: I64) {
    indent_str := repeat("    ", indent)
    output.push_str(indent_str)
    output.push_str("continue;\n")
}

// Info about a variadic parameter
VariadicParamInfo := struct {
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Info about a catch label for local throw/catch
CatchLabelInfo := struct {
    mut label: Str = ""
    mut temp_var: Str = ""
}


// Result struct for variant info extraction
VariantInfo := struct {
    mut type_name: Str = ""
    mut variant_name: Str = ""
}

// Info about a catch block for code generation
// Note: TIL version also has catch_block field, but Rust accesses stmts[i] directly
CatchLabelInfoEntry := struct {
    mut stmt_index: I64 = 0        // Index in stmts array
    mut type_name: Str = ""        // Error type being caught (e.g., "Str", "IndexOutOfBoundsError")
    mut label: Str = ""            // Goto label for this catch
    mut temp_var: Str = ""         // Temp variable holding the thrown value
}

// Info about a function parameter's type and whether passed by reference
ParamTypeInfo := struct {
    mut value_type: ValueType = ValueType.TCustom("")
    mut has_value_type: Bool = false  // tracks if value_type is set (Option pattern)
    mut by_ref: Bool = false
}

// Info about a collected variable declaration for hoisting
CollectedDeclaration := struct {
    mut name: Str = ""
    mut value_type: ValueType = ValueType.TCustom("")
}

// Info about a variadic function call
VariadicFCallInfo := struct {
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Extract enum type and variant names from a case pattern expression
// For FCall: Type.Variant -> VariantInfo { type_name: "Type", variant_name: "Variant" }
get_case_variant_info := proc(expr: Expr) returns VariantInfo {
    switch expr.node_type {
    case NodeType.FCall(_):
        // FCall for Type.Variant (without payload extraction)
        if not(expr.params.is_empty()) {
            mut first_param := Expr()
            expr.params.get(0, first_param)?
            switch first_param.node_type {
            case NodeType.Identifier(type_name):
                if not(first_param.params.is_empty()) {
                    mut nested_param := Expr()
                    first_param.params.get(0, nested_param)?
                    switch nested_param.node_type {
                    case NodeType.Identifier(variant_name):
                        mut result := VariantInfo()
                        result.type_name = type_name.clone()
                        result.variant_name = variant_name.clone()
                        return result
                    case:
                        // REM: not identifier
                    }
                }
            case:
                // REM: not identifier
            }
        }
        return VariantInfo()
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if not(expr.params.is_empty()) {
            mut ident_first_param := Expr()
            expr.params.get(0, ident_first_param)?
            switch ident_first_param.node_type {
            case NodeType.Identifier(variant_name):
                mut ident_result := VariantInfo()
                ident_result.type_name = name.clone()
                ident_result.variant_name = variant_name.clone()
                return ident_result
            case:
                // REM: not identifier
            }
        }
        // Plain identifier without nested params - NOT an enum variant pattern
        // Return empty to let emit_switch fall through to regular value comparison
        return VariantInfo()
    case:
        return VariantInfo()
    }

    catch (err: IndexOutOfBoundsError) {
        return VariantInfo()
    }
}

// Extract type name and variant name from a Pattern's variant_name (e.g., "Color.Green")
parse_pattern_variant_name := proc(variant_name: Str) returns VariantInfo throws Str {
    dot_pos := variant_name.rfind(".")
    if dot_pos.gteq(0) {
        type_name := variant_name.get_substr(0, dot_pos)?
        var_name := variant_name.get_substr(dot_pos.add(1), variant_name.len())?
        mut result := VariantInfo()
        result.type_name = type_name
        result.variant_name = var_name
        return result
    } else {
        // No dot - just variant name (shouldn't happen in practice)
        mut else_result := VariantInfo()
        else_result.variant_name = variant_name.clone()
        return else_result
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

/// Collect all variable declarations in a body (recursively) for hoisting
/// Returns Vec of CollectedDeclaration structs
collect_declarations_in_body := proc(body: Expr, mut context: Context) returns Vec throws Str {
    mut decls := Vec.new(CollectedDeclaration)
    // Track collected declarations for lookups during type inference
    mut collected := Map.new(Str, ValueType)

    switch body.node_type {
    case NodeType.Body:
        for stmt: Expr in body.params {
            collect_declarations_recursive(stmt, decls, collected, context)?
        }
    case:
        collect_declarations_recursive(body, decls, collected, context)?
    }

    return decls
}

collect_declarations_recursive := proc(expr: Expr, mut decls: Vec, mut collected: Map, mut context: Context) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // INFER_TYPE should have been resolved by typer
        switch decl.value_type {
        case ValueType.TCustom(name):
            if name.eq(INFER_TYPE) {
                panic(loc(), "Declaration '", decl.name, "' has INFER_TYPE in ccodegen - should have been resolved by typer")
            }
        case:
        }
        value_type := decl.value_type
        // Track this declaration for future lookups (both in collected and scope_stack)
        collected.set(decl.name.clone(), value_type)
        // Also add to scope_stack so get_value_type can find it for subsequent declarations
        mut symbol_info := SymbolInfo()
        symbol_info.value_type = value_type
        symbol_info.is_mut = decl.is_mut
        symbol_info.is_copy = false
        symbol_info.is_own = false
        symbol_info.is_comptime_const = false
        context.scope_stack.declare_symbol(decl.name.clone(), symbol_info)?
        mut collected_decl := CollectedDeclaration()
        collected_decl.name = decl.name.clone()
        collected_decl.value_type = value_type
        decls.push(collected_decl)
    case NodeType.Body:
        for stmt: Expr in expr.params {
            collect_declarations_recursive(stmt, decls, collected, context)?
        }
    case NodeType.If:
        // Recurse into if branches
        if expr.params.len().gteq(2) {
            mut second_param := Expr()
            expr.params.get(1, second_param)?
            collect_declarations_recursive(second_param, decls, collected, context)?
        }
        if expr.params.len().gteq(3) {
            mut third_param := Expr()
            expr.params.get(2, third_param)?
            collect_declarations_recursive(third_param, decls, collected, context)?
        }
    case NodeType.Switch:
        // Recurse into switch case bodies
        mut i := 1
        while i.add(1).lt(expr.params.len()) {
            mut body_param := Expr()
            expr.params.get(i.add(1), body_param)?
            collect_declarations_recursive(body_param, decls, collected, context)?
            i = i.add(2)
        }
    case NodeType.While:
        // Recurse into while body
        if expr.params.len().gteq(2) {
            mut while_body := Expr()
            expr.params.get(1, while_body)?
            collect_declarations_recursive(while_body, decls, collected, context)?
        }
    case NodeType.Catch:
        // Recurse into catch body (params[2] is catch body)
        // params[0] = err_var, params[1] = err_type, params[2] = body
        if expr.params.len().gteq(3) {
            mut catch_body := Expr()
            expr.params.get(2, catch_body)?
            collect_declarations_recursive(catch_body, decls, collected, context)?
        }
    case:
        // REM: other node types don't contain declarations
    }

    catch (err: IndexOutOfBoundsError) {
        // REM: ignore
    }
}

emit_switch := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // Switch: params[0] = switch expression
    // params[1..] = alternating (case_pattern, body) pairs
    // We emit if/else chains instead of C switch because:
    // 1. C switch only works with integer types, not Str
    // 2. Avoids GCC-specific case range extension
    // 3. More portable and easier to handle all TIL switch patterns
    if expr.params.is_empty() {
        throw "ccodegen: Switch requires expression"
    }

    indent_str := repeat("    ", indent)
    body_indent := repeat("    ", indent.add(1))

    // Get the switch expression
    mut switch_expr := Expr()
    expr.params.get(0, switch_expr)?

    // Bug #143: Use emit_arg_string to handle hoisting in switch expression
    switch_expr_str := emit_arg_string(switch_expr, Ptr(), false, output, indent, ctx, context)?

    // Determine the type of the switch expression for proper comparison
    // Type inference may fail - that's okay, we'll use default
    mut switch_type := ValueType.TCustom("")
    mut has_switch_type := false
    switch_type = get_value_type(context, switch_expr)?
    has_switch_type = true
    catch (err: Str) {
        // REM: type inference failed, that's ok
    }

    mut is_str_switch := false
    if has_switch_type {
        switch switch_type {
        case ValueType.TCustom(t):
            if t.eq("Str") {
                is_str_switch = true
            }
        case:
            // REM: not a custom type
        }
    }

    // Bug #136: Check if this is a struct switch that needs eq() method
    // Skip primitive types (I64, U8, Bool, Str) whose values are literals
    mut is_struct_switch := false
    mut struct_type_name := ""
    if has_switch_type {
        switch switch_type {
        case ValueType.TCustom(type_name):
            is_primitive := type_name.eq("Str").or(type_name.eq("I64")).or(type_name.eq("U8")).or(type_name.eq("Bool"))
            if not(is_primitive) {
                mut is_struct := false
                _struct_def := context.scope_stack.lookup_struct(type_name)?
                is_struct = true
                catch (err: KeyNotFoundError) { }
                if is_struct {
                    eq_method_name := format(type_name, ".eq")
                    _func_def := context.scope_stack.lookup_func(eq_method_name)?
                    is_struct_switch = true
                    struct_type_name = type_name.clone()
                    catch (err: KeyNotFoundError) { }
                }
            }
        case:
        }
    }

    // Determine if this is an enum switch and if it has payloads
    mut is_enum_switch := false
    mut enum_has_payloads_flag := false
    mut i := 1
    while i.lt(expr.params.len()) {
        mut check_case_pattern := Expr()
        expr.params.get(i, check_case_pattern)?
        switch check_case_pattern.node_type {
        case NodeType.Pattern(_):
            is_enum_switch = true
        case NodeType.Identifier(name):
            if not(check_case_pattern.params.is_empty()).or(name.contains(".")) {
                is_enum_switch = true
            }
        case NodeType.FCall(_):
            is_enum_switch = true
            // FCall with arguments (e.g., ValueType.TType(TTypeDef.TEnumDef))
            // implies the enum has payloads
            if check_case_pattern.params.len().gt(1) {
                enum_has_payloads_flag = true
            }
        case:
            // REM: not an enum case
        }
        i = i.add(2)
    }
    if is_enum_switch {
        if has_switch_type {
            switch switch_type {
            case ValueType.TCustom(enum_name):
                mut have_enum_def := true
                enum_def := context.scope_stack.lookup_enum(enum_name)?
                catch (err: KeyNotFoundError) {
                    have_enum_def = false
                }
                if have_enum_def {
                    enum_has_payloads_flag = enum_has_payloads(enum_def)
                }
            case:
                // REM: not a custom type
            }
        }
    }

    // Store switch expression in a temp variable to avoid re-evaluation
    switch_var := next_mangled(ctx)
    output.push_str(indent_str)
    output.push_str("__auto_type ")
    output.push_str(switch_var)
    output.push_str(" = ")
    output.push_str(switch_expr_str)
    output.push_str(";\n")

    // Hoist declarations from all case bodies to before the if/else chain
    // This ensures variables declared in switch cases are visible after the switch
    // (TIL has function-level scoping, not block-level scoping)
    mut j := 1
    while j.add(1).lt(expr.params.len()) {
        mut body := Expr()
        expr.params.get(j.add(1), body)?
        decls := collect_declarations_in_body(body, context)?
        for decl: CollectedDeclaration in decls {
            c_var_name := til_name(decl.name)
            if not(ctx.declared_vars.contains(c_var_name)) {
                mut have_c_type := true
                c_type := til_type_to_c(decl.value_type)?
                catch (err: Str) {
                    have_c_type = false
                }
                if have_c_type {
                    output.push_str(indent_str)
                    output.push_str(c_type)
                    output.push_str(" ")
                    output.push_str(c_var_name)
                    output.push_str(";\n")
                    _ := ctx.declared_vars.insert(c_var_name)
                    // Also register in scope_stack so get_value_type can find it
                    mut symbol_info := SymbolInfo()
                    symbol_info.value_type = decl.value_type
                    symbol_info.is_mut = false
                    symbol_info.is_copy = false
                    symbol_info.is_own = false
                    symbol_info.is_comptime_const = false
                    context.scope_stack.declare_symbol(decl.name.clone(), symbol_info)?
                }
            }
        }
        j = j.add(2)
    }

    // Emit if/else if chain for cases
    // Default case (if present) is guaranteed to be last by parser
    mut k := 1
    mut first_case := true
    mut has_cases := false
    while k.add(1).lt(expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(k, case_pattern)?
        mut case_body := Expr()
        expr.params.get(k.add(1), case_body)?
        has_cases = true

        // Check if this is the default case (guaranteed last by parser)
        switch case_pattern.node_type {
        case NodeType.DefaultCase:
            // Default case - emit as else block
            if not(first_case) {
                output.push_str(indent_str)
                output.push_str("} else {\n")
            }
            saved_declared_vars := ctx.declared_vars.clone()
            emit_body(case_body, output, indent.add(1), ctx, context)?
            ctx.declared_vars = saved_declared_vars
            k = k.add(2)
            continue
        case:
            // REM: not default case, continue below
        }

        // Regular case - emit if/else if
        output.push_str(indent_str)
        if first_case {
            output.push_str("if (")
            first_case = false
        } else {
            output.push_str("} else if (")
        }

        // Emit the condition based on pattern type
        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // Enum pattern with payload binding: compare tag
            mut info := parse_pattern_variant_name(pattern_info.variant_name)?
            // If no type prefix (shorthand syntax), use the switch expression's type
            if info.type_name.is_empty() {
                if has_switch_type {
                    switch switch_type {
                    case ValueType.TCustom(enum_name):
                        info.type_name = enum_name.clone()
                    case:
                        // REM: not a custom type
                    }
                }
            }
            output.push_str(switch_var)
            output.push_str(".tag == til_")
            output.push_str(info.type_name)
            output.push_str("_")
            output.push_str(info.variant_name)
            output.push_str(") {\n")

            // Extract payload into binding variable
            output.push_str(body_indent)
            output.push_str("__auto_type ")
            output.push_str(til_name(pattern_info.binding_var))
            output.push_str(" = ")
            output.push_str(switch_var)
            output.push_str(".payload.")
            output.push_str(info.variant_name)
            output.push_str(";\n")
        case NodeType.Range:
            // Range: low <= val && val <= high
            if case_pattern.params.len().lt(2) {
                throw "ccodegen: Range requires start and end values"
            }
            if is_str_switch {
                // For string ranges, use strcmp: strcmp(low, val) <= 0 && strcmp(val, high) <= 0
                output.push_str("strcmp((char*)")
                mut range_start := Expr()
            case_pattern.params.get(0, range_start)?
                emit_expr(range_start, output, 0, ctx, context)?
                output.push_str(".c_string.data, (char*)")
                output.push_str(switch_var)
                output.push_str(".c_string.data) <= 0 && strcmp((char*)")
                output.push_str(switch_var)
                output.push_str(".c_string.data, (char*)")
                mut range_end := Expr()
            case_pattern.params.get(1, range_end)?
                emit_expr(range_end, output, 0, ctx, context)?
                output.push_str(".c_string.data) <= 0")
            } else {
                mut else_range_start := Expr()
            case_pattern.params.get(0, else_range_start)?
                emit_expr(else_range_start, output, 0, ctx, context)?
                output.push_str(" <= ")
                output.push_str(switch_var)
                output.push_str(" && ")
                output.push_str(switch_var)
                output.push_str(" <= ")
                mut else_range_end := Expr()
            case_pattern.params.get(1, else_range_end)?
                emit_expr(else_range_end, output, 0, ctx, context)?
            }
            output.push_str(") {\n")
        case NodeType.Identifier(_name):
            ident_info := get_case_variant_info(case_pattern)
            if not(ident_info.variant_name.is_empty()) {
                // Enum variant without payload
                output.push_str(switch_var)
                if enum_has_payloads_flag {
                    output.push_str(".tag")
                }
                output.push_str(" == ")
                if not(ident_info.type_name.is_empty()) {
                    output.push_str("til_")
                    output.push_str(ident_info.type_name)
                    output.push_str("_")
                }
                output.push_str(ident_info.variant_name)
            } else if is_str_switch {
                // String comparison - pass by pointer
                output.push_str("til_Str_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else if is_struct_switch {
                // Bug #136: Struct comparison using eq() method
                output.push_str("til_")
                output.push_str(struct_type_name)
                output.push_str("_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else {
                // Regular value comparison
                output.push_str(switch_var)
                output.push_str(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)?
            }
            output.push_str(") {\n")
        case NodeType.LLiteral(_):
            if is_str_switch {
                // String literal comparison - pass by pointer
                output.push_str("til_Str_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else if is_struct_switch {
                // Bug #136: Struct comparison using eq() method
                output.push_str("til_")
                output.push_str(struct_type_name)
                output.push_str("_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else {
                // Regular literal comparison
                output.push_str(switch_var)
                output.push_str(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)?
            }
            output.push_str(") {\n")
        case NodeType.FCall(_):
            // FCall pattern: Type.Variant(payload) - enum variant with payload argument
            // For example: ValueType.TType(TTypeDef.TEnumDef)
            fcall_info := get_case_variant_info(case_pattern)
            if not(fcall_info.variant_name.is_empty()).and(enum_has_payloads_flag) {
                // Compare tag first
                output.push_str(switch_var)
                output.push_str(".tag == til_")
                output.push_str(fcall_info.type_name)
                output.push_str("_")
                output.push_str(fcall_info.variant_name)

                // Check if there's a payload argument to compare
                // params[0] is Type.Variant identifier, params[1+] are arguments
                if case_pattern.params.len().gt(1) {
                    mut payload_expr := Expr()
                case_pattern.params.get(1, payload_expr)?
                    // Check if payload is also an enum variant (Type.Variant pattern)
                    payload_info := get_case_variant_info(payload_expr)
                    if not(payload_info.variant_name.is_empty()) {
                        // Payload is an enum variant - compare payload field
                        output.push_str(" && ")
                        output.push_str(switch_var)
                        output.push_str(".payload.")
                        output.push_str(fcall_info.variant_name)
                        output.push_str(" == til_")
                        output.push_str(payload_info.type_name)
                        output.push_str("_")
                        output.push_str(payload_info.variant_name)
                    }
                    // TODO: handle non-enum payloads if needed
                }
                output.push_str(") {\n")
            } else if not(fcall_info.variant_name.is_empty()) {
                // Enum without payloads - simple tag comparison
                output.push_str(switch_var)
                output.push_str(" == til_")
                output.push_str(fcall_info.type_name)
                output.push_str("_")
                output.push_str(fcall_info.variant_name)
                output.push_str(") {\n")
            } else if is_struct_switch {
                // Bug #136: Not an enum pattern, struct comparison using eq()
                output.push_str("til_")
                output.push_str(struct_type_name)
                output.push_str("_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data) {\n")
            } else {
                // Not an enum pattern - fall through to generic comparison
                // Bug #143: Use emit_arg_string to handle hoisting in case patterns like add(40, 2)
                // We need to emit hoisting BEFORE the condition, so collect it first
                mut case_hoist := ""
                case_pattern_str := emit_arg_string(case_pattern, Ptr(), false, case_hoist, indent, ctx, context)?
                // If there's hoisting code, we need to close the current if/else-if, emit hoisting, then reopen
                // Actually, hoisting should go before the "if (" which we've already emitted
                // For now, emit hoisting inline (it will appear inside the condition, which is invalid C)
                // TODO: Restructure to emit hoisting before the "if ("
                if not(case_hoist.is_empty()) {
                    // We have hoisting code - this is a problem because we're already inside "if ("
                    // Workaround: emit a compound statement expression (GNU extension)
                    // ({ hoisting_code; switch_var == expr; })
                    output.push_str("({\n")
                    output.push_str(case_hoist)
                    output.push_str(repeat("    ", indent.add(1)))
                    output.push_str(switch_var)
                    output.push_str(" == ")
                    output.push_str(case_pattern_str)
                    output.push_str(";\n")
                    output.push_str(repeat("    ", indent))
                    output.push_str("})) {\n")
                } else {
                    output.push_str(switch_var)
                    output.push_str(" == ")
                    output.push_str(case_pattern_str)
                    output.push_str(") {\n")
                }
            }
        case:
            // Generic case: emit equality comparison
            // TODO: Should emit proper FCall through normal path instead of hardcoding
            if is_str_switch {
                output.push_str("til_Str_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else if is_struct_switch {
                // Bug #136: Struct comparison using eq() method
                output.push_str("til_")
                output.push_str(struct_type_name)
                output.push_str("_eq(&")
                output.push_str(switch_var)
                output.push_str(", &")
                emit_expr(case_pattern, output, 0, ctx, context)?
                output.push_str(").data")
            } else {
                output.push_str(switch_var)
                output.push_str(" == ")
                emit_expr(case_pattern, output, 0, ctx, context)?
            }
            output.push_str(") {\n")
        }

        // Emit case body
        // For pattern matching with binding variables, we need to add the binding to scope
        // so that get_value_type can resolve it during body emission
        // Save declared_vars for block scope - variables declared in this case body
        // should not affect other case bodies
        case_saved_declared_vars := ctx.declared_vars.clone()

        switch case_pattern.node_type {
        case NodeType.Pattern(pattern_info):
            // Get the payload type from the enum definition
            parsed_info := parse_pattern_variant_name(pattern_info.variant_name)?
            mut payload_type_opt := ValueType.TCustom("")
            mut has_payload_type := false
            if has_switch_type {
                switch switch_type {
                case ValueType.TCustom(enum_name):
                    mut have_payload_enum_def := true
                    payload_enum_def := context.scope_stack.lookup_enum(enum_name)?
                    catch (err: KeyNotFoundError) {
                        have_payload_enum_def = false
                    }
                    if have_payload_enum_def {
                        mut have_payload_ptr := true
                        payload_ptr := payload_enum_def.get(parsed_info.variant_name)?
                        catch (err: KeyNotFoundError) {
                            have_payload_ptr = false
                        }
                        catch (err: IndexOutOfBoundsError) {
                            throw err.msg
                        }
                        // Now check if we got a payload type (Ptr not NULL)
                        if have_payload_ptr.and(not(payload_ptr.is_null())) {
                            memcpy(to_ptr(payload_type_opt), payload_ptr.data, size_of(ValueType))
                            has_payload_type = true
                        }
                    }
                case:
                    // REM: not a custom type
                }
            }

            if has_payload_type {
                // Push scope and declare binding variable
                context.scope_stack.push(ScopeType.Block)
                mut binding_symbol_info := SymbolInfo()
                binding_symbol_info.value_type = payload_type_opt
                binding_symbol_info.is_mut = false
                binding_symbol_info.is_copy = false
                binding_symbol_info.is_own = false
                binding_symbol_info.is_comptime_const = false
                context.scope_stack.declare_symbol(pattern_info.binding_var.clone(), binding_symbol_info)?
                emit_body(case_body, output, indent.add(1), ctx, context)?
                _ := context.scope_stack.pop()?
                catch (err: Str) {
                    // REM: pop failed
                }
            } else {
                emit_body(case_body, output, indent.add(1), ctx, context)?
            }
        case:
            emit_body(case_body, output, indent.add(1), ctx, context)?
        }

        // Restore declared_vars after case body
        ctx.declared_vars = case_saved_declared_vars
        k = k.add(2)
    }

    // Close the if/else chain
    if has_cases {
        output.push_str(indent_str)
        output.push_str("}\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

emit_fcall := proc(expr: Expr, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) throws Str {
    // First param is the function name (or Type.method for type-qualified calls)
    if expr.params.is_empty() {
        throw "ccodegen: FCall with no params"
    }

    // Get function name (handles both nested identifiers and precomp'd "Type.method" strings)
    mut first_param := Expr()
    expr.params.get(0, first_param)?
    mut func_name := get_func_name_string(first_param)?
    if func_name.is_empty() {
        throw "ccodegen: FCall first param not Identifier"
    }

    // For builtins, we need the original name with dots
    orig_func_name := get_til_func_name_string(first_param)?

    // Check if this is a call to a nested (hoisted) function - use mangled name
    if ctx.nested_func_names.contains_key(orig_func_name) {
        ctx.nested_func_names.get(orig_func_name, func_name)?
    }

    // Named args are already reordered by precomp, so no reordering needed here

    // Check for struct literal: TypeName(field=value, ...) -> (til_TypeName){.field = value, ...}
    // Uses lookup_struct to properly identify struct types (like interpreter.rs)
    mut has_named_args := false
    mut arg_idx := 1
    while arg_idx.lt(expr.params.len()) {
        mut arg := Expr()
        expr.params.get(arg_idx, arg)?
        switch arg.node_type {
        case NodeType.NamedArg(_):
            has_named_args = true
        case:
            // REM: not a named arg
        }
        arg_idx.inc()
    }

    if has_named_args {
        struct_def := context.scope_stack.lookup_struct(func_name)?
        if true { // TODO Bug #96 workaround
            // Emit C compound literal: (til_TypeName){.field1 = val1, .field2 = val2, ...}
            output.push_str("(")
            output.push_str(TIL_PREFIX)
            output.push_str(func_name)
            output.push_str(")")

            // Build map of named arg values
            mut named_values := Map.new(Str, Expr)
            mut na_idx := 1
            while na_idx.lt(expr.params.len()) {
                mut na_arg := Expr()
                expr.params.get(na_idx, na_arg)?
                switch na_arg.node_type {
                case NodeType.NamedArg(field_name):
                    if not(na_arg.params.is_empty()) {
                        mut na_value_expr := Expr()
                        na_arg.params.get(0, na_value_expr)?
                        named_values.set(field_name.clone(), na_value_expr.clone())
                    }
                case:
                    // REM: not a named arg
                }
                na_idx.inc()
            }

            if struct_def.members.is_empty().or(struct_def.default_values.is_empty()) {
                output.push_str("{}")
            } else {
                output.push_str("{")
                mut first := true
                for member: Declaration in struct_def.members {
                    if not(member.is_mut) {
                        continue
                    }
                    if not(first) {
                        output.push_str(", ")
                    }
                    first = false
                    output.push_str(".")
                    output.push_str(member.name)
                    output.push_str(" = ")
                    // Use named arg value if provided, otherwise use default
                    // Bug #143: At expression level, use emit_expr - caller should have used emit_arg_string for hoisting
                    if named_values.contains_key(member.name) {
                        mut member_value_expr := Expr()
                        named_values.get(member.name, member_value_expr)?
                        emit_expr(member_value_expr, output, 0, ctx, context)?
                    } else {
                        mut default_expr := Expr()
                        struct_def.default_values.get(member.name, default_expr)?
                        emit_expr(default_expr, output, 0, ctx, context)?
                        catch (err: KeyNotFoundError) {
                            output.push_str("0")
                        }
                    }
                }
                output.push_str("}")
            }
            return
        }
        catch (err: KeyNotFoundError) {
            // REM: not a struct, continue below
        }
    }

    indent_str := repeat("    ", indent)

    // Statement level vs expression level:
    // - indent > 0: statement level (can emit hoisting statements, adds semicolon)
    // - indent == 0: expression level (nested in larger expression, no hoisting, no semicolons)
    is_stmt_level := indent.gt(0)

    // Get variadic info to know which args are variadic (need different handling)
    mut variadic_regular_count := 9999999
    mut have_variadic_info := true
    mut variadic_info_check := VariadicFCallInfo()
    ctx.func_variadic_args.get(orig_func_name, variadic_info_check)?
    variadic_regular_count = variadic_info_check.regular_count
    catch (err: KeyNotFoundError) {
        have_variadic_info = false
    }

    // Bug #143: Process ALL args upfront using single-pass emit_arg_string
    mut arg_strings := Vec.new(Str)
    if is_stmt_level.and(expr.params.len().gt(1)) {
        // Get param info for by-ref handling
        mut param_info := Vec.new(ParamTypeInfo)
        fd := get_fcall_func_def(context, expr)?
        for fd_arg: Declaration in fd.args {
            mut pi := ParamTypeInfo()
            pi.value_type = fd_arg.value_type
            pi.has_value_type = true
            pi.by_ref = param_needs_by_ref(fd_arg)
            param_info.push(pi)
        }
        catch (err: KeyNotFoundError) {
            // Handle builtins that don't have function definitions
            if orig_func_name.eq("enum_to_str").or(orig_func_name.eq("type_as_str")) {
                // These builtins take Dynamic arg - need proper hoisting
                mut builtin_pi := ParamTypeInfo()
                builtin_pi.value_type = ValueType.TCustom("Dynamic")
                builtin_pi.has_value_type = true
                builtin_pi.by_ref = false
                param_info.push(builtin_pi)
            }
        }
        mut prep_i := 0
        mut prep_arg_idx := 1
        while prep_arg_idx.lt(expr.params.len()) {
            mut prep_arg := Expr()
            expr.params.get(prep_arg_idx, prep_arg)?
            // For variadic args (i >= regular_count), use by_ref=false because
            // they get stored in temp vars, not passed directly to the function.
            prep_is_variadic_arg := prep_i.gteq(variadic_regular_count)
            mut prep_param_type := Ptr()
            mut prep_by_ref := false
            if prep_i.lt(param_info.len()) {
                mut prep_loop_pi := ParamTypeInfo()
                param_info.get(prep_i, prep_loop_pi)?
                prep_param_type.data = to_ptr(prep_loop_pi.value_type)
                if prep_is_variadic_arg {
                    prep_by_ref = false
                } else {
                    prep_by_ref = prep_loop_pi.by_ref
                }
            }
            prep_arg_str := emit_arg_string(prep_arg, prep_param_type, prep_by_ref, output, indent, ctx, context)?
            arg_strings.push(prep_arg_str)
            prep_i.inc()
            prep_arg_idx.inc()
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Hardcoded builtins (compile-time intrinsics that can't be implemented in TIL)
    if orig_func_name.eq("type_as_str") {
        // type_as_str(T) - get type name as string
        if expr.params.len().lt(2) {
            throw "ccodegen: type_as_str requires 1 argument"
        }
        mut type_arg := Expr()
        expr.params.get(1, type_arg)?
        switch type_arg.node_type {
        case NodeType.Identifier(type_name):
            // Check if this is a Type variable or a literal type name
            mut is_type_var := false
            sym := context.scope_stack.lookup_symbol(type_name)?
            switch sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    is_type_var = true
                }
            case:
                // REM: not Type
            }
            catch (err: KeyNotFoundError) {
                // REM: symbol not found
            }
            if is_type_var {
                // Type variable - already a const char*, wrap in Str struct literal
                // Use new Str format with Ptr { data, is_borrowed=1 }
                output.push_str("((")
                output.push_str(TIL_PREFIX)
                output.push_str("Str){((")
                output.push_str(TIL_PREFIX)
                output.push_str("Ptr){(")
                output.push_str(TIL_PREFIX)
                output.push_str("I64)")
                output.push_str(TIL_PREFIX)
                output.push_str(type_name)
                output.push_str(", 1}), strlen(")
                output.push_str(TIL_PREFIX)
                output.push_str(type_name)
                output.push_str("), 0})")
            } else {
                // Literal type name - create Str compound literal
                _ := context.scope_stack.lookup_struct("Str")?
                emit_str_literal(type_name, output)
                catch (err: KeyNotFoundError) {
                    output.push_str("\"")
                    output.push_str(type_name)
                    output.push_str("\"")
                }
            }
        case:
            emit_str_literal("unknown", output)
        }
        return
    } else if orig_func_name.eq("enum_to_str") {
        // enum_to_str(e) - get enum variant name as string
        if expr.params.len().lt(2) {
            throw "ccodegen: enum_to_str requires 1 argument"
        }
        mut enum_arg := Expr()
        expr.params.get(1, enum_arg)?
        value_type := get_value_type(context, enum_arg)?
        switch value_type {
        case ValueType.TCustom(enum_type_name):
            // Verify it's an enum type
            _ := context.scope_stack.lookup_enum(enum_type_name)?
            if true { // TODO Bug #96 workaround
                output.push_str(til_name(enum_type_name))
                output.push_str("_to_str(")
                // Bug #143: At expression level, just use & - caller handles hoisting via emit_arg_string
                output.push_str("&")
                emit_expr(enum_arg, output, 0, ctx, context)?
                output.push_str(")")
                return
            }
            catch (err: KeyNotFoundError) {
                mut err_msg := "ccodegen: enum_to_str argument '"
                err_msg.push_str(enum_type_name)
                err_msg.push_str("' is not an enum type")
                throw err_msg
            }
        case:
            throw "ccodegen: enum_to_str argument has non-custom type"
        }
    } else if orig_func_name.eq("enum_get_payload") {
        // enum_get_payload(e, payload_type, out) - extract enum payload into out parameter
        // Emits call to til_enum_get_payload runtime function
        if expr.params.len().lt(4) {
            throw "ccodegen: enum_get_payload requires 3 arguments"
        }
        mut payload_enum_arg := Expr()
        expr.params.get(1, payload_enum_arg)?
        mut payload_type_arg := Expr()
        expr.params.get(2, payload_type_arg)?
        mut payload_out_arg := Expr()
        expr.params.get(3, payload_out_arg)?

        output.push_str(TIL_PREFIX)
        output.push_str("enum_get_payload((")
        output.push_str(TIL_PREFIX)
        output.push_str("Dynamic*)&")
        emit_expr(payload_enum_arg, output, 0, ctx, context)?
        output.push_str(", &")
        // Emit type argument as Str (similar to size_of handling)
        switch payload_type_arg.node_type {
        case NodeType.Identifier(payload_type_name):
            // Check if this is a Type variable or a literal type name
            mut payload_is_type_var := false
            payload_sym := context.scope_stack.lookup_symbol(payload_type_name)?
            switch payload_sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    payload_is_type_var = true
                }
            case:
                // REM: not Type
            }
            catch (err: KeyNotFoundError) {
                // REM: symbol not found
            }
            if payload_is_type_var {
                // Type variable - wrap in Str struct literal
                // Use new Str format with Ptr { data, is_borrowed=1 }
                output.push_str("((")
                output.push_str(TIL_PREFIX)
                output.push_str("Str){((")
                output.push_str(TIL_PREFIX)
                output.push_str("Ptr){(")
                output.push_str(TIL_PREFIX)
                output.push_str("I64)")
                output.push_str(TIL_PREFIX)
                output.push_str(payload_type_name)
                output.push_str(", 1}), strlen(")
                output.push_str(TIL_PREFIX)
                output.push_str(payload_type_name)
                output.push_str("), 0})")
            } else {
                // Literal type name - create Str compound literal
                emit_str_literal(payload_type_name, output)
            }
        case:
            throw "ccodegen: enum_get_payload type argument must be a type name"
        }
        output.push_str(", (")
        output.push_str(TIL_PREFIX)
        output.push_str("Dynamic*)&")
        emit_expr(payload_out_arg, output, 0, ctx, context)?
        output.push_str(");")
        return
    } else if orig_func_name.eq("size_of") {
        // size_of(T) - runtime type size lookup via til_size_of function
        if expr.params.len().lt(2) {
            throw "ccodegen: size_of requires 1 argument"
        }
        output.push_str(TIL_PREFIX)
        output.push_str("size_of(&")
        mut size_type_arg := Expr()
        expr.params.get(1, size_type_arg)?
        switch size_type_arg.node_type {
        case NodeType.Identifier(type_name):
            // Check if this is a Type variable or a literal type name
            mut size_is_type_var := false
            size_sym := context.scope_stack.lookup_symbol(type_name)?
            switch size_sym.value_type {
            case ValueType.TCustom(t):
                if t.eq("Type") {
                    size_is_type_var = true
                }
            case:
                // REM: not Type
            }
            catch (err: KeyNotFoundError) {
                // REM: symbol not found
            }
            if size_is_type_var {
                // Type variable - already a const char*, wrap in Str struct literal
                // Use new Str format with Ptr { data, is_borrowed=1 }
                output.push_str("((")
                output.push_str(TIL_PREFIX)
                output.push_str("Str){((")
                output.push_str(TIL_PREFIX)
                output.push_str("Ptr){(")
                output.push_str(TIL_PREFIX)
                output.push_str("I64)")
                output.push_str(TIL_PREFIX)
                output.push_str(type_name)
                output.push_str(", 1}), strlen(")
                output.push_str(TIL_PREFIX)
                output.push_str(type_name)
                output.push_str("), 0})")
            } else {
                // Literal type name - create Str compound literal
                emit_str_literal(type_name, output)
            }
        case:
            // Not an identifier - emit as expression
            // Use new Str format with Ptr { data, is_borrowed=1 }
            output.push_str("((")
            output.push_str(TIL_PREFIX)
            output.push_str("Str){((")
            output.push_str(TIL_PREFIX)
            output.push_str("Ptr){(")
            output.push_str(TIL_PREFIX)
            output.push_str("I64)")
            emit_expr(size_type_arg, output, 0, ctx, context)?
            output.push_str(", 1}), strlen(")
            emit_expr(size_type_arg, output, 0, ctx, context)?
            output.push_str("), 0})")
        }
        output.push_str(")")
        return
    } else if orig_func_name.eq("to_ptr") {
        // to_ptr(var) - get address of variable
        if expr.params.len().lt(2) {
            throw "ccodegen: to_ptr requires 1 argument"
        }
        mut ptr_arg := Expr()
        expr.params.get(1, ptr_arg)?
        // Check if ptr_arg is a Dynamic parameter (void*) - just use the pointer directly
        mut is_dynamic_param := false
        switch ptr_arg.node_type {
        case NodeType.Identifier(name):
            if ptr_arg.params.is_empty() {
                ptr_sym := context.scope_stack.lookup_symbol(name)?
                switch ptr_sym.value_type {
                case ValueType.TCustom(t):
                    if t.eq("Dynamic") {
                        is_dynamic_param = true
                    }
                case:
                    // REM: not Dynamic
                }
                catch (err: KeyNotFoundError) {
                    // REM: symbol not found
                }
            }
        case:
            // REM: not identifier
        }
        output.push_str("(")
        output.push_str(TIL_PREFIX)
        output.push_str("I64)")
        if is_dynamic_param {
            // Dynamic param: just output the variable name (it's already a pointer)
            switch ptr_arg.node_type {
            case NodeType.Identifier(name):
                output.push_str(til_name(name))
            case:
                // REM: should not happen
            }
        } else {
            // Bug #143: At expression level, just use & - caller handles hoisting via emit_arg_string
            output.push_str("&")
            emit_expr(ptr_arg, output, 0, ctx, context)?
        }
        return
    }

    // User-defined function call
    output.push_str(indent_str)

    // Check for type-qualified call on FCall result: func_name(fcall_result, args...)
    if first_param.params.is_empty().and(expr.params.len().gteq(2)) {
        mut second_param := Expr()
        expr.params.get(1, second_param)?
        switch second_param.node_type {
        case NodeType.FCall(_):
            fcall_ret_type := get_value_type(context, second_param)?
            switch fcall_ret_type {
            case ValueType.TCustom(type_name):
                mut candidate := type_name.clone()
                candidate.push_str(".")
                candidate.push_str(orig_func_name)
                _ := context.scope_stack.lookup_func(candidate)?
                if true { // TODO Bug #96 workaround
                    // Emit as Type_method(fcall_result, args...)
                    output.push_str(TIL_PREFIX)
                    output.push_str(type_name)
                    output.push_str("_")
                    output.push_str(orig_func_name)
                    output.push_str("(")
                    emit_expr(second_param, output, 0, ctx, context)?
                    mut ri := 2
                    while ri.lt(expr.params.len()) {
                        output.push_str(", ")
                        mut remaining_arg := Expr()
                        expr.params.get(ri, remaining_arg)?
                        emit_expr(remaining_arg, output, 0, ctx, context)?
                        ri.inc()
                    }
                    output.push_str(")")
                    if is_stmt_level {
                        output.push_str(";\n")
                    }
                    return
                }
                catch (err: KeyNotFoundError) {
                    // REM: function not found, continue below
                }
            case:
                // REM: not TCustom
            }
            catch (err: Str) {
                // REM: get_value_type failed, continue below
            }
        case:
            // REM: not FCall
        }
    }

    // Check for struct construction: TypeName() -> (til_TypeName){defaults...}
    mut struct_def_opt_exists := true
    struct_def_opt := context.scope_stack.lookup_struct(func_name)?
    catch (err: KeyNotFoundError) {
        struct_def_opt_exists = false
    }

    if struct_def_opt_exists {
    if expr.params.len().eq(1) {
        // Use the struct definition to get default values
        if struct_def_opt.members.is_empty().or(struct_def_opt.default_values.is_empty()) {
            output.push_str("(")
            output.push_str(TIL_PREFIX)
            output.push_str(func_name)
            output.push_str("){}")
        } else {
            // Bug #143: emit_fcall_arg_string handles throwing defaults via emit_arg_string

            output.push_str(indent_str)
            output.push_str("(")
            output.push_str(TIL_PREFIX)
            output.push_str(func_name)
            output.push_str("){")
            mut member_first := true
            for member: Declaration in struct_def_opt.members {
                if not(member.is_mut) {
                    continue
                }
                if not(member_first) {
                    output.push_str(", ")
                }
                member_first = false
                output.push_str(".")
                output.push_str(member.name)
                output.push_str(" = ")
                mut out_default_expr := Expr()
                struct_def_opt.default_values.get(member.name, out_default_expr)?
                // Bug #143: At expression level, use emit_expr - caller handles hoisting via emit_arg_string
                emit_expr(out_default_expr, output, 0, ctx, context)?
                catch (err: KeyNotFoundError) {
                    output.push_str("0")
                }
            }
            output.push_str("}")
        }

        if is_stmt_level {
            output.push_str(";\n")
        }
        return
    }
    }

    // Regular function call
    // Detect and construct variadic array if needed (only at statement level)
    mut variadic_arr_var := ""
    mut has_variadic_arr := false
    if is_stmt_level.and(have_variadic_info) {
        mut variadic_info := VariadicFCallInfo()
        ctx.func_variadic_args.get(orig_func_name, variadic_info)?
        elem_type := variadic_info.elem_type.clone()
        regular_count := variadic_info.regular_count
        // Bug #143: Use pre-computed arg_strings
        mut variadic_arg_strings := Vec.new(Str)
        mut vi := regular_count
        while vi.lt(arg_strings.len()) {
            mut varg_str := ""
            arg_strings.get(vi, varg_str)?
            variadic_arg_strings.push(varg_str)
            vi.inc()
        }
        variadic_arr_var = emit_variadic_array_with_strings(elem_type, variadic_arg_strings, output, indent, ctx)?
        has_variadic_arr = true
        catch (err: KeyNotFoundError) {
            panic(loc(), "func_variadic_args.get failed: ", err.msg)
        }
        catch (err: IndexOutOfBoundsError) {
            panic(loc(), "arg_strings indexing failed: ", err.msg)
        }
    }

    // Check if this is an enum variant constructor (Type.Variant or Type_Variant)
    mut is_enum_constructor := false
    if func_name.contains("_") {
        parts := func_name.split("_")?
        if parts.len().gteq(2) {
            mut type_name_part := ""
            parts.get(0, type_name_part)?
            mut variant_name_part := ""
            parts.get(1, variant_name_part)?
            mut ctor_have_enum_def := true
            enum_def := context.scope_stack.lookup_enum(type_name_part)?
            catch (err: KeyNotFoundError) {
                ctor_have_enum_def = false
            }
            if ctor_have_enum_def {
                if enum_def.contains_key(variant_name_part)? {
                    is_enum_constructor = true
                }
            }
        }
    }

    output.push_str(TIL_PREFIX)
    if is_enum_constructor {
        ctor_parts := func_name.split("_")?
        mut ctor_type_name_part := ""
        ctor_parts.get(0, ctor_type_name_part)?
        mut ctor_variant_name_part := ""
        ctor_parts.get(1, ctor_variant_name_part)?
        output.push_str(ctor_type_name_part)
        output.push_str("_make_")
        output.push_str(ctor_variant_name_part)
    } else {
        output.push_str(func_name)
    }
    output.push_str("(")

    // Check if this is a variadic function call
    if have_variadic_info {
        mut var_fcall_info := VariadicFCallInfo()
        ctx.func_variadic_args.get(orig_func_name, var_fcall_info)?
        var_regular_count := var_fcall_info.regular_count

        // Bug #143: Use pre-computed arg_strings
        if is_stmt_level {
            // Emit regular args from arg_strings
            mut vstmt_arg_i := 0
            while vstmt_arg_i.lt(var_regular_count) {
                if vstmt_arg_i.gt(0) {
                    output.push_str(", ")
                }
                mut vstmt_arg_str := ""
                arg_strings.get(vstmt_arg_i, vstmt_arg_str)?
                output.push_str(vstmt_arg_str)
                vstmt_arg_i.inc()
            }
        } else {
            // Expression-level variadic calls - emit regular args with by-ref handling
            mut var_param_info := Vec.new(ParamTypeInfo)
            var_fd := get_fcall_func_def(context, expr)?
            for fd_arg: Declaration in var_fd.args {
                mut var_pi := ParamTypeInfo()
                var_pi.value_type = fd_arg.value_type
                var_pi.has_value_type = true
                var_pi.by_ref = param_needs_by_ref(fd_arg)
                var_param_info.push(var_pi)
            }
            catch (err: KeyNotFoundError) {
                // REM: function not found
            }
            mut vexpr_arg_i := 0
            mut vexpr_arg_idx := 1
            while vexpr_arg_i.lt(var_regular_count) {
                if vexpr_arg_i.gt(0) {
                    output.push_str(", ")
                }
                mut vexpr_arg := Expr()
                expr.params.get(vexpr_arg_idx, vexpr_arg)?
                mut vexpr_by_ref := false
                if vexpr_arg_i.lt(var_param_info.len()) {
                    mut vexpr_loop_pi := ParamTypeInfo()
                    var_param_info.get(vexpr_arg_i, vexpr_loop_pi)?
                    vexpr_by_ref = vexpr_loop_pi.by_ref
                }
                if vexpr_by_ref.and(is_pure_lvalue(vexpr_arg, context)) {
                    switch vexpr_arg.node_type {
                    case NodeType.Identifier(name):
                        if vexpr_arg.params.is_empty().and(ctx.current_ref_params.contains(name).or(ctx.current_variadic_params.contains_key(name))) {
                            // Already a pointer - emit name directly without dereference
                            output.push_str(til_name(name))
                        } else {
                            output.push_str("&")
                            emit_expr(vexpr_arg, output, 0, ctx, context)?
                        }
                    case:
                        output.push_str("&")
                        emit_expr(vexpr_arg, output, 0, ctx, context)?
                    }
                } else {
                    emit_expr(vexpr_arg, output, 0, ctx, context)?
                }
                vexpr_arg_i.inc()
                vexpr_arg_idx.inc()
            }
        }

        // Emit variadic array pointer
        if has_variadic_arr {
            if var_regular_count.gt(0) {
                output.push_str(", ")
            }
            output.push_str("&")
            output.push_str(variadic_arr_var)
        }
        catch (err: KeyNotFoundError) {
            // REM: variadic info lookup failed
        }
    } else {
        // Regular non-variadic function call
        // Bug #143: Use pre-computed arg_strings
        if is_stmt_level {
            mut nstmt_arg_i := 0
            while nstmt_arg_i.lt(arg_strings.len()) {
                if nstmt_arg_i.gt(0) {
                    output.push_str(", ")
                }
                mut nstmt_arg_str := ""
                arg_strings.get(nstmt_arg_i, nstmt_arg_str)?
                output.push_str(nstmt_arg_str)
                nstmt_arg_i.inc()
            }
        } else {
            // Expression-level call: emit args with by-ref handling
            mut nv_param_info := Vec.new(ParamTypeInfo)
            nv_fd := get_fcall_func_def(context, expr)?
            for fd_arg: Declaration in nv_fd.args {
                mut nv_pi := ParamTypeInfo()
                nv_pi.value_type = fd_arg.value_type
                nv_pi.has_value_type = true
                nv_pi.by_ref = param_needs_by_ref(fd_arg)
                nv_param_info.push(nv_pi)
            }
            catch (err: KeyNotFoundError) {
                // REM: function not found
            }

            // Bug #143: Process all args through emit_arg_string to handle hoisting
            mut nexpr_arg_hoist := ""
            mut nexpr_arg_strings := Vec.new(Str)
            mut nexpr_arg_i := 0
            mut nexpr_expr_i := 1
            while nexpr_expr_i.lt(expr.params.len()) {
                mut nexpr_arg := Expr()
                expr.params.get(nexpr_expr_i, nexpr_arg)?
                // Check if nexpr_arg is a type identifier - emit as string literal
                mut nexpr_type_arg_name := ""
                nexpr_type_arg_name = get_type_arg_name(nexpr_arg, context)?
                catch (err: KeyNotFoundError) {
                    nexpr_type_arg_name = ""
                }
                if not(nexpr_type_arg_name.is_empty()) {
                    nexpr_arg_strings.push(format("\"", nexpr_type_arg_name, "\""))
                } else {
                    mut nexpr_param_type := Ptr()
                    mut nexpr_by_ref := false
                    if nexpr_arg_i.lt(nv_param_info.len()) {
                        mut nexpr_loop_pi := ParamTypeInfo()
                        nv_param_info.get(nexpr_arg_i, nexpr_loop_pi)?
                        nexpr_param_type.data = to_ptr(nexpr_loop_pi.value_type)
                        nexpr_by_ref = nexpr_loop_pi.by_ref
                    }
                    nexpr_arg_str := emit_arg_string(nexpr_arg, nexpr_param_type, nexpr_by_ref, nexpr_arg_hoist, indent, ctx, context)?
                    nexpr_arg_strings.push(nexpr_arg_str)
                }
                nexpr_arg_i.inc()
                nexpr_expr_i.inc()
            }

            // Emit the collected arg strings
            mut nexpr_first_arg := true
            for nexpr_out_str: Str in nexpr_arg_strings {
                if not(nexpr_first_arg) {
                    output.push_str(", ")
                }
                nexpr_first_arg = false
                output.push_str(nexpr_out_str)
            }
        }
    }

    output.push_str(")")
    if is_stmt_level {
        output.push_str(";\n")
    }

    // Emit Array.delete if variadic array was constructed
    if has_variadic_arr {
        output.push_str(indent_str)
        output.push_str(TIL_PREFIX)
        output.push_str("Array_delete(&")
        output.push_str(variadic_arr_var)
        output.push_str(");\n")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
}

// Emit a Str literal as a compound literal
// is_borrowed=1 for string literals (they point to static .rodata, don't free)
emit_str_literal := proc(s: Str, mut output: Str) {
    // Str { c_string: Ptr { data: I64, is_borrowed: I64 }, _len: I64, cap: I64 }
    output.push_str("((")
    output.push_str(TIL_PREFIX)
    output.push_str("Str){((")
    output.push_str(TIL_PREFIX)
    output.push_str("Ptr){(")
    output.push_str(TIL_PREFIX)
    output.push_str("I64)\"")
    // Escape special characters for C string literals
    mut i := 0
    while i.lt(s.len()) {
        c := s.char_at(i)
        null_byte := U8.from_i64(0)?
        newline := U8.from_i64(10)?
        carriage_return := U8.from_i64(13)?
        tab := U8.from_i64(9)?
        backslash := U8.from_i64(92)?
        quote := U8.from_i64(34)?
        if c.eq(null_byte) {
            output.push_str("\\0")
        } else if c.eq(newline) {
            output.push_str("\\n")
        } else if c.eq(carriage_return) {
            output.push_str("\\r")
        } else if c.eq(tab) {
            output.push_str("\\t")
        } else if c.eq(backslash) {
            output.push_str("\\\\")
        } else if c.eq(quote) {
            output.push_str("\\\"")
        } else {
            char_str := s.get_substr(i, add(i, 1))?
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "IndexOutOfBoundsError in emit_str_literal: ", err.msg)
            }
            output.push_str(char_str)
        }
        i.inc()
        catch (err: U8_Overflow) {
            panic(loc(), "U8_Overflow: ASCII values are valid U8, should never happen: ", err.msg)
        }
    }
    // Close Ptr (data, is_borrowed=1), then Str (c_string, _len, cap=0 for literals)
    output.push_str("\", 1}), ")
    output.push_str(s.len().to_str())
    output.push_str(", 0})")
}

emit_literal := proc(lit: Literal, mut output: Str, context: Context) throws Str {
    switch lit {
    case Literal.Str(s):
        _has_str := context.scope_stack.lookup_struct("Str")?
        emit_str_literal(s, output)
        catch (err: KeyNotFoundError) {
            // No Str struct - emit raw string
            output.push_str("\"")
            // Escape special characters for C string literals
            mut j := 0
            while j.lt(s.len()) {
                c := s.char_at(j)
                null_byte := U8.from_i64(0)?
                newline := U8.from_i64(10)?
                carriage_return := U8.from_i64(13)?
                tab := U8.from_i64(9)?
                backslash := U8.from_i64(92)?
                quote := U8.from_i64(34)?
                if c.eq(null_byte) {
                    output.push_str("\\0")
                } else if c.eq(newline) {
                    output.push_str("\\n")
                } else if c.eq(carriage_return) {
                    output.push_str("\\r")
                } else if c.eq(tab) {
                    output.push_str("\\t")
                } else if c.eq(backslash) {
                    output.push_str("\\\\")
                } else if c.eq(quote) {
                    output.push_str("\\\"")
                } else {
                    output.push_str(c.to_str())
                }
                j.inc()
                catch (err: U8_Overflow) {
                    panic(loc(), "U8_Overflow: ASCII values are valid U8, should never happen: ", err.msg)
                }
            }
            output.push_str("\"")
        }
    case Literal.Number(n):
        output.push_str(n)
    case Literal.List(_):
        throw "ccodegen: List literals not yet supported"
    }
}
