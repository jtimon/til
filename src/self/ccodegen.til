mode lib

// C code generator for TIL
// Translates TIL AST to C source code

import("src.self.parser")  // Expr, NodeType, Literal

// Prefix for all TIL-generated C names (structs, functions, etc.)
TIL_PREFIX := "til_"

// Global counter for generating unique mangled names
mut MANGLING_COUNTER: I64 = 0

// Info about a variadic parameter
VariadicParamInfo := struct {
    mut arg_name: Str = ""
    mut elem_type: Str = ""
    mut regular_count: I64 = 0
}

// Codegen context for tracking function info during code generation
CodegenContext := struct {
    // Map function name -> variadic arg info (Map<Str, VariadicParamInfo>)
    mut func_variadic_args: Map = Map.new(Str, VariadicParamInfo)
    // Currently generating function's throw types (if any)
    mut current_throw_types: Vec = Vec.new(ValueType)
    // Currently generating function's return types (if any)
    mut current_return_types: Vec = Vec.new(ValueType)
    // Current function's variadic param (if any)
    mut current_variadic_param: VariadicParamInfo = VariadicParamInfo()
    mut has_variadic_param: Bool = false
    // Set of declared variable names in current function (to avoid redefinition) - Vec<Str>
    mut declared_vars: Vec = Vec.new(Str)
}

// Helper to check if Str struct is defined in context
has_str := func(context: Context) returns Bool {
    mut found := false
    _ := context.scope_stack.lookup_struct("Str")
    found = true
    catch (err: KeyNotFoundError) { }
    return found
}

// Generate unique mangled name using global counter
next_mangled := proc() returns Str {
    mut name := concat("_tmp", MANGLING_COUNTER.to_str())
    MANGLING_COUNTER = add(MANGLING_COUNTER, 1)
    return name
}

// Returns the C name for a TIL identifier - adds TIL_PREFIX
// Exceptions: C keywords/macros (true, false) and generated names (* or _ prefix)
til_name := func(name: Str) returns Str {
    if name.eq("true") { return "true" }
    if name.eq("false") { return "false" }
    if name.starts_with("*") { return name }
    if name.starts_with("_") { return name }
    return concat(TIL_PREFIX, name)
}

// Add a variable to declared_vars (if not already present)
add_var_declared := proc(mut ctx: CodegenContext, name: Str) throws AllocError {
    if not(ctx.declared_vars.contains(name)) {
        ctx.declared_vars.push(name)
    }
}

// Result type for receiver type lookup
ReceiverTypeResult := struct {
    mut found: Bool = false
    mut value_type: ValueType = ValueType.TCustom("")
}

// Look up receiver type from scope_stack
lookup_receiver_type := func(context: Context, name: Str) returns ReceiverTypeResult {
    mut result := ReceiverTypeResult()
    mut symbol := context.scope_stack.lookup_symbol(name)
    result.found = true
    result.value_type = symbol.value_type
    catch (err: KeyNotFoundError) { }
    return result
}

// Convert TIL type to C type
til_type_to_c := func(til_type: ValueType) returns Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq("Str") { return "const char*" }
        else { return concat(TIL_PREFIX, name) }  // All types get til_ prefix
    case:
        return "int"  // Default
    }
}

// Result type for lookup_func_by_name
FuncLookupResult := struct {
    mut found: Bool = false
    mut func_def: SFuncDef = SFuncDef()
}

// Lookup function in scope_stack, trying both underscore and dot notation
// get_fcall_func_name returns underscore format (Str_clone) but scope_stack uses dots (Str.clone)
lookup_func_by_name := func(context: Context, func_name: Str) returns FuncLookupResult {
    mut result := FuncLookupResult()
    // Try exact name first (for regular functions)
    mut fd := context.scope_stack.lookup_func(func_name)
    result.found = true
    result.func_def = fd

    catch (err: KeyNotFoundError) {
        // First lookup failed, try converting first underscore to dot (for struct methods)
        mut idx := func_name.find("_")
        if idx.gteq(0) {
            mut dot_name := func_name.get_substr(0, idx)
            dot_name = concat(dot_name, ".")
            dot_name = concat(dot_name, func_name.get_substr(add(idx, 1), func_name.len()))
            mut fd2 := context.scope_stack.lookup_func(dot_name)
            result.found = true
            result.func_def = fd2

            catch (err2: KeyNotFoundError) { }
            catch (err2: IndexOutOfBoundsError) { }
            catch (err2: AllocError) { }
        }
    }

    return result
}

// Helper to get C type name for a ValueType (same as til_type_to_c but for error struct definitions)
value_type_to_c_name := func(vt: ValueType) returns Str {
    switch vt {
    case ValueType.TCustom(name):
        if name.eq("Str") { return "const char*" }
        else { return concat(TIL_PREFIX, name) }  // All types get til_ prefix
    case:
        return "int"
    }
}

// Result type for check_throwing_fcall
ThrowingFCallInfo := struct {
    mut is_throwing: Bool = false
    mut func_name: Str = ""
    mut throw_types: Vec = Vec.new(ValueType)
    mut return_type: ValueType = ValueType.TCustom("")
    mut has_return_type: Bool = false
}

// Result type for hoisted arguments
HoistedArg := struct {
    mut index: I64 = 0
    mut temp_var: Str = ""
}

// Forward declaration - get_fcall_func_name is defined later in the file
// We'll use a simplified version here that just gets the basic name

// Check if an expression is a throwing function call
// Returns info about the throwing call if it is one
check_throwing_fcall := proc(expr: Expr, ctx: CodegenContext, context: Context) returns ThrowingFCallInfo {
    mut result := ThrowingFCallInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // Get function name (simplified - just basic name extraction)
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            mut func_name := ""
            switch first.node_type {
            case NodeType.Identifier(name):
                if gt(first.params.len(), 0) {
                    // UFCS: receiver.method - method is the LAST param (AST is flat)
                    mut method_idx := sub(first.params.len(), 1)
                    mut method_expr := Expr()
                    first.params.get(method_idx, method_expr)
                    switch method_expr.node_type {
                    case NodeType.Identifier(method_name):
                        func_name = method_name
                    case:
                        // Not identifier
                    }
                    catch (err: IndexOutOfBoundsError) { }
                } else {
                    func_name = name
                }
            case:
                // Not identifier
            }
            catch (err: IndexOutOfBoundsError) { }

            if gt(func_name.len(), 0) {
                mut lookup_result := lookup_func_by_name(context, func_name)
                if lookup_result.found {
                    if gt(lookup_result.func_def.throw_types.len(), 0) {
                        result.is_throwing = true
                        result.func_name = func_name
                        result.throw_types = lookup_result.func_def.throw_types
                        if gt(lookup_result.func_def.return_types.len(), 0) {
                            mut first_ret := ValueType.TCustom("")
                            lookup_result.func_def.return_types.get(0, first_ret)
                            result.return_type = first_ret
                            result.has_return_type = true
                            catch (err: IndexOutOfBoundsError) { }
                        }
                    }
                }
            }
        }
    case:
        // Not an FCall
    }
    return result
}

// Collect function info (throw types and return types) from AST into context
// Handles both top-level functions and struct methods
collect_func_info := proc(expr: Expr, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Top-level function - check for variadic args
                mut ai := 0
                while lt(ai, func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(ai, arg)
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        mut info := VariadicParamInfo()
                        info.arg_name = arg.name
                        info.elem_type = elem_type_name
                        info.regular_count = ai  // number of args before variadic
                        ctx.func_variadic_args.insert(decl.name, info)
                    case:
                        // Not variadic, continue
                    }
                    ai = add(ai, 1)
                }
                catch (err: IndexOutOfBoundsError) { /* ignore */ }
            case NodeType.StructDef(struct_def):
                // Struct methods - use mangled names (StructName_methodName)
                mut struct_name := decl.name
                mut keys := struct_def.default_values.keys
                mut i := 0
                while lt(i, keys.len()) {
                    mut member_name := ""
                    keys.get(i, member_name)
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        mut mangled_name := concat(struct_name, "_")
                        mangled_name = concat(mangled_name, member_name)
                        // Check for variadic args
                        mut ai := 0
                        while lt(ai, func_def.args.len()) {
                            mut arg := Declaration()
                            func_def.args.get(ai, arg)
                            switch arg.value_type {
                            case ValueType.TMulti(elem_type_name):
                                mut info := VariadicParamInfo()
                                info.arg_name = arg.name
                                info.elem_type = elem_type_name
                                info.regular_count = ai
                                ctx.func_variadic_args.insert(mangled_name, info)
                            case:
                                // Not variadic, continue
                            }
                            ai = add(ai, 1)
                        }
                        catch (err: IndexOutOfBoundsError) { /* ignore */ }
                    case:
                        // Not a function, skip
                    }
                    catch (err: KeyNotFoundError) { /* skip */ }
                    catch (err: AllocError) { throw err.msg }
                    catch (err: DuplicatedKeyError) { /* skip duplicates */ }
                    i = add(i, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            case:
                // Not a function or struct, skip
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
            catch (err: DuplicatedKeyError) { /* skip duplicates */ }
        }
    case:
        // Not a declaration, skip
    }
}

// Emit function signature (used by both prototype and definition)
// For throwing functions:
//   int func_name(RetType* _ret, Error1* _err1, Error2* _err2, args...)
// For non-throwing:
//   RetType func_name(args...)
emit_func_signature := proc(func_name: Str, func_def: SFuncDef, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut is_throwing := gt(func_def.throw_types.len(), 0)

    if is_throwing {
        // Throwing function returns int status code
        result = concat(result, "int ")
    } else {
        // Non-throwing function returns its actual type
        if eq(func_def.return_types.len(), 0) {
            result = concat(result, "void ")
        } else {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = concat(result, til_type_to_c(ret_type))
            result = concat(result, " ")
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
    }

    result = concat(result, func_name)
    result = concat(result, "(")

    mut param_count := 0

    if is_throwing {
        // Output params first: return value pointer, then error pointers
        if gt(func_def.return_types.len(), 0) {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = concat(result, til_type_to_c(ret_type))
            result = concat(result, "* _ret")
            param_count = add(param_count, 1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        // Error output parameters
        mut i := 0
        while lt(i, func_def.throw_types.len()) {
            if gt(param_count, 0) {
                result = concat(result, ", ")
            }
            mut throw_type := ValueType.TCustom("")
            func_def.throw_types.get(i, throw_type)
            mut err_type := value_type_to_c_name(throw_type)
            result = concat(result, err_type)
            result = concat(result, "* _err")
            result = concat(result, add(i, 1).to_str())
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Input parameters
    mut j := 0
    while lt(j, func_def.args.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        mut arg := Declaration()
        func_def.args.get(j, arg)

        // Check for variadic arg (TMulti)
        switch arg.value_type {
        case ValueType.TMulti(elem_type_name):
            // Variadic: emit count param and ...
            result = concat(result, "int ")
            result = concat(result, arg.name)
            result = concat(result, "_len, ...")
            param_count = add(param_count, 1)
            // Variadic must be last, so break
            j = func_def.args.len()
        case:
            // Regular arg - add const for non-mut
            if not(arg.is_mut) {
                result = concat(result, "const ")
            }
            result = concat(result, til_type_to_c(arg.value_type))
            result = concat(result, " ")
            result = concat(result, arg.name)
            param_count = add(param_count, 1)
            j = add(j, 1)
        }
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    if eq(param_count, 0) {
        result = concat(result, "void")
    }

    result = concat(result, ")")
    return result
}

// Get the function name from an FCall expression
get_fcall_func_name := func(expr: Expr, context: Context) returns Str {
    if eq(expr.params.len(), 0) {
        return ""
    }

    mut first := Expr()
    expr.params.get(0, first)

    switch first.node_type {
    case NodeType.Identifier(name):
        if eq(first.params.len(), 0) {
            // Regular function call
            return name
        } else {
            // UFCS: receiver.method() - method is the LAST param (AST is flat)
            mut method_idx := sub(first.params.len(), 1)
            mut nested := Expr()
            first.params.get(method_idx, nested)
            switch nested.node_type {
            case NodeType.Identifier(method_name):
                // Look up receiver type from scope_stack
                mut receiver_result := lookup_receiver_type(context, name)
                if receiver_result.found {
                    switch receiver_result.value_type {
                    case ValueType.TCustom(type_name):
                        if gt(type_name.len(), 0) {
                            // Check if it's a known struct method
                            mut is_struct_method := false
                            mut candidate := concat(type_name, ".")
                            candidate = concat(candidate, method_name)
                            mut func_def := context.scope_stack.lookup_func(candidate)
                            is_struct_method = true
                            catch (err: KeyNotFoundError) { }

                            if is_struct_method {
                                mut mangled := concat(type_name, "_")
                                mangled = concat(mangled, method_name)
                                return mangled
                            }
                        }
                    case:
                        // Not a custom type, fallback
                    }
                    // Not a struct method, use plain method name
                    return method_name
                }
                // Not found in scope - treat as Type.method (type-qualified call)
                mut result := concat(name, "_")
                result = concat(result, method_name)
                return result
            case:
                return ""
            }
        }
    case:
        return ""
    }

    catch (err: IndexOutOfBoundsError) { return "" }
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Get struct name from a struct declaration expression
// Returns empty string if not a struct declaration
get_struct_name := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return decl.name
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Get struct dependencies (other struct types used as mut fields)
// Returns a Vec of type names (Str) that this struct depends on
get_struct_dependencies := func(expr: Expr) returns Vec {
    mut deps := Vec.new(Str)
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return deps }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    catch (err: IndexOutOfBoundsError) { return deps }
                    if member.is_mut {
                        switch member.value_type {
                        case ValueType.TCustom(type_name):
                            // I64 and U8 are primitives, not struct deps
                            if not(Str.eq(type_name, "I64")) {
                                if not(Str.eq(type_name, "U8")) {
                                    if not(Str.eq(type_name, "auto")) {
                                        deps.push(type_name)
                                    }
                                }
                            }
                        case:
                            // Other types are not struct deps
                        }
                    }
                    i = add(i, 1)
                }
            case:
            }
        }
    case:
    }
    catch (err: AllocError) { }
    return deps
}

// Topologically sort struct declarations by their field dependencies
// Uses Kahn's algorithm. Returns Vec of indices in sorted order.
topological_sort_structs := func(structs: List) returns Vec {
    mut result := Vec.new(I64)
    mut n := structs.len()

    // Build name -> index map
    mut name_to_idx := Map.new(Str, I64)
    mut idx := 0
    while lt(idx, n) {
        mut expr := Expr()
        structs.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut name := get_struct_name(expr)
        if gt(name.len(), 0) {
            name_to_idx.set(name, idx)
        }
        idx = add(idx, 1)
    }

    // Build reverse adjacency list and calculate in-degrees
    // If A depends on B, then B has an edge to A (B must come before A)
    mut reverse_deps := List.new()  // List of Vec(I64)
    mut in_degree := Vec.new(I64)

    // Initialize
    idx = 0
    while lt(idx, n) {
        mut empty_vec := Vec.new(I64)
        reverse_deps.push(Vec, empty_vec)
        in_degree.push(0)
        idx = add(idx, 1)
    }

    // Build edges: for each struct, look at its dependencies
    idx = 0
    while lt(idx, n) {
        mut expr := Expr()
        structs.get(idx, expr)
        catch (err: IndexOutOfBoundsError) { return result }
        mut deps := get_struct_dependencies(expr)
        mut dep_idx := 0
        while lt(dep_idx, deps.len()) {
            mut dep_name := ""
            deps.get(dep_idx, dep_name)
            if name_to_idx.contains_key(dep_name) {
                mut dep_struct_idx := 0
                name_to_idx.get(dep_name, dep_struct_idx)
                catch (err: KeyNotFoundError) { }
                // Skip self-references
                if not(dep_struct_idx.eq(idx)) {
                    // dep_struct_idx has edge to idx (dep must come before this struct)
                    mut dep_edges := Vec.new(I64)
                    reverse_deps.get(dep_struct_idx, dep_edges)
                    catch (err: IndexOutOfBoundsError) { return result }
                    dep_edges.push(idx)
                    // Increment in-degree of idx
                    mut degree := 0
                    in_degree.get(idx, degree)
                    in_degree.set(idx, add(degree, 1))
                }
            }
            dep_idx = add(dep_idx, 1)
        }
        idx = add(idx, 1)
    }

    // Kahn's algorithm: start with nodes that have in-degree 0
    mut queue := Vec.new(I64)
    idx = 0
    while lt(idx, n) {
        mut degree := 0
        in_degree.get(idx, degree)
        if degree.eq(0) {
            queue.push(idx)
        }
        idx = add(idx, 1)
    }

    // Process queue
    while gt(queue.len(), 0) {
        mut current := 0
        queue.pop(current)
        catch (err: IndexOutOfBoundsError) { return result }
        result.push(current)

        // For each struct that depends on current, decrement in-degree
        mut edges := Vec.new(I64)
        reverse_deps.get(current, edges)
        catch (err: IndexOutOfBoundsError) { return result }
        mut edge_idx := 0
        while lt(edge_idx, edges.len()) {
            mut next := 0
            edges.get(edge_idx, next)
            mut degree := 0
            in_degree.get(next, degree)
            degree = sub(degree, 1)
            in_degree.set(next, degree)
            if degree.eq(0) {
                queue.push(next)
            }
            edge_idx = add(edge_idx, 1)
        }
    }

    // If cycle detected, append remaining in original order
    if lt(result.len(), n) {
        idx = 0
        while lt(idx, n) {
            // Check if idx is already in result
            mut found := false
            mut res_idx := 0
            while lt(res_idx, result.len()) {
                mut val := 0
                result.get(res_idx, val)
                if val.eq(idx) {
                    found = true
                }
                res_idx = add(res_idx, 1)
            }
            if not(found) {
                result.push(idx)
            }
            idx = add(idx, 1)
        }
    }

    catch (err: AllocError) { }
    catch (err: IndexOutOfBoundsError) { }
    return result
}

// Check if an expression is an enum declaration (Name := enum {...})
is_enum_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Check if an expression is a top-level constant declaration (name := literal)
// Constants are non-mut declarations with literal values (numbers, strings, bools)
is_constant_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Must not be mutable
        if decl.is_mut {
            return false
        }
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.LLiteral(lit):
                return true
            case NodeType.StructDef(struct_def):
                return false
            case NodeType.EnumDef(enum_def):
                return false
            case NodeType.FuncDef(func_def):
                return false
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a top-level constant declaration at file scope
emit_constant_declaration := proc(expr: Expr, output: Str, ctx: CodegenContext, context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.LLiteral(lit):
                switch lit {
                case Literal.Number(n):
                    // Non-mut declarations are constants
                    if not(decl.is_mut) {
                        result = concat(result, "const ")
                    }
                    result = concat(result, "I64 ")
                    result = concat(result, decl.name)
                    result = concat(result, " = ")
                    result = concat(result, n)
                    result = concat(result, ";\n")
                case Literal.Str(s):
                    if has_str(context) {
                        if not(decl.is_mut) {
                            result = concat(result, "const ")
                        }
                        result = format(result, TIL_PREFIX, "Str ")
                        result = concat(result, decl.name)
                        result = format(result, " = ", TIL_PREFIX, "Str_from_literal(\"")
                        result = concat(result, s)
                        result = concat(result, "\");\n")
                    } else {
                        result = concat(result, "const char* ")
                        result = concat(result, decl.name)
                        result = concat(result, " = \"")
                        result = concat(result, s)
                        result = concat(result, "\";\n")
                    }
                case:
                    // Skip list literals for now
                    result = result
                }
            case:
                result = result
            }
        }
    case:
        result = result
    }

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}

// Emit a struct declaration as a C typedef struct (only mut fields become struct fields)
emit_struct_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip I64, U8, Bool - these are primitive typedefs, not structs
        if decl.name.eq("I64") { return result }
        if decl.name.eq("U8") { return result }
        if decl.name.eq("Bool") { return result }
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                result = concat(result, "typedef struct {\n")
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit mut fields as struct members
                    if member.is_mut {
                        result = concat(result, "    ")
                        result = concat(result, til_type_to_c(member.value_type))
                        result = concat(result, " ")
                        result = concat(result, member.name)
                        result = concat(result, ";\n")
                    }
                    i = add(i, 1)
                }
                result = concat(result, "} ")
                result = concat(result, decl.name)
                result = concat(result, ";\n\n")
                return result
            case:
                throw "emit_struct_declaration: not a struct"
            }
        }
        throw "emit_struct_declaration: empty params"
    case:
        throw "emit_struct_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
emit_struct_constants := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        // Skip I64, U8, Bool - these are primitive typedefs, not structs
        if decl.name.eq("I64") { return result }
        if decl.name.eq("U8") { return result }
        if decl.name.eq("Bool") { return result }
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        // Check if default_value is NOT a function (constants only)
                        mut is_func := false
                        mut default_val := Expr()
                        struct_def.default_values.get(member.name, default_val)
                        switch default_val.node_type {
                        case NodeType.FuncDef(fd):
                            is_func = true
                        case:
                            is_func = false
                        }
                        if not(is_func) {
                            result = concat(result, "const ")
                            result = concat(result, til_type_to_c(member.value_type))
                            result = concat(result, " ")
                            result = concat(result, struct_name)
                            result = concat(result, "_")
                            result = concat(result, member.name)
                            result = concat(result, " = ")
                            result = emit_expr(default_val, result, 0, ctx, context)
                            result = concat(result, ";\n")
                        }
                        catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Check if an enum has any payloads
enum_has_payloads := func(enum_def: SEnumDef) returns Bool {
    mut keys := enum_def.enum_map.keys
    mut i := 0
    while lt(i, keys.len()) {
        mut key := ""
        keys.get(i, key)
        catch (err: IndexOutOfBoundsError) { return false }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(key, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }
        // Check if payload_type is not the default empty value
        switch payload_type {
        case ValueType.TCustom(name):
            if gt(name.len(), 0) {
                return true
            }
        case:
            return true  // Any non-TCustom type means it has a payload
        }
        i = add(i, 1)
    }
    return false
}

// Check if a variant has a payload (non-empty type)
variant_has_payload := func(payload_type: ValueType) returns Bool {
    switch payload_type {
    case ValueType.TCustom(name):
        return gt(name.len(), 0)
    case:
        return true  // Any non-TCustom type means it has a payload
    }
}

// Emit an enum with payloads as a tagged union
emit_enum_with_payloads := proc(enum_name: Str, enum_def: SEnumDef, output: Str) returns Str throws Str {
    mut result := output
    mut variants := enum_def.enum_map.keys

    // 1. Emit tag enum: typedef enum { Color_Unknown = 0, ... } Color_Tag;
    result = concat(result, "typedef enum {\n")
    mut i := 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, "_")
        result = concat(result, variant_name)
        result = concat(result, " = ")
        result = concat(result, i.to_str())
        result = concat(result, ",\n")
        i = add(i, 1)
    }
    result = concat(result, "} ")
    result = concat(result, enum_name)
    result = concat(result, "_Tag;\n\n")

    // 2. Emit payload union (only for variants that have payloads)
    // typedef union { unsigned char Green; long long Number; } Color_Payload;
    mut has_any_payload := false
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(variant_name, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }
        if variant_has_payload(payload_type) {
            has_any_payload = true
        }
        i = add(i, 1)
    }

    if has_any_payload {
        result = concat(result, "typedef union {\n")
        i = 0
        while lt(i, variants.len()) {
            mut variant_name := ""
            variants.get(i, variant_name)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            mut payload_type := ValueType.TCustom("")
            enum_def.enum_map.get(variant_name, payload_type)
            catch (err: KeyNotFoundError) { /* no payload */ }
            if variant_has_payload(payload_type) {
                result = concat(result, "    ")
                result = concat(result, til_type_to_c(payload_type))
                result = concat(result, " ")
                result = concat(result, variant_name)
                result = concat(result, ";\n")
            }
            i = add(i, 1)
        }
        result = concat(result, "} ")
        result = concat(result, enum_name)
        result = concat(result, "_Payload;\n\n")
    }

    // 3. Emit wrapper struct: typedef struct { Color_Tag tag; Color_Payload payload; } Color;
    result = concat(result, "typedef struct {\n")
    result = concat(result, "    ")
    result = concat(result, enum_name)
    result = concat(result, "_Tag tag;\n")
    if has_any_payload {
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, "_Payload payload;\n")
    }
    result = concat(result, "} ")
    result = concat(result, enum_name)
    result = concat(result, ";\n\n")

    // 4. Emit constructor functions for ALL variants (including no-payload ones)
    // This ensures consistent calling convention: Color_make_Red(42), Color_make_Unknown()
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(variant_name, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }

        result = concat(result, "static inline ")
        result = concat(result, enum_name)
        result = concat(result, " ")
        result = concat(result, enum_name)
        result = concat(result, "_make_")
        result = concat(result, variant_name)
        result = concat(result, "(")

        // Parameter for payload (if any)
        if variant_has_payload(payload_type) {
            result = concat(result, til_type_to_c(payload_type))
            result = concat(result, " value) {\n")
        } else {
            result = concat(result, "void) {\n")
        }

        // Constructor body
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, " result = { .tag = ")
        result = concat(result, enum_name)
        result = concat(result, "_")
        result = concat(result, variant_name)
        result = concat(result, " };\n")

        // Set payload if present
        if variant_has_payload(payload_type) {
            result = concat(result, "    result.payload.")
            result = concat(result, variant_name)
            result = concat(result, " = value;\n")
        }

        result = concat(result, "    return result;\n")
        result = concat(result, "}\n\n")

        i = add(i, 1)
    }

    return result
}

// Emit an enum declaration as a C typedef enum (for simple enums without payloads)
// or as a tagged union struct (for enums with payloads)
emit_enum_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := decl.name

                if enum_has_payloads(enum_def) {
                    // Phase 2: Enums with payloads - tagged union
                    return emit_enum_with_payloads(enum_name, enum_def, result)
                }

                // Phase 1: Simple enum without payloads
                // typedef enum { EnumName_Variant1 = 0, ... } EnumName;
                result = concat(result, "typedef enum {\n")

                // Get variant names (order matches insertion order from parser)
                mut variants := enum_def.enum_map.keys

                mut i := 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = concat(result, "    ")
                    result = concat(result, enum_name)
                    result = concat(result, "_")
                    result = concat(result, variant_name)
                    result = concat(result, " = ")
                    result = concat(result, i.to_str())
                    result = concat(result, ",\n")
                    i = add(i, 1)
                }

                result = concat(result, "} ")
                result = concat(result, enum_name)
                result = concat(result, ";\n\n")

                // Generate constructor functions for consistency with payload enums
                // static inline EnumName EnumName_make_Variant(void) { return EnumName_Variant; }
                i = 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = concat(result, "static inline ")
                    result = concat(result, enum_name)
                    result = concat(result, " ")
                    result = concat(result, enum_name)
                    result = concat(result, "_make_")
                    result = concat(result, variant_name)
                    result = concat(result, "(void) { return ")
                    result = concat(result, enum_name)
                    result = concat(result, "_")
                    result = concat(result, variant_name)
                    result = concat(result, "; }\n")
                    i = add(i, 1)
                }
                result = concat(result, "\n")

                return result
            case:
                throw "emit_enum_declaration: not an enum"
            }
        }
        throw "emit_enum_declaration: empty params"
    case:
        throw "emit_enum_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function prototypes with mangled names: StructName_funcname
emit_struct_func_prototypes := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Use emit_func_signature with mangled name
                            mut mangled_name := concat(struct_name, "_")
                            mangled_name = concat(mangled_name, member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = concat(result, ";\n")
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function bodies with mangled names: StructName_funcname
emit_struct_func_bodies := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Set current function context
                            ctx.current_throw_types = func_def.throw_types
                            ctx.current_return_types = func_def.return_types

                            // Clear declared_vars for new function scope
                            ctx.declared_vars = Vec.new(Str)
                            catch (err: AllocError) { throw err.msg }

                            // Use emit_func_signature with mangled name
                            mut mangled_name := concat(struct_name, "_")
                            mangled_name = concat(mangled_name, member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = concat(result, " {\n")

                            // Emit function body with catch pattern detection
                            result = emit_stmts(func_def.body, result, 1, ctx, context)

                            // For throwing void functions, add implicit return 0
                            if gt(func_def.throw_types.len(), 0) {
                                if eq(func_def.return_types.len(), 0) {
                                    result = concat(result, "    return 0;\n")
                                }
                            }

                            result = concat(result, "}\n\n")

                            // Clear current function context
                            ctx.current_throw_types = Vec.new(ValueType)
                            ctx.current_return_types = Vec.new(ValueType)
                            catch (err: AllocError) { throw err.msg }
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* skip member with no default */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr, mut context: Context) returns Str throws Str {
    mut output := ""
    mut ctx := CodegenContext()

    // C boilerplate
    output = concat(output, "#include <stdio.h>\n")
    output = concat(output, "#include <stdlib.h>\n")
    output = concat(output, "#include <string.h>\n\n")
    output = format(output, "typedef unsigned char ", TIL_PREFIX, "U8;\n")
    output = format(output, "typedef long long ", TIL_PREFIX, "I64;\n")
    output = format(output, "typedef struct ", TIL_PREFIX, "Bool { ", TIL_PREFIX, "U8 data; } ", TIL_PREFIX, "Bool;\n")
    output = format(output, "#define true ((", TIL_PREFIX, "Bool){1})\n")
    output = format(output, "#define false ((", TIL_PREFIX, "Bool){0})\n\n")

    // Pass 0: collect function info (throw types, return types) for call-site generation
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            collect_func_info(child, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip collect pass
    }

    // Pass 0b: emit forward declarations for all structs (for pointer cycles/self-references)
    // Skip I64, U8, Bool - these are primitive typedefs, not structs
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                switch child.node_type {
                case NodeType.Declaration(decl):
                    if decl.name.eq("I64") { }
                    else if decl.name.eq("U8") { }
                    else if decl.name.eq("Bool") { }
                    else {
                        output = concat(output, "typedef struct ")
                        output = concat(output, decl.name)
                        output = concat(output, " ")
                        output = concat(output, decl.name)
                        output = concat(output, ";\n")
                    }
                case:
                }
            }
            i = add(i, 1)
        }
        output = concat(output, "\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip forward declarations
    }

    // Pass 1: emit struct definitions (only mut fields become struct members)
    // Use topological sort to handle embedded struct dependencies
    switch ast.node_type {
    case NodeType.Body:
        // Collect all struct declarations
        mut struct_decls := List.new()
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                struct_decls.push(Expr, child)
            }
            i = add(i, 1)
        }

        // Sort by dependencies and emit in order
        mut sorted_indices := topological_sort_structs(struct_decls)
        i = 0
        while lt(i, sorted_indices.len()) {
            mut idx := 0
            sorted_indices.get(i, idx)
            mut struct_expr := Expr()
            struct_decls.get(idx, struct_expr)
            output = emit_struct_declaration(struct_expr, output)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw "AllocError in struct pass" }
    case:
        // Not a body, skip struct pass
    }

    // Pass 1b: emit enum definitions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_enum_declaration(child) {
                output = emit_enum_declaration(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip enum pass
    }

    // Pass 1c: emit helper functions (after structs are defined)
    output = concat(output, "\n// Type conversion helpers\n")
    output = format(output, "static inline ", TIL_PREFIX, "I64 u8_to_i64(", TIL_PREFIX, "U8 v) { return (", TIL_PREFIX, "I64)v; }\n")
    output = format(output, "static inline ", TIL_PREFIX, "U8 i64_to_u8(", TIL_PREFIX, "I64 v) { return (", TIL_PREFIX, "U8)v; }\n")
    if has_str(context) {
        output = concat(output, "// Str helper: create Str from C string literal\n")
        output = format(output, "static inline ", TIL_PREFIX, "Str ", TIL_PREFIX, "Str_from_literal(const char* lit) {\n")
        output = format(output, "    ", TIL_PREFIX, "Str s;\n")
        output = format(output, "    s.c_string = (", TIL_PREFIX, "I64)lit;\n")
        output = concat(output, "    s.cap = strlen(lit);\n")
        output = concat(output, "    return s;\n")
        output = concat(output, "}\n")
        output = concat(output, "// single_print: print a string without newline\n")
        output = format(output, "static inline void single_print(", TIL_PREFIX, "Str s) { printf(\"%s\", (char*)s.c_string); }\n")
    } else {
        output = concat(output, "\n// single_print: print a string without newline (no Str defined)\n")
        output = concat(output, "static inline void single_print(const char* s) { printf(\"%s\", s); }\n")
    }
    output = concat(output, "// print_flush: flush stdout\n")
    output = concat(output, "static inline void print_flush(void) { fflush(stdout); }\n")
    output = concat(output, "// to_ptr: get pointer address as integer\n")
    output = format(output, "static inline ", TIL_PREFIX, "I64 to_ptr(", TIL_PREFIX, "I64* p) { return (", TIL_PREFIX, "I64)p; }\n\n")

    // Pass 2: emit struct constants (non-mut, non-function fields with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_constants(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip constants pass
    }

    // Pass 2b: emit top-level constants (non-mut declarations with literal values)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_constant_declaration(child) {
                output = emit_constant_declaration(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip top-level constants pass
    }
    output = concat(output, "\n")

    // Pass 3: emit function prototypes (forward declarations)
    // 3a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_prototype(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip prototype pass
    }
    // 3b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_prototypes(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func prototype pass
    }
    output = concat(output, "\n")

    // Pass 4: emit function definitions
    // 4a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_declaration(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip function pass
    }
    // 4b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_bodies(child, output, ctx, context)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func body pass
    }

    // Main function
    output = concat(output, "int main() {\n")

    // Pass 5: emit non-struct, non-function, non-enum, non-constant statements
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            // Skip true/false declarations - they're now #defines
            mut skip_true_false := false
            switch child.node_type {
            case NodeType.Declaration(decl):
                if decl.name.eq("true") { skip_true_false = true }
                if decl.name.eq("false") { skip_true_false = true }
            case:
            }
            if not(skip_true_false) {
                if not(is_func_declaration(child)) {
                    if not(is_struct_declaration(child)) {
                        if not(is_enum_declaration(child)) {
                            if not(is_constant_declaration(child)) {
                                output = emit_expr(child, output, 1, ctx, context)
                            }
                        }
                    }
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, emit directly
        output = emit_expr(ast, output, 1, ctx, context)
    }

    output = concat(output, "    return 0;\n")
    output = concat(output, "}\n")

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return output
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = concat(result, ";\n")
                return result
            case:
                throw "emit_func_prototype: not a function"
            }
        }
        throw "emit_func_prototype: empty params"
    case:
        throw "emit_func_prototype: not a declaration"
    }
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Set current function context for return/throw generation
                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types

                // Clear declared_vars for new function scope
                ctx.declared_vars = Vec.new(Str)
                // Reset variadic param context
                ctx.has_variadic_param = false
                ctx.current_variadic_param = VariadicParamInfo()
                // Check for variadic parameter
                mut arg_idx := 0
                while lt(arg_idx, func_def.args.len()) {
                    mut arg := Declaration()
                    func_def.args.get(arg_idx, arg)
                    switch arg.value_type {
                    case ValueType.TMulti(elem_type_name):
                        ctx.has_variadic_param = true
                        ctx.current_variadic_param.arg_name = arg.name
                        ctx.current_variadic_param.elem_type = elem_type_name
                    case:
                        // Not variadic, continue
                    }
                    arg_idx = add(arg_idx, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = concat(result, " {\n")

                // If function has variadic param, emit va_list setup to copy args to local array
                if ctx.has_variadic_param {
                    mut param_name := ctx.current_variadic_param.arg_name
                    mut elem_type := ctx.current_variadic_param.elem_type
                    // Emit: elem_type* param_name = NULL;
                    result = concat(result, "    ")
                    result = concat(result, elem_type)
                    result = concat(result, "* ")
                    result = concat(result, param_name)
                    result = concat(result, " = NULL;\n")
                    // Emit: if (param_name_len > 0) { ... va_list setup ... }
                    result = concat(result, "    if (")
                    result = concat(result, param_name)
                    result = concat(result, "_len > 0) {\n")
                    // malloc the array
                    result = concat(result, "        ")
                    result = concat(result, param_name)
                    result = concat(result, " = (")
                    result = concat(result, elem_type)
                    result = concat(result, "*)malloc(")
                    result = concat(result, param_name)
                    result = concat(result, "_len * sizeof(")
                    result = concat(result, elem_type)
                    result = concat(result, "));\n")
                    // va_list setup
                    result = concat(result, "        va_list _va;\n")
                    result = concat(result, "        va_start(_va, ")
                    result = concat(result, param_name)
                    result = concat(result, "_len);\n")
                    // for loop to copy args
                    result = concat(result, "        for (int _i = 0; _i < ")
                    result = concat(result, param_name)
                    result = concat(result, "_len; _i++) {\n")
                    result = concat(result, "            ")
                    result = concat(result, param_name)
                    result = concat(result, "[_i] = va_arg(_va, ")
                    result = concat(result, elem_type)
                    result = concat(result, ");\n")
                    result = concat(result, "        }\n")
                    result = concat(result, "        va_end(_va);\n")
                    result = concat(result, "    }\n")
                }

                // Emit function body with catch pattern detection
                result = emit_stmts(func_def.body, result, 1, ctx, context)

                // For throwing void functions, add implicit return 0
                if gt(func_def.throw_types.len(), 0) {
                    if eq(func_def.return_types.len(), 0) {
                        result = concat(result, "    return 0;\n")
                    }
                }

                result = concat(result, "}\n\n")

                // Clear current function context
                ctx.current_throw_types = Vec.new(ValueType)
                ctx.current_return_types = Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }

                return result
            case:
                throw "emit_func_declaration: not a function"
            }
        }
        throw "emit_func_declaration: empty params"
    case:
        throw "emit_func_declaration: not a declaration"
    }
}

emit_if := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if lt(expr.params.len(), 2) {
        throw "ccodegen: If requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "if (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0, ctx, context)
    // Bool is a struct with .data field - extract for C truthiness
    mut cond_type := get_value_type(context, cond)
    switch cond_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Bool") {
            result = concat(result, ".data")
        }
    case:
    }
    catch (err: Str) { /* get_value_type failed, skip */ }
    result = concat(result, ") {\n")

    // Save declared_vars before entering new scope
    mut saved_declared_vars := ctx.declared_vars.clone()
    catch (err: AllocError) { throw err.msg }

    // Then body
    mut then_body := Expr()
    expr.params.get(1, then_body)
    result = emit_body(then_body, result, add(indent, 1), ctx, context)

    // Restore declared_vars after exiting then scope
    ctx.declared_vars = saved_declared_vars

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}")

    // Else branch (optional)
    if gt(expr.params.len(), 2) {
        mut else_part := Expr()
        expr.params.get(2, else_part)
        switch else_part.node_type {
        case NodeType.If:
            // else-if: emit inline
            result = concat(result, " else ")
            result = emit_if(else_part, result, indent, ctx, context)
        case:
            // else block
            result = concat(result, " else {\n")

            // Save declared_vars for else scope
            saved_declared_vars = ctx.declared_vars.clone()
            catch (err: AllocError) { throw err.msg }

            result = emit_body(else_part, result, add(indent, 1), ctx, context)

            // Restore declared_vars after exiting else scope
            ctx.declared_vars = saved_declared_vars

            i = 0
            while lt(i, indent) {
                result = concat(result, "    ")
                i = add(i, 1)
            }
            result = concat(result, "}\n")
        }
    } else {
        result = concat(result, "\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

emit_while := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // While: params[0] = condition, params[1] = body
    if lt(expr.params.len(), 2) {
        throw "ccodegen: While requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "while (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0, ctx, context)
    // Bool is a struct with .data field - extract for C truthiness
    mut cond_type := get_value_type(context, cond)
    switch cond_type {
    case ValueType.TCustom(type_name):
        if type_name.eq("Bool") {
            result = concat(result, ".data")
        }
    case:
    }
    catch (err: Str) { /* get_value_type failed, skip */ }
    result = concat(result, ") {\n")

    // Save declared_vars before entering new scope (C allows redeclaration in new blocks)
    mut saved_declared_vars := ctx.declared_vars.clone()
    catch (err: AllocError) { throw err.msg }

    // Body
    mut body := Expr()
    expr.params.get(1, body)
    result = emit_body(body, result, add(indent, 1), ctx, context)

    // Restore declared_vars after exiting scope
    ctx.declared_vars = saved_declared_vars

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

// Result struct for variant info extraction
VariantInfo := struct {
    mut type_name: Str = ""
    mut variant_name: Str = ""
}

// Extract enum type and variant names from a case pattern expression
// For FCall: Type.Variant -> VariantInfo { type_name: "Type", variant_name: "Variant" }
get_case_variant_info := func(expr: Expr) returns VariantInfo {
    mut result := VariantInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // FCall for Type.Variant (without payload extraction)
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return result }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                if gt(first.params.len(), 0) {
                    mut nested := Expr()
                    first.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return result }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        result.type_name = type_name
                        result.variant_name = variant_name
                        return result
                    case:
                        return result
                    }
                }
                return result
            case:
                return result
            }
        }
        return result
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if gt(expr.params.len(), 0) {
            mut nested := Expr()
            expr.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) {
                result.variant_name = name
                return result
            }
            switch nested.node_type {
            case NodeType.Identifier(variant_name):
                result.type_name = name
                result.variant_name = variant_name
                return result
            case:
                result.variant_name = name
                return result
            }
        }
        result.variant_name = name
        return result
    case:
        return result
    }
}

// Extract type name and variant name from a Pattern's variant_name (e.g., "Color.Green")
parse_pattern_variant_name := func(variant_name: Str) returns VariantInfo {
    mut result := VariantInfo()
    mut dot_pos := variant_name.rfind(".")
    if gteq(dot_pos, 0) {
        result.type_name = variant_name.get_substr(0, dot_pos)
        result.variant_name = variant_name.get_substr(add(dot_pos, 1), variant_name.len())
        catch (err: IndexOutOfBoundsError) {
            result.variant_name = variant_name
        }
        catch (err: AllocError) {
            result.variant_name = variant_name
        }
        return result
    }
    // No dot - just variant name (shouldn't happen in practice)
    result.variant_name = variant_name
    return result
}

emit_switch := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Switch: params[0] = switch expression
    // params[1..] = alternating (case_pattern, body) pairs
    if eq(expr.params.len(), 0) {
        throw "ccodegen: Switch requires expression"
    }

    mut result := output

    // Indentation strings
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    mut case_indent := ""
    ind = 0
    while lt(ind, add(indent, 1)) {
        case_indent = concat(case_indent, "    ")
        ind = add(ind, 1)
    }

    mut body_indent := ""
    ind = 0
    while lt(ind, add(indent, 2)) {
        body_indent = concat(body_indent, "    ")
        ind = add(ind, 1)
    }

    // Get the switch expression
    mut switch_expr := Expr()
    expr.params.get(0, switch_expr)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Determine if this is an enum switch or a primitive switch
    // by scanning case patterns for Range or Pattern types
    mut is_enum_switch := false
    mut has_ranges := false
    mut scan_i := 1
    while lt(scan_i, expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(scan_i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        switch case_pattern.node_type {
        case NodeType.Range:
            has_ranges = true
        case NodeType.Pattern(pattern_info):
            is_enum_switch = true
        case NodeType.Identifier(name):
            // Check if it has nested params (Type.Variant pattern like Color.Unknown)
            if gt(case_pattern.params.len(), 0) {
                is_enum_switch = true
            } else if name.contains(".") {
                // Or check if it looks like an enum variant (contains a dot)
                is_enum_switch = true
            }
        case:
            // DefaultCase and other patterns (literals) don't change detection
            is_enum_switch = is_enum_switch
        }
        scan_i = add(scan_i, 2)
    }

    // Emit: switch (expr) { or switch (expr.tag) {
    result = concat(result, indent_str)
    result = concat(result, "switch (")
    result = emit_expr(switch_expr, result, 0, ctx, context)
    if is_enum_switch {
        if not(has_ranges) {
            result = concat(result, ".tag")
        }
    }
    result = concat(result, ") {\n")

    // Process case patterns and bodies in pairs
    mut i := 1
    while lt(i, expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        mut has_body := lt(add(i, 1), expr.params.len())

        switch case_pattern.node_type {
        case NodeType.DefaultCase:
            // default: { ... break; }
            result = concat(result, case_indent)
            result = concat(result, "default: {\n")
            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx, context)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        case NodeType.Pattern(pattern_info):
            // case Type_Variant: { PayloadType binding = expr.payload.Variant; ... break; }
            mut info := parse_pattern_variant_name(pattern_info.variant_name)

            result = concat(result, case_indent)
            result = concat(result, "case ")
            result = concat(result, info.type_name)
            result = concat(result, "_")
            result = concat(result, info.variant_name)
            result = concat(result, ": {\n")

            // Emit payload extraction: PayloadType binding_var = expr.payload.VariantName;
            result = concat(result, body_indent)
            result = concat(result, "__auto_type ")
            result = concat(result, pattern_info.binding_var)
            result = concat(result, " = ")
            result = emit_expr(switch_expr, result, 0, ctx, context)
            result = concat(result, ".payload.")
            result = concat(result, info.variant_name)
            result = concat(result, ";\n")

            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx, context)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        case NodeType.Range:
            // Range case: case low ... high: { ... break; }
            // Uses GCC extension for case ranges
            if lt(case_pattern.params.len(), 2) {
                throw "ccodegen: Range requires start and end values"
            }

            mut range_start := Expr()
            case_pattern.params.get(0, range_start)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            mut range_end := Expr()
            case_pattern.params.get(1, range_end)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            result = concat(result, case_indent)
            result = concat(result, "case ")
            result = emit_expr(range_start, result, 0, ctx, context)
            result = concat(result, " ... ")
            result = emit_expr(range_end, result, 0, ctx, context)
            result = concat(result, ": {\n")

            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx, context)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        case:
            // Regular case: Type.Variant -> case Type_Variant: { ... break; }
            mut info := get_case_variant_info(case_pattern)

            result = concat(result, case_indent)
            result = concat(result, "case ")
            if gt(info.type_name.len(), 0) {
                result = concat(result, info.type_name)
                result = concat(result, "_")
            }
            result = concat(result, info.variant_name)
            result = concat(result, ": {\n")

            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx, context)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        }

        i = add(i, 2)  // Move to next case pattern
    }

    result = concat(result, indent_str)
    result = concat(result, "}\n")

    return result
}

emit_expr := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Body:
        return emit_body(expr, output, indent, ctx, context)
    case NodeType.FCall:
        return emit_fcall(expr, output, indent, ctx, context)
    case NodeType.LLiteral(lit):
        return emit_literal(lit, output, context)
    case NodeType.Declaration(decl):
        return emit_declaration(decl, expr, output, indent, ctx, context)
    case NodeType.Identifier(name):
        // Check for type-qualified access (Type.field)
        if gt(expr.params.len(), 0) {
            mut first_char := name.get_substr(0, 1)
            if first_char.is_uppercase() {
                mut param := Expr()
                expr.params.get(0, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    // Check if this is an enum variant by looking up in context
                    mut is_enum_variant := false
                    mut enum_def := context.scope_stack.lookup_enum(name)
                    is_enum_variant = enum_def.enum_map.contains_key(field)
                    catch (err: KeyNotFoundError) { /* not an enum */ }

                    if is_enum_variant {
                        // Enum variant: Type.Variant -> til_Type_make_Variant()
                        mut result := concat(output, TIL_PREFIX)
                        result = concat(result, name)
                        result = concat(result, "_make_")
                        result = concat(result, field)
                        result = concat(result, "()")
                        return result
                    } else {
                        // Struct constant: Type.constant -> til_Type_constant
                        mut result := concat(output, TIL_PREFIX)
                        result = concat(result, name)
                        result = concat(result, "_")
                        result = concat(result, field)
                        return result
                    }
                case:
                    // Fall through to regular handling
                }
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        // Regular identifier or field access (b.val -> b.val)
        mut result := concat(output, name)
        mut i := 0
        while lt(i, expr.params.len()) {
            mut param := Expr()
            expr.params.get(i, param)
            switch param.node_type {
            case NodeType.Identifier(field):
                result = concat(result, ".")
                result = concat(result, field)
            case:
                // Not a field access
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    case NodeType.FuncDef(func_def):
        return emit_funcdef(func_def, expr, output, indent, ctx, context)
    case NodeType.Assignment(name):
        return emit_assignment(name, expr, output, indent, ctx, context)
    case NodeType.Return:
        return emit_return(expr, output, indent, ctx, context)
    case NodeType.If:
        return emit_if(expr, output, indent, ctx, context)
    case NodeType.While:
        return emit_while(expr, output, indent, ctx, context)
    case NodeType.Catch:
        // Catch blocks handled at call site in emit_stmts
        return output
    case NodeType.Throw:
        return emit_throw(expr, output, indent, ctx, context)
    case NodeType.StructDef(s):
        throw "ccodegen: StructDef should be handled at top level, not in emit_expr"
    case NodeType.EnumDef(e):
        throw "ccodegen: EnumDef should be handled at top level, not in emit_expr"
    case NodeType.Switch:
        return emit_switch(expr, output, indent, ctx, context)
    case NodeType.DefaultCase:
        throw "ccodegen: DefaultCase should be handled inside emit_switch"
    case NodeType.Range:
        throw "ccodegen: Range not yet supported"
    case NodeType.Pattern(p):
        throw "ccodegen: Pattern should be handled inside emit_switch"
    }
}

emit_body := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    return emit_stmts(expr.params, output, indent, ctx, context)
}

// Pre-scan function body to collect function-level catch blocks
// These are catch blocks at the end of the function (after all regular statements)
// Returns a Vec<Expr> of catch blocks
prescan_func_level_catches := proc(stmts: Vec) returns Vec throws AllocError {
    mut catches := Vec.new(Expr)
    mut i := stmts.len()

    // Scan backwards from end to find catch blocks at function level
    while gt(i, 0) {
        i = sub(i, 1)
        mut stmt := Expr()
        stmts.get(i, stmt)
        catch (err: IndexOutOfBoundsError) { return catches }

        switch stmt.node_type {
        case NodeType.Catch:
            catches.push(stmt)
        case NodeType.Return:
            // Return statements can be interleaved with catches at function end
        case:
            // Stop scanning when we hit a non-catch, non-return statement
            return catches
        }
    }

    return catches
}

// Emit a sequence of statements with catch pattern detection
// This is the core logic for handling throw/catch at call sites
emit_stmts := proc(stmts: Vec, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    mut i := 0

    // Pre-scan for function-level catches (at the end of the block)
    mut func_level_catches := prescan_func_level_catches(stmts)
    catch (err: AllocError) { throw err.msg }

    while lt(i, stmts.len()) {
        mut stmt := Expr()
        stmts.get(i, stmt)

        // Check if this statement is followed by catch blocks
        // And if it's a call to a throwing function (FCall, Declaration with FCall, or Assignment with FCall)
        mut maybe_fcall := Expr()
        mut has_fcall := false
        mut maybe_decl_name := ""
        mut has_decl := false
        mut maybe_assign_name := ""
        mut has_assign := false

        switch stmt.node_type {
        case NodeType.FCall:
            maybe_fcall = stmt
            has_fcall = true
        case NodeType.Declaration(decl):
            // Check if declaration has an FCall as initializer
            if gt(stmt.params.len(), 0) {
                mut first := Expr()
                stmt.params.get(0, first)
                switch first.node_type {
                case NodeType.FCall:
                    maybe_fcall = first
                    has_fcall = true
                    maybe_decl_name = decl.name
                    has_decl = true
                case:
                    // Not an FCall
                }
                catch (err: IndexOutOfBoundsError) { /* no initializer */ }
            }
        case NodeType.Assignment(name):
            // Check if assignment has an FCall as RHS
            if gt(stmt.params.len(), 0) {
                mut first := Expr()
                stmt.params.get(0, first)
                switch first.node_type {
                case NodeType.FCall:
                    maybe_fcall = first
                    has_fcall = true
                    maybe_assign_name = name
                    has_assign = true
                case:
                    // Not an FCall
                }
                catch (err: IndexOutOfBoundsError) { /* no RHS */ }
            }
        case:
            // Not FCall, Declaration, or Assignment
        }

        if has_fcall {
            // Get function name from the FCall
            mut func_name := get_fcall_func_name(maybe_fcall, context)

            // Check if this function is a throwing function
            if gt(func_name.len(), 0) {
                mut throw_types := Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }
                mut is_throwing := false
                mut lookup_result := lookup_func_by_name(context, func_name)
                if lookup_result.found {
                    if gt(lookup_result.func_def.throw_types.len(), 0) {
                        throw_types = lookup_result.func_def.throw_types
                        is_throwing = true
                    }
                }

                if is_throwing {
                    // Collect subsequent catch blocks
                    mut catch_blocks := Vec.new(Expr)
                    catch (err: AllocError) { throw err.msg }
                    mut j := add(i, 1)
                    while lt(j, stmts.len()) {
                        mut next_stmt := Expr()
                        stmts.get(j, next_stmt)
                        switch next_stmt.node_type {
                        case NodeType.Catch:
                            catch_blocks.push(next_stmt)
                            catch (err: AllocError) { throw err.msg }
                            j = add(j, 1)
                        case:
                            // Not a catch block, stop
                            j = stmts.len()  // break out of loop
                        }
                        catch (err: IndexOutOfBoundsError) { j = stmts.len() }
                    }

                    if gt(catch_blocks.len(), 0) {
                        // Emit throwing call with catch handling
                        if has_decl {
                            result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, maybe_decl_name, "", result, indent, ctx, context)
                        } else {
                            if has_assign {
                                result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, "", maybe_assign_name, result, indent, ctx, context)
                            } else {
                                result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, "", "", result, indent, ctx, context)
                            }
                        }
                        i = add(i, add(1, catch_blocks.len()))  // Skip past catch blocks
                    } else {
                        // No catch blocks - check if we're inside a throwing function
                        if gt(ctx.current_throw_types.len(), 0) {
                            // We're in a throwing function, propagate errors to caller
                            if has_decl {
                                result = emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                            } else {
                                if has_assign {
                                    result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                } else {
                                    result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                }
                            }
                        } else {
                            if gt(func_level_catches.len(), 0) {
                                // No immediate catch, not a throwing function, but has function-level catches
                                // Use those catches for error handling
                                if has_decl {
                                    result = emit_throwing_call(maybe_fcall, throw_types, func_level_catches, maybe_decl_name, "", result, indent, ctx, context)
                                } else {
                                    if has_assign {
                                        result = emit_throwing_call(maybe_fcall, throw_types, func_level_catches, "", maybe_assign_name, result, indent, ctx, context)
                                    } else {
                                        result = emit_throwing_call(maybe_fcall, throw_types, func_level_catches, "", "", result, indent, ctx, context)
                                    }
                                }
                            } else {
                                // No catches - typer should have caught this if we're in non-throwing context
                                // Just use propagate (will silently succeed on error if we're not throwing)
                                if has_decl {
                                    result = emit_throwing_call_propagate(maybe_fcall, throw_types, maybe_decl_name, "", result, indent, ctx, context)
                                } else {
                                    if has_assign {
                                        result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", maybe_assign_name, result, indent, ctx, context)
                                    } else {
                                        result = emit_throwing_call_propagate(maybe_fcall, throw_types, "", "", result, indent, ctx, context)
                                    }
                                }
                            }
                        }
                        i = add(i, 1)
                    }
                } else {
                    // Not a throwing function, emit regular statement
                    result = emit_expr(stmt, result, indent, ctx, context)
                    i = add(i, 1)
                }
            } else {
                // Couldn't get function name, emit regular statement
                result = emit_expr(stmt, result, indent, ctx, context)
                i = add(i, 1)
            }
        } else {
            // Regular statement handling
            result = emit_expr(stmt, result, indent, ctx, context)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }
    return result
}

// Emit a call to a throwing function with catch handling
// Generates: declare temps, call func, if/else chain for error handling
emit_throwing_call := proc(fcall: Expr, throw_types: Vec, catch_blocks: Vec, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall, context)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := next_mangled()

    // Determine if we need a return value temp variable
    mut needs_ret := false
    if gt(decl_name.len(), 0) { needs_ret = true }
    if gt(assign_name.len(), 0) { needs_ret = true }

    // Declare local variables for return value and errors
    // Look up the actual return type from scope_stack
    mut ret_type := "int"
    if needs_ret {
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
        }
        catch (err: KeyNotFoundError) { /* use default int */ }
        catch (err: IndexOutOfBoundsError) { /* use default int */ }
        result = concat(result, indent_str)
        result = concat(result, ret_type)
        result = concat(result, " _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    if gt(decl_name.len(), 0) {
        result = concat(result, indent_str)
        result = concat(result, ret_type)
        result = concat(result, " ")
        result = concat(result, decl_name)
        result = concat(result, ";\n")
        // Add to scope_stack for UFCS type resolution
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_type := ValueType.TCustom("")
            fd.return_types.get(0, first_type)
            context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare error structs for each throw type
    // Use = {} to avoid warning for empty structs
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = concat(result, indent_str)
            result = concat(result, type_name)
            result = concat(result, " _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = {};\n")
        case:
            // Non-custom type, use int
            result = concat(result, indent_str)
            result = concat(result, "int _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    result = concat(result, indent_str)
    result = concat(result, "int _status_")
    result = concat(result, temp_suffix)
    result = concat(result, " = ")
    result = concat(result, func_name)
    result = concat(result, "(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if needs_ret {
        result = concat(result, "&_ret_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        result = concat(result, "&_err")
        result = concat(result, i.to_str())
        result = concat(result, "_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Then: actual arguments (skip the function name which is params[0])
    i = 1
    while lt(i, fcall.params.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        mut arg := Expr()
        fcall.params.get(i, arg)
        result = emit_expr(arg, result, 0, ctx, context)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = concat(result, ");\n")

    // Generate if/else chain for error handling
    result = concat(result, indent_str)
    result = concat(result, "if (_status_")
    result = concat(result, temp_suffix)
    result = concat(result, " == 0) {\n")

    // Success case: assign return value to target variable
    if gt(decl_name.len(), 0) {
        // Declaration: assign to newly declared variable (declared before if block)
        mut inner_indent := ""
        ind = 0
        while lt(ind, add(indent, 1)) {
            inner_indent = concat(inner_indent, "    ")
            ind = add(ind, 1)
        }
        result = concat(result, inner_indent)
        result = concat(result, decl_name)
        result = concat(result, " = _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
    } else {
        if gt(assign_name.len(), 0) {
            // Assignment: assign to existing variable
            mut inner_indent := ""
            ind = 0
            while lt(ind, add(indent, 1)) {
                inner_indent = concat(inner_indent, "    ")
                ind = add(ind, 1)
            }
            result = concat(result, inner_indent)
            result = concat(result, assign_name)
            result = concat(result, " = _ret_")
            result = concat(result, temp_suffix)
            result = concat(result, ";\n")
        }
    }

    result = concat(result, indent_str)
    result = concat(result, "}")

    // Generate else-if branches for each catch block
    i = 0
    while lt(i, catch_blocks.len()) {
        mut catch_block := Expr()
        catch_blocks.get(i, catch_block)

        // Get the error type index from status code (i+1)
        result = concat(result, " else if (_status_")
        result = concat(result, temp_suffix)
        result = concat(result, " == ")
        result = concat(result, add(i, 1).to_str())
        result = concat(result, ") {\n")

        // Emit catch block body
        // The catch block params should have the binding variable and body
        if gt(catch_block.params.len(), 0) {
            // Get binding info - catch params[0] is the error binding expr, params[1..] is the body
            mut k := 1
            while lt(k, catch_block.params.len()) {
                mut body_stmt := Expr()
                catch_block.params.get(k, body_stmt)
                result = emit_expr(body_stmt, result, add(indent, 1), ctx, context)
                k = add(k, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        result = concat(result, indent_str)
        result = concat(result, "}")

        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = concat(result, "\n")
    return result
}

// Emit a call to a throwing function WITHOUT catch blocks - propagate errors to caller
// Used when inside a throwing function that can forward the same error types
emit_throwing_call_propagate := proc(fcall: Expr, throw_types: Vec, decl_name: Str, assign_name: Str, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall, context)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call_propagate: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := next_mangled()

    // Determine if we need a return value temp variable
    mut needs_ret := false
    if gt(decl_name.len(), 0) { needs_ret = true }
    if gt(assign_name.len(), 0) { needs_ret = true }

    // Look up the actual return type from scope_stack
    mut ret_type := "int"
    if needs_ret {
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_ret := ValueType.TCustom("")
            fd.return_types.get(0, first_ret)
            ret_type = til_type_to_c(first_ret)
        }
        catch (err: KeyNotFoundError) { /* use default int */ }
        catch (err: IndexOutOfBoundsError) { /* use default int */ }
    }

    // Declare temp for return value if needed
    if needs_ret {
        result = concat(result, indent_str)
        result = concat(result, ret_type)
        result = concat(result, " _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
    }

    // For declarations: declare the variable BEFORE the if block so it's visible after
    if gt(decl_name.len(), 0) {
        result = concat(result, indent_str)
        result = concat(result, ret_type)
        result = concat(result, " ")
        result = concat(result, decl_name)
        result = concat(result, ";\n")
        // Add to scope_stack for UFCS type resolution
        mut fd := context.scope_stack.lookup_func(func_name)
        if gt(fd.return_types.len(), 0) {
            mut first_type := ValueType.TCustom("")
            fd.return_types.get(0, first_type)
            context.scope_stack.declare_symbol(decl_name, SymbolInfo.new(first_type, true, false, false))
        }
        catch (err: KeyNotFoundError) { }
        catch (err: IndexOutOfBoundsError) { }
    }

    // Declare error structs for each throw type of the called function
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = concat(result, indent_str)
            result = concat(result, type_name)
            result = concat(result, " _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = {};\n")
        case:
            // Non-custom type, use int
            result = concat(result, indent_str)
            result = concat(result, "int _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    result = concat(result, indent_str)
    result = concat(result, "int _status_")
    result = concat(result, temp_suffix)
    result = concat(result, " = ")
    result = concat(result, func_name)
    result = concat(result, "(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if needs_ret {
        result = concat(result, "&_ret_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        result = concat(result, "&_err")
        result = concat(result, i.to_str())
        result = concat(result, "_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Then: actual arguments (skip the function name which is params[0])
    i = 1
    while lt(i, fcall.params.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        mut arg := Expr()
        fcall.params.get(i, arg)
        result = emit_expr(arg, result, 0, ctx, context)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = concat(result, ");\n")

    // Generate error propagation: if status != 0, copy error to caller's error param and return
    // Map error types from called function to current function's error params
    mut called_idx := 0
    while lt(called_idx, throw_types.len()) {
        mut called_throw_type := ValueType.TCustom("")
        throw_types.get(called_idx, called_throw_type)
        switch called_throw_type {
        case ValueType.TCustom(called_type_name):
            // Find matching error type in current function's throw types
            mut curr_idx := 0
            mut found := false
            while lt(curr_idx, ctx.current_throw_types.len()) {
                mut curr_throw := ValueType.TCustom("")
                ctx.current_throw_types.get(curr_idx, curr_throw)
                switch curr_throw {
                case ValueType.TCustom(curr_name):
                    if curr_name.eq(called_type_name) {
                        // Found matching error type, generate propagation
                        result = concat(result, indent_str)
                        result = concat(result, "if (_status_")
                        result = concat(result, temp_suffix)
                        result = concat(result, " == ")
                        result = concat(result, add(called_idx, 1).to_str())
                        result = concat(result, ") { *_err")
                        result = concat(result, add(curr_idx, 1).to_str())
                        result = concat(result, " = _err")
                        result = concat(result, called_idx.to_str())
                        result = concat(result, "_")
                        result = concat(result, temp_suffix)
                        result = concat(result, "; return ")
                        result = concat(result, add(curr_idx, 1).to_str())
                        result = concat(result, "; }\n")
                        found = true
                        curr_idx = ctx.current_throw_types.len()  // break
                    }
                case:
                    // Non-TCustom, skip
                }
                curr_idx = add(curr_idx, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        case:
            // Non-custom throw type, skip
        }
        called_idx = add(called_idx, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Success case: assign return value to target variable if needed
    if gt(decl_name.len(), 0) {
        result = concat(result, indent_str)
        result = concat(result, decl_name)
        result = concat(result, " = _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
    } else {
        if gt(assign_name.len(), 0) {
            result = concat(result, indent_str)
            result = concat(result, assign_name)
            result = concat(result, " = _ret_")
            result = concat(result, temp_suffix)
            result = concat(result, ";\n")
        }
    }

    return result
}

// Emit a throw statement
// For throwing functions: *_errN = value; return N;
emit_throw := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output

    // Generate indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Get throw value if present
    if gt(expr.params.len(), 0) {
        mut throw_value := Expr()
        expr.params.get(0, throw_value)

        // Find which error type this throw corresponds to
        // For now, assume it's the first error type (index 1)
        // TODO: Match throw type to the correct error index
        result = concat(result, "*_err1 = ")
        result = emit_expr(throw_value, result, 0, ctx, context)
        result = concat(result, ";\n")

        ind = 0
        while lt(ind, indent) {
            result = concat(result, "    ")
            ind = add(ind, 1)
        }
        result = concat(result, "return 1;\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    } else {
        // Throw with no value - just return error status
        result = concat(result, "return 1;\n")
    }

    return result
}

// Check if an expression is a struct construction call (TypeName())
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                // If it's a PascalCase identifier with no nested params and no other args, assume struct
                if gt(name.len(), 0) {
                    // Check if first character is uppercase
                    mut first_char := name.get_substr(0, 1)
                    if first_char.is_uppercase() {
                        if eq(expr.params.len(), 1) {
                            if eq(first.params.len(), 0) {
                                return name
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Check if an expression is an enum construction (Type.Variant or Type.Variant(value))
// Returns the type name if it is, empty string otherwise
// AST structure for Color.Red(42): FCall -> [Identifier("Color") -> [Identifier("Red")], Literal(42)]
// AST structure for Color.Unknown: Identifier("Color") -> [Identifier("Unknown")]
get_enum_construction_type := func(expr: Expr) returns Str {
    // Check FCall case: Type.Variant(value) or Type.Variant()
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                // Check if the type name is PascalCase
                if gt(type_name.len(), 0) {
                    mut type_first_char := type_name.get_substr(0, 1)
                    if type_first_char.is_uppercase() {
                        // Check if there's a nested identifier (the variant) that's also PascalCase
                        if gt(first.params.len(), 0) {
                            mut nested := Expr()
                            first.params.get(0, nested)
                            catch (err: IndexOutOfBoundsError) { return "" }
                            switch nested.node_type {
                            case NodeType.Identifier(variant_name):
                                if gt(variant_name.len(), 0) {
                                    mut variant_first_char := variant_name.get_substr(0, 1)
                                    if variant_first_char.is_uppercase() {
                                        return type_name
                                    }
                                    catch (err: IndexOutOfBoundsError) { return "" }
                                    catch (err: AllocError) { return "" }
                                }
                                return ""
                            case:
                                return ""
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case NodeType.Identifier(type_name):
        // Check Identifier case: Type.Variant (no parentheses, no payload)
        if gt(type_name.len(), 0) {
            mut type_first_char := type_name.get_substr(0, 1)
            if type_first_char.is_uppercase() {
                if gt(expr.params.len(), 0) {
                    mut nested := Expr()
                    expr.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        if gt(variant_name.len(), 0) {
                            mut variant_first_char := variant_name.get_substr(0, 1)
                            if variant_first_char.is_uppercase() {
                                return type_name
                            }
                            catch (err: IndexOutOfBoundsError) { return "" }
                            catch (err: AllocError) { return "" }
                        }
                        return ""
                    case:
                        return ""
                    }
                }
            }
            catch (err: IndexOutOfBoundsError) { return "" }
            catch (err: AllocError) { return "" }
        }
        return ""
    case:
        return ""
    }
}

// Infer type from an expression (literal, function call, or identifier)
// Returns the inferred ValueType, or ValueType.TCustom("") if unknown
infer_type_from_expr := func(expr: Expr, context: Context) returns ValueType {
    switch expr.node_type {
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(n):
            return ValueType.TCustom("I64")
        case Literal.Str(s):
            return ValueType.TCustom("Str")
        case Literal.List(l):
            return ValueType.TCustom("")  // Can't infer list element type
        }
    case NodeType.FCall:
        // Look up function return type from scope_stack
        mut func_name := get_fcall_func_name(expr, context)
        if gt(func_name.len(), 0) {
            mut fd := context.scope_stack.lookup_func(func_name)
            if gt(fd.return_types.len(), 0) {
                mut first_ret := ValueType.TCustom("")
                fd.return_types.get(0, first_ret)
                catch (err: IndexOutOfBoundsError) { return ValueType.TCustom("") }
                return first_ret
            }
            catch (err: KeyNotFoundError) { return ValueType.TCustom("") }
        }
        return ValueType.TCustom("")
    case NodeType.Identifier(name):
        // Look up variable type from scope_stack
        mut var_type := ValueType.TCustom("")
        mut symbol := context.scope_stack.lookup_symbol(name)
        var_type = symbol.value_type
        catch (err: KeyNotFoundError) { }
        return var_type
    case:
        return ValueType.TCustom("")
    }
    return ValueType.TCustom("")
}

emit_declaration := proc(decl: Declaration, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    name := decl.name
    is_mut := decl.is_mut

    // Skip inline ext_func/ext_proc declarations - they're just declaring external functions exist
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            if func_def.is_ext {
                return output
            }
        case:
            // Continue
        }
    }

    // Skip NULL - it's a C macro for 0
    if Str.eq(name, "NULL") { return output }

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Check if this is a function definition - skip in main pass
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            // Skip - already emitted before main
            return output
        case NodeType.StructDef(struct_def):
            // Skip - already emitted before functions
            return output
        case:
            // Continue with normal declaration
        }
    }

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        struct_type = get_struct_construction_type(first)
    }

    // Check if this is an enum construction (Type.Variant or Type.Variant(value))
    mut enum_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        enum_type = get_enum_construction_type(first)
    }

    // Track variable type for UFCS mangling
    // Use the inferred type from struct/enum construction if available,
    // or use get_value_type to get return type of function calls like Vec.new(Str)
    mut var_type := decl.value_type
    if gt(struct_type.len(), 0) {
        var_type = ValueType.TCustom(struct_type)
    } else if gt(enum_type.len(), 0) {
        var_type = ValueType.TCustom(enum_type)
    } else {
        switch decl.value_type {
        case ValueType.TCustom(type_name):
            if Str.eq(type_name, "auto").and(gt(expr.params.len(), 0)) {
                // Try get_value_type first (handles function calls like Vec.new)
                // then fall back to literal inference
                mut first := Expr()
                expr.params.get(0, first)
                mut got_type := false
                mut inferred_type := get_value_type(context, first)
                got_type = true
                var_type = inferred_type
                catch (err: Str) {
                    // get_value_type failed, try literal inference
                    var_type = infer_type_from_expr(first, context)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }
        case:
            // Keep default decl.value_type
        }
    }
    // Add to scope_stack so get_value_type can find it
    context.scope_stack.declare_symbol(name, SymbolInfo.new(var_type, decl.is_mut, false, false))

    if gt(struct_type.len(), 0) {
        // Struct variable declaration
        result = concat(result, struct_type)
        result = concat(result, " ")
        result = concat(result, name)
        result = concat(result, " = {0};\n")
    } else if gt(enum_type.len(), 0) {
        // Enum variable declaration
        result = concat(result, enum_type)
        result = concat(result, " ")
        result = concat(result, name)
        result = concat(result, " = ")
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx, context)
        result = concat(result, ";\n")
    } else if is_mut {
        // Determine C type from inferred type or fall back to int
        mut c_type := "int"
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            inferred := infer_type_from_expr(first, context)
            switch inferred {
            case ValueType.TCustom(inf_type):
                if Str.eq(inf_type, "Str") {
                    c_type = "const char*"
                } else if gt(inf_type.len(), 0) {
                    c_type = inf_type  // I64, U8, etc. pass through
                }
            case:
                // Keep default "int"
            }
        }
        result = concat(result, c_type)
        result = concat(result, " ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx, context)
        }
        result = concat(result, ";\n")
    } else {
        // Determine C type from inferred type or fall back to int
        mut c_type := "int"
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            inferred := infer_type_from_expr(first, context)
            switch inferred {
            case ValueType.TCustom(inf_type):
                if Str.eq(inf_type, "Str") {
                    c_type = "const char*"
                } else if gt(inf_type.len(), 0) {
                    c_type = inf_type  // I64, U8, etc. pass through
                }
            case:
                // Keep default "int"
            }
        }
        result = concat(result, "const ")
        result = concat(result, c_type)
        result = concat(result, " ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx, context)
        }
        result = concat(result, ";\n")
    }
    return result
}

emit_funcdef := proc(func_def: SFuncDef, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // Inline function body (shouldn't be called for top-level funcs)
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "{\n")
    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, params_len) {
        mut stmt := Expr()
        expr.params.get(i, stmt)
        result = emit_expr(stmt, result, add(indent, 1), ctx, context)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    ind = 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "}\n")
    return result
}

emit_assignment := proc(name: Str, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, name)
    result = concat(result, " = ")
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx, context)
    }
    result = concat(result, ";\n")
    return result
}

emit_return := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    mut result := output
    mut ind := 0
    mut indent_str := ""
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, indent_str)

    // Check if we're in a throwing function
    if gt(ctx.current_throw_types.len(), 0) {
        // Throwing function: *_ret = value; return 0;
        if gt(expr.params.len(), 0) {
            mut return_expr := Expr()
            expr.params.get(0, return_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            // Check if return expression is a call to a throwing function
            mut handled_throw := false
            switch return_expr.node_type {
            case NodeType.FCall:
                mut func_name := get_fcall_func_name(return_expr, context)
                if gt(func_name.len(), 0) {
                    mut lookup_result := lookup_func_by_name(context, func_name)
                    if lookup_result.found {
                        if gt(lookup_result.func_def.throw_types.len(), 0) {
                            // Return expression is a throwing function call - emit with error propagation
                            // The result will be stored via the assign_name "*_ret"
                            result = emit_throwing_call_propagate(return_expr, lookup_result.func_def.throw_types, "", "*_ret", result, indent, ctx, context)
                            result = concat(result, indent_str)
                            result = concat(result, "return 0;\n")
                            handled_throw = true
                        }
                    }
                }
            case:
                // Not an FCall, handle normally
            }

            if not(handled_throw) {
                // Regular return value - just emit it
                result = concat(result, "*_ret = ")
                result = emit_expr(return_expr, result, 0, ctx, context)
                result = concat(result, ";\n")
                result = concat(result, indent_str)
                result = concat(result, "return 0;\n")
            }
        } else {
            result = concat(result, "return 0;\n")
        }
    } else {
        // Non-throwing function: regular return
        result = concat(result, "return")
        if gt(expr.params.len(), 0) {
            result = concat(result, " ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx, context)
        }
        result = concat(result, ";\n")
    }

    return result
}

// Emit a throwing function call's name and arguments for hoisting
emit_fcall_name_and_args_for_throwing := proc(expr: Expr, temp_var: Str, temp_suffix: Str, throw_types: Vec, nested_hoisted: Vec, mut output: Str, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    if lt(expr.params.len(), 1) {
        throw "emit_fcall_name_and_args_for_throwing: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)

    mut func_name := ""
    mut ufcs_receiver_name := ""
    mut has_ufcs_receiver := false
    mut ufcs_depth := 0  // Number of params (for chained access like self._len.eq)

    switch first.node_type {
    case NodeType.Identifier(name):
        if gt(first.params.len(), 0) {
            // UFCS: receiver.method()
            // AST is FLAT: a.b.c is Identifier("a") { params: [Identifier("b"), Identifier("c")] }
            // Method is the LAST param, not the first
            ufcs_depth = first.params.len()
            mut method_idx := sub(ufcs_depth, 1)
            mut method_expr := Expr()
            first.params.get(method_idx, method_expr)
            switch method_expr.node_type {
            case NodeType.Identifier(method_name):
                func_name = method_name
                ufcs_receiver_name = name
                has_ufcs_receiver = true
            case:
                throw "emit_fcall_name_and_args_for_throwing: UFCS method not Identifier"
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        } else {
            func_name = name
        }
    case:
        throw "emit_fcall_name_and_args_for_throwing: first param not Identifier"
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Emit function name with potential UFCS mangling
    if has_ufcs_receiver {
        mut first_char := ufcs_receiver_name.get_char(0)
        if first_char.is_uppercase() {
            // Type-qualified: Type.func -> Type_func
            output = concat(output, ufcs_receiver_name)
            output = concat(output, "_")
        } else {
            // Instance UFCS: instance.method -> Type_method (only if mangled name exists)
            mut receiver_type := ValueType.TCustom("")
            mut symbol := context.scope_stack.lookup_symbol(ufcs_receiver_name)
            receiver_type = symbol.value_type
            switch receiver_type {
            case ValueType.TCustom(type_name):
                mut candidate := concat(type_name, "_")
                candidate = concat(candidate, func_name)
                _ := context.scope_stack.lookup_func(candidate)
                // If lookup succeeded, use mangled name
                output = concat(output, type_name)
                output = concat(output, "_")
            case:
                // Skip
            }
            catch (err: KeyNotFoundError) { }
        }
        catch (err: IndexOutOfBoundsError) { }
        catch (err: AllocError) { }
    }

    output = concat(output, func_name)
    output = concat(output, "(&")
    output = concat(output, temp_var)

    // Add error output pointers
    mut err_idx := 0
    while lt(err_idx, throw_types.len()) {
        output = concat(output, ", &_err")
        output = concat(output, I64.to_str(err_idx))
        output = concat(output, "_")
        output = concat(output, temp_suffix)
        err_idx = add(err_idx, 1)
    }

    // Emit receiver for instance UFCS
    if has_ufcs_receiver {
        mut first_char := ufcs_receiver_name.get_char(0)
        if not(first_char.is_uppercase()) {
            output = concat(output, ", ")
            output = concat(output, til_name(ufcs_receiver_name))
            // Emit intermediate field accesses (all except the last which is the method)
            mut field_idx := 0
            while lt(field_idx, sub(ufcs_depth, 1)) {
                mut field_expr := Expr()
                first.params.get(field_idx, field_expr)
                switch field_expr.node_type {
                case NodeType.Identifier(field_name):
                    output = concat(output, ".")
                    output = concat(output, field_name)
                case:
                    // skip
                }
                field_idx = add(field_idx, 1)
            }
        }
        catch (err: IndexOutOfBoundsError) { }
        catch (err: AllocError) { }
    }

    // Emit remaining arguments (using hoisted temps where available)
    mut arg_idx := 0
    // Skip first param (function name), start from index 1
    mut i := 1
    while lt(i, expr.params.len()) {
        output = concat(output, ", ")
        // Check if this arg was hoisted
        mut found_hoisted := false
        mut j := 0
        while lt(j, nested_hoisted.len()) {
            mut hoisted_arg := HoistedArg()
            nested_hoisted.get(j, hoisted_arg)
            if eq(hoisted_arg.index, arg_idx) {
                output = concat(output, hoisted_arg.temp_var)
                found_hoisted = true
            }
            j = add(j, 1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
        if not(found_hoisted) {
            mut arg := Expr()
            expr.params.get(i, arg)
            output = emit_expr(arg, output, 0, ctx, context)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
        arg_idx = add(arg_idx, 1)
        i = add(i, 1)
    }

    output = concat(output, ")")
    return output
}

// Hoist throwing function calls from arguments (recursively)
// Returns a list of hoisted args with their temp var names
// Also modifies output to include hoisting code
hoist_throwing_args := proc(args: Vec, mut output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Vec throws Str, AllocError {
    mut hoisted := Vec.new(HoistedArg)
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    mut idx := 0
    while lt(idx, args.len()) {
        mut arg := Expr()
        args.get(idx, arg)

        mut info := check_throwing_fcall(arg, ctx, context)
        if info.is_throwing {
            // RECURSIVELY hoist any throwing calls in this call's arguments first
            mut nested_hoisted := Vec.new(HoistedArg)
            if gt(arg.params.len(), 1) {
                nested_hoisted = hoist_throwing_args(arg.params, output, indent, ctx, context)
            }

            mut temp_var := next_mangled()

            // Determine C type for temp variable
            mut c_type := "int"
            if info.has_return_type {
                c_type = til_type_to_c(info.return_type)
            }

            // Declare temp variable
            output = concat(output, indent_str)
            output = concat(output, c_type)
            output = concat(output, " ")
            output = concat(output, temp_var)
            output = concat(output, ";\n")

            // Declare error variables for each throw type
            mut temp_suffix := next_mangled()
            mut err_idx := 0
            while lt(err_idx, info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    output = concat(output, indent_str)
                    output = concat(output, type_name)
                    output = concat(output, " _err")
                    output = concat(output, I64.to_str(err_idx))
                    output = concat(output, "_")
                    output = concat(output, temp_suffix)
                    output = concat(output, ";\n")
                case:
                    // Skip non-custom types
                }
                err_idx = add(err_idx, 1)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            // Emit the function call with output pointers
            output = concat(output, indent_str)
            output = concat(output, "int _status_")
            output = concat(output, temp_suffix)
            output = concat(output, " = ")
            output = emit_fcall_name_and_args_for_throwing(arg, temp_var, temp_suffix, info.throw_types, nested_hoisted, output, ctx, context)
            output = concat(output, ";\n")

            // Emit error checking - propagate if any error occurred
            output = concat(output, indent_str)
            output = concat(output, "if (_status_")
            output = concat(output, temp_suffix)
            output = concat(output, " != 0) {\n")

            // Propagate error to current function's error pointers
            err_idx = 0
            while lt(err_idx, info.throw_types.len()) {
                mut throw_type := ValueType.TCustom("")
                info.throw_types.get(err_idx, throw_type)
                switch throw_type {
                case ValueType.TCustom(type_name):
                    // Find matching throw type in current function
                    mut curr_idx := 0
                    while lt(curr_idx, ctx.current_throw_types.len()) {
                        mut curr_throw := ValueType.TCustom("")
                        ctx.current_throw_types.get(curr_idx, curr_throw)
                        switch curr_throw {
                        case ValueType.TCustom(curr_type_name):
                            if curr_type_name.eq(type_name) {
                                output = concat(output, indent_str)
                                output = concat(output, "    if (_status_")
                                output = concat(output, temp_suffix)
                                output = concat(output, " == ")
                                output = concat(output, I64.to_str(add(err_idx, 1)))
                                output = concat(output, ") { *_err")
                                output = concat(output, I64.to_str(add(curr_idx, 1)))
                                output = concat(output, " = _err")
                                output = concat(output, I64.to_str(err_idx))
                                output = concat(output, "_")
                                output = concat(output, temp_suffix)
                                output = concat(output, "; return ")
                                output = concat(output, I64.to_str(add(curr_idx, 1)))
                                output = concat(output, "; }\n")
                            }
                        case:
                            // Skip
                        }
                        curr_idx = add(curr_idx, 1)
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                    }
                case:
                    // Skip
                }
                err_idx = add(err_idx, 1)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            }

            output = concat(output, indent_str)
            output = concat(output, "}\n")

            mut hoisted_arg := HoistedArg()
            hoisted_arg.index = idx
            hoisted_arg.temp_var = temp_var
            hoisted.push(hoisted_arg)
        }
        idx = add(idx, 1)

        catch (err: IndexOutOfBoundsError) { throw err.msg }
        catch (err: AllocError) { throw err.msg }
    }

    return hoisted
}

emit_fcall := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext, mut context: Context) returns Str throws Str {
    // First param is the function name (or UFCS receiver.method)
    mut params_len := expr.params.len()
    if lt(params_len, 1) {
        throw "ccodegen: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    mut func_name := ""
    mut has_ufcs_receiver := false
    mut ufcs_receiver_name := ""
    mut ufcs_depth := 0  // Number of params (for chained access like self._len.eq)

    switch first.node_type {
    case NodeType.Identifier(name):
        if gt(first.params.len(), 0) {
            // UFCS: receiver.method() - method is the LAST param (AST is flat)
            ufcs_depth = first.params.len()
            mut method_idx := sub(ufcs_depth, 1)
            mut method_expr := Expr()
            first.params.get(method_idx, method_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch method_expr.node_type {
            case NodeType.Identifier(method_name):
                func_name = method_name
                has_ufcs_receiver = true
                ufcs_receiver_name = name
            case:
                throw "ccodegen: UFCS method name not Identifier"
            }
        } else {
            func_name = name
        }
    case:
        throw "ccodegen: FCall first param not Identifier"
    }

    // Handle variadic parameter methods: args.len() and args.get(i, val)
    if has_ufcs_receiver {
        if ctx.has_variadic_param {
            if ufcs_receiver_name.eq(ctx.current_variadic_param.arg_name) {
                if func_name.eq("len") {
                    // args.len() -> args_len
                    return concat(output, concat(ctx.current_variadic_param.arg_name, "_len"))
                } else if func_name.eq("get") {
                    // args.get(i, val) -> val = args[i];
                    // params[1] is index, params[2] is output variable
                    if gt(params_len, 2) {
                        mut out_var_expr := Expr()
                        expr.params.get(2, out_var_expr)
                        catch (err: IndexOutOfBoundsError) { throw err.msg }
                        switch out_var_expr.node_type {
                        case NodeType.Identifier(out_var):
                            mut ind := 0
                            mut result := output
                            while lt(ind, indent) {
                                result = concat(result, "    ")
                                ind = add(ind, 1)
                            }
                            result = concat(result, out_var)
                            result = concat(result, " = ")
                            result = concat(result, ctx.current_variadic_param.arg_name)
                            result = concat(result, "[")
                            mut idx_expr := Expr()
                            expr.params.get(1, idx_expr)
                            catch (err: IndexOutOfBoundsError) { throw err.msg }
                            result = emit_expr(idx_expr, result, 0, ctx, context)
                            result = concat(result, "];\n")
                            return result
                        case:
                            // Not an identifier, fall through
                        }
                    }
                }
            }
        }
    }

    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Check for UFCS on FCall result: func_name(fcall_result, args...)
    // This happens for chained method calls like delimiter.len().eq(0)
    // Parser produces: FCall { params: [Identifier("eq"), FCall { ... }, LLiteral(0)] }
    if not(has_ufcs_receiver).and(gteq(params_len, 2)) {
        mut second_param := Expr()
        expr.params.get(1, second_param)
        switch second_param.node_type {
        case NodeType.FCall:
            // The second param is an FCall result - use get_value_type to get its return type
            mut fcall_ret_type := get_value_type(context, second_param)
            switch fcall_ret_type {
            case ValueType.TCustom(type_name):
                mut candidate := format(type_name, ".", func_name)
                // Try to lookup the function - if found, emit as Type_method
                mut func_info := context.scope_stack.lookup_func(candidate)
                // If we get here, the function was found (otherwise KeyNotFoundError)
                // Emit as Type_method(fcall_result, args...)
                result = concat(result, TIL_PREFIX)
                result = concat(result, type_name)
                result = concat(result, "_")
                result = concat(result, func_name)
                result = concat(result, "(")
                // First arg is the fcall result
                result = emit_expr(second_param, result, 0, ctx, context)
                // Remaining args
                mut arg_i := 2
                while lt(arg_i, params_len) {
                    result = concat(result, ", ")
                    mut arg := Expr()
                    expr.params.get(arg_i, arg)
                    result = emit_expr(arg, result, 0, ctx, context)
                    arg_i = add(arg_i, 1)
                }
                result = concat(result, ")")
                if gt(indent, 0) {
                    result = concat(result, ";\n")
                }
                return result
            case:
                // Not a custom type, skip
            }
            catch (err: Str) { /* get_value_type failed, fall through */ }
            catch (err: KeyNotFoundError) { /* function not found, fall through */ }
        case:
            // Not an FCall, skip
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Hardcoded builtins
    if func_name.eq("println") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0, ctx, context)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, "\"\\n\");\n")
        return result
    } else if func_name.eq("print") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0, ctx, context)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, ");\n")
        return result
    } else if func_name.eq("test") {
        // test(loc, cond, msg) -> if (!(cond)) { printf("FAIL: %s\n", msg); }
        if lt(params_len, 4) {
            throw "ccodegen: test requires 3 arguments"
        }
        result = concat(result, "if (!(")
        mut cond := Expr()
        expr.params.get(2, cond)
        result = emit_expr(cond, result, 0, ctx, context)
        result = concat(result, ")) { printf(\"FAIL: %s\\n\", ")
        mut msg := Expr()
        expr.params.get(3, msg)
        result = emit_expr(msg, result, 0, ctx, context)
        result = concat(result, "); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("assert_eq") {
        // assert_eq(loc, expected, actual) -> if ((expected) != (actual)) { printf("FAIL: assert_eq\n"); }
        if lt(params_len, 4) {
            throw "ccodegen: assert_eq requires 3 arguments"
        }
        result = concat(result, "if ((")
        mut expected := Expr()
        expr.params.get(2, expected)
        result = emit_expr(expected, result, 0, ctx, context)
        result = concat(result, ") != (")
        mut actual := Expr()
        expr.params.get(3, actual)
        result = emit_expr(actual, result, 0, ctx, context)
        result = concat(result, ")) { printf(\"FAIL: assert_eq\\n\"); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("loc") {
        if has_str(context) {
            return format(output, TIL_PREFIX, "Str_from_literal(\"\")")
        } else {
            return concat(output, "\"\"")
        }
    } else {
        // User-defined function call
        // Check if this is a type-qualified call (Type.func(...))
        if has_ufcs_receiver {
            switch first.node_type {
            case NodeType.Identifier(receiver_name):
                mut first_char := receiver_name.get_substr(0, 1)
                if first_char.is_uppercase() {
                    // Check if this is an enum value (no arguments) vs function/constructor call
                    mut has_args := gt(params_len, 1)

                    if not(has_args) {
                        // Simple enum value: Type.Variant -> Type_Variant
                        result = concat(result, receiver_name)
                        result = concat(result, "_")
                        result = concat(result, func_name)
                        if gt(indent, 0) {
                            result = concat(result, ";\n")
                        }
                        return result
                    }

                    // Type-qualified call with args: Type.func(args...) -> Type_func(args...)
                    // For enum constructors with payloads: Type.Variant(val) -> Type_make_Variant(val)
                    // Enum variants are capitalized, function names are lowercase
                    result = concat(result, receiver_name)
                    result = concat(result, "_")
                    mut func_first_char := func_name.get_substr(0, 1)
                    if func_first_char.is_uppercase() {
                        // Enum constructor with payload
                        result = concat(result, "make_")
                    }
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    mut i := 1
                    while lt(i, params_len) {
                        if gt(i, 1) {
                            result = concat(result, ", ")
                        }
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0, ctx, context)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                } else {
                    // Instance UFCS: instance.func(args...) -> Type_func(instance, args...)
                    // Look up the receiver's type for proper mangling (only if mangled name exists)
                    mut receiver_type := ValueType.TCustom("")
                    mut symbol := context.scope_stack.lookup_symbol(receiver_name)
                    receiver_type = symbol.value_type
                    switch receiver_type {
                    case ValueType.TCustom(type_name):
                        // Skip "auto" type - it's an inferred type placeholder
                        if gt(type_name.len(), 0).and(not(Str.eq(type_name, "auto"))) {
                            // Only mangle if Type_func exists in scope_stack
                            mut candidate := concat(type_name, "_")
                            candidate = concat(candidate, func_name)
                            _ := context.scope_stack.lookup_func(candidate)
                            // If lookup succeeded, use mangled name
                            result = concat(result, type_name)
                            result = concat(result, "_")
                            catch (err: KeyNotFoundError) { /* func not found, no prefix */ }
                        }
                    case:
                        // No type found, emit without prefix
                    }
                    catch (err: KeyNotFoundError) { /* type not found, no prefix */ }
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    result = concat(result, til_name(receiver_name))
                    // Emit intermediate field accesses (all except the last which is the method)
                    mut field_idx := 0
                    while lt(field_idx, sub(ufcs_depth, 1)) {
                        mut field_expr := Expr()
                        first.params.get(field_idx, field_expr)
                        switch field_expr.node_type {
                        case NodeType.Identifier(field_name):
                            result = concat(result, ".")
                            result = concat(result, field_name)
                        case:
                            // skip
                        }
                        field_idx = add(field_idx, 1)
                    }
                    mut i := 1
                    while lt(i, params_len) {
                        result = concat(result, ", ")
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0, ctx, context)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }
            case:
                throw "ccodegen: expected identifier for UFCS receiver"
            }
        }
        // Regular function call - check for UFCS: func(instance, ...) -> Type_func(instance, ...)
        // If first argument is a variable with known type, try mangled name
        mut mangled_name := func_name
        if gt(params_len, 1) {
            mut first_arg := Expr()
            expr.params.get(1, first_arg)
            switch first_arg.node_type {
            case NodeType.Identifier(first_arg_name):
                mut receiver_type := ValueType.TCustom("")
                mut symbol := context.scope_stack.lookup_symbol(first_arg_name)
                receiver_type = symbol.value_type
                switch receiver_type {
                case ValueType.TCustom(type_name):
                    // Skip "auto" type - it's an inferred type placeholder
                    if gt(type_name.len(), 0).and(not(Str.eq(type_name, "auto"))) {
                        // Check if mangled function exists in scope_stack
                        mut candidate := concat(type_name, "_")
                        candidate = concat(candidate, func_name)
                        _ := context.scope_stack.lookup_func(candidate)
                        // If lookup succeeded, use mangled name
                        mangled_name = candidate
                        catch (err: KeyNotFoundError) { /* func not found, no mangling */ }
                    }
                case:
                    // Not a custom type, no mangling
                }
                catch (err: KeyNotFoundError) { /* type not found, no mangling */ }
            case:
                // First arg not an identifier, no UFCS mangling
            }
            catch (err: IndexOutOfBoundsError) { /* no args */ }
        }

        result = concat(result, mangled_name)
        result = concat(result, "(")

        // Check if this is a variadic function
        mut variadic_info := VariadicParamInfo()
        mut is_variadic := false
        ctx.func_variadic_args.get(mangled_name, variadic_info)
        is_variadic = true
        catch (err: KeyNotFoundError) {
            is_variadic = false
        }

        if is_variadic {
            // Emit regular args first
            mut i := 1
            mut regular_end := add(variadic_info.regular_count, 1)  // +1 to skip func name
            while lt(i, regular_end) {
                if gt(i, 1) {
                    result = concat(result, ", ")
                }
                mut arg := Expr()
                expr.params.get(i, arg)
                result = emit_expr(arg, result, 0, ctx, context)
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }

            // Emit count of variadic args
            mut variadic_count := sub(params_len, regular_end)
            if gt(regular_end, 1) {
                result = concat(result, ", ")
            }
            result = concat(result, variadic_count.to_str())

            // Emit variadic args
            mut vi := regular_end
            while lt(vi, params_len) {
                result = concat(result, ", ")
                mut arg := Expr()
                expr.params.get(vi, arg)
                result = emit_expr(arg, result, 0, ctx, context)
                vi = add(vi, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        } else {
            // Non-variadic: emit args normally
            mut i := 1
            while lt(i, params_len) {
                if gt(i, 1) {
                    result = concat(result, ", ")
                }
                mut arg := Expr()
                expr.params.get(i, arg)
                result = emit_expr(arg, result, 0, ctx, context)
                i = add(i, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        result = concat(result, ")")
        // Only add statement terminator if this is a statement (indent > 0)
        if gt(indent, 0) {
            result = concat(result, ";\n")
        }
        return result
    }

    catch (err: I64_OverflowError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }
}

// Emit identifier without its nested params (for UFCS receiver)
emit_identifier_without_nested := proc(expr: Expr, output: Str) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Identifier(name):
        return concat(output, name)
    case:
        throw "ccodegen: expected identifier"
    }
}

emit_literal := proc(lit: Literal, output: Str, context: Context) returns Str throws Str {
    mut result := ""
    switch lit {
    case Literal.Str(s):
        if has_str(context) {
            result = format(output, TIL_PREFIX, "Str_from_literal(\"", s, "\")")
        } else {
            result = format(output, "\"", s, "\"")
        }
    case Literal.Number(n):
        result = concat(output, n)
    case Literal.List(l):
        throw "ccodegen: List literals not yet supported"
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return result
}
