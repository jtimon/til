mode liba

import("self.init")

// Type checking phase: Validates types, return/throw statements, mode constraints
// This module handles the type checking phase that runs after init.
// No eval, no arena access - pure type analysis.
//
// Translated from src/rs/typer.rs

// Helper function to extract does_throw from an FCall node type (Issue #132)
get_fcall_does_throw := func(e: Expr) returns Bool {
    switch e.node_type {
    case NodeType.FCall(does_throw):
        return does_throw
    case:
        return false
    }
}

// Context tracking for return value usage enforcement (Bug #8 fix)
ExprContext := enum {
    // Return value is being used (assigned, passed as arg, returned, etc)
    ValueUsed,
    // Return value is discarded (statement in Body)
    ValueDiscarded,
}

ThrownType := struct {
    mut type_str: Str = ""
    mut msg: Str = ""
}

// Type-check an imported file's AST.
// Called when the typer encounters an import() call.
// The AST was stored during init phase; we just run type checking on it.
typer_import_declarations := proc(mut context: Context, import_path_str: Str) returns Vec {
    mut errors := Vec.new(Str)
    mut path := import_path_to_file_path(import_path_str)

    // Already done (or in progress)? Skip.
    // Adding to done at START handles both circular imports and re-imports.
    if context.imports_typer_done.contains(path) {
        return errors
    }

    // Mark as done immediately - before processing - to handle circular imports
    _ := context.imports_typer_done.insert(path)

    // Get stored AST from init phase
    mut ast := Expr()
    context.imported_asts.get(path, ast)?
    catch (err: KeyNotFoundError) {
        // This shouldn't happen - init phase should have stored the AST
        errors.push(format("typer: Import ", path, " not found in stored ASTs - init phase should have stored it"))
        return errors
    }

    // Get stored mode from init phase (Bug #41 fix)
    mut file_mode := ModeDef()
    context.imported_modes.get(path, file_mode)?
    catch (err: KeyNotFoundError) {
        // This shouldn't happen - init phase should have stored the mode
        errors.push(format("typer: Import ", path, " not found in stored modes - init phase should have stored it"))
        return errors
    }

    // Save and restore context path and mode (Bug #41 fix: respect imported file's mode)
    mut original_path := context.path
    mut original_mode := context.mode_def
    context.path = path
    context.mode_def = file_mode

    // Bug #128: Run type checking AND resolve INFER_TYPE, then update stored AST
    mut result := type_check(context, ast)?
    catch (err: Str) {
        context.path = original_path
        context.mode_def = original_mode
        errors.push(err)
        return errors
    }

    // Update stored AST with resolved version
    context.imported_asts.set(path, result.resolved_ast)

    context.path = original_path
    context.mode_def = original_mode
    return result.errors
}

check_enum_def := proc(context: Context, e: Expr, enum_def: SEnumDef) returns Vec throws Str {
    mut errors := Vec.new(Str)
    if not(e.params.len().eq(0)) {
        e.exit_error("type", "in check_enum_def(): enum declarations don't have any parameters in the tree.")
        return errors
    }

    // Bug #38 fix: Iterate over variants Vec
    for i in 0..enum_def.variants.len() {
        mut ev := EnumVariant()
        enum_def.variants.get(i, ev)?
        enum_val_name := ev.name
        payload_ptr := ev.payload_type

        // Check if payload_ptr is Some (not NULL)
        if not(NULL.eq(payload_ptr.data)) {
            mut value_type := ValueType.TCustom("")
            memcpy(to_ptr(value_type), payload_ptr.data, size_of(ValueType))
            switch value_type {
            case ValueType.TCustom(custom_type_name):
                // Validate that the custom type exists
                mut symbol_found := false
                mut symbol_info := SymbolInfo()
                symbol_info = context.scope_stack.lookup_symbol(custom_type_name)?
                symbol_found = true
                catch (err: KeyNotFoundError) {
                    // Symbol not found
                }

                if not(symbol_found) {
                    errors.push(e.error(context.path, "type", format(
                        "Enum variant '", enum_val_name, "' uses undefined type '", custom_type_name, "'.\nHint: Make sure '", custom_type_name, "' is defined before this enum."
                    )))
                } else {
                    // Validate it's actually a type (enum or struct), not a value
                    switch symbol_info.value_type {
                    case ValueType.TType(TTypeDef.TEnumDef):
                        // Valid type
                    case ValueType.TType(TTypeDef.TStructDef):
                        // Valid type
                    case:
                        errors.push(e.error(context.path, "type", format(
                            "Enum variant '", enum_val_name, "' payload type '", custom_type_name, "' is not a valid type (expected enum or struct, found ", value_type_to_str(symbol_info.value_type), ")."
                        )))
                    }
                }
            case:
                errors.push(e.todo_error(context.path, "type", format("'enum' does not support payloads of value type '", value_type_to_str(value_type), "' yet")))
            }
        }
        // else: NULL means None (no payload), nothing to check
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

// Internal entry point: assumes Body-level context (return values discarded at statement level)
// Note: Prefer type_check() which also resolves INFER_TYPE in the AST.
check_types := proc(mut context: Context, e: Expr) returns Vec throws Str {
    return check_types_with_context(context, e, ExprContext.ValueDiscarded)?
}

// Internal type checker with context tracking for return value usage
check_types_with_context := proc(mut context: Context, e: Expr, expr_context: ExprContext) returns Vec throws Str {
    mut errors := Vec.new(Str)
    switch e.node_type {
    case NodeType.Body:
        // Statements in Body discard return values
        for i in 0..e.params.len() {
            mut p := Expr()
            e.params.get(i, p)?
            errors.extend(check_types_with_context(context, p, ExprContext.ValueDiscarded)?)
        }
    case NodeType.EnumDef(enum_def):
        errors.extend(check_enum_def(context, e, enum_def)?)
    case NodeType.StructDef(struct_def):
        errors.extend(check_struct_def(context, e, struct_def)?)
    case NodeType.If:
        errors.extend(check_if_statement(context, e)?)
    case NodeType.While:
        errors.extend(check_while_statement(context, e)?)
    case NodeType.Switch:
        errors.extend(check_switch_statement(context, e)?)
    case NodeType.Range:
        if not(e.params.len().eq(2)) {
            errors.push(e.lang_error(context.path, "type", "Range expression must have exactly two elements"))
            return errors
        }

        // Range operands are used
        mut left_expr := Expr()
        mut right_expr := Expr()
        e.params.get(0, left_expr)?
        e.params.get(1, right_expr)?
        errors.extend(check_types_with_context(context, left_expr, ExprContext.ValueUsed)?)
        errors.extend(check_types_with_context(context, right_expr, ExprContext.ValueUsed)?)

        mut left_type_ok := false
        mut right_type_ok := false
        mut left_type := ValueType.TCustom("")
        mut right_type := ValueType.TCustom("")

        left_type = get_value_type(context, left_expr)?
        left_type_ok = true
        catch (err: Str) {
            errors.push(err)
        }

        right_type = get_value_type(context, right_expr)?
        right_type_ok = true
        catch (err: Str) {
            errors.push(err)
        }

        if left_type_ok.and(right_type_ok) {
            // Compare types using value_type_to_str (includes payload for TCustom/TMulti)
            if not(value_type_to_str(left_type).eq(value_type_to_str(right_type))) {
                errors.push(e.error(context.path, "type", format("Range start and end must be of same type, found '", value_type_to_str(left_type), "' and '", value_type_to_str(right_type), "'")))
            }
        }
    case NodeType.FCall(does_throw):
        // Special handling for import() calls - type-check the imported file
        mut f_name := get_func_name_in_call(e)?
        if f_name.eq("import") {
            // Get the import path from the argument
            if e.params.len().gt(1) {
                mut path_expr := e.get(1)?
                switch path_expr.node_type {
                case NodeType.LLiteral(lit):
                    switch lit {
                    case Literal.Str(import_path):
                        errors.extend(typer_import_declarations(context, import_path))
                    case:
                        // Not a string literal
                    }
                case:
                    // Dynamic import path - can't type-check at compile time
                }
            }
        }
        errors.extend(check_fcall(context, e, does_throw)?)
        // Check if return value usage is correct for this context
        errors.extend(check_fcall_return_usage(context, e, expr_context)?)
    case NodeType.FuncDef(func_def):
        context.scope_stack.push(ScopeType.Function)
        errors.extend(check_func_proc_types(func_def, context, e)?)
        _ := context.scope_stack.pop()?
        catch (err: Str) {
            // Ignore pop error
        }
    case NodeType.Identifier(name):
        // Bug #32 fix: "_" is a special marker for field access on expression results
        // params[0] is the expression, params[1..] are the field chain (field names, not symbols)
        if name.eq("_") {
            if e.params.len().gt(0) {
                // Only check the base expression (params[0])
                // params[1..] are field identifiers that don't need symbol lookup
                errors.extend(check_types_with_context(context, e.get(0)?, ExprContext.ValueUsed)?)
            }
        } else {
            mut func_found := false
            mut symbol_found := false
            mut dummy_func := SFuncDef()
            dummy_func = context.scope_stack.lookup_func(name)?
            func_found = true
            catch (err: KeyNotFoundError) {
                func_found = false  // Bug #68 fix: is_some() = false when throws
            }
            mut dummy_symbol := SymbolInfo()
            dummy_symbol = context.scope_stack.lookup_symbol(name)?
            symbol_found = true
            catch (err: KeyNotFoundError) {
                symbol_found = false  // Bug #68 fix: is_some() = false when throws
            }
            if not(func_found.or(symbol_found)) {
                errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
            } else if context.scope_stack.is_closure_capture(name) {
                // Bug #50: Closures not supported yet
                errors.push(e.todo_error(context.path, "type", format(
                    "Closures are not supported yet. Pass '", name, "' as a parameter to this function instead.")))
            } else {
                // Bug #101: Mark symbol as used
                context.scope_stack.mark_symbol_used(name)
            }
        }
    case NodeType.Declaration(decl):
        errors.extend(check_declaration(context, e, decl)?)
    case NodeType.Assignment(var_name):
        errors.extend(check_assignment(context, e, var_name)?)
    case NodeType.Return:
        // Return values are used
        for return_val: Expr in e.params {
            errors.extend(check_types_with_context(context, return_val, ExprContext.ValueUsed)?)
        }
    case NodeType.Throw:
        // Throw values are used
        for throw_val: Expr in e.params {
            errors.extend(check_types_with_context(context, throw_val, ExprContext.ValueUsed)?)
        }
    case NodeType.Catch:
        errors.extend(check_catch_statement(context, e)?)
    case NodeType.Break:
        // Break and Continue are simple statements with no parameters to type-check
        // Scope validation (must be inside a loop) could be added here later
    case NodeType.Continue:
        // Break and Continue are simple statements with no parameters to type-check
        // Scope validation (must be inside a loop) could be added here later
    case NodeType.LLiteral(_):
        // Nothing to check
    case NodeType.DefaultCase:
        // Nothing to check
    case NodeType.Pattern(_):
        // Nothing to check
    case NodeType.NamedArg(_):
        // Check the value expression
        for p: Expr in e.params {
            errors.extend(check_types_with_context(context, p, ExprContext.ValueUsed)?)
        }
    case NodeType.ForIn(_var_type):
        errors.extend(check_forin_statement(context, e)?)
    case:
        // Other node types not handled
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

// Helper function to validate conditional statement parameters
// Returns empty string if OK, error message if validation fails
validate_conditional_params := proc(_path: Str, e: Expr, stmt_type: Str, min: I64, max: I64) returns Str {
    if e.params.len().lt(min).or(e.params.len().gt(max)) {
        if min.eq(max) {
            e.exit_error("type", format(stmt_type, " nodes must have exactly ", I64.to_str(min), " parameters."))
        } else {
            e.exit_error("type", format(stmt_type, " nodes must have ", I64.to_str(min), " or ", I64.to_str(max), " parameters."))
        }
    }
    return ""
}

// Helper function to validate function/procedure argument counts
// Returns empty string if OK, error message if validation fails
validate_func_arg_count := func(path: Str, e: Expr, f_name: Str, func_def: SFuncDef) returns Str throws Str {
    provided_args := e.params.len().sub(1)

    // Count required args (those without default values)
    mut required_args := 0
    for i in 0..func_def.args.len() {
        mut arg_decl := Declaration()
        func_def.args.get(i, arg_decl)?
        if NULL.eq(arg_decl.default_value.data) {
            required_args.inc()
        }
        catch (err: IndexOutOfBoundsError) {
            throw format("validate_func_arg_count: ", err.msg)
        }
    }

    has_multi_arg := func_proc_has_multi_arg(func_def)

    // Check arg count for non-variadic functions
    if not(has_multi_arg) {
        if provided_args.lt(required_args) {
            return e.error(path, "type", format("Function/procedure '", f_name, "' expects at least ", I64.to_str(required_args), " args, but ", I64.to_str(provided_args), " were provided."))
        }
        if provided_args.gt(func_def.args.len()) {
            return e.error(path, "type", format("Function/procedure '", f_name, "' expects at most ", I64.to_str(func_def.args.len()), " args, but ", I64.to_str(provided_args), " were provided."))
        }
    }

    // Check minimum count for variadic functions
    if has_multi_arg.and(func_def.args.len().sub(1).gt(provided_args)) {
        return e.error(path, "type", format("Function/procedure '", f_name, "' expects at least ", I64.to_str(func_def.args.len().sub(1)), " args, but ", I64.to_str(provided_args), " were provided."))
    }

    return ""
}

check_if_statement := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)
    err := validate_conditional_params(context.path, e, "if", 2, 3)
    if not(err.eq("")) {
        errors.push(err)
        return errors
    }

    mut inner_e := Expr()
    inner_e = e.get(0)?
    catch (error_str: Str) {
        errors.push(error_str)
        return errors
    }

    // Type check the condition expression exists, but don't enforce it must be Bool
    // NOTE: Bool type checking removed - Bool is a regular struct, not a special primitive
    // DEBUG: This call to get_value_type triggers type checking of the condition
    // which might recursively process nested expressions
    mut val_type := ValueType.TCustom("")
    val_type = get_value_type(context, inner_e)?
    catch (error_string: Str) {
        errors.push(error_string)
        return errors
    }

    // First param (condition) is used, remaining params (then/else bodies) discard values
    for i in 0..e.params.len() {
        mut p := Expr()
        e.params.get(i, p)?
        mut ctx := ExprContext.ValueDiscarded
        if i.eq(0) {
            ctx = ExprContext.ValueUsed
        }
        errors.extend(check_types_with_context(context, p, ctx)?)
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_while_statement := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)
    err := validate_conditional_params(context.path, e, "while", 2, 2)
    if not(err.eq("")) {
        errors.push(err)
        return errors
    }

    mut inner_e := Expr()
    inner_e = e.get(0)?
    catch (error_str: Str) {
        errors.push(error_str)
        return errors
    }

    // Type check the condition expression exists, but don't enforce it must be Bool
    // NOTE: Bool type checking removed - Bool is a regular struct, not a special primitive
    mut val_type := ValueType.TCustom("")
    val_type = get_value_type(context, inner_e)?
    catch (error_string: Str) {
        errors.push(error_string)
        return errors
    }

    // First param (condition) is used, second param (body) discards values
    for i in 0..e.params.len() {
        mut p := Expr()
        e.params.get(i, p)?
        mut ctx := ExprContext.ValueDiscarded
        if i.eq(0) {
            ctx = ExprContext.ValueUsed
        }
        errors.extend(check_types_with_context(context, p, ctx)?)
    }
    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_forin_statement := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)

    // e.params[0] = Identifier(var_name)
    // e.params[1] = collection expression
    // e.params[2] = body
    // NodeType.ForIn(var_type_name)

    mut var_type_name := ""
    switch e.node_type {
    case NodeType.ForIn(type_name):
        var_type_name = type_name
    case:
        errors.push(e.lang_error(context.path, "type", "Expected ForIn node"))
        return errors
    }

    // Extract variable name from params[0]
    mut var_name := ""
    if e.params.len().lt(1) {
        errors.push(e.lang_error(context.path, "type", "ForIn: missing loop variable"))
        return errors
    }
    mut var_expr := e.get(0)?
    switch var_expr.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        errors.push(e.lang_error(context.path, "type", "ForIn: expected identifier for loop variable"))
        return errors
    }

    // Get collection expression
    if e.params.len().lt(2) {
        errors.push(e.lang_error(context.path, "type", "ForIn: missing collection expression"))
        return errors
    }
    mut collection_expr := e.get(1)?

    // Type check the collection expression
    errors.extend(check_types_with_context(context, collection_expr, ExprContext.ValueUsed)?)

    // Get collection type
    mut collection_type := ValueType.TCustom("")
    collection_type = get_value_type(context, collection_expr)?
    catch (err: Str) {
        errors.push(err)
        return errors
    }

    mut type_name := ""
    switch collection_type {
    case ValueType.TCustom(name):
        type_name = name
    case:
        errors.push(e.error(context.path, "type", "for-in loop requires a collection type"))
        return errors
    }

    // Check TypeName.len() exists and returns I64
    len_method := format(type_name, ".len")
    mut len_func := SFuncDef()
    len_func = context.scope_stack.lookup_func(len_method)?
    // Verify returns I64
    if not(len_func.return_types.len().eq(1)) {
        errors.push(e.error(context.path, "type", format("for-in loop: '", type_name, ".len()' must return I64")))
    } else {
        mut ret_type := ValueType.TCustom("")
        len_func.return_types.get(0, ret_type)?
        switch ret_type {
        case ValueType.TCustom(ret_name):
            if not(ret_name.eq("I64")) {
                errors.push(e.error(context.path, "type", format("for-in loop: '", type_name, ".len()' must return I64")))
            }
        case:
            errors.push(e.error(context.path, "type", format("for-in loop: '", type_name, ".len()' must return I64")))
        }
    }
    catch (err: KeyNotFoundError) {
        errors.push(e.error(context.path, "type", format("for-in loop: type '", type_name, "' does not have a 'len()' method.\nRequired: ", type_name, ".len(self) returns I64")))
    }

    // Check TypeName.get() exists with right signature
    get_method := format(type_name, ".get")
    mut get_func := SFuncDef()
    get_func = context.scope_stack.lookup_func(get_method)?
    // Verify signature: get(self, I64, mut Dynamic) throws IndexOutOfBoundsError
    mut valid := get_func.args.len().gteq(3)
    if valid {
        mut arg1 := Declaration()
        get_func.args.get(1, arg1)?
        switch arg1.value_type {
        case ValueType.TCustom(arg1_name):
            if not(arg1_name.eq("I64")) {
                valid = false
            }
        case:
            valid = false
        }
    }
    if valid {
        mut arg2 := Declaration()
        get_func.args.get(2, arg2)?
        if not(arg2.is_mut) {
            valid = false
        }
        switch arg2.value_type {
        case ValueType.TCustom(arg2_name):
            if not(arg2_name.eq("Dynamic")) {
                valid = false
            }
        case:
            valid = false
        }
    }
    if valid {
        // Check throws IndexOutOfBoundsError
        mut throws_index_error := false
        for i in 0..get_func.throw_types.len() {
            mut throw_type := ValueType.TCustom("")
            get_func.throw_types.get(i, throw_type)?
            switch throw_type {
            case ValueType.TCustom(throw_name):
                if throw_name.eq("IndexOutOfBoundsError") {
                    throws_index_error = true
                }
            case:
            }
        }
        if not(throws_index_error) {
            valid = false
        }
    }
    if not(valid) {
        errors.push(e.error(context.path, "type", format("for-in loop: '", type_name, ".get()' has wrong signature.\nRequired: ", type_name, ".get(self, index: I64, mut item: Dynamic) throws IndexOutOfBoundsError")))
    }
    catch (err: KeyNotFoundError) {
        errors.push(e.error(context.path, "type", format("for-in loop: type '", type_name, "' does not have a 'get()' method.\nRequired: ", type_name, ".get(self, index: I64, mut item: Dynamic) throws IndexOutOfBoundsError")))
    }

    // Push scope for loop body, declare loop variable
    context.scope_stack.push(ScopeType.Block)
    context.scope_stack.declare_symbol(var_name, SymbolInfo(value_type=ValueType.TCustom(var_type_name), is_mut=true))?

    // Type check body
    if e.params.len().gteq(3) {
        mut body_expr := e.get(2)?
        errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
    }

    _ := context.scope_stack.pop()?

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_fcall := proc(mut context: Context, e: Expr, does_throw: Bool) returns Vec throws Str {
    mut errors := Vec.new(Str)
    mut f_name := get_func_name_in_call(e)?
    // Bug #101: Mark the function name as used (for local function declarations)
    context.scope_stack.mark_symbol_used(f_name)
    mut e_clone := e  // Clone for potential modification

    // Get func def, allowing for struct instantiation (returns None)
    mut func_def_found := false
    mut func_def := SFuncDef()
    func_def = get_func_def_for_fcall_with_expr(context, e_clone)?
    func_def_found = true
    catch (err: Str) {
        errors.push(err)
        return errors
    }
    catch (err: KeyNotFoundError) {
        // None case - struct or enum instantiation
        // Validate field names for structs (Bug #85)
        // Clone member names to avoid borrow conflict with check_types_with_context
        mut is_struct := false
        mut struct_member_names := Vec.new(Str)
        mut _struct_def := SStructDef()
        _struct_def = context.scope_stack.lookup_struct(f_name)?
        is_struct = true
        for decl: Declaration in _struct_def.members {
            struct_member_names.push(decl.name.clone())
        }
        catch (err2: KeyNotFoundError) {
            // Not a struct - enum constructor, no field validation needed
        }

        // Type-check all arguments (both struct and enum constructors)
        for struct_arg_idx in 1..e_clone.params.len() {
            mut struct_arg := Expr()
            struct_arg = e_clone.get(struct_arg_idx)?
            // Only validate field names for structs
            if is_struct {
                switch struct_arg.node_type {
                case NodeType.NamedArg(field_name):
                    if not(struct_member_names.contains(field_name)) {
                        mut err_msg := format("Field '", field_name, "' does not exist in struct '", f_name, "'")
                        mut field_err := struct_arg.error(context.path, "type", err_msg)
                        errors.push(field_err)
                    }
                case:
                }
            }
            // Also type-check the argument value
            errors.extend(check_types_with_context(context, struct_arg, ExprContext.ValueUsed)?)
        }
        // Issue #132: Struct/enum constructors don't throw, so ? is not allowed
        if does_throw {
            errors.push(e.error(context.path, "type", format("'", f_name, "' is a constructor and does not throw, remove the '?' from the call")))
        }
        return errors
    }

    if not(func_def_found) {
        return errors
    }

    // Update f_name after UFCS transformation (Bug #TODO)
    // The transformation may have changed e.g. "val.eq" -> "U8.eq"
    f_name = get_func_name_in_call(e_clone)?

    // Issue #132: Check mandatory ? for throwing functions
    func_throws := func_def.throw_types.len().gt(0)
    if func_throws.and(not(does_throw)) {
        mut throw_types_str := ""
        for ti in 0..func_def.throw_types.len() {
            mut tt := ValueType.TCustom("")
            func_def.throw_types.get(ti, tt)?
            catch (idx_err: IndexOutOfBoundsError) {
                // REM: Should not happen - iterating within bounds
            }
            if ti.gt(0) {
                throw_types_str = throw_types_str.concat(", ")
            }
            throw_types_str = throw_types_str.concat(value_type_to_str(tt))
        }
        errors.push(e_clone.error(context.path, "type", format("Function '", f_name, "' throws ", throw_types_str, " but call is missing '?'. Add '?' after the closing parenthesis: ", f_name, "(...)?")))
    }
    if not(func_throws).and(does_throw) {
        errors.push(e_clone.error(context.path, "type", format("Function '", f_name, "' does not throw, remove the '?' from the call")))
    }

    err := validate_func_arg_count(context.path, e_clone, f_name, func_def)?
    if not(err.eq("")) {
        errors.push(err)
        return errors
    }

    max_arg_def := func_def.args.len()
    mut def_arg_idx: I64 = 0  // Bug #61: Track definition arg separately from provided arg
    for fcall_arg_idx in 0..e_clone.params.len().sub(1) {
        mut arg_expr := Expr()
        arg_expr = e_clone.get(fcall_arg_idx.add(1))?
        catch (get_err: Str) {
            errors.push(get_err)
            return errors
        }

        // Function call arguments are being used (passed to the function)
        // This must happen BEFORE get_value_type so undefined symbol errors are detected
        errors.extend(check_types_with_context(context, arg_expr, ExprContext.ValueUsed)?)

        // Bug #61: Get provided type early to check if we should skip optional args
        mut found_type := ValueType.TCustom("")
        found_type = get_value_type(context, arg_expr)?
        catch (error_string: Str) {
            errors.push(error_string)
            return errors
        }

        // Bug #61: Skip optional args before variadic when type doesn't match
        while def_arg_idx.lt(max_arg_def) {
            mut current_def := Declaration()
            func_def.args.get(def_arg_idx, current_def)?
            catch (idx_err: IndexOutOfBoundsError) {
                break
            }

            mut expected := current_def.value_type
            switch current_def.value_type {
            case ValueType.TMulti(inner):
                expected = str_to_value_type(inner)
            case:
            }

            // Check if types are compatible
            // Bug #124: Allow I64 literals to be passed as U8 arguments
            mut is_u8_i64_coercion_skip := false
            switch expected {
            case ValueType.TCustom(expected_tn):
                if expected_tn.eq("U8") {
                    switch found_type {
                    case ValueType.TCustom(found_tn):
                        if found_tn.eq("I64") {
                            switch arg_expr.node_type {
                            case NodeType.LLiteral(literal):
                                switch literal {
                                case Literal.Number(_):
                                    is_u8_i64_coercion_skip = true
                                case:
                                }
                            case:
                            }
                        }
                    case:
                    }
                }
            case:
            }
            mut types_ok := false
            switch expected {
            case ValueType.TCustom(tn):
                if tn.eq("Dynamic").or(tn.eq("Type")) {
                    types_ok = true
                } else {
                    types_ok = value_type_to_str(expected).eq(value_type_to_str(found_type)).or(is_u8_i64_coercion_skip)
                }
            case:
                types_ok = value_type_to_str(expected).eq(value_type_to_str(found_type)).or(is_u8_i64_coercion_skip)
            }

            if types_ok {
                break  // Use this def arg
            }

            // Types don't match - check if we can skip this optional arg
            has_default := not(NULL.eq(current_def.default_value.data))
            mut variadic_follows := false
            if def_arg_idx.add(1).lt(max_arg_def) {
                mut next_def := Declaration()
                func_def.args.get(def_arg_idx.add(1), next_def)?
                catch (idx_err: IndexOutOfBoundsError) {}
                switch next_def.value_type {
                case ValueType.TMulti(_):
                    variadic_follows = true
                case:
                }
            }

            if has_default.and(variadic_follows) {
                def_arg_idx = def_arg_idx.add(1)
                continue
            }

            break  // Can't skip, will report type error
        }

        // min(def_arg_idx, max_arg_def - 1)
        mut arg_idx := def_arg_idx
        if arg_idx.gteq(max_arg_def) {
            arg_idx = max_arg_def.sub(1)
        }

        mut arg := Declaration()
        func_def.args.get(arg_idx, arg)?
        catch (idx_err: IndexOutOfBoundsError) {
            errors.push(e_clone.lang_error(context.path, "type", format("argument index ", I64.to_str(def_arg_idx), " out of bounds for function '", f_name, "'")))
            return errors
        }

        // Get expected type
        mut expected_type := arg.value_type
        switch arg.value_type {
        case ValueType.TMulti(inner_type_name):
            expected_type = str_to_value_type(inner_type_name)
        case:
            // Keep as-is
        }

        // Note: check_types_with_context called earlier in loop (before found_type calculation)

        // Check mut/own parameter requirements (Bug #48, Bug #63)
        // Both mut and own parameters require mutable variables
        if arg.is_mut.or(arg.is_own) {
            mut param_kind := "own"
            if arg.is_mut { param_kind = "mut" }
            switch arg_expr.node_type {
            case NodeType.Identifier(var_name):
                // Simple variable - check if it's mut
                mut symbol_found := false
                mut symbol_info := SymbolInfo()
                symbol_info = context.scope_stack.lookup_symbol(var_name)?
                symbol_found = true
                catch (key_err: KeyNotFoundError) {
                    // Not found
                }
                if symbol_found {
                    if not(symbol_info.is_mut) {
                        errors.push(arg_expr.error(context.path, "type", format(
                            "Cannot pass const variable '", var_name, "' to ", param_kind, " parameter '", arg.name, "' of function '", f_name, "'.\nSuggestion: declare '", var_name, "' as 'mut ", var_name, "'."
                        )))
                    }
                }
            case NodeType.LLiteral(_):
                errors.push(arg_expr.error(context.path, "type", format(
                    "Cannot pass literal to ", param_kind, " parameter '", arg.name, "'. Use a variable instead."
                )))
            case:
                // FCall: Allow - function results can be passed to mut/own parameters
                // Other node types: Shouldn't happen, but allow to avoid false positives
            }
        }

        // Check copy parameter requirements - structs must have clone() implementation
        // Only check for explicit 'copy' parameters, not regular immutable parameters
        if arg.is_copy {
            // Get the actual type being passed
            mut arg_type_ok := false
            mut arg_type := ValueType.TCustom("")
            arg_type = get_value_type(context, arg_expr)?
            arg_type_ok = true
            catch (type_err: Str) {
                // Type error already reported, skip clone check
            }

            if arg_type_ok {
                // Only check for custom types (user-defined structs)
                switch arg_type {
                case ValueType.TCustom(type_name):
                    // Skip primitive types that are trivially copyable (don't require clone())
                    // These types are copy-by-value and don't need deep cloning
                    // NOTE: Bool removed from this list - it's a regular struct, not a special primitive
                    mut is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Str"))
                    if not(is_primitive) {
                        mut copy_struct_found := false
                        mut copy_struct_def := SStructDef()
                        copy_struct_def = context.scope_stack.lookup_struct(type_name)?
                        copy_struct_found = true
                        catch (struct_err: KeyNotFoundError) {
                            // Not found
                        }
                        if copy_struct_found {
                            // Check if clone() exists as a const (associated function)
                            mut has_clone := false
                            mut clone_decl := Declaration()
                            clone_decl = copy_struct_def.get_member("clone")?
                            has_clone = not(clone_decl.is_mut)
                            catch (clone_err: Str) {
                                // No clone method found - has_clone stays false
                            }

                            if not(has_clone) {
                                errors.push(arg_expr.error(context.path, "type", format(
                                    "Cannot pass struct '", type_name, "' to copy parameter '", arg.name, "' of function '", f_name, "'.\nReason: struct '", type_name, "' does not implement clone() method.\nSuggestion: add 'clone := func(self: ", type_name, ") returns ", type_name, " { ... }' to struct '", type_name, "'."
                                )))
                            }
                        }
                    }
                case:
                    // Not a custom type
                }
            }
        }

        // Note: found_type was already computed at start of loop for Bug #61 skip logic
        // Bug #124: Allow I64 literals to be passed as U8 arguments
        mut is_u8_i64_coercion := false
        switch expected_type {
        case ValueType.TCustom(expected_tn):
            if expected_tn.eq("U8") {
                switch found_type {
                case ValueType.TCustom(found_tn):
                    if found_tn.eq("I64") {
                        switch arg_expr.node_type {
                        case NodeType.LLiteral(literal):
                            switch literal {
                            case Literal.Number(_):
                                is_u8_i64_coercion = true
                            case:
                            }
                        case:
                        }
                    }
                case:
                }
            }
        case:
        }
        // Check type compatibility
        switch expected_type {
        case ValueType.TCustom(tn):
            if tn.eq("Dynamic").or(tn.eq("Type")) {
                // Accept any type for Dynamic/Type-typed argument
            } else if tn.eq(INFER_TYPE) {
                errors.push(e_clone.error(context.path, "type", format(
                    "calling func/proc '", f_name, "' declared arg ", arg.name, " without type, but type inference in args is not supported.\nSuggestion: the arg should be '", arg.name, " : ", value_type_to_str(found_type), ",' instead of just '", arg.name, "'.\nAlternative option: the arg could be '", arg.name, " : Dynamic,' for dynamic arguments."
                )))
            } else {
                // Check type match
                if not(value_type_to_str(expected_type).eq(value_type_to_str(found_type))).and(not(is_u8_i64_coercion)) {
                    errors.push(e_clone.error(context.path, "type", format(
                        "calling function '", f_name, "' expects '", value_type_to_str(expected_type), "' for arg '", arg.name, "', but '", value_type_to_str(found_type), "' was provided."
                    )))
                }
            }
        case:
            // Check type match
            if not(value_type_to_str(expected_type).eq(value_type_to_str(found_type))).and(not(is_u8_i64_coercion)) {
                errors.push(e_clone.error(context.path, "type", format(
                    "calling function '", f_name, "' expects '", value_type_to_str(expected_type), "' for arg '", arg.name, "', but '", value_type_to_str(found_type), "' was provided."
                )))
            }
        }

        // Bug #49: Handle ownership transfer for 'own' parameters
        // Remove the symbol from scope so subsequent uses get "undefined symbol" error
        if arg.is_own {
            switch arg_expr.node_type {
            case NodeType.Identifier(var_name):
                // Only invalidate simple identifiers, not field access or function calls
                if arg_expr.params.len().eq(0) {
                    _ := context.scope_stack.remove_symbol(var_name)?
                }
            case:
                // Not an identifier
            }
        }

        // Bug #61: Advance def_arg_idx for non-variadic args
        switch arg.value_type {
        case ValueType.TMulti(_):
            // Variadic - don't advance
        case:
            def_arg_idx = def_arg_idx.add(1)
        }
    }

    return errors
}

// Check if a function call's return value is being used correctly (Bug #8 fix)
check_fcall_return_usage := proc(context: Context, e: Expr, expr_context: ExprContext) returns Vec throws Str {
    mut errors := Vec.new(Str)

    // Get the function definition to check if it returns a value
    mut func_def_found := false
    mut func_def := SFuncDef()
    func_def = get_func_def_for_fcall(context, e)?
    func_def_found = true
    catch (err: Str) {
        // Error already reported by check_fcall
        return errors
    }
    catch (err: KeyNotFoundError) {
        // Struct/enum constructor, no return value check needed
        return errors
    }

    if not(func_def_found) {
        return errors
    }

    // Check if this function returns a value
    returns_value := func_def.return_types.len().gt(0)

    // Compare ExprContext using enum_to_str since enums don't have eq()
    mut is_discarded := false
    switch expr_context {
    case ExprContext.ValueDiscarded:
        is_discarded = true
    case:
        is_discarded = false
    }

    if returns_value.and(is_discarded) {
        f_name := get_func_name_in_call(e)?

        errors.push(e.error(context.path, "type", format(
            "Function '", f_name, "' returns a value that is not being used.\nHint: Capture the return value with '_ := ", f_name, "(...)' or use it in an expression."
        )))
    }

    return errors
}

check_func_proc_types := proc(func_def: SFuncDef, mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)
    // Bug #101: Save outer function's tracking state for nested function support
    mut saved_function_locals := context.scope_stack.function_locals.clone()
    mut saved_used_symbols := context.scope_stack.used_symbols.clone()
    // Bug #97: Clear function_locals at start of each function
    context.scope_stack.function_locals.clear()
    // Bug #101: Clear used_symbols at start of each function
    context.scope_stack.used_symbols.clear()
    if not(context.mode_def.allows_procs).and(func_def.is_proc()) {
        errors.push(e.error(context.path, "type", "Procs not allowed in pure modes"))
    }
    mut has_variadic := false
    for i in 0..func_def.args.len() {
        mut arg := Declaration()
        func_def.args.get(i, arg)?

        if has_variadic {
            errors.push(e.error(context.path, "type", format("Variadic argument '", arg.name, "' must be the last (only one variadic argument allowed).")))
        }

        switch arg.value_type {
        case ValueType.TMulti(multi_type):
            if arg.is_mut {
                errors.push(e.error(context.path, "type", format("Variadic argument '", arg.name, "' cannot be 'mut'.")))
            }
            if not(i.eq(func_def.args.len().sub(1))) {
                errors.push(e.error(context.path, "type", format("Variadic argument '", arg.name, "' must be the last.")))
            }
            has_variadic = true

            // All array types now use the generic Array
            array_type_name := "Array"

            context.scope_stack.declare_symbol(arg.name, SymbolInfo(value_type=ValueType.TCustom(array_type_name)))?
        case ValueType.TCustom(custom_type_name):
            mut custom_symbol_found := false
            mut custom_symbol := SymbolInfo()
            custom_symbol = context.scope_stack.lookup_symbol(custom_type_name)?
            custom_symbol_found = true
            catch (key_err: KeyNotFoundError) {
                errors.push(e.error(context.path, "type", format("Argument '", arg.name, "' is of undefined type '", custom_type_name, "'.")))
                return errors
            }

            // Validate that the custom type is actually a type definition, not a value
            switch custom_symbol.value_type {
            case ValueType.TType(TTypeDef.TStructDef):
                // Valid: struct type
                context.scope_stack.declare_symbol(arg.name, SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))?
                // Register struct fields for type checking
                context.register_struct_fields_for_typecheck(arg.name, custom_type_name)?
            case ValueType.TType(TTypeDef.TEnumDef):
                // Valid: enum type
                context.scope_stack.declare_symbol(arg.name, SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))?
            case:
                // Invalid: not a type, it's a value or something else
                errors.push(e.error(context.path, "type", format("Argument '", arg.name, "' has type '", custom_type_name, "' which is not a valid type (expected struct or enum)")))
            }
        case:
            context.scope_stack.declare_symbol(arg.name, SymbolInfo(value_type=arg.value_type, is_mut=arg.is_mut, is_copy=arg.is_copy, is_own=arg.is_own))?
        }
        // Bug #101: Register argument in function_locals for unused tracking
        context.scope_stack.register_function_local(arg.name, e.line, e.col)
    }

    // TODO re-enable test when it is decided what to do with free, memcpy and memset
    // if func_def.function_type == FunctionType.FTFunc || func_def.function_type == FunctionType.FTFuncExt {
    //     if func_def.return_types.len() == 0 && func_def.throw_types.len() == 0 {
    //         errors.push(e.error(context.path, "type", "funcs must return or throw something, use a proc instead"))
    //     }
    // }

    // Don't check the bodies of external functions
    if func_def.is_ext() {
        // Bug #101: Restore outer function's tracking state before returning
        context.scope_stack.function_locals = saved_function_locals
        context.scope_stack.used_symbols = saved_used_symbols
        return errors
    }

    // TODO should macros be allowed to call procs?
    if not(func_def.is_proc()) {
        for se: Expr in func_def.body {
            if is_expr_calling_procs(context, se)? {
                errors.push(se.error(context.path, "type", "funcs cannot call procs."))
            }
        }
    }
    // Function body statements discard return values at the top level
    for p: Expr in func_def.body {
        errors.extend(check_types_with_context(context, p, ExprContext.ValueDiscarded)?)
    }

    mut return_found := false
    mut thrown_types := Vec.new(ThrownType)
    errors.extend(check_body_returns_throws(context, e, func_def, func_def.body, thrown_types, return_found)?)

    if not(return_found).and(func_def.return_types.len().gt(0)) {
        errors.push(e.error(context.path, "type", "No return statments found in function that returns "))
    }

    // Filter and report only the thrown types that are not declared
    for te: ThrownType in thrown_types {
        mut is_declared := false
        mut decl_idx := 0
        while decl_idx.lt(func_def.throw_types.len()) {
            mut declared := ValueType.TCustom("")
            func_def.throw_types.get(decl_idx, declared)?
            if value_type_to_str(declared).eq(te.type_str) {
                is_declared = true
            }
            decl_idx.inc()
        }
        if not(is_declared) {
            errors.push(te.msg)
        }
    }

    // Warn about declared throws that are never thrown
    mut decl_throw_idx := 0
    while decl_throw_idx.lt(func_def.throw_types.len()) {
        mut declared_throw := ValueType.TCustom("")
        func_def.throw_types.get(decl_throw_idx, declared_throw)?
        mut declared_str := value_type_to_str(declared_throw)

        mut is_thrown := false
        for te: ThrownType in thrown_types {
            if te.type_str.eq(declared_str) {
                is_thrown = true
            }
        }
        if not(is_thrown) {
            errors.push(e.error(context.path, "type", format("`", declared_str, "` is declared in the throws section, but this function never throws it.\nSuggestion: Remove it from the throws section.")))
        }
        decl_throw_idx.inc()
    }

    // Bug #101: Check for unused variables/arguments
    mut unused_symbols := context.scope_stack.get_unused_symbols()
    for unused_name: Str in unused_symbols {
        errors.push(e.error(context.path, "type", format("Unused variable '", unused_name, "'. Suggestion: Use it or rename to '_", unused_name, "'.")))
    }

    // Bug #101: Restore outer function's tracking state
    // Merge inner function's used_symbols into saved state (for nested function closures)
    for used_name: Str in context.scope_stack.used_symbols {
        _ := saved_used_symbols.insert(used_name)
    }
    context.scope_stack.function_locals = saved_function_locals
    context.scope_stack.used_symbols = saved_used_symbols

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    return errors
}

check_body_returns_throws := proc(mut context: Context, e: Expr, func_def: SFuncDef, body: Vec, mut thrown_types: Vec, mut return_found: Bool) returns Vec throws Str {

    mut errors := Vec.new(Str)
    returns_len := func_def.return_types.len()
    mut unconditional_exit_in_sequence := false

    for p: Expr in body {

        // Check if we're processing code after an unconditional return or throw
        if unconditional_exit_in_sequence {
            errors.push(p.error(context.path, "type", "Unreachable code after unconditional return or throw.\nNote: In TIL, catch is a statement that must be reachable, not syntax bound to a try block.\nSuggestion: Move catch blocks (and any other code) before the return/throw."))
        } else {
            switch p.node_type {
            case NodeType.Body:
                mut temp_thrown_types := Vec.new(ThrownType)
                errors.extend(check_body_returns_throws(context, e, func_def, p.params, temp_thrown_types, return_found)?)
                thrown_types.extend(temp_thrown_types)

            case NodeType.Return:
                return_found = true
                unconditional_exit_in_sequence = true
                if not(returns_len.eq(p.params.len())) {
                    errors.push(p.error(context.path, "type", format("Returning ", I64.to_str(p.params.len()), " values when ", I64.to_str(returns_len), " were expected.")))
                    errors.push(e.error(context.path, "type", "Suggestion: Update returns section here"))
                } else {
                    for i in 0..p.params.len() {
                        mut expected_value_type := ValueType.TCustom("")
                        mut have_expected := true
                        func_def.return_types.get(i, expected_value_type)?
                        catch (err: IndexOutOfBoundsError) {
                            errors.push(e.lang_error(context.path, "type", format("Fewer return values than provided at position ", I64.to_str(i))))
                            have_expected = false
                        }

                        mut return_val_e := Expr()
                        mut have_return_val := true
                        p.params.get(i, return_val_e)?
                        catch (err: IndexOutOfBoundsError) {
                            errors.push(e.lang_error(context.path, "type", format("Missing return value at position ", I64.to_str(i))))
                            have_return_val = false
                        }

                        if have_expected.and(have_return_val) {
                            // Recursively check this return expression for throws
                            mut single_expr := Vec.new(Expr)
                            single_expr.push(return_val_e)
                            errors.extend(check_body_returns_throws(context, return_val_e, func_def, single_expr, thrown_types, return_found)?)

                            mut actual_value_type := get_value_type(context, return_val_e)?
                            if not(value_type_to_str(expected_value_type).eq(value_type_to_str(actual_value_type))) {
                                errors.push(return_val_e.error(context.path, "type", format("Return value in pos ", I64.to_str(i), " expected to be '", value_type_to_str(expected_value_type), "', but found '", value_type_to_str(actual_value_type), "' instead")))
                                errors.push(e.error(context.path, "type", "Suggestion: Update returns section here"))
                            }
                            catch (err: Str) {
                                errors.push(err)
                            }
                        }
                    }
                }

            case NodeType.Throw:
                unconditional_exit_in_sequence = true
                if not(p.params.len().eq(1)) {
                    errors.push(p.error(context.path, "type", "Throw statement must have exactly one parameter."))
                } else {
                    mut throw_param := p.get(0)?
                    // Recursively check this throw expression for throws (just in case, although users should avoid this)
                    // TODO fix this, not a priority

                    mut thrown_type := get_value_type(context, throw_param)?
                    switch thrown_type {
                    case ValueType.TType(TTypeDef.TStructDef):
                        errors.push(throw_param.error(context.path, "type", "Cannot throw a struct definition.\nSuggestion: Create an instance by adding parentheses at the end."))
                    case:
                        // Track the thrown type as a string and another string with its error
                        thrown_type_str := value_type_to_str(thrown_type)
                        mut te1 := ThrownType()
                        te1.type_str = thrown_type_str
                        te1.msg = throw_param.error(context.path, "type", format("Function throws '", thrown_type_str, "', but it is not declared in this function's throws section."))
                        thrown_types.push(te1)
                        mut te2 := ThrownType()
                        te2.type_str = thrown_type_str
                        te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                        thrown_types.push(te2)
                    }
                    catch (err: Str) {
                        errors.push(err)
                    }
                }

            case NodeType.Catch:
                if not(p.params.len().eq(3)) {
                    errors.push(p.error(context.path, "type", "Catch must have 3 parameters: variable, type, and body."))
                } else {
                    mut var_name_expr := p.get(0)?
                    mut err_type_expr := p.get(1)?
                    mut catch_body_expr := p.get(2)?

                    mut var_name := ""
                    switch var_name_expr.node_type {
                    case NodeType.Identifier(name):
                        var_name = name
                    case:
                        errors.push(var_name_expr.error(context.path, "type", "Catch variable must be a valid identifier"))
                        return errors
                    }

                    mut caught_type := ""
                    switch err_type_expr.node_type {
                    case NodeType.Identifier(name):
                        caught_type = name
                    case:
                        errors.push(err_type_expr.error(context.path, "type", "Catch type must be a valid identifier"))
                        return errors
                    }

                    // Remove first, before descending into body
                    mut found_match := false
                    for te: ThrownType in thrown_types {
                        if te.type_str.eq(caught_type) {
                            found_match = true
                        }
                    }

                    if found_match {
                        // Remove matching entries
                        mut ri := 0
                        while ri.lt(thrown_types.len()) {
                            mut te_remove := ThrownType()
                            thrown_types.get(ri, te_remove)?
                            if te_remove.type_str.eq(caught_type) {
                                thrown_types.remove(ri)?
                            } else {
                                ri.inc()
                            }
                        }
                    } else {
                        errors.push(p.error(context.path, "type", format("Trying to catch '", caught_type, "', but it is not among the thrown types.")))
                    }

                    // Create scoped context for catch body with the error variable registered
                    context.scope_stack.push(ScopeType.Block)
                    context.scope_stack.declare_symbol(var_name, SymbolInfo(value_type=ValueType.TCustom(caught_type)))?

                    // Register struct fields so err.msg etc. can be accessed during type-checking
                    mut struct_found := false
                    mut struct_def_opt := SStructDef()
                    struct_def_opt = context.scope_stack.lookup_struct(caught_type)?
                    struct_found = true
                    catch (err: KeyNotFoundError) {
                        // Not a struct, skip field registration
                    }
                    if struct_found {
                        for field_decl: Declaration in struct_def_opt.members {
                            combined_name := format(var_name, ".", field_decl.name)
                            context.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=field_decl.value_type))?
                        }
                    }

                    // Then check body for other thrown exceptions
                    mut catch_thrown_types := Vec.new(ThrownType)
                    errors.extend(check_body_returns_throws(context, e, func_def, catch_body_expr.params, catch_thrown_types, return_found)?)
                    thrown_types.extend(catch_thrown_types)
                    _ := context.scope_stack.pop()?
                    catch (err: Str) {
                        // Ignore pop error
                    }
                }

            case NodeType.FCall(_):
                mut called_func_def := get_func_def_for_fcall(context, p)?
                for called_throw: ValueType in called_func_def.throw_types {
                    called_throw_str := value_type_to_str(called_throw)
                    error_msg := format("Function throws '", called_throw_str, "', but it is not declared in this function's throws section.")

                    mut fcall_te1 := ThrownType()
                    fcall_te1.type_str = called_throw_str
                    fcall_te1.msg = p.error(context.path, "type", error_msg)
                    thrown_types.push(fcall_te1)
                    mut fcall_te2 := ThrownType()
                    fcall_te2.type_str = called_throw_str
                    fcall_te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                    thrown_types.push(fcall_te2)
                }

                // Check nested function calls in arguments
                mut argi := 1
                while argi.lt(p.params.len()) {
                    mut arg := Expr()
                    p.params.get(argi, arg)?
                    switch arg.node_type {
                    case NodeType.FCall(_):
                        mut arg_nested_func_def := get_func_def_for_fcall(context, arg)?
                        mut arg_thrown_types := Vec.new(ThrownType)
                        errors.extend(check_body_returns_throws(context, arg, arg_nested_func_def, arg.params, arg_thrown_types, return_found)?)
                        thrown_types.extend(arg_thrown_types)
                        catch (err: Str) {
                            errors.push(arg.error(context.path, "type", format("Failed to resolve nested function call: ", err)))
                        }
                        catch (err: KeyNotFoundError) {
                            // Enum/struct constructor - no throw checking needed
                        }
                    // Bug #36 fix: Handle named arguments in struct literals (e.g., Map(keys=self.keys.clone()))
                    case NodeType.NamedArg(_):
                        if arg.params.len().gt(0) {
                            mut named_arg_value_expr := Expr()
                            arg.params.get(0, named_arg_value_expr)?
                            switch named_arg_value_expr.node_type {
                            case NodeType.FCall(_):
                                mut named_arg_nested_func_def := get_func_def_for_fcall(context, named_arg_value_expr)?
                                mut named_arg_thrown_types := Vec.new(ThrownType)
                                errors.extend(check_body_returns_throws(context, named_arg_value_expr, named_arg_nested_func_def, named_arg_value_expr.params, named_arg_thrown_types, return_found)?)
                                thrown_types.extend(named_arg_thrown_types)
                                catch (err: Str) {
                                    errors.push(named_arg_value_expr.error(context.path, "type", format("Failed to resolve nested function call in named arg: ", err)))
                                }
                                catch (err: KeyNotFoundError) {
                                    // Enum/struct constructor - no throw checking needed
                                }
                            case:
                            }
                        }
                    case:
                        // Not a function call, skip
                    }
                    argi.inc()
                }
                catch (err: Str) {
                    errors.push(p.error(context.path, "type", err))
                }
                catch (err: KeyNotFoundError) {
                    // Enum/struct constructor - but arguments may contain throwing function calls (Bug #36 fix)
                    mut argi2 := 1
                    while argi2.lt(p.params.len()) {
                        mut ctor_arg := Expr()
                        p.params.get(argi2, ctor_arg)?
                        switch ctor_arg.node_type {
                        case NodeType.FCall(_):
                            mut ctor_nested_func_def := get_func_def_for_fcall(context, ctor_arg)?
                            for ctor_called_throw: ValueType in ctor_nested_func_def.throw_types {
                                ctor_called_throw_str := value_type_to_str(ctor_called_throw)
                                ctor_error_msg := format("Function throws '", ctor_called_throw_str, "', but it is not declared in this function's throws section.")
                                mut ctor_te1 := ThrownType()
                                ctor_te1.type_str = ctor_called_throw_str
                                ctor_te1.msg = ctor_arg.error(context.path, "type", ctor_error_msg)
                                thrown_types.push(ctor_te1)
                                mut ctor_te2 := ThrownType()
                                ctor_te2.type_str = ctor_called_throw_str
                                ctor_te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                                thrown_types.push(ctor_te2)
                            }
                            catch (err2: Str) {
                                errors.push(ctor_arg.error(context.path, "type", format("Failed to resolve nested function call: ", err2)))
                            }
                            catch (err2: KeyNotFoundError) {
                            }
                        // Bug #36 fix: Handle named arguments in struct literals
                        case NodeType.NamedArg(_):
                            if ctor_arg.params.len().gt(0) {
                                mut ctor_named_value_expr := Expr()
                                ctor_arg.params.get(0, ctor_named_value_expr)?
                                switch ctor_named_value_expr.node_type {
                                case NodeType.FCall(_):
                                    mut ctor_named_nested_func_def := get_func_def_for_fcall(context, ctor_named_value_expr)?
                                    for ctor_named_called_throw: ValueType in ctor_named_nested_func_def.throw_types {
                                        ctor_named_called_throw_str := value_type_to_str(ctor_named_called_throw)
                                        ctor_named_error_msg := format("Function throws '", ctor_named_called_throw_str, "', but it is not declared in this function's throws section.")
                                        mut ctor_named_te1 := ThrownType()
                                        ctor_named_te1.type_str = ctor_named_called_throw_str
                                        ctor_named_te1.msg = ctor_named_value_expr.error(context.path, "type", ctor_named_error_msg)
                                        thrown_types.push(ctor_named_te1)
                                        mut ctor_named_te2 := ThrownType()
                                        ctor_named_te2.type_str = ctor_named_called_throw_str
                                        ctor_named_te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                                        thrown_types.push(ctor_named_te2)
                                    }
                                    catch (err2: Str) {
                                        errors.push(ctor_named_value_expr.error(context.path, "type", format("Failed to resolve nested function call in named arg: ", err2)))
                                    }
                                    catch (err2: KeyNotFoundError) {
                                    }
                                case:
                                }
                            }
                        case:
                        }
                        argi2.inc()
                    }
                }

            case NodeType.While:
                mut while_thrown_types := Vec.new(ThrownType)
                if p.params.len().gt(0) {
                    mut while_cond_expr := Expr()
                    p.params.get(0, while_cond_expr)?
                    mut while_single_cond := Vec.new(Expr)
                    while_single_cond.push(while_cond_expr)
                    errors.extend(check_body_returns_throws(context, e, func_def, while_single_cond, while_thrown_types, return_found)?)
                }
                if p.params.len().gt(1) {
                    mut while_body_expr := Expr()
                    p.params.get(1, while_body_expr)?
                    errors.extend(check_body_returns_throws(context, e, func_def, while_body_expr.params, while_thrown_types, return_found)?)
                }
                thrown_types.extend(while_thrown_types)

            case NodeType.ForIn(var_type_name):
                // ForIn: params[0]=var, params[1]=collection, params[2]=body
                mut forin_thrown_types := Vec.new(ThrownType)
                if p.params.len().gt(1) {
                    mut collection_expr := Expr()
                    p.params.get(1, collection_expr)?
                    mut single_collection := Vec.new(Expr)
                    single_collection.push(collection_expr)
                    errors.extend(check_body_returns_throws(context, e, func_def, single_collection, forin_thrown_types, return_found)?)
                }
                if p.params.len().gt(2) {
                    mut forin_body_expr := Expr()
                    p.params.get(2, forin_body_expr)?
                    // Push scope and declare loop variable before checking body
                    mut forin_var_name := ""
                    if p.params.len().gt(0) {
                        mut forin_var_expr := Expr()
                        p.params.get(0, forin_var_expr)?
                        switch forin_var_expr.node_type {
                        case NodeType.Identifier(name):
                            forin_var_name = name
                        case:
                        }
                    }
                    context.scope_stack.push(ScopeType.Block)
                    context.scope_stack.declare_symbol(forin_var_name, SymbolInfo(value_type=ValueType.TCustom(var_type_name), is_mut=true))?
                    errors.extend(check_body_returns_throws(context, e, func_def, forin_body_expr.params, forin_thrown_types, return_found)?)
                    _ := context.scope_stack.pop()?
                }
                thrown_types.extend(forin_thrown_types)

            case NodeType.If:
                mut if_thrown_types := Vec.new(ThrownType)
                if p.params.len().gt(0) {
                    mut if_cond_expr := Expr()
                    p.params.get(0, if_cond_expr)?
                    mut if_single_cond := Vec.new(Expr)
                    if_single_cond.push(if_cond_expr)
                    errors.extend(check_body_returns_throws(context, e, func_def, if_single_cond, if_thrown_types, return_found)?)
                }
                if p.params.len().gt(1) {
                    mut then_block := Expr()
                    p.params.get(1, then_block)?
                    errors.extend(check_body_returns_throws(context, e, func_def, then_block.params, if_thrown_types, return_found)?)
                }
                if p.params.len().gt(2) {
                    mut else_block := Expr()
                    p.params.get(2, else_block)?
                    errors.extend(check_body_returns_throws(context, e, func_def, else_block.params, if_thrown_types, return_found)?)
                }
                thrown_types.extend(if_thrown_types)

            case NodeType.Switch:
                mut switch_thrown_types := Vec.new(ThrownType)

                // Get switch expression type for pattern matching
                mut switch_expr_type := ValueType.TCustom("")
                mut have_switch_type := false
                if p.params.len().gt(0) {
                    mut switch_expr := Expr()
                    p.params.get(0, switch_expr)?
                    switch_expr_type = get_value_type(context, switch_expr)?
                    have_switch_type = true
                    catch (err: Str) {
                        have_switch_type = false
                    }

                    // Analyze the switch expression itself (could throw)
                    mut single_switch := Vec.new(Expr)
                    single_switch.push(switch_expr)
                    errors.extend(check_body_returns_throws(context, e, func_def, single_switch, switch_thrown_types, return_found)?)
                }

                mut si := 1
                while si.add(1).lt(p.params.len()) {
                    mut switch_case_expr := Expr()
                    p.params.get(si, switch_case_expr)?
                    mut switch_body_expr := Expr()
                    p.params.get(si.add(1), switch_body_expr)?

                    // Check case expression
                    mut single_case := Vec.new(Expr)
                    single_case.push(switch_case_expr)
                    errors.extend(check_body_returns_throws(context, e, func_def, single_case, switch_thrown_types, return_found)?)

                    // For pattern matching, add the binding variable to scope before checking body
                    // This mirrors check_switch_statement's scope handling (Bug #28 fix)
                    switch switch_case_expr.node_type {
                    case NodeType.Pattern(pattern_info):
                        mut handled := false
                        switch switch_expr_type {
                        case ValueType.TCustom(enum_name):
                            // Extract variant name (handle "Enum.Variant" format)
                            mut variant := pattern_info.variant_name
                            mut dot_pos := variant.rfind(".")
                            if dot_pos.gt(sub(0, 1)) {
                                variant = variant.get_substr(dot_pos.add(1), variant.len())?
                            }

                            // Look up payload type (Ptr to ValueType, NULL = None)
                            // Bug #38 fix: use helper method
                            mut switch_enum_def := context.scope_stack.lookup_enum(enum_name)?
                            mut payload_ptr := switch_enum_def.get(variant)?
                            catch (err: KeyNotFoundError) { }

                            // If payload exists (not NULL), add binding to scope
                            if not(NULL.eq(payload_ptr.data)) {
                                mut payload_type := ValueType.TCustom("")
                                memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                                context.scope_stack.push(ScopeType.Block)
                                context.scope_stack.declare_symbol(pattern_info.binding_var, SymbolInfo(value_type=payload_type))?
                                errors.extend(check_body_returns_throws(context, e, func_def, switch_body_expr.params, switch_thrown_types, return_found)?)
                                _ := context.scope_stack.pop()?
                                handled = true
                            }
                        case:
                            // Not a custom type
                        }
                        if not(handled) {
                            errors.extend(check_body_returns_throws(context, e, func_def, switch_body_expr.params, switch_thrown_types, return_found)?)
                        }
                    case:
                        errors.extend(check_body_returns_throws(context, e, func_def, switch_body_expr.params, switch_thrown_types, return_found)?)
                    }

                    si = si.add(2)
                }
                thrown_types.extend(switch_thrown_types)

            case NodeType.Declaration(decl):
                // Bug #28 fix: Declare variables so subsequent statements can reference them
                // This mirrors check_declaration's behavior but without full type inference
                if p.params.len().gt(0) {
                    mut initializer := Expr()
                    p.params.get(0, initializer)?

                    // Try to infer the type from the initializer (only if not already declared)
                    mut already_declared := true
                    mut _existing := context.scope_stack.lookup_symbol(decl.name)?
                    catch (err: KeyNotFoundError) {
                        already_declared = false
                    }

                    if not(already_declared) {
                        mut inferred_type := get_value_type(context, initializer)?
                        context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=inferred_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))?
                        catch (err: Str) {
                            // Can't infer type, skip declaration
                        }
                    }

                    switch initializer.node_type {
                    case NodeType.FCall(_):
                        mut is_constructor := false

                        mut id_expr := initializer.get(0)?
                        switch id_expr.node_type {
                        case NodeType.Identifier(name):
                            // Only skip default constructor calls (simple StructName() with no dots)
                            if id_expr.params.len().eq(0) {
                                mut symbol := context.scope_stack.lookup_symbol(name)?
                                switch symbol.value_type {
                                case ValueType.TType(TTypeDef.TStructDef):
                                    is_constructor = true
                                case:
                                }
                                catch (err: KeyNotFoundError) { }
                            }

                            // Check for enum constructors (e.g., Color.Green(true))
                            if id_expr.params.len().eq(1) {
                                mut enum_symbol := context.scope_stack.lookup_symbol(name)?
                                switch enum_symbol.value_type {
                                case ValueType.TType(TTypeDef.TEnumDef):
                                    mut enum_variant_expr := Expr()
                                    id_expr.params.get(0, enum_variant_expr)?
                                    switch enum_variant_expr.node_type {
                                    case NodeType.Identifier(variant_name):
                                        is_constructor = true
                                    case:
                                    }
                                case:
                                }
                                catch (err: KeyNotFoundError) { }
                                catch (err: IndexOutOfBoundsError) { throw err.msg }
                            }
                        case:
                        }
                        catch (err: Str) {
                            errors.push(err)
                        }

                        if not(is_constructor) {
                            mut decl_called_func_def := get_func_def_for_fcall(context, initializer)?
                            for decl_called_throw: ValueType in decl_called_func_def.throw_types {
                                decl_called_throw_str := value_type_to_str(decl_called_throw)
                                decl_error_msg := format("Function throws '", decl_called_throw_str, "', but it is not declared in this function's throws section.")

                                mut decl_te1 := ThrownType()
                                decl_te1.type_str = decl_called_throw_str
                                decl_te1.msg = initializer.error(context.path, "type", decl_error_msg)
                                thrown_types.push(decl_te1)
                                mut decl_te2 := ThrownType()
                                decl_te2.type_str = decl_called_throw_str
                                decl_te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                                thrown_types.push(decl_te2)
                            }

                            mut decl_thrown_types := Vec.new(ThrownType)
                            errors.extend(check_body_returns_throws(context, initializer, decl_called_func_def, initializer.params, decl_thrown_types, return_found)?)
                            thrown_types.extend(decl_thrown_types)
                            catch (err: Str) {
                                // If we can't resolve the function, skip throw checking
                            }
                            catch (err: KeyNotFoundError) {
                                // Struct/enum constructor - no throw checking needed
                            }
                        }
                    case:
                    }
                }

            case NodeType.Assignment(var_name):
                if p.params.len().gt(0) {
                    mut assign_initializer := Expr()
                    p.params.get(0, assign_initializer)?

                    switch assign_initializer.node_type {
                    case NodeType.FCall(_):
                        mut assign_is_constructor := false

                        mut assign_id_expr := assign_initializer.get(0)?
                        switch assign_id_expr.node_type {
                        case NodeType.Identifier(name):
                            // Only skip default constructor calls
                            if assign_id_expr.params.len().eq(0) {
                                mut assign_symbol := context.scope_stack.lookup_symbol(name)?
                                switch assign_symbol.value_type {
                                case ValueType.TType(TTypeDef.TStructDef):
                                    assign_is_constructor = true
                                case:
                                }
                                catch (err: KeyNotFoundError) { }
                            }

                            // Check for enum constructors
                            if assign_id_expr.params.len().eq(1) {
                                mut assign_symbol2 := context.scope_stack.lookup_symbol(name)?
                                switch assign_symbol2.value_type {
                                case ValueType.TType(TTypeDef.TEnumDef):
                                    mut assign_variant_expr := Expr()
                                    assign_id_expr.params.get(0, assign_variant_expr)?
                                    switch assign_variant_expr.node_type {
                                    case NodeType.Identifier(variant_name):
                                        assign_is_constructor = true
                                    case:
                                    }
                                case:
                                }
                                catch (err: KeyNotFoundError) { }
                                catch (err: IndexOutOfBoundsError) { throw err.msg }
                            }
                        case:
                        }
                        catch (err: Str) {
                            errors.push(err)
                        }

                        if not(assign_is_constructor) {
                            mut assign_called_func_def := get_func_def_for_fcall(context, assign_initializer)?
                            for assign_called_throw: ValueType in assign_called_func_def.throw_types {
                                assign_called_throw_str := value_type_to_str(assign_called_throw)
                                assign_error_msg := format("Function throws '", assign_called_throw_str, "', but it is not declared in this function's throws section.")

                                mut assign_te1 := ThrownType()
                                assign_te1.type_str = assign_called_throw_str
                                assign_te1.msg = assign_initializer.error(context.path, "type", assign_error_msg)
                                thrown_types.push(assign_te1)
                                mut assign_te2 := ThrownType()
                                assign_te2.type_str = assign_called_throw_str
                                assign_te2.msg = e.error(context.path, "type", "Suggestion: Either add it to the throws section here, or catch it with a catch block")
                                thrown_types.push(assign_te2)
                            }

                            mut assign_thrown_types := Vec.new(ThrownType)
                            errors.extend(check_body_returns_throws(context, assign_initializer, assign_called_func_def, assign_initializer.params, assign_thrown_types, return_found)?)
                            thrown_types.extend(assign_thrown_types)
                            catch (err: Str) {
                                // If we can't resolve the function, skip throw checking
                            }
                            catch (err: KeyNotFoundError) {
                                // Struct/enum constructor - no throw checking needed
                            }
                        }
                    case:
                    }
                }

            case:
                // Other node types - skip
            }
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_catch_statement := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)

    if not(e.params.len().eq(3)) {
        errors.push(e.error(context.path, "type", "Catch node must have three parameters: variable, type, and body."))
        return errors
    }

    mut err_var_expr := e.get(0)?
    mut err_type_expr := e.get(1)?
    mut body_expr := e.get(2)?

    mut var_name := ""
    switch err_var_expr.node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        errors.push(err_var_expr.error(context.path, "type", "First catch param must be an identifier"))
        return errors
    }

    mut type_name := ""
    switch err_type_expr.node_type {
    case NodeType.Identifier(name):
        type_name = name
    case:
        errors.push(err_type_expr.error(context.path, "type", "Second catch param must be a type identifier"))
        return errors
    }

    // Confirm that the type exists in the context (as done for function args)
    mut type_exists := true
    mut _type_symbol := context.scope_stack.lookup_symbol(type_name)?
    catch (err: KeyNotFoundError) {
        type_exists = false
    }
    if not(type_exists) {
        errors.push(e.error(context.path, "type", format("Catch refers to undefined type '", type_name, "'")))
        return errors
    }

    // Create scoped context for catch body
    context.scope_stack.push(ScopeType.Block)
    context.scope_stack.declare_symbol(var_name, SymbolInfo(value_type=ValueType.TCustom(type_name)))?

    // Map struct fields so err.msg etc. can be accessed during type-checking
    mut struct_def := context.scope_stack.lookup_struct(type_name)?
    for field_decl: Declaration in struct_def.members {
        combined_name := format(var_name, ".", field_decl.name)
        context.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=field_decl.value_type))?
    }
    catch (err: KeyNotFoundError) {
        // Not a struct, skip field registration
    }

    // Catch body statements discard return values
    errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
    _ := context.scope_stack.pop()?
    catch (err: Str) {
        // Ignore pop error
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_declaration := proc(mut context: Context, e: Expr, decl: Declaration) returns Vec throws Str {
    mut errors := Vec.new(Str)
    if not(e.params.len().eq(1)) {
        errors.push(e.error(context.path, "type", format("in declaration of ", decl.name, ", declaration nodes must take exactly 1 parameter.")))
        return errors
    }

    mut inner_e := e.get(0)?

    mut already_declared := true
    mut _existing := context.scope_stack.lookup_symbol(decl.name)?
    catch (err: KeyNotFoundError) {
        already_declared = false
    }

    // Bug #97: Disallow variable shadowing within a function
    // Only check when inside a function (not at global scope).
    // Track declarations by (name, line, col) to handle AST duplication from transformations
    // like for-in desugaring, while still catching actual shadowing.
    if not(decl.name.eq("_")).and(context.scope_stack.is_inside_function()) {
        // Skip if this exact declaration was already processed (AST duplication)
        if context.scope_stack.is_already_processed(decl.name, e.line, e.col) {
            // Same declaration visited again due to AST duplication - skip
        } else if context.scope_stack.is_shadowing_in_function(decl.name, e.line, e.col) {
            // Same name at different location - actual shadowing
            errors.push(e.lang_error(context.path, "type", format("Variable '", decl.name, "' already declared in this function (shadowing not allowed)")))
            return errors
        } else {
            // New declaration - register it
            context.scope_stack.register_function_local(decl.name, e.line, e.col)
        }
    }

    if not(already_declared) {
        mut value_type := decl.value_type
        switch value_type {
        case ValueType.TCustom(type_name):
            if type_name.eq(INFER_TYPE) {
                value_type = get_value_type(context, inner_e)?
                catch (err: Str) {
                    errors.push(err)
                    return errors
                }
            }
        case:
        }

        // TODO move to init_context() ? inner contexts are not persisted in init_context
        context.scope_stack.declare_symbol(decl.name, SymbolInfo(value_type=value_type, is_mut=decl.is_mut, is_copy=decl.is_copy, is_own=decl.is_own))?

        switch value_type {
        case ValueType.TCustom(custom_type):
            if custom_type.eq(INFER_TYPE) {
                errors.push(e.lang_error(context.path, "type", format("Cannot infer the declaration type of ", decl.name)))
                return errors
            }
            // During type checking, register struct fields so they can be accessed in the code
            // Memory allocation and default value evaluation happens during runtime in eval_declaration
            _struct_def := context.scope_stack.lookup_struct(custom_type)?
            context.register_struct_fields_for_typecheck(decl.name, custom_type)?
            catch (err: KeyNotFoundError) {
                // Not a struct, skip field registration
            }

        case ValueType.TFunction(FunctionType.FTFunc):
            switch inner_e.node_type {
            case NodeType.FuncDef(func_def):
                // TODO move to init_context() ? inner contexts are not persisted in init_context
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
                errors.push(e.lang_error(context.path, "type", "functions should have definitions"))
                return errors
            }

        case ValueType.TFunction(FunctionType.FTProc):
            switch inner_e.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
                errors.push(e.lang_error(context.path, "type", "functions should have definitions"))
                return errors
            }

        case ValueType.TFunction(FunctionType.FTMacro):
            switch inner_e.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(decl.name, func_def)?
            case:
                errors.push(e.lang_error(context.path, "type", "functions should have definitions"))
                return errors
            }

        case:
        }
    }

    // The RHS of a declaration is being used (assigned to the variable)
    errors.extend(check_types_with_context(context, inner_e, ExprContext.ValueUsed)?)

    return errors
}

check_assignment := proc(mut context: Context, e: Expr, var_name: Str) returns Vec throws Str {
    mut errors := Vec.new(Str)
    if not(e.params.len().eq(1)) {
        errors.push(e.error(context.path, "type", format("in assignment to ", var_name, ", assignments must take exactly one value, not ", I64.to_str(e.params.len()), ".")))
        return errors
    }

    // Check if it's a function (can't assign to functions)
    mut is_func := true
    _func_def := context.scope_stack.lookup_func(var_name)?
    catch (err: KeyNotFoundError) {
        is_func = false
    }

    if is_func {
        errors.push(e.error(context.path, "type", format("function '", var_name, "' cannot be assigned to.")))
    } else {
        // Check if symbol exists
        mut symbol_exists := true
        mut symbol_info := context.scope_stack.lookup_symbol(var_name)?
        catch (err: KeyNotFoundError) {
            symbol_exists = false
        }

        if symbol_exists {
            // Bug #101: Mark the variable as used (even though we're assigning to it)
            context.scope_stack.mark_symbol_used(var_name)
            if not(symbol_info.is_mut).and(not(symbol_info.is_copy)).and(not(symbol_info.is_own)) {
                errors.push(e.error(context.path, "type", format("Cannot assign to constant '", var_name, "', Suggestion: declare it as 'mut'.")))
            }
            // Additional check: if this is a field access (e.g., "s.value"), also check base instance mutability
            if var_name.contains(".") {
                mut parts := var_name.split(".")?
                if parts.len().gt(0) {
                    mut base_var := ""
                    parts.get(0, base_var)?
                    // Bug #101: Mark base variable as used
                    context.scope_stack.mark_symbol_used(base_var)
                    mut base_info := context.scope_stack.lookup_symbol(base_var)?
                    if not(base_info.is_mut).and(not(base_info.is_copy)).and(not(base_info.is_own)) {
                        errors.push(e.error(context.path, "type", format("Cannot assign to field of constant '", base_var, "', Suggestion: declare it as 'mut ", base_var, "'.")))
                    }
                    catch (err: KeyNotFoundError) {
                        // Base not found - already handled
                    }
                }
            }
        } else if var_name.contains(".") {
            // Field access assignment where the field itself isn't registered in symbols
            // With dynamic offset calculation, we need to validate against struct definition
            mut field_parts := var_name.split(".")?
            mut field_base_var := ""
            field_parts.get(0, field_base_var)?
            // Bug #101: Mark base variable as used
            context.scope_stack.mark_symbol_used(field_base_var)

            mut field_base_exists := true
            mut field_base_info := context.scope_stack.lookup_symbol(field_base_var)?
            catch (err: KeyNotFoundError) {
                field_base_exists = false
            }

            if field_base_exists {
                // Check base mutability
                if not(field_base_info.is_mut).and(not(field_base_info.is_copy)).and(not(field_base_info.is_own)) {
                    errors.push(e.error(context.path, "type", format("Cannot assign to field of constant '", field_base_var, "', Suggestion: declare it as 'mut ", field_base_var, "'.")))
                }

                // Validate field path exists in struct definition
                mut current_type := field_base_info.value_type
                mut has_error := false
                mut pi := 1
                while pi.lt(field_parts.len()) {
                    if not(has_error) {
                        mut field_name := ""
                        field_parts.get(pi, field_name)?
                        switch current_type {
                        case ValueType.TCustom(type_name):
                            mut field_struct_def := context.scope_stack.lookup_struct(type_name)?
                            // Find field in struct members
                            mut field_found := false
                            for field_decl: Declaration in field_struct_def.members {
                                if field_decl.name.eq(field_name) {
                                    current_type = field_decl.value_type
                                    field_found = true
                                }
                            }
                            if not(field_found) {
                                errors.push(e.error(context.path, "type", format("Field '", field_name, "' not found in struct '", type_name, "'")))
                                has_error = true
                            }
                            catch (err: KeyNotFoundError) {
                                errors.push(e.error(context.path, "type", format("Struct '", type_name, "' not found")))
                                has_error = true
                            }
                        case:
                            errors.push(e.error(context.path, "type", format("Cannot access field '", field_name, "' on non-struct type")))
                            has_error = true
                        }
                    }
                    pi.inc()
                }
            } else {
                errors.push(e.error(context.path, "type", format("Undefined symbol '", field_base_var, "'")))
            }
        } else {
            errors.push(e.error(context.path, "type", format("Suggestion: try changing '", var_name, " =' for '", var_name, " :='\nExplanation: Cannot assign to undefined symbol '", var_name, "'.")))
        }
    }

    // The RHS of an assignment is being used (assigned to the variable)
    mut inner_e := e.get(0)?
    errors.extend(check_types_with_context(context, inner_e, ExprContext.ValueUsed)?)
    catch (err: Str) {
        errors.push(err)
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    return errors
}

check_switch_statement := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)

    mut switch_expr := e.get(0)?
    // Bug #101: Check the switch expression to mark variables as used
    errors.extend(check_types_with_context(context, switch_expr, ExprContext.ValueUsed)?)
    mut switch_expr_type := get_value_type(context, switch_expr)?
    catch (err: Str) {
        errors.push(err)
        return errors
    }

    mut case_found := false
    mut default_found := false

    mut i := 1
    while i.lt(e.params.len()) {
        mut case_expr := Expr()
        e.params.get(i, case_expr)?

        switch case_expr.node_type {
        case NodeType.DefaultCase:
            if default_found {
                errors.push(case_expr.error(context.path, "type", "Duplicate default case in switch"))
            }
            default_found = true
            case_found = true

        case NodeType.Pattern(pattern_info):
            // Pattern matching - type is checked in exhaustiveness check below
            case_found = true
            // No need to check type here - patterns implicitly match the switch type

        case:
            case_found = true

            mut case_type := get_value_type(context, case_expr)?
            switch_type_str := value_type_to_str(switch_expr_type)
            case_type_str := value_type_to_str(case_type)
            if not(case_type_str.eq(switch_type_str)).and(not(case_type_str.eq(format(switch_type_str, "Range")))) {
                errors.push(case_expr.error(context.path, "type", format("Switch value type '", switch_type_str, "', case value type '", case_type_str, "' do not match")))
            }
            catch (err: Str) {
                errors.push(err)
            }
        }

        i.inc()

        if i.gteq(e.params.len()) {
            errors.push(e.error(context.path, "type", "Switch case missing body expression"))
            return errors
        }

        mut body_expr := Expr()
        e.params.get(i, body_expr)?

        // For pattern matching, add the binding variable to the context before type checking the body
        switch case_expr.node_type {
        case NodeType.Pattern(pattern_info):
            switch switch_expr_type {
            case ValueType.TCustom(enum_name):
                // Extract just the variant name (remove enum prefix if present)
                mut variant := pattern_info.variant_name
                mut dot_pos := variant.rfind(".")
                if dot_pos.gt(sub(0, 1)) {
                    variant = variant.get_substr(dot_pos.add(1), variant.len())?
                }

                // Look up payload type (Ptr to ValueType, NULL = None)
                // Bug #38 fix: use helper method
                mut enum_def := context.scope_stack.lookup_enum(enum_name)?
                mut payload_ptr := Ptr()
                mut variant_found := true
                payload_ptr = enum_def.get(variant)?
                catch (err: KeyNotFoundError) {
                    variant_found = false
                }

                if variant_found.and(not(NULL.eq(payload_ptr.data))) {
                    // Variant has a payload - create scoped context with binding variable
                    mut payload_type := ValueType.TCustom("")
                    memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                    context.scope_stack.push(ScopeType.Block)
                    context.scope_stack.declare_symbol(pattern_info.binding_var, SymbolInfo(value_type=payload_type))?
                    // Switch case body statements discard return values
                    errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
                    _ := context.scope_stack.pop()?
                } else if variant_found {
                    // Variant exists but has no payload (NULL pointer)
                    errors.push(case_expr.error(context.path, "type", format("Variant '", variant, "' has no payload, cannot use pattern matching")))
                    errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
                } else {
                    // Variant not found
                    mut enum_exists := true
                    mut _check_enum := context.scope_stack.lookup_enum(enum_name)?
                    catch (err: KeyNotFoundError) {
                        enum_exists = false
                    }
                    if enum_exists {
                        errors.push(case_expr.error(context.path, "type", format("Unknown variant '", variant, "'")))
                    }
                    errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
                }
            case:
                errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
            }
        case:
            errors.extend(check_types_with_context(context, body_expr, ExprContext.ValueDiscarded)?)
        }

        i.inc()
    }

    if not(case_found) {
        errors.push(e.error(context.path, "type", "Switch must have at least one case"))
    }

    // Exhaustiveness check only for enums
    switch switch_expr_type {
    case ValueType.TCustom(enum_name):
        mut exh_enum_def := context.scope_stack.lookup_enum(enum_name)?
        mut matched_variants := Vec.new(Str)

        mut j := 1
        while j.lt(e.params.len()) {
            mut exh_case_expr := Expr()
            e.params.get(j, exh_case_expr)?

            switch exh_case_expr.node_type {
            case NodeType.Pattern(exh_pattern_info):
                // Pattern matching: case EnumType.Variant(binding)
                // Extract the variant name from the full "EnumType.Variant" string
                exh_variant_name := exh_pattern_info.variant_name
                mut exh_dot_pos := exh_variant_name.rfind(".")
                if exh_dot_pos.gt(sub(0, 1)) {
                    enum_part := exh_variant_name.get_substr(0, exh_dot_pos)?
                    variant_part := exh_variant_name.get_substr(exh_dot_pos.add(1), exh_variant_name.len())?
                    if not(enum_part.eq(enum_name)) {
                        errors.push(exh_case_expr.error(context.path, "type", format("Mismatched enum type '", enum_part, "', expected '", enum_name, "'.")))
                    }
                    matched_variants.push(variant_part)
                } else {
                    // Just the variant name without enum prefix
                    matched_variants.push(exh_variant_name)
                }

            case NodeType.Identifier(exh_name):
                if exh_case_expr.params.len().eq(0) {
                    // case A
                    matched_variants.push(exh_name)
                } else {
                    // case ExampleEnum.A
                    mut exh_variant_expr := Expr()
                    exh_case_expr.params.get(0, exh_variant_expr)?
                    switch exh_variant_expr.node_type {
                    case NodeType.Identifier(exh_variant):
                        if not(exh_name.eq(enum_name)) {
                            errors.push(exh_case_expr.error(context.path, "type", format("Mismatched enum type '", exh_name, "', expected '", enum_name, "'.")))
                        }
                        matched_variants.push(exh_variant)
                    case:
                        errors.push(exh_case_expr.error(context.path, "type", "Invalid enum case syntax"))
                    }
                }

            case NodeType.DefaultCase:
                default_found = true

            case:
            }
            j = j.add(2)
        }

        if not(default_found) {
            // Bug #38 fix: use variants Vec
            for vi in 0..exh_enum_def.variants.len() {
                mut ev := EnumVariant()
                exh_enum_def.variants.get(vi, ev)?
                if not(matched_variants.contains(ev.name)) {
                    errors.push(e.error(context.path, "type", format("Switch is missing case for variant '", ev.name, "'")))
                }
            }
        }
        catch (err: KeyNotFoundError) {
            // Not an enum, skip exhaustiveness check
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    return errors
}

check_struct_def := proc(mut context: Context, e: Expr, struct_def: SStructDef) returns Vec throws Str {
    mut errors := Vec.new(Str)

    if not(e.params.len().eq(0)) {
        errors.push(e.error(context.path, "type", "in check_struct_def(): struct declarations must take exactly 0 params."))
        return errors
    }

    // Iterate through struct members
    for member_decl: Declaration in struct_def.members {
        // Validate that the member's declared type exists (if it's a custom type)
        switch member_decl.value_type {
        case ValueType.TCustom(custom_type_name):
            // Skip built-in types and special types
            if not(custom_type_name.eq("Dynamic")) {
                if not(custom_type_name.eq("Type")) {
                    if not(custom_type_name.eq(INFER_TYPE)) {
                        // Check if the type exists
                        mut symbol_found := false
                        mut symbol_info := SymbolInfo()
                        symbol_info = context.scope_stack.lookup_symbol(custom_type_name)?
                        symbol_found = true
                        catch (err: KeyNotFoundError) {
                            symbol_found = false
                        }
                        if not(symbol_found) {
                            errors.push(e.error(context.path, "type", format(
                                "Struct member '", member_decl.name, "' uses undefined type '", custom_type_name, "'.\nHint: Make sure '", custom_type_name, "' is defined before this struct."
                            )))
                        } else {
                            // Validate it's actually a type (enum or struct), not a value
                            switch symbol_info.value_type {
                            case ValueType.TType(TTypeDef.TEnumDef):
                                // Valid type
                            case ValueType.TType(TTypeDef.TStructDef):
                                // Valid type
                            case ValueType.TCustom(inner_custom):
                                // Valid type (TCustom covers built-in types like I64, Str, etc.)
                            case:
                                errors.push(e.error(context.path, "type", format(
                                    "Struct member '", member_decl.name, "' type '", custom_type_name, "' is not a valid type (expected enum, struct, or primitive, found ", value_type_to_str(symbol_info.value_type), ")."
                                )))
                            }
                        }
                    }
                }
            }
        case:
            // Non-custom types (like functions) are handled elsewhere
        }

        // Check default value
        if struct_def.default_values.contains_key(member_decl.name) {
            mut inner_e := Expr()
            struct_def.default_values.get(member_decl.name, inner_e)?

            switch inner_e.node_type {
            case NodeType.FuncDef(func_def):
                // If the member's default value is a function (method), type check it
                context.scope_stack.push(ScopeType.Function)
                mut func_errors := check_func_proc_types(func_def, context, inner_e)?
                errors.extend(func_errors)
                func_errors.delete()
                _ := context.scope_stack.pop()?
            case:
                // For other types of members, check type and purity
                // Bug #148: Type-check the default value expression (catches ? on non-throwing calls)
                errors.extend(check_types_with_context(context, inner_e, ExprContext.ValueUsed)?)

                // Check if default value calls procs (violates purity of constructors)
                if is_expr_calling_procs(context, inner_e)? {
                    errors.push(inner_e.error(context.path, "type",
                        format("Struct field '", member_decl.name, "' has default value that calls proc. Default values must be pure (can only call funcs, not procs).")))
                }

                // Check if default value type matches declared member type
                mut expected_type := member_decl.value_type
                mut found_type := ValueType.TCustom("")
                mut found_type_valid := true

                found_type = get_value_type(context, inner_e)?
                catch (err: Str) {
                    errors.push(err)
                    found_type_valid = false
                }

                if found_type_valid {
                    // Check if the value is a numeric literal (for implicit conversion)
                    mut is_numeric_literal := false
                    switch inner_e.node_type {
                    case NodeType.LLiteral(literal):
                        switch literal {
                        case Literal.Number(num_val):
                            is_numeric_literal = true
                        case:
                            // Other literal types
                        }
                    case:
                        // Other node types
                    }

                    // Check type matching
                    mut type_mismatch := false
                    switch expected_type {
                    case ValueType.TCustom(tn):
                        if tn.eq("Dynamic") {
                            // Accept any type for Dynamic
                            type_mismatch = false
                        } else if tn.eq("Type") {
                            // Accept any type for Type
                            type_mismatch = false
                        } else if tn.eq(INFER_TYPE) {
                            // Type inference is OK
                            type_mismatch = false
                        } else if tn.eq("U8") {
                            // Allow implicit conversion from I64 literals to U8
                            switch found_type {
                            case ValueType.TCustom(found_tn):
                                if found_tn.eq("I64") {
                                    if is_numeric_literal {
                                        type_mismatch = false
                                    } else {
                                        type_mismatch = true
                                    }
                                } else if found_tn.eq("U8") {
                                    type_mismatch = false
                                } else {
                                    type_mismatch = true
                                }
                            case:
                                type_mismatch = true
                            }
                        } else {
                            // Check if types match
                            switch found_type {
                            case ValueType.TCustom(found_tn):
                                type_mismatch = not(tn.eq(found_tn))
                            case:
                                type_mismatch = true
                            }
                        }
                    case:
                        // For non-TCustom expected types, check equality
                        // This is a simplified check - may need refinement
                        mut expected_str := value_type_to_str(expected_type)
                        mut found_str := value_type_to_str(found_type)
                        type_mismatch = not(expected_str.eq(found_str))
                    }

                    if type_mismatch {
                        errors.push(inner_e.error(context.path, "type", format(
                            "Struct field '", member_decl.name, "' declared as '", value_type_to_str(expected_type), "' but default value has type '", value_type_to_str(found_type), "'."
                        )))
                    }
                }
            }
        } else {
            errors.push(e.todo_error(context.path, "type", format("Member '", member_decl.name, "' lacks a default value. Not allowed yet.")))
        }
    }

    // Check if collection-like structs have mandatory len() and size() methods
    // A struct is considered collection-like if it has push/get/set/insert methods
    // Note: delete() is excluded as it's a cleanup method, not a collection operation
    mut has_push := false
    _ := struct_def.get_member("push")?
    has_push = true
    catch (err: Str) {
        has_push = false
    }

    mut has_get := false
    _ := struct_def.get_member("get")?
    has_get = true
    catch (err: Str) {
        has_get = false
    }

    mut has_set := false
    _ := struct_def.get_member("set")?
    has_set = true
    catch (err: Str) {
        has_set = false
    }

    mut has_insert := false
    _ := struct_def.get_member("insert")?
    has_insert = true
    catch (err: Str) {
        has_insert = false
    }

    if has_push.or(has_get).or(has_set).or(has_insert) {
        // This looks like a collection type - check for len() method
        mut has_len := false
        mut len_decl := struct_def.get_member("len")?
        if not(len_decl.is_mut) {
            has_len = true
        }
        catch (err: Str) {
            has_len = false
        }

        if not(has_len) {
            mut struct_name := "unknown"
            if e.params.len().gt(0) {
                mut first_param := e.get(0)?
                switch first_param.node_type {
                case NodeType.Identifier(name):
                    struct_name = name
                case:
                    struct_name = "unknown"
                }
            }

            // Build methods string
            mut methods_str := ""
            if has_push {
                methods_str = format(methods_str, "push()")
            }
            if has_get {
                if methods_str.len().gt(0) {
                    methods_str = format(methods_str, "/")
                }
                methods_str = format(methods_str, "get()")
            }
            if has_set {
                if methods_str.len().gt(0) {
                    methods_str = format(methods_str, "/")
                }
                methods_str = format(methods_str, "set()")
            }
            if has_insert {
                if methods_str.len().gt(0) {
                    methods_str = format(methods_str, "/")
                }
                methods_str = format(methods_str, "insert()")
            }

            errors.push(e.error(context.path, "type", format(
                "Collection-like struct '", struct_name, "' has ", methods_str, " method(s) but no len() method.\n",
                "Reason: Collection types must provide a way to query their size.\n",
                "Suggestion: add 'len := func(self: ", struct_name, ") returns I64 { ... }' to struct '", struct_name, "'."
            )))
        }

        // Also check for size() method (returns size in bytes)
        mut has_size := false
        mut size_decl := struct_def.get_member("size")?
        if not(size_decl.is_mut) {
            has_size = true
        }
        catch (err: Str) {
            has_size = false
        }

        if not(has_size) {
            mut size_struct_name := "unknown"
            if e.params.len().gt(0) {
                mut size_first_param := e.get(0)?
                switch size_first_param.node_type {
                case NodeType.Identifier(name):
                    size_struct_name = name
                case:
                    size_struct_name = "unknown"
                }
            }

            // Build methods string
            mut size_methods_str := ""
            if has_push {
                size_methods_str = format(size_methods_str, "push()")
            }
            if has_get {
                if size_methods_str.len().gt(0) {
                    size_methods_str = format(size_methods_str, "/")
                }
                size_methods_str = format(size_methods_str, "get()")
            }
            if has_set {
                if size_methods_str.len().gt(0) {
                    size_methods_str = format(size_methods_str, "/")
                }
                size_methods_str = format(size_methods_str, "set()")
            }
            if has_insert {
                if size_methods_str.len().gt(0) {
                    size_methods_str = format(size_methods_str, "/")
                }
                size_methods_str = format(size_methods_str, "insert()")
            }

            errors.push(e.error(context.path, "type", format(
                "Collection-like struct '", size_struct_name, "' has ", size_methods_str, " method(s) but no size() method.\n",
                "Reason: Collection types must provide their size in bytes.\n",
                "Suggestion: add 'size := func(self: ", size_struct_name, ") returns I64 { ... }' to struct '", size_struct_name, "'.\n",
                "Note: size() should return the total size in bytes, not element count (use len() for that)."
            )))
        }
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: KeyNotFoundError) {
        throw err.msg
    }

    return errors
}

// Returns SFuncDef if function found
// Throws KeyNotFoundError for struct/enum instantiation (Ok(None) case)
// Throws Str for errors
get_func_def_for_fcall_with_expr := proc(context: Context, mut fcall_expr: Expr) returns SFuncDef throws Str, KeyNotFoundError {
    // Check if it's an FCall
    mut is_fcall := false
    switch fcall_expr.node_type {
    case NodeType.FCall(_):
        is_fcall = true
    case:
        is_fcall = false
    }
    if not(is_fcall) {
        throw fcall_expr.lang_error(context.path, "type", "Expected FCall node type")
    }

    // Get first param (function name expression)
    if fcall_expr.params.len().eq(0) {
        throw fcall_expr.lang_error(context.path, "type", "get_func_def_for_fcall_with_expr: Fcalls must have a name")
    }
    mut func_expr := fcall_expr.get(0)?

    switch func_expr.node_type {
    case NodeType.Identifier(id_str):
        // Regular functions and associated functions used directly
        combined_name := get_combined_name(context.path, func_expr)?

        // Regular function call - check if it exists
        mut func_found := false
        mut func_def := SFuncDef()
        func_def = context.scope_stack.lookup_func(combined_name)?
        func_found = true
        catch (err: KeyNotFoundError) {
            // Function not found, continue to struct check
        }
        if func_found {
            return func_def
        }

        // Check for struct instantiation
        mut struct_found := false
        mut struct_def := SStructDef()
        struct_def = context.scope_stack.lookup_struct(combined_name)?
        struct_found = true
        catch (err: KeyNotFoundError) {
            // Struct not found, continue to enum check
        }
        if struct_found {
            // This is to allow struct instantiation - throw KeyNotFoundError to signal Ok(None)
            throw KeyNotFoundError(msg=format("Struct instantiation: ", combined_name))
        }

        // Check for enum constructors (e.g., Color.Green(true))
        if context.scope_stack.is_enum_constructor(combined_name) {
            throw KeyNotFoundError(msg=format("Enum constructor: ", combined_name))
        }

        // UFCS for chained calls: func(result, args) -> Type.func(result, args)
        // e.g., add(1, 2).mul(3) becomes mul(add(1,2), 3) which transforms to I64.mul(add(1,2), 3)
        // This only applies when no standalone function with this name exists (checked above).
        if fcall_expr.params.len().gteq(2) {
            mut first_arg := fcall_expr.get(1)?
            mut target_type := ValueType.TCustom("")
            mut target_type_valid := true
            target_type = get_value_type(context, first_arg)?
            catch (err: Str) {
                target_type_valid = false
            }
            if target_type_valid {
                switch target_type {
                case ValueType.TCustom(custom_type_name):
                    method_name := format(custom_type_name, ".", combined_name)
                    mut method_found := false
                    mut method_func_def := SFuncDef()
                    method_func_def = context.scope_stack.lookup_func(method_name)?
                    method_found = true
                    catch (err: KeyNotFoundError) {
                        // Method not found, continue to other checks
                    }
                    if method_found {
                        // Transform: func(target, args...) -> Type.func(target, args...)
                        mut empty_params := Vec.new(Expr)
                        mut new_e := Expr.new_clone(NodeType.Identifier(method_name), fcall_expr.get(0)?, empty_params)
                        mut new_args := Vec.new(Expr)
                        new_args.push(new_e)
                        // Extend with params[1..]
                        mut k := 1
                        while k.lt(fcall_expr.params.len()) {
                            mut arg_e := fcall_expr.get(k)?
                            new_args.push(arg_e)
                            k.inc()
                        }
                        fcall_expr = Expr.new_clone(NodeType.FCall(get_fcall_does_throw(fcall_expr)), fcall_expr.get(0)?, new_args)
                        return method_func_def
                    }
                case:
                    // Non-TCustom type, skip
                }
            }
        }

        // UFCS with dot notation
        if func_expr.params.len().gt(0) {
            // Get last param (function name)
            mut last_idx := func_expr.params.len().sub(1)
            mut func_name_expr := Expr()
            func_expr.params.get(last_idx, func_name_expr)?

            switch func_name_expr.node_type {
            case NodeType.Identifier(ufcs_func_name):
                // Build new_combined_name by removing last part
                mut parts := combined_name.split(".")?
                mut new_combined_name := ""
                mut j := 0
                while j.lt(parts.len().sub(1)) {
                    mut part := ""
                    parts.get(j, part)?
                    if j.gt(0) {
                        new_combined_name = format(new_combined_name, ".")
                    }
                    new_combined_name = format(new_combined_name, part)
                    j.inc()
                }
                parts.delete()

                // Create identifier expression preserving nested structure
                // Copy func_expr but remove the last param (the method name)
                mut id_params := func_expr.params.clone()
                // Pop last element
                if id_params.len().gt(0) {
                    mut dummy := Expr()
                    id_params.pop(dummy)?
                }
                mut extra_arg_e := Expr.new_clone(func_expr.node_type, fcall_expr, id_params)

                // Regular functions used with UFCS
                mut ufcs_found := false
                mut ufcs_fn_def := SFuncDef()
                ufcs_fn_def = context.scope_stack.lookup_func(ufcs_func_name)?
                ufcs_found = true
                catch (err: KeyNotFoundError) {
                    // Regular function not found with UFCS, try associated function
                }
                if ufcs_found {
                    mut ufcs_empty_params := Vec.new(Expr)
                    mut ufcs_new_e := Expr.new_clone(NodeType.Identifier(ufcs_func_name), fcall_expr.get(0)?, ufcs_empty_params)
                    mut ufcs_new_args := Vec.new(Expr)
                    ufcs_new_args.push(ufcs_new_e)
                    ufcs_new_args.push(extra_arg_e)
                    // Extend with params[1..]
                    mut ufcs_k := 1
                    while ufcs_k.lt(fcall_expr.params.len()) {
                        mut ufcs_arg_e := fcall_expr.get(ufcs_k)?
                        ufcs_new_args.push(ufcs_arg_e)
                        ufcs_k.inc()
                    }
                    fcall_expr = Expr.new_clone(NodeType.FCall(get_fcall_does_throw(fcall_expr)), fcall_expr.get(0)?, ufcs_new_args)
                    return ufcs_fn_def
                }

                // Associated functions used with UFCS (aka methods)
                // Bug #28 fix: Use get_value_type() to dynamically resolve field access chains
                mut ufcs_value_type := ValueType.TCustom("")
                mut ufcs_value_type_valid := true
                ufcs_value_type = get_value_type(context, extra_arg_e)?
                catch (err: Str) {
                    ufcs_value_type_valid = false
                }
                if ufcs_value_type_valid {
                    switch ufcs_value_type {
                    case ValueType.TCustom(custom_type_name):
                        id_expr_name := format(custom_type_name, ".", ufcs_func_name)
                        mut assoc_found := false
                        mut assoc_func_def := SFuncDef()
                        assoc_func_def = context.scope_stack.lookup_func(id_expr_name)?
                        assoc_found = true
                        catch (err: KeyNotFoundError) {
                            // Associated function not found
                        }
                        if assoc_found {
                            mut assoc_empty_params := Vec.new(Expr)
                            mut assoc_new_e := Expr.new_clone(NodeType.Identifier(id_expr_name), fcall_expr.get(0)?, assoc_empty_params)
                            mut assoc_new_args := Vec.new(Expr)
                            assoc_new_args.push(assoc_new_e)
                            assoc_new_args.push(extra_arg_e)
                            // Extend with params[1..]
                            mut assoc_m := 1
                            while assoc_m.lt(fcall_expr.params.len()) {
                                mut assoc_arg_e := fcall_expr.get(assoc_m)?
                                assoc_new_args.push(assoc_arg_e)
                                assoc_m.inc()
                            }
                            fcall_expr = Expr.new_clone(NodeType.FCall(get_fcall_does_throw(fcall_expr)), fcall_expr.get(0)?, assoc_new_args)
                            return assoc_func_def
                        }
                    case:
                        found_value_type := ufcs_value_type
                        throw func_expr.error(context.path, "type", format(
                            "'", new_combined_name, "' is of type '", value_type_to_str(found_value_type), "' and thus can't have a '", ufcs_func_name, "' associated function"))
                    }
                }
            case:
                // Non-Identifier case, skip
            }
        }
        // Check if this is actually a field being called as a function
        mut is_field := true
        field_value_type := get_value_type(context, func_expr)?
        catch (err: Str) {
            is_field = false
        }
        if is_field {
            throw func_expr.error(context.path, "type", format(
                "Cannot call '", combined_name, "', it is not a function, it is '", value_type_to_str(field_value_type), "'"))
        }
        throw func_expr.lang_error(context.path, "type", format("Could not find function definition for '", combined_name, "'"))
    case:
        throw func_expr.lang_error(context.path, "type", "Expected Identifier node type")
    }

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    // Should not reach here
    throw "get_func_def_for_fcall_with_expr: unexpected code path"
}

get_func_def_for_fcall := proc(context: Context, fcall_expr_: Expr) returns SFuncDef throws Str, KeyNotFoundError {
    mut fcall_expr := fcall_expr_
    return get_func_def_for_fcall_with_expr(context, fcall_expr)?
}






// ---------- Type checking

is_expr_calling_procs := func(context: Context, e: Expr) returns Bool throws Str {
    switch e.node_type {
    case NodeType.Body:
        for se: Expr in e.params {
            if is_expr_calling_procs(context, se)? {
                return true
            }
        }
        return false

    case NodeType.StructDef(struct_def):
        // Check if any default values call procs
        for key: Str in struct_def.default_values.keys {
            mut default_expr := Expr()
            struct_def.default_values.get(key, default_expr)?
            if is_expr_calling_procs(context, default_expr)? {
                return true
            }
        }
        return false

    case NodeType.EnumDef(enum_def):
        return false

    case NodeType.LLiteral(lit):
        return false

    case NodeType.DefaultCase:
        return false

    case NodeType.Pattern(pattern_info):
        return false

    case NodeType.NamedArg(_):
        // Check the value expression
        for se: Expr in e.params {
            if is_expr_calling_procs(context, se)? {
                return true
            }
        }
        return false

    case NodeType.Identifier(id_str):
        return false

    case NodeType.Range:
        for se: Expr in e.params {
            if is_expr_calling_procs(context, se)? {
                return true
            }
        }
        return false

    case NodeType.FCall(_):
        // Check if the function being called is a proc
        f_name := get_func_name_in_call(e)?
        // Check if this proc is allowed to be called from funcs in this mode
        if context.mode_def.allowed_procs_in_funcs.contains(f_name) {
            return false
        }

        mut func_is_proc := false
        mut func_def := context.scope_stack.lookup_func(f_name)?
        func_is_proc = func_def.is_proc()
        catch (err: KeyNotFoundError) {
            func_is_proc = false
        }

        // Also check if any of the arguments call procs
        // Skip the first param which is the function name itself
        for i in 1..e.params.len() {
            mut arg_e := e.get(i)?
            if is_expr_calling_procs(context, arg_e)? {
                return true
            }
        }

        return func_is_proc

    case NodeType.Declaration(decl):
        if e.params.len().gt(0) {
            mut inner_e := e.get(0)?
            return is_expr_calling_procs(context, inner_e)?
        } else {
            e.exit_error("type", format("while declaring '", decl.name, "', parameter is unexpectedly missing."))
            return true
        }

    case NodeType.Assignment(var_name):
        if e.params.len().gt(0) {
            mut assign_inner_e := e.get(0)?
            return is_expr_calling_procs(context, assign_inner_e)?
        } else {
            e.exit_error("type", format("while assigning ", var_name, ", parameter is unexpectedly missing."))
            return true
        }

    case NodeType.FuncDef(func_def):
        for it_e: Expr in func_def.body {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.If:
        for it_e: Expr in e.params {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.While:
        for it_e: Expr in e.params {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.Switch:
        for it_e: Expr in e.params {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.Return:
        for it_e: Expr in e.params {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.Throw:
        for it_e: Expr in e.params {
            if is_expr_calling_procs(context, it_e)? {
                return true
            }
        }
        return false

    case NodeType.Catch:
        // The catch body is always the third parameter
        if e.params.len().gt(2) {
            mut body_expr := e.get(2)?
            return is_expr_calling_procs(context, body_expr)?
        } else {
            // TODO Err(lang_error) here instead
            return true
        }

    case NodeType.Break:
        // Break and Continue have no params, so they don't call procs
        return false
    case NodeType.Continue:
        // Break and Continue have no params, so they don't call procs
        return false

    case:
        // Unknown node type - assume it might call procs to be safe
        return false
    }

    return false
}

func_proc_has_multi_arg := func(func_def: SFuncDef) returns Bool {
    for a: Declaration in func_def.args {
        switch a.value_type {
        case ValueType.TMulti(multi_type):
            return true
        case:
            // Not multi-arg, continue
        }
    }
    return false
}

basic_mode_checks := proc(context: Context, e: Expr) returns Vec throws Str {
    mut errors := Vec.new(Str)

    switch e.node_type {
    case NodeType.Body:
        for p: Expr in e.params {
            switch p.node_type {
            case NodeType.Declaration(decl):
                if not(context.mode_def.allows_base_mut) {
                    if decl.is_mut {
                        errors.push(e.error(context.path, "mode", format("mode ", context.mode_def.name, " doesn't allow mut declarations of 'mut ", decl.name, "'.\nSuggestion: remove 'mut' or change to mode script or cli")))
                    }
                }
            case NodeType.FCall(_):
                if not(context.mode_def.allows_base_calls) {
                    f_name := get_func_name_in_call(p)?
                    if not(f_name.eq("import")) {
                        errors.push(e.error(context.path, "mode", format("mode ", context.mode_def.name, " doesn't allow calls in the root context of the file'.\nSuggestion: remove the call to '", f_name, "' or change mode 'test' or 'script'")))
                    }
                }
            case:
                // Other node types in body, skip
            }
        }
    case:
        errors.push(e.lang_error(context.path, "mode", "basic_mode_checks() expects a body expression, this should never happen."))
    }

    if context.mode_def.needs_main_proc {
        mut symbol_found := false
        mut symbol_info := SymbolInfo()
        symbol_info = context.scope_stack.lookup_symbol("main")?
        symbol_found = true
        catch (err: KeyNotFoundError) {
            symbol_found = false
        }
        if symbol_found {
            // Check if it's a proc
            mut is_proc := false
            switch symbol_info.value_type {
            case ValueType.TFunction(FunctionType.FTProc):
                is_proc = true
            case:
                is_proc = false
            }
            if not(is_proc) {
                errors.push(e.error(context.path, "mode", format("mode ", context.mode_def.name, " requires 'main' to be defined as a proc. It was defined as a ", value_type_to_str(symbol_info.value_type), " instead")))
            }
        } else {
            errors.push(e.error(context.path, "mode", format("mode ", context.mode_def.name, " requires 'main' to be defined as a proc.")))
        }
    }

    return errors
}

// ---------- Bug #128: Resolve INFER_TYPE in AST after type checking ----------

// Result struct for type_check - contains resolved AST and any errors
TypeCheckResult := struct {
    mut resolved_ast: Expr = Expr()
    mut errors: Vec = Vec.new(Str)
}

// Bug #128: Unified type checking entry point.
// Runs type checking and resolves all INFER_TYPE references in the AST.
// Returns the resolved AST and any type errors found.
// After this function, no INFER_TYPE should remain in the returned AST.
type_check := proc(mut context: Context, e: Expr) returns TypeCheckResult throws Str {
    mut result := TypeCheckResult()
    result.errors = check_types(context, e)?
    // If check_types found errors, don't try to resolve types - just return the errors.
    // This avoids duplicate errors from resolve_inferred_types trying the same things.
    if result.errors.len().gt(0) {
        result.resolved_ast = e.clone()
        return result
    }
    result.resolved_ast = resolve_inferred_types(context, e)?
    return result
}

// Helper: recurse into params and return new params vec
resolve_params := proc(mut context: Context, e: Expr) returns Vec throws Str {
    mut result := Vec.new(Expr)
    for idx in 0..e.params.len() {
        mut param := Expr()
        e.params.get(idx, param)?
        result.push(resolve_inferred_types(context, param)?)
    }
    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "resolve_types", format("IndexOutOfBoundsError: ", err.msg))
    }
    return result
}

// Resolve all INFER_TYPE references in the AST after type checking.
// This replaces Declaration.value_type = INFER_TYPE with the resolved type
// from the scope stack (which typer populated during check_types).
//
// After this pass, no INFER_TYPE should remain in the AST, allowing
// post-typer phases (sugar, precomp, ccodegen) to read types directly
// without needing type inference.
resolve_inferred_types := proc(mut context: Context, e: Expr) returns Expr throws Str {
    switch e.node_type {
    case NodeType.Declaration(decl):
        return resolve_declaration(context, e, decl)?

    case NodeType.FuncDef(func_def):
        return resolve_funcdef(context, e, func_def)?

    case NodeType.Body:
        // Body - push block scope
        context.scope_stack.push(ScopeType.Block)
        resolved_params := resolve_params(context, e)?
        _ := context.scope_stack.pop()?
        return Expr.new_clone(e.node_type, e, resolved_params)

    case NodeType.If:
        // If - push block scope
        context.scope_stack.push(ScopeType.Block)
        if_params := resolve_params(context, e)?
        _ := context.scope_stack.pop()?
        return Expr.new_clone(e.node_type, e, if_params)

    case NodeType.While:
        // While - push block scope
        context.scope_stack.push(ScopeType.Block)
        while_params := resolve_params(context, e)?
        _ := context.scope_stack.pop()?
        return Expr.new_clone(e.node_type, e, while_params)

    case NodeType.ForIn(var_type_name):
        // ForIn - declare loop variable in scope before processing body
        context.scope_stack.push(ScopeType.Block)

        // Declare loop variable - get name from params[0], type from node_type
        if e.params.len().gt(0) {
            mut var_expr := Expr()
            e.params.get(0, var_expr)?
            switch var_expr.node_type {
            case NodeType.Identifier(var_name):
                var_type := str_to_value_type(var_type_name)
                context.scope_stack.declare_symbol(var_name, SymbolInfo(
                    value_type=var_type,
                    is_mut=false,
                    is_copy=false,
                    is_own=false,
                    is_comptime_const=false
                ))?
            case:
            }
        }

        forin_params := resolve_params(context, e)?

        _ := context.scope_stack.pop()?

        return Expr.new_clone(e.node_type, e, forin_params)

    case NodeType.Switch:
        // Switch - declare pattern binding variables in scope before processing case bodies
        mut new_params := Vec.new(Expr)

        // Get switch expression type for pattern binding
        mut switch_expr_type := ValueType.TCustom("")
        mut has_switch_type := false
        if e.params.len().gt(0) {
            mut switch_expr := Expr()
            e.params.get(0, switch_expr)?
            new_params.push(resolve_inferred_types(context, switch_expr)?)
            switch_expr_type = get_value_type(context, switch_expr)?
            has_switch_type = true
            catch (err: Str) {
                // REM: Error getting type, continue without switch type
                has_switch_type = false
            }
        }

        // Process case/body pairs (params[1..] are case, body, case, body, ...)
        mut i := 1
        while i.lt(e.params.len()) {
            mut case_expr := Expr()
            e.params.get(i, case_expr)?
            new_params.push(resolve_inferred_types(context, case_expr)?)
            i = i.add(1)

            if i.gteq(e.params.len()) {
                break
            }

            mut body_expr := Expr()
            e.params.get(i, body_expr)?

            // For pattern matching, add binding variable to scope
            switch case_expr.node_type {
            case NodeType.Pattern(pattern_info):
                switch switch_expr_type {
                case ValueType.TCustom(enum_name):
                    // Extract just the variant name (remove enum prefix if present)
                    mut variant := pattern_info.variant_name
                    mut dot_pos := variant.rfind(".")
                    if dot_pos.gt(sub(0, 1)) {
                        variant = variant.get_substr(dot_pos.add(1), variant.len())?
                    }

                    // Look up enum def - if not found, just process body normally
                    mut enum_def := SEnumDef()
                    mut enum_found := true
                    enum_def = context.scope_stack.lookup_enum(enum_name)?
                    catch (err: KeyNotFoundError) {
                        enum_found = false
                    }

                    if enum_found {
                        // Look up payload type (Ptr to ValueType, NULL = None)
                        mut payload_ptr := Ptr()
                        mut variant_found := true
                        payload_ptr = enum_def.get(variant)?
                        catch (err: KeyNotFoundError) {
                            variant_found = false
                        }

                        if variant_found.and(not(NULL.eq(payload_ptr.data))) {
                            // Variant has a payload - create scoped context with binding variable
                            mut payload_type := ValueType.TCustom("")
                            memcpy(to_ptr(payload_type), payload_ptr.data, size_of(ValueType))
                            context.scope_stack.push(ScopeType.Block)
                            context.scope_stack.declare_symbol(pattern_info.binding_var, SymbolInfo(value_type=payload_type))?
                            new_params.push(resolve_inferred_types(context, body_expr)?)
                            _ := context.scope_stack.pop()?
                        } else {
                            // No payload or variant not found, just process body normally
                            new_params.push(resolve_inferred_types(context, body_expr)?)
                        }
                    } else {
                        // Enum not found, just process body normally
                        new_params.push(resolve_inferred_types(context, body_expr)?)
                    }
                case:
                    new_params.push(resolve_inferred_types(context, body_expr)?)
                }
            case:
                new_params.push(resolve_inferred_types(context, body_expr)?)
            }

            i = i.add(1)
        }

        return Expr.new_clone(e.node_type, e, new_params)

    case NodeType.StructDef(struct_def):
        // StructDef - resolve member types and recurse into default_values
        // First, resolve types and recurse into default_values
        mut new_default_values := Map.new(Str, Expr)
        for name: Str in struct_def.default_values.keys {
            mut value_expr := Expr()
            struct_def.default_values.get(name, value_expr)?
            catch (err: KeyNotFoundError) {
                throw e.lang_error(context.path, "resolve_types", format("KeyNotFoundError: ", err.msg))
            }
            new_default_values.set(name, resolve_inferred_types(context, value_expr)?)
        }

        // Then, resolve INFER_TYPE in member declarations
        mut new_members := Vec.new(Declaration)
        for member_idx in 0..struct_def.members.len() {
            mut member := Declaration()
            struct_def.members.get(member_idx, member)?

            mut member_type_name := ""
            switch member.value_type {
            case ValueType.TCustom(name):
                member_type_name = name
            case:
                member_type_name = ""
            }

            mut resolved_type := member.value_type
            if member_type_name.eq(INFER_TYPE) {
                // Get resolved default_value for this member
                mut default_value := Expr()
                mut has_default := true
                new_default_values.get(member.name, default_value)?
                catch (err: KeyNotFoundError) {
                    has_default = false
                }
                if has_default {
                    resolved_type = get_value_type(context, default_value)?
                } else {
                    throw e.lang_error(context.path, "resolve_types", format("Cannot infer type for struct member '", member.name, "': no default value"))
                }
            }

            new_members.push(Declaration(
                name=member.name,
                value_type=resolved_type,
                is_mut=member.is_mut,
                is_copy=member.is_copy,
                is_own=member.is_own,
                default_value=member.default_value
            ))
        }

        new_struct_def := SStructDef(members=new_members, default_values=new_default_values)
        return Expr.new_explicit(NodeType.StructDef(new_struct_def), e.params, e.line, e.col)

    case NodeType.Catch:
        // Catch - declare catch variable in scope before processing body
        if not(e.params.len().eq(3)) {
            throw e.lang_error(context.path, "resolve_types", "Catch node must have three parameters: variable, type, and body.")
        }

        mut catch_var_expr := e.get(0)?
        mut catch_type_expr := e.get(1)?
        mut catch_body_expr := e.get(2)?

        mut catch_var_name := ""
        switch catch_var_expr.node_type {
        case NodeType.Identifier(name):
            catch_var_name = name
        case:
            throw e.lang_error(context.path, "resolve_types", "Catch variable must be an identifier")
        }

        mut catch_type_name := ""
        switch catch_type_expr.node_type {
        case NodeType.Identifier(name):
            catch_type_name = name
        case:
            throw e.lang_error(context.path, "resolve_types", "Catch type must be an identifier")
        }

        // Create scoped context for catch body
        context.scope_stack.push(ScopeType.Block)
        context.scope_stack.declare_symbol(catch_var_name, SymbolInfo(
            value_type=ValueType.TCustom(catch_type_name),
            is_mut=false,
            is_copy=false,
            is_own=false,
            is_comptime_const=false
        ))?

        // Map struct fields so err.msg etc. can be accessed
        mut catch_struct_def := context.scope_stack.lookup_struct(catch_type_name)?
        for field_decl: Declaration in catch_struct_def.members {
            combined_name := format(catch_var_name, ".", field_decl.name)
            context.scope_stack.declare_symbol(combined_name, SymbolInfo(value_type=field_decl.value_type))?
        }
        catch (err: KeyNotFoundError) {
            // Not a struct, skip field registration
        }

        // Process body only
        resolved_catch_body := resolve_inferred_types(context, catch_body_expr)?
        _ := context.scope_stack.pop()?
        catch (err: Str) {
            // Ignore pop error
        }

        mut catch_params := Vec.new(Expr)
        catch_params.push(catch_var_expr)
        catch_params.push(catch_type_expr)
        catch_params.push(resolved_catch_body)
        return Expr.new_explicit(e.node_type, catch_params, e.line, e.col)

    case:
        // Default: recurse into all params
        if e.params.is_empty() {
            return e
        }
        default_params := resolve_params(context, e)?
        return Expr.new_clone(e.node_type, e, default_params)
    }

    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "resolve_types", format("IndexOutOfBoundsError: ", err.msg))
    }
}

// Helper: resolve Declaration node
resolve_declaration := proc(mut context: Context, e: Expr, decl: Declaration) returns Expr throws Str {
    // Check if this declaration has INFER_TYPE
    mut resolved_type := decl.value_type
    mut decl_type_name := ""
    switch decl.value_type {
    case ValueType.TCustom(name):
        decl_type_name = name
    case:
        decl_type_name = ""
    }

    if decl_type_name.eq(INFER_TYPE) {
        // Infer type from the value expression
        if e.params.len().gt(0) {
            mut inner_e := Expr()
            e.params.get(0, inner_e)?
            resolved_type = get_value_type(context, inner_e)?
        } else {
            throw e.lang_error(context.path, "resolve_types", format("Cannot resolve type for '", decl.name, "': no value expression"))
        }
    }

    // Create new Declaration with resolved type
    mut new_decl := Declaration(
        name=decl.name,
        value_type=resolved_type,
        is_mut=decl.is_mut,
        is_copy=decl.is_copy,
        is_own=decl.is_own,
        default_value=decl.default_value
    )

    // Recurse into params
    decl_params := resolve_params(context, e)?

    // Register the symbol with resolved type (in case it wasn't already)
    mut already_registered := false
    mut existing := SymbolInfo()
    existing = context.scope_stack.lookup_symbol(new_decl.name)?
    already_registered = true
    catch (err: KeyNotFoundError) {
        already_registered = false
    }

    if not(already_registered) {
        context.scope_stack.declare_symbol(new_decl.name, SymbolInfo(
            value_type=new_decl.value_type,
            is_mut=new_decl.is_mut,
            is_copy=new_decl.is_copy,
            is_own=new_decl.is_own,
            is_comptime_const=false
        ))?
    }

    // For function declarations, also register the function definition (like type checker does)
    switch new_decl.value_type {
    case ValueType.TFunction(_):
        if decl_params.len().gt(0) {
            mut decl_inner_e := Expr()
            decl_params.get(0, decl_inner_e)?
            switch decl_inner_e.node_type {
            case NodeType.FuncDef(func_def):
                context.scope_stack.declare_func(new_decl.name, func_def)?
            case:
            }
        }
    case:
    }

    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "resolve_types", format("IndexOutOfBoundsError: ", err.msg))
    }

    return Expr.new_explicit(NodeType.Declaration(new_decl), decl_params, e.line, e.col)
}

// Helper: resolve FuncDef node
resolve_funcdef := proc(mut context: Context, e: Expr, func_def: SFuncDef) returns Expr throws Str {
    // FuncDef - push function scope and recurse into body
    context.scope_stack.push(ScopeType.Function)

    // Register function parameters in scope
    for arg_idx in 0..func_def.args.len() {
        mut arg := Declaration()
        func_def.args.get(arg_idx, arg)?
        context.scope_stack.declare_symbol(arg.name, SymbolInfo(
            value_type=arg.value_type,
            is_mut=arg.is_mut,
            is_copy=arg.is_copy,
            is_own=arg.is_own,
            is_comptime_const=false
        ))?
    }

    // Recurse into body statements
    mut new_body := Vec.new(Expr)
    for stmt_idx in 0..func_def.body.len() {
        mut stmt := Expr()
        func_def.body.get(stmt_idx, stmt)?
        new_body.push(resolve_inferred_types(context, stmt)?)
    }

    _ := context.scope_stack.pop()?

    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "resolve_types", format("IndexOutOfBoundsError in FuncDef: ", err.msg))
    }

    new_func_def := SFuncDef(
        function_type=func_def.function_type,
        args=func_def.args,
        return_types=func_def.return_types,
        throw_types=func_def.throw_types,
        body=new_body,
        source_path=func_def.source_path
    )
    return Expr.new_explicit(NodeType.FuncDef(new_func_def), e.params, e.line, e.col)
}
