mode liba

import("core.vec")
import("self.lexer")

DEFAULT_MODE := "lib"

ModeDef := struct {
    mut name: Str = ""
    mut allows_procs: Bool = false
    mut allows_base_mut: Bool = false
    mut allows_base_calls: Bool = false
    mut allows_base_anything: Bool = false
    mut needs_main_proc: Bool = false
    mut imports: Vec = Vec.new(Str)
    mut allowed_procs_in_funcs: Vec = Vec.new(Str)
}

can_be_imported := func(mode_def: ModeDef) returns Bool {
    if mode_def.needs_main_proc { return false }  // TODO think harder, why not?
    if mode_def.allows_base_calls { return false }
    if mode_def.allows_base_anything { return false }
    return true
}

// TODO: Add Vec literals so we can use vec!["panic"] instead of creating a Vec and pushing
mode_from_name := func(mode_name: Str, path: Str, t: Token) returns ModeDef throws Str, AllocError {
    if mode_name.eq("lib") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("liba") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        allowed_procs_in_funcs.push("print")
        allowed_procs_in_funcs.push("println")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("pure") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = false,
            allows_base_calls      = false,
            allows_base_mut        = false,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("pura") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        allowed_procs_in_funcs.push("print")
        allowed_procs_in_funcs.push("println")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = false,
            allows_base_calls      = false,
            allows_base_mut        = false,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("script") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = true,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("safe_script") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = true,
            needs_main_proc        = false,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("cli") {
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = true,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }
    if mode_name.eq("test") {
        mut test_imports := Vec.new(Str)
        test_imports.push("src/modes/test")
        mut allowed_procs_in_funcs := Vec.new(Str)
        allowed_procs_in_funcs.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            imports                = test_imports,
            allowed_procs_in_funcs = allowed_procs_in_funcs)
    }

    throw t.error(path, format(LANG_NAME, " interpreter implementation doesn't support mode '", mode_name, "'"))
}

parse_mode := func(path: Str, mut lexer: Lexer) returns ModeDef throws Str {
    _ := lexer.expect(TokenType.Mode)  // Add one for mode

    t := lexer.peek()
    tt := t.token_type
    switch tt {
    case TokenType.Identifier:
        // continue
    case:
        throw t.error(path, "Expected identifier after 'mode'")
    }
    mode_name := t.token_str
    m := mode_from_name(mode_name, path, t)

    m_name := m.name
    if m_name.eq("safe_script") {
        throw t.error(path, format("mode '", m.name, "' is not properly supported in '", LANG_NAME, "' yet. Try mode 'script' instead"))
    }

    _ := lexer.expect(TokenType.Identifier)  // Add one for the identifier of the mode

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }
    catch (err: AllocError) {
        throw err.msg
    }

    return m
}
