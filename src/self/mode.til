mode liba

import("core.vec")
import("self.lexer")

DEFAULT_MODE := "lib"

ModeDef := struct {
    mut name: Str = ""
    mut allows_procs: Bool = false
    mut allows_base_mut: Bool = false
    mut allows_base_calls: Bool = false
    mut allows_base_anything: Bool = false
    mut needs_main_proc: Bool = false
    mut imports: Vec = Vec.new(Str)
    mut allowed_procs_in_funcs: Vec = Vec.new(Str)

}

can_be_imported : func(mode_def: ModeDef) returns Bool = {
    if mode_def.needs_main_proc { return false }  // TODO think harder, why not?
    if mode_def.allows_base_calls { return false }
    if mode_def.allows_base_anything { return false }
    return true
}

// TODO: Add Vec literals so we can use vec!["panic"] instead of creating a Vec and pushing
mode_from_name : func(mode_name: Str, path: Str, t: Token) returns ModeDef throws Str = {
    switch mode_name {
    case "lib":
        mut lib_allowed := Vec.new(Str)
        lib_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = lib_allowed)
    case "liba":
        mut liba_allowed := Vec.new(Str)
        liba_allowed.push("panic")
        liba_allowed.push("print")
        liba_allowed.push("println")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = liba_allowed)
    case "pure":
        mut pure_allowed := Vec.new(Str)
        pure_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = false,
            allows_base_calls      = false,
            allows_base_mut        = false,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = pure_allowed)
    case "pura":
        mut pura_allowed := Vec.new(Str)
        pura_allowed.push("panic")
        pura_allowed.push("print")
        pura_allowed.push("println")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = false,
            allows_base_calls      = false,
            allows_base_mut        = false,
            allows_base_anything   = false,
            needs_main_proc        = false,
            allowed_procs_in_funcs = pura_allowed)
    case "script":
        mut script_allowed := Vec.new(Str)
        script_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = true,
            needs_main_proc        = false,
            allowed_procs_in_funcs = script_allowed)
    case "safe_script":
        mut safe_script_imports := Vec.new(Str)
        safe_script_imports.push("modes.safe_script")
        mut safe_script_allowed := Vec.new(Str)
        safe_script_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = true,
            needs_main_proc        = false,
            imports                = safe_script_imports,
            allowed_procs_in_funcs = safe_script_allowed)
    case "cli":
        mut cli_allowed := Vec.new(Str)
        cli_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = false,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = true,
            allowed_procs_in_funcs = cli_allowed)
    case "test":
        mut test_imports := Vec.new(Str)
        test_imports.push("modes.test")
        mut test_allowed := Vec.new(Str)
        test_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = false,
            imports                = test_imports,
            allowed_procs_in_funcs = test_allowed)
    case "make":
        mut make_allowed := Vec.new(Str)
        make_allowed.push("panic")
        return ModeDef(
            name                   = mode_name,
            allows_procs           = true,
            allows_base_calls      = true,
            allows_base_mut        = true,
            allows_base_anything   = false,
            needs_main_proc        = true,
            allowed_procs_in_funcs = make_allowed)
    case:
        throw t.error(path, format("interpreter implementation doesn't support mode '", mode_name, "'"))
    }
}

parse_mode : func(path: Str, mut lexer: Lexer) returns ModeDef throws Str = {
    _ := lexer.expect(TokenType.Mode)?  // Add one for mode

    t := lexer.peek()?
    tt := t.token_type
    switch tt {
    case TokenType.Identifier:
        // continue
    case:
        throw t.error(path, "Expected identifier after 'mode'")
    }
    mode_name := t.token_str
    m := mode_from_name(mode_name, path, t)?

    m_name := m.name
    if m_name.eq("safe_script") {
        throw t.error(path, format("mode '", m.name, "' is not properly supported yet. Try mode 'script' instead"))
    }

    _ := lexer.expect(TokenType.Identifier)?  // Add one for the identifier of the mode

    catch (err: IndexOutOfBoundsError) {
        throw err.msg
    }

    return m
}
