mode test

import("src.std.vec")

ExampleEnum := enum {
    A,
    B,
    C,
    D,
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum: ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    mut to_switch2 := to_switch
    to_switch2 = ExampleEnum.B
    to_switch2 = to_switch
    mut to_return := ""
    switch to_switch2 {
    case ExampleEnum.A: to_return = "enum switch aaaaaa"
    case ExampleEnum.B: to_return = "enum switch bbbbbb"
    case: to_return = "enum cccccc by default"
    }
    return to_return
}

assert_eq_str(loc(), "enum switch aaaaaa",     test_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",     test_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.D))

// Test enum_to_str core function
assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(ExampleEnum.A))
assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(ExampleEnum.B))
assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(ExampleEnum.C))
assert_eq_str(loc(), "ExampleEnum.D", enum_to_str(ExampleEnum.D))

no_return_switch_str := "xxxxxx because return inside switch doesn't work even for enum"
test_return_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    // println("in test_return_switch_enum: to_switch: ", enum_to_str(to_switch))
    switch to_switch {
    case ExampleEnum.A:
        return "enum switch aaaaaa"
    case ExampleEnum.B:
        return "enum switch bbbbbb"
    case:
        return "enum cccccc by default"
    }
    return no_return_switch_str
}
assert_eq_str(loc(), "enum switch aaaaaa",       test_return_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",       test_return_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.D))

// Test that enum variants are valid symbols and type-check
test_enum_variant_resolution := proc() {
    mut my_enum_val: ExampleEnum = ExampleEnum.A
    my_enum_val2 := ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.C
    assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(my_enum_val))

    // my_enum_val = ExampleEnum.D // TODO make sure this fails at check type
}
test_enum_variant_resolution()

// Test tagged unions
Color := enum {
    Unknown,
    Green: Bool,
    Number: I64,
    Name: Str,
}

aaa := Color.Unknown
bbb := Color.Green(true)
ccc := Color.Number(42)

// Test payload extraction using switch pattern matching
test_simple_payload_extraction := proc() {
    mut bool_payload := false
    switch bbb {
    case Color.Green(is_olive):
        bool_payload = is_olive
    case:
        // Other variants
    }
    assert(loc(), bool_payload)

    mut i64_payload := 0
    switch ccc {
    case Color.Number(code):
        i64_payload = code
    case:
        // Other variants
    }
    assert_eq(loc(), 42, i64_payload)

    // Test with different values
    green_false := Color.Green(false)
    mut bool_payload2 := false
    switch green_false {
    case Color.Green(is_olive):
        bool_payload2 = is_olive
    case:
        // Other variants
    }
    assert(loc(), not(bool_payload2))

    number_99 := Color.Number(99)
    mut i64_payload2 := 0
    switch number_99 {
    case Color.Number(code):
        i64_payload2 = code
    case:
        // Other variants
    }
    assert_eq(loc(), 99, i64_payload2)
}
test_simple_payload_extraction()

green_false := Color.Green(false)

// Test type checking: these should fail at compile time
// Color.Green(42)  // ERROR: expects Bool, got I64
// Color.Number(true)  // ERROR: expects I64, got Bool

// Test matching enum variants with payload extraction using switch pattern matching
test_color_match := proc(to_switch: Color) returns Str {
    switch to_switch {
    case Color.Unknown: return "unknown color"
    case Color.Green(is_olive):
        if is_olive {
            return "olive green"
        }
        return "dark green"
    case Color.Number(code):
        if gt(code, 0) {
            return "positive color code"
        }
        return "negative color code"
    case Color.Name:
        return "color with name"
    case:
        return "should not reach here"
    }
}

assert_eq_str(loc(), test_color_match(Color.Unknown), "unknown color")
assert_eq_str(loc(), test_color_match(bbb), "olive green")
assert_eq_str(loc(), test_color_match(green_false), "dark green")
assert_eq_str(loc(), test_color_match(ccc), "positive color code")

// Test Str payloads
test_str_payloads := proc() {
    // Test creating enum with Str payload
    my_name := "crimson"
    color_name := Color.Name(my_name)

    // Test extraction with switch pattern matching
    mut extracted_name := ""
    switch color_name {
    case Color.Name(name):
        extracted_name = name
    case:
        // Other variants
    }
    assert(loc(), extracted_name.eq("crimson"))

    // Test with different string values
    blue_color := Color.Name("blue")
    mut extracted_blue := ""
    switch blue_color {
    case Color.Name(name):
        extracted_blue = name
    case:
        // Other variants
    }
    assert(loc(), extracted_blue.eq("blue"))

    // Test with longer string
    long_name := "bright-yellow-green"
    long_color := Color.Name(long_name)
    mut extracted_long := ""
    switch long_color {
    case Color.Name(name):
        extracted_long = name
    case:
        // Other variants
    }
    assert(loc(), extracted_long.eq("bright-yellow-green"))

    // Test in switch statement
    test_color_name_match := proc(col: Color) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        switch col {
        case Color.Name(name):
            return format("color name: ", name)
        case Color.Number(code):
            code_str := I64.to_str(code)
            return format("color code: ", code_str)
        case:
            return "other color"
        }
    }

    assert(loc(), test_color_name_match(color_name).eq("color name: crimson"))
    assert(loc(), test_color_name_match(blue_color).eq("color name: blue"))

    number_color := Color.Number(255)
    assert(loc(), test_color_name_match(number_color).eq("color code: 255"))

    // Catch unexpected errors at end
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }
}
test_str_payloads()

// Test struct payloads
Vec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Vec3 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
    mut z: I64 = 0
}

ContainerStruct := struct {
    mut vec: Vec2 = Vec2()
    mut value: I64 = 0
}

Shape := enum {
    Point: Vec2,
    Point3D: Vec3,
    Container: ContainerStruct,
}

test_struct_payloads := proc() {
    // Test basic struct payload
    mut my_vec := Vec2()
    my_vec.x = 10
    my_vec.y = 20
    point := Shape.Point(my_vec)

    mut extracted_vec := Vec2()
    switch point {
    case Shape.Point(vec):
        extracted_vec = vec
    case:
        // Other variants
    }
    assert_eq(loc(), 10, extracted_vec.x)
    assert_eq(loc(), 20, extracted_vec.y)

    // Test 3D point
    mut my_vec3 := Vec3()
    my_vec3.x = 1
    my_vec3.y = 2
    my_vec3.z = 3
    point3d := Shape.Point3D(my_vec3)

    mut extracted_vec3 := Vec3()
    switch point3d {
    case Shape.Point3D(vec3):
        extracted_vec3 = vec3
    case:
        // Other variants
    }
    assert_eq(loc(), 1, extracted_vec3.x)
    assert_eq(loc(), 2, extracted_vec3.y)
    assert_eq(loc(), 3, extracted_vec3.z)

    // TODO: Test nested struct payload - requires fixing nested struct allocation in insert_struct
    // mut container := ContainerStruct()
    // container.vec.x = 100
    // container.vec.y = 200
    // container.value = 42
    // container_shape := Shape.Container(container)
    //
    // mut extracted_container := ContainerStruct()
    // rsonly_enum_extract_payload(container_shape, extracted_container)
    // assert_eq(loc(), 100, extracted_container.vec.x)
    // assert_eq(loc(), 200, extracted_container.vec.y)
    // assert_eq(loc(), 42, extracted_container.value)

    // Test with switch pattern matching
    test_shape_match := proc(s: Shape) returns I64 {
        switch s {
        case Shape.Point(v):
            return add(v.x, v.y)
        case Shape.Point3D(v3):
            return add(add(v3.x, v3.y), v3.z)
        case Shape.Container:
            // TODO: Container with nested struct not yet supported
            return 0
        case:
            return 0
        }
    }

    assert_eq(loc(), 30, test_shape_match(point))  // 10 + 20
    assert_eq(loc(), 6, test_shape_match(point3d))  // 1 + 2 + 3
    // assert_eq(loc(), 42, test_shape_match(container_shape))  // TODO: nested struct
}
test_struct_payloads()

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD,
    LBool : Bool,
    LNumber : I64,
    LString : Str,
}

// Test enum payloads - Option<Color> pattern
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

Option := enum {
    None,
    Some: SimpleColor,
}

test_enum_payloads := proc() {
    // Test None variant (no payload)
    opt_none := Option.None
    assert(loc(), enum_to_str(opt_none).eq("Option.None"))

    // Test Some variant with Color payload
    my_color := SimpleColor.Red
    opt_some := Option.Some(my_color)

    mut extracted_color := SimpleColor.Blue
    switch opt_some {
    case Option.Some(color):
        extracted_color = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test with Green
    green := SimpleColor.Green
    opt_green := Option.Some(green)
    mut extracted2 := SimpleColor.Red
    switch opt_green {
    case Option.Some(color):
        extracted2 = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted2).eq("SimpleColor.Green"))

    // Test with Blue
    blue := SimpleColor.Blue
    opt_blue := Option.Some(blue)
    mut extracted3 := SimpleColor.Red
    switch opt_blue {
    case Option.Some(color):
        extracted3 = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted3).eq("SimpleColor.Blue"))
}
test_enum_payloads()

// Test nested enums with payloads - Result<Option<Color>, Error>
ErrorType := enum {
    NotFound,
    Invalid,
}

Result := enum {
    Ok: Option,
    Err: ErrorType,
}

test_nested_enum_payloads := proc() {
    red := SimpleColor.Red
    some_red := Option.Some(red)
    result_ok := Result.Ok(some_red)

    // Extract Option from Result using switch pattern matching
    switch result_ok {
        case Result.Ok(extracted_option):
            assert(loc(), enum_to_str(extracted_option).eq("Option.Some"))

            // Extract the color from the option
            switch extracted_option {
                case Option.Some(extracted_color):
                    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))
                case Option.None:
                    // Not expected in this branch
                    assert(loc(), false)
            }
        case Result.Err:
            // Not expected for result_ok
            assert(loc(), false)
    }

    // Test Ok(None)
    none_opt := Option.None
    result_ok_none := Result.Ok(none_opt)
    switch result_ok_none {
        case Result.Ok(extracted_option2):
            assert(loc(), enum_to_str(extracted_option2).eq("Option.None"))
        case Result.Err:
            // Not expected
            assert(loc(), false)
    }

    // Test Err variant
    error := ErrorType.NotFound
    result_err := Result.Err(error)
    switch result_err {
        case Result.Err(extracted_error):
            assert(loc(), enum_to_str(extracted_error).eq("ErrorType.NotFound"))
        case Result.Ok:
            // Not expected
            assert(loc(), false)
    }
}
test_nested_enum_payloads()

// Test deeply nested structs and enums - complex real-world scenario
// This tests: struct->enum->struct->enum->struct nesting
Point2D := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Status := enum {
    Active,
    Inactive,
    Error: Point2D,
}

Entity := struct {
    mut id: I64 = 0
    mut status: Status = Status.Inactive
}

Action := enum {
    Noop,
    Move: Point2D,
    Update: Entity,
}

GameState := struct {
    mut current_action: Action = Action.Noop
    mut player_id: I64 = 0  // Simple field - avoid nested struct limitation
}

Message := enum {
    Info: Str,
    State: GameState,
    Error: Status,
}

test_complex_nesting := proc() {
    // Note: Helper functions don't use pattern matching because type checker doesn't
    // support type inference for pattern-bound variables in nested procedures yet
    // Build up a complex nested structure: Message.State(GameState { Action.Update(Entity { Status.Error(Point2D) }) })

    // Level 1: Create Point2D
    mut error_pos := Point2D()
    error_pos.x = 42
    error_pos.y = 100

    // Level 2: Create Status.Error with Point2D payload
    error_status := Status.Error(error_pos)

    // Level 3: Create Entity with error status
    mut entity := Entity()
    entity.id = 123
    entity.status = error_status

    // Level 4: Create Action.Update with Entity payload
    update_action := Action.Update(entity)

    // Level 5: Create GameState with Action
    mut game_state := GameState()
    game_state.current_action = update_action
    game_state.player_id = 456  // Simple I64 field

    // Level 6: Create Message.State with GameState payload
    message := Message.State(game_state)

    // Now extract and verify the deep nesting

    // Extract GameState from Message using switch pattern matching
    mut extracted_state := GameState()
    switch message {
    case Message.State(state):
        extracted_state = state
    case:
        // Other variants
    }

    // Verify GameState.player_id
    assert_eq(loc(), 456, extracted_state.player_id)

    // Extract Action from GameState
    mut extracted_action := Action.Noop
    extracted_action = extracted_state.current_action
    assert(loc(), enum_to_str(extracted_action).eq("Action.Update"))

    // TODO: Cannot extract Entity from Action because Entity contains enum field (Status)
    // This is a known limitation - structs with enum fields as enum payloads don't work yet
    // // Extract Entity from Action using switch pattern matching
    // mut extracted_entity := Entity()
    // switch extracted_action {
    // case Action.Update(entity):
    //     extracted_entity = entity
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 123, extracted_entity.id)
    // assert(loc(), enum_to_str(extracted_entity.status).eq("Status.Error"))
    //
    // // Extract Status from Entity - it's a struct field so direct access
    // mut extracted_status := Status.Inactive
    // extracted_status = extracted_entity.status
    // assert(loc(), enum_to_str(extracted_status).eq("Status.Error"))
    //
    // // Extract Point2D from Status using switch pattern matching
    // mut extracted_point := Point2D()
    // switch extracted_status {
    // case Status.Error(point):
    //     extracted_point = point
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 42, extracted_point.x)
    // assert_eq(loc(), 100, extracted_point.y)

    // Test another branch: Message.Info with string
    info_msg := Message.Info("System initialized")

    // Test direct extraction
    mut extracted_info := ""
    switch info_msg {
    case Message.Info(info):
        extracted_info = info
    case:
        // Other variants
    }
    assert(loc(), extracted_info.eq("System initialized"))

    // Test Message.Error with simpler Status
    active_status := Status.Active
    simple_error := Message.Error(active_status)

    // Test direct extraction using switch pattern matching
    mut extracted_status2 := Status.Inactive
    switch simple_error {
    case Message.Error(status):
        extracted_status2 = status
    case:
        // Other variants
    }
    assert(loc(), enum_to_str(extracted_status2).eq("Status.Active"))

    // Test Action.Move with Point2D directly (simpler test)
    mut test_point := Point2D()
    test_point.x = 99
    test_point.y = 88
    test_move := Action.Move(test_point)

    // Test direct extraction using switch pattern matching
    mut extracted_test_point := Point2D()
    switch test_move {
    case Action.Move(point):
        extracted_test_point = point
    case:
        // Other variants
    }
    assert_eq(loc(), 99, extracted_test_point.x)
    assert_eq(loc(), 88, extracted_test_point.y)

    // TODO: Cannot extract Point2D from Action.Move when Action comes from struct field
    // This is a known limitation - extracting payloads from enums stored as struct fields
    // doesn't work yet (the enum was already copied when the struct was extracted)
    // // Test with Move action containing Point2D wrapped in GameState/Message
    // mut move_point := Point2D()
    // move_point.x = 10
    // move_point.y = 20
    // move_action := Action.Move(move_point)
    //
    // mut game_state2 := GameState()
    // game_state2.current_action = move_action
    //
    // message2 := Message.State(game_state2)
    // mut extracted_state2 := GameState()
    // switch message2 {
    // case Message.State(state):
    //     extracted_state2 = state
    // case:
    //     // Other variants
    // }
    //
    // mut extracted_action2 := Action.Noop
    // extracted_action2 = extracted_state2.current_action
    // assert(loc(), enum_to_str(extracted_action2).eq("Action.Move"))
    //
    // mut extracted_move_point := Point2D()
    // switch extracted_action2 {
    // case Action.Move(point):
    //     extracted_move_point = point
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 10, extracted_move_point.x)
    // assert_eq(loc(), 20, extracted_move_point.y)
}
test_complex_nesting()

// Test switch pattern matching with payload extraction
// This tests the new syntax: case EnumVariant(var_name):
test_switch_pattern_bool := proc() {
    green_true := Color.Green(true)
    green_false := Color.Green(false)

    mut result := ""

    // Test extracting true payload
    switch green_true {
    case Color.Green(is_olive):
        if is_olive {
            result = "olive green"
        } else {
            result = "ERROR: Should be olive green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "olive green", result)

    // Test extracting false payload
    switch green_false {
    case Color.Green(is_olive):
        if not(is_olive) {
            result = "dark green"
        } else {
            result = "ERROR: Should be dark green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "dark green", result)
}

test_switch_pattern_i64 := proc() {
    num42 := Color.Number(42)
    num0 := Color.Number(0)

    mut result := ""

    // Test extracting I64 payload
    switch num42 {
    case Color.Number(code):
        if I64.eq(code, 42) {
            result = "answer to everything"
        } else {
            result = "ERROR: Should be 42"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "answer to everything", result)

    // Test extracting zero
    switch num0 {
    case Color.Number(code):
        if I64.eq(code, 0) {
            result = "zero"
        } else {
            result = "ERROR: Should be 0"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "zero", result)
}

test_switch_pattern_str := proc() {
    red := Color.Name("red")
    blue := Color.Name("blue")

    mut result := ""

    // Test extracting Str payload
    switch red {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "red") {
            result = "red color"
        } else {
            result = "ERROR: Should be red"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "red color", result)

    // Test extracting another string
    switch blue {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "blue") {
            result = "blue color"
        } else {
            result = "ERROR: Should be blue"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "blue color", result)
}

// Run the pattern matching tests
test_switch_pattern_bool()
test_switch_pattern_i64()
test_switch_pattern_str()

// Test: Direct nested enum construction
TestInnerEnum := enum {
    ValueA: I64,
    ValueB: Str,
}

TestOuterEnum := enum {
    WrapperA: TestInnerEnum,
    WrapperB: I64,
}

test_direct_nested_construction := proc() {

    // Direct nested enum construction
    mut outer := TestOuterEnum.WrapperA(TestInnerEnum.ValueA(42))

    // Extract and verify
    switch outer {
    case TestOuterEnum.WrapperA(inner):
        switch inner {
        case TestInnerEnum.ValueA(val):
            assert_eq(loc(), 42, val)
        case TestInnerEnum.ValueB(s):
            panic(loc(), "Wrong inner variant")
        }
    case TestOuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }

    // Test with string payload
    mut outer2 := TestOuterEnum.WrapperA(TestInnerEnum.ValueB("hello"))
    switch outer2 {
    case TestOuterEnum.WrapperA(inner_extracted):
        switch inner_extracted {
        case TestInnerEnum.ValueB(s):
            assert(loc(), Str.eq(s, "hello"))
        case TestInnerEnum.ValueA(i):
            panic(loc(), "Wrong inner variant")
        }
    case TestOuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }
}
test_direct_nested_construction()

// Test: Enum payload preservation when copying
TestSimpleEnum := enum {
    IntValue: I64,
    StrValue: Str,
    NoValue,
}

TestContainer := struct {
    mut enum_field: TestSimpleEnum = TestSimpleEnum.NoValue
}

test_enum_payload_copy := proc() {
    // Copy enum with I64 payload
    mut original := TestSimpleEnum.IntValue(42)
    mut dup := original
    switch dup {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 42, val)
    case: panic(loc(), "Payload lost during copy")
    }

    // Copy enum with Str payload
    mut original_str := TestSimpleEnum.StrValue("hello")
    mut dup_str := original_str
    switch dup_str {
    case TestSimpleEnum.StrValue(s):
        assert(loc(), Str.eq(s, "hello"))
    case: panic(loc(), "Payload lost during copy")
    }

    // Copy from struct field (critical test case)
    mut container := TestContainer()
    container.enum_field = TestSimpleEnum.IntValue(99)
    mut local_copy := container.enum_field
    switch local_copy {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 99, val)
    case: panic(loc(), "Payload lost when copying from struct field")
    }

    // Chain of copies
    mut a := TestSimpleEnum.IntValue(123)
    mut b := a
    mut c := b
    mut d := c
    switch d {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 123, val)
    case: panic(loc(), "Payload lost in chain of copies")
    }
}
test_enum_payload_copy()

// Note: rsonly_enum_extract_payload has been removed in favor of switch pattern matching

// ==============================================================================
// Regression tests for enum payloads in struct fields (Bug #6)
// ==============================================================================

TokenType := enum {
    String,
    Number,
    Identifier: Str,
}

Token := struct {
    mut token_type: TokenType = TokenType.String
    mut token_str: Str = ""
}

// Test: Direct enum assignment to struct field preserves payload
test_enum_field_assignment := proc() {
    mut t := Token()
    t.token_type = TokenType.Identifier("foo")

    nt := t.token_type
    switch nt {
    case TokenType.Identifier(name):
        assert_eq_str(loc(), "foo", name)
    case:
        panic(loc(), "Expected Identifier variant")
    }
}
test_enum_field_assignment()

// Test: Enum without payload in struct field
test_enum_field_no_payload := proc() {
    mut t := Token()
    t.token_type = TokenType.String

    nt := t.token_type
    switch nt {
    case TokenType.String:
        // Success
    case:
        panic(loc(), "Expected String variant")
    }
}
test_enum_field_no_payload()

// Test: Struct copy preserves enum payloads (Bug #6 regression test)
test_struct_copy_with_enum := proc() {
    mut t1 := Token()
    t1.token_type = TokenType.Identifier("foo")
    t1.token_str = "identifier_foo"

    // Copy the struct
    t2 := t1

    // Verify the enum payload was preserved
    nt := t2.token_type
    switch nt {
    case TokenType.Identifier(name):
        assert_eq_str(loc(), "foo", name)
    case:
        panic(loc(), "Expected Identifier variant with payload 'foo'")
    }

    // Verify the string field was also preserved
    assert_eq_str(loc(), "identifier_foo", t2.token_str)
}
test_struct_copy_with_enum()

// Test: Struct copy with different enum variants
test_struct_copy_various_payloads := proc() {
    // Test with Number variant
    mut t1 := Token()
    t1.token_type = TokenType.Number
    t2 := t1

    nt := t2.token_type
    switch nt {
    case TokenType.Number:
        // Success
    case:
        panic(loc(), "Expected Number variant")
    }

    // Test with String variant
    mut t3 := Token()
    t3.token_type = TokenType.String
    t4 := t3

    nt2 := t4.token_type
    switch nt2 {
    case TokenType.String:
        // Success
    case:
        panic(loc(), "Expected String variant")
    }

    // Test with different Identifier payload
    mut t5 := Token()
    t5.token_type = TokenType.Identifier("bar_test")
    t6 := t5

    nt3 := t6.token_type
    switch nt3 {
    case TokenType.Identifier(name):
        assert_eq_str(loc(), "bar_test", name)
    case:
        panic(loc(), "Expected Identifier variant with payload 'bar_test'")
    }
}
test_struct_copy_various_payloads()

// ==============================================================================
// Test: Enum constructor as function return value (parser.til blocker)
// ==============================================================================

// This tests the specific pattern that's blocking parser.til translation:
// Returning an enum variant with a payload constructed from another enum

InnerType := enum {
    TypeA,
    TypeB,
}

OuterType := enum {
    Nested: InnerType,
    Value: I64,
}

// Test: Can we construct enum variant with enum payload inside a function?
test_enum_constructor_in_function := proc() {
    // Test 1: Using a variable (this works)
    inner := InnerType.TypeA
    outer1 := OuterType.Nested(inner)

    mut extracted1 := InnerType.TypeB
    switch outer1 {
    case OuterType.Nested(i):
        extracted1 = i
    case:
        panic(loc(), "Failed to match Nested variant")
    }
    assert(loc(), enum_to_str(extracted1).eq("InnerType.TypeA"))

    // Test 2: Direct construction in return position
    get_nested_a := proc() returns OuterType {
        inner_temp := InnerType.TypeA
        return OuterType.Nested(inner_temp)
    }

    outer2 := get_nested_a()
    mut extracted2 := InnerType.TypeB
    switch outer2 {
    case OuterType.Nested(i):
        extracted2 = i
    case:
        panic(loc(), "Failed to match Nested variant in returned value")
    }
    assert(loc(), enum_to_str(extracted2).eq("InnerType.TypeA"))

    // Test 3: Can we do it inline? (THIS is what parser.til needs)
    // This would be: return OuterType.Nested(InnerType.TypeA)
    get_nested_b := proc() returns OuterType {
        // Try inline construction
        return OuterType.Nested(InnerType.TypeB)
    }

    outer3 := get_nested_b()
    mut extracted3 := InnerType.TypeA
    switch outer3 {
    case OuterType.Nested(i):
        extracted3 = i
    case:
        panic(loc(), "Failed to match inline nested construction")
    }
    assert(loc(), enum_to_str(extracted3).eq("InnerType.TypeB"))
}
test_enum_constructor_in_function()

// ============================================================================
// Bug #28 Regression Tests - UFCS fails inside pattern match case bodies
// See doc/todo/bugs.org for full details
// Fixed: Added scope management in check_body_returns_throws for pattern bindings
// ============================================================================

// Test: UFCS v.push(n) inside switch case WITH binding - Bug #28 manifestation 2
// This tests the check_body_returns_throws scope issue (typer.rs:739-740)
test_bug28_ufcs_push_in_binding := proc() {
    val := Color.Number(123)
    mut result := 0
    switch val {
    case Color.Number(n):
        mut v := Vec.new(I64)
        v.push(n)  // UFCS with arg - was failing in check_body_returns_throws
        result = v.len()
    case:
        result = 0
    }
    catch (err: AllocError) { panic(loc(), err.msg) }
    assert_eq(loc(), 1, result)
}
test_bug28_ufcs_push_in_binding()

// Test: UFCS v.len() inside switch case WITH binding - Bug #28
// Tests UFCS without extra args but still in binding context
test_bug28_ufcs_len_in_binding := proc() {
    val := Color.Number(123)
    mut result := 0
    switch val {
    case Color.Number(n):
        mut v := Vec.new(I64)
        Vec.push(v, 99)  // fully qualified push (works)
        result = v.len()  // UFCS len - was failing in check_body_returns_throws
    case:
        result = 0
    }
    catch (err: AllocError) { panic(loc(), err.msg) }
    assert_eq(loc(), 1, result)
}
test_bug28_ufcs_len_in_binding()

// Additional switch scope tests (not pattern matching)
// Test: UFCS in enum value-matching case (no binding)
test_ufcs_in_value_case := proc() {
    val := Color.Unknown
    mut result := 0
    switch val {
    case Color.Unknown:
        mut v := Vec.new(I64)
        v.push(42)  // UFCS in value-matching case
        result = v.len()
    case:
        result = 0
    }
    catch (err: AllocError) { panic(loc(), err.msg) }
    assert_eq(loc(), 1, result)
}
test_ufcs_in_value_case()

// Test: UFCS in default case body
test_ufcs_in_default_case := proc() {
    val := Color.Green(true)
    mut result := 0
    switch val {
    case Color.Unknown:
        result = 999
    case:
        mut v := Vec.new(I64)
        v.push(99)  // UFCS in default case body
        result = v.len()
    }
    catch (err: AllocError) { panic(loc(), err.msg) }
    assert_eq(loc(), 1, result)
}
test_ufcs_in_default_case()

// ============================================================================
// Bug #31 - Switch on struct field (enum field access) fails
// The interpreter doesn't properly handle field access in switch expressions
// ============================================================================

StructWithEnum := struct {
    mut node_type: ExampleEnum = ExampleEnum.A
}

test_switch_on_struct_field := proc() {
    mut s := StructWithEnum()
    s.node_type = ExampleEnum.B

    mut result := ""
    switch s.node_type {
    case ExampleEnum.A:
        result = "got A"
    case ExampleEnum.B:
        result = "got B"
    case:
        result = "got default"
    }
    assert_eq_str(loc(), "got B", result)
}
test_switch_on_struct_field()

// Test with pattern matching (payload extraction) on struct field
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test_switch_on_struct_field_with_payload := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)

    mut result := 0
    switch s.color {
    case Color.Number(n):
        result = n
    case:
        result = 0
    }
    assert_eq(loc(), 42, result)
}
test_switch_on_struct_field_with_payload()
