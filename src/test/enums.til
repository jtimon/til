mode test

ExampleEnum := enum {
    A,
    B,
    C,
    D,
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum: ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    mut to_switch2 := to_switch
    to_switch2 = ExampleEnum.B
    to_switch2 = to_switch
    mut to_return := ""
    switch to_switch2 {
    case ExampleEnum.A: to_return = "enum switch aaaaaa"
    case ExampleEnum.B: to_return = "enum switch bbbbbb"
    case: to_return = "enum cccccc by default"
    }
    return to_return
}

assert_eq_str(loc(), "enum switch aaaaaa",     test_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",     test_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.D))

// Test enum_to_str core function
assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(ExampleEnum.A))
assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(ExampleEnum.B))
assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(ExampleEnum.C))
assert_eq_str(loc(), "ExampleEnum.D", enum_to_str(ExampleEnum.D))

no_return_switch_str := "xxxxxx because return inside switch doesn't work even for enum"
test_return_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    // println("in test_return_switch_enum: to_switch: ", enum_to_str(to_switch))
    switch to_switch {
    case ExampleEnum.A:
        return "enum switch aaaaaa"
    case ExampleEnum.B:
        return "enum switch bbbbbb"
    case:
        return "enum cccccc by default"
    }
    return no_return_switch_str
}
assert_eq_str(loc(), "enum switch aaaaaa",       test_return_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",       test_return_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.D))

// Test that enum variants are valid symbols and type-check
test_enum_variant_resolution := proc() {
    mut my_enum_val: ExampleEnum = ExampleEnum.A
    my_enum_val2 := ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.C
    assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(my_enum_val))

    // my_enum_val = ExampleEnum.D // TODO make sure this fails at check type
}
test_enum_variant_resolution()

// Test tagged unions
Color := enum {
    Unknown,
    Green: Bool,
    Number: I64,
    Name: Str,
}

aaa := Color.Unknown
bbb := Color.Green(true)
ccc := Color.Number(42)

// Test payload extraction
mut bool_payload := false
enum_extract_payload(bbb, bool_payload)
assert(loc(), bool_payload)

mut i64_payload := 0
enum_extract_payload(ccc, i64_payload)
assert_eq(loc(), 42, i64_payload)

// Test with different values
green_false := Color.Green(false)
mut bool_payload2 := false
enum_extract_payload(green_false, bool_payload2)
assert(loc(), not(bool_payload2))

number_99 := Color.Number(99)
mut i64_payload2 := 0
enum_extract_payload(number_99, i64_payload2)
assert_eq(loc(), 99, i64_payload2)

// Test type checking: these should fail at compile time
// Color.Green(42)  // ERROR: expects Bool, got I64
// Color.Number(true)  // ERROR: expects I64, got Bool

// Test matching enum variants with payload extraction
// Note: Full pattern matching syntax like `case Color.Green(is_olive):` requires parser changes
// For now, we match on enum_to_str() and extract payloads manually
test_color_match := proc(to_switch: Color) returns Str {
    variant_str := enum_to_str(to_switch)
    switch variant_str {
    case "Color.Unknown": return "unknown color"
    case "Color.Green":
        mut is_olive := false
        enum_extract_payload(to_switch, is_olive)
        if is_olive {
            return "olive green"
        }
        return "dark green"
    case "Color.Number":
        mut code := 0
        enum_extract_payload(to_switch, code)
        if gt(code, 0) {
            return "positive color code"
        }
        return "negative color code"
    }
    return "should not reach here"
}

assert_eq_str(loc(), test_color_match(Color.Unknown), "unknown color")
assert_eq_str(loc(), test_color_match(bbb), "olive green")
assert_eq_str(loc(), test_color_match(green_false), "dark green")
assert_eq_str(loc(), test_color_match(ccc), "positive color code")

// Test Str payloads
test_str_payloads := proc() {
    // Test creating enum with Str payload
    my_name := "crimson"
    color_name := Color.Name(my_name)

    // Test extraction with enum_extract_payload
    mut extracted_name := ""
    enum_extract_payload(color_name, extracted_name)
    assert(loc(), extracted_name.eq("crimson"))

    // Test with different string values
    blue_color := Color.Name("blue")
    mut extracted_blue := ""
    enum_extract_payload(blue_color, extracted_blue)
    assert(loc(), extracted_blue.eq("blue"))

    // Test with longer string
    long_name := "bright-yellow-green"
    long_color := Color.Name(long_name)
    mut extracted_long := ""
    enum_extract_payload(long_color, extracted_long)
    assert(loc(), extracted_long.eq("bright-yellow-green"))

    // Test in switch statement
    test_color_name_match := proc(c: Color) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(c)
        switch variant_str {
        case "Color.Name":
            mut name := ""
            enum_extract_payload(c, name)
            return format("color name: ", name)
        case "Color.Number":
            mut code := 0
            enum_extract_payload(c, code)
            return format("color code: ", code.to_str())
        }
        return "other color"
    }

    assert(loc(), test_color_name_match(color_name).eq("color name: crimson"))
    assert(loc(), test_color_name_match(blue_color).eq("color name: blue"))

    number_color := Color.Number(255)
    assert(loc(), test_color_name_match(number_color).eq("color code: 255"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_str_payloads()

// Test struct payloads
Vec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Vec3 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
    mut z: I64 = 0
}

ContainerStruct := struct {
    mut vec: Vec2 = Vec2()
    mut value: I64 = 0
}

Shape := enum {
    Point: Vec2,
    Point3D: Vec3,
    Container: ContainerStruct,
}

test_struct_payloads := proc() {
    // Test basic struct payload
    mut my_vec := Vec2()
    my_vec.x = 10
    my_vec.y = 20
    point := Shape.Point(my_vec)

    mut extracted_vec := Vec2()
    enum_extract_payload(point, extracted_vec)
    assert_eq(loc(), 10, extracted_vec.x)
    assert_eq(loc(), 20, extracted_vec.y)

    // Test 3D point
    mut my_vec3 := Vec3()
    my_vec3.x = 1
    my_vec3.y = 2
    my_vec3.z = 3
    point3d := Shape.Point3D(my_vec3)

    mut extracted_vec3 := Vec3()
    enum_extract_payload(point3d, extracted_vec3)
    assert_eq(loc(), 1, extracted_vec3.x)
    assert_eq(loc(), 2, extracted_vec3.y)
    assert_eq(loc(), 3, extracted_vec3.z)

    // TODO: Test nested struct payload - requires fixing nested struct allocation in insert_struct
    // mut container := ContainerStruct()
    // container.vec.x = 100
    // container.vec.y = 200
    // container.value = 42
    // container_shape := Shape.Container(container)
    //
    // mut extracted_container := ContainerStruct()
    // enum_extract_payload(container_shape, extracted_container)
    // assert_eq(loc(), 100, extracted_container.vec.x)
    // assert_eq(loc(), 200, extracted_container.vec.y)
    // assert_eq(loc(), 42, extracted_container.value)

    // Test with enum_extract_payload in switch
    test_shape_match := proc(s: Shape) returns I64 {
        variant_str := enum_to_str(s)
        switch variant_str {
        case "Shape.Point":
            mut v := Vec2()
            enum_extract_payload(s, v)
            return add(v.x, v.y)
        case "Shape.Point3D":
            mut v3 := Vec3()
            enum_extract_payload(s, v3)
            return add(add(v3.x, v3.y), v3.z)
        case "Shape.Container":
            mut c := ContainerStruct()
            enum_extract_payload(s, c)
            return c.value
        }
        return 0
    }

    assert_eq(loc(), 30, test_shape_match(point))  // 10 + 20
    assert_eq(loc(), 6, test_shape_match(point3d))  // 1 + 2 + 3
    // assert_eq(loc(), 42, test_shape_match(container_shape))  // TODO: nested struct
}
test_struct_payloads()

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD,
    LBool : Bool,
    LNumber : I64,
    LString : Str,
}
