mode test

ExampleEnum := enum {
    A,
    B,
    C,
    D,
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum: ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    mut to_switch2 := to_switch
    to_switch2 = ExampleEnum.B
    to_switch2 = to_switch
    mut to_return := ""
    switch to_switch2 {
    case ExampleEnum.A: to_return = "enum switch aaaaaa"
    case ExampleEnum.B: to_return = "enum switch bbbbbb"
    case: to_return = "enum cccccc by default"
    }
    return to_return
}

assert_eq_str(loc(), "enum switch aaaaaa",     test_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",     test_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.D))

// Test enum_to_str core function
assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(ExampleEnum.A))
assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(ExampleEnum.B))
assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(ExampleEnum.C))
assert_eq_str(loc(), "ExampleEnum.D", enum_to_str(ExampleEnum.D))

no_return_switch_str := "xxxxxx because return inside switch doesn't work even for enum"
test_return_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    // println("in test_return_switch_enum: to_switch: ", enum_to_str(to_switch))
    switch to_switch {
    case ExampleEnum.A:
        return "enum switch aaaaaa"
    case ExampleEnum.B:
        return "enum switch bbbbbb"
    case:
        return "enum cccccc by default"
    }
    return no_return_switch_str
}
assert_eq_str(loc(), "enum switch aaaaaa",       test_return_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",       test_return_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.D))

// Test that enum variants are valid symbols and type-check
test_enum_variant_resolution := proc() {
    mut my_enum_val: ExampleEnum = ExampleEnum.A
    my_enum_val2 := ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.C
    assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(my_enum_val))

    // my_enum_val = ExampleEnum.D // TODO make sure this fails at check type
}
test_enum_variant_resolution()

// Test tagged unions
Color := enum {
    Unknown,
    Green: Bool,
    Number: I64,
    Name: Str,
}

aaa := Color.Unknown
bbb := Color.Green(true)
ccc := Color.Number(42)

// Test payload extraction
mut bool_payload := false
enum_extract_payload(bbb, bool_payload)
assert(loc(), bool_payload)

mut i64_payload := 0
enum_extract_payload(ccc, i64_payload)
assert_eq(loc(), 42, i64_payload)

// Test with different values
green_false := Color.Green(false)
mut bool_payload2 := false
enum_extract_payload(green_false, bool_payload2)
assert(loc(), not(bool_payload2))

number_99 := Color.Number(99)
mut i64_payload2 := 0
enum_extract_payload(number_99, i64_payload2)
assert_eq(loc(), 99, i64_payload2)

// Test type checking: these should fail at compile time
// Color.Green(42)  // ERROR: expects Bool, got I64
// Color.Number(true)  // ERROR: expects I64, got Bool

// Test matching enum variants with payload extraction
// Note: Full pattern matching syntax like `case Color.Green(is_olive):` requires parser changes
// For now, we match on enum_to_str() and extract payloads manually
test_color_match := proc(to_switch: Color) returns Str {
    variant_str := enum_to_str(to_switch)
    switch variant_str {
    case "Color.Unknown": return "unknown color"
    case "Color.Green":
        mut is_olive := false
        enum_extract_payload(to_switch, is_olive)
        if is_olive {
            return "olive green"
        }
        return "dark green"
    case "Color.Number":
        mut code := 0
        enum_extract_payload(to_switch, code)
        if gt(code, 0) {
            return "positive color code"
        }
        return "negative color code"
    }
    return "should not reach here"
}

assert_eq_str(loc(), test_color_match(Color.Unknown), "unknown color")
assert_eq_str(loc(), test_color_match(bbb), "olive green")
assert_eq_str(loc(), test_color_match(green_false), "dark green")
assert_eq_str(loc(), test_color_match(ccc), "positive color code")

// Test Str payloads
test_str_payloads := proc() {
    // Test creating enum with Str payload
    my_name := "crimson"
    color_name := Color.Name(my_name)

    // Test extraction with enum_extract_payload
    mut extracted_name := ""
    enum_extract_payload(color_name, extracted_name)
    assert(loc(), extracted_name.eq("crimson"))

    // Test with different string values
    blue_color := Color.Name("blue")
    mut extracted_blue := ""
    enum_extract_payload(blue_color, extracted_blue)
    assert(loc(), extracted_blue.eq("blue"))

    // Test with longer string
    long_name := "bright-yellow-green"
    long_color := Color.Name(long_name)
    mut extracted_long := ""
    enum_extract_payload(long_color, extracted_long)
    assert(loc(), extracted_long.eq("bright-yellow-green"))

    // Test in switch statement
    test_color_name_match := proc(c: Color) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(c)
        switch variant_str {
        case "Color.Name":
            mut name := ""
            enum_extract_payload(c, name)
            return format("color name: ", name)
        case "Color.Number":
            mut code := 0
            enum_extract_payload(c, code)
            return format("color code: ", code.to_str())
        }
        return "other color"
    }

    assert(loc(), test_color_name_match(color_name).eq("color name: crimson"))
    assert(loc(), test_color_name_match(blue_color).eq("color name: blue"))

    number_color := Color.Number(255)
    assert(loc(), test_color_name_match(number_color).eq("color code: 255"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_str_payloads()

// Test struct payloads
Vec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Vec3 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
    mut z: I64 = 0
}

ContainerStruct := struct {
    mut vec: Vec2 = Vec2()
    mut value: I64 = 0
}

Shape := enum {
    Point: Vec2,
    Point3D: Vec3,
    Container: ContainerStruct,
}

test_struct_payloads := proc() {
    // Test basic struct payload
    mut my_vec := Vec2()
    my_vec.x = 10
    my_vec.y = 20
    point := Shape.Point(my_vec)

    mut extracted_vec := Vec2()
    enum_extract_payload(point, extracted_vec)
    assert_eq(loc(), 10, extracted_vec.x)
    assert_eq(loc(), 20, extracted_vec.y)

    // Test 3D point
    mut my_vec3 := Vec3()
    my_vec3.x = 1
    my_vec3.y = 2
    my_vec3.z = 3
    point3d := Shape.Point3D(my_vec3)

    mut extracted_vec3 := Vec3()
    enum_extract_payload(point3d, extracted_vec3)
    assert_eq(loc(), 1, extracted_vec3.x)
    assert_eq(loc(), 2, extracted_vec3.y)
    assert_eq(loc(), 3, extracted_vec3.z)

    // TODO: Test nested struct payload - requires fixing nested struct allocation in insert_struct
    // mut container := ContainerStruct()
    // container.vec.x = 100
    // container.vec.y = 200
    // container.value = 42
    // container_shape := Shape.Container(container)
    //
    // mut extracted_container := ContainerStruct()
    // enum_extract_payload(container_shape, extracted_container)
    // assert_eq(loc(), 100, extracted_container.vec.x)
    // assert_eq(loc(), 200, extracted_container.vec.y)
    // assert_eq(loc(), 42, extracted_container.value)

    // Test with enum_extract_payload in switch
    test_shape_match := proc(s: Shape) returns I64 {
        variant_str := enum_to_str(s)
        switch variant_str {
        case "Shape.Point":
            mut v := Vec2()
            enum_extract_payload(s, v)
            return add(v.x, v.y)
        case "Shape.Point3D":
            mut v3 := Vec3()
            enum_extract_payload(s, v3)
            return add(add(v3.x, v3.y), v3.z)
        case "Shape.Container":
            mut c := ContainerStruct()
            enum_extract_payload(s, c)
            return c.value
        }
        return 0
    }

    assert_eq(loc(), 30, test_shape_match(point))  // 10 + 20
    assert_eq(loc(), 6, test_shape_match(point3d))  // 1 + 2 + 3
    // assert_eq(loc(), 42, test_shape_match(container_shape))  // TODO: nested struct
}
test_struct_payloads()

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD,
    LBool : Bool,
    LNumber : I64,
    LString : Str,
}

// Test enum payloads - Option<Color> pattern
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

Option := enum {
    None,
    Some: SimpleColor,
}

test_enum_payloads := proc() {
    // Test None variant (no payload)
    opt_none := Option.None
    assert(loc(), enum_to_str(opt_none).eq("Option.None"))

    // Test Some variant with Color payload
    my_color := SimpleColor.Red
    opt_some := Option.Some(my_color)

    mut extracted_color := SimpleColor.Blue
    enum_extract_payload(opt_some, extracted_color)
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test with Green
    green := SimpleColor.Green
    opt_green := Option.Some(green)
    mut extracted2 := SimpleColor.Red
    enum_extract_payload(opt_green, extracted2)
    assert(loc(), enum_to_str(extracted2).eq("SimpleColor.Green"))

    // Test with Blue
    blue := SimpleColor.Blue
    opt_blue := Option.Some(blue)
    mut extracted3 := SimpleColor.Red
    enum_extract_payload(opt_blue, extracted3)
    assert(loc(), enum_to_str(extracted3).eq("SimpleColor.Blue"))
}
test_enum_payloads()

// Test nested enums with payloads - Result<Option<Color>, Error>
ErrorType := enum {
    NotFound,
    Invalid,
}

Result := enum {
    Ok: Option,
    Err: ErrorType,
}

test_nested_enum_payloads := proc() {
    // Test Ok(Some(Red))
    red := SimpleColor.Red
    some_red := Option.Some(red)
    result_ok := Result.Ok(some_red)

    mut extracted_option := Option.None
    enum_extract_payload(result_ok, extracted_option)
    assert(loc(), enum_to_str(extracted_option).eq("Option.Some"))

    // Extract the color from the option
    mut extracted_color := SimpleColor.Blue
    enum_extract_payload(extracted_option, extracted_color)
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test Ok(None)
    none_opt := Option.None
    result_ok_none := Result.Ok(none_opt)
    green_temp := SimpleColor.Green
    mut extracted_option2 := Option.Some(green_temp)
    enum_extract_payload(result_ok_none, extracted_option2)
    assert(loc(), enum_to_str(extracted_option2).eq("Option.None"))

    // Test Err variant
    error := ErrorType.NotFound
    result_err := Result.Err(error)
    mut extracted_error := ErrorType.Invalid
    enum_extract_payload(result_err, extracted_error)
    assert(loc(), enum_to_str(extracted_error).eq("ErrorType.NotFound"))
}
test_nested_enum_payloads()

// Test deeply nested structs and enums - complex real-world scenario
// This tests: struct->enum->struct->enum->struct nesting
Point2D := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Status := enum {
    Active,
    Inactive,
    Error: Point2D,
}

Entity := struct {
    mut id: I64 = 0
    mut status: Status = Status.Inactive
}

Action := enum {
    Noop,
    Move: Point2D,
    Update: Entity,
}

GameState := struct {
    mut current_action: Action = Action.Noop
    mut player_id: I64 = 0  // Simple field - avoid nested struct limitation
}

Message := enum {
    Info: Str,
    State: GameState,
    Error: Status,
}

test_complex_nesting := proc() {
    // Helper to process Message using switch
    process_message := proc(msg: Message) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(msg)
        switch variant_str {
        case "Message.Info":
            mut info := ""
            enum_extract_payload(msg, info)
            return format("Info: ", info)
        case "Message.State":
            mut state := GameState()
            enum_extract_payload(msg, state)
            player_id := state.player_id
            return format("State with player_id=", player_id.to_str())
        case "Message.Error":
            mut err_status := Status.Inactive
            enum_extract_payload(msg, err_status)
            return format("Error: ", enum_to_str(err_status))
        }
        return "unknown message"
    }

    // Helper to process Action using switch
    process_action := proc(act: Action) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(act)
        switch variant_str {
        case "Action.Noop":
            return "Noop action"
        case "Action.Move":
            mut pos := Point2D()
            enum_extract_payload(act, pos)
            x := pos.x
            y := pos.y
            return format("Move to (", x.to_str(), ",", y.to_str(), ")")
        case "Action.Update":
            // Note: Can't extract Entity because it contains enum field
            return "Update action (extraction not supported)"
        }
        return "unknown action"
    }
    // Build up a complex nested structure: Message.State(GameState { Action.Update(Entity { Status.Error(Point2D) }) })

    // Level 1: Create Point2D
    mut error_pos := Point2D()
    error_pos.x = 42
    error_pos.y = 100

    // Level 2: Create Status.Error with Point2D payload
    error_status := Status.Error(error_pos)

    // Level 3: Create Entity with error status
    mut entity := Entity()
    entity.id = 123
    entity.status = error_status

    // Level 4: Create Action.Update with Entity payload
    update_action := Action.Update(entity)

    // Level 5: Create GameState with Action
    mut game_state := GameState()
    game_state.current_action = update_action
    game_state.player_id = 456  // Simple I64 field

    // Level 6: Create Message.State with GameState payload
    message := Message.State(game_state)

    // Now extract and verify the deep nesting

    // Test using switch-based helper
    result := process_message(message)
    assert(loc(), result.eq("State with player_id=456"))

    // Extract GameState from Message
    mut extracted_state := GameState()
    enum_extract_payload(message, extracted_state)

    // Verify GameState.player_id
    assert_eq(loc(), 456, extracted_state.player_id)

    // Extract Action from GameState and test with switch
    mut extracted_action := Action.Noop
    extracted_action = extracted_state.current_action
    assert(loc(), enum_to_str(extracted_action).eq("Action.Update"))

    action_result := process_action(extracted_action)
    assert(loc(), action_result.eq("Update action (extraction not supported)"))

    // TODO: Entity extraction fails because Entity contains Status enum field
    // This creates struct-with-enum-field as enum payload, which doesn't work yet
    // // Extract Entity from Action
    // mut extracted_entity := Entity()
    // enum_extract_payload(extracted_action, extracted_entity)
    // assert_eq(loc(), 123, extracted_entity.id)
    // assert(loc(), enum_to_str(extracted_entity.status).eq("Status.Error"))

    // // Extract Status from Entity
    // mut extracted_status := Status.Inactive
    // extracted_status = extracted_entity.status
    // assert(loc(), enum_to_str(extracted_status).eq("Status.Error"))

    // // Extract Point2D from Status
    // mut extracted_point := Point2D()
    // enum_extract_payload(extracted_status, extracted_point)
    // assert_eq(loc(), 42, extracted_point.x)
    // assert_eq(loc(), 100, extracted_point.y)

    // Test another branch: Message.Info with string
    info_msg := Message.Info("System initialized")

    // Test with switch-based helper
    info_result := process_message(info_msg)
    assert(loc(), info_result.eq("Info: System initialized"))

    // Also test direct extraction
    mut extracted_info := ""
    enum_extract_payload(info_msg, extracted_info)
    assert(loc(), extracted_info.eq("System initialized"))

    // Test Message.Error with simpler Status
    active_status := Status.Active
    simple_error := Message.Error(active_status)

    // Test with switch-based helper
    error_result := process_message(simple_error)
    assert(loc(), error_result.eq("Error: Status.Active"))

    // Also test direct extraction
    mut extracted_status2 := Status.Inactive
    enum_extract_payload(simple_error, extracted_status2)
    assert(loc(), enum_to_str(extracted_status2).eq("Status.Active"))

    // Test Action.Move with Point2D directly (simpler test)
    mut test_point := Point2D()
    test_point.x = 99
    test_point.y = 88
    test_move := Action.Move(test_point)

    // Test with switch-based helper
    move_result := process_action(test_move)
    assert(loc(), move_result.eq("Move to (99,88)"))

    // Also test direct extraction
    mut extracted_test_point := Point2D()
    enum_extract_payload(test_move, extracted_test_point)
    assert_eq(loc(), 99, extracted_test_point.x)
    assert_eq(loc(), 88, extracted_test_point.y)

    // Test with Move action containing Point2D wrapped in GameState/Message
    // TODO: This fails - struct payloads from enums nested in other structs don't work
    // mut move_point := Point2D()
    // move_point.x = 10
    // move_point.y = 20
    // move_action := Action.Move(move_point)

    // mut game_state2 := GameState()
    // game_state2.current_action = move_action

    // message2 := Message.State(game_state2)
    // mut extracted_state2 := GameState()
    // enum_extract_payload(message2, extracted_state2)

    // mut extracted_action2 := Action.Noop
    // extracted_action2 = extracted_state2.current_action
    // assert(loc(), enum_to_str(extracted_action2).eq("Action.Move"))

    // mut extracted_move_point := Point2D()
    // enum_extract_payload(extracted_action2, extracted_move_point)
    // assert_eq(loc(), 10, extracted_move_point.x)
    // assert_eq(loc(), 20, extracted_move_point.y)

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_complex_nesting()
