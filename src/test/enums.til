mode test

ExampleEnum := enum {
    A,
    B,
    C,
    D,
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum: ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    mut to_switch2 := to_switch
    to_switch2 = ExampleEnum.B
    to_switch2 = to_switch
    mut to_return := ""
    switch to_switch2 {
    case ExampleEnum.A: to_return = "enum switch aaaaaa"
    case ExampleEnum.B: to_return = "enum switch bbbbbb"
    case: to_return = "enum cccccc by default"
    }
    return to_return
}

assert_eq_str(loc(), "enum switch aaaaaa",     test_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",     test_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.D))

// Test enum_to_str core function
assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(ExampleEnum.A))
assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(ExampleEnum.B))
assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(ExampleEnum.C))
assert_eq_str(loc(), "ExampleEnum.D", enum_to_str(ExampleEnum.D))

no_return_switch_str := "xxxxxx because return inside switch doesn't work even for enum"
test_return_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    // println("in test_return_switch_enum: to_switch: ", enum_to_str(to_switch))
    switch to_switch {
    case ExampleEnum.A:
        return "enum switch aaaaaa"
    case ExampleEnum.B:
        return "enum switch bbbbbb"
    case:
        return "enum cccccc by default"
    }
    return no_return_switch_str
}
assert_eq_str(loc(), "enum switch aaaaaa",       test_return_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",       test_return_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.D))

// Test that enum variants are valid symbols and type-check
test_enum_variant_resolution := proc() {
    mut my_enum_val: ExampleEnum = ExampleEnum.A
    my_enum_val2 := ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.C
    assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(my_enum_val))

    // my_enum_val = ExampleEnum.D // TODO make sure this fails at check type
}
test_enum_variant_resolution()

// Test tagged unions
Color := enum {
    Unknown,
    Green: Bool,
    Number: I64,
    Name: Str,
}

aaa := Color.Unknown
bbb := Color.Green(true)
ccc := Color.Number(42)

// Test payload extraction using switch pattern matching
test_simple_payload_extraction := proc() {
    mut bool_payload := false
    switch bbb {
    case Color.Green(is_olive):
        bool_payload = is_olive
    case:
        // Other variants
    }
    assert(loc(), bool_payload)

    mut i64_payload := 0
    switch ccc {
    case Color.Number(code):
        i64_payload = code
    case:
        // Other variants
    }
    assert_eq(loc(), 42, i64_payload)

    // Test with different values
    green_false := Color.Green(false)
    mut bool_payload2 := false
    switch green_false {
    case Color.Green(is_olive):
        bool_payload2 = is_olive
    case:
        // Other variants
    }
    assert(loc(), not(bool_payload2))

    number_99 := Color.Number(99)
    mut i64_payload2 := 0
    switch number_99 {
    case Color.Number(code):
        i64_payload2 = code
    case:
        // Other variants
    }
    assert_eq(loc(), 99, i64_payload2)
}
test_simple_payload_extraction()

green_false := Color.Green(false)

// Test type checking: these should fail at compile time
// Color.Green(42)  // ERROR: expects Bool, got I64
// Color.Number(true)  // ERROR: expects I64, got Bool

// Test matching enum variants with payload extraction using switch pattern matching
test_color_match := proc(to_switch: Color) returns Str {
    switch to_switch {
    case Color.Unknown: return "unknown color"
    case Color.Green(is_olive):
        if is_olive {
            return "olive green"
        }
        return "dark green"
    case Color.Number(code):
        if gt(code, 0) {
            return "positive color code"
        }
        return "negative color code"
    case Color.Name:
        return "color with name"
    case:
        return "should not reach here"
    }
}

assert_eq_str(loc(), test_color_match(Color.Unknown), "unknown color")
assert_eq_str(loc(), test_color_match(bbb), "olive green")
assert_eq_str(loc(), test_color_match(green_false), "dark green")
assert_eq_str(loc(), test_color_match(ccc), "positive color code")

// Test Str payloads
test_str_payloads := proc() {
    // Test creating enum with Str payload
    my_name := "crimson"
    color_name := Color.Name(my_name)

    // Test extraction with switch pattern matching
    mut extracted_name := ""
    switch color_name {
    case Color.Name(name):
        extracted_name = name
    case:
        // Other variants
    }
    assert(loc(), extracted_name.eq("crimson"))

    // Test with different string values
    blue_color := Color.Name("blue")
    mut extracted_blue := ""
    switch blue_color {
    case Color.Name(name):
        extracted_blue = name
    case:
        // Other variants
    }
    assert(loc(), extracted_blue.eq("blue"))

    // Test with longer string
    long_name := "bright-yellow-green"
    long_color := Color.Name(long_name)
    mut extracted_long := ""
    switch long_color {
    case Color.Name(name):
        extracted_long = name
    case:
        // Other variants
    }
    assert(loc(), extracted_long.eq("bright-yellow-green"))

    // Test in switch statement
    test_color_name_match := proc(col: Color) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        switch col {
        case Color.Name(name):
            return format("color name: ", name)
        case Color.Number(code):
            code_str := I64.to_str(code)
            return format("color code: ", code_str)
        case:
            return "other color"
        }
    }

    assert(loc(), test_color_name_match(color_name).eq("color name: crimson"))
    assert(loc(), test_color_name_match(blue_color).eq("color name: blue"))

    number_color := Color.Number(255)
    assert(loc(), test_color_name_match(number_color).eq("color code: 255"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_str_payloads()

// Test struct payloads
Vec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Vec3 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
    mut z: I64 = 0
}

ContainerStruct := struct {
    mut vec: Vec2 = Vec2()
    mut value: I64 = 0
}

Shape := enum {
    Point: Vec2,
    Point3D: Vec3,
    Container: ContainerStruct,
}

test_struct_payloads := proc() {
    // Test basic struct payload
    mut my_vec := Vec2()
    my_vec.x = 10
    my_vec.y = 20
    point := Shape.Point(my_vec)

    mut extracted_vec := Vec2()
    switch point {
    case Shape.Point(vec):
        extracted_vec = vec
    case:
        // Other variants
    }
    assert_eq(loc(), 10, extracted_vec.x)
    assert_eq(loc(), 20, extracted_vec.y)

    // Test 3D point
    mut my_vec3 := Vec3()
    my_vec3.x = 1
    my_vec3.y = 2
    my_vec3.z = 3
    point3d := Shape.Point3D(my_vec3)

    mut extracted_vec3 := Vec3()
    switch point3d {
    case Shape.Point3D(vec3):
        extracted_vec3 = vec3
    case:
        // Other variants
    }
    assert_eq(loc(), 1, extracted_vec3.x)
    assert_eq(loc(), 2, extracted_vec3.y)
    assert_eq(loc(), 3, extracted_vec3.z)

    // TODO: Test nested struct payload - requires fixing nested struct allocation in insert_struct
    // mut container := ContainerStruct()
    // container.vec.x = 100
    // container.vec.y = 200
    // container.value = 42
    // container_shape := Shape.Container(container)
    //
    // mut extracted_container := ContainerStruct()
    // rsonly_enum_extract_payload(container_shape, extracted_container)
    // assert_eq(loc(), 100, extracted_container.vec.x)
    // assert_eq(loc(), 200, extracted_container.vec.y)
    // assert_eq(loc(), 42, extracted_container.value)

    // Test with switch pattern matching
    test_shape_match := proc(s: Shape) returns I64 {
        switch s {
        case Shape.Point(v):
            return add(v.x, v.y)
        case Shape.Point3D(v3):
            return add(add(v3.x, v3.y), v3.z)
        case Shape.Container:
            // TODO: Container with nested struct not yet supported
            return 0
        case:
            return 0
        }
    }

    assert_eq(loc(), 30, test_shape_match(point))  // 10 + 20
    assert_eq(loc(), 6, test_shape_match(point3d))  // 1 + 2 + 3
    // assert_eq(loc(), 42, test_shape_match(container_shape))  // TODO: nested struct
}
test_struct_payloads()

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD,
    LBool : Bool,
    LNumber : I64,
    LString : Str,
}

// Test enum payloads - Option<Color> pattern
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

Option := enum {
    None,
    Some: SimpleColor,
}

test_enum_payloads := proc() {
    // Test None variant (no payload)
    opt_none := Option.None
    assert(loc(), enum_to_str(opt_none).eq("Option.None"))

    // Test Some variant with Color payload
    my_color := SimpleColor.Red
    opt_some := Option.Some(my_color)

    mut extracted_color := SimpleColor.Blue
    switch opt_some {
    case Option.Some(color):
        extracted_color = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test with Green
    green := SimpleColor.Green
    opt_green := Option.Some(green)
    mut extracted2 := SimpleColor.Red
    switch opt_green {
    case Option.Some(color):
        extracted2 = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted2).eq("SimpleColor.Green"))

    // Test with Blue
    blue := SimpleColor.Blue
    opt_blue := Option.Some(blue)
    mut extracted3 := SimpleColor.Red
    switch opt_blue {
    case Option.Some(color):
        extracted3 = color
    case:
        // None
    }
    assert(loc(), enum_to_str(extracted3).eq("SimpleColor.Blue"))
}
test_enum_payloads()

// Test nested enums with payloads - Result<Option<Color>, Error>
ErrorType := enum {
    NotFound,
    Invalid,
}

Result := enum {
    Ok: Option,
    Err: ErrorType,
}

test_nested_enum_payloads := proc() {
    // NOTE: Pattern matching not yet supported for enum payloads, using rsonly_enum_extract_payload
    red := SimpleColor.Red
    some_red := Option.Some(red)
    result_ok := Result.Ok(some_red)

    mut extracted_option := Option.None
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_ok, extracted_option)
    assert(loc(), enum_to_str(extracted_option).eq("Option.Some"))

    // Extract the color from the option
    mut extracted_color := SimpleColor.Blue
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(extracted_option, extracted_color)
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test Ok(None)
    none_opt := Option.None
    result_ok_none := Result.Ok(none_opt)
    green_temp := SimpleColor.Green
    mut extracted_option2 := Option.Some(green_temp)
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_ok_none, extracted_option2)
    assert(loc(), enum_to_str(extracted_option2).eq("Option.None"))

    // Test Err variant
    error := ErrorType.NotFound
    result_err := Result.Err(error)
    mut extracted_error := ErrorType.Invalid
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_err, extracted_error)
    assert(loc(), enum_to_str(extracted_error).eq("ErrorType.NotFound"))
}
test_nested_enum_payloads()

// Test deeply nested structs and enums - complex real-world scenario
// This tests: struct->enum->struct->enum->struct nesting
Point2D := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Status := enum {
    Active,
    Inactive,
    Error: Point2D,
}

Entity := struct {
    mut id: I64 = 0
    mut status: Status = Status.Inactive
}

Action := enum {
    Noop,
    Move: Point2D,
    Update: Entity,
}

GameState := struct {
    mut current_action: Action = Action.Noop
    mut player_id: I64 = 0  // Simple field - avoid nested struct limitation
}

Message := enum {
    Info: Str,
    State: GameState,
    Error: Status,
}

test_complex_nesting := proc() {
    // Note: Helper functions don't use pattern matching because type checker doesn't
    // support type inference for pattern-bound variables in nested procedures yet
    // Build up a complex nested structure: Message.State(GameState { Action.Update(Entity { Status.Error(Point2D) }) })

    // Level 1: Create Point2D
    mut error_pos := Point2D()
    error_pos.x = 42
    error_pos.y = 100

    // Level 2: Create Status.Error with Point2D payload
    error_status := Status.Error(error_pos)

    // Level 3: Create Entity with error status
    mut entity := Entity()
    entity.id = 123
    entity.status = error_status

    // Level 4: Create Action.Update with Entity payload
    update_action := Action.Update(entity)

    // Level 5: Create GameState with Action
    mut game_state := GameState()
    game_state.current_action = update_action
    game_state.player_id = 456  // Simple I64 field

    // Level 6: Create Message.State with GameState payload
    message := Message.State(game_state)

    // Now extract and verify the deep nesting

    // Extract GameState from Message using switch pattern matching
    mut extracted_state := GameState()
    switch message {
    case Message.State(state):
        extracted_state = state
    case:
        // Other variants
    }

    // Verify GameState.player_id
    assert_eq(loc(), 456, extracted_state.player_id)

    // Extract Action from GameState
    mut extracted_action := Action.Noop
    extracted_action = extracted_state.current_action
    assert(loc(), enum_to_str(extracted_action).eq("Action.Update"))

    // TODO: Cannot extract Entity from Action because Entity contains enum field (Status)
    // This is a known limitation - structs with enum fields as enum payloads don't work yet
    // // Extract Entity from Action using switch pattern matching
    // mut extracted_entity := Entity()
    // switch extracted_action {
    // case Action.Update(entity):
    //     extracted_entity = entity
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 123, extracted_entity.id)
    // assert(loc(), enum_to_str(extracted_entity.status).eq("Status.Error"))
    //
    // // Extract Status from Entity - it's a struct field so direct access
    // mut extracted_status := Status.Inactive
    // extracted_status = extracted_entity.status
    // assert(loc(), enum_to_str(extracted_status).eq("Status.Error"))
    //
    // // Extract Point2D from Status using switch pattern matching
    // mut extracted_point := Point2D()
    // switch extracted_status {
    // case Status.Error(point):
    //     extracted_point = point
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 42, extracted_point.x)
    // assert_eq(loc(), 100, extracted_point.y)

    // Test another branch: Message.Info with string
    info_msg := Message.Info("System initialized")

    // Test direct extraction
    mut extracted_info := ""
    switch info_msg {
    case Message.Info(info):
        extracted_info = info
    case:
        // Other variants
    }
    assert(loc(), extracted_info.eq("System initialized"))

    // Test Message.Error with simpler Status
    active_status := Status.Active
    simple_error := Message.Error(active_status)

    // Test direct extraction using switch pattern matching
    mut extracted_status2 := Status.Inactive
    switch simple_error {
    case Message.Error(status):
        extracted_status2 = status
    case:
        // Other variants
    }
    assert(loc(), enum_to_str(extracted_status2).eq("Status.Active"))

    // Test Action.Move with Point2D directly (simpler test)
    mut test_point := Point2D()
    test_point.x = 99
    test_point.y = 88
    test_move := Action.Move(test_point)

    // Test direct extraction using switch pattern matching
    mut extracted_test_point := Point2D()
    switch test_move {
    case Action.Move(point):
        extracted_test_point = point
    case:
        // Other variants
    }
    assert_eq(loc(), 99, extracted_test_point.x)
    assert_eq(loc(), 88, extracted_test_point.y)

    // TODO: Cannot extract Point2D from Action.Move when Action comes from struct field
    // This is a known limitation - extracting payloads from enums stored as struct fields
    // doesn't work yet (the enum was already copied when the struct was extracted)
    // // Test with Move action containing Point2D wrapped in GameState/Message
    // mut move_point := Point2D()
    // move_point.x = 10
    // move_point.y = 20
    // move_action := Action.Move(move_point)
    //
    // mut game_state2 := GameState()
    // game_state2.current_action = move_action
    //
    // message2 := Message.State(game_state2)
    // mut extracted_state2 := GameState()
    // switch message2 {
    // case Message.State(state):
    //     extracted_state2 = state
    // case:
    //     // Other variants
    // }
    //
    // mut extracted_action2 := Action.Noop
    // extracted_action2 = extracted_state2.current_action
    // assert(loc(), enum_to_str(extracted_action2).eq("Action.Move"))
    //
    // mut extracted_move_point := Point2D()
    // switch extracted_action2 {
    // case Action.Move(point):
    //     extracted_move_point = point
    // case:
    //     // Other variants
    // }
    // assert_eq(loc(), 10, extracted_move_point.x)
    // assert_eq(loc(), 20, extracted_move_point.y)
}
test_complex_nesting()

// Test switch pattern matching with payload extraction
// This tests the new syntax: case EnumVariant(var_name):
test_switch_pattern_bool := proc() {
    green_true := Color.Green(true)
    green_false := Color.Green(false)

    mut result := ""

    // Test extracting true payload
    switch green_true {
    case Color.Green(is_olive):
        if is_olive {
            result = "olive green"
        } else {
            result = "ERROR: Should be olive green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "olive green", result)

    // Test extracting false payload
    switch green_false {
    case Color.Green(is_olive):
        if not(is_olive) {
            result = "dark green"
        } else {
            result = "ERROR: Should be dark green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "dark green", result)
}

test_switch_pattern_i64 := proc() {
    num42 := Color.Number(42)
    num0 := Color.Number(0)

    mut result := ""

    // Test extracting I64 payload
    switch num42 {
    case Color.Number(code):
        if I64.eq(code, 42) {
            result = "answer to everything"
        } else {
            result = "ERROR: Should be 42"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "answer to everything", result)

    // Test extracting zero
    switch num0 {
    case Color.Number(code):
        if I64.eq(code, 0) {
            result = "zero"
        } else {
            result = "ERROR: Should be 0"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "zero", result)
}

test_switch_pattern_str := proc() {
    red := Color.Name("red")
    blue := Color.Name("blue")

    mut result := ""

    // Test extracting Str payload
    switch red {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "red") {
            result = "red color"
        } else {
            result = "ERROR: Should be red"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "red color", result)

    // Test extracting another string
    switch blue {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "blue") {
            result = "blue color"
        } else {
            result = "ERROR: Should be blue"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "blue color", result)
}

// Run the pattern matching tests
test_switch_pattern_bool()
test_switch_pattern_i64()
test_switch_pattern_str()

// Test: Direct nested enum construction
TestInnerEnum := enum {
    ValueA: I64,
    ValueB: Str,
}

TestOuterEnum := enum {
    WrapperA: TestInnerEnum,
    WrapperB: I64,
}

test_direct_nested_construction := proc() {

    // Direct nested enum construction
    mut outer := TestOuterEnum.WrapperA(TestInnerEnum.ValueA(42))

    // Extract and verify
    switch outer {
    case TestOuterEnum.WrapperA(inner):
        switch inner {
        case TestInnerEnum.ValueA(val):
            assert_eq(loc(), 42, val)
        case TestInnerEnum.ValueB(s):
            panic(loc(), "Wrong inner variant")
        }
    case TestOuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }

    // Test with string payload
    mut outer2 := TestOuterEnum.WrapperA(TestInnerEnum.ValueB("hello"))
    switch outer2 {
    case TestOuterEnum.WrapperA(inner_extracted):
        switch inner_extracted {
        case TestInnerEnum.ValueB(s):
            assert(loc(), Str.eq(s, "hello"))
        case TestInnerEnum.ValueA(i):
            panic(loc(), "Wrong inner variant")
        }
    case TestOuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }
}
test_direct_nested_construction()

// Test: Enum payload preservation when copying
TestSimpleEnum := enum {
    IntValue: I64,
    StrValue: Str,
    NoValue,
}

TestContainer := struct {
    mut enum_field: TestSimpleEnum = TestSimpleEnum.NoValue
}

test_enum_payload_copy := proc() {
    // Copy enum with I64 payload
    mut original := TestSimpleEnum.IntValue(42)
    mut copy := original
    switch copy {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 42, val)
    case: panic(loc(), "Payload lost during copy")
    }

    // Copy enum with Str payload
    mut original_str := TestSimpleEnum.StrValue("hello")
    mut copy_str := original_str
    switch copy_str {
    case TestSimpleEnum.StrValue(s):
        assert(loc(), Str.eq(s, "hello"))
    case: panic(loc(), "Payload lost during copy")
    }

    // Copy from struct field (critical test case)
    mut container := TestContainer()
    container.enum_field = TestSimpleEnum.IntValue(99)
    mut local_copy := container.enum_field
    switch local_copy {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 99, val)
    case: panic(loc(), "Payload lost when copying from struct field")
    }

    // Chain of copies
    mut a := TestSimpleEnum.IntValue(123)
    mut b := a
    mut c := b
    mut d := c
    switch d {
    case TestSimpleEnum.IntValue(val):
        assert_eq(loc(), 123, val)
    case: panic(loc(), "Payload lost in chain of copies")
    }
}
test_enum_payload_copy()

// Test: rsonly_enum_extract_payload function
TestPayloadEnum := enum {
    IntValue: I64,
    StrValue: Str,
    NoValue,
}

TestPerson := struct {
    mut name: Str = ""
    mut age: I64 = 0
}

TestStructPayload := enum {
    PersonData: TestPerson,
    Count: I64,
}

TestNestedPayload := enum {
    Inner: TestPayloadEnum,
    Direct: I64,
}

test_rsonly_extract_payload := proc() {
    // Extract I64 payload
    mut val_i64 := TestPayloadEnum.IntValue(42)
    mut extracted_i64: I64 = 0
    rsonly_enum_extract_payload(val_i64, extracted_i64)
    assert_eq(loc(), 42, extracted_i64)

    // Extract Str payload
    mut val_str := TestPayloadEnum.StrValue("hello")
    mut extracted_str: Str = ""
    rsonly_enum_extract_payload(val_str, extracted_str)
    assert(loc(), Str.eq(extracted_str, "hello"))

    // Extract struct payload
    mut p := TestPerson()
    p.name = "Alice"
    p.age = 30
    mut val_struct := TestStructPayload.PersonData(p)
    mut extracted_person := TestPerson()
    rsonly_enum_extract_payload(val_struct, extracted_person)
    assert(loc(), Str.eq(extracted_person.name, "Alice"))
    assert_eq(loc(), 30, extracted_person.age)

    // Extract nested enum payload
    mut val_nested := TestNestedPayload.Inner(TestPayloadEnum.IntValue(99))
    mut extracted_inner := TestPayloadEnum.NoValue
    rsonly_enum_extract_payload(val_nested, extracted_inner)
    mut final_value: I64 = 0
    rsonly_enum_extract_payload(extracted_inner, final_value)
    assert_eq(loc(), 99, final_value)
}
test_rsonly_extract_payload()
