mode test

ExampleEnum := enum {
    A,
    B,
    C,
    D,
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum: ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    mut to_switch2 := to_switch
    to_switch2 = ExampleEnum.B
    to_switch2 = to_switch
    mut to_return := ""
    switch to_switch2 {
    case ExampleEnum.A: to_return = "enum switch aaaaaa"
    case ExampleEnum.B: to_return = "enum switch bbbbbb"
    case: to_return = "enum cccccc by default"
    }
    return to_return
}

assert_eq_str(loc(), "enum switch aaaaaa",     test_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",     test_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default", test_switch_enum(ExampleEnum.D))

// Test enum_to_str core function
assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(ExampleEnum.A))
assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(ExampleEnum.B))
assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(ExampleEnum.C))
assert_eq_str(loc(), "ExampleEnum.D", enum_to_str(ExampleEnum.D))

no_return_switch_str := "xxxxxx because return inside switch doesn't work even for enum"
test_return_switch_enum := proc(to_switch: ExampleEnum) returns Str {
    // println("in test_return_switch_enum: to_switch: ", enum_to_str(to_switch))
    switch to_switch {
    case ExampleEnum.A:
        return "enum switch aaaaaa"
    case ExampleEnum.B:
        return "enum switch bbbbbb"
    case:
        return "enum cccccc by default"
    }
    return no_return_switch_str
}
assert_eq_str(loc(), "enum switch aaaaaa",       test_return_switch_enum(ExampleEnum.A))
assert_eq_str(loc(), "enum switch bbbbbb",       test_return_switch_enum(ExampleEnum.B))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.C))
assert_eq_str(loc(), "enum cccccc by default",   test_return_switch_enum(ExampleEnum.D))

// Test that enum variants are valid symbols and type-check
test_enum_variant_resolution := proc() {
    mut my_enum_val: ExampleEnum = ExampleEnum.A
    my_enum_val2 := ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.A", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.B
    assert_eq_str(loc(), "ExampleEnum.B", enum_to_str(my_enum_val))

    my_enum_val = ExampleEnum.C
    assert_eq_str(loc(), "ExampleEnum.C", enum_to_str(my_enum_val))

    // my_enum_val = ExampleEnum.D // TODO make sure this fails at check type
}
test_enum_variant_resolution()

// Test tagged unions
Color := enum {
    Unknown,
    Green: Bool,
    Number: I64,
    Name: Str,
}

aaa := Color.Unknown
bbb := Color.Green(true)
ccc := Color.Number(42)

// Test payload extraction using switch pattern matching
test_simple_payload_extraction := proc() {
    mut bool_payload := false
    switch bbb {
    case Color.Green(is_olive):
        bool_payload = is_olive
    case:
        // Other variants
    }
    assert(loc(), bool_payload)

    mut i64_payload := 0
    switch ccc {
    case Color.Number(code):
        i64_payload = code
    case:
        // Other variants
    }
    assert_eq(loc(), 42, i64_payload)

    // Test with different values
    green_false := Color.Green(false)
    mut bool_payload2 := false
    switch green_false {
    case Color.Green(is_olive):
        bool_payload2 = is_olive
    case:
        // Other variants
    }
    assert(loc(), not(bool_payload2))

    number_99 := Color.Number(99)
    mut i64_payload2 := 0
    switch number_99 {
    case Color.Number(code):
        i64_payload2 = code
    case:
        // Other variants
    }
    assert_eq(loc(), 99, i64_payload2)
}
test_simple_payload_extraction()

green_false := Color.Green(false)

// Test type checking: these should fail at compile time
// Color.Green(42)  // ERROR: expects Bool, got I64
// Color.Number(true)  // ERROR: expects I64, got Bool

// Test matching enum variants with payload extraction using switch pattern matching
test_color_match := proc(to_switch: Color) returns Str {
    switch to_switch {
    case Color.Unknown: return "unknown color"
    case Color.Green(is_olive):
        if is_olive {
            return "olive green"
        }
        return "dark green"
    case Color.Number(code):
        if gt(code, 0) {
            return "positive color code"
        }
        return "negative color code"
    case Color.Name:
        return "color with name"
    case:
        return "should not reach here"
    }
}

assert_eq_str(loc(), test_color_match(Color.Unknown), "unknown color")
assert_eq_str(loc(), test_color_match(bbb), "olive green")
assert_eq_str(loc(), test_color_match(green_false), "dark green")
assert_eq_str(loc(), test_color_match(ccc), "positive color code")

// Test Str payloads
test_str_payloads := proc() {
    // Test creating enum with Str payload
    my_name := "crimson"
    color_name := Color.Name(my_name)

    // Test extraction with switch pattern matching
    mut extracted_name := ""
    switch color_name {
    case Color.Name(name):
        extracted_name = name
    case:
        // Other variants
    }
    assert(loc(), extracted_name.eq("crimson"))

    // Test with different string values
    blue_color := Color.Name("blue")
    mut extracted_blue := ""
    switch blue_color {
    case Color.Name(name):
        extracted_blue = name
    case:
        // Other variants
    }
    assert(loc(), extracted_blue.eq("blue"))

    // Test with longer string
    long_name := "bright-yellow-green"
    long_color := Color.Name(long_name)
    mut extracted_long := ""
    switch long_color {
    case Color.Name(name):
        extracted_long = name
    case:
        // Other variants
    }
    assert(loc(), extracted_long.eq("bright-yellow-green"))

    // Test in switch statement
    test_color_name_match := proc(col: Color) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        switch col {
        case Color.Name(name):
            return format("color name: ", name)
        case Color.Number(code):
            code_str := I64.to_str(code)
            return format("color code: ", code_str)
        case:
            return "other color"
        }
    }

    assert(loc(), test_color_name_match(color_name).eq("color name: crimson"))
    assert(loc(), test_color_name_match(blue_color).eq("color name: blue"))

    number_color := Color.Number(255)
    assert(loc(), test_color_name_match(number_color).eq("color code: 255"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_str_payloads()

// Test struct payloads
Vec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Vec3 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
    mut z: I64 = 0
}

ContainerStruct := struct {
    mut vec: Vec2 = Vec2()
    mut value: I64 = 0
}

Shape := enum {
    Point: Vec2,
    Point3D: Vec3,
    Container: ContainerStruct,
}

test_struct_payloads := proc() {
    // Test basic struct payload
    // NOTE: Pattern matching not yet supported for struct payloads, using rsonly_enum_extract_payload
    mut my_vec := Vec2()
    my_vec.x = 10
    my_vec.y = 20
    point := Shape.Point(my_vec)

    mut extracted_vec := Vec2()
    switch point {
    case Shape.Point(vec):
        extracted_vec = vec
    case:
        // Other variants
    }
    assert_eq(loc(), 10, extracted_vec.x)
    assert_eq(loc(), 20, extracted_vec.y)

    // Test 3D point
    mut my_vec3 := Vec3()
    my_vec3.x = 1
    my_vec3.y = 2
    my_vec3.z = 3
    point3d := Shape.Point3D(my_vec3)

    mut extracted_vec3 := Vec3()
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(point3d, extracted_vec3)
    assert_eq(loc(), 1, extracted_vec3.x)
    assert_eq(loc(), 2, extracted_vec3.y)
    assert_eq(loc(), 3, extracted_vec3.z)

    // TODO: Test nested struct payload - requires fixing nested struct allocation in insert_struct
    // mut container := ContainerStruct()
    // container.vec.x = 100
    // container.vec.y = 200
    // container.value = 42
    // container_shape := Shape.Container(container)
    //
    // mut extracted_container := ContainerStruct()
    // rsonly_enum_extract_payload(container_shape, extracted_container)
    // assert_eq(loc(), 100, extracted_container.vec.x)
    // assert_eq(loc(), 200, extracted_container.vec.y)
    // assert_eq(loc(), 42, extracted_container.value)

    // Test with switch - using enum_to_str because struct pattern matching not supported yet
    test_shape_match := proc(s: Shape) returns I64 {
        variant_str := enum_to_str(s)
        switch variant_str {
        case "Shape.Point":
            mut v := Vec2()
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(s, v)
            return add(v.x, v.y)
        case "Shape.Point3D":
            mut v3 := Vec3()
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(s, v3)
            return add(add(v3.x, v3.y), v3.z)
        case "Shape.Container":
            mut c := ContainerStruct()
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(s, c)
            return c.value
        }
        return 0
    }

    assert_eq(loc(), 30, test_shape_match(point))  // 10 + 20
    assert_eq(loc(), 6, test_shape_match(point3d))  // 1 + 2 + 3
    // assert_eq(loc(), 42, test_shape_match(container_shape))  // TODO: nested struct
}
test_struct_payloads()

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD,
    LBool : Bool,
    LNumber : I64,
    LString : Str,
}

// Test enum payloads - Option<Color> pattern
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

Option := enum {
    None,
    Some: SimpleColor,
}

test_enum_payloads := proc() {
    // Test None variant (no payload)
    opt_none := Option.None
    assert(loc(), enum_to_str(opt_none).eq("Option.None"))

    // Test Some variant with Color payload
    // NOTE: Pattern matching not yet supported for enum payloads, using rsonly_enum_extract_payload
    my_color := SimpleColor.Red
    opt_some := Option.Some(my_color)

    mut extracted_color := SimpleColor.Blue
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(opt_some, extracted_color)
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test with Green
    green := SimpleColor.Green
    opt_green := Option.Some(green)
    mut extracted2 := SimpleColor.Red
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(opt_green, extracted2)
    assert(loc(), enum_to_str(extracted2).eq("SimpleColor.Green"))

    // Test with Blue
    blue := SimpleColor.Blue
    opt_blue := Option.Some(blue)
    mut extracted3 := SimpleColor.Red
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(opt_blue, extracted3)
    assert(loc(), enum_to_str(extracted3).eq("SimpleColor.Blue"))
}
test_enum_payloads()

// Test nested enums with payloads - Result<Option<Color>, Error>
ErrorType := enum {
    NotFound,
    Invalid,
}

Result := enum {
    Ok: Option,
    Err: ErrorType,
}

test_nested_enum_payloads := proc() {
    // Test Ok(Some(Red))
    // NOTE: Pattern matching not yet supported for enum payloads, using rsonly_enum_extract_payload
    red := SimpleColor.Red
    some_red := Option.Some(red)
    result_ok := Result.Ok(some_red)

    mut extracted_option := Option.None
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_ok, extracted_option)
    assert(loc(), enum_to_str(extracted_option).eq("Option.Some"))

    // Extract the color from the option
    mut extracted_color := SimpleColor.Blue
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(extracted_option, extracted_color)
    assert(loc(), enum_to_str(extracted_color).eq("SimpleColor.Red"))

    // Test Ok(None)
    none_opt := Option.None
    result_ok_none := Result.Ok(none_opt)
    green_temp := SimpleColor.Green
    mut extracted_option2 := Option.Some(green_temp)
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_ok_none, extracted_option2)
    assert(loc(), enum_to_str(extracted_option2).eq("Option.None"))

    // Test Err variant
    error := ErrorType.NotFound
    result_err := Result.Err(error)
    mut extracted_error := ErrorType.Invalid
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(result_err, extracted_error)
    assert(loc(), enum_to_str(extracted_error).eq("ErrorType.NotFound"))
}
test_nested_enum_payloads()

// Test deeply nested structs and enums - complex real-world scenario
// This tests: struct->enum->struct->enum->struct nesting
Point2D := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

Status := enum {
    Active,
    Inactive,
    Error: Point2D,
}

Entity := struct {
    mut id: I64 = 0
    mut status: Status = Status.Inactive
}

Action := enum {
    Noop,
    Move: Point2D,
    Update: Entity,
}

GameState := struct {
    mut current_action: Action = Action.Noop
    mut player_id: I64 = 0  // Simple field - avoid nested struct limitation
}

Message := enum {
    Info: Str,
    State: GameState,
    Error: Status,
}

test_complex_nesting := proc() {
    // Helper to process Message - using enum_to_str because struct/enum payload pattern matching not supported
    process_message := proc(msg: Message) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(msg)
        switch variant_str {
        case "Message.Info":
            mut info := ""
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(msg, info)
            return format("Info: ", info)
        case "Message.State":
            mut state := GameState()
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(msg, state)
            player_id := state.player_id
            return format("State with player_id=", player_id.to_str())
        case "Message.Error":
            mut err_status := Status.Inactive
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(msg, err_status)
            return format("Error: ", enum_to_str(err_status))
        }
        return "unknown message"
    }

    // Helper to process Action - using enum_to_str because struct payload pattern matching not supported
    process_action := proc(act: Action) returns Str throws AllocError, IndexOutOfBoundsError, I64_OverflowError {
        variant_str := enum_to_str(act)
        switch variant_str {
        case "Action.Noop":
            return "Noop action"
        case "Action.Move":
            mut pos := Point2D()
            // TODO: Use switch instead of rsonly_enum_extract_payload
            rsonly_enum_extract_payload(act, pos)
            x := pos.x
            y := pos.y
            return format("Move to (", x.to_str(), ",", y.to_str(), ")")
        case "Action.Update":
            // Note: Can't extract Entity because it contains enum field
            return "Update action (extraction not supported)"
        }
        return "unknown action"
    }
    // Build up a complex nested structure: Message.State(GameState { Action.Update(Entity { Status.Error(Point2D) }) })

    // Level 1: Create Point2D
    mut error_pos := Point2D()
    error_pos.x = 42
    error_pos.y = 100

    // Level 2: Create Status.Error with Point2D payload
    error_status := Status.Error(error_pos)

    // Level 3: Create Entity with error status
    mut entity := Entity()
    entity.id = 123
    entity.status = error_status

    // Level 4: Create Action.Update with Entity payload
    update_action := Action.Update(entity)

    // Level 5: Create GameState with Action
    mut game_state := GameState()
    game_state.current_action = update_action
    game_state.player_id = 456  // Simple I64 field

    // Level 6: Create Message.State with GameState payload
    message := Message.State(game_state)

    // Now extract and verify the deep nesting

    // Test using switch-based helper
    result := process_message(message)
    assert(loc(), result.eq("State with player_id=456"))

    // Extract GameState from Message
    mut extracted_state := GameState()
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(message, extracted_state)

    // Verify GameState.player_id
    assert_eq(loc(), 456, extracted_state.player_id)

    // Extract Action from GameState and test with switch
    mut extracted_action := Action.Noop
    extracted_action = extracted_state.current_action
    assert(loc(), enum_to_str(extracted_action).eq("Action.Update"))

    action_result := process_action(extracted_action)
    assert(loc(), action_result.eq("Update action (extraction not supported)"))

    // TODO: Entity extraction fails because Entity contains Status enum field
    // This creates struct-with-enum-field as enum payload, which doesn't work yet
    // // Extract Entity from Action
    // mut extracted_entity := Entity()
    // rsonly_enum_extract_payload(extracted_action, extracted_entity)
    // assert_eq(loc(), 123, extracted_entity.id)
    // assert(loc(), enum_to_str(extracted_entity.status).eq("Status.Error"))

    // // Extract Status from Entity
    // mut extracted_status := Status.Inactive
    // extracted_status = extracted_entity.status
    // assert(loc(), enum_to_str(extracted_status).eq("Status.Error"))

    // // Extract Point2D from Status
    // mut extracted_point := Point2D()
    // rsonly_enum_extract_payload(extracted_status, extracted_point)
    // assert_eq(loc(), 42, extracted_point.x)
    // assert_eq(loc(), 100, extracted_point.y)

    // Test another branch: Message.Info with string
    info_msg := Message.Info("System initialized")

    // Test with switch-based helper
    info_result := process_message(info_msg)
    assert(loc(), info_result.eq("Info: System initialized"))

    // Also test direct extraction
    mut extracted_info := ""
    switch info_msg {
    case Message.Info(info):
        extracted_info = info
    case:
        // Other variants
    }
    assert(loc(), extracted_info.eq("System initialized"))

    // Test Message.Error with simpler Status
    active_status := Status.Active
    simple_error := Message.Error(active_status)

    // Test with switch-based helper
    error_result := process_message(simple_error)
    assert(loc(), error_result.eq("Error: Status.Active"))

    // Also test direct extraction
    mut extracted_status2 := Status.Inactive
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(simple_error, extracted_status2)
    assert(loc(), enum_to_str(extracted_status2).eq("Status.Active"))

    // Test Action.Move with Point2D directly (simpler test)
    mut test_point := Point2D()
    test_point.x = 99
    test_point.y = 88
    test_move := Action.Move(test_point)

    // Test with switch-based helper
    move_result := process_action(test_move)
    assert(loc(), move_result.eq("Move to (99,88)"))

    // Also test direct extraction
    mut extracted_test_point := Point2D()
    // TODO: Use switch instead of rsonly_enum_extract_payload
    rsonly_enum_extract_payload(test_move, extracted_test_point)
    assert_eq(loc(), 99, extracted_test_point.x)
    assert_eq(loc(), 88, extracted_test_point.y)

    // Test with Move action containing Point2D wrapped in GameState/Message
    // TODO: This fails - struct payloads from enums nested in other structs don't work
    // mut move_point := Point2D()
    // move_point.x = 10
    // move_point.y = 20
    // move_action := Action.Move(move_point)

    // mut game_state2 := GameState()
    // game_state2.current_action = move_action

    // message2 := Message.State(game_state2)
    // mut extracted_state2 := GameState()
    // rsonly_enum_extract_payload(message2, extracted_state2)

    // mut extracted_action2 := Action.Noop
    // extracted_action2 = extracted_state2.current_action
    // assert(loc(), enum_to_str(extracted_action2).eq("Action.Move"))

    // mut extracted_move_point := Point2D()
    // rsonly_enum_extract_payload(extracted_action2, extracted_move_point)
    // assert_eq(loc(), 10, extracted_move_point.x)
    // assert_eq(loc(), 20, extracted_move_point.y)

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("Unexpected I64_OverflowError: ", err.msg))
    }
}
test_complex_nesting()

// Test switch pattern matching with payload extraction
// This tests the new syntax: case EnumVariant(var_name):
test_switch_pattern_bool := proc() {
    green_true := Color.Green(true)
    green_false := Color.Green(false)

    mut result := ""

    // Test extracting true payload
    switch green_true {
    case Color.Green(is_olive):
        if is_olive {
            result = "olive green"
        } else {
            result = "ERROR: Should be olive green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "olive green", result)

    // Test extracting false payload
    switch green_false {
    case Color.Green(is_olive):
        if not(is_olive) {
            result = "dark green"
        } else {
            result = "ERROR: Should be dark green"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "dark green", result)

    println("PASS: Switch pattern matching with Bool payload works")
}

test_switch_pattern_i64 := proc() {
    num42 := Color.Number(42)
    num0 := Color.Number(0)

    mut result := ""

    // Test extracting I64 payload
    switch num42 {
    case Color.Number(code):
        if I64.eq(code, 42) {
            result = "answer to everything"
        } else {
            result = "ERROR: Should be 42"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "answer to everything", result)

    // Test extracting zero
    switch num0 {
    case Color.Number(code):
        if I64.eq(code, 0) {
            result = "zero"
        } else {
            result = "ERROR: Should be 0"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "zero", result)

    println("PASS: Switch pattern matching with I64 payload works")
}

test_switch_pattern_str := proc() {
    red := Color.Name("red")
    blue := Color.Name("blue")

    mut result := ""

    // Test extracting Str payload
    switch red {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "red") {
            result = "red color"
        } else {
            result = "ERROR: Should be red"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "red color", result)

    // Test extracting another string
    switch blue {
    case Color.Name(name):
        mut name_copy := name
        if Str.eq(name_copy, "blue") {
            result = "blue color"
        } else {
            result = "ERROR: Should be blue"
        }
    case:
        result = "ERROR: No match"
    }
    assert_eq_str(loc(), "blue color", result)

    println("PASS: Switch pattern matching with Str payload works")
}

// Run the pattern matching tests
test_switch_pattern_bool()
test_switch_pattern_i64()
test_switch_pattern_str()
