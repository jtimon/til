mode test

import("core.vec")

test_array_static_u8 := proc() {
    mut stat := Array.new(U8, 3)
    assert_eq(loc(), 3, stat.len())       // Static array len equals cap
    stat.set(0, U8.from_i64(10))
    stat.set(1, U8.from_i64(20))
    stat.set(2, U8.from_i64(30))
    mut val := U8.from_i64(0)
    stat.get(2, val)
    test(loc(), U8.from_i64(30).eq(val), "Get after set at index 2")

    // Uncomment to test panic behavior
    // stat.push(U8.from_i64(77)) // Should panic

    stat.delete()

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_OverflowError) {
        println("ERROR:", loc(), "Unexpected U8_OverflowError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_u8()

test_array_static_str := proc() {
    mut stat := Array.new(Str, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, "hello")
    stat.set(1, "world")
    stat.set(2, "!")
    mut val := ""
    stat.get(2, val)
    test(loc(), val.eq("!"), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_str()

test_array_contains := proc() {
    mut arr := Array.new(Str, 3)
    arr.set(0, "apple")
    arr.set(1, "banana")
    arr.set(2, "cherry")

    test(loc(), arr.contains("apple"), "contains finds first element")
    test(loc(), arr.contains("banana"), "contains finds middle element")
    test(loc(), arr.contains("cherry"), "contains finds last element")
    test(loc(), not(arr.contains("grape")), "contains returns false for missing element")
    test(loc(), not(arr.contains("")), "contains returns false for empty string")

    arr.delete()

    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_contains()

test_array_static_bool := proc() {
    mut stat := Array.new(Bool, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, true)
    stat.set(1, false)
    stat.set(2, true)
    mut val := false
    stat.get(2, val)
    test(loc(), val.eq(true), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_bool()

test_array_static_i64 := proc() {
    mut stat := Array.new(I64, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, 100)
    stat.set(1, 200)
    stat.set(2, 300)
    mut val := 0
    stat.get(2, val)
    test(loc(), val.eq(300), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    new := func(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }
}

test_array_static_vec2 := proc() {
    mut stat := Array.new(Vec2, 3)
    assert_eq(loc(), 3, stat.len())

    // v1 = Vec2.new(1, 2) // TODO FIX
    // v2 = Vec2.new(3, 4) // TODO FIX
    // v3 = Vec2.new(5, 6) // TODO FIX
    v1 := Vec2.new(1, 2)
    v2 := Vec2.new(3, 4)
    v3 := Vec2.new(5, 6)
    stat.set(0, v1)
    stat.set(1, v2)
    stat.set(2, v3)

    mut v := Vec2()
    stat.get(2, v)
    assert_eq(loc(), 5, v.x)
    assert_eq(loc(), 6, v.y)

    // stat.push(Vec2.new(7, 8)) // Should panic if uncommented

    stat.delete()

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_vec2()

// Test push on static array removed - Array.push no longer exists
// Use Vec for dynamic arrays instead
