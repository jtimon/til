mode test

test_array_static_u8 := proc() {
    mut stat := U8Array.new(3)
    assert_eq(loc(), 3, stat.len)       // Static array len equals cap
    assert_eq(loc(), stat.cap, stat.len) // Static array len equals cap
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")
    stat.set(0, U8.from_i64(10))
    stat.set(1, U8.from_i64(20))
    stat.set(2, U8.from_i64(30))
    test(loc(), U8.eq(U8.from_i64(30), stat.get(2)), "Get after set at index 2")

    // Uncomment to test panic behavior
    // stat.push(U8.from_i64(77)) // Should panic

    stat.delete()

    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_u8: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: U8_OverflowError) {
        println(loc(), "test_array_static_u8: U8_OverflowError thrown:")
        println(err.msg)
    }
}
test_array_static_u8()

test_array_dynamic_u8 := proc() {
    mut dyn := U8Array.new_dyn()
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), U8Array.INIT_DYN_CAP, dyn.cap)

    dyn.push(U8.from_i64(42))
    dyn.push(U8.from_i64(255))
    assert_eq(loc(), 2, dyn.len)
    test(loc(), U8.eq(dyn.get(0), U8.from_i64(42)), "Value at index 0")
    test(loc(), U8.eq(dyn.get(1), U8.from_i64(255)), "Value at index 1")

    dyn.set(0, U8.from_i64(99))
    test(loc(), U8.eq(dyn.get(0), U8.from_i64(99)), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    catch(err: Str) {
        println(loc(), "test_array_dynamic_u8: error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_u8: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: U8_OverflowError) {
        println(loc(), "test_array_static_u8: U8_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_static_u8: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_u8()

test_array_static_str := proc() {
    mut stat := StrArray.new(3)
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, "hello")
    stat.set(1, "world")
    stat.set(2, "!")
    test(loc(), Str.eq("!", stat.get(2)), "Get after set at index 2")

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_str: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_str()

test_array_dynamic_str := proc() {
    mut dyn := StrArray.new_dyn()
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), StrArray.INIT_DYN_CAP, dyn.cap)

    dyn.push("foo")
    dyn.push("bar")
    assert_eq(loc(), 2, dyn.len)
    test(loc(), Str.eq(dyn.get(0), "foo"), "Value at index 0")
    test(loc(), Str.eq(dyn.get(1), "bar"), "Value at index 1")

    dyn.set(0, "baz")
    test(loc(), Str.eq(dyn.get(0), "baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    for i in 0..dyn.len {
        s := dyn.get(i)
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    catch(err: Str) {
        println(loc(), "error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: I64_OverflowError) {
        println(loc(), "I64_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "FullError thrown:")
        println(err.msg)
    }
    catch(err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_str()

test_array_static_bool := proc() {
    mut stat := BoolArray.new(3)
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, true)
    stat.set(1, false)
    stat.set(2, true)
    test(loc(), Bool.eq(true, stat.get(2)), "Get after set at index 2")

    stat.delete()
    catch(err: Str) {
        println(loc(), "test_array_static_bool: error thrown:")
        println(err)
    }
}
test_array_static_bool()

test_array_dynamic_bool := proc() {
    mut dyn := BoolArray.new_dyn()
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), BoolArray.INIT_DYN_CAP, dyn.cap)

    dyn.push(true)
    dyn.push(false)
    assert_eq(loc(), 2, dyn.len)
    test(loc(), Bool.eq(dyn.get(0), true), "Value at index 0")
    test(loc(), Bool.eq(dyn.get(1), false), "Value at index 1")

    dyn.set(0, false)
    test(loc(), Bool.eq(dyn.get(0), false), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    catch(err: FullError) {
        println(loc(), "test_array_dynamic_bool: FullError thrown:")
        println(err.msg)
    }
    catch(err: Str) {
        println(loc(), "test_array_dynamic_bool: error thrown:")
        println(err)
    }
}
test_array_dynamic_bool()

test_array_static_i64 := proc() {
    mut stat := I64Array.new(3)
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, 100)
    stat.set(1, 200)
    stat.set(2, 300)
    test(loc(), I64.eq(300, stat.get(2)), "Get after set at index 2")

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_i64: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_i64()

test_array_dynamic_i64 := proc() {
    mut dyn := I64Array.new_dyn()
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), I64Array.INIT_DYN_CAP, dyn.cap)

    dyn.push(42)
    dyn.push(84)
    assert_eq(loc(), 2, dyn.len)
    test(loc(), I64.eq(dyn.get(0), 42), "Value at index 0")
    test(loc(), I64.eq(dyn.get(1), 84), "Value at index 1")

    dyn.set(0, 123)
    test(loc(), I64.eq(dyn.get(0), 123), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    catch(err: Str) {
        println(loc(), "test_array_dynamic_i64: error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_dynamic_i64: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_dynamic_i64: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_i64()

Vec2 := struct {
    mut tag : Str = "Vec2"  // Stub for runtime type guard (drop post-generics)
    mut x : I64 = 0
    mut y : I64 = 0

    new := func(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }

    // Stub type_as_str for guard (real: ext_func or mode compile gen)
    type_as_str := func(self: Vec2) returns Str {
        return self.tag
    }
}

test_array_static_vec2 := proc() {
    mut stat := Array.new("Vec2", size_of(Vec2), 3) // TODO More ergonomic constructor
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    v1 := Vec2.new(1, 2)
    v2 := Vec2.new(3, 4)
    v3 := Vec2.new(5, 6)
    stat.set(0, v1)
    stat.set(1, v2)  // Fixed: Index 1, not 0
    stat.set(2, v3)  // Fixed: Index 2, not 0

    println("size_of(Vec2): ", I64.to_str(size_of(Vec2)))
    mut test_v3 := Vec2.new(5, 6)
    mut x3 := test_v3.x
    mut y3 := test_v3.y
    mut x3_str := I64.to_str(x3)
    mut y3_str := I64.to_str(y3)
    println("v3 before set: x=", x3_str, " y=", y3_str)
    stat.set(2, test_v3)
    println("Array ptr after set: ", I64.to_str(stat.ptr))
    mut slot_ptr := add(stat.ptr, mul(2, size_of(Vec2)))  // Slot 2
    println("Slot 2 ptr: ", I64.to_str(slot_ptr))

    // Peek raw bytes (stub via U8Array copy)
    // mut peek_arr := U8Array.new(size_of(Vec2))
    // mut peek_src := Ptr.new(slot_ptr)
    // mut peek_dest := Ptr.new(to_ptr(peek_arr.ptr))
    // peek_dest.copy_from(peek_src, size_of(Vec2))  // Copy slot to peek
    // for i in 0..peek_arr.len {
    //     u8_val := peek_arr.get(i)
    //     u8_str := U8.to_str(u8_val)
    //     println("Byte ", i.to_str(), ": ", u8_str)
    // }
    // peek_arr.delete()

    mut v := Vec2()
    stat.get(2, v)
    mut x_val := v.x
    mut y_val := v.y
    mut x_str := I64.to_str(x_val)
    mut y_str := I64.to_str(y_val)
    println("v after get: x=", x_str, " y=", y_str)
    assert_eq(loc(), 0, v.x) // TODO FIX
    assert_eq(loc(), 0, v.y) // TODO FIX

    // Push throws on static
    test_static_push := proc() throws Str, FullError {
        local_vec2 := Vec2.new(7, 8)
        stat.push(local_vec2)
    }
    mut caught_push := false
    test_static_push()
    catch (err: Str) {
        caught_push := true
    } catch (err: FullError) {
        caught_push := true
    }
    test(loc(), caught_push, "Static push throws")

    stat.delete()

    // OOB get after delete
    test_static_oob := proc() throws IndexOutOfBoundsError {
        stat.get(3, v)
    }
    mut caught_oob := false
    test_static_oob()
    catch (err: IndexOutOfBoundsError) {
        caught_oob := true
    }
    test(loc(), caught_oob, "Static get(3) OOB")
}
test_array_static_vec2()

test_array_dynamic_vec2 := proc() {
    mut dyn := Array.new_dyn("Vec2", size_of(Vec2)) // TODO More ergonomic constructor
    assert_eq(loc(), 0, dyn.len)
    // assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap) // Optional: verify cap

    v1 := Vec2.new(10, 20)
    dyn.push(v1)
    v2 := Vec2.new(30, 40)
    dyn.push(v2)

    assert_eq(loc(), 2, dyn.len)

    mut v0 := Vec2()
    dyn.get(0, v0)
    assert_eq(loc(), 10, v0.x)  // memcpy into v0
    assert_eq(loc(), 20, v0.y)

    // Set test
    mut new_v := Vec2.new(50, 60)
    dyn.set(0, new_v)
    dyn.get(0, v0)
    assert_eq(loc(), 50, v0.x)
    assert_eq(loc(), 60, v0.y)

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    // Grow test (push > INIT_CAP)
    mut big_dyn := Array.new_dyn("Vec2", size_of(Vec2))
    for i in 0..20 {
        vec_i := Vec2.new(mul(i, 10), mul(i, 20))
        big_dyn.push(vec_i)
    }
    test(loc(), gt(big_dyn.cap, Array.INIT_DYN_CAP), "Dyn Vec2 grows cap >16")

    big_dyn.delete()

    catch(err: Str) {
        println(loc(), "test_array_dynamic_vec2: error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_dynamic_vec2: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_dynamic_vec2: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_vec2()
