mode test

test_array_static_u8 := proc() {
    mut stat := Array.new("U8", size_of(U8), 3)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 3, stat.len)       // Static array len equals cap
    assert_eq(loc(), stat.cap, stat.len) // Static array len equals cap
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")
    stat.set(0, U8.from_i64(10))
    stat.set(1, U8.from_i64(20))
    stat.set(2, U8.from_i64(30))
    mut val := U8.from_i64(0)
    stat.get(2, val)
    test(loc(), U8.eq(U8.from_i64(30), val), "Get after set at index 2")

    // Uncomment to test panic behavior
    // stat.push(U8.from_i64(77)) // Should panic

    stat.delete()

    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_u8: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: U8_OverflowError) {
        println(loc(), "test_array_static_u8: U8_OverflowError thrown:")
        println(err.msg)
    }
}
test_array_static_u8()

test_array_dynamic_u8 := proc() {
    mut dyn := Array.new_dyn("U8", size_of(U8))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap)

    dyn.push(U8.from_i64(42))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    dyn.push(U8.from_i64(255))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 2, dyn.len)
    mut val0 := U8.from_i64(0)
    dyn.get(0, val0)
    test(loc(), U8.eq(val0, U8.from_i64(42)), "Value at index 0")
    mut val1 := U8.from_i64(0)
    dyn.get(1, val1)
    test(loc(), U8.eq(val1, U8.from_i64(255)), "Value at index 1")

    dyn.set(0, U8.from_i64(99))
    mut val := U8.from_i64(0)
    dyn.get(0, val)
    test(loc(), U8.eq(val, U8.from_i64(99)), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    catch(err: Str) {
        println(loc(), "test_array_dynamic_u8: error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_u8: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: U8_OverflowError) {
        println(loc(), "test_array_static_u8: U8_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_static_u8: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_u8()

test_array_static_str := proc() {
    mut stat := Array.new("Str", size_of(Str), 3)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, "hello")
    stat.set(1, "world")
    stat.set(2, "!")
    mut val := ""
    stat.get(2, val)
    test(loc(), Str.eq("!", val), "Get after set at index 2")

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_str: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_str()

test_array_dynamic_str := proc() {
    mut dyn := Array.new_dyn("Str", size_of(Str))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap)

    dyn.push("foo")
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    dyn.push("bar")
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 2, dyn.len)
    mut val0 := ""
    dyn.get(0, val0)
    test(loc(), Str.eq(val0, "foo"), "Value at index 0")
    mut val1 := ""
    dyn.get(1, val1)
    test(loc(), Str.eq(val1, "bar"), "Value at index 1")

    dyn.set(0, "baz")
    mut val := ""
    dyn.get(0, val)
    test(loc(), Str.eq(val, "baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    for i in 0..dyn.len {
        mut s := ""
        dyn.get(i, s)
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    catch(err: Str) {
        println(loc(), "error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: I64_OverflowError) {
        println(loc(), "I64_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "FullError thrown:")
        println(err.msg)
    }
    catch(err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_str()

test_array_static_bool := proc() {
    mut stat := Array.new("Bool", size_of(Bool), 3)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, true)
    stat.set(1, false)
    stat.set(2, true)
    mut val := false
    stat.get(2, val)
    test(loc(), Bool.eq(true, val), "Get after set at index 2")

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_bool: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_bool()

test_array_dynamic_bool := proc() {
    mut dyn := Array.new_dyn("Bool", size_of(Bool))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap)

    dyn.push(true)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    dyn.push(false)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 2, dyn.len)
    mut val0 := false
    dyn.get(0, val0)
    test(loc(), Bool.eq(val0, true), "Value at index 0")
    mut val1 := false
    dyn.get(1, val1)
    test(loc(), Bool.eq(val1, false), "Value at index 1")

    dyn.set(0, false)
    mut val := false
    dyn.get(0, val)
    test(loc(), Bool.eq(val, false), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_dynamic_bool: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_dynamic_bool: FullError thrown:")
        println(err.msg)
    }
    catch(err: Str) {
        println(loc(), "test_array_dynamic_bool: error thrown:")
        println(err)
    }
}
test_array_dynamic_bool()

test_array_static_i64 := proc() {
    mut stat := Array.new("I64", size_of(I64), 3)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    stat.set(0, 100)
    stat.set(1, 200)
    stat.set(2, 300)
    mut val := 0
    stat.get(2, val)
    test(loc(), I64.eq(300, val), "Get after set at index 2")

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_i64: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_i64()

test_array_dynamic_i64 := proc() {
    mut dyn := Array.new_dyn("I64", size_of(I64))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap)

    dyn.push(42)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    dyn.push(84)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 2, dyn.len)
    mut val0 := 0
    dyn.get(0, val0)
    test(loc(), I64.eq(val0, 42), "Value at index 0")
    mut val1 := 0
    dyn.get(1, val1)
    test(loc(), I64.eq(val1, 84), "Value at index 1")

    dyn.set(0, 123)
    mut val := 0
    dyn.get(0, val)
    test(loc(), I64.eq(val, 123), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    catch(err: Str) {
        println(loc(), "test_array_dynamic_i64: error thrown:")
        println(err)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_dynamic_i64: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: FullError) {
        println(loc(), "test_array_dynamic_i64: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    new := func(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }
}

test_array_static_vec2 := proc() {
    mut stat := Array.new("Vec2", size_of(Vec2), 3) // TODO More ergonomic constructor
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 3, stat.len)
    assert_eq(loc(), stat.cap, stat.len)
    test(loc(), not(stat.is_dyn), "Static array should not be dynamic")

    // v1 = Vec2.new(1, 2) // TODO FIX
    // v2 = Vec2.new(3, 4) // TODO FIX
    // v3 = Vec2.new(5, 6) // TODO FIX
    v1 := Vec2.new(1, 2)
    v2 := Vec2.new(3, 4)
    v3 := Vec2.new(5, 6)
    stat.set(0, v1)
    stat.set(1, v2)
    stat.set(2, v3)

    mut v := Vec2()
    stat.get(2, v)
    assert_eq(loc(), 5, v.x)
    assert_eq(loc(), 6, v.y)

    // stat.push(Vec2.new(7, 8)) // Should panic if uncommented

    stat.delete()
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_array_static_vec2: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_static_vec2()

test_array_dynamic_vec2 := proc() {
    mut dyn := Array.new_dyn("Vec2", size_of(Vec2)) // TODO More ergonomic constructor
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    assert_eq(loc(), 0, dyn.len)
    // assert_eq(loc(), Array.INIT_DYN_CAP, dyn.cap) // Optional: verify cap

    // dyn.push(Vec2.new(10, 20)) // TODO FIX
    // dyn.push(Vec2.new(30, 40)) // TODO FIX
    v1 := Vec2.new(10, 20)
    dyn.push(v1)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }
    v2 := Vec2.new(30, 40)
    dyn.push(v2)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }

    assert_eq(loc(), 2, dyn.len)

    mut v0 := Vec2()
    dyn.get(0, v0)
    catch (err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    test(loc(), I64.eq(v0.x, 10), "v0.x should be 10")
    test(loc(), I64.eq(v0.y, 20), "v0.y should be 20")

    v3 := Vec2.new(50, 60)
    dyn.set(0, v3)
    catch (err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }

    mut v_after_set := Vec2()
    dyn.get(0, v_after_set)
    catch (err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    test(loc(), I64.eq(v_after_set.x, 50), "v_after_set.x should be 50")
    test(loc(), I64.eq(v_after_set.y, 60), "v_after_set.y should be 60")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len)
    assert_eq(loc(), 0, dyn.cap)

    catch(err: Str) {
        println(loc(), "test_array_dynamic_vec2: error thrown:")
        println(err)
    }
    catch(err: FullError) {
        println(loc(), "test_array_static_u8: FullError thrown:")
        println(err.msg)
    }
}
test_array_dynamic_vec2()

// Test Array growth/reallocation beyond initial capacity
test_array_growth := proc() {
    mut dyn := Array.new_dyn("I64", size_of(I64))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }

    initial_cap := dyn.cap
    test(loc(), I64.eq(initial_cap, Array.INIT_DYN_CAP), "Initial capacity should be INIT_DYN_CAP")

    // Push elements beyond initial capacity to trigger reallocation
    mut i := 0
    while lt(i, add(Array.INIT_DYN_CAP, 5)) {
        dyn.push(mul(i, 10))
        i = add(i, 1)
    }
    catch (err: AllocError) {
        println(loc(), "AllocError thrown during growth:")
        println(err.msg)
        return
    }
    catch (err: FullError) {
        println(loc(), "FullError thrown during growth:")
        println(err.msg)
        return
    }
    catch (err: Str) {
        println(loc(), "Error thrown during growth:")
        println(err)
        return
    }

    test(loc(), I64.eq(dyn.len, add(Array.INIT_DYN_CAP, 5)), "Length should be INIT_DYN_CAP + 5")
    test(loc(), gt(dyn.cap, initial_cap), "Capacity should have grown beyond initial")
    test(loc(), I64.eq(dyn.cap, mul(Array.INIT_DYN_CAP, 2)), "Capacity should have doubled")

    // Verify all values are still correct after reallocation
    mut val := 0
    dyn.get(0, val)
    test(loc(), I64.eq(val, 0), "First element should still be 0")
    dyn.get(Array.INIT_DYN_CAP, val)
    test(loc(), I64.eq(val, mul(Array.INIT_DYN_CAP, 10)), "Element after reallocation should be correct")

    dyn.delete()

    catch (err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
test_array_growth()

// Test IndexOutOfBoundsError for get
test_array_get_out_of_bounds := proc() {
    mut arr := Array.new_dyn("I64", size_of(I64))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }

    arr.push(42)
    arr.push(84)
    catch (err: AllocError) { return }
    catch (err: FullError) { return }
    catch (err: Str) { return }

    // Try to get index that's out of bounds
    mut val := 0
    arr.get(10, val)
    panic(loc(), "Expected IndexOutOfBoundsError for get with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for get")
    }

    arr.delete()
}
test_array_get_out_of_bounds()

// Test IndexOutOfBoundsError for set
test_array_set_out_of_bounds := proc() {
    mut arr := Array.new_dyn("I64", size_of(I64))
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }

    arr.push(42)
    catch (err: AllocError) { return }
    catch (err: FullError) { return }
    catch (err: Str) { return }

    // Try to set index that's out of bounds
    arr.set(10, 999)
    panic(loc(), "Expected IndexOutOfBoundsError for set with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for set")
    }

    arr.delete()
}
test_array_set_out_of_bounds()

// Test push on static array throws error
test_array_static_push_error := proc() {
    mut arr := Array.new("I64", size_of(I64), 3)
    catch (err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
        return
    }

    arr.set(0, 10)
    arr.set(1, 20)
    arr.set(2, 30)
    catch (err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown during set:")
        println(err.msg)
        arr.delete()
        return
    }

    // Try to push to static array (should fail)
    arr.push(40)
    panic(loc(), "Expected error when pushing to static array")

    catch (err: Str) {
        test(loc(), true, "Error correctly thrown when pushing to static array")
    }
    catch (err: FullError) {
        test(loc(), true, "FullError correctly thrown when pushing to static array")
    }
    catch (err: AllocError) {
        println(loc(), "Unexpected AllocError")
    }

    arr.delete()
}
test_array_static_push_error()
