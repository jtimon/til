mode test

import("core.vec")

test_array_static_u8 := proc() {
    mut stat := Array.new(U8, 3)
    assert_eq(loc(), 3, stat.len())       // Static array len equals cap
    stat.set(0, U8.from_i64(10)?)?
    stat.set(1, U8.from_i64(20)?)?
    stat.set(2, U8.from_i64(30)?)?
    val := cast(U8, stat.get(2)?)
    test(loc(), U8.from_i64(30)?.eq(val), "Get after set at index 2")

    // Uncomment to test panic behavior
    // stat.push(U8.from_i64(77)) // Should panic

    stat.delete()

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_Overflow) {
        println("ERROR:", loc(), "Unexpected U8_Overflow")
        println(err.msg)
        exit(1)
    }
}
test_array_static_u8()

test_array_static_str := proc() {
    mut stat := Array.new(Str, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, "hello")?
    stat.set(1, "world")?
    stat.set(2, "!")?
    val := cast(Str, stat.get(2)?)
    test(loc(), val.eq("!"), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_str()

test_array_contains := proc() {
    mut arr := Array.new(Str, 3)
    arr.set(0, "apple")?
    arr.set(1, "banana")?
    arr.set(2, "cherry")?

    test(loc(), arr.contains("apple"), "contains finds first element")
    test(loc(), arr.contains("banana"), "contains finds middle element")
    test(loc(), arr.contains("cherry"), "contains finds last element")
    test(loc(), not(arr.contains("grape")), "contains returns false for missing element")
    test(loc(), not(arr.contains("")), "contains returns false for empty string")

    arr.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_contains()

test_array_static_bool := proc() {
    mut stat := Array.new(Bool, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, true)?
    stat.set(1, false)?
    stat.set(2, true)?
    val := cast(Bool, stat.get(2)?)
    test(loc(), val.eq(true), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_bool()

test_array_static_i64 := proc() {
    mut stat := Array.new(I64, 3)
    assert_eq(loc(), 3, stat.len())

    stat.set(0, 100)?
    stat.set(1, 200)?
    stat.set(2, 300)?
    val := cast(I64, stat.get(2)?)
    test(loc(), val.eq(300), "Get after set at index 2")

    stat.delete()

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_array_static_vec2 := proc() {
    mut stat := Array.new(Vec2, 3)
    assert_eq(loc(), 3, stat.len())

    v1 := Vec2(x=1, y=2)
    v2 := Vec2(x=3, y=4)
    v3 := Vec2(x=5, y=6)
    stat.set(0, v1)?
    stat.set(1, v2)?
    stat.set(2, v3)?

    v := cast(Vec2, stat.get(2)?)
    assert_eq(loc(), 5, v.x)
    assert_eq(loc(), 6, v.y)

    // stat.push(Vec2.new(7, 8)) // Should panic if uncommented

    stat.delete()

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_array_static_vec2()

// Test push on static array removed - Array.push no longer exists
// Use Vec for dynamic arrays instead
