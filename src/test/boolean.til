mode test

// ============================================================
// Bool.and - binary method in Bool struct namespace
// ============================================================

test(loc(), true.and(true), "Bool.and: true.and(true) == true")
test(loc(), not(true.and(false)), "Bool.and: true.and(false) == false")
test(loc(), not(false.and(true)), "Bool.and: false.and(true) == false")
test(loc(), not(false.and(false)), "Bool.and: false.and(false) == false")

// ============================================================
// and - variadic standalone function
// ============================================================

test(loc(), and(true), "and: and(true) == true")
test(loc(), not(and(false)), "and: and(false) == false")
test(loc(), and(true, true), "and: and(true, true) == true")
test(loc(), not(and(true, false)), "and: and(true, false) == false")
test(loc(), and(true, true, true), "and: and(true, true, true) == true")
test(loc(), not(and(true, false, true)), "and: and(true, false, true) == false")
test(loc(), not(and(false, false, false)), "and: and(false, false, false) == false")

// ============================================================
// Bool.or - binary method in Bool struct namespace
// ============================================================

test(loc(), true.or(true), "Bool.or: true.or(true) == true")
test(loc(), true.or(false), "Bool.or: true.or(false) == true")
test(loc(), false.or(true), "Bool.or: false.or(true) == true")
test(loc(), not(false.or(false)), "Bool.or: false.or(false) == false")

// ============================================================
// or - variadic standalone function
// ============================================================

test(loc(), or(true), "or: or(true) == true")
test(loc(), not(or(false)), "or: or(false) == false")
test(loc(), or(true, true), "or: or(true, true) == true")
test(loc(), or(true, false), "or: or(true, false) == true")
test(loc(), or(false, false, true), "or: or(false, false, true) == true")
test(loc(), not(or(false, false, false)), "or: or(false, false, false) == false")

// ============================================================
// not - unary standalone function
// ============================================================

test(loc(), true, "not: true is true")
test(loc(), not(false), "not: not(false) == true")
test(loc(), not(not(true)), "not: not(not(true)) == true")

// ============================================================
// xor - binary standalone function
// ============================================================

test(loc(), xor(true, false), "xor: xor(true, false) == true")
test(loc(), xor(false, true), "xor: xor(false, true) == true")
test(loc(), not(xor(true, true)), "xor: xor(true, true) == false")
test(loc(), not(xor(false, false)), "xor: xor(false, false) == false")

// ============================================================
// xnor - binary standalone function
// ============================================================

test(loc(), not(xnor(true, false)), "xnor: xnor(true, false) == false")
test(loc(), not(xnor(false, true)), "xnor: xnor(false, true) == false")
test(loc(), xnor(true, true), "xnor: xnor(true, true) == true")
test(loc(), xnor(false, false), "xnor: xnor(false, false) == true")

// ============================================================
// Bool.eq - binary method (equivalent to xnor)
// ============================================================

test(loc(), not(true.eq(false)), "Bool.eq: true.eq(false) == false")
test(loc(), not(false.eq(true)), "Bool.eq: false.eq(true) == false")
test(loc(), true.eq(true), "Bool.eq: true.eq(true) == true")
test(loc(), false.eq(false), "Bool.eq: false.eq(false) == true")

// ============================================================
// Bool.to_i64 - conversion to integer
// ============================================================

test(loc(), true.to_i64().eq(1), "Bool.to_i64: true.to_i64() == 1")
test(loc(), false.to_i64().eq(0), "Bool.to_i64: false.to_i64() == 0")

// ============================================================
// Bool.to_str - conversion to string
// ============================================================

test(loc(), true.to_str().eq("true"), "Bool.to_str: true.to_str() == 'true'")
test(loc(), false.to_str().eq("false"), "Bool.to_str: false.to_str() == 'false'")

// ============================================================
// I64 bitwise operations
// ============================================================

test_i64_bitwise := proc() {
    // XOR tests
    test(loc(), I64.xor(0, 0).eq(0), "I64: 0 XOR 0 = 0")
    test(loc(), I64.xor(1, 0).eq(1), "I64: 1 XOR 0 = 1")
    test(loc(), I64.xor(0, 1).eq(1), "I64: 0 XOR 1 = 1")
    test(loc(), I64.xor(1, 1).eq(0), "I64: 1 XOR 1 = 0")
    test(loc(), I64.xor(12, 10).eq(6), "I64: 12 XOR 10 = 6 (1100 XOR 1010 = 0110)")
    test(loc(), I64.xor(255, 15).eq(240), "I64: 255 XOR 15 = 240")

    // AND tests
    test(loc(), I64.and(0, 0).eq(0), "I64: 0 AND 0 = 0")
    test(loc(), I64.and(1, 0).eq(0), "I64: 1 AND 0 = 0")
    test(loc(), I64.and(0, 1).eq(0), "I64: 0 AND 1 = 0")
    test(loc(), I64.and(1, 1).eq(1), "I64: 1 AND 1 = 1")
    test(loc(), I64.and(12, 10).eq(8), "I64: 12 AND 10 = 8 (1100 AND 1010 = 1000)")
    test(loc(), I64.and(255, 15).eq(15), "I64: 255 AND 15 = 15")
    test(loc(), I64.and(16, 15).eq(0), "I64: 16 AND 15 = 0 (power of 2 mask)")

    // OR tests
    test(loc(), I64.or(0, 0).eq(0), "I64: 0 OR 0 = 0")
    test(loc(), I64.or(1, 0).eq(1), "I64: 1 OR 0 = 1")
    test(loc(), I64.or(0, 1).eq(1), "I64: 0 OR 1 = 1")
    test(loc(), I64.or(1, 1).eq(1), "I64: 1 OR 1 = 1")
    test(loc(), I64.or(12, 10).eq(14), "I64: 12 OR 10 = 14 (1100 OR 1010 = 1110)")
    test(loc(), I64.or(255, 15).eq(255), "I64: 255 OR 15 = 255")
}
test_i64_bitwise()

// ============================================================
// U8 bitwise operations
// ============================================================

test_u8_bitwise := proc() {
    u8_0 : U8 = 0
    u8_1 : U8 = 1
    u8_6 : U8 = 6
    u8_8 : U8 = 8
    u8_10 : U8 = 10
    u8_12 : U8 = 12
    u8_14 : U8 = 14
    u8_15 : U8 = 15
    u8_16 : U8 = 16
    u8_240 : U8 = 240
    u8_255 : U8 = 255

    // XOR tests
    test(loc(), U8.xor(u8_0, u8_0).eq(u8_0), "U8: 0 XOR 0 = 0")
    test(loc(), U8.xor(u8_1, u8_0).eq(u8_1), "U8: 1 XOR 0 = 1")
    test(loc(), U8.xor(u8_0, u8_1).eq(u8_1), "U8: 0 XOR 1 = 1")
    test(loc(), U8.xor(u8_1, u8_1).eq(u8_0), "U8: 1 XOR 1 = 0")
    test(loc(), U8.xor(u8_12, u8_10).eq(u8_6), "U8: 12 XOR 10 = 6")
    test(loc(), U8.xor(u8_255, u8_15).eq(u8_240), "U8: 255 XOR 15 = 240")

    // AND tests
    test(loc(), U8.and(u8_0, u8_0).eq(u8_0), "U8: 0 AND 0 = 0")
    test(loc(), U8.and(u8_1, u8_0).eq(u8_0), "U8: 1 AND 0 = 0")
    test(loc(), U8.and(u8_0, u8_1).eq(u8_0), "U8: 0 AND 1 = 0")
    test(loc(), U8.and(u8_1, u8_1).eq(u8_1), "U8: 1 AND 1 = 1")
    test(loc(), U8.and(u8_12, u8_10).eq(u8_8), "U8: 12 AND 10 = 8")
    test(loc(), U8.and(u8_255, u8_15).eq(u8_15), "U8: 255 AND 15 = 15")
    test(loc(), U8.and(u8_16, u8_15).eq(u8_0), "U8: 16 AND 15 = 0")

    // OR tests
    test(loc(), U8.or(u8_0, u8_0).eq(u8_0), "U8: 0 OR 0 = 0")
    test(loc(), U8.or(u8_1, u8_0).eq(u8_1), "U8: 1 OR 0 = 1")
    test(loc(), U8.or(u8_0, u8_1).eq(u8_1), "U8: 0 OR 1 = 1")
    test(loc(), U8.or(u8_1, u8_1).eq(u8_1), "U8: 1 OR 1 = 1")
    test(loc(), U8.or(u8_12, u8_10).eq(u8_14), "U8: 12 OR 10 = 14")
    test(loc(), U8.or(u8_255, u8_15).eq(u8_255), "U8: 255 OR 15 = 255")
}
test_u8_bitwise()
