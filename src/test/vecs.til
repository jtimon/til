mode test

import("src.core.vec")

test_vec_u8 := proc() {
    mut dyn := Vec.new(U8)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(U8.from_i64(42))
    dyn.push(U8.from_i64(255))
    assert_eq(loc(), 2, dyn.len())
    mut val0 := U8.from_i64(0)
    dyn.get(0, val0)
    test(loc(), val0.eq(U8.from_i64(42)), "Value at index 0")
    mut val1 := U8.from_i64(0)
    dyn.get(1, val1)
    test(loc(), val1.eq(U8.from_i64(255)), "Value at index 1")

    dyn.set(0, U8.from_i64(99))
    mut val := U8.from_i64(0)
    dyn.get(0, val)
    test(loc(), val.eq(U8.from_i64(99)), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_OverflowError) {
        println("ERROR:", loc(), "Unexpected U8_OverflowError")
        println(err.msg)
        exit(1)
    }
}
test_vec_u8()

test_vec_str := proc() {
    mut dyn := Vec.new(Str)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push("foo")
    dyn.push("bar")
    assert_eq(loc(), 2, dyn.len())
    mut val0 := ""
    dyn.get(0, val0)
    test(loc(), val0.eq("foo"), "Value at index 0")
    mut val1 := ""
    dyn.get(1, val1)
    test(loc(), val1.eq("bar"), "Value at index 1")

    dyn.set(0, "baz")
    mut val := ""
    dyn.get(0, val)
    test(loc(), val.eq("baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    mut dyn_len := dyn.len()
    for i in 0..dyn_len {
        mut s := ""
        dyn.get(i, s)
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr) // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }
}
test_vec_str()

test_vec_bool := proc() {
    mut dyn := Vec.new(Bool)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(true)
    dyn.push(false)
    assert_eq(loc(), 2, dyn.len())
    mut val0 := false
    dyn.get(0, val0)
    test(loc(), val0.eq(true), "Value at index 0")
    mut val1 := false
    dyn.get(1, val1)
    test(loc(), val1.eq(false), "Value at index 1")

    dyn.set(0, false)
    mut val := false
    dyn.get(0, val)
    test(loc(), val.eq(false), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_bool()

test_vec_i64 := proc() {
    mut dyn := Vec.new(I64)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(42)
    dyn.push(84)
    assert_eq(loc(), 2, dyn.len())
    mut val0 := 0
    dyn.get(0, val0)
    test(loc(), val0.eq(42), "Value at index 0")
    mut val1 := 0
    dyn.get(1, val1)
    test(loc(), val1.eq(84), "Value at index 1")

    dyn.set(0, 123)
    mut val := 0
    dyn.get(0, val)
    test(loc(), val.eq(123), "Set and get index 0")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    new := func(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }
}

test_vec_vec2 := proc() {
    mut dyn := Vec.new(Vec2) // TODO More ergonomic constructor
    assert_eq(loc(), 0, dyn.len())

    v1 := Vec2.new(10, 20)
    dyn.push(v1)
    v2 := Vec2.new(30, 40)
    dyn.push(v2)

    assert_eq(loc(), 2, dyn.len())

    mut v0 := Vec2()
    dyn.get(0, v0)
    test(loc(), v0.x.eq(10), "v0.x should be 10")
    test(loc(), v0.y.eq(20), "v0.y should be 20")

    v3 := Vec2.new(50, 60)
    dyn.set(0, v3)

    mut v_after_set := Vec2()
    dyn.get(0, v_after_set)
    test(loc(), v_after_set.x.eq(50), "v_after_set.x should be 50")
    test(loc(), v_after_set.y.eq(60), "v_after_set.y should be 60")

    dyn.delete()
    assert_eq(loc(), 0, dyn.ptr)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_vec2()

// Test Array growth/reallocation beyond initial capacity
test_vec_growth := proc() {
    mut dyn := Vec.new(I64)

    initial_cap := dyn.cap
    test(loc(), initial_cap.eq(Vec.INIT_CAP), "Initial capacity should be INIT_DYN_CAP")

    // Push elements beyond initial capacity to trigger reallocation
    mut i := 0
    while lt(i, add(Vec.INIT_CAP, 5)) {
        dyn.push(mul(i, 10))
        i = add(i, 1)
    }

    test(loc(), dyn.len().eq(add(Vec.INIT_CAP, 5)), "Length should be INIT_DYN_CAP + 5")
    test(loc(), gt(dyn.cap, initial_cap), "Capacity should have grown beyond initial")
    test(loc(), dyn.cap.eq(mul(Vec.INIT_CAP, 2)), "Capacity should have doubled")

    // Verify all values are still correct after reallocation
    mut val := 0
    dyn.get(0, val)
    test(loc(), val.eq(0), "First element should still be 0")
    dyn.get(Vec.INIT_CAP, val)
    test(loc(), val.eq(mul(Vec.INIT_CAP, 10)), "Element after reallocation should be correct")

    dyn.delete()

    // Catch unexpected errors at end
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_growth()

// Test IndexOutOfBoundsError for get
test_vec_get_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)
    arr.push(84)

    // Try to get index that's out of bounds
    mut val := 0
    arr.get(10, val)
    panic(loc(), "Expected IndexOutOfBoundsError for get with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for get")
    }

    arr.delete()

    // Catch unexpected errors at end
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_vec_get_out_of_bounds()

// Test IndexOutOfBoundsError for set
test_vec_set_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)

    // Try to set index that's out of bounds
    arr.set(10, 999)
    panic(loc(), "Expected IndexOutOfBoundsError for set with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for set")
    }

    arr.delete()

    // Catch unexpected errors at end
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_vec_set_out_of_bounds()

test_vec_pop := proc() {
    mut stack := Vec.new(I64)

    // Push some values
    stack.push(10)
    stack.push(20)
    stack.push(30)

    assert_eq(loc(), 3, stack.len())

    // Pop values in LIFO order
    mut val := 0
    stack.pop(val)
    assert_eq(loc(), 30, val)
    assert_eq(loc(), 2, stack.len())

    stack.pop(val)
    assert_eq(loc(), 20, val)
    assert_eq(loc(), 1, stack.len())

    stack.pop(val)
    assert_eq(loc(), 10, val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty Vec - should throw
    stack.pop(val)
    catch (err: IndexOutOfBoundsError) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown IndexOutOfBoundsError")
    exit(1)

    // Catch unexpected errors at end
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_vec_pop()
