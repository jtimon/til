mode test

import("core.vec")

test_vec_u8 := proc() {
    mut dyn := Vec.new(U8)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(U8.from_i64(42)?)
    dyn.push(U8.from_i64(255)?)
    assert_eq(loc(), 2, dyn.len())
    mut val0 := U8.from_i64(0)?
    dyn.get(0, val0)?
    test(loc(), val0.eq(U8.from_i64(42)?), "Value at index 0")
    mut val1 := U8.from_i64(0)?
    dyn.get(1, val1)?
    test(loc(), val1.eq(U8.from_i64(255)?), "Value at index 1")

    dyn.set(0, U8.from_i64(99)?)?
    mut val := U8.from_i64(0)?
    dyn.get(0, val)?
    test(loc(), val.eq(U8.from_i64(99)?), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_Overflow) {
        println("ERROR:", loc(), "Unexpected U8_Overflow")
        println(err.msg)
        exit(1)
    }
}
test_vec_u8()

test_vec_str := proc() {
    mut dyn := Vec.new(Str)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push("foo")
    dyn.push("bar")
    assert_eq(loc(), 2, dyn.len())
    mut val0 := ""
    dyn.get(0, val0)?
    test(loc(), val0.eq("foo"), "Value at index 0")
    mut val1 := ""
    dyn.get(1, val1)?
    test(loc(), val1.eq("bar"), "Value at index 1")

    dyn.set(0, "baz")?
    mut val := ""
    dyn.get(0, val)?
    test(loc(), val.eq("baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    mut dyn_len := dyn.len()
    for i in 0..dyn_len {
        mut s := ""
        dyn.get(i, s)?
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_str()

test_vec_bool := proc() {
    mut dyn := Vec.new(Bool)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(true)
    dyn.push(false)
    assert_eq(loc(), 2, dyn.len())
    mut val0 := false
    dyn.get(0, val0)?
    test(loc(), val0.eq(true), "Value at index 0")
    mut val1 := false
    dyn.get(1, val1)?
    test(loc(), val1.eq(false), "Value at index 1")

    dyn.set(0, false)?
    mut val := false
    dyn.get(0, val)?
    test(loc(), val.eq(false), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_bool()

test_vec_i64 := proc() {
    mut dyn := Vec.new(I64)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(42)
    dyn.push(84)
    assert_eq(loc(), 2, dyn.len())
    mut val0 := 0
    dyn.get(0, val0)?
    test(loc(), val0.eq(42), "Value at index 0")
    mut val1 := 0
    dyn.get(1, val1)?
    test(loc(), val1.eq(84), "Value at index 1")

    dyn.set(0, 123)?
    mut val := 0
    dyn.get(0, val)?
    test(loc(), val.eq(123), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_vec_vec2 := proc() {
    mut dyn := Vec.new(Vec2) // TODO More ergonomic constructor
    assert_eq(loc(), 0, dyn.len())

    v1 := Vec2(x=10, y=20)
    dyn.push(v1)
    v2 := Vec2(x=30, y=40)
    dyn.push(v2)

    assert_eq(loc(), 2, dyn.len())

    mut v0 := Vec2()
    dyn.get(0, v0)?
    test(loc(), v0.x.eq(10), "v0.x should be 10")
    test(loc(), v0.y.eq(20), "v0.y should be 20")

    v3 := Vec2(x=50, y=60)
    dyn.set(0, v3)?

    mut v_after_set := Vec2()
    dyn.get(0, v_after_set)?
    test(loc(), v_after_set.x.eq(50), "v_after_set.x should be 50")
    test(loc(), v_after_set.y.eq(60), "v_after_set.y should be 60")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_vec2()

// Test Array growth/reallocation beyond initial capacity
test_vec_growth := proc() {
    mut dyn := Vec.new(I64)

    initial_cap := dyn.cap
    test(loc(), initial_cap.eq(Vec.INIT_CAP), "Initial capacity should be INIT_DYN_CAP")

    // Push elements beyond initial capacity to trigger reallocation
    mut i := 0
    while lt(i, add(Vec.INIT_CAP, 5)) {
        dyn.push(mul(i, 10))
        i = add(i, 1)
    }

    test(loc(), dyn.len().eq(add(Vec.INIT_CAP, 5)), "Length should be INIT_DYN_CAP + 5")
    test(loc(), gt(dyn.cap, initial_cap), "Capacity should have grown beyond initial")
    test(loc(), dyn.cap.gteq(add(Vec.INIT_CAP, 5)), "Capacity should be at least len")

    // Verify all values are still correct after reallocation
    mut val := 0
    dyn.get(0, val)?
    test(loc(), val.eq(0), "First element should still be 0")
    dyn.get(Vec.INIT_CAP, val)?
    test(loc(), val.eq(mul(Vec.INIT_CAP, 10)), "Element after reallocation should be correct")

    dyn.delete()

    // Catch unexpected errors at end
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_growth()

// Test OutOfBounds for get
test_vec_get_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)
    arr.push(84)

    // Try to get index that's out of bounds
    mut val := 0
    arr.get(10, val)?
    panic(loc(), "Expected OutOfBounds for get with invalid index")

    catch (err: OutOfBounds) {
        test(loc(), true, "OutOfBounds correctly thrown for get")
    }

    arr.delete()

}
test_vec_get_out_of_bounds()

// Test OutOfBounds for set
test_vec_set_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)

    // Try to set index that's out of bounds
    arr.set(10, 999)?
    panic(loc(), "Expected OutOfBounds for set with invalid index")

    catch (err: OutOfBounds) {
        test(loc(), true, "OutOfBounds correctly thrown for set")
    }

    arr.delete()

}
test_vec_set_out_of_bounds()

test_vec_pop := proc() {
    mut stack := Vec.new(I64)

    // Push some values
    stack.push(10)
    stack.push(20)
    stack.push(30)

    assert_eq(loc(), 3, stack.len())

    // Pop values in LIFO order
    mut val := 0
    stack.pop(val)?
    assert_eq(loc(), 30, val)
    assert_eq(loc(), 2, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 20, val)
    assert_eq(loc(), 1, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 10, val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty Vec - should throw
    stack.pop(val)?
    catch (err: OutOfBounds) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown OutOfBounds")
    exit(1)

}
test_vec_pop()

test_vec_extend := proc() {
    mut dest := Vec.new(I64)
    dest.push(1)
    dest.push(2)

    mut src := Vec.new(I64)
    src.push(3)
    src.push(4)
    src.push(5)

    assert_eq(loc(), 2, dest.len())
    assert_eq(loc(), 3, src.len())

    dest.extend(src)

    assert_eq(loc(), 5, dest.len())
    assert_eq(loc(), 3, src.len()) // src should be unchanged

    // Verify all values
    mut val := 0
    dest.get(0, val)?
    assert_eq(loc(), 1, val)
    dest.get(1, val)?
    assert_eq(loc(), 2, val)
    dest.get(2, val)?
    assert_eq(loc(), 3, val)
    dest.get(3, val)?
    assert_eq(loc(), 4, val)
    dest.get(4, val)?
    assert_eq(loc(), 5, val)

    dest.delete()
    src.delete()

    // Catch unexpected errors at end
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend()

test_vec_extend_empty := proc() {
    mut dest := Vec.new(Str)
    dest.push("a")
    dest.push("b")

    mut empty := Vec.new(Str)

    dest.extend(empty) // Extending with empty vec should be no-op

    assert_eq(loc(), 2, dest.len())

    mut val := ""
    dest.get(0, val)?
    assert_eq_str(loc(), "a", val)
    dest.get(1, val)?
    assert_eq_str(loc(), "b", val)

    dest.delete()
    empty.delete()

    // Catch unexpected errors at end
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend_empty()

test_vec_remove := proc() {
    mut vec := Vec.new(I64)
    vec.push(10)
    vec.push(20)
    vec.push(30)
    vec.push(40)

    assert_eq(loc(), 4, vec.len())

    // Remove middle element (index 1 = value 20)
    vec.remove(1)?

    assert_eq(loc(), 3, vec.len())

    mut val := 0
    vec.get(0, val)?
    assert_eq(loc(), 10, val)
    vec.get(1, val)?
    assert_eq(loc(), 30, val) // 30 shifted to index 1
    vec.get(2, val)?
    assert_eq(loc(), 40, val) // 40 shifted to index 2

    // Remove first element
    vec.remove(0)?

    assert_eq(loc(), 2, vec.len())
    vec.get(0, val)?
    assert_eq(loc(), 30, val)
    vec.get(1, val)?
    assert_eq(loc(), 40, val)

    // Remove last element
    vec.remove(1)?

    assert_eq(loc(), 1, vec.len())
    vec.get(0, val)?
    assert_eq(loc(), 30, val)

    vec.delete()

    // Catch unexpected errors at end
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_remove()

test_vec_remove_out_of_bounds := proc() {
    mut vec := Vec.new(I64)
    vec.push(42)

    // Try to remove index that's out of bounds
    vec.remove(5)?
    panic(loc(), "Expected OutOfBounds for remove with invalid index")

    catch (err: OutOfBounds) {
        test(loc(), true, "OutOfBounds correctly thrown for remove")
    }

    vec.delete()

}
test_vec_remove_out_of_bounds()

test_vec_contains := proc() {
    // Test with I64
    mut nums := Vec.new(I64)
    nums.push(10)
    nums.push(20)
    nums.push(30)

    test(loc(), nums.contains(10), "contains should find 10")
    test(loc(), nums.contains(20), "contains should find 20")
    test(loc(), nums.contains(30), "contains should find 30")
    test(loc(), not(nums.contains(15)), "contains should not find 15")
    test(loc(), not(nums.contains(0)), "contains should not find 0")

    nums.delete()

    // Test with Str
    mut strs := Vec.new(Str)
    strs.push("foo")
    strs.push("bar")
    strs.push("baz")

    test(loc(), strs.contains("foo"), "contains should find foo")
    test(loc(), strs.contains("bar"), "contains should find bar")
    test(loc(), strs.contains("baz"), "contains should find baz")
    test(loc(), not(strs.contains("qux")), "contains should not find qux")
    test(loc(), not(strs.contains("")), "contains should not find empty string")

    strs.delete()

    // Test empty vec
    mut empty := Vec.new(I64)
    test(loc(), not(empty.contains(42)), "contains on empty vec should return false")
    empty.delete()

}
test_vec_contains()

// Bug #37/#38 regression test: Vec with enums
// Bug #37: Vec.push with direct enum constructor was reported to not store data correctly
// Bug #38: Vec.get was reported to not preserve enum payload values
// Both turned out to be false positives or were fixed by other bugfixes.
SimpleColor := enum { Red, Green, Blue }

PayloadEnum := enum {
    None,
    Number: I64,
}

test_vec_enum_direct_push := proc() {
    // Bug #37: Test that direct enum constructor push works
    mut colors := Vec.new(SimpleColor)

    // Push via variable (always worked)
    c := SimpleColor.Red
    colors.push(c)

    // Push directly (Bug #37 claimed this failed)
    colors.push(SimpleColor.Green)
    colors.push(SimpleColor.Blue)

    assert_eq(loc(), 3, colors.len())

    mut out := SimpleColor.Red
    colors.get(0, out)?
    switch out {
    case SimpleColor.Red: test(loc(), true, "colors[0] should be Red")
    case: test(loc(), false, "colors[0] should be Red")
    }

    colors.get(1, out)?
    switch out {
    case SimpleColor.Green: test(loc(), true, "colors[1] should be Green")
    case: test(loc(), false, "colors[1] should be Green")
    }

    colors.get(2, out)?
    switch out {
    case SimpleColor.Blue: test(loc(), true, "colors[2] should be Blue")
    case: test(loc(), false, "colors[2] should be Blue")
    }

    colors.delete()

    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
// Bug #37 test - should fail until bug is fixed
test_vec_enum_direct_push()

test_vec_enum_payload := proc() {
    // Bug #38: Test that enum payloads are preserved through Vec storage
    mut items := Vec.new(PayloadEnum)

    p1 := PayloadEnum.Number(42)
    items.push(p1)

    p2 := PayloadEnum.Number(100)
    items.push(p2)

    items.push(PayloadEnum.None)

    assert_eq(loc(), 3, items.len())

    mut result := PayloadEnum.None
    items.get(0, result)?
    switch result {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 42, n)
    case PayloadEnum.None:
        test(loc(), false, "items[0] should be Number(42), got None")
    }

    items.get(1, result)?
    switch result {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 100, n)
    case PayloadEnum.None:
        test(loc(), false, "items[1] should be Number(100), got None")
    }

    items.get(2, result)?
    switch result {
    case PayloadEnum.None:
        test(loc(), true, "items[2] should be None")
    case PayloadEnum.Number(n):
        test(loc(), false, "items[2] should be None, got Number")
    }

    items.delete()

    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_enum_payload()

test_vec_with_capacity := proc() {
    // Test with_capacity creates vec with pre-allocated memory
    mut vec := Vec.with_capacity(I64, 10)

    assert_eq(loc(), 0, vec.len())
    assert_eq(loc(), 10, vec.cap)
    test(loc(), not(vec.ptr.is_null()), "ptr should be allocated")

    // Push elements without triggering reallocation
    mut i := 0
    while i.lt(10) {
        vec.push(i)
        i = i.add(1)
    }

    assert_eq(loc(), 10, vec.len())
    assert_eq(loc(), 10, vec.cap) // Should not have grown

    // Verify values
    mut val := 0
    vec.get(0, val)?
    assert_eq(loc(), 0, val)
    vec.get(9, val)?
    assert_eq(loc(), 9, val)

    // Push one more to trigger growth
    vec.push(100)
    assert_eq(loc(), 11, vec.len())
    test(loc(), vec.cap.gt(10), "cap should have grown")

    vec.delete()

    // Test with_capacity(0) behaves like new()
    mut empty := Vec.with_capacity(Str, 0)
    assert_eq(loc(), 0, empty.len())
    assert_eq(loc(), 0, empty.cap)
    test(loc(), empty.ptr.is_null(), "Empty vec ptr is null")

    empty.push("hello")
    assert_eq(loc(), 1, empty.len())
    test(loc(), empty.cap.gteq(1), "cap should be at least 1")

    empty.delete()

    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_with_capacity()

test_sort_str_vec := proc() {
    mut variants := Vec.new(Str)
    variants.push("zebra")
    variants.push("apple")
    variants.push("banana")
    variants.push("cherry")

    sort_str_vec(variants)

    // Verify sorted order
    mut v0 := ""
    mut v1 := ""
    mut v2 := ""
    mut v3 := ""
    variants.get(0, v0)?
    variants.get(1, v1)?
    variants.get(2, v2)?
    variants.get(3, v3)?

    assert_eq_str(loc(), "apple", v0)
    assert_eq_str(loc(), "banana", v1)
    assert_eq_str(loc(), "cherry", v2)
    assert_eq_str(loc(), "zebra", v3)

    variants.delete()

    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_sort_str_vec()

test_vec_insert_at := proc() {
    // Test insert_at with I64
    mut vec := Vec.new(I64)
    vec.push(10)
    vec.push(30)
    vec.push(40)

    assert_eq(loc(), 3, vec.len())

    // Insert at middle (index 1)
    vec.insert_at(1, 20)?

    assert_eq(loc(), 4, vec.len())

    mut val := 0
    vec.get(0, val)?
    assert_eq(loc(), 10, val)
    vec.get(1, val)?
    assert_eq(loc(), 20, val) // Newly inserted
    vec.get(2, val)?
    assert_eq(loc(), 30, val) // Shifted right
    vec.get(3, val)?
    assert_eq(loc(), 40, val) // Shifted right

    // Insert at beginning (index 0)
    vec.insert_at(0, 5)?

    assert_eq(loc(), 5, vec.len())
    vec.get(0, val)?
    assert_eq(loc(), 5, val)
    vec.get(1, val)?
    assert_eq(loc(), 10, val)

    // Insert at end (index = len)
    vec.insert_at(5, 50)?

    assert_eq(loc(), 6, vec.len())
    vec.get(5, val)?
    assert_eq(loc(), 50, val)

    vec.delete()

    // Test insert_at with Str
    mut strs := Vec.new(Str)
    strs.push("a")
    strs.push("c")

    strs.insert_at(1, "b")?

    assert_eq(loc(), 3, strs.len())

    mut s := ""
    strs.get(0, s)?
    assert_eq_str(loc(), "a", s)
    strs.get(1, s)?
    assert_eq_str(loc(), "b", s)
    strs.get(2, s)?
    assert_eq_str(loc(), "c", s)

    strs.delete()

    // Test insert_at on empty vec
    mut empty := Vec.new(I64)
    empty.insert_at(0, 42)?
    assert_eq(loc(), 1, empty.len())
    empty.get(0, val)?
    assert_eq(loc(), 42, val)
    empty.delete()

    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_vec_insert_at()

test_vec_insert_at_out_of_bounds := proc() {
    mut vec := Vec.new(I64)
    vec.push(42)

    // Try to insert at index > len (should throw)
    vec.insert_at(5, 999)?
    panic(loc(), "Expected OutOfBounds for insert_at with invalid index")

    catch (err: OutOfBounds) {
        test(loc(), true, "OutOfBounds correctly thrown for insert_at")
    }

    vec.delete()

}
test_vec_insert_at_out_of_bounds()
