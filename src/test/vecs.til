mode test

import("core.vec")

test_vec_u8 := proc() {
    mut dyn := Vec.new(U8)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(U8.from_i64(42)?)
    dyn.push(U8.from_i64(255)?)
    assert_eq(loc(), 2, dyn.len())
    val0_ref := dyn.get_by_ref(0)?
    create_alias(val0, U8, val0_ref.data)
    test(loc(), val0.eq(U8.from_i64(42)?), "Value at index 0")
    val1_ref := dyn.get_by_ref(1)?
    create_alias(val1, U8, val1_ref.data)
    test(loc(), val1.eq(U8.from_i64(255)?), "Value at index 1")

    dyn.set(0, U8.from_i64(99)?)?
    val_ref := dyn.get_by_ref(0)?
    create_alias(val, U8, val_ref.data)
    test(loc(), val.eq(U8.from_i64(99)?), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_Overflow) {
        println("ERROR:", loc(), "Unexpected U8_Overflow")
        println(err.msg)
        exit(1)
    }
}
test_vec_u8()

test_vec_str := proc() {
    mut dyn := Vec.new(Str)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push("foo")
    dyn.push("bar")
    assert_eq(loc(), 2, dyn.len())
    val0_ref := dyn.get_by_ref(0)?
    create_alias(val0, Str, val0_ref.data)
    test(loc(), val0.eq("foo"), "Value at index 0")
    val1_ref := dyn.get_by_ref(1)?
    create_alias(val1, Str, val1_ref.data)
    test(loc(), val1.eq("bar"), "Value at index 1")

    dyn.set(0, "baz")?
    val_ref := dyn.get_by_ref(0)?
    create_alias(val, Str, val_ref.data)
    test(loc(), val.eq("baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    mut dyn_len := dyn.len()
    for i in 0..dyn_len {
        s_ref := dyn.get_by_ref(i)?
        create_alias(s, Str, s_ref.data)
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_str()

test_vec_bool := proc() {
    mut dyn := Vec.new(Bool)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(true)
    dyn.push(false)
    assert_eq(loc(), 2, dyn.len())
    val0_ref := dyn.get_by_ref(0)?
    create_alias(val0, Bool, val0_ref.data)
    test(loc(), val0.eq(true), "Value at index 0")
    val1_ref := dyn.get_by_ref(1)?
    create_alias(val1, Bool, val1_ref.data)
    test(loc(), val1.eq(false), "Value at index 1")

    dyn.set(0, false)?
    val_ref := dyn.get_by_ref(0)?
    create_alias(val, Bool, val_ref.data)
    test(loc(), val.eq(false), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_bool()

test_vec_i64 := proc() {
    mut dyn := Vec.new(I64)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(42)
    dyn.push(84)
    assert_eq(loc(), 2, dyn.len())
    val0_ref := dyn.get_by_ref(0)?
    create_alias(val0, I64, val0_ref.data)
    test(loc(), val0.eq(42), "Value at index 0")
    val1_ref := dyn.get_by_ref(1)?
    create_alias(val1, I64, val1_ref.data)
    test(loc(), val1.eq(84), "Value at index 1")

    dyn.set(0, 123)?
    val_ref := dyn.get_by_ref(0)?
    create_alias(val, I64, val_ref.data)
    test(loc(), val.eq(123), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_vec_vec2 := proc() {
    mut dyn := Vec.new(Vec2) // TODO More ergonomic constructor
    assert_eq(loc(), 0, dyn.len())

    v1 := Vec2(x=10, y=20)
    dyn.push(v1)
    v2 := Vec2(x=30, y=40)
    dyn.push(v2)

    assert_eq(loc(), 2, dyn.len())

    v0_ref := dyn.get_by_ref(0)?
    create_alias(v0, Vec2, v0_ref.data)
    test(loc(), v0.x.eq(10), "v0.x should be 10")
    test(loc(), v0.y.eq(20), "v0.y should be 20")

    v3 := Vec2(x=50, y=60)
    dyn.set(0, v3)?

    v_after_set_ref := dyn.get_by_ref(0)?
    create_alias(v_after_set, Vec2, v_after_set_ref.data)
    test(loc(), v_after_set.x.eq(50), "v_after_set.x should be 50")
    test(loc(), v_after_set.y.eq(60), "v_after_set.y should be 60")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_vec2()

// Test Array growth/reallocation beyond initial capacity
test_vec_growth := proc() {
    mut dyn := Vec.new(I64)

    initial_cap := dyn.cap
    test(loc(), initial_cap.eq(Vec.INIT_CAP), "Initial capacity should be INIT_DYN_CAP")

    // Push elements beyond initial capacity to trigger reallocation
    mut i := 0
    while lt(i, add(Vec.INIT_CAP, 5)) {
        dyn.push(mul(i, 10))
        i = add(i, 1)
    }

    test(loc(), dyn.len().eq(add(Vec.INIT_CAP, 5)), "Length should be INIT_DYN_CAP + 5")
    test(loc(), gt(dyn.cap, initial_cap), "Capacity should have grown beyond initial")
    test(loc(), dyn.cap.gteq(add(Vec.INIT_CAP, 5)), "Capacity should be at least len")

    // Verify all values are still correct after reallocation
    val_0_ref := dyn.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    test(loc(), val_0.eq(0), "First element should still be 0")
    val_1_ref := dyn.get_by_ref(Vec.INIT_CAP)?
    create_alias(val_1, I64, val_1_ref.data)
    test(loc(), val_1.eq(mul(Vec.INIT_CAP, 10)), "Element after reallocation should be correct")

    dyn.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_growth()

// Test IndexOutOfBoundsError for get
test_vec_get_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)
    arr.push(84)

    // Try to get index that's out of bounds
    val_ref := arr.get_by_ref(10)?
    create_alias(val, I64, val_ref.data)
    panic(loc(), "Expected IndexOutOfBoundsError for get with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for get")
    }

    arr.delete()

}
test_vec_get_out_of_bounds()

// Test IndexOutOfBoundsError for set
test_vec_set_out_of_bounds := proc() {
    mut arr := Vec.new(I64)

    arr.push(42)

    // Try to set index that's out of bounds
    arr.set(10, 999)?
    panic(loc(), "Expected IndexOutOfBoundsError for set with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for set")
    }

    arr.delete()

}
test_vec_set_out_of_bounds()

test_vec_pop := proc() {
    mut stack := Vec.new(I64)

    // Push some values
    stack.push(10)
    stack.push(20)
    stack.push(30)

    assert_eq(loc(), 3, stack.len())

    // Pop values in LIFO order
    mut val := 0
    stack.pop(val)?
    assert_eq(loc(), 30, val)
    assert_eq(loc(), 2, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 20, val)
    assert_eq(loc(), 1, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 10, val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty Vec - should throw
    stack.pop(val)?
    catch (err: IndexOutOfBoundsError) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown IndexOutOfBoundsError")
    exit(1)

}
test_vec_pop()

test_vec_extend := proc() {
    mut dest := Vec.new(I64)
    dest.push(1)
    dest.push(2)

    mut src := Vec.new(I64)
    src.push(3)
    src.push(4)
    src.push(5)

    assert_eq(loc(), 2, dest.len())
    assert_eq(loc(), 3, src.len())

    dest.extend(src)

    assert_eq(loc(), 5, dest.len())
    assert_eq(loc(), 3, src.len()) // src should be unchanged

    // Verify all values
    val_0_ref := dest.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 1, val_0)
    val_1_ref := dest.get_by_ref(1)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 2, val_1)
    val_2_ref := dest.get_by_ref(2)?
    create_alias(val_2, I64, val_2_ref.data)
    assert_eq(loc(), 3, val_2)
    val_3_ref := dest.get_by_ref(3)?
    create_alias(val_3, I64, val_3_ref.data)
    assert_eq(loc(), 4, val_3)
    val_4_ref := dest.get_by_ref(4)?
    create_alias(val_4, I64, val_4_ref.data)
    assert_eq(loc(), 5, val_4)

    dest.delete()
    src.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend()

test_vec_extend_empty := proc() {
    mut dest := Vec.new(Str)
    dest.push("a")
    dest.push("b")

    mut empty := Vec.new(Str)

    dest.extend(empty) // Extending with empty vec should be no-op

    assert_eq(loc(), 2, dest.len())

    val_0_ref := dest.get_by_ref(0)?
    create_alias(val_0, Str, val_0_ref.data)
    assert_eq_str(loc(), "a", val_0)
    val_1_ref := dest.get_by_ref(1)?
    create_alias(val_1, Str, val_1_ref.data)
    assert_eq_str(loc(), "b", val_1)

    dest.delete()
    empty.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend_empty()

test_vec_remove := proc() {
    mut vec := Vec.new(I64)
    vec.push(10)
    vec.push(20)
    vec.push(30)
    vec.push(40)

    assert_eq(loc(), 4, vec.len())

    // Remove middle element (index 1 = value 20)
    vec.remove(1)?

    assert_eq(loc(), 3, vec.len())

    val_0_ref := vec.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 10, val_0)
    val_1_ref := vec.get_by_ref(1)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 30, val_1) // 30 shifted to index 1
    val_2_ref := vec.get_by_ref(2)?
    create_alias(val_2, I64, val_2_ref.data)
    assert_eq(loc(), 40, val_2) // 40 shifted to index 2

    // Remove first element
    vec.remove(0)?

    assert_eq(loc(), 2, vec.len())
    val_3_ref := vec.get_by_ref(0)?
    create_alias(val_3, I64, val_3_ref.data)
    assert_eq(loc(), 30, val_3)
    val_4_ref := vec.get_by_ref(1)?
    create_alias(val_4, I64, val_4_ref.data)
    assert_eq(loc(), 40, val_4)

    // Remove last element
    vec.remove(1)?

    assert_eq(loc(), 1, vec.len())
    val_5_ref := vec.get_by_ref(0)?
    create_alias(val_5, I64, val_5_ref.data)
    assert_eq(loc(), 30, val_5)

    vec.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_remove()

test_vec_remove_out_of_bounds := proc() {
    mut vec := Vec.new(I64)
    vec.push(42)

    // Try to remove index that's out of bounds
    vec.remove(5)?
    panic(loc(), "Expected IndexOutOfBoundsError for remove with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for remove")
    }

    vec.delete()

}
test_vec_remove_out_of_bounds()

test_vec_contains := proc() {
    // Test with I64
    mut nums := Vec.new(I64)
    nums.push(10)
    nums.push(20)
    nums.push(30)

    test(loc(), nums.contains(10), "contains should find 10")
    test(loc(), nums.contains(20), "contains should find 20")
    test(loc(), nums.contains(30), "contains should find 30")
    test(loc(), not(nums.contains(15)), "contains should not find 15")
    test(loc(), not(nums.contains(0)), "contains should not find 0")

    nums.delete()

    // Test with Str
    mut strs := Vec.new(Str)
    strs.push("foo")
    strs.push("bar")
    strs.push("baz")

    test(loc(), strs.contains("foo"), "contains should find foo")
    test(loc(), strs.contains("bar"), "contains should find bar")
    test(loc(), strs.contains("baz"), "contains should find baz")
    test(loc(), not(strs.contains("qux")), "contains should not find qux")
    test(loc(), not(strs.contains("")), "contains should not find empty string")

    strs.delete()

    // Test empty vec
    mut empty := Vec.new(I64)
    test(loc(), not(empty.contains(42)), "contains on empty vec should return false")
    empty.delete()

}
test_vec_contains()

// Bug #37/#38 regression test: Vec with enums
// Bug #37: Vec.push with direct enum constructor was reported to not store data correctly
// Bug #38: Vec.get was reported to not preserve enum payload values
// Both turned out to be false positives or were fixed by other bugfixes.
SimpleColor := enum { Red, Green, Blue }

PayloadEnum := enum {
    None,
    Number: I64,
}

test_vec_enum_direct_push := proc() {
    // Bug #37: Test that direct enum constructor push works
    mut colors := Vec.new(SimpleColor)

    // Push via variable (always worked)
    c := SimpleColor.Red
    colors.push(c)

    // Push directly (Bug #37 claimed this failed)
    colors.push(SimpleColor.Green)
    colors.push(SimpleColor.Blue)

    assert_eq(loc(), 3, colors.len())

    out_0_ref := colors.get_by_ref(0)?
    create_alias(out_0, SimpleColor, out_0_ref.data)
    switch out_0 {
    case SimpleColor.Red: test(loc(), true, "colors[0] should be Red")
    case: test(loc(), false, "colors[0] should be Red")
    }

    out_1_ref := colors.get_by_ref(1)?
    create_alias(out_1, SimpleColor, out_1_ref.data)
    switch out_1 {
    case SimpleColor.Green: test(loc(), true, "colors[1] should be Green")
    case: test(loc(), false, "colors[1] should be Green")
    }

    out_2_ref := colors.get_by_ref(2)?
    create_alias(out_2, SimpleColor, out_2_ref.data)
    switch out_2 {
    case SimpleColor.Blue: test(loc(), true, "colors[2] should be Blue")
    case: test(loc(), false, "colors[2] should be Blue")
    }

    colors.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
// Bug #37 test - should fail until bug is fixed
test_vec_enum_direct_push()

test_vec_enum_payload := proc() {
    // Bug #38: Test that enum payloads are preserved through Vec storage
    mut items := Vec.new(PayloadEnum)

    p1 := PayloadEnum.Number(42)
    items.push(p1)

    p2 := PayloadEnum.Number(100)
    items.push(p2)

    items.push(PayloadEnum.None)

    assert_eq(loc(), 3, items.len())

    result_0_ref := items.get_by_ref(0)?
    create_alias(result_0, PayloadEnum, result_0_ref.data)
    switch result_0 {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 42, n)
    case PayloadEnum.None:
        test(loc(), false, "items[0] should be Number(42), got None")
    }

    result_1_ref := items.get_by_ref(1)?
    create_alias(result_1, PayloadEnum, result_1_ref.data)
    switch result_1 {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 100, n)
    case PayloadEnum.None:
        test(loc(), false, "items[1] should be Number(100), got None")
    }

    result_2_ref := items.get_by_ref(2)?
    create_alias(result_2, PayloadEnum, result_2_ref.data)
    switch result_2 {
    case PayloadEnum.None:
        test(loc(), true, "items[2] should be None")
    case PayloadEnum.Number(n):
        test(loc(), false, "items[2] should be None, got Number")
    }

    items.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_enum_payload()

test_vec_with_capacity := proc() {
    // Test with_capacity creates vec with pre-allocated memory
    mut vec := Vec.with_capacity(I64, 10)

    assert_eq(loc(), 0, vec.len())
    assert_eq(loc(), 10, vec.cap)
    test(loc(), not(vec.ptr.is_null()), "ptr should be allocated")

    // Push elements without triggering reallocation
    mut i := 0
    while i.lt(10) {
        vec.push(i.clone())
        i = i.add(1)
    }

    assert_eq(loc(), 10, vec.len())
    assert_eq(loc(), 10, vec.cap) // Should not have grown

    // Verify values
    val_0_ref := vec.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 0, val_0)
    val_1_ref := vec.get_by_ref(9)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 9, val_1)

    // Push one more to trigger growth
    vec.push(100)
    assert_eq(loc(), 11, vec.len())
    test(loc(), vec.cap.gt(10), "cap should have grown")

    vec.delete()

    // Test with_capacity(0) behaves like new()
    mut empty := Vec.with_capacity(Str, 0)
    assert_eq(loc(), 0, empty.len())
    assert_eq(loc(), 0, empty.cap)
    test(loc(), empty.ptr.is_null(), "Empty vec ptr is null")

    empty.push("hello")
    assert_eq(loc(), 1, empty.len())
    test(loc(), empty.cap.gteq(1), "cap should be at least 1")

    empty.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_with_capacity()

test_sort_str_vec := proc() {
    mut variants := Vec.new(Str)
    variants.push("zebra")
    variants.push("apple")
    variants.push("banana")
    variants.push("cherry")

    sort_str_vec(variants)

    // Verify sorted order
    v0_ref := variants.get_by_ref(0)?
    create_alias(v0, Str, v0_ref.data)
    v1_ref := variants.get_by_ref(1)?
    create_alias(v1, Str, v1_ref.data)
    v2_ref := variants.get_by_ref(2)?
    create_alias(v2, Str, v2_ref.data)
    v3_ref := variants.get_by_ref(3)?
    create_alias(v3, Str, v3_ref.data)

    assert_eq_str(loc(), "apple", v0)
    assert_eq_str(loc(), "banana", v1)
    assert_eq_str(loc(), "cherry", v2)
    assert_eq_str(loc(), "zebra", v3)

    variants.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_sort_str_vec()

test_vec_insert_at := proc() {
    // Test insert_at with I64
    mut vec := Vec.new(I64)
    vec.push(10)
    vec.push(30)
    vec.push(40)

    assert_eq(loc(), 3, vec.len())

    // Insert at middle (index 1)
    vec.insert_at(1, 20)?

    assert_eq(loc(), 4, vec.len())

    val_0_ref := vec.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 10, val_0)
    val_1_ref := vec.get_by_ref(1)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 20, val_1) // Newly inserted
    val_2_ref := vec.get_by_ref(2)?
    create_alias(val_2, I64, val_2_ref.data)
    assert_eq(loc(), 30, val_2) // Shifted right
    val_3_ref := vec.get_by_ref(3)?
    create_alias(val_3, I64, val_3_ref.data)
    assert_eq(loc(), 40, val_3) // Shifted right

    // Insert at beginning (index 0)
    vec.insert_at(0, 5)?

    assert_eq(loc(), 5, vec.len())
    val_4_ref := vec.get_by_ref(0)?
    create_alias(val_4, I64, val_4_ref.data)
    assert_eq(loc(), 5, val_4)
    val_5_ref := vec.get_by_ref(1)?
    create_alias(val_5, I64, val_5_ref.data)
    assert_eq(loc(), 10, val_5)

    // Insert at end (index = len)
    vec.insert_at(5, 50)?

    assert_eq(loc(), 6, vec.len())
    val_6_ref := vec.get_by_ref(5)?
    create_alias(val_6, I64, val_6_ref.data)
    assert_eq(loc(), 50, val_6)

    vec.delete()

    // Test insert_at with Str
    mut strs := Vec.new(Str)
    strs.push("a")
    strs.push("c")

    strs.insert_at(1, "b")?

    assert_eq(loc(), 3, strs.len())

    s_0_ref := strs.get_by_ref(0)?
    create_alias(s_0, Str, s_0_ref.data)
    assert_eq_str(loc(), "a", s_0)
    s_1_ref := strs.get_by_ref(1)?
    create_alias(s_1, Str, s_1_ref.data)
    assert_eq_str(loc(), "b", s_1)
    s_2_ref := strs.get_by_ref(2)?
    create_alias(s_2, Str, s_2_ref.data)
    assert_eq_str(loc(), "c", s_2)

    strs.delete()

    // Test insert_at on empty vec
    mut empty := Vec.new(I64)
    empty.insert_at(0, 42)?
    assert_eq(loc(), 1, empty.len())
    val_7_ref := empty.get_by_ref(0)?
    create_alias(val_7, I64, val_7_ref.data)
    assert_eq(loc(), 42, val_7)
    empty.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_insert_at()

// Bug #166 regression: insert_at growth must preserve Ptr metadata (elem_type, elem_size).
// Previously insert_at used Ptr.new_by_size() directly instead of _alloc_ptr(), so the
// grown Ptr lost elem_size/elem_type. This caused Map (which uses insert_at) to read
// ptr.elem_size as 0.
test_vec_insert_at_growth_preserves_ptr_metadata := proc() {
    mut vec := Vec.new(I64)
    // Vec starts with cap=0, so the very first insert_at triggers growth
    vec.insert_at(0, 10)?
    assert_eq(loc(), 1, vec.len())
    test(loc(), vec.ptr.elem_size.gt(0), "ptr.elem_size should be set after insert_at growth")
    assert_eq(loc(), size_of(I64), vec.ptr.elem_size)

    // Fill to capacity to trigger another growth via insert_at
    while vec.len().lt(vec.cap) {
        vec.push(0)
    }
    old_cap := vec.cap
    vec.insert_at(0, 99)?
    test(loc(), vec.cap.gt(old_cap), "cap should have grown")
    assert_eq(loc(), size_of(I64), vec.ptr.elem_size)

    // Verify data integrity after growth
    val_0_ref := vec.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 99, val_0)
    val_1_ref := vec.get_by_ref(1)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 10, val_1)

    vec.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_insert_at_growth_preserves_ptr_metadata()

test_vec_insert_at_out_of_bounds := proc() {
    mut vec := Vec.new(I64)
    vec.push(42)

    // Try to insert at index > len (should throw)
    vec.insert_at(5, 999)?
    panic(loc(), "Expected IndexOutOfBoundsError for insert_at with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for insert_at")
    }

    vec.delete()

}
test_vec_insert_at_out_of_bounds()

test_vec_split_off := proc() {
    mut vec := Vec.new(I64)
    vec.push(10)
    vec.push(20)
    vec.push(30)
    vec.push(40)
    vec.push(50)

    // Split at index 3
    mut tail := vec.split_off(3)?
    assert_eq(loc(), 3, vec.len())
    assert_eq(loc(), 2, tail.len())

    val_0_ref := vec.get_by_ref(0)?
    create_alias(val_0, I64, val_0_ref.data)
    assert_eq(loc(), 10, val_0)
    val_1_ref := vec.get_by_ref(1)?
    create_alias(val_1, I64, val_1_ref.data)
    assert_eq(loc(), 20, val_1)
    val_2_ref := vec.get_by_ref(2)?
    create_alias(val_2, I64, val_2_ref.data)
    assert_eq(loc(), 30, val_2)

    val_3_ref := tail.get_by_ref(0)?
    create_alias(val_3, I64, val_3_ref.data)
    assert_eq(loc(), 40, val_3)
    val_4_ref := tail.get_by_ref(1)?
    create_alias(val_4, I64, val_4_ref.data)
    assert_eq(loc(), 50, val_4)

    // Split at 0 (move everything)
    mut all := vec.split_off(0)?
    assert_eq(loc(), 0, vec.len())
    assert_eq(loc(), 3, all.len())

    // Split at len (empty tail)
    mut empty := all.split_off(3)?
    assert_eq(loc(), 3, all.len())
    assert_eq(loc(), 0, empty.len())

    all.delete()
    tail.delete()
    empty.delete()
    vec.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_split_off()

test_vec_get_by_ref := proc() {
    mut v := Vec.new(I64)
    v.push(10)
    v.push(20)
    v.push(30)

    // Read via get_by_ref
    ref0 := v.get_by_ref(0)?
    mut val := 0
    ref0.dereference(I64, val)
    assert_eq(loc(), 10, val)

    ref2 := v.get_by_ref(2)?
    ref2.dereference(I64, val)
    assert_eq(loc(), 30, val)

    // Ptr is borrowed (won't free vec memory)
    test(loc(), ref0.is_borrowed.eq(1), "get_by_ref returns borrowed Ptr")

    // Out of bounds throws
    mut threw := false
    _bad := v.get_by_ref(5)?
    catch (err: IndexOutOfBoundsError) {
        threw = true
    }
    test(loc(), threw, "get_by_ref out of bounds throws")

    v.delete()
}
test_vec_get_by_ref()
