mode test

import("core.vec")

test_vec_u8 : proc() = {
    mut dyn := Vec.new(U8)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(own U8.from_i64(42)?)
    dyn.push(own U8.from_i64(255)?)
    assert_eq(loc(), 2, dyn.len())
    val0 := cast(U8, dyn.get(0)?)
    test(loc(), val0.eq(U8.from_i64(42)?), "Value at index 0")
    val1 := cast(U8, dyn.get(1)?)
    test(loc(), val1.eq(U8.from_i64(255)?), "Value at index 1")

    dyn.set(0, own U8.from_i64(99)?)?
    val := cast(U8, dyn.get(0)?)
    test(loc(), val.eq(U8.from_i64(99)?), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch(err: U8_Overflow) {
        println("ERROR:", loc(), "Unexpected U8_Overflow")
        println(err.msg)
        exit(1)
    }
}
test_vec_u8()

test_vec_str : proc() = {
    mut dyn := Vec.new(Str)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(own "foo")
    dyn.push(own "bar")
    assert_eq(loc(), 2, dyn.len())
    val0 := cast(Str, dyn.get(0)?)
    test(loc(), val0.eq("foo"), "Value at index 0")
    val1 := cast(Str, dyn.get(1)?)
    test(loc(), val1.eq("bar"), "Value at index 1")

    dyn.set(0, own "baz")?
    val := cast(Str, dyn.get(0)?)
    test(loc(), val.eq("baz"), "Set and get index 0")

    mut combined_str := ""
    // for s in dyn { // TODO support for loops for Arrays
    mut dyn_len := dyn.len()
    for i in 0..dyn_len {
        s := cast(Str, dyn.get(i)?)
        combined_str = format(combined_str, s)
    }
    assert_eq_str(loc(), "bazbar", combined_str)

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null") // Pointer cleared after delete
    assert_eq(loc(), 0, dyn.len()) // Length reset after delete
    assert_eq(loc(), 0, dyn.cap) // Capacity reset after delete

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_str()

test_vec_bool : proc() = {
    mut dyn := Vec.new(Bool)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(own true)
    dyn.push(own false)
    assert_eq(loc(), 2, dyn.len())
    val0 := cast(Bool, dyn.get(0)?)
    test(loc(), val0.eq(true), "Value at index 0")
    val1 := cast(Bool, dyn.get(1)?)
    test(loc(), val1.eq(false), "Value at index 1")

    dyn.set(0, own false)?
    val := cast(Bool, dyn.get(0)?)
    test(loc(), val.eq(false), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_bool()

test_vec_i64 : proc() = {
    mut dyn := Vec.new(I64)
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), Vec.INIT_CAP, dyn.cap)

    dyn.push(own 42)
    dyn.push(own 84)
    assert_eq(loc(), 2, dyn.len())
    val0 := cast(I64, dyn.get(0)?)
    test(loc(), val0.eq(42), "Value at index 0")
    val1 := cast(I64, dyn.get(1)?)
    test(loc(), val1.eq(84), "Value at index 1")

    dyn.set(0, own 123)?
    val := cast(I64, dyn.get(0)?)
    test(loc(), val.eq(123), "Set and get index 0")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_i64()

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_vec_vec2 : proc() = {
    mut dyn := Vec.new(Vec2) // TODO More ergonomic constructor
    assert_eq(loc(), 0, dyn.len())

    v1 := Vec2(x=10, y=20)
    dyn.push(own v1)
    v2 := Vec2(x=30, y=40)
    dyn.push(own v2)

    assert_eq(loc(), 2, dyn.len())

    v0 := cast(Vec2, dyn.get(0)?)
    test(loc(), v0.x.eq(10), "v0.x should be 10")
    test(loc(), v0.y.eq(20), "v0.y should be 20")

    v3 := Vec2(x=50, y=60)
    dyn.set(0, own v3)?

    v_after_set := cast(Vec2, dyn.get(0)?)
    test(loc(), v_after_set.x.eq(50), "v_after_set.x should be 50")
    test(loc(), v_after_set.y.eq(60), "v_after_set.y should be 60")

    dyn.delete()
    test(loc(), dyn.ptr.is_null(), "Pointer is null")
    assert_eq(loc(), 0, dyn.len())
    assert_eq(loc(), 0, dyn.cap)

    // Catch unexpected errors at end
    catch(err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_vec2()

// Test Array growth/reallocation beyond initial capacity
test_vec_growth : proc() = {
    mut dyn := Vec.new(I64)

    initial_cap := dyn.cap
    test(loc(), initial_cap.eq(Vec.INIT_CAP), "Initial capacity should be INIT_DYN_CAP")

    // Push elements beyond initial capacity to trigger reallocation
    mut i := 0
    while lt(i, add(Vec.INIT_CAP, 5)) {
        dyn.push(own mul(i, 10))
        i = add(i, 1)
    }

    test(loc(), dyn.len().eq(add(Vec.INIT_CAP, 5)), "Length should be INIT_DYN_CAP + 5")
    test(loc(), gt(dyn.cap, initial_cap), "Capacity should have grown beyond initial")
    test(loc(), dyn.cap.gteq(add(Vec.INIT_CAP, 5)), "Capacity should be at least len")

    // Verify all values are still correct after reallocation
    val_0 := cast(I64, dyn.get(0)?)
    test(loc(), val_0.eq(0), "First element should still be 0")
    val_1 := cast(I64, dyn.get(Vec.INIT_CAP)?)
    test(loc(), val_1.eq(mul(Vec.INIT_CAP, 10)), "Element after reallocation should be correct")

    dyn.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_growth()

// Test IndexOutOfBoundsError for get
test_vec_get_out_of_bounds : proc() = {
    mut arr := Vec.new(I64)

    arr.push(own 42)
    arr.push(own 84)

    // Try to get index that's out of bounds
    _val := cast(I64, arr.get(10)?)
    panic(loc(), "Expected IndexOutOfBoundsError for get with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for get")
    }

    arr.delete()

}
test_vec_get_out_of_bounds()

// Test IndexOutOfBoundsError for set
test_vec_set_out_of_bounds : proc() = {
    mut arr := Vec.new(I64)

    arr.push(own 42)

    // Try to set index that's out of bounds
    arr.set(10, own 999)?
    panic(loc(), "Expected IndexOutOfBoundsError for set with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for set")
    }

    arr.delete()

}
test_vec_set_out_of_bounds()

test_vec_pop : proc() = {
    mut stack := Vec.new(I64)

    // Push some values
    stack.push(own 10)
    stack.push(own 20)
    stack.push(own 30)

    assert_eq(loc(), 3, stack.len())

    // Pop values in LIFO order
    mut val := 0
    stack.pop(val)?
    assert_eq(loc(), 30, val)
    assert_eq(loc(), 2, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 20, val)
    assert_eq(loc(), 1, stack.len())

    stack.pop(val)?
    assert_eq(loc(), 10, val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty Vec - should throw
    stack.pop(val)?
    catch (err: IndexOutOfBoundsError) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown IndexOutOfBoundsError")
    exit(1)

}
test_vec_pop()

test_vec_extend : proc() = {
    mut dest := Vec.new(I64)
    dest.push(own 1)
    dest.push(own 2)

    mut src := Vec.new(I64)
    src.push(own 3)
    src.push(own 4)
    src.push(own 5)

    assert_eq(loc(), 2, dest.len())
    assert_eq(loc(), 3, src.len())

    dest.extend(src)

    assert_eq(loc(), 5, dest.len())
    assert_eq(loc(), 3, src.len()) // src should be unchanged

    // Verify all values
    val_0 := cast(I64, dest.get(0)?)
    assert_eq(loc(), 1, val_0)
    val_1 := cast(I64, dest.get(1)?)
    assert_eq(loc(), 2, val_1)
    val_2 := cast(I64, dest.get(2)?)
    assert_eq(loc(), 3, val_2)
    val_3 := cast(I64, dest.get(3)?)
    assert_eq(loc(), 4, val_3)
    val_4 := cast(I64, dest.get(4)?)
    assert_eq(loc(), 5, val_4)

    dest.delete()
    src.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend()

test_vec_extend_empty : proc() = {
    mut dest := Vec.new(Str)
    dest.push(own "a")
    dest.push(own "b")

    mut empty := Vec.new(Str)

    dest.extend(empty) // Extending with empty vec should be no-op

    assert_eq(loc(), 2, dest.len())

    val_0 := cast(Str, dest.get(0)?)
    assert_eq_str(loc(), "a", val_0)
    val_1 := cast(Str, dest.get(1)?)
    assert_eq_str(loc(), "b", val_1)

    dest.delete()
    empty.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_extend_empty()

test_vec_remove : proc() = {
    mut vec := Vec.new(I64)
    vec.push(own 10)
    vec.push(own 20)
    vec.push(own 30)
    vec.push(own 40)

    assert_eq(loc(), 4, vec.len())

    // Remove middle element (index 1 = value 20)
    vec.remove(1)?

    assert_eq(loc(), 3, vec.len())

    val_0 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 10, val_0)
    val_1 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 30, val_1) // 30 shifted to index 1
    val_2 := cast(I64, vec.get(2)?)
    assert_eq(loc(), 40, val_2) // 40 shifted to index 2

    // Remove first element
    vec.remove(0)?

    assert_eq(loc(), 2, vec.len())
    val_3 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 30, val_3)
    val_4 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 40, val_4)

    // Remove last element
    vec.remove(1)?

    assert_eq(loc(), 1, vec.len())
    val_5 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 30, val_5)

    vec.delete()

    // Catch unexpected errors at end
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_remove()

test_vec_remove_out_of_bounds : proc() = {
    mut vec := Vec.new(I64)
    vec.push(own 42)

    // Try to remove index that's out of bounds
    vec.remove(5)?
    panic(loc(), "Expected IndexOutOfBoundsError for remove with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for remove")
    }

    vec.delete()

}
test_vec_remove_out_of_bounds()

test_vec_contains : proc() = {
    // Test with I64
    mut nums := Vec.new(I64)
    nums.push(own 10)
    nums.push(own 20)
    nums.push(own 30)

    test(loc(), nums.contains(10), "contains should find 10")
    test(loc(), nums.contains(20), "contains should find 20")
    test(loc(), nums.contains(30), "contains should find 30")
    test(loc(), not(nums.contains(15)), "contains should not find 15")
    test(loc(), not(nums.contains(0)), "contains should not find 0")

    nums.delete()

    // Test with Str
    mut strs := Vec.new(Str)
    strs.push(own "foo")
    strs.push(own "bar")
    strs.push(own "baz")

    test(loc(), strs.contains("foo"), "contains should find foo")
    test(loc(), strs.contains("bar"), "contains should find bar")
    test(loc(), strs.contains("baz"), "contains should find baz")
    test(loc(), not(strs.contains("qux")), "contains should not find qux")
    test(loc(), not(strs.contains("")), "contains should not find empty string")

    strs.delete()

    // Test empty vec
    mut empty := Vec.new(I64)
    test(loc(), not(empty.contains(42)), "contains on empty vec should return false")
    empty.delete()

}
test_vec_contains()

// Bug #37/#38 regression test: Vec with enums
// Bug #37: Vec.push with direct enum constructor was reported to not store data correctly
// Bug #38: Vec.get was reported to not preserve enum payload values
// Both turned out to be false positives or were fixed by other bugfixes.
SimpleColor := enum { Red, Green, Blue }

PayloadEnum := enum {
    None,
    Number: I64,
}

test_vec_enum_direct_push : proc() = {
    // Bug #37: Test that direct enum constructor push works
    mut colors := Vec.new(SimpleColor)

    // Push via variable (always worked)
    c := SimpleColor.Red
    colors.push(own c)

    // Push directly (Bug #37 claimed this failed)
    colors.push(own SimpleColor.Green)
    colors.push(own SimpleColor.Blue)

    assert_eq(loc(), 3, colors.len())

    out_0 := cast(SimpleColor, colors.get(0)?)
    switch out_0 {
    case SimpleColor.Red: test(loc(), true, "colors[0] should be Red")
    case: test(loc(), false, "colors[0] should be Red")
    }

    out_1 := cast(SimpleColor, colors.get(1)?)
    switch out_1 {
    case SimpleColor.Green: test(loc(), true, "colors[1] should be Green")
    case: test(loc(), false, "colors[1] should be Green")
    }

    out_2 := cast(SimpleColor, colors.get(2)?)
    switch out_2 {
    case SimpleColor.Blue: test(loc(), true, "colors[2] should be Blue")
    case: test(loc(), false, "colors[2] should be Blue")
    }

    colors.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
// Bug #37 test - should fail until bug is fixed
test_vec_enum_direct_push()

test_vec_enum_payload : proc() = {
    // Bug #38: Test that enum payloads are preserved through Vec storage
    mut items := Vec.new(PayloadEnum)

    p1 := PayloadEnum.Number(42)
    items.push(own p1)

    p2 := PayloadEnum.Number(100)
    items.push(own p2)

    items.push(own PayloadEnum.None)

    assert_eq(loc(), 3, items.len())

    result_0 := cast(PayloadEnum, items.get(0)?)
    switch result_0 {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 42, n)
    case PayloadEnum.None:
        test(loc(), false, "items[0] should be Number(42), got None")
    }

    result_1 := cast(PayloadEnum, items.get(1)?)
    switch result_1 {
    case PayloadEnum.Number(n):
        assert_eq(loc(), 100, n)
    case PayloadEnum.None:
        test(loc(), false, "items[1] should be Number(100), got None")
    }

    result_2 := cast(PayloadEnum, items.get(2)?)
    switch result_2 {
    case PayloadEnum.None:
        test(loc(), true, "items[2] should be None")
    case PayloadEnum.Number(n):
        test(loc(), false, "items[2] should be None, got Number")
    }

    items.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_enum_payload()

test_vec_with_capacity : proc() = {
    // Test with_capacity creates vec with pre-allocated memory
    mut vec := Vec.with_capacity(I64, 10)

    assert_eq(loc(), 0, vec.len())
    assert_eq(loc(), 10, vec.cap)
    test(loc(), not(vec.ptr.is_null()), "ptr should be allocated")

    // Push elements without triggering reallocation
    mut i := 0
    while i.lt(10) {
        vec.push(own i.clone())
        i = i.add(1)
    }

    assert_eq(loc(), 10, vec.len())
    assert_eq(loc(), 10, vec.cap) // Should not have grown

    // Verify values
    val_0 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 0, val_0)
    val_1 := cast(I64, vec.get(9)?)
    assert_eq(loc(), 9, val_1)

    // Push one more to trigger growth
    vec.push(own 100)
    assert_eq(loc(), 11, vec.len())
    test(loc(), vec.cap.gt(10), "cap should have grown")

    vec.delete()

    // Test with_capacity(0) behaves like new()
    mut empty := Vec.with_capacity(Str, 0)
    assert_eq(loc(), 0, empty.len())
    assert_eq(loc(), 0, empty.cap)
    test(loc(), empty.ptr.is_null(), "Empty vec ptr is null")

    empty.push(own "hello")
    assert_eq(loc(), 1, empty.len())
    test(loc(), empty.cap.gteq(1), "cap should be at least 1")

    empty.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_with_capacity()

test_sort_str_vec : proc() = {
    mut variants := Vec.new(Str)
    variants.push(own "zebra")
    variants.push(own "apple")
    variants.push(own "banana")
    variants.push(own "cherry")

    sort_str_vec(variants)

    // Verify sorted order
    v0 := cast(Str, variants.get(0)?)
    v1 := cast(Str, variants.get(1)?)
    v2 := cast(Str, variants.get(2)?)
    v3 := cast(Str, variants.get(3)?)

    assert_eq_str(loc(), "apple", v0)
    assert_eq_str(loc(), "banana", v1)
    assert_eq_str(loc(), "cherry", v2)
    assert_eq_str(loc(), "zebra", v3)

    variants.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_sort_str_vec()

test_vec_insert_at : proc() = {
    // Test insert_at with I64
    mut vec := Vec.new(I64)
    vec.push(own 10)
    vec.push(own 30)
    vec.push(own 40)

    assert_eq(loc(), 3, vec.len())

    // Insert at middle (index 1)
    vec.insert_at(1, own 20)?

    assert_eq(loc(), 4, vec.len())

    val_0 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 10, val_0)
    val_1 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 20, val_1) // Newly inserted
    val_2 := cast(I64, vec.get(2)?)
    assert_eq(loc(), 30, val_2) // Shifted right
    val_3 := cast(I64, vec.get(3)?)
    assert_eq(loc(), 40, val_3) // Shifted right

    // Insert at beginning (index 0)
    vec.insert_at(0, own 5)?

    assert_eq(loc(), 5, vec.len())
    val_4 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 5, val_4)
    val_5 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 10, val_5)

    // Insert at end (index = len)
    vec.insert_at(5, own 50)?

    assert_eq(loc(), 6, vec.len())
    val_6 := cast(I64, vec.get(5)?)
    assert_eq(loc(), 50, val_6)

    vec.delete()

    // Test insert_at with Str
    mut strs := Vec.new(Str)
    strs.push(own "a")
    strs.push(own "c")

    strs.insert_at(1, own "b")?

    assert_eq(loc(), 3, strs.len())

    s_0 := cast(Str, strs.get(0)?)
    assert_eq_str(loc(), "a", s_0)
    s_1 := cast(Str, strs.get(1)?)
    assert_eq_str(loc(), "b", s_1)
    s_2 := cast(Str, strs.get(2)?)
    assert_eq_str(loc(), "c", s_2)

    strs.delete()

    // Test insert_at on empty vec
    mut empty := Vec.new(I64)
    empty.insert_at(0, own 42)?
    assert_eq(loc(), 1, empty.len())
    val_7 := cast(I64, empty.get(0)?)
    assert_eq(loc(), 42, val_7)
    empty.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_insert_at()

// Bug #166 regression: insert_at growth must preserve Ptr metadata (elem_type, elem_size).
// Previously insert_at used Ptr.new_by_size() directly instead of _alloc_ptr(), so the
// grown Ptr lost elem_size/elem_type. This caused Map (which uses insert_at) to read
// ptr.elem_size as 0.
test_vec_insert_at_growth_preserves_ptr_metadata : proc() = {
    mut vec := Vec.new(I64)
    // Vec starts with cap=0, so the very first insert_at triggers growth
    vec.insert_at(0, own 10)?
    assert_eq(loc(), 1, vec.len())
    test(loc(), vec.ptr.elem_size.gt(0), "ptr.elem_size should be set after insert_at growth")
    assert_eq(loc(), size_of(I64), vec.ptr.elem_size)

    // Fill to capacity to trigger another growth via insert_at
    while vec.len().lt(vec.cap) {
        vec.push(own 0)
    }
    old_cap := vec.cap
    vec.insert_at(0, own 99)?
    test(loc(), vec.cap.gt(old_cap), "cap should have grown")
    assert_eq(loc(), size_of(I64), vec.ptr.elem_size)

    // Verify data integrity after growth
    val_0 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 99, val_0)
    val_1 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 10, val_1)

    vec.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_insert_at_growth_preserves_ptr_metadata()

test_vec_insert_at_out_of_bounds : proc() = {
    mut vec := Vec.new(I64)
    vec.push(own 42)

    // Try to insert at index > len (should throw)
    vec.insert_at(5, own 999)?
    panic(loc(), "Expected IndexOutOfBoundsError for insert_at with invalid index")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown for insert_at")
    }

    vec.delete()

}
test_vec_insert_at_out_of_bounds()

test_vec_split_off : proc() = {
    mut vec := Vec.new(I64)
    vec.push(own 10)
    vec.push(own 20)
    vec.push(own 30)
    vec.push(own 40)
    vec.push(own 50)

    // Split at index 3
    mut tail := vec.split_off(3)?
    assert_eq(loc(), 3, vec.len())
    assert_eq(loc(), 2, tail.len())

    val_0 := cast(I64, vec.get(0)?)
    assert_eq(loc(), 10, val_0)
    val_1 := cast(I64, vec.get(1)?)
    assert_eq(loc(), 20, val_1)
    val_2 := cast(I64, vec.get(2)?)
    assert_eq(loc(), 30, val_2)

    val_3 := cast(I64, tail.get(0)?)
    assert_eq(loc(), 40, val_3)
    val_4 := cast(I64, tail.get(1)?)
    assert_eq(loc(), 50, val_4)

    // Split at 0 (move everything)
    mut all := vec.split_off(0)?
    assert_eq(loc(), 0, vec.len())
    assert_eq(loc(), 3, all.len())

    // Split at len (empty tail)
    mut empty := all.split_off(3)?
    assert_eq(loc(), 3, all.len())
    assert_eq(loc(), 0, empty.len())

    all.delete()
    tail.delete()
    empty.delete()
    vec.delete()

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_vec_split_off()

test_vec_get : proc() = {
    mut v := Vec.new(I64)
    v.push(own 10)
    v.push(own 20)
    v.push(own 30)

    // Read via get
    ref0 := v.get(0)?
    mut val := 0
    ref0.dereference(I64, val)
    assert_eq(loc(), 10, val)

    ref2 := v.get(2)?
    ref2.dereference(I64, val)
    assert_eq(loc(), 30, val)

    // Ptr is borrowed (won't free vec memory)
    test(loc(), ref0.is_borrowed.eq(1), "get returns borrowed Ptr")

    // Out of bounds throws
    mut threw := false
    _bad := v.get(5)?
    catch (err: IndexOutOfBoundsError) {
        threw = true
    }
    test(loc(), threw, "get out of bounds throws")

    v.delete()
}
test_vec_get()
