mode test

import("std.list")

// List tests for heterogeneous collections
// List.push() and List.set() now take type as first parameter: list.push(I64, 42)

// Test creating empty list
test_list_new := proc() {
    mut list := List.new()

    assert_eq(loc(), 0, list.len())

    list.delete()
}
test_list_new()

// Test pushing heterogeneous types
test_list_push_heterogeneous := proc() {
    mut list := List.new()

    // Push I64
    list.push(I64, 42)?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Push Str
    list.push(Str, "hello")?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Push Bool
    list.push(Bool, true)?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 3, list.len())

    list.delete()
}
test_list_push_heterogeneous()

// Test getting elements
test_list_get := proc() {
    mut list := List.new()

    list.push(I64, 100)?
    list.push(Str, "world")?
    list.push(Bool, false)?

    // Get I64 at index 0
    val0 := cast(I64, list.get(0)?)
    test(loc(), val0.eq(100), "Value at index 0")

    // Get Str at index 1
    val1 := cast(Str, list.get(1)?)
    test(loc(), val1.eq("world"), "Value at index 1")

    // Get Bool at index 2
    val2 := cast(Bool, list.get(2)?)
    test(loc(), val2.eq(false), "Value at index 2")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    list.delete()
}
test_list_get()

// Test setting elements (same size)
test_list_set_same_size := proc() {
    mut list := List.new()

    list.push(I64, 10)?
    list.push(I64, 20)?
    list.push(I64, 30)?

    // Set index 1 to new I64
    list.set(1, I64, 999)?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    val := cast(I64, list.get(1)?)
    test(loc(), val.eq(999), "Set and get index 1")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    list.delete()
}
test_list_set_same_size()

// Test setting elements (different size)
test_list_set_different_size := proc() {
    mut list := List.new()

    list.push(I64, 1)?
    list.push(I64, 2)?
    list.push(I64, 3)?

    // Replace I64 at index 1 with Str (different size)
    list.set(1, Str, "replaced")?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Verify element at index 1 is now Str
    val := cast(Str, list.get(1)?)
    test(loc(), val.eq("replaced"), "Set different size at index 1")

    // Verify element at index 2 is still correct
    val2 := cast(I64, list.get(2)?)
    test(loc(), val2.eq(3), "Element at index 2 after set")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    list.delete()
}
test_list_set_different_size()

// Test with user-defined struct
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_list_with_struct := proc() {
    mut list := List.new()

    v1 := Vec2(x=10, y=20)

    v2 := Vec2(x=30, y=40)

    list.push(Vec2, v1)?
    list.push(I64, 42)?
    list.push(Vec2, v2)?

    assert_eq(loc(), 3, list.len())

    // Get Vec2 at index 0
    result := cast(Vec2, list.get(0)?)
    test(loc(), result.x.eq(10), "Vec2.x at index 0")
    test(loc(), result.y.eq(20), "Vec2.y at index 0")

    // Get I64 at index 1
    num := cast(I64, list.get(1)?)
    test(loc(), num.eq(42), "I64 at index 1")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    list.delete()
}
test_list_with_struct()

// Test len field
test_list_len := proc() {
    mut list := List.new()

    test(loc(), list.len().eq(0), "Empty list length")

    list.push(I64, 1)?
    list.push(I64, 2)?
    list.push(I64, 3)?
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(3), "List length after 3 pushes")

    list.delete()
}
test_list_len()

// Test index out of bounds error
test_list_out_of_bounds := proc() {
    mut list := List.new()

    list.push(I64, 10)?

    _val := cast(I64, list.get(5)?)
    panic(loc(), "Expected IndexOutOfBoundsError")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown")
    }

    list.delete()
}
test_list_out_of_bounds()

// Test multiple pushes
test_list_multiple_pushes := proc() {
    mut list := List.new()

    // Push several elements
    for i in 0..10 {
        list.push(I64, i.clone())?
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(10), "List holds 10 elements")

    // Verify values are correct
    val0 := cast(I64, list.get(0)?)
    test(loc(), val0.eq(0), "First element")

    val9 := cast(I64, list.get(9)?)
    test(loc(), val9.eq(9), "Last element")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    list.delete()
}
test_list_multiple_pushes()

// Test nested lists
test_nested_lists := proc() {
    mut inner := List.new()

    inner.push(I64, 1)?
    inner.push(I64, 2)?

    mut outer := List.new()

    outer.push(List, inner)?
    outer.push(I64, 99)?

    assert_eq(loc(), 2, outer.len())

    // Get the nested list (zero-copy reference into outer's data buffer)
    retrieved_inner := cast(List, outer.get(0)?)

    test(loc(), retrieved_inner.len().eq(2), "Nested list length")

    // Get value from nested list
    nested_val := cast(I64, retrieved_inner.get(0)?)
    test(loc(), nested_val.eq(1), "Value from nested list")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // inner was transferred to outer via push(own), so outer owns it now
    outer.delete()
}
test_nested_lists()

test_list_pop := proc() {
    mut stack := List.new()

    // Push heterogeneous values
    stack.push(I64, 10)?
    stack.push(Str, "hello")?
    stack.push(Bool, true)?
    stack.push(I64, 42)?

    assert_eq(loc(), 4, stack.len())

    // Pop in LIFO order
    mut i_val := 0
    stack.pop(i_val)?
    assert_eq(loc(), 42, i_val)
    assert_eq(loc(), 3, stack.len())

    mut b_val := false
    stack.pop(b_val)?
    test(loc(), b_val, "Popped bool value")
    assert_eq(loc(), 2, stack.len())

    mut s_val := ""
    stack.pop(s_val)?
    test(loc(), s_val.eq("hello"), "Popped string value")
    assert_eq(loc(), 1, stack.len())

    stack.pop(i_val)?
    assert_eq(loc(), 10, i_val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty List - should throw
    stack.pop(i_val)?
    catch (err: IndexOutOfBoundsError) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown IndexOutOfBoundsError")
    exit(1)

}
test_list_pop()
