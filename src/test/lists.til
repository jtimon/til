mode test

import("std.list")

// List tests for heterogeneous collections
// List.push() and List.set() now take type as first parameter: list.push(I64, 42)

// Test creating empty list
test_list_new := proc() {
    mut list := List.new()

    assert_eq(loc(), 0, list.len())

    list.delete()
}
test_list_new()

// Test pushing heterogeneous types
test_list_push_heterogeneous := proc() {
    mut list := List.new()

    // Push I64
    list.push(I64, 42)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    // Push Str
    list.push(Str, "hello")?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    // Push Bool
    list.push(Bool, true)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 3, list.len())

    list.delete()
}
test_list_push_heterogeneous()

// Test getting elements
test_list_get := proc() {
    mut list := List.new()

    list.push(I64, 100)?
    list.push(Str, "world")?
    list.push(Bool, false)?

    // Get I64 at index 0
    mut val0 := 0
    list.get(0, val0)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val0.eq(100), "Value at index 0")

    // Get Str at index 1
    mut val1 := ""
    list.get(1, val1)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val1.eq("world"), "Value at index 1")

    // Get Bool at index 2
    mut val2 := true
    list.get(2, val2)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val2.eq(false), "Value at index 2")

    list.delete()
}
test_list_get()

// Test setting elements (same size)
test_list_set_same_size := proc() {
    mut list := List.new()

    list.push(I64, 10)?
    list.push(I64, 20)?
    list.push(I64, 30)?

    // Set index 1 to new I64
    list.set(1, I64, 999)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    mut val := 0
    list.get(1, val)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(999), "Set and get index 1")

    list.delete()
}
test_list_set_same_size()

// Test setting elements (different size)
test_list_set_different_size := proc() {
    mut list := List.new()

    list.push(I64, 1)?
    list.push(I64, 2)?
    list.push(I64, 3)?

    // Replace I64 at index 1 with Str (different size)
    list.set(1, Str, "replaced")?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    // Verify element at index 1 is now Str
    mut val := ""
    list.get(1, val)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq("replaced"), "Set different size at index 1")

    // Verify element at index 2 is still correct
    mut val2 := 0
    list.get(2, val2)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val2.eq(3), "Element at index 2 after set")

    list.delete()
}
test_list_set_different_size()

// Test with user-defined struct
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_list_with_struct := proc() {
    mut list := List.new()

    v1 := Vec2(x=10, y=20)

    v2 := Vec2(x=30, y=40)

    list.push(Vec2, v1)?
    list.push(I64, 42)?
    list.push(Vec2, v2)?

    assert_eq(loc(), 3, list.len())

    // Get Vec2 at index 0
    mut result := Vec2()
    list.get(0, result)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), result.x.eq(10), "Vec2.x at index 0")
    test(loc(), result.y.eq(20), "Vec2.y at index 0")

    // Get I64 at index 1
    mut num := 0
    list.get(1, num)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), num.eq(42), "I64 at index 1")

    list.delete()
}
test_list_with_struct()

// Test len field
test_list_len := proc() {
    mut list := List.new()

    test(loc(), list.len().eq(0), "Empty list length")

    list.push(I64, 1)?
    list.push(I64, 2)?
    list.push(I64, 3)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(3), "List length after 3 pushes")

    list.delete()
}
test_list_len()

// Test index out of bounds error
test_list_out_of_bounds := proc() {
    mut list := List.new()

    list.push(I64, 10)?

    mut val := 0
    list.get(5, val)?
    panic(loc(), "Expected OutOfBounds")

    catch (err: OutOfBounds) {
        test(loc(), true, "OutOfBounds correctly thrown")
    }

    list.delete()
}
test_list_out_of_bounds()

// Test multiple pushes
test_list_multiple_pushes := proc() {
    mut list := List.new()

    // Push several elements
    for i in 0..10 {
        list.push(I64, i)?
    }
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(10), "List holds 10 elements")

    // Verify values are correct
    mut val := 0
    list.get(0, val)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(0), "First element")

    list.get(9, val)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(9), "Last element")

    list.delete()
}
test_list_multiple_pushes()

// Test nested lists
test_nested_lists := proc() {
    mut inner := List.new()

    inner.push(I64, 1)?
    inner.push(I64, 2)?

    mut outer := List.new()

    outer.push(List, inner)?
    outer.push(I64, 99)?

    assert_eq(loc(), 2, outer.len())

    // Get the nested list
    mut retrieved_inner := List.new()

    outer.get(0, retrieved_inner)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }

    test(loc(), retrieved_inner.len().eq(2), "Nested list length")

    // Get value from nested list
    mut nested_val := 0
    retrieved_inner.get(0, nested_val)?
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
    test(loc(), nested_val.eq(1), "Value from nested list")

    // NOTE: Don't delete retrieved_inner - it's a shallow copy that shares
    // memory with inner. List.get does memcpy which copies the List struct
    // including its internal data pointer. Deleting both would double-free.
    //
    // This is a fundamental design choice: TIL's List stores elements in a
    // contiguous buffer (like a C array), so nested Lists share memory after get.
    // Alternative: Lisp-style cons cells where each element is a pointer,
    // making "copies" just reference the same data without ownership issues.
    // Other options: deep copy on get, reference counting, or ownership semantics.
    //
    // The interpreter doesn't actually free on .delete() which masks this issue.
    // retrieved_inner.delete()  // Would cause double-free in compiled code
    inner.delete()
    outer.delete()
}
test_nested_lists()

test_list_pop := proc() {
    mut stack := List.new()

    // Push heterogeneous values
    stack.push(I64, 10)?
    stack.push(Str, "hello")?
    stack.push(Bool, true)?
    stack.push(I64, 42)?

    assert_eq(loc(), 4, stack.len())

    // Pop in LIFO order
    mut i_val := 0
    stack.pop(i_val)?
    assert_eq(loc(), 42, i_val)
    assert_eq(loc(), 3, stack.len())

    mut b_val := false
    stack.pop(b_val)?
    test(loc(), b_val, "Popped bool value")
    assert_eq(loc(), 2, stack.len())

    mut s_val := ""
    stack.pop(s_val)?
    test(loc(), s_val.eq("hello"), "Popped string value")
    assert_eq(loc(), 1, stack.len())

    stack.pop(i_val)?
    assert_eq(loc(), 10, i_val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty List - should throw
    stack.pop(i_val)?
    catch (err: OutOfBounds) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown OutOfBounds")
    exit(1)

}
test_list_pop()
