mode test

import("src.core.list")

// List tests for heterogeneous collections
// List.push() and List.set() now take type as first parameter: list.push(I64, 42)

// Test creating empty list
test_list_new := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 0, list.len())

    list.delete()
}
test_list_new()

// Test pushing heterogeneous types
test_list_push_heterogeneous := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    // Push I64
    list.push(I64, 42)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Push Str
    list.push(Str, "hello")
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Push Bool
    list.push(Bool, true)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 3, list.len())

    list.delete()
}
test_list_push_heterogeneous()

// Test getting elements
test_list_get := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    list.push(I64, 100)
    list.push(Str, "world")
    list.push(Bool, false)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    // Get I64 at index 0
    mut val0 := 0
    list.get(0, val0)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val0.eq(100), "Value at index 0")

    // Get Str at index 1
    mut val1 := ""
    list.get(1, val1)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val1.eq("world"), "Value at index 1")

    // Get Bool at index 2
    mut val2 := true
    list.get(2, val2)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val2.eq(false), "Value at index 2")

    list.delete()
}
test_list_get()

// Test setting elements (same size)
test_list_set_same_size := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    list.push(I64, 10)
    list.push(I64, 20)
    list.push(I64, 30)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    // Set index 1 to new I64
    list.set(1, I64, 999)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    mut val := 0
    list.get(1, val)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(999), "Set and get index 1")

    list.delete()
}
test_list_set_same_size()

// Test setting elements (different size)
test_list_set_different_size := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    list.push(I64, 1)
    list.push(I64, 2)
    list.push(I64, 3)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    // Replace I64 at index 1 with Str (different size)
    list.set(1, Str, "replaced")
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    // Verify element at index 1 is now Str
    mut val := ""
    list.get(1, val)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq("replaced"), "Set different size at index 1")

    // Verify element at index 2 is still correct
    mut val2 := 0
    list.get(2, val2)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val2.eq(3), "Element at index 2 after set")

    list.delete()
}
test_list_set_different_size()

// Test with user-defined struct
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

test_list_with_struct := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    mut v1 := Vec2()
    v1.x = 10
    v1.y = 20

    mut v2 := Vec2()
    v2.x = 30
    v2.y = 40

    list.push(Vec2, v1)
    list.push(I64, 42)
    list.push(Vec2, v2)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 3, list.len())

    // Get Vec2 at index 0
    mut result := Vec2()
    list.get(0, result)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), result.x.eq(10), "Vec2.x at index 0")
    test(loc(), result.y.eq(20), "Vec2.y at index 0")

    // Get I64 at index 1
    mut num := 0
    list.get(1, num)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), num.eq(42), "I64 at index 1")

    list.delete()
}
test_list_with_struct()

// Test len field
test_list_len := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(0), "Empty list length")

    list.push(I64, 1)
    list.push(I64, 2)
    list.push(I64, 3)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(3), "List length after 3 pushes")

    list.delete()
}
test_list_len()

// Test index out of bounds error
test_list_out_of_bounds := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    list.push(I64, 10)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    mut val := 0
    list.get(5, val)
    panic(loc(), "Expected IndexOutOfBoundsError")

    catch (err: IndexOutOfBoundsError) {
        test(loc(), true, "IndexOutOfBoundsError correctly thrown")
    }

    list.delete()
}
test_list_out_of_bounds()

// Test multiple pushes
test_list_multiple_pushes := proc() {
    mut list := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    // Push several elements
    mut i := 0
    while lt(i, 10) {
        list.push(I64, i)
        i = add(i, 1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    test(loc(), list.len().eq(10), "List holds 10 elements")

    // Verify values are correct
    mut val := 0
    list.get(0, val)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(0), "First element")

    list.get(9, val)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), val.eq(9), "Last element")

    list.delete()
}
test_list_multiple_pushes()

// Test nested lists
test_nested_lists := proc() {
    mut inner := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    inner.push(I64, 1)
    inner.push(I64, 2)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    mut outer := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    outer.push(List, inner)
    outer.push(I64, 99)
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    assert_eq(loc(), 2, outer.len())

    // Get the nested list
    mut retrieved_inner := List.new()
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }

    outer.get(0, retrieved_inner)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }

    test(loc(), retrieved_inner.len().eq(2), "Nested list length")

    // Get value from nested list
    mut nested_val := 0
    retrieved_inner.get(0, nested_val)
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    test(loc(), nested_val.eq(1), "Value from nested list")

    retrieved_inner.delete()
    inner.delete()
    outer.delete()
}
test_nested_lists()

test_list_pop := proc() {
    mut stack := List.new()

    // Push heterogeneous values
    stack.push(I64, 10)
    stack.push(Str, "hello")
    stack.push(Bool, true)
    stack.push(I64, 42)

    assert_eq(loc(), 4, stack.len())

    // Pop in LIFO order
    mut i_val := 0
    stack.pop(i_val)
    assert_eq(loc(), 42, i_val)
    assert_eq(loc(), 3, stack.len())

    mut b_val := false
    stack.pop(b_val)
    test(loc(), b_val, "Popped bool value")
    assert_eq(loc(), 2, stack.len())

    mut s_val := ""
    stack.pop(s_val)
    test(loc(), s_val.eq("hello"), "Popped string value")
    assert_eq(loc(), 1, stack.len())

    stack.pop(i_val)
    assert_eq(loc(), 10, i_val)
    assert_eq(loc(), 0, stack.len())

    // Test popping from empty List - should throw
    stack.pop(i_val)
    catch (err: IndexOutOfBoundsError) {
        // Expected error
        stack.delete()
        return
    }

    println("ERROR:", loc(), "Should have thrown IndexOutOfBoundsError")
    exit(1)

    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_list_pop()
