mode test

// Test compile-time constant folding for pure functions with literal arguments

// Test 1: Simple arithmetic
test_simple_add := proc() {
    result := add(1, 2)
    test(loc(), result.eq(3), "add(1, 2) should be 3")
}
test_simple_add()

// Test 2: Nested arithmetic
test_nested_arithmetic := proc() {
    result := mul(add(1, 2), sub(10, 5))
    test(loc(), result.eq(15), "mul(add(1, 2), sub(10, 5)) should be 15")
}
test_nested_arithmetic()

// Test 3: Deeply nested
test_deeply_nested := proc() {
    result := add(mul(2, 3), mul(4, 5))
    test(loc(), result.eq(26), "add(mul(2, 3), mul(4, 5)) should be 26")
}
test_deeply_nested()

// Test 4: String concat - NOT currently folded because concat throws AllocError
// TODO: Support folding functions that throw but have literal args that won't cause errors
test_string_concat := proc() {
    result := concat("hello", " world")
    test(loc(), result.eq("hello world"), "concat works at runtime")
}
test_string_concat()

// Test 5: Mixed - this should NOT be folded because x is a variable
// TODO: Support folding with const variables (not just literals)
test_no_fold_variable := proc() {
    x := 5
    result := add(x, 3)  // x is not a literal, so no folding
    test(loc(), result.eq(8), "add(x, 3) should still work at runtime")
}
test_no_fold_variable()

// Test 6: loc() is folded to the correct source location at compile time
test_loc_folded_correctly := proc() {
    location := loc()
    test(loc(), location.contains("constfold.til"), "loc() should contain filename")
    test(loc(), location.contains(":45:"), "loc() should contain correct line number")
}
test_loc_folded_correctly()
