mode test

// Test compile-time constant folding for pure functions with literal arguments

// Test 1: Simple arithmetic
test_simple_add : proc() = {
    result := add(1, 2)
    test(loc(), result.eq(3), "add(1, 2) should be 3")
}
test_simple_add()

// Test 2: Nested arithmetic
test_nested_arithmetic : proc() = {
    result := mul(add(1, 2), sub(10, 5))
    test(loc(), result.eq(15), "mul(add(1, 2), sub(10, 5)) should be 15")
}
test_nested_arithmetic()

// Test 3: Deeply nested
test_deeply_nested : proc() = {
    result := add(mul(2, 3), mul(4, 5))
    test(loc(), result.eq(26), "add(mul(2, 3), mul(4, 5)) should be 26")
}
test_deeply_nested()

// Test 4: String concat - now folded at compile time
test_string_concat : proc() = {
    result := concat("hello", " world")  // Folded to "hello world"
    test(loc(), result.eq("hello world"), "concat is folded at compile time")
}
test_string_concat()

// Test 5: Folding through immutable variables
// Immutable variables (non-mut) with comptime-evaluable values are folded
test_fold_variable : proc() = {
    x := 5
    result := add(x, 3)  // x is immutable with literal value, so this folds to 8
    test(loc(), result.eq(8), "add(x, 3) should fold to 8")
}
test_fold_variable()

// Test 6: loc() is folded to the correct source location at compile time
test_loc_folded_correctly : proc() = {
    location := loc()
    test(loc(), location.contains("constfold.til"), "loc() should contain filename")
    test(loc(), location.contains(":44:"), "loc() should contain correct line number")
}
test_loc_folded_correctly()

// === Struct Comptime Folding ===

// Simple struct with pure constructor
CfVec2 := struct {
    mut x: I64 = 0
    mut y: I64 = 0

namespace:
    // Pure func (not proc!) so it can be folded
    // Use non-default values to ensure we're not relying on defaults
    magic : func() returns CfVec2 = {
        return CfVec2(x=42, y=99)
    }

    at : func(x: I64, y: I64) returns CfVec2 = {
        return CfVec2(x=x, y=y)
    }
}

// Test 7: Simple struct folding with non-default values
test_struct_fold_simple : proc() = {
    v := CfVec2.magic()  // Should fold to CfVec2(x=42, y=99)
    assert_eq(loc(), 42, v.x)
    assert_eq(loc(), 99, v.y)
}
test_struct_fold_simple()

// Test 8: Struct with argument values
test_struct_fold_values : proc() = {
    p := CfVec2.at(10, 20)  // Should fold to CfVec2(x=10, y=20)
    assert_eq(loc(), 10, p.x)
    assert_eq(loc(), 20, p.y)
}
test_struct_fold_values()

// Test 9: Nested struct
CfRect := struct {
    mut top_left: CfVec2 = CfVec2()
    mut bottom_right: CfVec2 = CfVec2()

namespace:
    // Use non-default values to verify nested folding works
    sample : func() returns CfRect = {
        return CfRect(top_left=CfVec2(x=5, y=10), bottom_right=CfVec2(x=100, y=200))
    }
}

test_struct_fold_nested : proc() = {
    r := CfRect.sample()  // Should fold to CfRect(top_left=CfVec2(x=5,y=10), bottom_right=CfVec2(x=100,y=200))
    assert_eq(loc(), 5, r.top_left.x)
    assert_eq(loc(), 10, r.top_left.y)
    assert_eq(loc(), 100, r.bottom_right.x)
    assert_eq(loc(), 200, r.bottom_right.y)
}
test_struct_fold_nested()
