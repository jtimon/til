mode test

// Arithmetic tests

c2      := 2
c4      := 4
c42     := 42
c0      := 0
c1      := 1
cNeg2   := I64.sub(0, 2)
cNeg42  := I64.sub(0, 42)

test(loc(), c42.eq(I64.add(40, 2)), "40 + 2 = 42")
test(loc(), c42.eq(I64.sub(44, 2)), "44 - 2 = 42")
test(loc(), c42.eq(I64.mul(6, 7)), " 6 * 7 = 42")
test(loc(), c42.eq(I64.div(420, 10)), " 420 / 10 = 42")
test(loc(),  c4.eq(I64.add(2, 2)), "2 + 2 = 4")
test(loc(),  c4.eq(I64.mul(2, 2)), "2 * 2 = 4")

// Testing inc and dec (UFCS: val.inc() -> inc(val))
test_inc_dec := proc() {
    mut val := 41
    val.inc() // Equivalent to I64.inc(val)
    test(loc(), val.eq(42), "41.inc() == 42")

    val.dec()
    test(loc(), val.eq(41), "42.dec() == 41")
}
test_inc_dec()

test(loc(), I64.add(40, 2).eq(42), "40 + 2 = 42")
test(loc(), I64.sub(44, 2).eq(42), "44 - 2 = 42")
test(loc(), I64.mul(6, 7).eq(42), "6 * 7 = 42")
test(loc(), I64.div(420, 10).eq(42), "420 / 10 = 42")
test(loc(), I64.add(2, 2).eq(4), "2 + 2 = 4")
test(loc(), I64.mul(2, 2).eq(4), "2 * 2 = 4")

// Additional tests for arithmetic functions
test(loc(), I64.mul(0, 5).eq(0), "0 * 5 = 0")
test(loc(), I64.mul(1, 5).eq(5), "1 * 5 = 5")
test(loc(), I64.div(10, 2).eq(5), "10 / 2 = 5")
test(loc(), I64.div(9, 3).eq(3), "9 / 3 = 3")
test(loc(), I64.sub(5, 2).eq(3), "5 - 2 = 3")
test(loc(), I64.add(0, 0).eq(0), "0 + 0 = 0")
test(loc(), I64.add(1, 1).eq(2), "1 + 1 = 2")

// Negative number tests
test(loc(), cNeg42.add(100).eq(58), "-42 + 100 = 58")
test(loc(), cNeg42.sub(cNeg2).eq(I64.sub(0, 40)), "-42 - (-2) = -40")
test(loc(), cNeg2.mul(21).eq(cNeg42), "-2 * 21 = -42")
test(loc(), cNeg42.div(cNeg2).eq(21), "-42 / -2 = 21")  // Toward zero?
test(loc(), I64.sub(0, cNeg2).eq(2), "0 - (-2) = 2")

// TODO: Safe wrappers for future throws (core mul/div wrap for now; add explicit checks post-selfhost)
# DivideByZero := struct {}
# safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
#     if I64.eq(b, 0) { throw DivideByZero() }
#     return div(a, b)
# }
# // Similar for safe_add/safe_mul with I64_OverflowError
# // Tests: Wrap in catch + flag, e.g., test_safe_div() proc as before

// Chaining and precedence (UFCS dots for "methods")
test_chaining := proc() {
    mut val := 5
    val = val.add(3)
    val = val.mul(2)
    val = val.sub(1)
    test(loc(), val.eq(15), "(5 + 3) * 2 - 1 = 15")

    test(loc(), I64.add(2, 3).mul(4).sub(1).eq(19), "((2 + 3) * 4) - 1 = 19")
    test(loc(), I64.mul(10, 2).sub(5).add(3).eq(18), "((10 * 2 - 5) + 3) = 18")
}
test_chaining()

// Mod tests (Current: toward-zero div, rem sign follows dividend like Rust/C.
// Pros: Hardware-friendly, consistent with div. Cons: Negative rems possible.
// Alt (Python/Go): toward -inf div, rem sign follows divisor (always |rem| < |div|, non-neg for pos div).
// Pros: Math-ier, intuitive for loops. Cons: Asym rounding, slower on some HW.
// TODO: Decide post-selfhost? For now, stick to zero for bootstrap/FFI ease.
// Remove core.til TODO once settled.
test(loc(), I64.mod(10, 3).eq(1), "10 % 3 = 1")
test(loc(), I64.sub(0, 10).mod(3).eq(I64.sub(0, 1)), "-10 % 3 = -1")
test(loc(), I64.mod(10, I64.sub(0, 3)).eq(1), "10 % -3 = 1 (toward zero)")
# test(loc(), I64.eq(I64.mod(10, I64.sub(0, 3)), I64.sub(0, 2)), "10 % -3 = -2 (if toward -inf; alt impl)")

// Division and modulo by zero tests
// Current behavior: Returns 0 for div/mod by zero (safe default)
// Future: Post-self-hosting may add optional DivideByZero error
test_divmod_by_zero := proc() {
    // Division by zero returns 0
    test(loc(), I64.div(10, 0).eq(0), "div(10, 0) returns 0 (safe default)")
    test(loc(), I64.div(0, 0).eq(0), "div(0, 0) returns 0")
    test(loc(), I64.sub(0, 10).div(0).eq(0), "div(-10, 0) returns 0")

    // Modulo by zero returns 0
    test(loc(), I64.mod(10, 0).eq(0), "mod(10, 0) returns 0 (safe default)")
    test(loc(), I64.mod(0, 0).eq(0), "mod(0, 0) returns 0")
    test(loc(), I64.sub(0, 10).mod(0).eq(0), "mod(-10, 0) returns 0")
}
test_divmod_by_zero()

// Bitwise operations - don't really belong in arithmetics, but here for now
test_bitwise := proc() {
    // XOR tests
    test(loc(), I64.xor(0, 0).eq(0), "0 XOR 0 = 0")
    test(loc(), I64.xor(1, 0).eq(1), "1 XOR 0 = 1")
    test(loc(), I64.xor(0, 1).eq(1), "0 XOR 1 = 1")
    test(loc(), I64.xor(1, 1).eq(0), "1 XOR 1 = 0")
    test(loc(), I64.xor(12, 10).eq(6), "12 XOR 10 = 6 (1100 XOR 1010 = 0110)")
    test(loc(), I64.xor(255, 15).eq(240), "255 XOR 15 = 240")

    // AND tests
    test(loc(), I64.and(0, 0).eq(0), "0 AND 0 = 0")
    test(loc(), I64.and(1, 0).eq(0), "1 AND 0 = 0")
    test(loc(), I64.and(0, 1).eq(0), "0 AND 1 = 0")
    test(loc(), I64.and(1, 1).eq(1), "1 AND 1 = 1")
    test(loc(), I64.and(12, 10).eq(8), "12 AND 10 = 8 (1100 AND 1010 = 1000)")
    test(loc(), I64.and(255, 15).eq(15), "255 AND 15 = 15")
    test(loc(), I64.and(16, 15).eq(0), "16 AND 15 = 0 (power of 2 mask)")

    // OR tests
    test(loc(), I64.or(0, 0).eq(0), "0 OR 0 = 0")
    test(loc(), I64.or(1, 0).eq(1), "1 OR 0 = 1")
    test(loc(), I64.or(0, 1).eq(1), "0 OR 1 = 1")
    test(loc(), I64.or(1, 1).eq(1), "1 OR 1 = 1")
    test(loc(), I64.or(12, 10).eq(14), "12 OR 10 = 14 (1100 OR 1010 = 1110)")
    test(loc(), I64.or(255, 15).eq(255), "255 OR 15 = 255")
}
test_bitwise()
