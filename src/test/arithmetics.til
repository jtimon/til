mode test

// Arithmetic tests

c2      := 2
c4      := 4
c42     := 42
c0      := 0
c1      := 1
cNeg2   := sub(0, 2)
cNeg42  := sub(0, 42)

test(loc(), c42.eq(add(40, 2)), "40 + 2 = 42")
test(loc(), c42.eq(sub(44, 2)), "44 - 2 = 42")
test(loc(), c42.eq(mul(6, 7)), " 6 * 7 = 42")
test(loc(), c42.eq(div(420, 10)), " 420 / 10 = 42")
test(loc(),  c4.eq(add(2, 2)), "2 + 2 = 4")
test(loc(),  c4.eq(mul(2, 2)), "2 * 2 = 4")

// Testing inc and dec (UFCS: val.inc() -> inc(val))
test_inc_dec := proc() {
    mut val := 41
    val.inc() // Equivalent to I64.inc(val)
    test(loc(), val.eq(42), "41.inc() == 42")

    val.dec()
    test(loc(), val.eq(41), "42.dec() == 41")
}
test_inc_dec()

test(loc(), add(40, 2).eq(42), "40 + 2 = 42")
test(loc(), sub(44, 2).eq(42), "44 - 2 = 42")
test(loc(), mul(6, 7).eq(42), "6 * 7 = 42")
test(loc(), div(420, 10).eq(42), "420 / 10 = 42")
test(loc(), add(2, 2).eq(4), "2 + 2 = 4")
test(loc(), mul(2, 2).eq(4), "2 * 2 = 4")

// Additional tests for arithmetic functions
test(loc(), mul(0, 5).eq(0), "0 * 5 = 0")
test(loc(), mul(1, 5).eq(5), "1 * 5 = 5")
test(loc(), div(10, 2).eq(5), "10 / 2 = 5")
test(loc(), div(9, 3).eq(3), "9 / 3 = 3")
test(loc(), sub(5, 2).eq(3), "5 - 2 = 3")
test(loc(), add(0, 0).eq(0), "0 + 0 = 0")
test(loc(), add(1, 1).eq(2), "1 + 1 = 2")

// Negative number tests
test(loc(), add(cNeg42, 100).eq(58), "-42 + 100 = 58")
test(loc(), sub(cNeg42, cNeg2).eq(sub(0, 40)), "-42 - (-2) = -40")
test(loc(), mul(cNeg2, 21).eq(cNeg42), "-2 * 21 = -42")
test(loc(), div(cNeg42, cNeg2).eq(21), "-42 / -2 = 21")  // Toward zero?
test(loc(), sub(0, cNeg2).eq(2), "0 - (-2) = 2")

// TODO: Safe wrappers for future throws (core mul/div wrap for now; add explicit checks post-selfhost)
# DivideByZero := struct {}
# safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
#     if I64.eq(b, 0) { throw DivideByZero() }
#     return div(a, b)
# }
# // Similar for safe_add/safe_mul with I64_OverflowError
# // Tests: Wrap in catch + flag, e.g., test_safe_div() proc as before

// Chaining and precedence (UFCS dots for "methods")
test_chaining := proc() {
    mut val := 5
    val = val.add(3)
    val = val.mul(2)
    val = val.sub(1)
    test(loc(), val.eq(15), "(5 + 3) * 2 - 1 = 15")

    test(loc(), sub(mul(add(2, 3), 4), 1).eq(19), "((2 + 3) * 4) - 1 = 19")
    test(loc(), add(sub(mul(10, 2), 5), 3).eq(18), "((10 * 2 - 5) + 3) = 18")
}
test_chaining()

// Mod tests (Current: toward-zero div, rem sign follows dividend like Rust/C.
// Pros: Hardware-friendly, consistent with div. Cons: Negative rems possible.
// Alt (Python/Go): toward -inf div, rem sign follows divisor (always |rem| < |div|, non-neg for pos div).
// Pros: Math-ier, intuitive for loops. Cons: Asym rounding, slower on some HW.
// TODO: Decide post-selfhost? For now, stick to zero for bootstrap/FFI ease.
// Remove core.til TODO once settled.
test(loc(), mod(10, 3).eq(1), "10 % 3 = 1")
test(loc(), mod(sub(0, 10), 3).eq(sub(0, 1)), "-10 % 3 = -1")
test(loc(), mod(10, sub(0, 3)).eq(1), "10 % -3 = 1 (toward zero)")
# test(loc(), I64.eq(mod(10, sub(0, 3)), sub(0, 2)), "10 % -3 = -2 (if toward -inf; alt impl)")

// Division and modulo by zero tests
// Current behavior: Returns 0 for div/mod by zero (safe default)
// Future: Post-self-hosting may add optional DivideByZero error
test_divmod_by_zero := proc() {
    // Division by zero returns 0
    test(loc(), div(10, 0).eq(0), "div(10, 0) returns 0 (safe default)")
    test(loc(), div(0, 0).eq(0), "div(0, 0) returns 0")
    test(loc(), div(sub(0, 10), 0).eq(0), "div(-10, 0) returns 0")

    // Modulo by zero returns 0
    test(loc(), mod(10, 0).eq(0), "mod(10, 0) returns 0 (safe default)")
    test(loc(), mod(0, 0).eq(0), "mod(0, 0) returns 0")
    test(loc(), mod(sub(0, 10), 0).eq(0), "mod(-10, 0) returns 0")
}
test_divmod_by_zero()
