mode test

// Arithmetic tests

c2      := 2
c4      := 4
c42     := 42
c0      := 0
c1      := 1
cNeg2   := I64.sub(0, 2)
cNeg42  := I64.sub(0, 42)

test(loc(), c42.eq(I64.add(40, 2)), "40 + 2 = 42")
test(loc(), c42.eq(I64.sub(44, 2)), "44 - 2 = 42")
test(loc(), c42.eq(I64.mul(6, 7)), " 6 * 7 = 42")
test(loc(), c42.eq(I64.div(420, 10)), " 420 / 10 = 42")
test(loc(),  c4.eq(I64.add(2, 2)), "2 + 2 = 4")
test(loc(),  c4.eq(I64.mul(2, 2)), "2 * 2 = 4")

// Testing inc and dec (UFCS: val.inc() -> inc(val))
test_inc_dec : proc() = {
    mut val := 41
    val.inc() // Equivalent to I64.inc(val)
    test(loc(), val.eq(42), "41.inc() == 42")

    val.dec()
    test(loc(), val.eq(41), "42.dec() == 41")
}
test_inc_dec()

test(loc(), I64.add(40, 2).eq(42), "40 + 2 = 42")
test(loc(), I64.sub(44, 2).eq(42), "44 - 2 = 42")
test(loc(), I64.mul(6, 7).eq(42), "6 * 7 = 42")
test(loc(), I64.div(420, 10).eq(42), "420 / 10 = 42")
test(loc(), I64.add(2, 2).eq(4), "2 + 2 = 4")
test(loc(), I64.mul(2, 2).eq(4), "2 * 2 = 4")

// Additional tests for arithmetic functions
test(loc(), I64.mul(0, 5).eq(0), "0 * 5 = 0")
test(loc(), I64.mul(1, 5).eq(5), "1 * 5 = 5")
test(loc(), I64.div(10, 2).eq(5), "10 / 2 = 5")
test(loc(), I64.div(9, 3).eq(3), "9 / 3 = 3")
test(loc(), I64.sub(5, 2).eq(3), "5 - 2 = 3")
test(loc(), I64.add(0, 0).eq(0), "0 + 0 = 0")
test(loc(), I64.add(1, 1).eq(2), "1 + 1 = 2")

// Negative number tests
test(loc(), cNeg42.add(100).eq(58), "-42 + 100 = 58")
test(loc(), cNeg42.sub(cNeg2).eq(I64.sub(0, 40)), "-42 - (-2) = -40")
test(loc(), cNeg2.mul(21).eq(cNeg42), "-2 * 21 = -42")
test(loc(), cNeg42.div(cNeg2).eq(21), "-42 / -2 = 21")  // Toward zero?
test(loc(), I64.sub(0, cNeg2).eq(2), "0 - (-2) = 2")

// TODO: Safe wrappers for future throws (core mul/div wrap for now; add explicit checks post-selfhost)
# DivideByZero := struct {}
# safe_div : func(a: I64, b: I64) returns I64 throws DivideByZero = {
#     if I64.eq(b, 0) { throw DivideByZero() }
#     return div(a, b)
# }
# // Similar for safe_add/safe_mul with I64_OverflowError
# // Tests: Wrap in catch + flag, e.g., test_safe_div() proc as before

// Chaining and precedence (UFCS dots for "methods")
test_chaining : proc() = {
    mut val := 5
    val = val.add(3)
    val = val.mul(2)
    val = val.sub(1)
    test(loc(), val.eq(15), "(5 + 3) * 2 - 1 = 15")

    test(loc(), I64.add(2, 3).mul(4).sub(1).eq(19), "((2 + 3) * 4) - 1 = 19")
    test(loc(), I64.mul(10, 2).sub(5).add(3).eq(18), "((10 * 2 - 5) + 3) = 18")
}
test_chaining()

// Mod tests (Current: toward-zero div, rem sign follows dividend like Rust/C.
// Pros: Hardware-friendly, consistent with div. Cons: Negative rems possible.
// Alt (Python/Go): toward -inf div, rem sign follows divisor (always |rem| < |div|, non-neg for pos div).
// Pros: Math-ier, intuitive for loops. Cons: Asym rounding, slower on some HW.
// TODO: Decide post-selfhost? For now, stick to zero for bootstrap/FFI ease.
// Remove core.til TODO once settled.
test(loc(), I64.mod(10, 3).eq(1), "10 % 3 = 1")
test(loc(), I64.sub(0, 10).mod(3).eq(I64.sub(0, 1)), "-10 % 3 = -1")
test(loc(), I64.mod(10, I64.sub(0, 3)).eq(1), "10 % -3 = 1 (toward zero)")
# test(loc(), I64.eq(I64.mod(10, I64.sub(0, 3)), I64.sub(0, 2)), "10 % -3 = -2 (if toward -inf; alt impl)")

// Division and modulo by zero tests
// Current behavior: Returns 0 for div/mod by zero (safe default)
// Future: Post-self-hosting may add optional DivideByZero error
test_divmod_by_zero : proc() = {
    // Division by zero returns 0
    test(loc(), I64.div(10, 0).eq(0), "div(10, 0) returns 0 (safe default)")
    test(loc(), I64.div(0, 0).eq(0), "div(0, 0) returns 0")
    test(loc(), I64.sub(0, 10).div(0).eq(0), "div(-10, 0) returns 0")

    // Modulo by zero returns 0
    test(loc(), I64.mod(10, 0).eq(0), "mod(10, 0) returns 0 (safe default)")
    test(loc(), I64.mod(0, 0).eq(0), "mod(0, 0) returns 0")
    test(loc(), I64.sub(0, 10).mod(0).eq(0), "mod(-10, 0) returns 0")
}
test_divmod_by_zero()

// U8 increment and decrement tests
test_u8_inc_dec : proc() = {
    mut val : U8 = 41
    val.inc()
    u8_42 : U8 = 42
    test(loc(), val.eq(u8_42), "U8: 41.inc() == 42")

    val.dec()
    u8_41 : U8 = 41
    test(loc(), val.eq(u8_41), "U8: 42.dec() == 41")

    // Test wrapping behavior
    mut wrap_val : U8 = 255
    wrap_val.inc()
    u8_0 : U8 = 0
    test(loc(), wrap_val.eq(u8_0), "U8: 255.inc() wraps to 0")

    mut unwrap_val : U8 = 0
    unwrap_val.dec()
    u8_255 : U8 = 255
    test(loc(), unwrap_val.eq(u8_255), "U8: 0.dec() wraps to 255")
}
test_u8_inc_dec()

// U8 comparison tests (gteq, lteq)
test_u8_comparisons : proc() = {
    a : U8 = 10
    b : U8 = 20
    c : U8 = 10

    // gteq tests
    test(loc(), U8.gteq(b, a), "U8: 20 >= 10")
    test(loc(), U8.gteq(a, c), "U8: 10 >= 10")
    test(loc(), not(U8.gteq(a, b)), "U8: not(10 >= 20)")

    // lteq tests
    test(loc(), U8.lteq(a, b), "U8: 10 <= 20")
    test(loc(), U8.lteq(a, c), "U8: 10 <= 10")
    test(loc(), not(U8.lteq(b, a)), "U8: not(20 <= 10)")

    // Edge cases
    zero : U8 = 0
    max : U8 = 255
    test(loc(), U8.lteq(zero, max), "U8: 0 <= 255")
    test(loc(), U8.gteq(max, zero), "U8: 255 >= 0")
    test(loc(), U8.gteq(zero, zero), "U8: 0 >= 0")
    test(loc(), U8.lteq(max, max), "U8: 255 <= 255")
}
test_u8_comparisons()

// U8 arithmetic tests
test_u8_arithmetic : proc() = {
    u8_2 : U8 = 2
    u8_4 : U8 = 4
    u8_42 : U8 = 42
    u8_6 : U8 = 6
    u8_7 : U8 = 7
    u8_10 : U8 = 10
    u8_40 : U8 = 40
    u8_44 : U8 = 44

    // Addition
    test(loc(), U8.add(u8_40, u8_2).eq(u8_42), "U8: 40 + 2 = 42")
    test(loc(), U8.add(u8_2, u8_2).eq(u8_4), "U8: 2 + 2 = 4")

    // Subtraction
    test(loc(), U8.sub(u8_44, u8_2).eq(u8_42), "U8: 44 - 2 = 42")

    // Multiplication
    test(loc(), U8.mul(u8_6, u8_7).eq(u8_42), "U8: 6 * 7 = 42")
    test(loc(), U8.mul(u8_2, u8_2).eq(u8_4), "U8: 2 * 2 = 4")

    // Division
    u8_420_mod : U8 = 164  // 420 % 256 = 164
    u8_16 : U8 = 16
    u8_5 : U8 = 5
    test(loc(), U8.div(u8_420_mod, u8_10).eq(u8_16), "U8: 164 / 10 = 16")
    test(loc(), U8.div(u8_10, u8_2).eq(u8_5), "U8: 10 / 2 = 5")

    // Modulo
    u8_3 : U8 = 3
    u8_1 : U8 = 1
    test(loc(), U8.mod(u8_10, u8_3).eq(u8_1), "U8: 10 % 3 = 1")

    // Wrapping behavior
    u8_200 : U8 = 200
    u8_100 : U8 = 100
    u8_255 : U8 = 255
    u8_0 : U8 = 0
    test(loc(), U8.add(u8_200, u8_100).eq(u8_44), "U8: 200 + 100 wraps to 44")
    test(loc(), U8.add(u8_255, u8_1).eq(u8_0), "U8: 255 + 1 wraps to 0")
    test(loc(), U8.sub(u8_0, u8_1).eq(u8_255), "U8: 0 - 1 wraps to 255")
}
test_u8_arithmetic()
