mode test

import("core.ptr")

test_pointers := proc() {
    // Note: Ptr.new_by_size(0) now panics internally instead of throwing BadAlloc
    // So we can't test for the error being thrown - removed that test

    mut p := Ptr.new_by_size(32) // allocate 32 bytes
    test(loc(), gt(p.data, 0), "Pointer address should be non-zero")

    p.set_zero(32)

    mut q := Ptr.new_by_size(32)

    p.copy_to(q, 32)

    r := p.offset(16)
    test(loc(), gt(r.data, p.data), "Offset pointer should be greater than base pointer")

    mut s := Ptr.new(I64)
    test(loc(), gt(s.data, 0), "Typed pointer allocation should succeed")

    // Test dereference method
    mut t := Ptr.new(I64)
    mut src_val: I64 = 42
    t.copy_from_dynamic(src_val, size_of(I64))
    mut dest_val: I64 = 0
    t.dereference(I64, dest_val)
    assert_eq(loc(), 42, dest_val)
    t.delete()

    // TODO actually free things after self hosting, when we move on from an interpreted arena (very wasteful, but feels like garbage collection for free)
    p.delete()

    q.delete()
    s.delete()
    // No need to free 'r', it shares memory with 'p'
}
test_pointers()

test_cast := proc() {
    mut vec := Vec.new(I64)
    vec.push(own 42)
    vec.push(own 99)

    // Get a reference to element 0, cast to typed pointer alias
    item := cast(I64, vec.get(0)?)

    // item should now read the value from vec memory
    assert_eq(loc(), 42, item)

    // Get a reference to element 1
    item2 := cast(I64, vec.get(1)?)

    assert_eq(loc(), 99, item2)

    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), err.msg)
        exit(1)
    }
}
test_cast()
