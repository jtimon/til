mode test

// Bug #44: Missing status check for throwing call when there's
// an unrelated catch in a preceding block
//
// The issue appears in get_fcall_value_type where:
// 1. There's an if block with throws/catches
// 2. After the if block, there's another throwing call with a catch
// 3. The status check for the second throwing call is missing

ErrorA := struct { mut msg: Str = "" }
ErrorC := struct { mut msg: Str = "" }

maybe_throw_A := func(do_throw: Bool) returns I64 throws ErrorA {
    if do_throw { throw ErrorA(msg="A") }
    return 1
}

maybe_throw_C := func(do_throw: Bool) returns I64 throws ErrorC {
    if do_throw { throw ErrorC(msg="C") }
    return 3
}

// Simulates get_fcall_value_type structure
test_func := func() returns I64 throws Str {
    // This block mimics the "if e.params.len().gteq(2)" block
    if true {
        mut val := maybe_throw_A(false)?
        catch (err: ErrorA) {
            // handle A
        }
        // The original code also has "catch (err: I64_OverflowError)" here
    }

    // After the if block - this mimics the standalone function lookup
    mut found := false
    mut result := maybe_throw_C(true)?  // This SHOULD throw
    found = true  // This should NOT run if C throws
    catch (err: ErrorC) {
        // Should catch C
    }

    if found {
        throw "BUG: found should be false!"
    }
    return 0
}

caller := proc() {
    mut r := test_func()?
    catch (err: Str) {
        println("ERROR: ", err)
        exit(1)
    }
    println("Result: ", r.to_str())
}
caller()
println("test_bug44: PASSED")
