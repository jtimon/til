mode test

// UNVERIFIED: Division and modulo by zero handling
// Location: interpreter.rs:2177
// Comment: "TODO: Handle b == 0? (e.g., return 0, throw, or propagate Rust panic/UB)"
//
// Testing to see what actually happens when dividing/modulo by zero

// Test 1: Division by zero (FIXED to return 0)
test_div_by_zero := proc() {
    println("Test 1: Testing div(10, 0)...")
    mut result := div(10, 0)
    test(loc(), I64.eq(result, 0), "div(10, 0) should return 0")
    println("PASS: div by zero returns 0 (safe default)")
}

// Test 2: Modulo by zero (FIXED to return 0)
test_mod_by_zero := proc() {
    println("Test 2: Testing mod(10, 0)...")
    mut result := mod(10, 0)
    test(loc(), I64.eq(result, 0), "mod(10, 0) should return 0")
    println("PASS: mod by zero returns 0 (safe default)")
}

test_divmod_zero_status := proc() {
    println("")
    println("Division/Modulo by Zero - FIXED:")
    println("Current behavior: Returns 0 for div/mod by zero (safe default)")
    println("Future consideration: Post-self-hosting, may add optional DivideByZero error")
    println("Users can implement safe_div/safe_mod if they want error handling")
}

// Test 3: Normal operations (baseline)
test_normal_ops := proc() {
    println("Test 3: Normal operations (baseline)...")

    mut div_result := div(10, 2)
    test(loc(), I64.eq(div_result, 5), "10 / 2 should be 5")

    mut mod_result := mod(10, 3)
    test(loc(), I64.eq(mod_result, 1), "10 % 3 should be 1")

    println("PASS: Normal div and mod work correctly")
}

// Run tests
test_normal_ops()
println("")
test_div_by_zero()
test_mod_by_zero()
test_divmod_zero_status()
