mode test

Color := enum {
    Black,
    White,
    // other: I64, // TODO support tagged unions
}

test_size_of := proc() {
    assert_eq(loc(), size_of(U8), 1)
    assert_eq(loc(), size_of(Bool), 1)
    assert_eq(loc(), size_of(I64), 8)
    assert_eq(loc(), size_of(Color), 8)
    assert_eq(loc(), size_of(Str), 16)
}
test_size_of()

test_to_ptr := proc() {
    mut x : I64 = 256
    test(loc(), gt(to_ptr(x), 0), "to_ptr(I64) should return non-zero")

    mut b : Bool = false
    test(loc(), gt(to_ptr(b), 0), "to_ptr(Bool) should return non-zero")

    mut s : Str = "abc"
    test(loc(), gt(to_ptr(s), 0), "to_ptr(Str) should return non-zero")

    mut u : U8 = 42
    test(loc(), gt(to_ptr(u), 0), "to_ptr(U8) should return non-zero")
}
test_to_ptr()

test_type_as_str := proc() {
    assert_eq_str(loc(), "I64", type_as_str(I64))
    assert_eq_str(loc(), "Bool", type_as_str(Bool))
    assert_eq_str(loc(), "Str", type_as_str(Str))
    assert_eq_str(loc(), "U8", type_as_str(U8))
    assert_eq_str(loc(), "Color", type_as_str(Color))
}
test_type_as_str()

test_malloc := proc() {
    mut p := malloc(16)
    test(loc(), gt(p, 0), "malloc: pointer address should be non-zero")
    free(p)
    catch(err: AllocError) {
        exit(1)
    }
}
test_malloc()

test_free := proc() {
    mut p := malloc(8)
    free(p)
    catch(err: AllocError) {
        exit(1)
    }
}
test_free()

test_memset := proc() {
    mut p := malloc(8)
    memset(p, U8.from_i64(0), 8)
    free(p)
    catch(err: AllocError) {
        exit(1)
    }
}
test_memset()

test_memcpy := proc() {
    mut p1 := malloc(8)
    mut p2 := malloc(8)
    memset(p1, U8.from_i64(42), 8)
    memcpy(p2, p1, 8)
    free(p1)
    free(p2)
    catch(err: AllocError) {
        exit(1)
    }
}
test_memcpy()

test_memcmp_i64 := proc() {
    mut a := 42
    mut b := 42
    mut c := 99

    // Compare equal values
    mut result := memcmp(to_ptr(a), to_ptr(b), size_of(I64))
    test(loc(), result.eq(0), "memcmp(42, 42) should return 0")

    // Compare different values (a < c)
    result = memcmp(to_ptr(a), to_ptr(c), size_of(I64))
    test(loc(), not(result.eq(0)), "memcmp(42, 99) should return non-zero")
}
test_memcmp_i64()

test_memcmp_str := proc() {
    mut s1 := "hello"
    mut s2 := "hello"
    mut s3 := "world"

    // Note: memcmp compares the Str struct bytes (which contain pointers),
    // not the actual string content. Each string literal gets its own allocation.
    // So s1 and s2 will have different pointer values even if content is same.
    // Use s.eq() for content comparison, not memcmp on Str types.

    // Compare equal strings - these will have different pointers!
    mut result := memcmp(to_ptr(s1), to_ptr(s2), size_of(Str))
    test(loc(), not(result.eq(0)), "memcmp on Str structs compares pointers, not content")

    // Verify content equality works with .eq()
    test(loc(), s1.eq(s2), "s1.eq(s2) should be true for same content")
    test(loc(), not(s1.eq(s3)), "s1.eq(s3) should be false for different content")
}
test_memcmp_str()

test_memcmp_bool := proc() {
    mut t1 := true
    mut t2 := true
    mut f1 := false

    // Compare equal bools
    mut result := memcmp(to_ptr(t1), to_ptr(t2), size_of(Bool))
    test(loc(), result.eq(0), "memcmp(true, true) should return 0")

    // Compare different bools
    result = memcmp(to_ptr(t1), to_ptr(f1), size_of(Bool))
    test(loc(), not(result.eq(0)), "memcmp(true, false) should return non-zero")
}
test_memcmp_bool()
