mode test

Color := enum {
    Black,
    White,
    // other: I64, // TODO support tagged unions
}

test_size_of := proc() {
    assert_eq(loc(), size_of(U8), 1)
    assert_eq(loc(), size_of(Bool), 1)
    assert_eq(loc(), size_of(I64), 8)
    // Color enum is 8 bytes in interpreter (I64), 4 bytes in compiled C (int enum)
    test(loc(), size_of(Color).gteq(4), "size_of(Color) should be at least 4")
    assert_eq(loc(), size_of(Str), 56)  // Ptr(5 fields * 8 bytes = 40) + _len(8) + cap(8) = 56
}
test_size_of()

test_to_ptr := proc() {
    mut x : I64 = 256
    test(loc(), gt(to_ptr(x), 0), "to_ptr(I64) should return non-zero")

    mut b : Bool = false
    test(loc(), gt(to_ptr(b), 0), "to_ptr(Bool) should return non-zero")

    mut s : Str = "abc"
    test(loc(), gt(to_ptr(s), 0), "to_ptr(Str) should return non-zero")

    mut u : U8 = 42
    test(loc(), gt(to_ptr(u), 0), "to_ptr(U8) should return non-zero")
}
test_to_ptr()

test_type_as_str := proc() {
    assert_eq_str(loc(), "I64", type_as_str(I64))
    assert_eq_str(loc(), "Bool", type_as_str(Bool))
    assert_eq_str(loc(), "Str", type_as_str(Str))
    assert_eq_str(loc(), "U8", type_as_str(U8))
    assert_eq_str(loc(), "Color", type_as_str(Color))
}
test_type_as_str()

test_malloc := proc() {
    mut p := malloc(16)?
    test(loc(), gt(p, 0), "malloc: pointer address should be non-zero")
    free(p)
    catch(err: BadAlloc) {
        panic(loc(), "buy more ram")
    }
}
test_malloc()

test_free := proc() {
    mut p := malloc(8)?
    free(p)
    catch(err: BadAlloc) {
        panic(loc(), "buy more ram")
    }
}
test_free()

test_memset := proc() {
    mut p := malloc(8)?
    memset(p, U8.from_i64(0)?, 8)
    free(p)
    catch(err: BadAlloc) {
        panic(loc(), "buy more ram")
    }
}
test_memset()

test_memcpy := proc() {
    mut p1 := malloc(8)?
    mut p2 := malloc(8)?
    memset(p1, U8.from_i64(42)?, 8)
    memcpy(p2, p1, 8)
    free(p1)
    free(p2)
    catch(err: BadAlloc) {
        panic(loc(), "buy more ram")
    }
}
test_memcpy()

test_memcmp_i64 := proc() {
    mut a := 42
    mut b := 42
    mut c := 99

    // Compare equal values
    mut result := memcmp(to_ptr(a), to_ptr(b), size_of(I64))
    test(loc(), result.eq(0), "memcmp(42, 42) should return 0")

    // Compare different values (a < c)
    result = memcmp(to_ptr(a), to_ptr(c), size_of(I64))
    test(loc(), not(result.eq(0)), "memcmp(42, 99) should return non-zero")
}
test_memcmp_i64()

// NOTE: test_memcmp_str moved to memcmp_str_interpreted.til and memcmp_str_compiled.til
// because string literal pooling differs between interpreter and compiled C

test_memcmp_bool := proc() {
    mut t1 := true
    mut t2 := true
    mut f1 := false

    // Compare equal bools
    mut result := memcmp(to_ptr(t1), to_ptr(t2), size_of(Bool))
    test(loc(), result.eq(0), "memcmp(true, true) should return 0")

    // Compare different bools
    result = memcmp(to_ptr(t1), to_ptr(f1), size_of(Bool))
    test(loc(), not(result.eq(0)), "memcmp(true, false) should return non-zero")
}
test_memcmp_bool()
