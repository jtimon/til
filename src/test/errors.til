mode test

AAAError := struct {}
simplest_catch := proc () {
    mut catched := false
    throw AAAError()
    assert(loc(), false) // This line should be unreachable
    catch (err: AAAError) {
        catched = true
    }
    assert(loc(), catched)
}
simplest_catch()

// Test catch block with error that has fields
ErrorWithMessage := struct {
    msg: Str = "default error message"
}

test_catch_with_fields := proc() {
    mut caught_msg := ""
    mut catched := false
    my_error := ErrorWithMessage()
    throw my_error
    catch (err: ErrorWithMessage) {
        caught_msg = err.msg
        catched = true
    }
    assert(loc(), catched)
    assert_eq_str(loc(), "default error message", caught_msg)
}
test_catch_with_fields()

DivideByZero := struct {} // REM Apparently Roc tried this and rolled it back

// Functions must explicitly declare what they can throw, like in Java
safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
    if I64.eq(b, 0) {
        throw DivideByZero()
    }
    return div(a, b)
}

unsafe_div := proc(a: I64, b: I64) returns I64 {
    return safe_div(a, b)
    catch (err: DivideByZero) {
        return 0
    }
}

test_unsafe_div := proc() {
    mut result := unsafe_div(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div()

unsafe_div2 := proc(a: I64, b: I64) returns I64 {
    res := safe_div(a, b)
    assertm(loc(), false, "DivideByZero should have been thrown")
    catch (err: DivideByZero) {
        return 0
    }
    return res
}

test_unsafe_div2 := proc() {
    mut result := unsafe_div2(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div2()

// Only the selecter error can be thrown
// REM Remove 'throws DivideByZero' to trigger a static type error
missing_throws := proc() throws DivideByZero {
    safe_div(42, 0)
}
// missing_throws() // REM Gives an error if uncommented

// All exceptions that are not catched must be declared in the throws section again
// TODO: We should have a way to signal which calls can throw? perhaps not if the compiler errors are good enough?
// perhaps try at the beginning of each statement that can throw or ? at the end
test_example_catch := proc() {
    a := 420
    mut b := 10
    mut catched := false

    // Test that division works when b is non-zero
    mut result1 := safe_div(a, b)
    assert_eq(loc(), 42, result1)

    b = 0
    result := I64.to_str(a.safe_div(b)) // test declaration
    mut result2 := "0"
    result2 = I64.to_str(a.safe_div(b)) // test assignment
    catch (err: DivideByZero) {
        catched = true
    }
    assert(loc(), catched)

    // safe_div(a, b) // REM this one is not catched nor example_catch throws anything, should give error
}
test_example_catch()

ErrorUndeclaredInFunc := struct {}
ErrorUndeclaredInMethod := struct {}
ErrorUndeclaredInAssoc := struct {}

another_func := func() throws ErrorUndeclaredInFunc {
    throw ErrorUndeclaredInFunc()
}

SomeStruct := struct {
    some_method := func(self: SomeStruct) throws ErrorUndeclaredInFunc {
        throw ErrorUndeclaredInFunc() // FIXED: the compiler now correctly tells us this error must be declared!
    }

    some_assoc := func() throws ErrorUndeclaredInAssoc {
        throw ErrorUndeclaredInAssoc()
    }
}

// Remove things from the throws section to test the errors
undeclared_throws := proc() throws Str, I64, ErrorUndeclaredInAssoc, ErrorUndeclaredInFunc {
    if true {
        another_func()
        catch (err: ErrorUndeclaredInFunc) {
            // Caught successfully
        }
    } else {
        throw "We can throw Str, but we have to declare it in throws"
    }
    while false {
        throw 69
    }
    SomeStruct.some_assoc()
    ss := SomeStruct()
    ss.some_method()

    // another_func() // REM if uncommented, should ask undeclared_throws to throws ErrorUndeclaredInFunc
}

test_undeclared_throws := proc() {
    mut catched_assoc := false

    undeclared_throws()
    catch (err: ErrorUndeclaredInAssoc) {
        catched_assoc = true
    }
    catch (err: Str) {
    }
    catch (err: I64) {
    }
    catch (err: ErrorUndeclaredInFunc) {
    }

    assert(loc(), catched_assoc)
}
test_undeclared_throws()

// TODO do beter examples with throw, including catch in the examples
# example1 := func(u32 a, u32 b) returns u32 throws AaaException, BbbException {

#     if (a > b) throw AaaException;
#     else if (a > b) throw BbbException
#     else if (a < 32) return a;
#     return 42;
# }

# main := proc() throws BbbException {

#     const result1 = example1(50, 50) catch {
#         AaaException: debug.print("AaaException\n");
#         BbbException: rethrow;
#     }

#     const result2 = example2(50, 50) catch debug.print("Exception calling example2\n");
# }
