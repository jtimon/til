mode test

AAAError := struct {}
simplest_catch := proc () {
    mut catched := false
    throw AAAError()
    assert(loc(), false) // This line should be unreachable
    catch (err: AAAError) {
        catched = true
    }
    assert(loc(), catched)
}
simplest_catch()

// Test catch block with error that has fields
ErrorWithMessage := struct {
    mut msg: Str = "default error message"
}

test_catch_with_fields := proc() {
    mut caught_msg := ""
    mut catched := false
    my_error := ErrorWithMessage()
    throw my_error
    catch (err: ErrorWithMessage) {
        caught_msg = err.msg
        catched = true
    }
    assert(loc(), catched)
    assert_eq_str(loc(), "default error message", caught_msg)
}
test_catch_with_fields()

DivideByZero := struct {} // REM Apparently Roc tried this and rolled it back

// Functions must explicitly declare what they can throw, like in Java
safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
    if I64.eq(b, 0) {
        throw DivideByZero()
    }
    return div(a, b)
}

unsafe_div := proc(a: I64, b: I64) returns I64 {
    return safe_div(a, b)
    catch (err: DivideByZero) {
        return 0
    }
}

test_unsafe_div := proc() {
    mut result := unsafe_div(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div()

unsafe_div2 := proc(a: I64, b: I64) returns I64 {
    res := safe_div(a, b)
    assertm(loc(), false, "DivideByZero should have been thrown")
    catch (err: DivideByZero) {
        return 0
    }
    return res
}

test_unsafe_div2 := proc() {
    mut result := unsafe_div2(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div2()

// Only the selecter error can be thrown
// REM Remove 'throws DivideByZero' to trigger a static type error
missing_throws := proc() throws DivideByZero {
    safe_div(42, 0)
}
// missing_throws() // REM Gives an error if uncommented

// All exceptions that are not catched must be declared in the throws section again
// TODO: We should have a way to signal which calls can throw? perhaps not if the compiler errors are good enough?
// perhaps try at the beginning of each statement that can throw or ? at the end
test_example_catch := proc() {
    a := 420
    mut b := 10
    mut catched := false

    // Test that division works when b is non-zero
    mut result1 := safe_div(a, b)
    assert_eq(loc(), 42, result1)

    b = 0
    result := I64.to_str(a.safe_div(b)) // test declaration
    mut result2 := "0"
    result2 = I64.to_str(a.safe_div(b)) // test assignment
    catch (err: DivideByZero) {
        catched = true
    }
    assert(loc(), catched)

    // safe_div(a, b) // REM this one is not catched nor example_catch throws anything, should give error
}
test_example_catch()

ErrorUndeclaredInFunc := struct {}
ErrorUndeclaredInMethod := struct {}
ErrorUndeclaredInAssoc := struct {}

another_func := func() throws ErrorUndeclaredInFunc {
    throw ErrorUndeclaredInFunc()
}

SomeStruct := struct {
    some_method := func(self: SomeStruct) throws ErrorUndeclaredInFunc {
        throw ErrorUndeclaredInFunc() // FIXED: the compiler now correctly tells us this error must be declared!
    }

    some_assoc := func() throws ErrorUndeclaredInAssoc {
        throw ErrorUndeclaredInAssoc()
    }
}

// Remove things from the throws section to test the errors
undeclared_throws := proc() throws Str, I64, ErrorUndeclaredInAssoc, ErrorUndeclaredInFunc {
    if true {
        another_func()
        catch (err: ErrorUndeclaredInFunc) {
            // Caught successfully
        }
    } else {
        throw "We can throw Str, but we have to declare it in throws"
    }
    while false {
        throw 69
    }
    SomeStruct.some_assoc()
    ss := SomeStruct()
    ss.some_method()

    // another_func() // REM if uncommented, should ask undeclared_throws to throws ErrorUndeclaredInFunc
}

test_undeclared_throws := proc() {
    mut catched_assoc := false

    undeclared_throws()
    catch (err: ErrorUndeclaredInAssoc) {
        catched_assoc = true
    }
    catch (err: Str) {
    }
    catch (err: I64) {
    }
    catch (err: ErrorUndeclaredInFunc) {
    }

    assert(loc(), catched_assoc)
}
test_undeclared_throws()

// Test catching and printing Str errors
test_catch_str_error := proc() {
    mut caught := false
    mut error_msg := ""

    throw "This is a test error message"
    catch (err: Str) {
        caught = true
        println("Caught error:")
        println(err)
        error_msg = err
    }

    assert(loc(), caught)
    assert_eq_str(loc(), "This is a test error message", error_msg)
}
test_catch_str_error()

// Test catching errors with Str fields in structs
test_catch_error_with_str_field := proc() {
    mut caught := false
    mut caught_msg := ""

    mut my_error := ErrorWithMessage()
    // Change the message before throwing
    my_error.msg = "Custom error message"
    throw my_error
    catch (err: ErrorWithMessage) {
        caught = true
        // Test accessing Str field in caught struct
        println("Caught error with message:")
        println(err.msg)
        caught_msg = err.msg
    }

    assert(loc(), caught)
    assert_eq_str(loc(), "Custom error message", caught_msg)
}
test_catch_error_with_str_field()

// ==============================================================================
// TODO: Features that could be added to error handling
// ==============================================================================

// TODO: PanicError - special error type that can be thrown implicitly everywhere
// This would allow functions to panic without declaring throws PanicError
// Currently panic() is special-cased but doesn't actually throw
//
// PanicError := struct {
//     msg: Str = "panic"
//     location: Str = ""
// }
//
// test_implicit_panic := proc() {
//     // This should work without declaring throws PanicError
//     panic(loc(), "Something went wrong")
//     catch (err: PanicError) {
//         assert_eq_str(loc(), "Something went wrong", err.msg)
//     }
// }

// TODO: Multiple error types in a single catch chain
// Currently partially works - can have multiple catch blocks
// Could be improved with better syntax
//
// test_multiple_catches := proc() {
//     risky_operation()
//     catch (err: IOError) {
//         println("IO error: ", err.msg)
//     }
//     catch (err: ParseError) {
//         println("Parse error: ", err.msg)
//     }
//     catch (err: Str) {
//         println("String error: ", err)
//     }
// }

// TODO: Result<T, E> type (Rust-style)
// Alternative to throws - explicit error handling in return type
//
// Result := enum {
//     Ok: T,
//     Err: E,
// }
//
// safe_divide := func(a: I64, b: I64) returns Result<I64, DivideByZero> {
//     if eq(b, 0) {
//         return Result.Err(DivideByZero())
//     }
//     return Result.Ok(div(a, b))
// }
//
// test_result_type := proc() {
//     result := safe_divide(10, 2)
//     switch result {
//     case Result.Ok(value):
//         assert_eq(loc(), 5, value)
//     case Result.Err(err):
//         panic(loc(), "Should not error")
//     }
// }

// TODO: Rethrow keyword
// Currently have to manually throw again
//
// test_rethrow := proc() throws SomeError {
//     risky_operation()
//     catch (err: SomeError) {
//         println("Logging error before rethrow")
//         rethrow  // or: throw err
//     }
// }

// TODO: Try operator (? in Rust)
// Automatically propagate errors without explicit catch
//
// parse_and_compute := func(s: Str) returns I64 throws ParseError, ComputeError {
//     n := parse_number(s)?  // Auto-propagates ParseError
//     result := compute(n)?  // Auto-propagates ComputeError
//     return result
// }

// TODO: Finally blocks
// Cleanup code that runs whether error is thrown or not
//
// test_finally := proc() {
//     resource := acquire_resource()
//     try {
//         use_resource(resource)
//     }
//     catch (err: ResourceError) {
//         println("Error using resource")
//     }
//     finally {
//         release_resource(resource)  // Always runs
//     }
// }
