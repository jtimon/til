mode test

AAAError := struct {}
simplest_catch := proc () {
    mut catched := false
    if I64.eq(1, 1) {
        throw AAAError()
    }
    assert(loc(), false) // This line should be unreachable
    catch (err: AAAError) {
        catched = true
    }
    assert(loc(), catched)
}
simplest_catch()

// Test catch block with error that has fields
ErrorWithMessage := struct {
    mut msg: Str = "default error message"
}

test_catch_with_fields := proc() {
    mut caught_msg := ""
    mut catched := false
    if I64.eq(1, 1) {
        my_error := ErrorWithMessage()
        throw my_error
    }
    catch (err: ErrorWithMessage) {
        caught_msg = err.msg
        catched = true
    }
    assert(loc(), catched)
    assert_eq_str(loc(), "default error message", caught_msg)
}
test_catch_with_fields()

// DivideByZero and safe_div are now in core/i64.til

unsafe_div := proc(a: I64, b: I64) returns I64 {
    result := a.safe_div(b)?

    catch (err: DivideByZero) {
        return 0
    }

    return result
}

test_unsafe_div := proc() {
    mut result := unsafe_div(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div()

unsafe_div2 := proc(a: I64, b: I64) returns I64 {
    res := a.safe_div(b)?
    assertm(loc(), false, "DivideByZero should have been thrown")
    catch (err: DivideByZero) {
        return 0
    }
    return res
}

test_unsafe_div2 := proc() {
    mut result := unsafe_div2(42, 0)
    // If we get here without panic, the catch worked
    assert_eq(loc(), 0, result)
}
test_unsafe_div2()

// Only the selecter error can be thrown
// REM Remove 'throws DivideByZero' to trigger a static type error
missing_throws := proc() throws DivideByZero {
    mut zero := 0 // REM mut so precomp doesn't catch the error at compile time
    _ := I64.safe_div(42, zero)?
}
// missing_throws() // REM Gives an error if uncommented

// All exceptions that are not catched must be declared in the throws section again
// TODO: We should have a way to signal which calls can throw? perhaps not if the compiler errors are good enough?
// perhaps try at the beginning of each statement that can throw or ? at the end
test_example_catch := proc() {
    a := 420
    mut b := 10
    mut catched := false

    // Test that division works when b is non-zero
    mut result1 := a.safe_div(b)?
    assert_eq(loc(), 42, result1)

    b = 0
    _result := I64.to_str(a.safe_div(b)?) // test declaration
    mut result2 := "0"
    result2 = I64.to_str(a.safe_div(b)?) // test assignment
    catch (err: DivideByZero) {
        catched = true
    }
    assert(loc(), catched)

    // a.safe_div(b) // REM this one is not catched nor example_catch throws anything, should give error
}
test_example_catch()

ErrorUndeclaredInFunc := struct {}
ErrorUndeclaredInMethod := struct {}
ErrorUndeclaredInAssoc := struct {}

another_func := proc() throws ErrorUndeclaredInFunc { // REM proc so precomp doesn't fold it
    throw ErrorUndeclaredInFunc()
}

SomeStruct := struct {
    some_method := func(_self: SomeStruct) throws ErrorUndeclaredInFunc {
        throw ErrorUndeclaredInFunc() // FIXED: the compiler now correctly tells us this error must be declared!
    }

    some_assoc := proc() throws ErrorUndeclaredInAssoc { // REM proc so precomp doesn't fold it
        throw ErrorUndeclaredInAssoc()
    }
}

// Remove things from the throws section to test the errors
undeclared_throws := proc() throws Str, I64, ErrorUndeclaredInAssoc, ErrorUndeclaredInFunc {
    if true {
        another_func()?
        catch (err: ErrorUndeclaredInFunc) {
            // Caught successfully
        }
    } else {
        throw "We can throw Str, but we have to declare it in throws"
    }
    while false {
        throw 69
    }
    SomeStruct.some_assoc()?
    ss := SomeStruct()
    ss.some_method()?

    // another_func() // REM if uncommented, should ask undeclared_throws to throws ErrorUndeclaredInFunc
}

test_undeclared_throws := proc() {
    mut catched_assoc := false

    undeclared_throws()?
    catch (err: ErrorUndeclaredInAssoc) {
        catched_assoc = true
    }
    catch (err: Str) {
    }
    catch (err: I64) {
    }
    catch (err: ErrorUndeclaredInFunc) {
    }

    assert(loc(), catched_assoc)
}
test_undeclared_throws()

// Test catching and printing Str errors
test_catch_str_error := proc() {
    mut caught := false
    mut error_msg := ""

    if I64.eq(1, 1) {
        throw "This is a test error message"
    }
    catch (err: Str) {
        caught = true
        println("Caught error:")
        println(err)
        error_msg = err
    }

    assert(loc(), caught)
    assert_eq_str(loc(), "This is a test error message", error_msg)
}
test_catch_str_error()

// Test catching errors with Str fields in structs
test_catch_error_with_str_field := proc() {
    mut caught := false
    mut caught_msg := ""

    if I64.eq(1, 1) {
        mut my_error := ErrorWithMessage()
        // Change the message before throwing
        my_error.msg = "Custom error message"
        throw my_error
    }
    catch (err: ErrorWithMessage) {
        caught = true
        // Test accessing Str field in caught struct
        println("Caught error with message:")
        println(err.msg)
        caught_msg = err.msg
    }

    assert(loc(), caught)
    assert_eq_str(loc(), "Custom error message", caught_msg)
}
test_catch_error_with_str_field()

// Test rethrowing error field as different type
// Note: takes dummy arg to prevent compile-time evaluation (precomp)
trigger_out_of_bounds := func(_dummy: I64) returns I64 throws Str {
    mut arr := Array.new(I64, 2)
    mut val := 0
    arr.get(10, val)?  // Intentionally out of bounds

    catch (err: OutOfBounds) {
        throw err.msg  // Rethrow the message field as Str
    }

    return 0
}

test_rethrow_error_field := proc() {
    mut caught := false
    mut error_msg := ""
    mut dummy := 0  // Use variable to prevent compile-time evaluation

    _ := trigger_out_of_bounds(dummy)?

    catch (err: Str) {
        caught = true
        error_msg = err
    }
    assert(loc(), caught)
    assert_eq_str(loc(), "src/core/array.til:43:42:Array.get: index out of bounds", error_msg)
}
test_rethrow_error_field()

// Test assigning error field to variable then throwing (Bug #29 regression)
// Note: takes dummy arg to prevent compile-time evaluation (precomp)
trigger_out_of_bounds_assign := func(_dummy: I64) returns I64 throws Str {
    mut arr := Array.new(I64, 2)
    mut val := 0
    arr.get(10, val)?

    catch (err: OutOfBounds) {
        msg := err.msg  // Assign to variable first
        throw msg
    }

    return 0
}

test_rethrow_error_field_via_assign := proc() {
    mut caught := false
    mut error_msg := ""
    mut dummy := 0  // Use variable to prevent compile-time evaluation

    _ := trigger_out_of_bounds_assign(dummy)?

    catch (err: Str) {
        caught = true
        error_msg = err
    }
    assert(loc(), caught)
    assert_eq_str(loc(), "src/core/array.til:43:42:Array.get: index out of bounds", error_msg)
}
test_rethrow_error_field_via_assign()

// ==============================================================================
// Bug #34 regression test: code AFTER catch must run in both success/error paths
// ==============================================================================

Bug34Error := struct {
    mut msg: Str = ""
}

bug34_maybe_throw := func(should_throw: Bool) throws Bug34Error {
    if should_throw {
        throw Bug34Error()
    }
}

// Test that code AFTER catch runs on success path
test_bug34_after_catch_success := proc() {
    mut after_catch_ran := false

    bug34_maybe_throw(false)?  // Does NOT throw
    catch (err: Bug34Error) {
        // Should not reach here
    }

    // Code AFTER catch - must run on success path
    after_catch_ran = true

    test(loc(), after_catch_ran, "Bug #34: code after catch must run on success")
}
test_bug34_after_catch_success()

// Test that code AFTER catch runs on error path (this was the bug)
test_bug34_after_catch_error := proc() {
    mut after_catch_ran := false

    bug34_maybe_throw(true)?   // DOES throw
    catch (err: Bug34Error) {
        // Error caught
    }

    // Code AFTER catch - Bug #34: this was NOT running when error was caught
    after_catch_ran = true

    test(loc(), after_catch_ran, "Bug #34: code after catch must run on error path")
}
test_bug34_after_catch_error()

// ==============================================================================
// Bug #34 remaining: code BETWEEN throwing call and catch must be skipped on error
// ==============================================================================

// Test that code BETWEEN throw and catch is skipped on error path
// Bug #34: when there's code between a throwing call and its catch block,
// ccodegen doesn't run the code after the catch.
//
// NOTE: This test FAILS with `rstil run` until Bug #34 is fixed!
mut bug34_between_test_completed := false

test_bug34_between_throw_and_catch := proc() {
    mut caught := false

    bug34_maybe_throw(true)?
    caught = false  // Code between - should NOT run on error path
    catch (err: Bug34Error) {
        caught = true
    }

    test(loc(), caught, "Bug #34: error should be caught")
    bug34_between_test_completed = true
}
test_bug34_between_throw_and_catch()
test(loc(), bug34_between_test_completed, "Bug #34: code after catch must run")

// Test that code BETWEEN throw and catch DOES run on success path
test_bug34_between_success := proc() {
    mut between_ran := false
    mut caught := false

    bug34_maybe_throw(false)?  // Does NOT throw
    between_ran = true        // This SHOULD run when no error
    catch (err: Bug34Error) {
        caught = true
    }

    test(loc(), not(caught), "Bug #34: no error should be caught on success")
    test(loc(), between_ran, "Bug #34: code between throw and catch must run on success")
}
test_bug34_between_success()

// ==============================================================================
// Bug #36: Throwing functions in struct literal parameters not recognized
// ==============================================================================

Bug36Error := struct {
    mut msg: Str = ""
}

Bug36TestData := struct {
    mut a: I64 = 0
    mut b: I64 = 0
}

// A function that throws
bug36_throws := proc(should_throw: Bool) returns I64 throws Bug36Error { // REM proc so precomp doesn't fold it
    if should_throw {
        throw Bug36Error(msg="test error")
    }
    return 42
}

// Bug #36: This function should compile without error.
// The compiler incorrectly said Bug36Error is declared but never thrown,
// because it didn't see the throwing function inside the struct literal.
bug36_test_throws_in_struct_literal := proc() returns Bug36TestData throws Bug36Error { // REM proc so precomp doesn't fold it
    return Bug36TestData(
        a=bug36_throws(true)?,
        b=bug36_throws(true)?
    )
}

test_bug36 := proc() {
    mut caught := false
    _result := bug36_test_throws_in_struct_literal()?
    // Should not reach here
    assert(loc(), false)

    catch (err: Bug36Error) {
        caught = true
    }

    test(loc(), caught, "Bug #36: throwing functions in struct literal params")
}
test_bug36()

// ==============================================================================
// Complex multi-catch tests for goto simplification (better34)
// ==============================================================================

// Test A: Non-consecutive catches with code between
TestErrorA := struct {}
TestErrorB := struct {}

throw_a_maybe := func(should_throw: Bool) throws TestErrorA {
    if should_throw {
        throw TestErrorA()
    }
}

throw_b_maybe := func(should_throw: Bool) throws TestErrorB {
    if should_throw {
        throw TestErrorB()
    }
}

test_non_consecutive_catches := proc() {
    mut after_a_ran := false
    mut after_b_ran := false
    mut caught_a := false
    mut caught_b := false

    throw_a_maybe(true)?  // throws TestErrorA
    after_a_ran = true   // should NOT run on error path
    catch (err: TestErrorA) {
        caught_a = true
    }

    throw_b_maybe(true)?  // throws TestErrorB
    after_b_ran = true   // should NOT run on error path
    catch (err: TestErrorB) {
        caught_b = true
    }

    test(loc(), not(after_a_ran), "code after throwing call A should not run")
    test(loc(), not(after_b_ran), "code after throwing call B should not run")
    test(loc(), caught_a, "TestErrorA should be caught")
    test(loc(), caught_b, "TestErrorB should be caught")
}
test_non_consecutive_catches()

// Test B: Caller/callee with different throw signatures
// callee2 throws A and B, callee1 only throws A (catches B internally)
CallerCalleeErrorA := struct {}
CallerCalleeErrorB := struct {}

callee2_throws_both := func(throw_a: Bool, throw_b: Bool) throws CallerCalleeErrorA, CallerCalleeErrorB {
    if throw_b {
        throw CallerCalleeErrorB()
    }
    if throw_a {
        throw CallerCalleeErrorA()
    }
}

// callee1 only exposes ErrorA, must catch ErrorB internally
callee1_throws_a_only := func(throw_a: Bool, throw_b: Bool) returns Bool throws CallerCalleeErrorA {
    mut after_callee2_ran := false
    mut caught_b := false

    callee2_throws_both(throw_a, throw_b)?
    after_callee2_ran = true  // should NOT run if callee2 throws
    catch (err: CallerCalleeErrorB) {
        caught_b = true
    }

    // Return whether ErrorB was caught (for verification)
    return caught_b
}

test_caller_callee_different_throws := proc() {
    mut after_callee1_ran := false
    mut caught_a := false

    // Test 1: callee2 throws B, which callee1 catches internally
    caught_b_internally := callee1_throws_a_only(false, true)?
    catch (err: CallerCalleeErrorA) {
    }
    test(loc(), caught_b_internally, "ErrorB should be caught internally by callee1")

    // Test 2: callee2 throws A, which propagates to caller
    after_callee1_ran = false
    caught_a = false
    _ := callee1_throws_a_only(true, false)?  // callee1 propagates A
    after_callee1_ran = true  // should NOT run
    catch (err: CallerCalleeErrorA) {
        caught_a = true
    }

    test(loc(), not(after_callee1_ran), "code after throwing call should not run")
    test(loc(), caught_a, "CallerCalleeErrorA should be caught in caller")
}
test_caller_callee_different_throws()

// Test C: Multiple throwing calls before single catch
MultiThrowError := struct {}

multi_throw_maybe := func(should_throw: Bool) throws MultiThrowError {
    if should_throw {
        throw MultiThrowError()
    }
}

test_multi_throw_single_catch := proc() {
    mut after_first_ran := false
    mut after_second_ran := false
    mut caught := false

    multi_throw_maybe(true)?   // throws MultiThrowError
    after_first_ran = true    // should NOT run if first throws
    multi_throw_maybe(false)?  // does NOT throw
    after_second_ran = true   // should NOT run because first already threw
    catch (err: MultiThrowError) {
        caught = true
    }

    test(loc(), not(after_first_ran), "code after first throw should not run")
    test(loc(), not(after_second_ran), "second call should not run after first throws")
    test(loc(), caught, "MultiThrowError should be caught")
}
test_multi_throw_single_catch()

// Test C variant: success path - all code should run when nothing throws
test_multi_throw_success := proc() {
    mut after_first_ran := false
    mut after_second_ran := false
    mut caught := false

    multi_throw_maybe(false)?  // does NOT throw
    after_first_ran = true    // SHOULD run
    multi_throw_maybe(false)?  // does NOT throw
    after_second_ran = true   // SHOULD run
    catch (err: MultiThrowError) {
        caught = true
    }

    test(loc(), after_first_ran, "code after success should run")
    test(loc(), after_second_ran, "second call should run after first succeeds")
    test(loc(), not(caught), "no error should be caught")
}
test_multi_throw_success()

// ==============================================================================
// TODO: Features that could be added to error handling
// ==============================================================================

// TODO: PanicError - special error type that can be thrown implicitly everywhere
// This would allow functions to panic without declaring throws PanicError
// Currently panic() is special-cased but doesn't actually throw
//
// Related: exit() is currently ext_func (not ext_proc) because funcs need a way to
// exit/panic without returning. With PanicError, funcs could throw it implicitly.
//
// PanicError := struct {
//     msg: Str = "panic"
//     location: Str = ""
// }
//
// test_implicit_panic := proc() {
//     // This should work without declaring throws PanicError
//     panic(loc(), "Something went wrong")
//     catch (err: PanicError) {
//         assert_eq_str(loc(), "Something went wrong", err.msg)
//     }
// }

// TODO: Multiple error types in a single catch chain
// Currently partially works - can have multiple catch blocks
// Could be improved with better syntax
//
// test_multiple_catches := proc() {
//     risky_operation()
//     catch (err: IOError) {
//         println("IO error: ", err.msg)
//     }
//     catch (err: ParseError) {
//         println("Parse error: ", err.msg)
//     }
//     catch (err: Str) {
//         println("String error: ", err)
//     }
// }

// TODO: Result<T, E> type (Rust-style)
// Alternative to throws - explicit error handling in return type
//
// Result := enum {
//     Ok: T,
//     Err: E,
// }
//
// safe_divide := func(a: I64, b: I64) returns Result<I64, DivideByZero> {
//     if eq(b, 0) {
//         return Result.Err(DivideByZero())
//     }
//     return Result.Ok(div(a, b))
// }
//
// test_result_type := proc() {
//     result := safe_divide(10, 2)
//     switch result {
//     case Result.Ok(value):
//         assert_eq(loc(), 5, value)
//     case Result.Err(err):
//         panic(loc(), "Should not error")
//     }
// }

// TODO: Rethrow keyword
// Currently have to manually throw again
//
// test_rethrow := proc() throws SomeError {
//     risky_operation()
//     catch (err: SomeError) {
//         println("Logging error before rethrow")
//         rethrow  // or: throw err
//     }
// }

// TODO: Try operator (? in Rust)
// Automatically propagate errors without explicit catch
//
// parse_and_compute := func(s: Str) returns I64 throws ParseError, ComputeError {
//     n := parse_number(s)?  // Auto-propagates ParseError
//     result := compute(n)?  // Auto-propagates ComputeError
//     return result
// }

// TODO: Finally blocks
// Cleanup code that runs whether error is thrown or not
//
// test_finally := proc() {
//     resource := acquire_resource()
//     try {
//         use_resource(resource)
//     }
//     catch (err: ResourceError) {
//         println("Error using resource")
//     }
//     finally {
//         release_resource(resource)  // Always runs
//     }
// }
