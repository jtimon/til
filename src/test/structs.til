mode test

MyEnum := enum {
    Red,
    Green,
    Blue,
}

MyStruct := struct {
    // TODO fix type inference in fields
    static_bool_field: Bool = true
    mut bool_field: Bool = false
    mut int_field: I64 = 0 // 0 is just the default, but you can set something else once in the init func
    mut string_field: Str = ""
    mut color_field: MyEnum = MyEnum.Red
    mut vec2_field: Vec2 = Vec2()

    // FIXED: Type checker now correctly catches these errors!
    // Commented out to allow tests to pass - these were intentionally buggy test cases
    // to_string := proc(self: MyStruct) returns Str {
    //     todo("implement MyStruct.to_string()")
    //     return ""
    // }
    //
    // unchecked_associated := func() returns I64 {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
    //
    // unchecked_method := func(ms: MyStruct) returns I64 {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
}

test_my_struct := proc() {
    test(loc(), MyStruct.static_bool_field, "MyStruct.static_bool_field is not true")

    v := Vec2(x=1, y=2)

    mut my_struct := MyStruct(
        bool_field=true,
        int_field=42,
        string_field="my field string",
        color_field=MyEnum.Green,
        vec2_field=v
    ) // with enum and struct field
    assert(loc(), my_struct.bool_field)
    assert_eq(loc(), 42, my_struct.int_field)
    assert_eq_str(loc(), "my field string", my_struct.string_field)
    res_vec2_field := my_struct.vec2_field
    assert_eq(loc(), 1, res_vec2_field.x)
    assert_eq(loc(), 2, res_vec2_field.y)
    assert_eq(loc(), 1, my_struct.vec2_field.x) // multiple dots for accessing fields
    assert_eq(loc(), 2, my_struct.vec2_field.y)

    // Test enum field reassignment
    my_struct.color_field = MyEnum.Blue

    // Assert enum field is Blue using a switch
    mut is_blue := false
    switch my_struct.color_field {
    case MyEnum.Blue: is_blue = true
    case: is_blue = false
    }
    assert(loc(), is_blue)

    // Switch statement to check runtime matching after assignment
    mut color_str := ""
    switch my_struct.color_field {
    case MyEnum.Red: color_str = "red"
    case MyEnum.Green: color_str = "green"
    case MyEnum.Blue: color_str = "blue"
    case: color_str = "unknown"
    }
    assert_eq_str(loc(), "blue", color_str)

    // MyStruct.unchecked_associated() // FIXME uncomment to test if associated functions are being checked
    // my_struct.unchecked_method() // FIXME uncomment to test if methods are being checked
}
test_my_struct()

EmptyStruct := struct {} // NOTE: empty struct instantiations are allowed
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

namespace Vec2 {
    add_all_coordinates := func(self: Vec2) returns I64 {
        return self.x.add(self.y)
    }
}

Vec3 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
    mut z : I64 = 0
}

// my_struct_type := MyStruct
// trying_dot_struct2 : Bool = MyStruct.bool_field.ccccc // TODO implement nested structs

test_structs := proc() {
    _my_empty_struct := EmptyStruct() // NOTE: empty instantiations are allowed
    my_vec2 := Vec2(x=40, y=2)
    assert_eq(loc(), 42, Vec2.add_all_coordinates(my_vec2)) // associated functions using fields
    assert_eq(loc(), 42, my_vec2.add_all_coordinates()) // associated functions can be used as methods (if the first argument matches the type)

    my_vec3 := Vec3(z=42)
    assert_eq(loc(), 42, my_vec3.z) // access to struct fields as arguments

    new_vec2 := Vec2(x=40, y=2)

    assert_eq(loc(), 40, my_vec2.x)
    assert_eq(loc(), 40, new_vec2.x)
    assert_eq(loc(),  2, new_vec2.y)
    assert_eq(loc(), 42, Vec2.add_all_coordinates(new_vec2))
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(new_vec2))

    another_vec2 := my_vec2 // make a copy
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(another_vec2))

    _my_i8 := U8()
    _my_bool := Bool() /// TODO truly self host Bool with an U8
    _my_i64 := I64() // TODO truly self host I64 with an [8]U8
    _my_string := Str()

}
test_structs()

// Test that struct default values maintain purity rules
// Default values can call funcs but not procs (to keep constructors pure)

pure_func := func() returns I64 {
    return 42
}

impure_proc := proc() returns I64 {
    println("Side effect!")
    return 99
}

// Test: Default values with funcs are OK
PurityTestStruct := struct {
    mut value1: I64 = 10
    mut value2: I64 = pure_func()  // OK: calling func
    mut value3: I64 = I64.add(20, 30)  // OK: calling func
}

// Test: Nested struct with func calls OK
InnerPurity := struct {
    mut x: I64 = pure_func()
}

OuterPurity := struct {
    mut inner: InnerPurity = InnerPurity()
    mut y: I64 = pure_func()
}

// Test: The following should fail type check (proc calls in defaults)
// Uncomment to test error detection:
//
// BadPurityStruct := struct {
//     mut bad_value: I64 = impure_proc()  // ERROR: calling proc
// }

// Test that struct member default values match their declared types

// Test 1: Correct types - should work
GoodStruct := struct {
    mut x: I64 = 42
    mut y: I64 = 100
}

// Test 2: Numeric literals can be assigned to U8
U8Struct := struct {
    mut byte1: U8 = 0
    mut byte2: U8 = 42
    mut byte3: U8 = 255
}

// Test 3: Function return types must match
returns_i64 := func() returns I64 {
    return 123
}

FuncReturnStruct := struct {
    mut value1: I64 = returns_i64()
}

test_struct_member_types := proc() {
    // Test purity
    mut purity := PurityTestStruct()
    assert_eq(loc(), 10, purity.value1)
    assert_eq(loc(), 42, purity.value2)
    assert_eq(loc(), 50, purity.value3)

    mut outer := OuterPurity()
    assert_eq(loc(), 42, outer.inner.x)
    assert_eq(loc(), 42, outer.y)

    // Test type matching
    mut good := GoodStruct()
    assert_eq(loc(), 42, good.x)
    assert_eq(loc(), 100, good.y)

    mut u8_test := U8Struct()
    assert_eq(loc(), 0, U8.to_i64(u8_test.byte1))
    assert_eq(loc(), 42, U8.to_i64(u8_test.byte2))
    assert_eq(loc(), 255, U8.to_i64(u8_test.byte3))

    mut func_test := FuncReturnStruct()
    assert_eq(loc(), 123, func_test.value1)

    // Test 4: The following should fail type check (wrong literal type)
    // Uncomment to test error detection:
    //
    // BadStruct1 := struct {
    //     mut x: I64 = "not a number"  // ERROR: Str assigned to I64
    // }

    // Test 5: The following should fail type check (wrong function return type)
    // Uncomment to test error detection:
    //
    // returns_str := func() returns Str {
    //     return "string result"
    // }
    //
    // BadStruct2 := struct {
    //     mut x: I64 = returns_str()  // ERROR: Str assigned to I64
    // }

    // Test 6: The following should fail (non-literal I64 to U8 not allowed)
    // Uncomment to test error detection:
    //
    // BadStruct3 := struct {
    //     mut byte: U8 = returns_i64()  // ERROR: I64 func result can't convert to U8
    // }
}
test_struct_member_types()

// Test that "self" is just a convention - associated functions can use any parameter name
// and can be called either as Type.function(instance) or instance.function()
TestAssociatedFunctions := struct {
    mut value: I64 = 0
}

namespace TestAssociatedFunctions {
    // Using "self" as parameter name (conventional)
    get_value_self := func(self: TestAssociatedFunctions) returns I64 {
        return self.value
    }

    // Using "urmum" as parameter name (unconventional but valid)
    get_value_urmum := func(urmum: TestAssociatedFunctions) returns I64 {
        return urmum.value
    }

    // Using "instance" as parameter name
    get_value_instance := func(instance: TestAssociatedFunctions) returns I64 {
        return instance.value
    }

    // Type parameter doesn't have to be first - but then UFCS won't work for it
    add_with_instance_last := func(amount: I64, instance: TestAssociatedFunctions) returns I64 {
        return instance.value.add(amount)
    }

    // Type parameter in the middle
    add_with_instance_middle := func(amount1: I64, instance: TestAssociatedFunctions, amount2: I64) returns I64 {
        return instance.value.add(amount1).add(amount2)
    }
}

test_associated_function_names := proc() {
    mut obj := TestAssociatedFunctions()
    obj.value = 42

    // All of these work the same way with UFCS (dot syntax)
    assert_eq(loc(), 42, obj.get_value_self())
    assert_eq(loc(), 42, obj.get_value_urmum())
    assert_eq(loc(), 42, obj.get_value_instance())

    // All of these work when called as Type.function(instance)
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_self(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_urmum(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_instance(obj))

    // UFCS only works when the instance type matches the FIRST parameter
    // These DON'T work with UFCS because instance is not first:
    // assert_eq(loc(), 52, obj.add_with_instance_last(10))       // ERROR: would pass obj as first arg (amount), not instance
    // assert_eq(loc(), 52, obj.add_with_instance_middle(5, 5))   // ERROR: would pass obj as first arg (amount1), not instance

    // But we can still call them the long way (Type.function(args))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_last(10, obj))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_middle(5, obj, 5))
}
test_associated_function_names()

// === Struct Literals Tests ===
// Struct instantiation with named field values

test_struct_literals := proc() {
    // Default constructor (already works)
    p1 := Vec2()
    assert_eq(loc(), 0, p1.x)
    assert_eq(loc(), 0, p1.y)

    // Struct literal with all fields
    p2 := Vec2(x=10, y=20)
    assert_eq(loc(), 10, p2.x)
    assert_eq(loc(), 20, p2.y)

    // Partial struct literal (uses defaults for omitted fields)
    p3 := Vec2(y=5)
    assert_eq(loc(), 0, p3.x)
    assert_eq(loc(), 5, p3.y)

    // Struct literal with fields in different order
    p4 := Vec2(y=100, x=50)
    assert_eq(loc(), 50, p4.x)
    assert_eq(loc(), 100, p4.y)

    // Vec3 with partial fields
    v3 := Vec3(z=42)
    assert_eq(loc(), 0, v3.x)
    assert_eq(loc(), 0, v3.y)
    assert_eq(loc(), 42, v3.z)

    // All fields for Vec3
    v3b := Vec3(x=1, y=2, z=3)
    assert_eq(loc(), 1, v3b.x)
    assert_eq(loc(), 2, v3b.y)
    assert_eq(loc(), 3, v3b.z)
}
test_struct_literals()

// === Bug #32: Chained field access after function/method calls ===
// After a function/method call returns a struct, we should be able to access its fields

ChainedInner := struct {
    mut value: I64 = 42
}

get_chained_inner := func() returns ChainedInner {
    return ChainedInner()
}

test_chained_field_access := proc() {
    // After get_chained_inner() returns ChainedInner, access .value
    result := get_chained_inner().value
    assert_eq(loc(), 42, result)

    // Chained field access followed by method call
    result2 := get_chained_inner().value.eq(42)
    test(loc(), result2, "chained field then method should work")
}
test_chained_field_access()
