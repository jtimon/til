mode test

MyEnum := enum {
    Red,
    Green,
    Blue,
}

MyStruct := struct {
    // TODO fix type inference in fields
    static_bool_field: Bool = true
    mut bool_field: Bool = false
    mut int_field: I64 = 0 // 0 is just the default, but you can set something else once in the init func
    mut string_field: Str = ""
    mut color_field: MyEnum = MyEnum.Red
    mut vec2_field: Vec2 = Vec2()

    new := proc(bool_field: Bool, int_field: I64, string_field: Str, color_field: MyEnum, vec2_field: Vec2) returns MyStruct {
        mut self := MyStruct()
        self.bool_field = bool_field
        self.int_field = int_field
        self.string_field = string_field
        self.color_field = color_field
        self.vec2_field = vec2_field
        return self
    }

    // FIXED: Type checker now correctly catches these errors!
    // Commented out to allow tests to pass - these were intentionally buggy test cases
    // to_string := proc(self: MyStruct) returns Str {
    //     todo("implement MyStruct.to_string()")
    //     return ""
    // }
    //
    // unchecked_associated := func() returns I64 {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
    //
    // unchecked_method := func(ms: MyStruct) returns I64 {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
}

test_my_struct := proc() {
    test(loc(), MyStruct.static_bool_field, "MyStruct.static_bool_field is not true")

    mut v := Vec2()
    v.x = 1
    v.y = 2

    mut my_struct := MyStruct.new(true, 42, "my field string", MyEnum.Green, v) // with enum and struct field
    assert(loc(), my_struct.bool_field)
    assert_eq(loc(), 42, my_struct.int_field)
    assert_eq_str(loc(), "my field string", my_struct.string_field)
    res_vec2_field := my_struct.vec2_field
    assert_eq(loc(), 1, res_vec2_field.x)
    assert_eq(loc(), 2, res_vec2_field.y)
    assert_eq(loc(), 1, my_struct.vec2_field.x) // multiple dots for accessing fields
    assert_eq(loc(), 2, my_struct.vec2_field.y)

    // Test enum field reassignment
    my_struct.color_field = MyEnum.Blue

    // Assert enum field is Blue using a switch
    mut is_blue := false
    switch my_struct.color_field {
    case MyEnum.Blue: is_blue = true
    case: is_blue = false
    }
    assert(loc(), is_blue)

    // Switch statement to check runtime matching after assignment
    mut color_str := ""
    switch my_struct.color_field {
    case MyEnum.Red: color_str = "red"
    case MyEnum.Green: color_str = "green"
    case MyEnum.Blue: color_str = "blue"
    case: color_str = "unknown"
    }
    assert_eq_str(loc(), "blue", color_str)

    // MyStruct.unchecked_associated() // FIXME uncomment to test if associated functions are being checked
    // my_struct.unchecked_method() // FIXME uncomment to test if methods are being checked
}
test_my_struct()

EmptyStruct := struct {} // NOTE: empty struct instantiations are allowed
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    new := proc(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }

    add_all_coordinates := func(self: Vec2) returns I64 {
        return add(self.x, self.y)
    }
}

Vec3 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
    mut z : I64 = 0
}

// my_struct_type := MyStruct
// trying_dot_struct2 : Bool = MyStruct.bool_field.ccccc // TODO implement nested structs

test_structs := proc() {
    my_empty_struct := EmptyStruct() // NOTE: empty instantiations are allowed
    mut my_vec2 := Vec2()
    my_vec2.x = 40
    my_vec2.y =  2
    assert_eq(loc(), 42, Vec2.add_all_coordinates(my_vec2)) // associated functions using fields
    assert_eq(loc(), 42, my_vec2.add_all_coordinates()) // associated functions can be used as methods (if the first argument matches the type)

    mut my_vec3 := Vec3()
    my_vec3.z = 42
    assert_eq(loc(), 42, my_vec3.z) // access to struct fields as arguments

    new_vec2 := Vec2.new(40, 2)

    assert_eq(loc(), 40, my_vec2.x)
    assert_eq(loc(), 40, new_vec2.x)
    assert_eq(loc(),  2, new_vec2.y)
    assert_eq(loc(), 42, Vec2.add_all_coordinates(new_vec2))
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(new_vec2))

    another_vec2 := my_vec2 // make a copy
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(another_vec2))

    my_i8 := U8()
    my_bool := Bool() /// TODO truly self host Bool with an U8
    my_i64 := I64() // TODO truly self host I64 with an [8]U8
    my_string := Str()

}
test_structs()

// Test that struct default values maintain purity rules
// Default values can call funcs but not procs (to keep constructors pure)

pure_func := func() returns I64 {
    return 42
}

impure_proc := proc() returns I64 {
    println("Side effect!")
    return 99
}

// Test: Default values with funcs are OK
PurityTestStruct := struct {
    mut value1: I64 = 10
    mut value2: I64 = pure_func()  // OK: calling func
    mut value3: I64 = add(20, 30)  // OK: calling func
}

// Test: Nested struct with func calls OK
InnerPurity := struct {
    mut x: I64 = pure_func()
}

OuterPurity := struct {
    mut inner: InnerPurity = InnerPurity()
    mut y: I64 = pure_func()
}

// Test: The following should fail type check (proc calls in defaults)
// Uncomment to test error detection:
//
// BadPurityStruct := struct {
//     mut bad_value: I64 = impure_proc()  // ERROR: calling proc
// }

// Test that struct member default values match their declared types

// Test 1: Correct types - should work
GoodStruct := struct {
    mut x: I64 = 42
    mut y: I64 = 100
}

// Test 2: Numeric literals can be assigned to U8
U8Struct := struct {
    mut byte1: U8 = 0
    mut byte2: U8 = 42
    mut byte3: U8 = 255
}

// Test 3: Function return types must match
returns_i64 := func() returns I64 {
    return 123
}

FuncReturnStruct := struct {
    mut value1: I64 = returns_i64()
}

test_struct_member_types := proc() {
    // Test purity
    mut purity := PurityTestStruct()
    assert_eq(loc(), 10, purity.value1)
    assert_eq(loc(), 42, purity.value2)
    assert_eq(loc(), 50, purity.value3)

    mut outer := OuterPurity()
    assert_eq(loc(), 42, outer.inner.x)
    assert_eq(loc(), 42, outer.y)

    // Test type matching
    mut good := GoodStruct()
    assert_eq(loc(), 42, good.x)
    assert_eq(loc(), 100, good.y)

    mut u8_test := U8Struct()
    assert_eq(loc(), 0, U8.to_i64(u8_test.byte1))
    assert_eq(loc(), 42, U8.to_i64(u8_test.byte2))
    assert_eq(loc(), 255, U8.to_i64(u8_test.byte3))

    mut func_test := FuncReturnStruct()
    assert_eq(loc(), 123, func_test.value1)

    // Test 4: The following should fail type check (wrong literal type)
    // Uncomment to test error detection:
    //
    // BadStruct1 := struct {
    //     mut x: I64 = "not a number"  // ERROR: Str assigned to I64
    // }

    // Test 5: The following should fail type check (wrong function return type)
    // Uncomment to test error detection:
    //
    // returns_str := func() returns Str {
    //     return "string result"
    // }
    //
    // BadStruct2 := struct {
    //     mut x: I64 = returns_str()  // ERROR: Str assigned to I64
    // }

    // Test 6: The following should fail (non-literal I64 to U8 not allowed)
    // Uncomment to test error detection:
    //
    // BadStruct3 := struct {
    //     mut byte: U8 = returns_i64()  // ERROR: I64 func result can't convert to U8
    // }
}
test_struct_member_types()

// Test that "self" is just a convention - associated functions can use any parameter name
// and can be called either as Type.function(instance) or instance.function()
TestAssociatedFunctions := struct {
    mut value: I64 = 0

    // Using "self" as parameter name (conventional)
    get_value_self := func(self: TestAssociatedFunctions) returns I64 {
        return self.value
    }

    // Using "urmum" as parameter name (unconventional but valid)
    get_value_urmum := func(urmum: TestAssociatedFunctions) returns I64 {
        return urmum.value
    }

    // Using "instance" as parameter name
    get_value_instance := func(instance: TestAssociatedFunctions) returns I64 {
        return instance.value
    }

    // Type parameter doesn't have to be first - but then UFCS won't work for it
    add_with_instance_last := func(amount: I64, instance: TestAssociatedFunctions) returns I64 {
        return add(instance.value, amount)
    }

    // Type parameter in the middle
    add_with_instance_middle := func(amount1: I64, instance: TestAssociatedFunctions, amount2: I64) returns I64 {
        return add(add(instance.value, amount1), amount2)
    }
}

test_associated_function_names := proc() {
    mut obj := TestAssociatedFunctions()
    obj.value = 42

    // All of these work the same way with UFCS (dot syntax)
    assert_eq(loc(), 42, obj.get_value_self())
    assert_eq(loc(), 42, obj.get_value_urmum())
    assert_eq(loc(), 42, obj.get_value_instance())

    // All of these work when called as Type.function(instance)
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_self(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_urmum(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_instance(obj))

    // UFCS only works when the instance type matches the FIRST parameter
    // These DON'T work with UFCS because instance is not first:
    // assert_eq(loc(), 52, obj.add_with_instance_last(10))       // ERROR: would pass obj as first arg (amount), not instance
    // assert_eq(loc(), 52, obj.add_with_instance_middle(5, 5))   // ERROR: would pass obj as first arg (amount1), not instance

    // But we can still call them the long way (Type.function(args))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_last(10, obj))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_middle(5, obj, 5))
}
test_associated_function_names()
