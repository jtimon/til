mode test

MyEnum := enum {
    Red,
    Green,
    Blue,
}

MyStruct := struct {
    // TODO fix type inference in fields
    static_bool_field: Bool = true
    mut bool_field: Bool = false
    mut int_field: I64 = 0 // 0 is just the default, but you can set something else once in the init func
    mut string_field: Str = ""
    mut color_field: MyEnum = MyEnum.Red
    mut vec2_field: Vec2 = Vec2()

    // FIXED: Type checker now correctly catches these errors!
    // Commented out to allow tests to pass - these were intentionally buggy test cases
    // to_string : proc(self: MyStruct) returns Str = {
    //     todo("implement MyStruct.to_string()")
    //     return ""
    // }
    //
    // unchecked_associated : func() returns I64 = {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
    //
    // unchecked_method : func(ms: MyStruct) returns I64 = {
    //     return my_undefined_symbol // FIXED: Now caught at type checking phase!
    // }
}

test_my_struct : proc() = {
    test(loc(), MyStruct.static_bool_field, "MyStruct.static_bool_field is not true")

    v := Vec2(x=1, y=2)

    mut my_struct := MyStruct(
        bool_field=true,
        int_field=42,
        string_field="my field string",
        color_field=MyEnum.Green,
        vec2_field=v
    ) // with enum and struct field
    assert(loc(), my_struct.bool_field)
    assert_eq(loc(), 42, my_struct.int_field)
    assert_eq_str(loc(), "my field string", my_struct.string_field)
    res_vec2_field := my_struct.vec2_field
    assert_eq(loc(), 1, res_vec2_field.x)
    assert_eq(loc(), 2, res_vec2_field.y)
    assert_eq(loc(), 1, my_struct.vec2_field.x) // multiple dots for accessing fields
    assert_eq(loc(), 2, my_struct.vec2_field.y)

    // Test enum field reassignment
    my_struct.color_field = MyEnum.Blue

    // Assert enum field is Blue using a switch
    mut is_blue := false
    switch my_struct.color_field {
    case MyEnum.Blue: is_blue = true
    case: is_blue = false
    }
    assert(loc(), is_blue)

    // Switch statement to check runtime matching after assignment
    mut color_str := ""
    switch my_struct.color_field {
    case MyEnum.Red: color_str = "red"
    case MyEnum.Green: color_str = "green"
    case MyEnum.Blue: color_str = "blue"
    case: color_str = "unknown"
    }
    assert_eq_str(loc(), "blue", color_str)

    // MyStruct.unchecked_associated() // FIXME uncomment to test if associated functions are being checked
    // my_struct.unchecked_method() // FIXME uncomment to test if methods are being checked
}
test_my_struct()

EmptyStruct := struct {} // NOTE: empty struct instantiations are allowed
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

namespace:
    add_all_coordinates : func(self: Vec2) returns I64 = {
        return self.x.add(self.y)
    }
}

Vec3 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
    mut z : I64 = 0
}

// my_struct_type := MyStruct
// trying_dot_struct2 : Bool = MyStruct.bool_field.ccccc // TODO implement nested structs

test_structs : proc() = {
    _my_empty_struct := EmptyStruct() // NOTE: empty instantiations are allowed
    my_vec2 := Vec2(x=40, y=2)
    assert_eq(loc(), 42, Vec2.add_all_coordinates(my_vec2)) // associated functions using fields
    assert_eq(loc(), 42, my_vec2.add_all_coordinates()) // associated functions can be used as methods (if the first argument matches the type)

    my_vec3 := Vec3(z=42)
    assert_eq(loc(), 42, my_vec3.z) // access to struct fields as arguments

    new_vec2 := Vec2(x=40, y=2)

    assert_eq(loc(), 40, my_vec2.x)
    assert_eq(loc(), 40, new_vec2.x)
    assert_eq(loc(),  2, new_vec2.y)
    assert_eq(loc(), 42, Vec2.add_all_coordinates(new_vec2))
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(new_vec2))

    another_vec2 := my_vec2 // make a copy
    assert_eq(loc(), Vec2.add_all_coordinates(my_vec2), Vec2.add_all_coordinates(another_vec2))

    _my_i8 := U8()
    _my_bool := Bool() /// TODO truly self host Bool with an U8
    _my_i64 := I64() // TODO truly self host I64 with an [8]U8
    _my_string := Str()

}
test_structs()

// Test that struct default values maintain purity rules
// Default values can call funcs but not procs (to keep constructors pure)

pure_func : func() returns I64 = {
    return 42
}

impure_proc : proc() returns I64 = {
    println("Side effect!")
    return 99
}

// Test: Default values with funcs are OK
PurityTestStruct := struct {
    mut value1: I64 = 10
    mut value2: I64 = pure_func()  // OK: calling func
    mut value3: I64 = I64.add(20, 30)  // OK: calling func
}

// Test: Nested struct with func calls OK
InnerPurity := struct {
    mut x: I64 = pure_func()
}

OuterPurity := struct {
    mut inner: InnerPurity = InnerPurity()
    mut y: I64 = pure_func()
}

// Test: The following should fail type check (proc calls in defaults)
// Uncomment to test error detection:
//
// BadPurityStruct := struct {
//     mut bad_value: I64 = impure_proc()  // ERROR: calling proc
// }

// Test that struct member default values match their declared types

// Test 1: Correct types - should work
GoodStruct := struct {
    mut x: I64 = 42
    mut y: I64 = 100
}

// Test 2: Numeric literals can be assigned to U8
U8Struct := struct {
    mut byte1: U8 = 0
    mut byte2: U8 = 42
    mut byte3: U8 = 255
}

// Test 3: Function return types must match
returns_i64 : func() returns I64 = {
    return 123
}

FuncReturnStruct := struct {
    mut value1: I64 = returns_i64()
}

test_struct_member_types : proc() = {
    // Test purity
    mut purity := PurityTestStruct()
    assert_eq(loc(), 10, purity.value1)
    assert_eq(loc(), 42, purity.value2)
    assert_eq(loc(), 50, purity.value3)

    mut outer := OuterPurity()
    assert_eq(loc(), 42, outer.inner.x)
    assert_eq(loc(), 42, outer.y)

    // Test type matching
    mut good := GoodStruct()
    assert_eq(loc(), 42, good.x)
    assert_eq(loc(), 100, good.y)

    mut u8_test := U8Struct()
    assert_eq(loc(), 0, U8.to_i64(u8_test.byte1))
    assert_eq(loc(), 42, U8.to_i64(u8_test.byte2))
    assert_eq(loc(), 255, U8.to_i64(u8_test.byte3))

    mut func_test := FuncReturnStruct()
    assert_eq(loc(), 123, func_test.value1)

    // Test 4: The following should fail type check (wrong literal type)
    // Uncomment to test error detection:
    //
    // BadStruct1 := struct {
    //     mut x: I64 = "not a number"  // ERROR: Str assigned to I64
    // }

    // Test 5: The following should fail type check (wrong function return type)
    // Uncomment to test error detection:
    //
    // returns_str : func() returns Str = {
    //     return "string result"
    // }
    //
    // BadStruct2 := struct {
    //     mut x: I64 = returns_str()  // ERROR: Str assigned to I64
    // }

    // Test 6: The following should fail (non-literal I64 to U8 not allowed)
    // Uncomment to test error detection:
    //
    // BadStruct3 := struct {
    //     mut byte: U8 = returns_i64()  // ERROR: I64 func result can't convert to U8
    // }
}
test_struct_member_types()

// Test that "self" is just a convention - associated functions can use any parameter name
// and can be called either as Type.function(instance) or instance.function()
TestAssociatedFunctions := struct {
    mut value: I64 = 0

namespace:
    // Using "self" as parameter name (conventional)
    get_value_self : func(self: TestAssociatedFunctions) returns I64 = {
        return self.value
    }

    // Using "urmum" as parameter name (unconventional but valid)
    get_value_urmum : func(urmum: TestAssociatedFunctions) returns I64 = {
        return urmum.value
    }

    // Using "instance" as parameter name
    get_value_instance : func(instance: TestAssociatedFunctions) returns I64 = {
        return instance.value
    }

    // Type parameter doesn't have to be first - but then UFCS won't work for it
    add_with_instance_last : func(amount: I64, instance: TestAssociatedFunctions) returns I64 = {
        return instance.value.add(amount)
    }

    // Type parameter in the middle
    add_with_instance_middle : func(amount1: I64, instance: TestAssociatedFunctions, amount2: I64) returns I64 = {
        return instance.value.add(amount1).add(amount2)
    }
}

test_associated_function_names : proc() = {
    mut obj := TestAssociatedFunctions()
    obj.value = 42

    // All of these work the same way with UFCS (dot syntax)
    assert_eq(loc(), 42, obj.get_value_self())
    assert_eq(loc(), 42, obj.get_value_urmum())
    assert_eq(loc(), 42, obj.get_value_instance())

    // All of these work when called as Type.function(instance)
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_self(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_urmum(obj))
    assert_eq(loc(), 42, TestAssociatedFunctions.get_value_instance(obj))

    // UFCS only works when the instance type matches the FIRST parameter
    // These DON'T work with UFCS because instance is not first:
    // assert_eq(loc(), 52, obj.add_with_instance_last(10))       // ERROR: would pass obj as first arg (amount), not instance
    // assert_eq(loc(), 52, obj.add_with_instance_middle(5, 5))   // ERROR: would pass obj as first arg (amount1), not instance

    // But we can still call them the long way (Type.function(args))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_last(10, obj))
    assert_eq(loc(), 52, TestAssociatedFunctions.add_with_instance_middle(5, obj, 5))
}
test_associated_function_names()

// === Struct Literals Tests ===
// Struct instantiation with named field values

test_struct_literals : proc() = {
    // Default constructor (already works)
    p1 := Vec2()
    assert_eq(loc(), 0, p1.x)
    assert_eq(loc(), 0, p1.y)

    // Struct literal with all fields
    p2 := Vec2(x=10, y=20)
    assert_eq(loc(), 10, p2.x)
    assert_eq(loc(), 20, p2.y)

    // Partial struct literal (uses defaults for omitted fields)
    p3 := Vec2(y=5)
    assert_eq(loc(), 0, p3.x)
    assert_eq(loc(), 5, p3.y)

    // Struct literal with fields in different order
    p4 := Vec2(y=100, x=50)
    assert_eq(loc(), 50, p4.x)
    assert_eq(loc(), 100, p4.y)

    // Vec3 with partial fields
    v3 := Vec3(z=42)
    assert_eq(loc(), 0, v3.x)
    assert_eq(loc(), 0, v3.y)
    assert_eq(loc(), 42, v3.z)

    // All fields for Vec3
    v3b := Vec3(x=1, y=2, z=3)
    assert_eq(loc(), 1, v3b.x)
    assert_eq(loc(), 2, v3b.y)
    assert_eq(loc(), 3, v3b.z)
}
test_struct_literals()

// === Bug #32: Chained field access after function/method calls ===
// After a function/method call returns a struct, we should be able to access its fields

ChainedInner := struct {
    mut value: I64 = 42
}

get_chained_inner : func() returns ChainedInner = {
    return ChainedInner()
}

test_chained_field_access : proc() = {
    // After get_chained_inner() returns ChainedInner, access .value
    result := get_chained_inner().value
    assert_eq(loc(), 42, result)

    // Chained field access followed by method call
    result2 := get_chained_inner().value.eq(42)
    test(loc(), result2, "chained field then method should work")
}
test_chained_field_access()

// === Issue #105: First-class structs (macro-returned struct definitions) ===

// Macro that returns a simple struct definition
make_point : macro() returns struct = {
    return struct {
        mut x: I64 = 0
        mut y: I64 = 0
    }
}

Point := make_point()

// Macro returning a struct with mixed field types
make_config : macro() returns struct = {
    return struct {
        mut width: I64 = 800
        mut height: I64 = 600
        mut title: Str = "untitled"
    }
}

Config := make_config()

// TODO #105: Immutable-only fields from macro fail in compiled mode
// Codegen doesn't emit constants for macro-expanded structs
// make_constants : macro() returns struct = {
//     return struct {
//         pi_approx: I64 = 3
//         e_approx: I64 = 2
//     }
// }
// MathConsts := make_constants()

// TODO #105: Macro parameters in struct defaults fail
// Init type-checks struct literal inside macro body before macro expansion,
// so macro params are "undefined symbol"
// make_pair_with_default : macro(default_val: I64) returns struct = {
//     return struct {
//         mut first: I64 = default_val
//         mut second: I64 = default_val
//     }
// }
// DefaultPair := make_pair_with_default(42)

// TODO #105: Namespace blocks on macro-defined structs fail
// Init processes namespaces before macro expansion, so struct isn't registered yet
// make_vec2 : macro() returns struct = {
//     return struct {
//         mut x: I64 = 0
//         mut y: I64 = 0
//     }
// }
// MyVec2 := make_vec2()
// namespace MyVec2 {
//     sum : func(self: MyVec2) returns I64 = {
//         return self.x.add(self.y)
//     }
// }

test_first_class_structs : proc() = {
    // Basic: macro-defined struct works like a normal struct
    p := Point()
    assert_eq(loc(), 0, p.x)
    assert_eq(loc(), 0, p.y)

    // Struct literal with named fields
    p2 := Point(x=10, y=20)
    assert_eq(loc(), 10, p2.x)
    assert_eq(loc(), 20, p2.y)

    // Partial struct literal
    p3 := Point(y=42)
    assert_eq(loc(), 0, p3.x)
    assert_eq(loc(), 42, p3.y)

    // Macro with mixed field types
    c := Config()
    assert_eq(loc(), 800, c.width)
    assert_eq(loc(), 600, c.height)
    assert_eq_str(loc(), "untitled", c.title)

    // Override defaults
    c2 := Config(width=1920, height=1080, title="my app")
    assert_eq(loc(), 1920, c2.width)
    assert_eq(loc(), 1080, c2.height)
    assert_eq_str(loc(), "my app", c2.title)

    // TODO #105: re-enable when immutable-only fields work in compiled mode
    // assert_eq(loc(), 3, MathConsts.pi_approx)
    // assert_eq(loc(), 2, MathConsts.e_approx)

    // Mutable fields: assignment works
    mut p4 := Point(x=1, y=2)
    p4.x = 100
    assert_eq(loc(), 100, p4.x)
    assert_eq(loc(), 2, p4.y)

    // TODO #105: re-enable when macro params in struct defaults work
    // p5 := DefaultPair()
    // assert_eq(loc(), 42, p5.first)
    // assert_eq(loc(), 42, p5.second)

    // TODO #105: re-enable when namespace blocks on macro-defined structs work
    // v := MyVec2(x=3, y=4)
    // assert_eq(loc(), 7, v.sum())
}
test_first_class_structs()

// Issue #105: Anonymous struct expressions
test_anonymous_structs := proc() {
    // Anonymous type definition
    P := struct { mut x: I64 = 10 }
    inst := P()
    assert_eq(loc(), 10, inst.x)

    // Anonymous instantiation with named args
    q := struct { mut x: I64 = 0 }(x=42)
    assert_eq(loc(), 42, q.x)

    // Anonymous instantiation with defaults
    r := struct { mut x: I64 = 99, mut y: I64 = 77 }()
    assert_eq(loc(), 99, r.x)
    assert_eq(loc(), 77, r.y)

    // Anonymous instantiation with partial override
    s := struct { mut x: I64 = 0, mut y: I64 = 0 }(x=5)
    assert_eq(loc(), 5, s.x)
    assert_eq(loc(), 0, s.y)
}
test_anonymous_structs()

// Issue #161: mutable static namespace variable (struct)
Counter161 := struct {
namespace:
    mut next_id := 0
}

test_ns_mut_struct := proc() = {
    assert_eq(loc(), 0, Counter161.next_id)
    Counter161.next_id = 1
    assert_eq(loc(), 1, Counter161.next_id)
    Counter161.next_id = Counter161.next_id.add(1)
    assert_eq(loc(), 2, Counter161.next_id)
}
test_ns_mut_struct()
