mode test

// Test basic StrMap operations

test_map_new := proc() {
    m := StrMap.new()
    assert_eq(loc(), 0, m.len())

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
}
test_map_new()

test_map_insert_and_get := proc() {
    mut m := StrMap.new()

    // Insert some key-value pairs
    m.insert("name", "Alice")
    m.insert("age", "30")
    m.insert("city", "NYC")

    assert_eq(loc(), 3, m.len())

    // Get values
    name := m.get("name")
    assert(loc(), name.eq("Alice"))

    age := m.get("age")
    assert(loc(), age.eq("30"))

    city := m.get("city")
    assert(loc(), city.eq("NYC"))

    // Get non-existent key returns empty string
    missing := m.get("missing")
    assert(loc(), missing.eq(""))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_insert_and_get()

test_map_update := proc() {
    mut m := StrMap.new()

    // Insert initial value
    m.insert("color", "red")
    color := m.get("color")
    assert(loc(), color.eq("red"))
    assert_eq(loc(), 1, m.len())

    // Update same key
    m.insert("color", "blue")
    color2 := m.get("color")
    assert(loc(), color2.eq("blue"))
    assert_eq(loc(), 1, m.len())  // Size should not increase

    // Update again
    m.insert("color", "green")
    color3 := m.get("color")
    assert(loc(), color3.eq("green"))
    assert_eq(loc(), 1, m.len())

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_update()

test_map_contains_key := proc() {
    mut m := StrMap.new()

    m.insert("foo", "bar")
    m.insert("baz", "qux")

    assert(loc(), m.contains_key("foo"))
    assert(loc(), m.contains_key("baz"))
    assert(loc(), not(m.contains_key("missing")))
    assert(loc(), not(m.contains_key("")))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_contains_key()

test_map_position := proc() {
    mut m := StrMap.new()

    // Test insertion order is preserved
    m.insert("first", "1")
    m.insert("second", "2")
    m.insert("third", "3")

    // Position should match insertion order
    assert_eq(loc(), 0, m.position("first"))
    assert_eq(loc(), 1, m.position("second"))
    assert_eq(loc(), 2, m.position("third"))

    // Non-existent key returns -1
    neg_one := sub(0, 1)
    assert_eq(loc(), neg_one, m.position("missing"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_position()

test_map_enum_use_case := proc() {
    mut enum_map := StrMap.new()

    // Simulate enum variant storage (like HashMap<String, Option<ValueType>>)
    // For now we'll use empty string to mean None, and type name for Some(type)
    enum_map.insert("Red", "")        // No payload
    enum_map.insert("Green", "Bool")  // Bool payload
    enum_map.insert("Blue", "I64")    // I64 payload
    enum_map.insert("Name", "Str")    // Str payload

    // Check we can get variant positions (for enum tags)
    assert_eq(loc(), 0, enum_map.position("Red"))
    assert_eq(loc(), 1, enum_map.position("Green"))
    assert_eq(loc(), 2, enum_map.position("Blue"))
    assert_eq(loc(), 3, enum_map.position("Name"))

    // Check payload types
    payload_type := enum_map.get("Red")
    assert(loc(), payload_type.eq(""))

    payload_type2 := enum_map.get("Green")
    assert(loc(), payload_type2.eq("Bool"))

    payload_type3 := enum_map.get("Blue")
    assert(loc(), payload_type3.eq("I64"))

    payload_type4 := enum_map.get("Name")
    assert(loc(), payload_type4.eq("Str"))

    assert_eq(loc(), 4, enum_map.len())

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_enum_use_case()

test_map_empty_keys := proc() {
    mut m := StrMap.new()

    // Empty string as key should work
    m.insert("", "empty_key_value")
    assert(loc(), m.contains_key(""))

    value := m.get("")
    assert(loc(), value.eq("empty_key_value"))
    assert_eq(loc(), 0, m.position(""))

    // Add another key
    m.insert("normal", "value")
    assert_eq(loc(), 2, m.len())
    assert_eq(loc(), 0, m.position(""))
    assert_eq(loc(), 1, m.position("normal"))

    catch (err: AllocError) {
        panic(loc(), format("Unexpected AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("Unexpected FullError: ", err.msg))
    }
    catch (err: Str) {
        panic(loc(), format("Unexpected error: ", err))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("Unexpected IndexOutOfBoundsError: ", err.msg))
    }
}
test_map_empty_keys()
