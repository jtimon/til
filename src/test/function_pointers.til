mode test

// Issue #91: Function signature type definitions

// Define function signature type (empty body {} as delimiter, like ext_func)
BinaryIntOp := func(I64, I64) returns I64 {}

// Functions declared with that type using binding tuple
add2 : BinaryIntOp = (a, b) { return a.add(b) }
subtract : BinaryIntOp = (a, b) { return a.sub(b) }

// Direct calls work
assert_eq(loc(), 8, add2(3, 5))
assert_eq(loc(), 6, subtract(10, 4))
assert_eq(loc(), 0, subtract(5, 5))

// Also test with explicit type annotation
BinaryIntOp2 : FunctionSig = func(I64, I64) returns I64 {}
multiply : BinaryIntOp2 = (a, b) { return a.mul(b) }
assert_eq(loc(), 15, multiply(3, 5))

// Test proc signature
BinaryIntProc := proc(I64, I64) returns I64 {}
add_proc : BinaryIntProc = (a, b) { return a.add(b) }
assert_eq(loc(), 7, add_proc(3, 4))

// Issue #91: Pass functions as arguments (higher-order)
apply_op : func(op: BinaryIntOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}
assert_eq(loc(), 8, apply_op(add2, 3, 5))
assert_eq(loc(), 6, apply_op(subtract, 10, 4))
assert_eq(loc(), 15, apply_op(multiply, 3, 5))

// Multiple calls to same higher-order function with different functions
assert_eq(loc(), 0, apply_op(subtract, 5, 5))
assert_eq(loc(), 30, apply_op(multiply, 5, 6))

// Issue #91: Runtime function pointer calls (not constant-foldable)
// Use a wrapper proc to force runtime dispatch
test_runtime_dispatch := proc(op: BinaryIntOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}
assert_eq(loc(), 11, test_runtime_dispatch(add2, 5, 6))
assert_eq(loc(), 4, test_runtime_dispatch(subtract, 10, 6))
assert_eq(loc(), 42, test_runtime_dispatch(multiply, 6, 7))

