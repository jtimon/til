mode test

// Issue #91: Function signature type definitions

// Define function signature type (empty body {} as delimiter, like ext_func)
BinaryIntOp := func(I64, I64) returns I64 {}

// Functions declared with that type using binding tuple
add2 : BinaryIntOp = (a, b) { return a.add(b) }
subtract : BinaryIntOp = (a, b) { return a.sub(b) }

// Direct calls work
assert_eq(loc(), 8, add2(3, 5))
assert_eq(loc(), 6, subtract(10, 4))
assert_eq(loc(), 0, subtract(5, 5))

// Also test with explicit type annotation
BinaryIntOp2 : FunctionSig = func(I64, I64) returns I64 {}
multiply : BinaryIntOp2 = (a, b) { return a.mul(b) }
assert_eq(loc(), 15, multiply(3, 5))

// Test proc signature
BinaryIntProc := proc(I64, I64) returns I64 {}
add_proc : BinaryIntProc = (a, b) { return a.add(b) }
assert_eq(loc(), 7, add_proc(3, 4))

// Issue #91: Pass functions as arguments (higher-order)
apply_op : func(op: BinaryIntOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}
assert_eq(loc(), 8, apply_op(add2, 3, 5))
assert_eq(loc(), 6, apply_op(subtract, 10, 4))
assert_eq(loc(), 15, apply_op(multiply, 3, 5))

// Multiple calls to same higher-order function with different functions
assert_eq(loc(), 0, apply_op(subtract, 5, 5))
assert_eq(loc(), 30, apply_op(multiply, 5, 6))

// Issue #91: Runtime function pointer calls (not constant-foldable)
// Use a wrapper proc to force runtime dispatch
test_runtime_dispatch := proc(op: BinaryIntOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}
assert_eq(loc(), 11, test_runtime_dispatch(add2, 5, 6))
assert_eq(loc(), 4, test_runtime_dispatch(subtract, 10, 6))
assert_eq(loc(), 42, test_runtime_dispatch(multiply, 6, 7))

// Multiple function-typed parameters
apply_two : func(f: BinaryIntOp, g: BinaryIntOp, a: I64, b: I64) returns I64 = {
    return f(a, g(a, b))
}
assert_eq(loc(), 18, apply_two(add2, multiply, 3, 5))

// Nested higher-order: function that takes a function that takes a function
compose_and_apply : func(outer: BinaryIntOp, inner: BinaryIntOp, a: I64, b: I64) returns I64 = {
    intermediate := inner(a, b)
    return outer(intermediate, intermediate)
}
assert_eq(loc(), 16, compose_and_apply(add2, add2, 3, 5))
assert_eq(loc(), 225, compose_and_apply(multiply, multiply, 3, 5))

// Issue #91: Returning functions from functions
get_op : func(which: I64) returns BinaryIntOp = {
    if which.eq(0) { return add2 }
    return subtract
}
op := get_op(0)
assert_eq(loc(), 8, op(3, 5))
op2 := get_op(1)
assert_eq(loc(), 6, op2(10, 4))

// Return function through multiple calls
get_op2 : func(which: I64) returns BinaryIntOp = {
    if which.eq(0) { return add2 }
    if which.eq(1) { return subtract }
    return multiply
}
op3 := get_op2(2)
assert_eq(loc(), 15, op3(3, 5))


