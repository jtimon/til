mode test

// Issue #91: Function signature type definitions

// Define function signature type (empty body {} as delimiter, like ext_func)
BinaryIntOp := func(I64, I64) returns I64 {}

// Functions declared with that type using binding tuple
add2 : BinaryIntOp = (a, b) { return a.add(b) }
subtract : BinaryIntOp = (a, b) { return a.sub(b) }

// Direct calls work
assert_eq(loc(), 8, add2(3, 5))
assert_eq(loc(), 6, subtract(10, 4))
assert_eq(loc(), 0, subtract(5, 5))

// Also test with explicit type annotation
BinaryIntOp2 : FunctionSig = func(I64, I64) returns I64 {}
multiply : BinaryIntOp2 = (a, b) { return a.mul(b) }
assert_eq(loc(), 15, multiply(3, 5))

// Issue #105 Step 4d: FuncSig annotation (alias for FunctionSig)
BinaryIntOp3 : FuncSig = func(I64, I64) returns I64 {}
divide : BinaryIntOp3 = (a, b) { return a.div(b) }
assert_eq(loc(), 3, divide(15, 5))

// Test proc signature
BinaryIntProc := proc(I64, I64) returns I64 {}
add_proc : BinaryIntProc = (a, b) { return a.add(b) }
assert_eq(loc(), 7, add_proc(3, 4))

// Issue #91: Pass functions as arguments (higher-order)
apply_op := func(op: BinaryIntOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}
assert_eq(loc(), 8, apply_op(add2, 3, 5))
assert_eq(loc(), 6, apply_op(subtract, 10, 4))
assert_eq(loc(), 15, apply_op(multiply, 3, 5))

// Multiple calls to same higher-order function with different functions
assert_eq(loc(), 0, apply_op(subtract, 5, 5))
assert_eq(loc(), 30, apply_op(multiply, 5, 6))

// Issue #91: Runtime function pointer calls (not constant-foldable)
// Use a wrapper proc to force runtime dispatch
test_runtime_dispatch := proc(op: BinaryIntOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}
assert_eq(loc(), 11, test_runtime_dispatch(add2, 5, 6))
assert_eq(loc(), 4, test_runtime_dispatch(subtract, 10, 6))
assert_eq(loc(), 42, test_runtime_dispatch(multiply, 6, 7))

// Multiple function-typed parameters
apply_two := func(f: BinaryIntOp, g: BinaryIntOp, a: I64, b: I64) returns I64 {
    return f(a, g(a, b))
}
assert_eq(loc(), 18, apply_two(add2, multiply, 3, 5))

// Nested higher-order: function that takes a function that takes a function
compose_and_apply := func(outer: BinaryIntOp, inner: BinaryIntOp, a: I64, b: I64) returns I64 {
    intermediate := inner(a, b)
    return outer(intermediate, intermediate)
}
assert_eq(loc(), 16, compose_and_apply(add2, add2, 3, 5))
assert_eq(loc(), 225, compose_and_apply(multiply, multiply, 3, 5))

// Issue #91: Returning functions from functions
get_op := func(which: I64) returns BinaryIntOp {
    if which.eq(0) { return add2 }
    return subtract
}
op := get_op(0)
assert_eq(loc(), 8, op(3, 5))
op2 := get_op(1)
assert_eq(loc(), 6, op2(10, 4))

// Return function through multiple calls
get_op2 := func(which: I64) returns BinaryIntOp {
    if which.eq(0) { return add2 }
    if which.eq(1) { return subtract }
    return multiply
}
op3 := get_op2(2)
assert_eq(loc(), 15, op3(3, 5))

// Issue #91: Anonymous inline functions (lambdas without captures)
assert_eq(loc(), 8, apply_op(func(a: I64, b: I64) returns I64 { return a.add(b) }, 3, 5))
assert_eq(loc(), 6, apply_op(func(a: I64, b: I64) returns I64 { return a.sub(b) }, 10, 4))
assert_eq(loc(), 15, apply_op(func(a: I64, b: I64) returns I64 { return a.mul(b) }, 3, 5))

// Issue #91: Struct fields with function pointers
Handler := struct {
    mut on_click: BinaryIntOp = add2
}

// Default value
h := Handler()
op4 := h.on_click
assert_eq(loc(), 8, op4(3, 5))

// Construct with specific function
h2 := Handler(on_click=subtract)
op5 := h2.on_click
assert_eq(loc(), 6, op5(10, 4))

// Reassign
test_reassign := proc() {
    mut h3 := Handler()
    h3.on_click = multiply
    op6 := h3.on_click
    assert_eq(loc(), 15, op6(3, 5))
}
test_reassign()

// Issue #91: Func ptr passthrough (return param)
passthrough_op := func(op: BinaryIntOp) returns BinaryIntOp { return op }
result_op := passthrough_op(add2)
assert_eq(loc(), 8, result_op(3, 5))
result_op2 := passthrough_op(subtract)
assert_eq(loc(), 6, result_op2(10, 4))

// Issue #91: Func ptr with throws
ThrowingOp := func(I64, I64) returns I64 throws Str {}
safe_div : ThrowingOp = (a, b) {
    if b.eq(0) {
        throw "divide by zero"
    }
    return a.div(b)
}

test_throwing := proc() {
    result := safe_div(10, 2)?
    assert_eq(loc(), 5, result)

    catch (err: Str) {
        println("ERROR:", err)
        exit(1)
    }
}
test_throwing()
