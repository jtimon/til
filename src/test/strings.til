mode test

test_strings := proc() {
    test(loc(), format("Hello, ", "world!").eq("Hello, world!"), "format('Hello, ', 'world!') = 'Hello, world!'")
    assert_eq_str(loc(), "abc", format("a", "b", "c"))
    test(loc(), I64.from_str("123").eq(123), "I64.from_str('123') = 123")
    test(loc(), I64.from_str("0").eq(0), "I64.from_str('0') = 0")
    // TODO: Test with invalid strings for I64.from_str, e.g., I64.from_str("abc") // Expected: error or undefined behavior
    test(loc(), I64.to_str(456).eq("456"), "I64.to_str(456) = '456'")
    test(loc(), I64.to_str(0).eq("0"), "I64.to_str(0) = '0'")

    empty_str := ""
    len3_str := "012"
    len5_str := "01234"
    test(loc(), empty_str.len().eq(0), "Str.len('') = 0")
    test(loc(), len3_str.len().eq(3), "Str.len('012') = 3")
    test(loc(), len5_str.len().eq(5), "Str.len('01234') = 5")

    assert_eq_str(loc(), "0",   get_substr("01234", 0, 1)?)
    assert_eq_str(loc(), "012", get_substr("01234", 0, 3)?)
    assert_eq_str(loc(), "234", get_substr("01234", 2, 5)?)

    assert_eq_str(loc(), "\\",  get_substr(",,\\", 2, 3)?)
    assert_eq_str(loc(), "\"",  get_substr(",,\"", 2, 3)?)
    assert_eq_str(loc(), "\n",  get_substr(",,\n", 2, 3)?)
    assert_eq_str(loc(), "\t",  get_substr(",,\t", 2, 3)?)
    assert_eq_str(loc(), "\r",  get_substr(",,\r", 2, 3)?)
    // assert_eq_str(loc(), "\0",  get_substr(",,\0", 2, 3)) // TODO Decide: Do we need to handle string null termination in string literals?

    assert_eq_str(loc(), "\\",  get_char(",,\\", 2)?)
    assert_eq_str(loc(), "\"",  get_char(",,\"", 2)?)
    assert_eq_str(loc(), "\n",  get_char(",,\n", 2)?)
    assert_eq_str(loc(), "\t",  get_char(",,\t", 2)?)
    assert_eq_str(loc(), "\r",  get_char(",,\r", 2)?)
    // assert_eq_str(loc(), "\0",  get_char(",,\0", 2))

    // char_at tests (returns U8)
    abc := "ABC"
    assert_eq(loc(), 65, abc.char_at(0).to_i64())  // 'A' = 65
    assert_eq(loc(), 66, abc.char_at(1).to_i64())  // 'B' = 66
    assert_eq(loc(), 67, abc.char_at(2).to_i64())  // 'C' = 67

    // from_byte tests
    byte_a := U8.from_i64(65)?
    byte_z := U8.from_i64(90)?
    byte_0 := U8.from_i64(48)?
    assert_eq_str(loc(), "A", Str.from_byte(byte_a))
    assert_eq_str(loc(), "Z", Str.from_byte(byte_z))
    assert_eq_str(loc(), "0", Str.from_byte(byte_0))

    catch (err: U8_Overflow) {
        println("ERROR:", loc(), "U8_Overflow:", err.msg)
        exit(1)
    }

    // starts_with tests
    hello := "hello"
    test(loc(), hello.starts_with("he"), "starts_with: 'hello'.starts_with('he') = true")
    test(loc(), hello.starts_with("hello"), "starts_with: 'hello'.starts_with('hello') = true")
    test(loc(), hello.starts_with(""), "starts_with: 'hello'.starts_with('') = true")
    test(loc(), not(hello.starts_with("world")), "starts_with: 'hello'.starts_with('world') = false")
    test(loc(), not(hello.starts_with("helloworld")), "starts_with: 'hello'.starts_with('helloworld') = false")
    test(loc(), not(hello.starts_with("ello")), "starts_with: 'hello'.starts_with('ello') = false")
    test(loc(), empty_str.starts_with(""), "starts_with: ''.starts_with('') = true")
    test(loc(), not(empty_str.starts_with("a")), "starts_with: ''.starts_with('a') = false")

    // ends_with tests
    test(loc(), hello.ends_with("lo"), "ends_with: 'hello'.ends_with('lo') = true")
    test(loc(), hello.ends_with("hello"), "ends_with: 'hello'.ends_with('hello') = true")
    test(loc(), hello.ends_with(""), "ends_with: 'hello'.ends_with('') = true")
    test(loc(), not(hello.ends_with("world")), "ends_with: 'hello'.ends_with('world') = false")
    test(loc(), not(hello.ends_with("helloworld")), "ends_with: 'hello'.ends_with('helloworld') = false")
    test(loc(), not(hello.ends_with("hell")), "ends_with: 'hello'.ends_with('hell') = false")
    test(loc(), empty_str.ends_with(""), "ends_with: ''.ends_with('') = true")
    test(loc(), not(empty_str.ends_with("a")), "ends_with: ''.ends_with('a') = false")

    // strip_prefix tests
    assert_eq_str(loc(), "llo", hello.strip_prefix("he"))
    assert_eq_str(loc(), "", hello.strip_prefix("hello"))
    assert_eq_str(loc(), "hello", hello.strip_prefix(""))
    assert_eq_str(loc(), "", hello.strip_prefix("world"))  // no match returns empty
    assert_eq_str(loc(), "", hello.strip_prefix("helloworld"))  // prefix longer than string
    assert_eq_str(loc(), "", empty_str.strip_prefix(""))
    assert_eq_str(loc(), "", empty_str.strip_prefix("a"))

    // strip_suffix tests
    assert_eq_str(loc(), "hel", hello.strip_suffix("lo"))
    assert_eq_str(loc(), "", hello.strip_suffix("hello"))
    assert_eq_str(loc(), "hello", hello.strip_suffix(""))
    assert_eq_str(loc(), "", hello.strip_suffix("world"))  // no match returns empty
    assert_eq_str(loc(), "", hello.strip_suffix("helloworld"))  // suffix longer than string
    assert_eq_str(loc(), "", empty_str.strip_suffix(""))
    assert_eq_str(loc(), "", empty_str.strip_suffix("a"))

    // find tests
    find_str := "hello"
    assert_eq(loc(), 0, find_str.find("h"))
    assert_eq(loc(), 0, find_str.find("he"))
    assert_eq(loc(), 2, find_str.find("ll"))
    assert_eq(loc(), 4, find_str.find("o"))
    assert_eq(loc(), sub(0, 1), find_str.find("x"))
    assert_eq(loc(), sub(0, 1), find_str.find(""))
    assert_eq(loc(), sub(0, 1), empty_str.find("a"))
    aaa_str := "aaa"
    assert_eq(loc(), 0, aaa_str.find("a"))  // finds first, not last
    func_name := "Str_clone"
    assert_eq(loc(), 3, func_name.find("_"))  // the actual use case

    // Test find with newline in needle
    newline_str := "hello\nreal\t0m0.123s"
    assert_eq(loc(), 5, newline_str.find("\nreal"))

    // Test find with medium string
    mut med_str := ""
    for i in 0..10 {
        med_str = med_str.concat("Line ").concat(i.to_str()).concat(".\n")
    }
    med_str = med_str.concat("\nreal\t0m0.123s\n")
    med_pos := med_str.find("\nreal")
    test(loc(), med_pos.gt(0), "find in medium string should work")

    // get_substr with start==end returns empty string (regression test)
    assert_eq_str(loc(), "", get_substr("hello", 0, 0)?)
    assert_eq_str(loc(), "", get_substr("hello", 3, 3)?)
    assert_eq_str(loc(), "", get_substr("hello", 5, 5)?)

    // replacen tests (regression: match at position 0 was broken)
    src_path := "src/examples/empty.c"
    assert_eq_str(loc(), "gen/c/examples/empty.c", src_path.replacen("src/", "gen/c/", 1))
    src_path2 := "src/test.c"
    assert_eq_str(loc(), "gen/c/test.c", src_path2.replacen("src/", "gen/c/", 1))
    no_match := "hello world"
    assert_eq_str(loc(), "hello world", no_match.replacen("foo", "bar", 1))  // no match
    match_start := "foo world"
    assert_eq_str(loc(), "bar world", match_start.replacen("foo", "bar", 1))  // match at start
    match_end := "hello foo"
    assert_eq_str(loc(), "hello bar", match_end.replacen("foo", "bar", 1))  // match at end
    multi := "foo foo foo"
    assert_eq_str(loc(), "bar bar foo", multi.replacen("foo", "bar", 2))  // n=2

    // repeat tests
    ab := "ab"
    indent := "    "
    assert_eq_str(loc(), "", ab.repeat(0))
    assert_eq_str(loc(), "", ab.repeat(sub(0, 1)))  // negative
    assert_eq_str(loc(), "ab", ab.repeat(1))
    assert_eq_str(loc(), "abab", ab.repeat(2))
    assert_eq_str(loc(), "ababab", ab.repeat(3))
    assert_eq_str(loc(), "    ", indent.repeat(1))
    assert_eq_str(loc(), "        ", indent.repeat(2))

    // join tests
    mut parts := Vec.new(Str)
    assert_eq_str(loc(), "", join(parts, ", "))  // empty vec
    parts.push("hello")
    assert_eq_str(loc(), "hello", join(parts, ", "))  // single element
    parts.push("world")
    assert_eq_str(loc(), "hello, world", join(parts, ", "))  // two elements
    parts.push("test")
    assert_eq_str(loc(), "hello, world, test", join(parts, ", "))  // three elements
    assert_eq_str(loc(), "hello world test", join(parts, " "))  // different separator
    assert_eq_str(loc(), "helloworldtest", join(parts, ""))  // empty separator

    // hash tests (FNV-1a)
    // Same string should always produce same hash
    test(loc(), Str.hash("hello").eq(Str.hash("hello")), "same string same hash")
    test(loc(), Str.hash("world").eq(Str.hash("world")), "same string same hash 2")
    // Different strings should (usually) produce different hashes
    test(loc(), not(Str.hash("hello").eq(Str.hash("world"))), "different strings different hash")
    test(loc(), not(Str.hash("").eq(Str.hash("a"))), "empty vs non-empty different hash")
    // Empty string should have a consistent hash (FNV offset basis)
    empty_hash := Str.hash("")
    test(loc(), empty_hash.eq(Str.hash("")), "empty string consistent hash")

    // Comparison tests (lt, gt, lteq, gteq, eq)
    test(loc(), Str.eq("hello", "hello"), "Str.eq: equal strings")
    test(loc(), not(Str.eq("hello", "world")), "Str.eq: different strings")
    test(loc(), Str.eq("", ""), "Str.eq: empty strings")

    test(loc(), Str.lt("a", "b"), "Str.lt: a < b")
    test(loc(), Str.lt("apple", "banana"), "Str.lt: apple < banana")
    test(loc(), Str.lt("", "a"), "Str.lt: empty < non-empty")
    test(loc(), Str.lt("ab", "abc"), "Str.lt: shorter < longer prefix")
    test(loc(), not(Str.lt("b", "a")), "Str.lt: not(b < a)")
    test(loc(), not(Str.lt("hello", "hello")), "Str.lt: not(hello < hello)")

    test(loc(), Str.gt("b", "a"), "Str.gt: b > a")
    test(loc(), Str.gt("banana", "apple"), "Str.gt: banana > apple")
    test(loc(), Str.gt("a", ""), "Str.gt: non-empty > empty")
    test(loc(), Str.gt("abc", "ab"), "Str.gt: longer > shorter prefix")
    test(loc(), not(Str.gt("a", "b")), "Str.gt: not(a > b)")
    test(loc(), not(Str.gt("hello", "hello")), "Str.gt: not(hello > hello)")

    test(loc(), Str.lteq("a", "b"), "Str.lteq: a <= b")
    test(loc(), Str.lteq("hello", "hello"), "Str.lteq: hello <= hello")
    test(loc(), Str.lteq("", ""), "Str.lteq: empty <= empty")
    test(loc(), Str.lteq("apple", "banana"), "Str.lteq: apple <= banana")
    test(loc(), not(Str.lteq("b", "a")), "Str.lteq: not(b <= a)")

    test(loc(), Str.gteq("b", "a"), "Str.gteq: b >= a")
    test(loc(), Str.gteq("hello", "hello"), "Str.gteq: hello >= hello")
    test(loc(), Str.gteq("", ""), "Str.gteq: empty >= empty")
    test(loc(), Str.gteq("banana", "apple"), "Str.gteq: banana >= apple")
    test(loc(), not(Str.gteq("a", "b")), "Str.gteq: not(a >= b)")

    // Test lexicographic ordering
    test(loc(), Str.lt("A", "a"), "Str.lt: A < a (uppercase before lowercase)")
    test(loc(), Str.lt("9", "A"), "Str.lt: 9 < A (digits before uppercase)")
    test(loc(), Str.lt("Zoo", "aardvark"), "Str.lt: Zoo < aardvark (Z < a)")

    // Str.inc tests
    mut inc_a := "a"
    inc_a.inc()
    assert_eq_str(loc(), "b", inc_a)

    mut inc_z := "z"
    inc_z.inc()
    assert_eq_str(loc(), "{", inc_z)  // z (122) + 1 = { (123)

    mut inc_multi := "ab"
    inc_multi.inc()
    assert_eq_str(loc(), "ab", inc_multi)  // multi-char strings unchanged

    // Str.dec tests
    mut dec_b := "b"
    dec_b.dec()
    assert_eq_str(loc(), "a", dec_b)

    mut dec_a := "a"
    dec_a.dec()
    assert_eq_str(loc(), "`", dec_a)  // a (97) - 1 = ` (96)

    mut dec_multi := "ab"
    dec_multi.dec()
    assert_eq_str(loc(), "ab", dec_multi)  // multi-char strings unchanged

    // Test range for with strings (uses inc/dec internally)
    mut alphabet := ""
    for c in "a".."f" {
        alphabet = alphabet.concat(c)
    }
    assert_eq_str(loc(), "abcde", alphabet)  // range is exclusive of end

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}
test_strings()
