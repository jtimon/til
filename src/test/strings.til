mode test

test_strings := proc() {
    test(loc(), format("Hello, ", "world!").eq("Hello, world!"), "format('Hello, ', 'world!') = 'Hello, world!'")
    assert_eq_str(loc(), "abc", format("a", "b", "c"))
    test(loc(), I64.from_str("123").eq(123), "I64.from_str('123') = 123")
    test(loc(), I64.from_str("0").eq(0), "I64.from_str('0') = 0")
    // TODO: Test with invalid strings for I64.from_str, e.g., I64.from_str("abc") // Expected: error or undefined behavior
    test(loc(), I64.to_str(456).eq("456"), "I64.to_str(456) = '456'")
    test(loc(), I64.to_str(0).eq("0"), "I64.to_str(0) = '0'")

    empty_str := ""
    len3_str := "012"
    len5_str := "01234"
    test(loc(), empty_str.len().eq(0), "Str.len('') = 0")
    test(loc(), len3_str.len().eq(3), "Str.len('012') = 3")
    test(loc(), len5_str.len().eq(5), "Str.len('01234') = 5")

    assert_eq_str(loc(), "0",   get_substr("01234", 0, 1))
    assert_eq_str(loc(), "012", get_substr("01234", 0, 3))
    assert_eq_str(loc(), "234", get_substr("01234", 2, 5))

    assert_eq_str(loc(), "\\",  get_substr(",,\\", 2, 3))
    assert_eq_str(loc(), "\"",  get_substr(",,\"", 2, 3))
    assert_eq_str(loc(), "\n",  get_substr(",,\n", 2, 3))
    assert_eq_str(loc(), "\t",  get_substr(",,\t", 2, 3))
    assert_eq_str(loc(), "\r",  get_substr(",,\r", 2, 3))
    // assert_eq_str(loc(), "\0",  get_substr(",,\0", 2, 3)) // TODO Decide: Do we need to handle string null termination in string literals?

    assert_eq_str(loc(), "\\",  get_char(",,\\", 2))
    assert_eq_str(loc(), "\"",  get_char(",,\"", 2))
    assert_eq_str(loc(), "\n",  get_char(",,\n", 2))
    assert_eq_str(loc(), "\t",  get_char(",,\t", 2))
    assert_eq_str(loc(), "\r",  get_char(",,\r", 2))
    // assert_eq_str(loc(), "\0",  get_char(",,\0", 2))

    // starts_with tests
    hello := "hello"
    test(loc(), hello.starts_with("he"), "starts_with: 'hello'.starts_with('he') = true")
    test(loc(), hello.starts_with("hello"), "starts_with: 'hello'.starts_with('hello') = true")
    test(loc(), hello.starts_with(""), "starts_with: 'hello'.starts_with('') = true")
    test(loc(), not(hello.starts_with("world")), "starts_with: 'hello'.starts_with('world') = false")
    test(loc(), not(hello.starts_with("helloworld")), "starts_with: 'hello'.starts_with('helloworld') = false")
    test(loc(), not(hello.starts_with("ello")), "starts_with: 'hello'.starts_with('ello') = false")
    test(loc(), empty_str.starts_with(""), "starts_with: ''.starts_with('') = true")
    test(loc(), not(empty_str.starts_with("a")), "starts_with: ''.starts_with('a') = false")

    // find tests
    find_str := "hello"
    assert_eq(loc(), 0, find_str.find("h"))
    assert_eq(loc(), 0, find_str.find("he"))
    assert_eq(loc(), 2, find_str.find("ll"))
    assert_eq(loc(), 4, find_str.find("o"))
    assert_eq(loc(), sub(0, 1), find_str.find("x"))
    assert_eq(loc(), sub(0, 1), find_str.find(""))
    assert_eq(loc(), sub(0, 1), empty_str.find("a"))
    aaa_str := "aaa"
    assert_eq(loc(), 0, aaa_str.find("a"))  // finds first, not last
    func_name := "Str_clone"
    assert_eq(loc(), 3, func_name.find("_"))  // the actual use case

    catch(err: I64_OverflowError) {
        panic(loc(), "Unexpected I64_OverflowError")
    }
    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "Unexpected IndexOutOfBoundsError")
    }
    catch(err: AllocError) {
        panic(loc(), "Unexpected AllocError")
    }
}
test_strings()
