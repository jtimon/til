mode test

test_strings := proc() {
    test(loc(), format("Hello, ", "world!").eq("Hello, world!"), "format('Hello, ', 'world!') = 'Hello, world!'")
    assert_eq_str(loc(), "abc", format("a", "b", "c"))
    test(loc(), I64.from_str("123").eq(123), "I64.from_str('123') = 123")
    test(loc(), I64.from_str("0").eq(0), "I64.from_str('0') = 0")
    // TODO: Test with invalid strings for I64.from_str, e.g., I64.from_str("abc") // Expected: error or undefined behavior
    test(loc(), I64.to_str(456).eq("456"), "I64.to_str(456) = '456'")
    test(loc(), I64.to_str(0).eq("0"), "I64.to_str(0) = '0'")

    empty_str := ""
    len3_str := "012"
    len5_str := "01234"
    test(loc(), empty_str.len().eq(0), "Str.len('') = 0")
    test(loc(), len3_str.len().eq(3), "Str.len('012') = 3")
    test(loc(), len5_str.len().eq(5), "Str.len('01234') = 5")

    assert_eq_str(loc(), "0",   get_substr("01234", 0, 1))
    assert_eq_str(loc(), "012", get_substr("01234", 0, 3))
    assert_eq_str(loc(), "234", get_substr("01234", 2, 5))

    assert_eq_str(loc(), "\\",  get_substr(",,\\", 2, 3))
    assert_eq_str(loc(), "\"",  get_substr(",,\"", 2, 3))
    assert_eq_str(loc(), "\n",  get_substr(",,\n", 2, 3))
    assert_eq_str(loc(), "\t",  get_substr(",,\t", 2, 3))
    assert_eq_str(loc(), "\r",  get_substr(",,\r", 2, 3))
    // assert_eq_str(loc(), "\0",  get_substr(",,\0", 2, 3)) // TODO Decide: Do we need to handle string null termination in string literals?

    assert_eq_str(loc(), "\\",  get_char(",,\\", 2))
    assert_eq_str(loc(), "\"",  get_char(",,\"", 2))
    assert_eq_str(loc(), "\n",  get_char(",,\n", 2))
    assert_eq_str(loc(), "\t",  get_char(",,\t", 2))
    assert_eq_str(loc(), "\r",  get_char(",,\r", 2))
    // assert_eq_str(loc(), "\0",  get_char(",,\0", 2))

    // starts_with tests
    hello := "hello"
    test(loc(), hello.starts_with("he"), "starts_with: 'hello'.starts_with('he') = true")
    test(loc(), hello.starts_with("hello"), "starts_with: 'hello'.starts_with('hello') = true")
    test(loc(), hello.starts_with(""), "starts_with: 'hello'.starts_with('') = true")
    test(loc(), not(hello.starts_with("world")), "starts_with: 'hello'.starts_with('world') = false")
    test(loc(), not(hello.starts_with("helloworld")), "starts_with: 'hello'.starts_with('helloworld') = false")
    test(loc(), not(hello.starts_with("ello")), "starts_with: 'hello'.starts_with('ello') = false")
    test(loc(), empty_str.starts_with(""), "starts_with: ''.starts_with('') = true")
    test(loc(), not(empty_str.starts_with("a")), "starts_with: ''.starts_with('a') = false")

    // ends_with tests
    test(loc(), hello.ends_with("lo"), "ends_with: 'hello'.ends_with('lo') = true")
    test(loc(), hello.ends_with("hello"), "ends_with: 'hello'.ends_with('hello') = true")
    test(loc(), hello.ends_with(""), "ends_with: 'hello'.ends_with('') = true")
    test(loc(), not(hello.ends_with("world")), "ends_with: 'hello'.ends_with('world') = false")
    test(loc(), not(hello.ends_with("helloworld")), "ends_with: 'hello'.ends_with('helloworld') = false")
    test(loc(), not(hello.ends_with("hell")), "ends_with: 'hello'.ends_with('hell') = false")
    test(loc(), empty_str.ends_with(""), "ends_with: ''.ends_with('') = true")
    test(loc(), not(empty_str.ends_with("a")), "ends_with: ''.ends_with('a') = false")

    // find tests
    find_str := "hello"
    assert_eq(loc(), 0, find_str.find("h"))
    assert_eq(loc(), 0, find_str.find("he"))
    assert_eq(loc(), 2, find_str.find("ll"))
    assert_eq(loc(), 4, find_str.find("o"))
    assert_eq(loc(), sub(0, 1), find_str.find("x"))
    assert_eq(loc(), sub(0, 1), find_str.find(""))
    assert_eq(loc(), sub(0, 1), empty_str.find("a"))
    aaa_str := "aaa"
    assert_eq(loc(), 0, aaa_str.find("a"))  // finds first, not last
    func_name := "Str_clone"
    assert_eq(loc(), 3, func_name.find("_"))  // the actual use case

    // Test find with newline in needle
    newline_str := "hello\nreal\t0m0.123s"
    assert_eq(loc(), 5, newline_str.find("\nreal"))

    // Test find with medium string
    mut med_str := ""
    for i in 0..10 {
        med_str = med_str.concat("Line ").concat(i.to_str()).concat(".\n")
    }
    med_str = med_str.concat("\nreal\t0m0.123s\n")
    med_pos := med_str.find("\nreal")
    test(loc(), med_pos.gt(0), "find in medium string should work")

    // get_substr with start==end returns empty string (regression test)
    assert_eq_str(loc(), "", get_substr("hello", 0, 0))
    assert_eq_str(loc(), "", get_substr("hello", 3, 3))
    assert_eq_str(loc(), "", get_substr("hello", 5, 5))

    // replacen tests (regression: match at position 0 was broken)
    src_path := "src/examples/empty.c"
    assert_eq_str(loc(), "gen/c/examples/empty.c", src_path.replacen("src/", "gen/c/", 1))
    src_path2 := "src/test.c"
    assert_eq_str(loc(), "gen/c/test.c", src_path2.replacen("src/", "gen/c/", 1))
    no_match := "hello world"
    assert_eq_str(loc(), "hello world", no_match.replacen("foo", "bar", 1))  // no match
    match_start := "foo world"
    assert_eq_str(loc(), "bar world", match_start.replacen("foo", "bar", 1))  // match at start
    match_end := "hello foo"
    assert_eq_str(loc(), "hello bar", match_end.replacen("foo", "bar", 1))  // match at end
    multi := "foo foo foo"
    assert_eq_str(loc(), "bar bar foo", multi.replacen("foo", "bar", 2))  // n=2

    // repeat tests
    ab := "ab"
    indent := "    "
    assert_eq_str(loc(), "", ab.repeat(0))
    assert_eq_str(loc(), "", ab.repeat(sub(0, 1)))  // negative
    assert_eq_str(loc(), "ab", ab.repeat(1))
    assert_eq_str(loc(), "abab", ab.repeat(2))
    assert_eq_str(loc(), "ababab", ab.repeat(3))
    assert_eq_str(loc(), "    ", indent.repeat(1))
    assert_eq_str(loc(), "        ", indent.repeat(2))

    // join tests
    mut parts := Vec.new(Str)
    assert_eq_str(loc(), "", join(parts, ", "))  // empty vec
    parts.push("hello")
    assert_eq_str(loc(), "hello", join(parts, ", "))  // single element
    parts.push("world")
    assert_eq_str(loc(), "hello, world", join(parts, ", "))  // two elements
    parts.push("test")
    assert_eq_str(loc(), "hello, world, test", join(parts, ", "))  // three elements
    assert_eq_str(loc(), "hello world test", join(parts, " "))  // different separator
    assert_eq_str(loc(), "helloworldtest", join(parts, ""))  // empty separator

    catch(err: AllocError) {
        panic(loc(), "Unexpected AllocError")
    }
}
test_strings()
