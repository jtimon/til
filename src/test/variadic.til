mode test

concat2 := proc(args: ..Str) returns Str {
    mut result := ""
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := ""
        args.get(i, val)
        result = format(result, val)
    }
    return result

    catch(err: I64_OverflowError) {
        println(loc(), "I64_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "concat2: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
    }
}
assert_eq_str(loc(), "Variadic: foobarbaz", concat2("Variadic: ", "foo", "bar", "baz"))

var_i64_add := proc(args: ..I64) returns I64 {
    mut result := 0
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := 0
        args.get(i, val)
        result = result.add(val)
    }
    return result

    catch(err: IndexOutOfBoundsError) {
        println(loc(), "var_i64_add: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
}
assert_eq(loc(), add(34, 35), var_i64_add(34, 35))

var_u8_add := proc(args: ..U8) returns U8 {
    mut result : U8 = 0
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := U8.from_i64(0)
        args.get(i, val)
        result = result.u8_add(val)
    }
    return result

    catch(err: IndexOutOfBoundsError) {
        println(loc(), "var_i64_add: IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: U8_OverflowError) {
        println(loc(), "var_i64_add: U8_OverflowError thrown:")
        println(err.msg)
    }
}
assert_eq(loc(), add(34, 35), U8.to_i64(var_u8_add(U8.from_i64(34), U8.from_i64(35))))

// Test: Variadic type checking (merged from variadic_type_check.til)
test_i64_variadic := func(args: ..I64) returns I64 {
    mut sum := 0
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := 0
        args.get(i, val)
        sum = sum.add(val)
    }
    return sum

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "test_i64_variadic: IndexOutOfBoundsError should never happen")
    }
}

// Test with different numbers of arguments
assert_eq(loc(), 6, test_i64_variadic(1, 2, 3))
assert_eq(loc(), 30, test_i64_variadic(10, 20))
assert_eq(loc(), 0, test_i64_variadic())

test_str_variadic := func(args: ..Str) returns Str {
    mut result := ""
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := ""
        args.get(i, val)
        result = format(result, val)
    }
    return result

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "test_str_variadic: IndexOutOfBoundsError should never happen")
    }
    catch(err: I64_OverflowError) {
        panic(loc(), "test_str_variadic: I64_OverflowError")
    }
    catch(err: AllocError) {
        panic(loc(), "test_str_variadic: AllocError")
    }
}

assert_eq_str(loc(), "hello world", test_str_variadic("hello", " ", "world"))
assert_eq_str(loc(), "", test_str_variadic())

// Test: Edge cases for variadic arguments

// Single argument
assert_eq(loc(), 42, test_i64_variadic(42))
assert_eq_str(loc(), "single", test_str_variadic("single"))

// Many arguments
assert_eq(loc(), 15, test_i64_variadic(1, 2, 3, 4, 5))
assert_eq_str(loc(), "onetwothreefourfive", test_str_variadic("one", "two", "three", "four", "five"))

// Test: Variadic with Bool type
test_bool_variadic := func(args: ..Bool) returns I64 {
    mut count_true := 0
    mut args_len := args.len()
    for i in 0..args_len {
        mut val := false
        args.get(i, val)
        if val {
            count_true = count_true.add(1)
        }
    }
    return count_true

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "test_bool_variadic: IndexOutOfBoundsError should never happen")
    }
}

assert_eq(loc(), 3, test_bool_variadic(true, false, true, true, false))
assert_eq(loc(), 0, test_bool_variadic(false, false, false))
assert_eq(loc(), 0, test_bool_variadic())

// Type checking tests (these should fail at compile time if uncommented):
// test_i64_variadic("string")  // Should fail: passing Str to ..I64
// test_i64_variadic(1, "two", 3)  // Should fail: mixed types
// test_i64_variadic(true, false)  // Should fail: passing Bool to ..I64
// test_str_variadic(1, 2, 3)  // Should fail: passing I64 to ..Str
// test_str_variadic("hello", 42, "world")  // Should fail: mixed types
// test_bool_variadic(1, 0)  // Should fail: passing I64 to ..Bool
