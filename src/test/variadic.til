mode test

concat2 := proc(args: ..Str) returns Str {
    mut result := ""
    for val: Str in args {
        result = format(result, val)
    }

    catch(err: I64_OverflowError) {
        println(loc(), "I64_OverflowError thrown:")
        println(err.msg)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "IndexOutOfBoundsError thrown:")
        println(err.msg)
    }
    catch(err: AllocError) {
        println(loc(), "AllocError thrown:")
        println(err.msg)
    }

    return result
}
assert_eq_str(loc(), "Variadic: foobarbaz", concat2("Variadic: ", "foo", "bar", "baz"))

var_i64_add := proc(args: ..I64) returns I64 {
    mut result := 0
    for val: I64 in args {
        result = result.add(val)
    }
    return result
}
assert_eq(loc(), add(34, 35), var_i64_add(34, 35))

var_u8_add := proc(args: ..U8) returns U8 {
    mut result : U8 = 0
    for val: U8 in args {
        result = result.u8_add(val)
    }

    catch(err: U8_OverflowError) {
        println(loc(), "U8_OverflowError thrown:")
        println(err.msg)
    }

    return result
}
assert_eq(loc(), add(34, 35), U8.to_i64(var_u8_add(U8.from_i64(34), U8.from_i64(35))))

// Test: Variadic type checking (merged from variadic_type_check.til)
test_i64_variadic := func(args: ..I64) returns I64 {
    mut sum := 0
    for val: I64 in args {
        sum = sum.add(val)
    }
    return sum
}

// Test with different numbers of arguments
assert_eq(loc(), 6, test_i64_variadic(1, 2, 3))
assert_eq(loc(), 30, test_i64_variadic(10, 20))
assert_eq(loc(), 0, test_i64_variadic())

test_str_variadic := func(args: ..Str) returns Str throws I64_OverflowError, IndexOutOfBoundsError, AllocError {
    mut result := ""
    for val: Str in args {
        result = format(result, val)
    }
    return result
}

assert_eq_str(loc(), "hello world", test_str_variadic("hello", " ", "world"))
assert_eq_str(loc(), "", test_str_variadic())

// Test: Edge cases for variadic arguments

// Single argument
assert_eq(loc(), 42, test_i64_variadic(42))
assert_eq_str(loc(), "single", test_str_variadic("single"))

// Many arguments
assert_eq(loc(), 15, test_i64_variadic(1, 2, 3, 4, 5))
assert_eq_str(loc(), "onetwothreefourfive", test_str_variadic("one", "two", "three", "four", "five"))

// Test: Variadic with Bool type
test_bool_variadic := func(args: ..Bool) returns I64 {
    mut count_true := 0
    for val: Bool in args {
        if val {
            count_true.inc()
        }
    }
    return count_true
}

assert_eq(loc(), 3, test_bool_variadic(true, false, true, true, false))
assert_eq(loc(), 0, test_bool_variadic(false, false, false))
assert_eq(loc(), 0, test_bool_variadic())

// Type checking tests (these should fail at compile time if uncommented):
// test_i64_variadic("string")  // Should fail: passing Str to ..I64
// test_i64_variadic(1, "two", 3)  // Should fail: mixed types
// test_i64_variadic(true, false)  // Should fail: passing Bool to ..I64
// test_str_variadic(1, 2, 3)  // Should fail: passing I64 to ..Str
// test_str_variadic("hello", 42, "world")  // Should fail: mixed types
// test_bool_variadic(1, 0)  // Should fail: passing I64 to ..Bool
