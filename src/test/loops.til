mode test

import("core.vec")
import("core.array")

test_while_loop := proc() {
    mut it := 0
    mut result := ""
    while it.lt(5) {
        result = result.concat(it.to_str()).concat(" ")
        it.inc()
    }
    assert_eq_str(loc(), "0 1 2 3 4 ", result)
}
test_while_loop()

test_for_range_loop := proc() {
    mut sum := 0
    for i in 0..5 {
        sum = sum.add(i)
    }
    assert_eq(loc(), 10, sum)  // 0+1+2+3+4 = 10
}
test_for_range_loop()

test_for_in_vec_i64 := proc() {
    mut v := Vec.new(I64)
    v.push(10)
    v.push(20)
    v.push(30)
    mut total := 0
    for x: I64 in v {
        total = total.add(x)
    }
    assert_eq(loc(), 60, total)
    v.delete()

    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_for_in_vec_i64()

test_for_in_vec_str := proc() {
    mut words := Vec.new(Str)
    words.push("hello")
    words.push(" ")
    words.push("world")
    mut sentence := ""
    for w: Str in words {
        sentence = sentence.concat(w)
    }
    assert_eq_str(loc(), "hello world", sentence)
    words.delete()

    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
}
test_for_in_vec_str()

test_for_in_array_i64 := proc() {
    mut arr := Array.new(I64, 3)
    arr.set(0, 100)
    arr.set(1, 200)
    arr.set(2, 300)
    mut arr_total := 0
    for n: I64 in arr {
        arr_total = arr_total.add(n)
    }
    assert_eq(loc(), 600, arr_total)
    arr.delete()

    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        // This catches IndexOutOfBoundsError from arr.set() calls above
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_for_in_array_i64()

// Bug #33: for-in loops don't work with enum collections
// The for-in desugaring creates `mut val := TYPE()` which fails for enums
// because enums don't have parameterless constructors.
// Fix: precomp now generates `EnumType.FirstVariant` for enum collections.

// Simple enum with no payloads
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

// Test for-in with enum that has no payloads
test_forin_simple_enum := proc() {
    mut colors := Vec.new(SimpleColor)
    // Note: Must use variables for push due to separate bug with direct enum constructor expressions
    c_red := SimpleColor.Red
    c_green := SimpleColor.Green
    c_blue := SimpleColor.Blue
    colors.push(c_red)
    colors.push(c_green)
    colors.push(c_blue)

    mut count := 0
    for color: SimpleColor in colors {
        count = count.add(1)
        switch color {
        case SimpleColor.Red:
            assert_eq(loc(), 1, count)
        case SimpleColor.Green:
            assert_eq(loc(), 2, count)
        case SimpleColor.Blue:
            assert_eq(loc(), 3, count)
        case:
            panic(loc(), "unexpected color")
        }
    }
    assert_eq(loc(), 3, count)

    catch (err: AllocError) { panic(loc(), err.msg) }
}
test_forin_simple_enum()

// Note: Payload enum test removed - Vec.get doesn't correctly preserve enum payloads
// (separate pre-existing bug with memcpy-based enum payload storage, Bug #38)
