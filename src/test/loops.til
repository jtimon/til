mode test

import("core.vec")
import("core.array")
import("core.range")

test_while_loop := proc() {
    mut it := 0
    mut result := ""
    while it.lt(5) {
        result = result.concat(it.to_str()).concat(" ")
        it.inc()
    }
    assert_eq_str(loc(), "0 1 2 3 4 ", result)
}
test_while_loop()

test_for_range_loop := proc() {
    mut sum := 0
    for i in 0..5 {
        sum = sum.add(i)
    }
    assert_eq(loc(), 10, sum)  // 0+1+2+3+4 = 10
}
test_for_range_loop()

test_for_reverse_range_loop := proc() {
    mut sum := 0
    for i in 5..0 {
        sum = sum.add(i)
    }
    assert_eq(loc(), 15, sum)  // 5+4+3+2+1 = 15
}
test_for_reverse_range_loop()

test_for_in_vec_i64 := proc() {
    mut v := Vec.new(I64)
    v.push(10)
    v.push(20)
    v.push(30)
    mut total := 0
    for x: I64 in v {
        total = total.add(x)
    }
    assert_eq(loc(), 60, total)
    v.delete()

}
test_for_in_vec_i64()

test_for_in_vec_str := proc() {
    mut words := Vec.new(Str)
    words.push("hello")
    words.push(" ")
    words.push("world")
    mut sentence := ""
    for w: Str in words {
        sentence = sentence.concat(w)
    }
    assert_eq_str(loc(), "hello world", sentence)
    words.delete()

}
test_for_in_vec_str()

test_for_in_array_i64 := proc() {
    mut arr := Array.new(I64, 3)
    arr.set(0, 100)?
    arr.set(1, 200)?
    arr.set(2, 300)?
    mut arr_total := 0
    for n: I64 in arr {
        arr_total = arr_total.add(n)
    }
    assert_eq(loc(), 600, arr_total)
    arr.delete()

    catch (err: IndexOutOfBoundsError) {
        // This catches IndexOutOfBoundsError from arr.set() calls above
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}
test_for_in_array_i64()

// Bug #33: for-in loops don't work with enum collections
// The for-in desugaring creates `mut val := TYPE()` which fails for enums
// because enums don't have parameterless constructors.
// Fix: precomp now generates `EnumType.FirstVariant` for enum collections.

// Simple enum with no payloads
SimpleColor := enum {
    Red,
    Green,
    Blue,
}

// Test for-in with enum that has no payloads
test_forin_simple_enum := proc() {
    mut colors := Vec.new(SimpleColor)
    // Note: Must use variables for push due to separate bug with direct enum constructor expressions
    c_red := SimpleColor.Red
    c_green := SimpleColor.Green
    c_blue := SimpleColor.Blue
    colors.push(c_red)
    colors.push(c_green)
    colors.push(c_blue)

    mut count := 0
    for color: SimpleColor in colors {
        count = count.add(1)
        switch color {
        case SimpleColor.Red:
            assert_eq(loc(), 1, count)
        case SimpleColor.Green:
            assert_eq(loc(), 2, count)
        case SimpleColor.Blue:
            assert_eq(loc(), 3, count)
        case:
            panic(loc(), "unexpected color")
        }
    }
    assert_eq(loc(), 3, count)

}
test_forin_simple_enum()

// Bug #86: Fixed - for-in now works with enum payloads
PayloadColor := enum {
    Unknown,
    Green: Bool,
    Number: I64,
}

test_forin_payload_enum := proc() {
    mut colors := Vec.new(PayloadColor)
    colors.push(PayloadColor.Unknown)
    g := PayloadColor.Green(true)
    colors.push(g)
    n := PayloadColor.Number(42)
    colors.push(n)

    mut count := 0
    for color: PayloadColor in colors {
        count = count.add(1)
        switch color {
        case PayloadColor.Unknown:
            assert_eq(loc(), 1, count)
        case PayloadColor.Green(is_olive):
            assert_eq(loc(), 2, count)
            assert(loc(), is_olive)
        case PayloadColor.Number(code):
            assert_eq(loc(), 3, count)
            assert_eq(loc(), 42, code)
        }
    }
    assert_eq(loc(), 3, count)

}
test_forin_payload_enum()

// I64Range test - use as collection with for-in
test_i64range := proc() {
    mut sum := 0
    for i: I64 in I64Range(start=0, end=5) {
        sum = sum.add(i)
    }
    assert_eq(loc(), 10, sum)  // 0+1+2+3+4 = 10
}
test_i64range()
