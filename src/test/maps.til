mode test

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    new := proc(x: I64, y: I64) returns Vec2 {
        mut v := Vec2()
        v.x = x
        v.y = y
        return v
    }
}

// Test Map<I64, I64>
test_map_i64_to_i64 := proc() {
    mut ages := Map.new("I64", size_of(I64), "I64", size_of(I64))
    ages.insert(100, 30)
    ages.insert(200, 25)

    mut age := 0
    ages.get(100, age)
    test(loc(), I64.eq(age, 30), "ID 100 should map to 30")
    ages.get(200, age)
    test(loc(), I64.eq(age, 25), "ID 200 should map to 25")

    ages.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map<I64, Str>
test_map_i64_to_str := proc() {
    mut names := Map.new("I64", size_of(I64), "Str", size_of(Str))
    names.insert(100, "Alice")
    names.insert(200, "Bob")
    names.insert(300, "Charlie")

    mut name := ""
    names.get(100, name)
    test(loc(), Str.eq(name, "Alice"), "ID 100 should map to Alice")
    names.get(200, name)
    test(loc(), Str.eq(name, "Bob"), "ID 200 should map to Bob")
    names.get(300, name)
    test(loc(), Str.eq(name, "Charlie"), "ID 300 should map to Charlie")

    names.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map<Str, Bool>
test_map_str_to_bool := proc() {
    mut flags := Map.new("Str", size_of(Str), "Bool", size_of(Bool))
    flags.insert("debug", true)
    flags.insert("verbose", false)
    flags.insert("production", false)

    mut flag := false
    flags.get("debug", flag)
    test(loc(), flag.eq(true), "debug should be true")
    flags.get("verbose", flag)
    test(loc(), flag.eq(false), "verbose should be false")
    flags.get("production", flag)
    test(loc(), flag.eq(false), "production should be false")

    flags.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map<Str, Str>
test_map_str_to_str := proc() {
    mut capitals := Map.new("Str", size_of(Str), "Str", size_of(Str))
    capitals.insert("France", "Paris")
    capitals.insert("Japan", "Tokyo")
    capitals.insert("Brazil", "Brasilia")

    mut capital := ""
    capitals.get("France", capital)
    test(loc(), Str.eq(capital, "Paris"), "France's capital should be Paris")
    capitals.get("Japan", capital)
    test(loc(), Str.eq(capital, "Tokyo"), "Japan's capital should be Tokyo")
    capitals.get("Brazil", capital)
    test(loc(), Str.eq(capital, "Brasilia"), "Brazil's capital should be Brasilia")

    capitals.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map<Str, U8>
test_map_str_to_u8 := proc() {
    mut grades := Map.new("Str", size_of(Str), "U8", size_of(U8))
    grades.insert("Alice", U8.from_i64(90))
    grades.insert("Bob", U8.from_i64(85))
    grades.insert("Charlie", U8.from_i64(92))

    mut grade := U8.from_i64(0)
    grades.get("Alice", grade)
    test(loc(), grade.eq(U8.from_i64(90)), "Alice's grade should be 90")
    grades.get("Bob", grade)
    test(loc(), grade.eq(U8.from_i64(85)), "Bob's grade should be 85")
    grades.get("Charlie", grade)
    test(loc(), grade.eq(U8.from_i64(92)), "Charlie's grade should be 92")

    grades.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
    catch (err: U8_OverflowError) { exit(1) }
}

// Test Map<Str, Vec2>
test_map_str_to_vec2 := proc() {
    mut positions := Map.new("Str", size_of(Str), "Vec2", size_of(Vec2))
    mut player_pos := Vec2.new(10, 20)
    positions.insert("player", player_pos)
    mut enemy_pos := Vec2.new(30, 40)
    positions.insert("enemy", enemy_pos)
    mut item_pos := Vec2.new(50, 60)
    positions.insert("item", item_pos)

    mut pos := Vec2()
    positions.get("player", pos)
    test(loc(), I64.eq(pos.x, 10), "player.x should be 10")
    test(loc(), I64.eq(pos.y, 20), "player.y should be 20")
    positions.get("enemy", pos)
    test(loc(), I64.eq(pos.x, 30), "enemy.x should be 30")
    test(loc(), I64.eq(pos.y, 40), "enemy.y should be 40")
    positions.get("item", pos)
    test(loc(), I64.eq(pos.x, 50), "item.x should be 50")
    test(loc(), I64.eq(pos.y, 60), "item.y should be 60")

    positions.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map<Str, Array<Str>>
test_map_str_to_array_str := proc() {
    mut lists := Map.new("Str", size_of(Str), "Array", size_of(Array))

    mut fruits := Vec.new("Str", size_of(Str))
    fruits.push("apple")
    fruits.push("banana")
    fruits.push("orange")
    lists.insert("fruits", fruits)

    mut colors := Vec.new("Str", size_of(Str))
    colors.push("red")
    colors.push("green")
    colors.push("blue")
    lists.insert("colors", colors)

    mut arr := Array()
    lists.get("fruits", arr)
    test(loc(), I64.eq(arr.len, 3), "fruits array should have 3 elements")
    mut item := ""
    arr.get(0, item)
    test(loc(), Str.eq(item, "apple"), "fruits[0] should be apple")

    lists.get("colors", arr)
    test(loc(), I64.eq(arr.len, 3), "colors array should have 3 elements")
    arr.get(0, item)
    test(loc(), Str.eq(item, "red"), "colors[0] should be red")

    fruits.delete()
    colors.delete()
    lists.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
    catch (err: FullError) { exit(1) }
}

// Test Map<U8, Bool>
test_map_u8_to_bool := proc() {
    mut flags := Map.new("U8", size_of(U8), "Bool", size_of(Bool))
    flags.insert(U8.from_i64(10), true)
    flags.insert(U8.from_i64(20), false)
    flags.insert(U8.from_i64(30), true)

    mut flag := false
    flags.get(U8.from_i64(10), flag)
    test(loc(), flag.eq(true), "key 10 should be true")
    flags.get(U8.from_i64(20), flag)
    test(loc(), flag.eq(false), "key 20 should be false")
    flags.get(U8.from_i64(30), flag)
    test(loc(), flag.eq(true), "key 30 should be true")

    flags.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test insert() - should throw on duplicate keys
test_map_insert_duplicate := proc() {
    mut ages := Map.new("Str", size_of(Str), "I64", size_of(I64))
    ages.insert("Alice", 30)
    ages.insert("Alice", 35)
    panic(loc(), "Expected DuplicatedKeyError when inserting duplicate key")
    catch (err: DuplicatedKeyError) {}
    ages.delete()
    catch (err: AllocError) { exit(1) }
}

// Test set() - should overwrite existing keys
test_map_set := proc() {
    mut ages := Map.new("Str", size_of(Str), "I64", size_of(I64))
    ages.set("Alice", 30)
    ages.set("Alice", 35)
    test(loc(), I64.eq(ages.len(), 1), "Size should still be 1 after set update")

    mut age := 0
    ages.get("Alice", age)
    test(loc(), I64.eq(age, 35), "Expected age 35 after update")

    ages.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test get() with non-existent key
test_map_get_missing := proc() {
    mut ages := Map.new("Str", size_of(Str), "I64", size_of(I64))
    ages.insert("Alice", 30)

    mut age := 0
    ages.get("Charlie", age)
    panic(loc(), "Expected KeyNotFoundError for non-existent key")
    catch (err: KeyNotFoundError) {}
    ages.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Test contains_key()
test_map_contains_key := proc() {
    mut ages := Map.new("Str", size_of(Str), "I64", size_of(I64))
    ages.insert("Alice", 30)
    ages.insert("Bob", 25)

    test(loc(), ages.contains_key("Alice"), "Should contain Alice")
    test(loc(), ages.contains_key("Bob"), "Should contain Bob")
    test(loc(), not(ages.contains_key("Charlie")), "Should not contain Charlie")

    ages.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Test position() method
test_map_position := proc() {
    mut colors := Map.new("Str", size_of(Str), "I64", size_of(I64))
    colors.insert("red", 1)
    colors.insert("green", 2)
    colors.insert("blue", 3)

    test(loc(), I64.eq(colors.position("red"), 0), "red should be at position 0")
    test(loc(), I64.eq(colors.position("green"), 1), "green should be at position 1")
    test(loc(), I64.eq(colors.position("blue"), 2), "blue should be at position 2")

    mut pos := colors.position("yellow")
    test(loc(), I64.eq(pos, sub(0, 1)), "non-existent key should return -1")

    colors.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Test empty Map operations
test_map_empty := proc() {
    mut m := Map.new("Str", size_of(Str), "I64", size_of(I64))
    test(loc(), I64.eq(m.len(), 0), "Empty map should have size 0")
    test(loc(), not(m.contains_key("anything")), "Empty map should not contain any key")
    mut pos := m.position("anything")
    test(loc(), I64.eq(pos, sub(0, 1)), "position in empty map should return -1")

    m.delete()
    catch (err: AllocError) { exit(1) }
}

// Test Map growth/reallocation beyond initial capacity
test_map_growth := proc() {
    mut ages := Map.new("I64", size_of(I64), "I64", size_of(I64))

    // Array.INIT_DYN_CAP is 16, so insert 20 elements to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        ages.insert(i, mul(i, 100))
        i = add(i, 1)
    }

    test(loc(), I64.eq(ages.len(), 20), "Map should have 20 entries after growth")

    // Verify all values are still correct after reallocation
    mut val := 0
    ages.get(0, val)
    test(loc(), I64.eq(val, 0), "First element should still be 0")
    ages.get(10, val)
    test(loc(), I64.eq(val, 1000), "Middle element should be 1000")
    ages.get(19, val)
    test(loc(), I64.eq(val, 1900), "Last element should be 1900")

    // Verify contains_key still works after reallocation
    test(loc(), ages.contains_key(5), "Should contain key 5 after growth")
    test(loc(), ages.contains_key(15), "Should contain key 15 after growth")
    test(loc(), not(ages.contains_key(25)), "Should not contain key 25")

    ages.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test Map.delete() properly resets size
test_map_delete := proc() {
    mut m := Map.new("Str", size_of(Str), "I64", size_of(I64))

    m.insert("a", 1)
    m.insert("b", 2)
    m.insert("c", 3)
    test(loc(), I64.eq(m.len(), 3), "Map should have 3 entries")

    m.delete()
    test(loc(), I64.eq(m.len(), 0), "Map size should be 0 after delete")

    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Test len() tracks correctly through various operations
test_map_len_tracking := proc() {
    mut m := Map.new("Str", size_of(Str), "I64", size_of(I64))

    test(loc(), I64.eq(m.len(), 0), "Empty map should have len 0")

    m.insert("a", 1)
    test(loc(), I64.eq(m.len(), 1), "Map should have len 1 after first insert")

    m.insert("b", 2)
    m.insert("c", 3)
    test(loc(), I64.eq(m.len(), 3), "Map should have len 3 after three inserts")

    // set() with existing key should not change len
    m.set("a", 100)
    test(loc(), I64.eq(m.len(), 3), "Map len should stay 3 after set() on existing key")

    // set() with new key should increase len
    m.set("d", 4)
    test(loc(), I64.eq(m.len(), 4), "Map len should be 4 after set() with new key")

    m.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Test multiple set() overwrites
test_map_multiple_overwrites := proc() {
    mut m := Map.new("Str", size_of(Str), "I64", size_of(I64))

    m.set("key", 1)
    mut val := 0
    m.get("key", val)
    test(loc(), I64.eq(val, 1), "First set should store 1")

    m.set("key", 2)
    m.get("key", val)
    test(loc(), I64.eq(val, 2), "Second set should overwrite to 2")

    m.set("key", 3)
    m.get("key", val)
    test(loc(), I64.eq(val, 3), "Third set should overwrite to 3")

    test(loc(), I64.eq(m.len(), 1), "Multiple overwrites should keep len at 1")

    m.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: KeyNotFoundError) { exit(1) }
}

// Test insertion order is preserved after growth
test_map_order_after_growth := proc() {
    mut m := Map.new("I64", size_of(I64), "Str", size_of(Str))

    // Insert 20 keys to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        m.insert(i, format("val", I64.to_str(i)))
        i = add(i, 1)
    }

    // Verify position() still returns correct insertion order
    test(loc(), I64.eq(m.position(0), 0), "Key 0 should be at position 0")
    test(loc(), I64.eq(m.position(5), 5), "Key 5 should be at position 5")
    test(loc(), I64.eq(m.position(10), 10), "Key 10 should be at position 10")
    test(loc(), I64.eq(m.position(19), 19), "Key 19 should be at position 19")
    test(loc(), I64.eq(m.position(100), sub(0, 1)), "Non-existent key should return -1")

    m.delete()
    catch (err: AllocError) { exit(1) }
    catch (err: DuplicatedKeyError) { exit(1) }
}

// Run all tests
test_map_i64_to_i64()
test_map_i64_to_str()
test_map_str_to_bool()
test_map_str_to_str()
test_map_str_to_u8()
test_map_str_to_vec2()
test_map_str_to_array_str()
test_map_u8_to_bool()
test_map_insert_duplicate()
test_map_set()
test_map_get_missing()
test_map_contains_key()
test_map_position()
test_map_empty()
test_map_growth()
test_map_delete()
test_map_len_tracking()
test_map_multiple_overwrites()
test_map_order_after_growth()

