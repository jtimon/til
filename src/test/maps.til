mode test

import("core.vec")
import("std.map")
import("std.hashmap")

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

// Test Map<I64, I64>
test_map_i64_to_i64 := proc() {
    mut ages := Map.new(I64, I64)
    ages.insert(100, 30)?
    ages.insert(200, 25)?

    mut age := 0
    ages.get(100, age)?
    test(loc(), age.eq(30), "ID 100 should map to 30")
    ages.get(200, age)?
    test(loc(), age.eq(25), "ID 200 should map to 25")

    ages.delete()

    // Catch unexpected errors at end
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<Str, Vec2>
test_map_str_to_vec2 := proc() {
    mut positions := Map.new(Str, Vec2)
    mut player_pos := Vec2(x=10, y=20)
    positions.insert("player", player_pos)?
    mut enemy_pos := Vec2(x=30, y=40)
    positions.insert("enemy", enemy_pos)?
    mut item_pos := Vec2(x=50, y=60)
    positions.insert("item", item_pos)?

    mut pos := Vec2()
    positions.get("player", pos)?
    test(loc(), pos.x.eq(10), "player.x should be 10")
    test(loc(), pos.y.eq(20), "player.y should be 20")
    positions.get("enemy", pos)?
    test(loc(), pos.x.eq(30), "enemy.x should be 30")
    test(loc(), pos.y.eq(40), "enemy.y should be 40")
    positions.get("item", pos)?
    test(loc(), pos.x.eq(50), "item.x should be 50")
    test(loc(), pos.y.eq(60), "item.y should be 60")

    positions.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<Str, Vec<Str>>
test_map_str_to_vec_str := proc() {
    mut lists := Map.new(Str, Vec)

    mut fruits := Vec.new(Str)
    fruits.push("apple")
    fruits.push("banana")
    fruits.push("orange")
    lists.insert("fruits", fruits)?

    mut colors := Vec.new(Str)
    colors.push("red")
    colors.push("green")
    colors.push("blue")
    lists.insert("colors", colors)?

    mut retrieved := Vec()
    lists.get("fruits", retrieved)?
    test(loc(), retrieved.len().eq(3), "fruits vec should have 3 elements")
    mut item := ""
    retrieved.get(0, item)?
    test(loc(), item.eq("apple"), "fruits[0] should be apple")

    lists.get("colors", retrieved)?
    test(loc(), retrieved.len().eq(3), "colors vec should have 3 elements")
    retrieved.get(0, item)?
    test(loc(), item.eq("red"), "colors[0] should be red")

    // fruits and colors were transferred to lists via insert(own), so lists owns them
    lists.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<U8, Bool>
test_map_u8_to_bool := proc() {
    mut flags := Map.new(U8, Bool)
    flags.insert(U8.from_i64(10)?, true)?
    flags.insert(U8.from_i64(20)?, false)?
    flags.insert(U8.from_i64(30)?, true)?

    mut flag := false
    flags.get(U8.from_i64(10)?, flag)?
    test(loc(), flag.eq(true), "key 10 should be true")
    flags.get(U8.from_i64(20)?, flag)?
    test(loc(), flag.eq(false), "key 20 should be false")
    flags.get(U8.from_i64(30)?, flag)?
    test(loc(), flag.eq(true), "key 30 should be true")

    flags.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test insert() - should throw on duplicate keys
test_map_insert_duplicate := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Alice", 35)?
    panic(loc(), "Expected DuplicatedKeyError when inserting duplicate key")
    catch (err: DuplicatedKeyError) {}
    ages.delete()
}

// Test set() - should overwrite existing keys
test_map_set := proc() {
    mut ages := Map.new(Str, I64)
    ages.set("Alice", 30)
    ages.set("Alice", 35)
    test(loc(), ages.len().eq(1), "Size should still be 1 after set update")

    mut age := 0
    ages.get("Alice", age)?
    test(loc(), age.eq(35), "Expected age 35 after update")

    ages.delete()
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test get() with non-existent key
test_map_get_missing := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?

    mut age := 0
    ages.get("Charlie", age)?
    panic(loc(), "Expected KeyNotFoundError for non-existent key")
    catch (err: KeyNotFoundError) {}
    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test contains_key()
test_map_contains_key := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?

    test(loc(), ages.contains_key("Alice"), "Should contain Alice")
    test(loc(), ages.contains_key("Bob"), "Should contain Bob")
    test(loc(), not(ages.contains_key("Charlie")), "Should not contain Charlie")

    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test position() method
// Note: Map is sorted by key, so positions are in sorted order (blue < green < red)
test_map_position := proc() {
    mut colors := Map.new(Str, I64)
    colors.insert("red", 1)?
    colors.insert("green", 2)?
    colors.insert("blue", 3)?

    // Sorted order: blue=0, green=1, red=2
    test(loc(), colors.position("blue").eq(0), "blue should be at position 0")
    test(loc(), colors.position("green").eq(1), "green should be at position 1")
    test(loc(), colors.position("red").eq(2), "red should be at position 2")

    mut pos := colors.position("yellow")
    test(loc(), pos.eq(sub(0, 1)), "non-existent key should return -1")

    colors.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test empty Map operations
test_map_empty := proc() {
    mut m := Map.new(Str, I64)
    test(loc(), m.len().eq(0), "Empty map should have size 0")
    test(loc(), not(m.contains_key("anything")), "Empty map should not contain any key")
    mut pos := m.position("anything")
    test(loc(), pos.eq(sub(0, 1)), "position in empty map should return -1")

    m.delete()
}

// Test Map growth/reallocation beyond initial capacity
test_map_growth := proc() {
    mut ages := Map.new(I64, I64)

    // Array.INIT_DYN_CAP is 16, so insert 20 elements to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        ages.insert(i.clone(), mul(i, 100))?
        i = add(i, 1)
    }

    test(loc(), ages.len().eq(20), "Map should have 20 entries after growth")

    // Verify all values are still correct after reallocation
    mut val := 0
    ages.get(0, val)?
    test(loc(), val.eq(0), "First element should still be 0")
    ages.get(10, val)?
    test(loc(), val.eq(1000), "Middle element should be 1000")
    ages.get(19, val)?
    test(loc(), val.eq(1900), "Last element should be 1900")

    // Verify contains_key still works after reallocation
    test(loc(), ages.contains_key(5), "Should contain key 5 after growth")
    test(loc(), ages.contains_key(15), "Should contain key 15 after growth")
    test(loc(), not(ages.contains_key(25)), "Should not contain key 25")

    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map.delete() properly resets size
test_map_delete := proc() {
    mut m := Map.new(Str, I64)

    m.insert("a", 1)?
    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "Map should have 3 entries")

    m.delete()
    test(loc(), m.len().eq(0), "Map size should be 0 after delete")

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test len() tracks correctly through various operations
test_map_len_tracking := proc() {
    mut m := Map.new(Str, I64)

    test(loc(), m.len().eq(0), "Empty map should have len 0")

    m.insert("a", 1)?
    test(loc(), m.len().eq(1), "Map should have len 1 after first insert")

    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "Map should have len 3 after three inserts")

    // set() with existing key should not change len
    m.set("a", 100)
    test(loc(), m.len().eq(3), "Map len should stay 3 after set() on existing key")

    // set() with new key should increase len
    m.set("d", 4)
    test(loc(), m.len().eq(4), "Map len should be 4 after set() with new key")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test multiple set() overwrites
test_map_multiple_overwrites := proc() {
    mut m := Map.new(Str, I64)

    m.set("key", 1)
    mut val := 0
    m.get("key", val)?
    test(loc(), val.eq(1), "First set should store 1")

    m.set("key", 2)
    m.get("key", val)?
    test(loc(), val.eq(2), "Second set should overwrite to 2")

    m.set("key", 3)
    m.get("key", val)?
    test(loc(), val.eq(3), "Third set should overwrite to 3")

    test(loc(), m.len().eq(1), "Multiple overwrites should keep len at 1")

    m.delete()
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test insertion order is preserved after growth
test_map_order_after_growth := proc() {
    mut m := Map.new(I64, Str)

    // Insert 20 keys to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        m.insert(i.clone(), format("val", I64.to_str(i)))?
        i = add(i, 1)
    }

    // Verify position() still returns correct insertion order
    test(loc(), m.position(0).eq(0), "Key 0 should be at position 0")
    test(loc(), m.position(5).eq(5), "Key 5 should be at position 5")
    test(loc(), m.position(10).eq(10), "Key 10 should be at position 10")
    test(loc(), m.position(19).eq(19), "Key 19 should be at position 19")
    test(loc(), m.position(100).eq(sub(0, 1)), "Non-existent key should return -1")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test direct .keys field access
test_map_keys_field := proc() {
    mut m := Map.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    mut keys := m.keys
    test(loc(), keys.len().eq(3), "m.keys should have 3 keys")

    mut key := ""
    keys.get(0, key)?
    test(loc(), key.eq("alice"), "First key should be alice")
    keys.get(1, key)?
    test(loc(), key.eq("bob"), "Second key should be bob")
    keys.get(2, key)?
    test(loc(), key.eq("charlie"), "Third key should be charlie")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}

// Test Map.remove
test_map_remove := proc() {
    mut m := Map.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    test(loc(), m.len().eq(3), "Map should have 3 entries before remove")
    test(loc(), m.contains_key("bob"), "Map should contain bob before remove")

    // Remove middle element
    m.remove("bob")

    test(loc(), m.len().eq(2), "Map should have 2 entries after remove")
    test(loc(), not(m.contains_key("bob")), "Map should not contain bob after remove")
    test(loc(), m.contains_key("alice"), "Map should still contain alice")
    test(loc(), m.contains_key("charlie"), "Map should still contain charlie")

    // Verify remaining values are correct
    mut val := 0
    m.get("alice", val)?
    test(loc(), val.eq(30), "alice should still be 30")
    m.get("charlie", val)?
    test(loc(), val.eq(35), "charlie should still be 35")

    // Remove non-existent key (should be no-op)
    m.remove("nonexistent")
    test(loc(), m.len().eq(2), "Map should still have 2 entries after removing non-existent")

    // Remove remaining elements
    m.remove("alice")
    m.remove("charlie")
    test(loc(), m.len().eq(0), "Map should be empty after removing all")
    test(loc(), m.is_empty(), "Map.is_empty should be true")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// ============================================================================
// HashMap Tests (Issue #112)
// ============================================================================

// Test HashMap<Str, I64>
test_hashmap_str_to_i64 := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?
    ages.insert("Charlie", 35)?

    mut age := 0
    ages.get("Alice", age)?
    test(loc(), age.eq(30), "HashMap: Alice should be 30")
    ages.get("Bob", age)?
    test(loc(), age.eq(25), "HashMap: Bob should be 25")
    ages.get("Charlie", age)?
    test(loc(), age.eq(35), "HashMap: Charlie should be 35")

    test(loc(), ages.len().eq(3), "HashMap should have 3 entries")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap<I64, I64>
test_hashmap_i64_to_i64 := proc() {
    mut ages := HashMap.new(I64, I64)
    ages.insert(100, 30)?
    ages.insert(200, 25)?

    mut age := 0
    ages.get(100, age)?
    test(loc(), age.eq(30), "HashMap: ID 100 should map to 30")
    ages.get(200, age)?
    test(loc(), age.eq(25), "HashMap: ID 200 should map to 25")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap<Str, Vec2>
test_hashmap_str_to_vec2 := proc() {
    mut positions := HashMap.new(Str, Vec2)
    mut player_pos := Vec2(x=10, y=20)
    positions.insert("player", player_pos)?
    mut enemy_pos := Vec2(x=30, y=40)
    positions.insert("enemy", enemy_pos)?

    mut pos := Vec2()
    positions.get("player", pos)?
    test(loc(), pos.x.eq(10), "HashMap: player.x should be 10")
    test(loc(), pos.y.eq(20), "HashMap: player.y should be 20")
    positions.get("enemy", pos)?
    test(loc(), pos.x.eq(30), "HashMap: enemy.x should be 30")
    test(loc(), pos.y.eq(40), "HashMap: enemy.y should be 40")

    positions.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap insert() - should throw on duplicate keys
test_hashmap_insert_duplicate := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Alice", 35)?
    panic(loc(), "Expected DuplicatedKeyError when inserting duplicate key")
    catch (err: DuplicatedKeyError) {}
    ages.delete()
}

// Test HashMap set() - should overwrite existing keys
test_hashmap_set := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.set("Alice", 30)
    ages.set("Alice", 35)
    test(loc(), ages.len().eq(1), "HashMap: Size should still be 1 after set update")

    mut age := 0
    ages.get("Alice", age)?
    test(loc(), age.eq(35), "HashMap: Expected age 35 after update")

    ages.delete()

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap get() with non-existent key
test_hashmap_get_missing := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?

    mut age := 0
    ages.get("Charlie", age)?
    panic(loc(), "Expected KeyNotFoundError for non-existent key")
    catch (err: KeyNotFoundError) {}
    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap contains_key()
test_hashmap_contains_key := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?

    test(loc(), ages.contains_key("Alice"), "HashMap: Should contain Alice")
    test(loc(), ages.contains_key("Bob"), "HashMap: Should contain Bob")
    test(loc(), not(ages.contains_key("Charlie")), "HashMap: Should not contain Charlie")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test empty HashMap operations
test_hashmap_empty := proc() {
    mut m := HashMap.new(Str, I64)
    test(loc(), m.len().eq(0), "Empty HashMap should have size 0")
    test(loc(), m.is_empty(), "Empty HashMap is_empty() should be true")
    test(loc(), not(m.contains_key("anything")), "Empty HashMap should not contain any key")

    m.delete()
}

// Test HashMap growth/resize beyond initial capacity
test_hashmap_growth := proc() {
    mut ages := HashMap.new(I64, I64)

    // Initial bucket count is 16, load factor 0.75 = 12 entries before resize
    // Insert 20 elements to trigger at least one resize
    mut i := 0
    while i.lt(20) {
        ages.insert(i.clone(), i.mul(100))?
        i = i.add(1)
    }

    test(loc(), ages.len().eq(20), "HashMap should have 20 entries after growth")

    // Verify all values are still correct after resize
    mut val := 0
    ages.get(0, val)?
    test(loc(), val.eq(0), "HashMap: First element should still be 0")
    ages.get(10, val)?
    test(loc(), val.eq(1000), "HashMap: Middle element should be 1000")
    ages.get(19, val)?
    test(loc(), val.eq(1900), "HashMap: Last element should be 1900")

    // Verify contains_key still works after resize
    test(loc(), ages.contains_key(5), "HashMap: Should contain key 5 after growth")
    test(loc(), ages.contains_key(15), "HashMap: Should contain key 15 after growth")
    test(loc(), not(ages.contains_key(25)), "HashMap: Should not contain key 25")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap.clear()
test_hashmap_clear := proc() {
    mut m := HashMap.new(Str, I64)

    m.insert("a", 1)?
    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "HashMap should have 3 entries")

    m.clear()
    test(loc(), m.len().eq(0), "HashMap size should be 0 after clear")
    test(loc(), m.is_empty(), "HashMap should be empty after clear")
    test(loc(), not(m.contains_key("a")), "HashMap should not contain 'a' after clear")

    // Should be able to insert again after clear
    m.insert("d", 4)?
    test(loc(), m.len().eq(1), "HashMap should have 1 entry after re-insert")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap len() tracks correctly through various operations
test_hashmap_len_tracking := proc() {
    mut m := HashMap.new(Str, I64)

    test(loc(), m.len().eq(0), "Empty HashMap should have len 0")

    m.insert("a", 1)?
    test(loc(), m.len().eq(1), "HashMap should have len 1 after first insert")

    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "HashMap should have len 3 after three inserts")

    // set() with existing key should not change len
    m.set("a", 100)
    test(loc(), m.len().eq(3), "HashMap len should stay 3 after set() on existing key")

    // set() with new key should increase len
    m.set("d", 4)
    test(loc(), m.len().eq(4), "HashMap len should be 4 after set() with new key")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test multiple set() overwrites
test_hashmap_multiple_overwrites := proc() {
    mut m := HashMap.new(Str, I64)

    m.set("key", 1)
    mut val := 0
    m.get("key", val)?
    test(loc(), val.eq(1), "HashMap: First set should store 1")

    m.set("key", 2)
    m.get("key", val)?
    test(loc(), val.eq(2), "HashMap: Second set should overwrite to 2")

    m.set("key", 3)
    m.get("key", val)?
    test(loc(), val.eq(3), "HashMap: Third set should overwrite to 3")

    test(loc(), m.len().eq(1), "HashMap: Multiple overwrites should keep len at 1")

    m.delete()

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap with many string keys (stress test for hash distribution)
test_hashmap_many_strings := proc() {
    mut m := HashMap.new(Str, I64)

    // Insert 50 different string keys
    mut i := 0
    while i.lt(50) {
        key := format("key_", I64.to_str(i))
        m.insert(key, i.clone())?
        i = i.add(1)
    }

    test(loc(), m.len().eq(50), "HashMap should have 50 entries")

    // Verify lookups work for various keys
    mut val := 0
    m.get("key_0", val)?
    test(loc(), val.eq(0), "HashMap: key_0 should be 0")
    m.get("key_25", val)?
    test(loc(), val.eq(25), "HashMap: key_25 should be 25")
    m.get("key_49", val)?
    test(loc(), val.eq(49), "HashMap: key_49 should be 49")

    // Verify non-existent keys
    test(loc(), not(m.contains_key("key_50")), "HashMap: Should not contain key_50")
    test(loc(), not(m.contains_key("nonexistent")), "HashMap: Should not contain nonexistent")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap.remove
test_hashmap_remove := proc() {
    mut m := HashMap.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    test(loc(), m.len().eq(3), "HashMap should have 3 entries before remove")
    test(loc(), m.contains_key("bob"), "HashMap should contain bob before remove")

    // Remove middle element
    m.remove("bob")

    test(loc(), m.len().eq(2), "HashMap should have 2 entries after remove")
    test(loc(), not(m.contains_key("bob")), "HashMap should not contain bob after remove")
    test(loc(), m.contains_key("alice"), "HashMap should still contain alice")
    test(loc(), m.contains_key("charlie"), "HashMap should still contain charlie")

    // Verify remaining values are correct
    mut val := 0
    m.get("alice", val)?
    test(loc(), val.eq(30), "HashMap alice should still be 30")
    m.get("charlie", val)?
    test(loc(), val.eq(35), "HashMap charlie should still be 35")

    // Remove non-existent key (should be no-op)
    m.remove("nonexistent")
    test(loc(), m.len().eq(2), "HashMap should still have 2 entries after removing non-existent")

    // Remove remaining elements
    m.remove("alice")
    m.remove("charlie")
    test(loc(), m.len().eq(0), "HashMap should be empty after removing all")
    test(loc(), m.is_empty(), "HashMap.is_empty should be true")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// ============================================================================
// Run all Map tests
// ============================================================================
test_map_i64_to_i64()
test_map_str_to_vec2()
test_map_str_to_vec_str()
test_map_u8_to_bool()
test_map_insert_duplicate()
test_map_set()
test_map_get_missing()
test_map_contains_key()
test_map_position()
test_map_empty()
test_map_growth()
test_map_delete()
test_map_len_tracking()
test_map_multiple_overwrites()
test_map_order_after_growth()
test_map_keys_field()
test_map_remove()

// ============================================================================
// Run all HashMap tests
// ============================================================================
test_hashmap_str_to_i64()
test_hashmap_i64_to_i64()
test_hashmap_str_to_vec2()
test_hashmap_insert_duplicate()
test_hashmap_set()
test_hashmap_get_missing()
test_hashmap_contains_key()
test_hashmap_empty()
test_hashmap_growth()
test_hashmap_clear()
test_hashmap_len_tracking()
test_hashmap_multiple_overwrites()
test_hashmap_many_strings()
test_hashmap_remove()

test_map_get_by_ref := proc() {
    mut m := Map.new(Str, I64)
    m.set("a", 10)
    m.set("b", 20)

    ref_a := m.get_by_ref("a")?
    mut val := 0
    ref_a.dereference(I64, val)
    assert_eq(loc(), 10, val)

    // Missing key throws
    mut threw := false
    _bad := m.get_by_ref("missing")?
    catch (err: KeyNotFoundError) {
        threw = true
    }
    test(loc(), threw, "Map.get_by_ref missing key throws")

    m.delete()
}

test_hashmap_get_by_ref := proc() {
    mut m := HashMap.new(Str, I64)
    m.set("x", 42)
    m.set("y", 99)

    ref_x := m.get_by_ref("x")?
    mut val := 0
    ref_x.dereference(I64, val)
    assert_eq(loc(), 42, val)

    // Missing key throws
    mut threw := false
    _bad := m.get_by_ref("missing")?
    catch (err: KeyNotFoundError) {
        threw = true
    }
    test(loc(), threw, "HashMap.get_by_ref missing key throws")

    m.delete()
}

test_map_get_by_ref()
test_hashmap_get_by_ref()
