mode test

import("core.vec")
import("std.map")
import("std.hashmap")

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
}

// Test Map<I64, I64>
test_map_i64_to_i64 := proc() {
    mut ages := Map.new(I64, I64)
    ages.insert(100, 30)?
    ages.insert(200, 25)?

    age0 := cast(I64, ages.get_by_ref(100)?)
    test(loc(), age0.eq(30), "ID 100 should map to 30")
    age1 := cast(I64, ages.get_by_ref(200)?)
    test(loc(), age1.eq(25), "ID 200 should map to 25")

    ages.delete()

    // Catch unexpected errors at end
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<Str, Vec2>
test_map_str_to_vec2 := proc() {
    mut positions := Map.new(Str, Vec2)
    mut player_pos := Vec2(x=10, y=20)
    positions.insert("player", player_pos)?
    mut enemy_pos := Vec2(x=30, y=40)
    positions.insert("enemy", enemy_pos)?
    mut item_pos := Vec2(x=50, y=60)
    positions.insert("item", item_pos)?

    player := cast(Vec2, positions.get_by_ref("player")?)
    test(loc(), player.x.eq(10), "player.x should be 10")
    test(loc(), player.y.eq(20), "player.y should be 20")
    enemy := cast(Vec2, positions.get_by_ref("enemy")?)
    test(loc(), enemy.x.eq(30), "enemy.x should be 30")
    test(loc(), enemy.y.eq(40), "enemy.y should be 40")
    item := cast(Vec2, positions.get_by_ref("item")?)
    test(loc(), item.x.eq(50), "item.x should be 50")
    test(loc(), item.y.eq(60), "item.y should be 60")

    positions.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<Str, Vec<Str>>
test_map_str_to_vec_str := proc() {
    mut lists := Map.new(Str, Vec)

    mut fruits := Vec.new(Str)
    fruits.push("apple")
    fruits.push("banana")
    fruits.push("orange")
    lists.insert("fruits", fruits)?

    mut colors := Vec.new(Str)
    colors.push("red")
    colors.push("green")
    colors.push("blue")
    lists.insert("colors", colors)?

    fruits_vec := cast(Vec, lists.get_by_ref("fruits")?)
    test(loc(), fruits_vec.len().eq(3), "fruits vec should have 3 elements")
    fruits_item := cast(Str, fruits_vec.get_by_ref(0)?)
    test(loc(), fruits_item.eq("apple"), "fruits[0] should be apple")

    colors_vec := cast(Vec, lists.get_by_ref("colors")?)
    test(loc(), colors_vec.len().eq(3), "colors vec should have 3 elements")
    colors_item := cast(Str, colors_vec.get_by_ref(0)?)
    test(loc(), colors_item.eq("red"), "colors[0] should be red")

    // fruits and colors were transferred to lists via insert(own), so lists owns them
    lists.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}

// Test Map<U8, Bool>
test_map_u8_to_bool := proc() {
    mut flags := Map.new(U8, Bool)
    flags.insert(U8.from_i64(10)?, true)?
    flags.insert(U8.from_i64(20)?, false)?
    flags.insert(U8.from_i64(30)?, true)?

    flag0 := cast(Bool, flags.get_by_ref(U8.from_i64(10)?)?)
    test(loc(), flag0.eq(true), "key 10 should be true")
    flag1 := cast(Bool, flags.get_by_ref(U8.from_i64(20)?)?)
    test(loc(), flag1.eq(false), "key 20 should be false")
    flag2 := cast(Bool, flags.get_by_ref(U8.from_i64(30)?)?)
    test(loc(), flag2.eq(true), "key 30 should be true")

    flags.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
    catch (err: U8_Overflow) {
        println("ERROR:", loc(), "Unexpected U8_Overflow")
        println(err.msg)
        exit(1)
    }
}

// Test insert() - should throw on duplicate keys
test_map_insert_duplicate := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Alice", 35)?
    panic(loc(), "Expected DuplicatedKeyError when inserting duplicate key")
    catch (err: DuplicatedKeyError) {}
    ages.delete()
}

// Test set() - should overwrite existing keys
test_map_set := proc() {
    mut ages := Map.new(Str, I64)
    ages.set("Alice", 30)
    ages.set("Alice", 35)
    test(loc(), ages.len().eq(1), "Size should still be 1 after set update")

    age := cast(I64, ages.get_by_ref("Alice")?)
    test(loc(), age.eq(35), "Expected age 35 after update")

    ages.delete()
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test get() with non-existent key
test_map_get_missing := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?

    _age := cast(I64, ages.get_by_ref("Charlie")?)
    panic(loc(), "Expected KeyNotFoundError for non-existent key")
    catch (err: KeyNotFoundError) {}
    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test contains_key()
test_map_contains_key := proc() {
    mut ages := Map.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?

    test(loc(), ages.contains_key("Alice"), "Should contain Alice")
    test(loc(), ages.contains_key("Bob"), "Should contain Bob")
    test(loc(), not(ages.contains_key("Charlie")), "Should not contain Charlie")

    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test position() method
// Note: Map is sorted by key, so positions are in sorted order (blue < green < red)
test_map_position := proc() {
    mut colors := Map.new(Str, I64)
    colors.insert("red", 1)?
    colors.insert("green", 2)?
    colors.insert("blue", 3)?

    // Sorted order: blue=0, green=1, red=2
    test(loc(), colors.position("blue").eq(0), "blue should be at position 0")
    test(loc(), colors.position("green").eq(1), "green should be at position 1")
    test(loc(), colors.position("red").eq(2), "red should be at position 2")

    mut pos := colors.position("yellow")
    test(loc(), pos.eq(sub(0, 1)), "non-existent key should return -1")

    colors.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test empty Map operations
test_map_empty := proc() {
    mut m := Map.new(Str, I64)
    test(loc(), m.len().eq(0), "Empty map should have size 0")
    test(loc(), not(m.contains_key("anything")), "Empty map should not contain any key")
    mut pos := m.position("anything")
    test(loc(), pos.eq(sub(0, 1)), "position in empty map should return -1")

    m.delete()
}

// Test Map growth/reallocation beyond initial capacity
test_map_growth := proc() {
    mut ages := Map.new(I64, I64)

    // Array.INIT_DYN_CAP is 16, so insert 20 elements to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        ages.insert(i.clone(), mul(i, 100))?
        i = add(i, 1)
    }

    test(loc(), ages.len().eq(20), "Map should have 20 entries after growth")

    // Verify all values are still correct after reallocation
    val0 := cast(I64, ages.get_by_ref(0)?)
    test(loc(), val0.eq(0), "First element should still be 0")
    val10 := cast(I64, ages.get_by_ref(10)?)
    test(loc(), val10.eq(1000), "Middle element should be 1000")
    val19 := cast(I64, ages.get_by_ref(19)?)
    test(loc(), val19.eq(1900), "Last element should be 1900")

    // Verify contains_key still works after reallocation
    test(loc(), ages.contains_key(5), "Should contain key 5 after growth")
    test(loc(), ages.contains_key(15), "Should contain key 15 after growth")
    test(loc(), not(ages.contains_key(25)), "Should not contain key 25")

    ages.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test Map.delete() properly resets size
test_map_delete := proc() {
    mut m := Map.new(Str, I64)

    m.insert("a", 1)?
    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "Map should have 3 entries")

    m.delete()
    test(loc(), m.len().eq(0), "Map size should be 0 after delete")

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test len() tracks correctly through various operations
test_map_len_tracking := proc() {
    mut m := Map.new(Str, I64)

    test(loc(), m.len().eq(0), "Empty map should have len 0")

    m.insert("a", 1)?
    test(loc(), m.len().eq(1), "Map should have len 1 after first insert")

    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "Map should have len 3 after three inserts")

    // set() with existing key should not change len
    m.set("a", 100)
    test(loc(), m.len().eq(3), "Map len should stay 3 after set() on existing key")

    // set() with new key should increase len
    m.set("d", 4)
    test(loc(), m.len().eq(4), "Map len should be 4 after set() with new key")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test multiple set() overwrites
test_map_multiple_overwrites := proc() {
    mut m := Map.new(Str, I64)

    m.set("key", 1)
    val1 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val1.eq(1), "First set should store 1")

    m.set("key", 2)
    val2 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val2.eq(2), "Second set should overwrite to 2")

    m.set("key", 3)
    val3 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val3.eq(3), "Third set should overwrite to 3")

    test(loc(), m.len().eq(1), "Multiple overwrites should keep len at 1")

    m.delete()
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test insertion order is preserved after growth
test_map_order_after_growth := proc() {
    mut m := Map.new(I64, Str)

    // Insert 20 keys to trigger reallocation
    mut i := 0
    while lt(i, 20) {
        m.insert(i.clone(), format("val", I64.to_str(i)))?
        i = add(i, 1)
    }

    // Verify position() still returns correct insertion order
    test(loc(), m.position(0).eq(0), "Key 0 should be at position 0")
    test(loc(), m.position(5).eq(5), "Key 5 should be at position 5")
    test(loc(), m.position(10).eq(10), "Key 10 should be at position 10")
    test(loc(), m.position(19).eq(19), "Key 19 should be at position 19")
    test(loc(), m.position(100).eq(sub(0, 1)), "Non-existent key should return -1")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test direct .keys field access
test_map_keys_field := proc() {
    mut m := Map.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    mut keys := m.keys
    test(loc(), keys.len().eq(3), "m.keys should have 3 keys")

    key0 := cast(Str, keys.get_by_ref(0)?)
    test(loc(), key0.eq("alice"), "First key should be alice")
    key1 := cast(Str, keys.get_by_ref(1)?)
    test(loc(), key1.eq("bob"), "Second key should be bob")
    key2 := cast(Str, keys.get_by_ref(2)?)
    test(loc(), key2.eq("charlie"), "Third key should be charlie")

    m.delete()
    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
}

// Test Map.remove
test_map_remove := proc() {
    mut m := Map.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    test(loc(), m.len().eq(3), "Map should have 3 entries before remove")
    test(loc(), m.contains_key("bob"), "Map should contain bob before remove")

    // Remove middle element
    m.remove("bob")

    test(loc(), m.len().eq(2), "Map should have 2 entries after remove")
    test(loc(), not(m.contains_key("bob")), "Map should not contain bob after remove")
    test(loc(), m.contains_key("alice"), "Map should still contain alice")
    test(loc(), m.contains_key("charlie"), "Map should still contain charlie")

    // Verify remaining values are correct
    alice_val := cast(I64, m.get_by_ref("alice")?)
    test(loc(), alice_val.eq(30), "alice should still be 30")
    charlie_val := cast(I64, m.get_by_ref("charlie")?)
    test(loc(), charlie_val.eq(35), "charlie should still be 35")

    // Remove non-existent key (should be no-op)
    m.remove("nonexistent")
    test(loc(), m.len().eq(2), "Map should still have 2 entries after removing non-existent")

    // Remove remaining elements
    m.remove("alice")
    m.remove("charlie")
    test(loc(), m.len().eq(0), "Map should be empty after removing all")
    test(loc(), m.is_empty(), "Map.is_empty should be true")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// ============================================================================
// HashMap Tests (Issue #112)
// ============================================================================

// Test HashMap<Str, I64>
test_hashmap_str_to_i64 := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?
    ages.insert("Charlie", 35)?

    alice_age := cast(I64, ages.get_by_ref("Alice")?)
    test(loc(), alice_age.eq(30), "HashMap: Alice should be 30")
    bob_age := cast(I64, ages.get_by_ref("Bob")?)
    test(loc(), bob_age.eq(25), "HashMap: Bob should be 25")
    charlie_age := cast(I64, ages.get_by_ref("Charlie")?)
    test(loc(), charlie_age.eq(35), "HashMap: Charlie should be 35")

    test(loc(), ages.len().eq(3), "HashMap should have 3 entries")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap<I64, I64>
test_hashmap_i64_to_i64 := proc() {
    mut ages := HashMap.new(I64, I64)
    ages.insert(100, 30)?
    ages.insert(200, 25)?

    age0 := cast(I64, ages.get_by_ref(100)?)
    test(loc(), age0.eq(30), "HashMap: ID 100 should map to 30")
    age1 := cast(I64, ages.get_by_ref(200)?)
    test(loc(), age1.eq(25), "HashMap: ID 200 should map to 25")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap<Str, Vec2>
test_hashmap_str_to_vec2 := proc() {
    mut positions := HashMap.new(Str, Vec2)
    mut player_pos := Vec2(x=10, y=20)
    positions.insert("player", player_pos)?
    mut enemy_pos := Vec2(x=30, y=40)
    positions.insert("enemy", enemy_pos)?

    player := cast(Vec2, positions.get_by_ref("player")?)
    test(loc(), player.x.eq(10), "HashMap: player.x should be 10")
    test(loc(), player.y.eq(20), "HashMap: player.y should be 20")
    enemy := cast(Vec2, positions.get_by_ref("enemy")?)
    test(loc(), enemy.x.eq(30), "HashMap: enemy.x should be 30")
    test(loc(), enemy.y.eq(40), "HashMap: enemy.y should be 40")

    positions.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap insert() - should throw on duplicate keys
test_hashmap_insert_duplicate := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Alice", 35)?
    panic(loc(), "Expected DuplicatedKeyError when inserting duplicate key")
    catch (err: DuplicatedKeyError) {}
    ages.delete()
}

// Test HashMap set() - should overwrite existing keys
test_hashmap_set := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.set("Alice", 30)
    ages.set("Alice", 35)
    test(loc(), ages.len().eq(1), "HashMap: Size should still be 1 after set update")

    age := cast(I64, ages.get_by_ref("Alice")?)
    test(loc(), age.eq(35), "HashMap: Expected age 35 after update")

    ages.delete()

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap get_by_ref() with non-existent key
test_hashmap_get_missing := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?

    _age := cast(I64, ages.get_by_ref("Charlie")?)
    panic(loc(), "Expected KeyNotFoundError for non-existent key")
    catch (err: KeyNotFoundError) {}
    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap contains_key()
test_hashmap_contains_key := proc() {
    mut ages := HashMap.new(Str, I64)
    ages.insert("Alice", 30)?
    ages.insert("Bob", 25)?

    test(loc(), ages.contains_key("Alice"), "HashMap: Should contain Alice")
    test(loc(), ages.contains_key("Bob"), "HashMap: Should contain Bob")
    test(loc(), not(ages.contains_key("Charlie")), "HashMap: Should not contain Charlie")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test empty HashMap operations
test_hashmap_empty := proc() {
    mut m := HashMap.new(Str, I64)
    test(loc(), m.len().eq(0), "Empty HashMap should have size 0")
    test(loc(), m.is_empty(), "Empty HashMap is_empty() should be true")
    test(loc(), not(m.contains_key("anything")), "Empty HashMap should not contain any key")

    m.delete()
}

// Test HashMap growth/resize beyond initial capacity
test_hashmap_growth := proc() {
    mut ages := HashMap.new(I64, I64)

    // Initial bucket count is 16, load factor 0.75 = 12 entries before resize
    // Insert 20 elements to trigger at least one resize
    mut i := 0
    while i.lt(20) {
        ages.insert(i.clone(), i.mul(100))?
        i = i.add(1)
    }

    test(loc(), ages.len().eq(20), "HashMap should have 20 entries after growth")

    // Verify all values are still correct after resize
    val0 := cast(I64, ages.get_by_ref(0)?)
    test(loc(), val0.eq(0), "HashMap: First element should still be 0")
    val10 := cast(I64, ages.get_by_ref(10)?)
    test(loc(), val10.eq(1000), "HashMap: Middle element should be 1000")
    val19 := cast(I64, ages.get_by_ref(19)?)
    test(loc(), val19.eq(1900), "HashMap: Last element should be 1900")

    // Verify contains_key still works after resize
    test(loc(), ages.contains_key(5), "HashMap: Should contain key 5 after growth")
    test(loc(), ages.contains_key(15), "HashMap: Should contain key 15 after growth")
    test(loc(), not(ages.contains_key(25)), "HashMap: Should not contain key 25")

    ages.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap.clear()
test_hashmap_clear := proc() {
    mut m := HashMap.new(Str, I64)

    m.insert("a", 1)?
    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "HashMap should have 3 entries")

    m.clear()
    test(loc(), m.len().eq(0), "HashMap size should be 0 after clear")
    test(loc(), m.is_empty(), "HashMap should be empty after clear")
    test(loc(), not(m.contains_key("a")), "HashMap should not contain 'a' after clear")

    // Should be able to insert again after clear
    m.insert("d", 4)?
    test(loc(), m.len().eq(1), "HashMap should have 1 entry after re-insert")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap len() tracks correctly through various operations
test_hashmap_len_tracking := proc() {
    mut m := HashMap.new(Str, I64)

    test(loc(), m.len().eq(0), "Empty HashMap should have len 0")

    m.insert("a", 1)?
    test(loc(), m.len().eq(1), "HashMap should have len 1 after first insert")

    m.insert("b", 2)?
    m.insert("c", 3)?
    test(loc(), m.len().eq(3), "HashMap should have len 3 after three inserts")

    // set() with existing key should not change len
    m.set("a", 100)
    test(loc(), m.len().eq(3), "HashMap len should stay 3 after set() on existing key")

    // set() with new key should increase len
    m.set("d", 4)
    test(loc(), m.len().eq(4), "HashMap len should be 4 after set() with new key")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
}

// Test multiple set() overwrites
test_hashmap_multiple_overwrites := proc() {
    mut m := HashMap.new(Str, I64)

    m.set("key", 1)
    val1 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val1.eq(1), "HashMap: First set should store 1")

    m.set("key", 2)
    val2 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val2.eq(2), "HashMap: Second set should overwrite to 2")

    m.set("key", 3)
    val3 := cast(I64, m.get_by_ref("key")?)
    test(loc(), val3.eq(3), "HashMap: Third set should overwrite to 3")

    test(loc(), m.len().eq(1), "HashMap: Multiple overwrites should keep len at 1")

    m.delete()

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap with many string keys (stress test for hash distribution)
test_hashmap_many_strings := proc() {
    mut m := HashMap.new(Str, I64)

    // Insert 50 different string keys
    mut i := 0
    while i.lt(50) {
        key := format("key_", I64.to_str(i))
        m.insert(key, i.clone())?
        i = i.add(1)
    }

    test(loc(), m.len().eq(50), "HashMap should have 50 entries")

    // Verify lookups work for various keys
    val0 := cast(I64, m.get_by_ref("key_0")?)
    test(loc(), val0.eq(0), "HashMap: key_0 should be 0")
    val25 := cast(I64, m.get_by_ref("key_25")?)
    test(loc(), val25.eq(25), "HashMap: key_25 should be 25")
    val49 := cast(I64, m.get_by_ref("key_49")?)
    test(loc(), val49.eq(49), "HashMap: key_49 should be 49")

    // Verify non-existent keys
    test(loc(), not(m.contains_key("key_50")), "HashMap: Should not contain key_50")
    test(loc(), not(m.contains_key("nonexistent")), "HashMap: Should not contain nonexistent")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// Test HashMap.remove
test_hashmap_remove := proc() {
    mut m := HashMap.new(Str, I64)
    m.insert("alice", 30)?
    m.insert("bob", 25)?
    m.insert("charlie", 35)?

    test(loc(), m.len().eq(3), "HashMap should have 3 entries before remove")
    test(loc(), m.contains_key("bob"), "HashMap should contain bob before remove")

    // Remove middle element
    m.remove("bob")

    test(loc(), m.len().eq(2), "HashMap should have 2 entries after remove")
    test(loc(), not(m.contains_key("bob")), "HashMap should not contain bob after remove")
    test(loc(), m.contains_key("alice"), "HashMap should still contain alice")
    test(loc(), m.contains_key("charlie"), "HashMap should still contain charlie")

    // Verify remaining values are correct
    alice_val := cast(I64, m.get_by_ref("alice")?)
    test(loc(), alice_val.eq(30), "HashMap alice should still be 30")
    charlie_val := cast(I64, m.get_by_ref("charlie")?)
    test(loc(), charlie_val.eq(35), "HashMap charlie should still be 35")

    // Remove non-existent key (should be no-op)
    m.remove("nonexistent")
    test(loc(), m.len().eq(2), "HashMap should still have 2 entries after removing non-existent")

    // Remove remaining elements
    m.remove("alice")
    m.remove("charlie")
    test(loc(), m.len().eq(0), "HashMap should be empty after removing all")
    test(loc(), m.is_empty(), "HashMap.is_empty should be true")

    m.delete()

    catch (err: DuplicatedKeyError) {
        println("ERROR:", loc(), "Unexpected DuplicatedKeyError")
        println(err.msg)
        exit(1)
    }
    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), "Unexpected KeyNotFoundError")
        println(err.msg)
        exit(1)
    }
}

// ============================================================================
// Run all Map tests
// ============================================================================
test_map_i64_to_i64()
test_map_str_to_vec2()
test_map_str_to_vec_str()
test_map_u8_to_bool()
test_map_insert_duplicate()
test_map_set()
test_map_get_missing()
test_map_contains_key()
test_map_position()
test_map_empty()
test_map_growth()
test_map_delete()
test_map_len_tracking()
test_map_multiple_overwrites()
test_map_order_after_growth()
test_map_keys_field()
test_map_remove()

// ============================================================================
// Run all HashMap tests
// ============================================================================
test_hashmap_str_to_i64()
test_hashmap_i64_to_i64()
test_hashmap_str_to_vec2()
test_hashmap_insert_duplicate()
test_hashmap_set()
test_hashmap_get_missing()
test_hashmap_contains_key()
test_hashmap_empty()
test_hashmap_growth()
test_hashmap_clear()
test_hashmap_len_tracking()
test_hashmap_multiple_overwrites()
test_hashmap_many_strings()
test_hashmap_remove()

test_map_get_by_ref := proc() {
    mut m := Map.new(Str, I64)
    m.set("a", 10)
    m.set("b", 20)

    ref_a := m.get_by_ref("a")?
    mut val := 0
    ref_a.dereference(I64, val)
    assert_eq(loc(), 10, val)

    // Missing key throws
    mut threw := false
    _bad := m.get_by_ref("missing")?
    catch (err: KeyNotFoundError) {
        threw = true
    }
    test(loc(), threw, "Map.get_by_ref missing key throws")

    m.delete()
}

test_hashmap_get_by_ref := proc() {
    mut m := HashMap.new(Str, I64)
    m.set("x", 42)
    m.set("y", 99)

    ref_x := m.get_by_ref("x")?
    mut val := 0
    ref_x.dereference(I64, val)
    assert_eq(loc(), 42, val)

    // Missing key throws
    mut threw := false
    _bad := m.get_by_ref("missing")?
    catch (err: KeyNotFoundError) {
        threw = true
    }
    test(loc(), threw, "HashMap.get_by_ref missing key throws")

    m.delete()
}

test_map_get_by_ref()
test_hashmap_get_by_ref()
