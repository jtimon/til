mode test

// Basic control flow (execution):

// regular comment
/* block comment */
/** doc comment */
# another comment
/*

multi
line
comments

/*
nested too
*/

doesn't break with nesting like C // REM nested comments don't work properly in til-mode, but that's an emacs limitation
                                  // TODO rewrite emacs in til and fix this

*/ // TODO should it be unterminated comment when we remove this? or give errors in "doesn't break"

// 'if' statements:

test_if_statement := proc() {
    if not(gt(4, 2)) {
        panic(loc(), "'gt(4, 2)' (aka '4 > 2') is not true") // Obviously this should never happen
    }
    // If we reach here, the test passed
}
test_if_statement()

// 'if/elif/else/' statements:

test_if_elif_else := proc() {
    mut result := ""
    // if 42 { // fails because ints are not allowed for conditions, only bool
    if gt(2, 4) {
        result = "if branch"
    } else if gt(3, 4) {
        result = "elif branch"
    } else {
        result = "else branch"
    }
    assert_eq_str(loc(), "else branch", result)
}
test_if_elif_else()

// while loops:
test_while_loop := proc() {
    mut it := 0 // one has to use the 'mut' keyword for actual variables, since all declarations are const by default
    mut count := 0
    // while 42 { // fails, because while expects a bool first, not an int
    while lt(it, 5) {
        count = add(count, 1)
        it = add(it, 1)
    }
    assert_eq(loc(), 5, it)
    assert_eq(loc(), 5, count)
}
test_while_loop()

// for loops:
test_for_loop := proc() {
    mut sum := 0
    for i in 0..5 {
        sum = add(sum, i)
    }
    assert_eq(loc(), 10, sum) // 0+1+2+3+4 = 10
}
test_for_loop()

// switch statements:

test_int_switch := proc() {
    check_answer := proc(to_switch: I64) returns Bool {
        switch to_switch {
        case add(40, 2):
            return true; // semicolons are optional here too
        case:
            return false;
        }
        return false
    }

    test(loc(), not(check_answer(0)), "0 is not the answer")
    test(loc(), check_answer(42), "42 is the answer")
    test(loc(), not(check_answer(69)), "69 is not the answer")
    // test_int_switch(69);; // fails because there's no need for ';;' (aka empty statements), try 'if true {}' instead, whatever you want that for.
}
test_int_switch()

test_int_range := proc() {
    classify_range := proc(x: I64) returns I64 {
        switch x {
        case 1..5:
            return 1 // between 1 and 5
        case 10..20:
            return 2 // between 10 and 20
        case:
            return 0 // out of ranges
        }
        return 0
    }

    assert_eq(loc(), 1, classify_range(3))
    assert_eq(loc(), 2, classify_range(10))
    assert_eq(loc(), 2, classify_range(19))
    assert_eq(loc(), 2, classify_range(20))
    assert_eq(loc(), 0, classify_range(42))
}
test_int_range()

test_for_loop_range := proc(min_range : I64, max_range : I64) {

    mut sum_for := 0
    for i in min_range..max_range {
        sum_for = sum_for.add(i)
    }

    mut sum_while := 0
    mut j := min_range
    while j.lt(max_range) {
        sum_while = sum_while.add(j)
        j.inc()
    }

    assert_eq(loc(), sum_for, sum_while)
}
test_for_loop_range(0, 12)
test_for_loop_range(3, 5)
test_for_loop_range(4, 2) // TODO this should probably fail, but it hasn't been tested yet

// Test: Nested function returns and stack frame handling
test_nested_function_returns := proc() {
    // Simple return (baseline)
    test_simple := proc() returns I64 {
        return 42
    }
    assert_eq(loc(), 42, test_simple())

    // Nested function calls with returns
    inner_function := proc() returns I64 {
        return 100
    }

    middle_function := proc() returns I64 {
        mut val := inner_function()
        return add(val, 10)  // Should return 110
    }

    outer_function := proc() returns I64 {
        mut val := middle_function()
        return add(val, 1)  // Should return 111
    }

    assert_eq(loc(), 111, outer_function())

    // Deep nesting (4+ levels)
    level_4 := proc() returns I64 {
        return 4
    }

    level_3 := proc() returns I64 {
        mut v := level_4()
        return add(v, 3)  // Should be 7
    }

    level_2 := proc() returns I64 {
        mut v := level_3()
        return add(v, 2)  // Should be 9
    }

    level_1 := proc() returns I64 {
        mut v := level_2()
        return add(v, 1)  // Should be 10
    }

    assert_eq(loc(), 10, level_1())

    // Test with simple helper function
    add_ten_helper := func(x: I64) returns I64 {
        return add(x, 10)
    }

    assert_eq(loc(), 15, add_ten_helper(5))
}
test_nested_function_returns()

// break and continue statements:

test_break_in_while := proc() {
    mut sum := 0
    mut i := 0
    while lt(i, 10) {
        if i.eq(5) {
            break
        }
        sum = sum.add(i)
        i.inc()
    }
    // sum should be 0+1+2+3+4 = 10 (breaks before adding 5)
    assert_eq(loc(), 10, sum)
    assert_eq(loc(), 5, i) // i should be 5 when break happened
}
test_break_in_while()

test_continue_in_while := proc() {
    mut sum := 0
    mut i := 0
    while lt(i, 10) {
        i.inc()
        if i.eq(5) {
            continue // skip adding 5 to sum
        }
        sum = sum.add(i)
    }
    // sum should be 1+2+3+4+6+7+8+9+10 = 55 - 5 = 50
    assert_eq(loc(), 50, sum)
}
test_continue_in_while()

test_break_in_for := proc() {
    mut sum := 0
    for i in 0..10 {
        if i.eq(5) {
            break
        }
        sum = sum.add(i)
    }
    // sum should be 0+1+2+3+4 = 10
    assert_eq(loc(), 10, sum)
}
test_break_in_for()

// NOTE: continue in for loops does NOT work because for loops desugar to while
// with the increment at the end of the body. Continue skips the increment,
// causing an infinite loop. Use while loops with manual increment if you need continue.

test_nested_loop_break := proc() {
    // break only breaks innermost loop
    mut outer_count := 0
    mut inner_count := 0
    mut i := 0
    while lt(i, 3) {
        outer_count.inc()
        mut j := 0
        while lt(j, 5) {
            inner_count.inc()
            if j.eq(2) {
                break // breaks inner loop only
            }
            j.inc()
        }
        i.inc()
    }
    // outer loop runs 3 times
    assert_eq(loc(), 3, outer_count)
    // inner loop runs 3 times for each outer (0,1,2 then break) = 3*3 = 9
    assert_eq(loc(), 9, inner_count)
}
test_nested_loop_break()

test_break_after_statements := proc() {
    mut a := 0
    mut b := 0
    mut i := 0
    while lt(i, 10) {
        a.inc()
        b = b.add(i)
        if i.eq(3) {
            break
        }
        i.inc()
    }
    // a should be 4 (0,1,2,3 then break)
    assert_eq(loc(), 4, a)
    // b should be 0+1+2+3 = 6
    assert_eq(loc(), 6, b)
}
test_break_after_statements()
