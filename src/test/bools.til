mode test

// boolean logic:

test(loc(), true, "true is true")
test(loc(), not(false), "not: not false is true")
test(loc(), not(not(true)), "not: not not true is true")
// true.and(1111) // fails, 'and' cannot take number literals
// true.and("asdfgdfafgd") // fails, 'and' cannot take string literals
test(loc(), true.and(true), "true.and(true) == true")
test(loc(), not(true.and(false)), "true.and(false) == false")
test(loc(), not(true.and(false)), "false.and(true) == false")
test(loc(), not(false.and(true)), "false.and(true) == false")
test(loc(), not(false.and(false)), "false.and(false) == false")

test(loc(), true.or(true), "true.or(true) == true")
test(loc(), true.or(false), "true.or(false) == true")
test(loc(), false.or(true), "false.or(true) == true")
test(loc(), not(false.or(false)), "false.or(false) == false")

// note that both 'and' and 'or' can take any number of bools as args, like in lisp
// test(loc(), or(false, true, true), "or(false, false, true) == true")
// test(loc(), not(and(false, true, true)), "and(false, false, true) == false")

test(loc(), true.or(false), "and: true or false is true")

test(loc(), xor(true, false), "and: true xor false is true")
test(loc(), not(xor(true, true)), "xor(true, true) == false")

// --------------- TODO remove redundancies

// Bool to int tests tests
test(loc(), I64.eq(Bool.to_i64(true), 1), "Bool.to_i64(true) = 1")
test(loc(), I64.eq(Bool.to_i64(false), 0), "Bool.to_i64(false) = 0")

// Testing 'and' with all combinations
test(loc(), true.and(true), "true AND true = true")
test(loc(), not(true.and(false)), "true AND false = false")
test(loc(), not(false.and(true)), "false AND true = false")
test(loc(), not(false.and(false)), "false AND false = false")

// variadic 'and'
test(loc(), and(true), "true AND = true")
test(loc(), not(and(false)), "false AND = false")
test(loc(), and(true, true, true), "true AND true AND true = true")
test(loc(), not(and(true, false, true)), "true AND false AND true = false")

// Testing 'or' with all combinations
test(loc(), not(false.or(false)), "false OR false = false")
test(loc(), true.or(false), "true OR false = true")
test(loc(), false.or(true), "false OR true = true")
test(loc(), true.or(true), "true OR true = true")

// variadic 'or'
test(loc(), or(true), "true OR = true")
test(loc(), not(or(false)), "false OR = false")
test(loc(), or(false, false, true), "false OR false OR true = true")
test(loc(), not(or(false, false, false)), "false OR false OR false = false")

// Testing 'xor' with all combinations
test(loc(), xor(true, false), "true XOR false = true")
test(loc(), xor(false, true), "false XOR true = true")
test(loc(), not(xor(true, true)), "true XOR true = false")
test(loc(), not(xor(false, false)), "false XOR false = false")

// Testing 'xnor' with all combinations
test(loc(), not(xnor(true, false)), "true XNOR false = false")
test(loc(), not(xnor(false, true)), "false XNOR true = false")
test(loc(), xnor(true, true), "true XNOR true = true")
test(loc(), xnor(false, false), "false XNOR false = true")

// Testing 'Bool.eq' with all combinations (it is equivalent to xnor)
test(loc(), not(Bool.eq(true, false)), "true BOOL.eq false = false")
test(loc(), not(Bool.eq(false, true)), "false BOOL.eq true = false")
test(loc(), Bool.eq(true, true), "true BOOL.eq true = true")
test(loc(), Bool.eq(false, false), "false BOOL.eq false = true")

// Test Bool.to_str()
aaa := true
test(loc(), Str.eq("true", aaa.to_str()), "'true' = Bool.to_str(true)") // Use associated functions as methods with UFCS
test(loc(), Str.eq("true", aaa.to_str()), "'true' = Bool.to_str(true)")
test(loc(), Str.eq("true", Bool.to_str(true)), "'true' = Bool.to_str(true)")
test(loc(), Str.eq("false", Bool.to_str(false)), "'false' = Bool.to_str(false)")
test(loc(), Str.eq("false", false.and(false).to_str()), "'false' = Bool.to_str(false.and(false)))")
