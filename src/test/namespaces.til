mode test

// Struct definitions can be used as namespaces by declaring only constants in them (no mut)
MyNamespace := struct {

    field_static_str : Str = "hello MyNamespace.field_static_str"
    field_static_bool : Bool = true
    field_static_int : I64 = 42

    proc_static := proc() {
        // Side effects (non memoizable effects) are allowed in procs
        assert_eq(loc(), 42, MyNamespace.field_static_int)
    }

    func_static_str := func() returns Str {
        return "func 'func_static_str' in struct 'MyNamespace' has been called"
    }
}

test_namespace_fields := proc() {
    assert_eq_str(loc(), "hello MyNamespace.field_static_str", MyNamespace.field_static_str)
    assert_eq(loc(), 42, MyNamespace.field_static_int)
    test(loc(), MyNamespace.field_static_bool, "field_static_bool should be true")
    MyNamespace.proc_static()
    assert_eq_str(loc(), MyNamespace.func_static_str(), "func 'func_static_str' in struct 'MyNamespace' has been called")
    // assert_eq_str(loc(), MyNamespace.proc_static_str(), "func 'func_static_str' in struct 'MyNamespace' has been called") // TODO improve this error messages, only one is good
// src/test/namespaces.til:26:26: type ERROR: 'MyNamespace' is of type 'struct' and thus can't have a 'proc_static_str' associated function
// src/test/namespaces.til:26:26: type ERROR: Struct 'MyNamespace' has no member 'proc_static_str'
// src/test/namespaces.til:26:26: type ERROR: Failed to resolve nested function call: src/test/namespaces.til:26:26: type ERROR: 'MyNamespace' is of type 'struct' and thus can't have a 'proc_static_str' associated function

}
test_namespace_fields()

// ========================================================================
// Test Issue #108: namespace keyword for adding methods to types
// ========================================================================

// Test: namespace block for enums
SimpleEnum := enum {
    A,
    B,
    C,
}

namespace SimpleEnum {
    get_default := func() returns SimpleEnum {
        return SimpleEnum.A
    }

    is_a := func(self: SimpleEnum) returns Bool {
        switch self {
        case SimpleEnum.A:
            return true
        case:
            return false
        }
    }

    describe := func(self: SimpleEnum) returns Str {
        switch self {
        case SimpleEnum.A:
            return "variant A"
        case SimpleEnum.B:
            return "variant B"
        case SimpleEnum.C:
            return "variant C"
        }
        return "unknown"
    }
}

test_enum_namespace := proc() {
    // Test static function on enum
    default_val := SimpleEnum.get_default()
    test(loc(), SimpleEnum.is_a(default_val), "get_default should be A")

    // Test instance method via UFCS
    val_b := SimpleEnum.B
    test(loc(), not(val_b.is_a()), "B should not be A")

    // Test describe method (using explicit variables since chained calls like SimpleEnum.A.describe() don't work yet)
    val_a := SimpleEnum.A
    val_b2 := SimpleEnum.B
    val_c := SimpleEnum.C
    assert_eq_str(loc(), "variant A", val_a.describe())
    assert_eq_str(loc(), "variant B", val_b2.describe())
    assert_eq_str(loc(), "variant C", val_c.describe())
}
test_enum_namespace()

// Test: namespace block for structs (external method definition)
Point := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

namespace Point {
    new := func(x_val: I64, y_val: I64) returns Point {
        return Point(x=x_val, y=y_val)
    }

    origin := func() returns Point {
        return Point(x=0, y=0)
    }

    add := func(self: Point, other: Point) returns Point {
        return Point(x=self.x.add(other.x), y=self.y.add(other.y))
    }

    distance_squared := func(self: Point) returns I64 {
        return self.x.mul(self.x).add(self.y.mul(self.y))
    }
}

test_struct_namespace := proc() {
    // Test static factory functions
    p1 := Point.new(3, 4)
    assert_eq(loc(), 3, p1.x)
    assert_eq(loc(), 4, p1.y)

    origin := Point.origin()
    assert_eq(loc(), 0, origin.x)
    assert_eq(loc(), 0, origin.y)

    // Test instance methods via UFCS
    p2 := Point.new(1, 2)
    p3 := p1.add(p2)
    assert_eq(loc(), 4, p3.x)
    assert_eq(loc(), 6, p3.y)

    // Test distance_squared
    assert_eq(loc(), 25, p1.distance_squared())  // 3*3 + 4*4 = 9 + 16 = 25
}
test_struct_namespace()
