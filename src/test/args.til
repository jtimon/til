mode test

import("core.vec")

// Test basic argument passing

Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    clone := func(self: Vec2) returns Vec2 {
        return Vec2(x=self.x, y=self.y)
    }
}

Color := enum {
    Red,
    Green,
    Blue,
}

// === Test primitive argument passing ===

test_i64_arg := proc(n: I64) returns I64 {
    return mul(n, 2)
}

test_i64_args := proc() {
    result := test_i64_arg(21)
    assert_eq(loc(), 42, result)
}
test_i64_args()

test_bool_arg := proc(b: Bool) returns Bool {
    return not(b)
}

test_bool_args := proc() {
    result := test_bool_arg(true)
    test(loc(), Bool.eq(false, result), "bool arg should be negated")
}
test_bool_args()

test_str_arg := proc(s: Str) returns Str {
    return format(s, " world")
}

test_str_args := proc() {
    result := test_str_arg("hello")
    assert_eq_str(loc(), "hello world", result)
}
test_str_args()

// === Test struct argument passing ===

sum_vec := func(v: Vec2) returns I64 {
    return add(v.x, v.y)
}

test_struct_arg := proc() {
    v := Vec2(x=10, y=20)
    result := sum_vec(v)
    assert_eq(loc(), 30, result)
}
test_struct_arg()

// === Test enum argument passing ===

color_to_i64 := func(c: Color) returns I64 {
    switch c {
    case Color.Red: return 1
    case Color.Green: return 2
    case Color.Blue: return 3
    }
}

test_enum_arg := proc() {
    result := color_to_i64(Color.Green)
    assert_eq(loc(), 2, result)
}
test_enum_arg()

// === Test mut primitive arguments ===

double_i64 := proc(mut n: I64) {
    n = mul(n, 2)
}

test_mut_i64 := proc() {
    mut value := 21
    double_i64(value)
    assert_eq(loc(), 42, value)
}
test_mut_i64()

toggle_bool := proc(mut b: Bool) {
    b = not(b)
}

test_mut_bool := proc() {
    mut flag := true
    toggle_bool(flag)
    test(loc(), Bool.eq(false, flag), "flag should be toggled to false")
}
test_mut_bool()

append_str := proc(mut s: Str, suffix: Str) {
    s = format(s, suffix)
}

test_mut_str := proc() {
    mut text := "hello"
    append_str(text, " world")
    assert_eq_str(loc(), "hello world", text)
}
test_mut_str()

// === Test mut struct arguments ===

scale_vec := proc(mut v: Vec2, factor: I64) {
    v.x = mul(v.x, factor)
    v.y = mul(v.y, factor)
}

test_mut_struct := proc() {
    mut v := Vec2(x=3, y=4)
    scale_vec(v, 10)
    assert_eq(loc(), 30, v.x)
    assert_eq(loc(), 40, v.y)
}
test_mut_struct()

// === Test mut enum arguments ===

next_color := proc(mut c: Color) {
    switch c {
    case Color.Red: c = Color.Green
    case Color.Green: c = Color.Blue
    case Color.Blue: c = Color.Red
    }
}

test_mut_enum := proc() {
    mut col := Color.Red
    next_color(col)
    assert_eq(loc(), color_to_i64(Color.Green), color_to_i64(col))

    next_color(col)
    assert_eq(loc(), color_to_i64(Color.Blue), color_to_i64(col))
}
test_mut_enum()

// === Test multiple arguments ===

add_three := func(a: I64, b: I64, c: I64) returns I64 {
    return add(add(a, b), c)
}

test_multiple_args := proc() {
    result := add_three(10, 20, 30)
    assert_eq(loc(), 60, result)
}
test_multiple_args()

// === Test mixed mut and non-mut arguments ===

add_to_first := proc(mut a: I64, b: I64) {
    a = add(a, b)
}

test_mixed_mut := proc() {
    mut x := 10
    y := 20
    add_to_first(x, y)
    assert_eq(loc(), 30, x)
    assert_eq(loc(), 20, y)  // y should be unchanged
}
test_mixed_mut()

translate_vec := proc(mut v: Vec2, dx: I64, dy: I64) {
    v.x = add(v.x, dx)
    v.y = add(v.y, dy)
}

test_struct_mixed_mut := proc() {
    mut pos := Vec2(x=100, y=200)
    translate_vec(pos, 50, 75)
    assert_eq(loc(), 150, pos.x)
    assert_eq(loc(), 275, pos.y)
}
test_struct_mixed_mut()

// === Test that non-mut struct arguments don't persist changes ===

// Note: This would normally be a compile error if we tried to modify
// a non-mut parameter, but we can test that passing a struct doesn't
// affect the original when using non-mut

copy_and_modify := func(v: Vec2) returns Vec2 {
    mut dup := v
    dup.x = 999
    dup.y = 888
    return dup
}

test_non_mut_isolation := proc() {
    original := Vec2(x=1, y=2)
    modified := copy_and_modify(original)

    // Original should be unchanged
    assert_eq(loc(), 1, original.x)
    assert_eq(loc(), 2, original.y)

    // Modified copy should have new values
    assert_eq(loc(), 999, modified.x)
    assert_eq(loc(), 888, modified.y)
}
test_non_mut_isolation()

// === Test arrays with mut arguments ===

push_value := proc(mut arr: Vec, value: I64) {
    arr.push(value)
}

test_mut_array := proc() {
    mut numbers := Vec.new(I64)

    assert_eq(loc(), 0, numbers.len())

    push_value(numbers, 42)
    assert_eq(loc(), 1, numbers.len())

    push_value(numbers, 84)
    assert_eq(loc(), 2, numbers.len())

    mut val0 := 0
    numbers.get(0, val0)?
    assert_eq(loc(), 42, val0)

    mut val1 := 0
    numbers.get(1, val1)?
    assert_eq(loc(), 84, val1)

    numbers.delete()

    // Catch unexpected errors at end
    catch (err: OutOfBounds) {
        println("ERROR:", loc(), "Unexpected OutOfBounds")
        println(err.msg)
        exit(1)
    }
}
test_mut_array()

// === Test nested struct fields ===

Point := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    clone := func(self: Point) returns Point {
        return Point(x=self.x, y=self.y)
    }
}

Line := struct {
    mut start : Point = Point()
    mut end   : Point = Point()

    clone := func(self: Line) returns Line {
        return Line(start=self.start.clone(), end=self.end.clone())
    }
}

move_line := proc(mut line: Line, dx: I64, dy: I64) {
    line.start.x = add(line.start.x, dx)
    line.start.y = add(line.start.y, dy)
    line.end.x = add(line.end.x, dx)
    line.end.y = add(line.end.y, dy)
}

test_nested_struct_mut := proc() {
    mut l := Line(start=Point(x=10, y=20), end=Point(x=30, y=40))

    move_line(l, 5, 10)

    assert_eq(loc(), 15, l.start.x)
    assert_eq(loc(), 30, l.start.y)
    assert_eq(loc(), 35, l.end.x)
    assert_eq(loc(), 50, l.end.y)
}
test_nested_struct_mut()

// === Test copy keyword ===

// Validation test: mut and copy are mutually exclusive (parser enforced)
// Uncomment to verify this produces a parse error:
/*
test_mut_copy_error := proc(mut copy x: I64) {
    x = 10
}
*/
/*
test_copy_mut_error := proc(copy mut x: I64) {
    x = 10
}
*/

// Test 1: copy parameter with primitives can be modified
test_copy_i64 := proc(copy x: I64) returns I64 {
    x = add(x, 10)
    return x
}

test_copy_primitive := proc() {
    original := 42
    result := test_copy_i64(original)
    assert_eq(loc(), 52, result)
    assert_eq(loc(), 42, original)  // original unchanged
}
test_copy_primitive()

// Test 2: copy parameter with struct can be modified
test_copy_struct := proc(copy v: Vec2) returns Vec2 {
    v.x = 999
    v.y = 888
    return v
}

test_copy_struct_modification := proc() {
    original := Vec2(x=1, y=2)
    modified := test_copy_struct(original)

    // Modified copy has new values
    assert_eq(loc(), 999, modified.x)
    assert_eq(loc(), 888, modified.y)

    // Original unchanged
    assert_eq(loc(), 1, original.x)
    assert_eq(loc(), 2, original.y)
}
test_copy_struct_modification()

// Test 3: Multiple copy parameters
test_multiple_copy := proc(copy a: I64, copy b: I64) returns I64 {
    a = mul(a, 2)
    b = mul(b, 3)
    return add(a, b)
}

test_multiple_copy_params := proc() {
    x := 10
    y := 20
    result := test_multiple_copy(x, y)
    assert_eq(loc(), 80, result)  // (10*2) + (20*3) = 80
    assert_eq(loc(), 10, x)  // originals unchanged
    assert_eq(loc(), 20, y)
}
test_multiple_copy_params()

// Test 4: Mix of copy, mut, and immutable parameters
test_mixed_params := proc(immut_x: I64, mut m_y: I64, copy c_z: I64) returns I64 {
    // immut_x cannot be modified (would be compile error)
    m_y = mul(m_y, 2)  // modifies caller's value
    c_z = mul(c_z, 3)  // modifies local copy only
    return add(add(immut_x, m_y), c_z)
}

test_mixed_param_modes := proc() {
    a := 1
    mut b := 10
    c := 100

    result := test_mixed_params(a, b, c)

    assert_eq(loc(), 321, result)  // 1 + 20 + 300 = 321
    assert_eq(loc(), 1, a)    // immutable: unchanged
    assert_eq(loc(), 20, b)   // mut: changed to 20
    assert_eq(loc(), 100, c)  // copy: unchanged
}
test_mixed_param_modes()

// Test 5: copy parameter can be reassigned entirely
test_copy_reassignment := proc(copy v: Vec2) returns Vec2 {
    v = Vec2(x=7, y=8)  // completely replace the copy
    return v
}

test_copy_full_reassignment := proc() {
    original := Vec2(x=1, y=2)
    result := test_copy_reassignment(original)

    assert_eq(loc(), 7, result.x)
    assert_eq(loc(), 8, result.y)
    assert_eq(loc(), 1, original.x)
    assert_eq(loc(), 2, original.y)
}
test_copy_full_reassignment()

// Test 6: Nested struct with copy
test_copy_nested_struct := proc(copy line: Line) returns Line {
    line.start.x = 100
    line.start.y = 200
    line.end.x = 300
    line.end.y = 400
    return line
}

test_copy_nested := proc() {
    mut original := Line(start=Point(x=1, y=2), end=Point(x=3, y=4))

    modified := test_copy_nested_struct(original)

    // Modified has new values
    assert_eq(loc(), 100, modified.start.x)
    assert_eq(loc(), 200, modified.start.y)
    assert_eq(loc(), 300, modified.end.x)
    assert_eq(loc(), 400, modified.end.y)

    // Original unchanged
    assert_eq(loc(), 1, original.start.x)
    assert_eq(loc(), 2, original.start.y)
    assert_eq(loc(), 3, original.end.x)
    assert_eq(loc(), 4, original.end.y)
}
test_copy_nested()

// === Test that declarations create independent copies ===

test_declaration_creates_copy := proc() {
    original := Vec2(x=1, y=2)
    mut dup := original  // Should create copy, not share offset
    dup.x = 999
    dup.y = 888

    // Original should be unchanged - declarations should copy
    assert_eq(loc(), 1, original.x)
    assert_eq(loc(), 2, original.y)

    // Dup should have new values
    assert_eq(loc(), 999, dup.x)
    assert_eq(loc(), 888, dup.y)
}
test_declaration_creates_copy()

// === Test own keyword for ownership transfer ===
// NOTE: Own keyword implementation has bugs - tests disabled for now
// TODO: Fix infinite loop and field access issues

// Test 1: own parameter with primitive (I64)
consume_i64 := proc(own n: I64) returns I64 {
    return mul(n, 2)
}

test_own_primitive := proc() {
    mut x := 42
    result := consume_i64(x)
    assert_eq(loc(), 84, result)
    // x should still exist in this context (own parameters don't remove from caller yet)
    // This will be implemented later when we add use-after-move checking
}
test_own_primitive()

// Test 2: own parameter with struct - test field access
consume_vec := proc(own v: Vec2) returns I64 {
    return add(v.x, v.y)
}

test_own_struct := proc() {
    mut point := Vec2(x=10, y=20)
    result := consume_vec(point)
    assert_eq(loc(), 30, result)
}
test_own_struct()

// Test 3: own parameter can modify the received value
modify_own_struct := proc(own v: Vec2) returns Vec2 {
    v.x = 100
    v.y = 200
    return v
}

test_own_can_modify := proc() {
    mut original := Vec2(x=1, y=2)
    modified := modify_own_struct(original)
    assert_eq(loc(), 100, modified.x)
    assert_eq(loc(), 200, modified.y)
}
test_own_can_modify()

// Test 4: own with string
consume_string := proc(own s: Str) returns Str {
    return format(s, " consumed")
}

test_own_string := proc() {
    mut text := "hello"
    result := consume_string(text)
    assert_eq_str(loc(), "hello consumed", result)
}
test_own_string()

// Test 5: own with expression (not a variable) - should allocate fresh
test_own_expression := proc() {
    result := consume_vec(Vec2(x=5, y=15))
    assert_eq(loc(), 20, result)  // 5+15=20
}
test_own_expression()

// Test 6: own parameter with nested struct
consume_line := proc(own l: Line) returns I64 {
    return add(add(l.start.x, l.start.y), add(l.end.x, l.end.y))
}

test_own_nested_struct := proc() {
    mut line := Line()
    line.start.x = 1
    line.start.y = 2
    line.end.x = 3
    line.end.y = 4

    result := consume_line(line)
    assert_eq(loc(), 10, result)  // 1+2+3+4 = 10
}
test_own_nested_struct()

// Test 7: Multiple own parameters
sum_owned := proc(own a: I64, own b: I64) returns I64 {
    return add(a, b)
}

test_multiple_own := proc() {
    mut x := 10
    mut y := 20
    result := sum_owned(x, y)
    assert_eq(loc(), 30, result)
}
test_multiple_own()

// Test 8: Mix of own, mut, and regular parameters
mixed_params := proc(normal: I64, mut m: I64, own o: I64) returns I64 {
    m = mul(m, 2)
    return add(add(normal, m), o)
}

test_mixed_own := proc() {
    a := 1
    mut b := 10
    mut c := 100

    result := mixed_params(a, b, c)
    assert_eq(loc(), 121, result)  // 1 + 20 + 100 = 121
    assert_eq(loc(), 20, b)  // b was modified through mut
}
test_mixed_own()

// === Step 1: Named Arguments ===

test_named_args_basic := proc() {
    // Helper function
    minus := func(a: I64, b: I64) returns I64 { return sub(a, b) }

    // Positional (existing behavior)
    assert_eq(loc(), 7, minus(10, 3))

    // Named args
    assert_eq(loc(), 7, minus(a=10, b=3))
    assert_eq(loc(), 7, minus(b=3, a=10))

    // Mixed positional and named
    assert_eq(loc(), 7, minus(10, b=3))
}
test_named_args_basic()

// === Step 2: Optional Arguments (with defaults) ===

greet := func(name: Str, greeting: Str = "Hello") returns Str {
    return format(greeting, " ", name)
}

test_optional_args := proc() {
    // With default
    assert_eq_str(loc(), "Hello World", greet("World"))
    // With explicit value
    assert_eq_str(loc(), "Hi World", greet("World", "Hi"))
    // With named arg
    assert_eq_str(loc(), "Hey World", greet("World", greeting="Hey"))
}
test_optional_args()

// === Step 3: Variadic Arguments ===

sum_all := func(numbers: ..I64) returns I64 {
    mut total := 0
    for n: I64 in numbers {
        total = add(total, n)
    }
    return total
}

test_variadic_args := proc() {
    assert_eq(loc(), 0, sum_all())
    assert_eq(loc(), 5, sum_all(5))
    assert_eq(loc(), 15, sum_all(1, 2, 3, 4, 5))
}
test_variadic_args()

join_strings := func(sep: Str, parts: ..Str) returns Str {
    mut result := ""
    mut first := true
    for part: Str in parts {
        if first {
            result = part
            first = false
        } else {
            result = format(result, sep, part)
        }
    }
    return result
}

test_variadic_strings := proc() {
    assert_eq_str(loc(), "", join_strings(", "))
    assert_eq_str(loc(), "a", join_strings(", ", "a"))
    assert_eq_str(loc(), "a, b, c", join_strings(", ", "a", "b", "c"))
}
test_variadic_strings()

// === Step 4: Optional + Variadic (the tricky case) ===

// This is what run_cmd would ideally look like:
// run_cmd(mut output: Str, timeout: I64 = 0, args: ..Str) returns I64

// Test case: optional arg before variadic
log_with_level := func(level: I64 = 1, messages: ..Str) returns Str {
    mut result := format("[", level.to_str(), "] ")
    for msg: Str in messages {
        result = format(result, msg)
    }
    return result
}

test_optional_before_variadic := proc() {
    // Explicit level - works
    assert_eq_str(loc(), "[2] hello world", log_with_level(2, "hello ", "world"))

    // Default level - should use default when type doesn't match
    // Bug #61 fixed: typer now skips optional args before variadic when type doesn't match
    assert_eq_str(loc(), "[1] hello world", log_with_level("hello ", "world"))
}
test_optional_before_variadic()
