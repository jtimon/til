// Bug #159: Test deep copy semantics in struct cloning
// When doing `mut cloned := original`, the clone should be independent.
// Fixed: garbager inserts Type.clone() calls, so Ptr fields are deep copied.

mode test

Container := struct {
    mut items: Vec = Vec.new(I64)
}

// Test shallow copy bug by modifying an existing element (not pushing)
// This avoids reallocation which could mask the bug
test_shallow_copy_bug := proc() {
    mut original := Container()
    original.items.push(own 10)
    original.items.push(own 20)
    original.items.push(own 30)

    mut cloned := original

    // Modify existing element in clone (no reallocation)
    cloned.items.set(0, own 999)?

    // Read values
    orig_val := cast(I64, original.items.get(0)?)
    clone_val := cast(I64, cloned.items.get(0)?)

    // Clone is independent: original should be 10, cloned should be 999
    assert_eq(loc(), 10, orig_val)
    assert_eq(loc(), 999, clone_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

test_shallow_copy_bug()
