// Bug #159: Test deep copy semantics in struct cloning
// All struct operations should produce independent copies, not shared memory.
//
// FIXED: Declarations (mut x := y) - calls Type.clone()
// FIXED: Reassignments (x = y) - now uses clone (interpreter + ccodegen)
// FIXED: Field assignments (obj.field = x) - now uses clone (interpreter + ccodegen)
// FIXED: Named struct args (Foo(bar: x)) - calls Type.clone() on identifier args
// FIXED: copy param passing - calls Type.clone() for deep copy

mode test

Container := struct {
    mut items: Vec = Vec.new(I64)
}

Holder := struct {
    mut data: Container = Container()
}

// Test 1: Declaration (mut x := y) - FIXED
test_declaration := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)
    original.items.push(30)

    mut cloned := original

    // Modify existing element in clone (no reallocation)
    cloned.items.set(0, 999)?

    // Read values
    mut orig_val := 0
    original.items.get(0, orig_val)?
    mut clone_val := 0
    cloned.items.get(0, clone_val)?

    // FIXED: With clone(), they have independent memory
    assert_eq(loc(), 10, orig_val)
    assert_eq(loc(), 999, clone_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 2: Reassignment (x = y) - FIXED
test_reassignment := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)

    mut other := Container()
    other.items.push(100)

    other = original  // Reassignment - now clones

    // Modify through other
    other.items.set(0, 999)?

    mut orig_val := 0
    original.items.get(0, orig_val)?

    // Original should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 3: Named struct args (Foo(bar: x)) - TODO (ccodegen)
test_named_struct_arg := proc() {
    mut c := Container()
    c.items.push(10)
    c.items.push(20)

    // Named struct arg - should clone c, not shallow copy
    mut h := Holder(data=c)

    // Modify through h
    h.data.items.set(0, 999)?

    mut orig_val := 0
    c.items.get(0, orig_val)?

    // c should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 4: copy param passing - TODO (ccodegen)
// Copy params should create a deep copy. We test by comparing the raw pointer
// values - if shallow copy, the Vec's internal ptr matches original; if deep
// copy, they're different. This avoids relying on declaration cloning.
get_items_ptr := func(copy c: Container) returns I64 {
    // Return the raw pointer value of c's Vec internal buffer
    return c.items.ptr.data
}

test_copy_param := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)

    // Get the copy param's Vec ptr
    copy_ptr := get_items_ptr(original)
    original_ptr := original.items.ptr.data

    // With shallow copy: copy_ptr == original_ptr (FAIL - shared memory)
    // With deep copy: copy_ptr != original_ptr (PASS - independent memory)
    test(loc(), not(original_ptr.eq(copy_ptr)), "copy param should have independent Vec ptr")
}

// Test 5: Field assignment (obj.field = x) - FIXED
test_field_assignment := proc() {
    mut c := Container()
    c.items.push(10)
    c.items.push(20)

    mut h := Holder()
    h.data = c  // Field assignment - now clones

    // Modify through h
    h.data.items.set(0, 999)?

    mut orig_val := 0
    c.items.get(0, orig_val)?

    // c should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

test_declaration()
test_reassignment()
test_named_struct_arg()
test_copy_param()
test_field_assignment()
