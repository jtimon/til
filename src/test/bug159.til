// Bug #159: Test deep copy semantics in struct cloning
// All struct operations should produce independent copies, not shared memory.
//
// FIXED: Declarations (mut x := y) - calls Type.clone()
// FIXED: Reassignments (x = y) - now uses clone (interpreter + ccodegen)
// FIXED: Field assignments (obj.field = x) - now uses clone (interpreter + ccodegen)
// FIXED: Named struct args (Foo(bar: x)) - calls Type.clone() on identifier args
// FIXED: copy param passing - calls Type.clone() for deep copy

mode test

Container := struct {
    mut items: Vec = Vec.new(I64)
}

Holder := struct {
    mut data: Container = Container()
}

// Test 1: Declaration (mut x := y) - FIXED
test_declaration := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)
    original.items.push(30)

    mut cloned := original

    // Modify existing element in clone (no reallocation)
    cloned.items.set(0, 999)?

    // Read values
    mut orig_val := 0
    original.items.get(0, orig_val)?
    mut clone_val := 0
    cloned.items.get(0, clone_val)?

    // FIXED: With clone(), they have independent memory
    assert_eq(loc(), 10, orig_val)
    assert_eq(loc(), 999, clone_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 2: Reassignment (x = y) - FIXED
test_reassignment := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)

    mut other := Container()
    other.items.push(100)

    other = original  // Reassignment - now clones

    // Modify through other
    other.items.set(0, 999)?

    mut orig_val := 0
    original.items.get(0, orig_val)?

    // Original should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 3: Named struct args (Foo(bar: x)) - TODO (ccodegen)
test_named_struct_arg := proc() {
    mut c := Container()
    c.items.push(10)
    c.items.push(20)

    // Named struct arg - should clone c, not shallow copy
    mut h := Holder(data=c)

    // Modify through h
    h.data.items.set(0, 999)?

    mut orig_val := 0
    c.items.get(0, orig_val)?

    // c should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 4: copy param passing - FIXED
// Copy params create a deep copy. Since copy params are const, we test by
// declaring a local from the copy param and mutating that. If copy param
// cloning is broken (shallow), the local would share memory with original.
copy_param_helper := proc(copy c: Container) {
    // Declare from copy param - this creates another clone
    mut local := c
    // Mutate the local
    local.items.set(0, 999)?

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

test_copy_param := proc() {
    mut original := Container()
    original.items.push(10)
    original.items.push(20)

    // Pass to copy param - should deep clone
    copy_param_helper(original)

    // Original should still be 10 (copy was independent)
    mut orig_val := 0
    original.items.get(0, orig_val)?
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

// Test 5: Field assignment (obj.field = x) - FIXED
test_field_assignment := proc() {
    mut c := Container()
    c.items.push(10)
    c.items.push(20)

    mut h := Holder()
    h.data = c  // Field assignment - now clones

    // Modify through h
    h.data.items.set(0, 999)?

    mut orig_val := 0
    c.items.get(0, orig_val)?

    // c should still be 10 (independent copy)
    assert_eq(loc(), 10, orig_val)

    catch (err: IndexOutOfBoundsError) {
        panic("IndexOutOfBoundsError:", err.msg)
    }
}

test_declaration()
test_reassignment()
test_named_struct_arg()
test_copy_param()
test_field_assignment()
