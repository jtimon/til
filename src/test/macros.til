// macro.til - Test macros (compile-time evaluation)
// Issue #88: Macros are evaluated at compile-time, not runtime

mode test

// Compile-time factorial - computed once at compile-time, not at runtime
// This is the "real world" use case: expensive computation done at compile-time
factorial : macro(n: I64) returns I64 = {
    if n.lteq(1) {
        return 1
    }
    // Note: recursive macro calls work because each call is evaluated at compile-time
    return n.mul(factorial(n.sub(1)))
}

// Compile-time fibonacci - another example of expensive computation
fib : macro(n: I64) returns I64 = {
    if n.lteq(1) {
        return n
    }
    return fib(n.sub(1)).add(fib(n.sub(2)))
}

// Basic macro returning I64
double : macro(x: I64) returns I64 = {
    return x.mul(2)
}

// Macro that calls another macro
quadruple : macro(x: I64) returns I64 = {
    return double(double(x))
}

// Macro with multiple args
add3 : macro(a: I64, b: I64, c: I64) returns I64 = {
    return a.add(b).add(c)
}

// Test that macros work with compile-time known values
test_basic_macro : proc() = {
    result1 := double(5)
    assert_eq(loc(), 10, result1)

    result2 := double(0)
    assert_eq(loc(), 0, result2)

    result3 := double(100)
    assert_eq(loc(), 200, result3)
}

test_nested_macro : proc() = {
    // quadruple(3) = double(double(3)) = double(6) = 12
    result := quadruple(3)
    assert_eq(loc(), 12, result)
}

test_multi_arg_macro : proc() = {
    result := add3(1, 2, 3)
    assert_eq(loc(), 6, result)

    result2 := add3(10, 20, 30)
    assert_eq(loc(), 60, result2)
}

// Test macro used in expressions
test_macro_in_expression : proc() = {
    x := double(5).add(double(3))
    assert_eq(loc(), 16, x)  // 10 + 6

    y := quadruple(2).mul(2)
    assert_eq(loc(), 16, y)  // 8 * 2
}

// Test macro inside a function body (not just at global scope)
test_macro_inside_function : proc() = {
    inner_test : func() returns I64 = {
        return double(7)
    }
    result := inner_test()
    assert_eq(loc(), 14, result)
}

// Test compile-time factorial
test_factorial : proc() = {
    // These are all computed at compile-time, not runtime
    assert_eq(loc(), 1, factorial(0))
    assert_eq(loc(), 1, factorial(1))
    assert_eq(loc(), 2, factorial(2))
    assert_eq(loc(), 6, factorial(3))
    assert_eq(loc(), 24, factorial(4))
    assert_eq(loc(), 120, factorial(5))
    assert_eq(loc(), 3628800, factorial(10))
}

// Test compile-time fibonacci
test_fibonacci : proc() = {
    assert_eq(loc(), 0, fib(0))
    assert_eq(loc(), 1, fib(1))
    assert_eq(loc(), 1, fib(2))
    assert_eq(loc(), 2, fib(3))
    assert_eq(loc(), 5, fib(5))
    assert_eq(loc(), 55, fib(10))
}

// Issue #105: Parameterized struct template via macro
make_vec3 : macro(T: Type) returns struct = {
    return struct {
        mut x: T = T()
        mut y: T = T()
        mut z: T = T()
    }
}

I64Vec3 := make_vec3(I64)
U8Vec3 := make_vec3(U8)

test_i64_vec3 : proc() = {
    v := I64Vec3(x=1, y=2, z=3)
    assert_eq(loc(), 1, v.x)
    assert_eq(loc(), 2, v.y)
    assert_eq(loc(), 3, v.z)

    v2 := I64Vec3()
    assert_eq(loc(), 0, v2.x)
    assert_eq(loc(), 0, v2.y)
    assert_eq(loc(), 0, v2.z)
}

test_u8_vec3 : proc() = {
    v := U8Vec3(x=10, y=20, z=30)
    assert_eq(loc(), 10, U8.to_i64(v.x))
    assert_eq(loc(), 20, U8.to_i64(v.y))
    assert_eq(loc(), 30, U8.to_i64(v.z))

    v2 := U8Vec3()
    assert_eq(loc(), 0, U8.to_i64(v2.x))
    assert_eq(loc(), 0, U8.to_i64(v2.y))
    assert_eq(loc(), 0, U8.to_i64(v2.z))
}

// Issue #105: Macro with namespace - typed_ptr template
import("std.typed_ptr")

I64Ptr := make_typed_ptr(I64)

test_typed_ptr_basic : proc() = {
    mut p := I64Ptr.new()
    test(loc(), p.is_null().not(), "typed_ptr new allocates")

    p.set(42)
    mut result := 0
    p.get(result)
    assert_eq(loc(), 42, result)

    p.set(999)
    p.get(result)
    assert_eq(loc(), 999, result)

    p.delete()
    test(loc(), p.is_null(), "typed_ptr deleted")
}

test_typed_ptr_array : proc() = {
    mut p := I64Ptr.new_array(3)
    test(loc(), p.is_null().not(), "typed_ptr array allocates")
    p.delete()
}

// Issue #105: Macro struct with NULL constant default
make_nullable : macro(T: Type) returns struct = {
    return struct {
        mut data: I64 = NULL
        mut size: I64 = 0
    }
}

NullableI64 := make_nullable(I64)

test_null_default : proc() = {
    x := NullableI64()
    assert_eq(loc(), 0, x.data)
    assert_eq(loc(), 0, x.size)
}

// Issue #105: Macro struct with immutable (constant) field
make_tagged : macro(T: Type) returns struct = {
    return struct {
        tag: Str = "default_tag"
        mut data: I64 = 0
    }
}

TaggedI64 := make_tagged(I64)

test_immutable_field : proc() = {
    t := TaggedI64()
    assert_eq(loc(), 0, t.data)
    assert_eq_str(loc(), "default_tag", TaggedI64.tag)
}

test_basic_macro()
test_nested_macro()
test_multi_arg_macro()
test_macro_in_expression()
test_macro_inside_function()
test_factorial()
test_fibonacci()
test_i64_vec3()
test_u8_vec3()
test_typed_ptr_basic()
test_typed_ptr_array()
test_null_default()
test_immutable_field()

// Issue #106: Macro with namespace - typed_option template (enum)
import("std.typed_option")

I64Option := make_option(I64)

test_option_none : proc() = {
    opt := I64Option.None
    test(loc(), opt.is_none(), "None is_none")
    test(loc(), opt.is_some().not(), "None not is_some")
}

test_option_some : proc() = {
    opt := I64Option.Some(42)
    test(loc(), opt.is_some(), "Some is_some")
    test(loc(), opt.is_none().not(), "Some not is_none")
}

test_option_none()
test_option_some()

// Issue #105: struct_def_of - inspect struct definitions at compile time
import("std.meta")

Point105 := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

// Macro that counts mutable fields (user-declared data fields)
count_fields : macro(T: Type) returns I64 = {
    def := struct_def_of(type_as_str(T))
    mut count := 0
    for i in 0..def.members.len() {
        m := cast(Declaration, def.members.get(i)?)
        if m.is_mut {
            count = count.add(1)
        }
    }
    return count
}
assert_eq(loc(), 2, count_fields(Point105))

// Macro that gets first field name
first_field_name : macro(T: Type) returns Str = {
    def := struct_def_of(type_as_str(T))
    m := cast(Declaration, def.members.get(0)?)
    return m.name
}
assert_eq_str(loc(), "x", first_field_name(Point105))

// Issue #106: enum_def_of - inspect enum definitions at compile time

Color106 := enum { Red, Green, Blue }
TaggedVal106 := enum { None, Some: I64 }

// Count variants
count_variants : macro(T: Type) returns I64 = {
    def := enum_def_of(type_as_str(T))
    return def.variants.len()
}
assert_eq(loc(), 3, count_variants(Color106))
assert_eq(loc(), 2, count_variants(TaggedVal106))

// Get first variant name
first_variant_name : macro(T: Type) returns Str = {
    def := enum_def_of(type_as_str(T))
    v := cast(EnumVariant, def.variants.get(0)?)
    return v.name
}
assert_eq_str(loc(), "Red", first_variant_name(Color106))
assert_eq_str(loc(), "None", first_variant_name(TaggedVal106))
