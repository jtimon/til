// macro.til - Test macros (compile-time evaluation)
// Issue #88: Macros are evaluated at compile-time, not runtime

mode test

// Compile-time factorial - computed once at compile-time, not at runtime
// This is the "real world" use case: expensive computation done at compile-time
factorial := macro(n: I64) returns I64 {
    if n.lteq(1) {
        return 1
    }
    // Note: recursive macro calls work because each call is evaluated at compile-time
    return n.mul(factorial(n.sub(1)))
}

// Compile-time fibonacci - another example of expensive computation
fib := macro(n: I64) returns I64 {
    if n.lteq(1) {
        return n
    }
    return fib(n.sub(1)).add(fib(n.sub(2)))
}

// Basic macro returning I64
double := macro(x: I64) returns I64 {
    return x.mul(2)
}

// Macro that calls another macro
quadruple := macro(x: I64) returns I64 {
    return double(double(x))
}

// Macro with multiple args
add3 := macro(a: I64, b: I64, c: I64) returns I64 {
    return a.add(b).add(c)
}

// Test that macros work with compile-time known values
test_basic_macro := proc() {
    result1 := double(5)
    assert_eq(loc(), 10, result1)

    result2 := double(0)
    assert_eq(loc(), 0, result2)

    result3 := double(100)
    assert_eq(loc(), 200, result3)
}

test_nested_macro := proc() {
    // quadruple(3) = double(double(3)) = double(6) = 12
    result := quadruple(3)
    assert_eq(loc(), 12, result)
}

test_multi_arg_macro := proc() {
    result := add3(1, 2, 3)
    assert_eq(loc(), 6, result)

    result2 := add3(10, 20, 30)
    assert_eq(loc(), 60, result2)
}

// Test macro used in expressions
test_macro_in_expression := proc() {
    x := double(5).add(double(3))
    assert_eq(loc(), 16, x)  // 10 + 6

    y := quadruple(2).mul(2)
    assert_eq(loc(), 16, y)  // 8 * 2
}

// Test macro inside a function body (not just at global scope)
test_macro_inside_function := proc() {
    inner_test := func() returns I64 {
        return double(7)
    }
    result := inner_test()
    assert_eq(loc(), 14, result)
}

// Test compile-time factorial
test_factorial := proc() {
    // These are all computed at compile-time, not runtime
    assert_eq(loc(), 1, factorial(0))
    assert_eq(loc(), 1, factorial(1))
    assert_eq(loc(), 2, factorial(2))
    assert_eq(loc(), 6, factorial(3))
    assert_eq(loc(), 24, factorial(4))
    assert_eq(loc(), 120, factorial(5))
    assert_eq(loc(), 3628800, factorial(10))
}

// Test compile-time fibonacci
test_fibonacci := proc() {
    assert_eq(loc(), 0, fib(0))
    assert_eq(loc(), 1, fib(1))
    assert_eq(loc(), 1, fib(2))
    assert_eq(loc(), 2, fib(3))
    assert_eq(loc(), 5, fib(5))
    assert_eq(loc(), 55, fib(10))
}

// Issue #105: Parameterized struct template via macro
make_vec3 := macro(T: Type) returns struct {
    return struct {
        mut x: T = T()
        mut y: T = T()
        mut z: T = T()
    }
}

I64Vec3 := make_vec3(I64)
U8Vec3 := make_vec3(U8)

test_i64_vec3 := proc() {
    v := I64Vec3(x=1, y=2, z=3)
    assert_eq(loc(), 1, v.x)
    assert_eq(loc(), 2, v.y)
    assert_eq(loc(), 3, v.z)

    v2 := I64Vec3()
    assert_eq(loc(), 0, v2.x)
    assert_eq(loc(), 0, v2.y)
    assert_eq(loc(), 0, v2.z)
}

test_u8_vec3 := proc() {
    v := U8Vec3(x=10, y=20, z=30)
    assert_eq(loc(), 10, U8.to_i64(v.x))
    assert_eq(loc(), 20, U8.to_i64(v.y))
    assert_eq(loc(), 30, U8.to_i64(v.z))

    v2 := U8Vec3()
    assert_eq(loc(), 0, U8.to_i64(v2.x))
    assert_eq(loc(), 0, U8.to_i64(v2.y))
    assert_eq(loc(), 0, U8.to_i64(v2.z))
}

// Issue #105: Macro with namespace - typed_ptr template
import("std.typed_ptr")

I64Ptr := make_typed_ptr(I64)

test_typed_ptr_basic := proc() {
    mut p := I64Ptr.new()
    test(loc(), p.is_null().not(), "typed_ptr new allocates")

    p.set(42)
    mut result := 0
    p.get(result)
    assert_eq(loc(), 42, result)

    p.set(999)
    p.get(result)
    assert_eq(loc(), 999, result)

    p.delete()
    test(loc(), p.is_null(), "typed_ptr deleted")
}

test_typed_ptr_array := proc() {
    mut p := I64Ptr.new_array(3)
    test(loc(), p.is_null().not(), "typed_ptr array allocates")
    p.delete()
}

test_basic_macro()
test_nested_macro()
test_multi_arg_macro()
test_macro_in_expression()
test_macro_inside_function()
test_factorial()
test_fibonacci()
test_i64_vec3()
test_u8_vec3()
test_typed_ptr_basic()
test_typed_ptr_array()

// Issue #106: Macro with namespace - typed_option template (enum)
import("std.typed_option")

I64Option := make_option(I64)

test_option_none := proc() {
    opt := I64Option.None
    test(loc(), opt.is_none(), "None is_none")
    test(loc(), opt.is_some().not(), "None not is_some")
}

test_option_some := proc() {
    opt := I64Option.Some(42)
    test(loc(), opt.is_some(), "Some is_some")
    test(loc(), opt.is_none().not(), "Some not is_none")
}

test_option_none()
test_option_some()
