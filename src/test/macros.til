// macro.til - Test macros (compile-time evaluation)
// Issue #88: Macros are evaluated at compile-time, not runtime

mode test

// Compile-time factorial - computed once at compile-time, not at runtime
// This is the "real world" use case: expensive computation done at compile-time
factorial := macro(n: I64) returns I64 {
    if n.lteq(1) {
        return 1
    }
    // Note: recursive macro calls work because each call is evaluated at compile-time
    return n.mul(factorial(n.sub(1)))
}

// Compile-time fibonacci - another example of expensive computation
fib := macro(n: I64) returns I64 {
    if n.lteq(1) {
        return n
    }
    return fib(n.sub(1)).add(fib(n.sub(2)))
}

// Basic macro returning I64
double := macro(x: I64) returns I64 {
    return x.mul(2)
}

// Macro that calls another macro
quadruple := macro(x: I64) returns I64 {
    return double(double(x))
}

// Macro with multiple args
add3 := macro(a: I64, b: I64, c: I64) returns I64 {
    return a.add(b).add(c)
}

// Test that macros work with compile-time known values
test_basic_macro := proc() {
    result1 := double(5)
    assert_eq(loc(), 10, result1)

    result2 := double(0)
    assert_eq(loc(), 0, result2)

    result3 := double(100)
    assert_eq(loc(), 200, result3)
}

test_nested_macro := proc() {
    // quadruple(3) = double(double(3)) = double(6) = 12
    result := quadruple(3)
    assert_eq(loc(), 12, result)
}

test_multi_arg_macro := proc() {
    result := add3(1, 2, 3)
    assert_eq(loc(), 6, result)

    result2 := add3(10, 20, 30)
    assert_eq(loc(), 60, result2)
}

// Test macro used in expressions
test_macro_in_expression := proc() {
    x := double(5).add(double(3))
    assert_eq(loc(), 16, x)  // 10 + 6

    y := quadruple(2).mul(2)
    assert_eq(loc(), 16, y)  // 8 * 2
}

// Test macro inside a function body (not just at global scope)
test_macro_inside_function := proc() {
    inner_test := func() returns I64 {
        return double(7)
    }
    result := inner_test()
    assert_eq(loc(), 14, result)
}

// Test compile-time factorial
test_factorial := proc() {
    // These are all computed at compile-time, not runtime
    assert_eq(loc(), 1, factorial(0))
    assert_eq(loc(), 1, factorial(1))
    assert_eq(loc(), 2, factorial(2))
    assert_eq(loc(), 6, factorial(3))
    assert_eq(loc(), 24, factorial(4))
    assert_eq(loc(), 120, factorial(5))
    assert_eq(loc(), 3628800, factorial(10))
}

// Test compile-time fibonacci
test_fibonacci := proc() {
    assert_eq(loc(), 0, fib(0))
    assert_eq(loc(), 1, fib(1))
    assert_eq(loc(), 1, fib(2))
    assert_eq(loc(), 2, fib(3))
    assert_eq(loc(), 5, fib(5))
    assert_eq(loc(), 55, fib(10))
}

test_basic_macro()
test_nested_macro()
test_multi_arg_macro()
test_macro_in_expression()
test_macro_inside_function()
test_factorial()
test_fibonacci()
