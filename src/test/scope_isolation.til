mode test

// Tests for scope isolation
// These should pass with both context cloning and scope stack approaches

// Test 1: Basic scope isolation - local variables shouldn't leak
test_basic_isolation : proc() = {
    outer_var := 42

    inner_func : func() returns I64 = {
        inner_var := 100
        return inner_var
    }

    result := inner_func()
    test(loc(), result.eq(100), "inner function should return its local variable")
    test(loc(), outer_var.eq(42), "outer variable should be unchanged")
}
test_basic_isolation()

// Test 2: Parameter shadowing - parameters should shadow parent scope variables
test_parameter_shadowing : proc() = {
    x := 10

    shadow_func : func(x: I64) returns I64 = {
        // This 'x' is the parameter, not the outer 'x'
        return add(x, 1)
    }

    result := shadow_func(20)
    test(loc(), result.eq(21), "function should use parameter x=20, not outer x=10")
    test(loc(), x.eq(10), "outer x should still be 10")
}
test_parameter_shadowing()

// Test 3: Nested function calls with same variable names
test_nested_same_names : proc() = {
    compute : func(n: I64) returns I64 = {
        if n.eq(0) {
            return 1
        }
        temp := mul(n, 2)
        return temp
    }

    wrapper : func(n: I64) returns I64 = {
        temp := add(n, 5)  // Different 'temp' than in compute()
        inner_result := compute(temp)
        return add(inner_result, temp)
    }

    result := wrapper(3)
    // wrapper(3): temp=8, compute(8)=16, result=16+8=24
    test(loc(), result.eq(24), "nested calls with same variable names should work")
}
test_nested_same_names()

// Test 4: Simple recursion
test_simple_recursion : proc() = {
    factorial : func(n: I64) returns I64 = {
        if lteq(n, 1) {
            return 1
        }
        return mul(n, factorial(sub(n, 1)))
    }

    result := factorial(5)
    test(loc(), result.eq(120), "factorial(5) should be 120")
}
test_simple_recursion()

// Test 5: Mut parameter DOES modify caller's variable (pass-by-reference)
test_mut_parameter_passbyref : proc() = {
    mut original := 100

    modify_param : proc(mut n: I64) = {
        n = add(n, 50)
        // n is now 150 inside this function
    }

    modify_param(original)
    // original SHOULD be 150 because mut parameters are pass-by-reference
    test(loc(), original.eq(150), "original value should be modified by mut param call")
}
test_mut_parameter_passbyref()

// Test 6: Multiple sequential calls don't interfere
test_sequential_calls : proc() = {
    add_ten : func(x: I64) returns I64 = {
        return add(x, 10)
    }

    r1 := add_ten(5)
    r2 := add_ten(20)
    r3 := add_ten(100)

    test(loc(), r1.eq(15), "first call should work")
    test(loc(), r2.eq(30), "second call should work")
    test(loc(), r3.eq(110), "third call should work")
}
test_sequential_calls()

// Test 7: Bool parameter shadowing (specific test for Bool since it's a struct)
test_bool_parameter_shadowing : proc() = {
    flag := true

    negate_bool : func(flag: Bool) returns Bool = {
        return not(flag)
    }

    result := negate_bool(false)
    test(loc(), Bool.eq(result, true), "should negate false to true")
    test(loc(), Bool.eq(flag, true), "outer flag should still be true")
}
test_bool_parameter_shadowing()

// Test 8: Str parameter shadowing (specific test for Str since it's a struct)
test_str_parameter_shadowing : proc() = {
    msg := "outer"

    get_length : func(msg: Str) returns I64 = {
        return msg.len()
    }

    result := get_length("inner")
    test(loc(), result.eq(5), "should get length of 'inner' (5)")
    test(loc(), Str.eq(msg, "outer"), "outer msg should still be 'outer'")
}
test_str_parameter_shadowing()
