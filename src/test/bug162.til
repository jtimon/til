mode test

// Bug #162: Typer own-param requires mut variable + no control-flow awareness
//
// Two issues:
// 1. own params incorrectly require mut variables (compiled mode rejects const)
// 2. own consumption has no control-flow awareness (consuming in one branch
//    makes the variable undefined in the other branch)

import("core.vec")
import("std.map")

OwnTestStruct := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

consume_struct : proc(own v: OwnTestStruct) returns I64 = {
    return add(v.x, v.y)
}

consume_i64 : proc(own n: I64) returns I64 = {
    return mul(n, 2)
}

// Test 1: own should accept const variables (not just mut)
test_own_const : proc() = {
    original := OwnTestStruct(x=1, y=2)
    result := consume_struct(original)
    assert_eq(loc(), 3, result)
    println("PASS: own accepts const struct")
}

// Test 2: own consumption in if-branch should not affect else-branch
test_own_if_else : proc() = {
    mut x := 42
    mut result := 0
    if true {
        result = consume_i64(x)
    } else {
        // x should still be valid here - it was NOT consumed in this branch
        result = x
    }
    assert_eq(loc(), 84, result)
    println("PASS: own in if-branch does not affect else-branch")
}

// Test 3: own consumption in both branches - variable should be consumed after
test_own_both_branches : proc() = {
    mut x := 10
    mut result := 0
    if true {
        result = consume_i64(x)
    } else {
        result = consume_i64(x)
    }
    // x is consumed in BOTH branches, so it should be invalid here
    // (we don't test this case - just that the code above compiles)
    assert_eq(loc(), 20, result)
    println("PASS: own in both branches works")
}

// Test 4: own consumption after if (not inside) - should work normally
test_own_after_if : proc() = {
    mut x := 5
    if true {
        // don't consume x here
    }
    result := consume_i64(x)  // x should still be valid
    assert_eq(loc(), 10, result)
    println("PASS: own after if works")
}

// Test 5: own with Vec.push (real-world usage from #117)
test_own_vec_push : proc() = {
    mut v := Vec.new(I64)
    x := 42
    v.push(x)  // push takes Dynamic, but once it takes own, const should work
    result := cast(I64, v.get(0)?)
    assert_eq(loc(), 42, result)
    println("PASS: own vec push works")

    catch (err: IndexOutOfBoundsError) {
        println("ERROR: ", err.msg)
        exit(1)
    }
}

// Test 6: UFCS on variable consumed by own param later in function
// Reproduces init.til workaround: name.eq("_") fails when name is consumed
// by TWO set() calls (one with clone, one direct)
test_ufcs_before_own_consumption : proc() = {
    mut m1 := Map.new(Str, I64)
    mut m2 := Map.new(Str, I64)
    name := "hello"

    // UFCS call on name BEFORE it's consumed by set()
    if name.eq("_") {
        // skip
    }

    m1.set(name.clone(), 42)
    m2.set(name, 99)

    val1 := cast(I64, m1.get("hello")?)
    assert_eq(loc(), 42, val1)
    val2 := cast(I64, m2.get("hello")?)
    assert_eq(loc(), 99, val2)
    println("PASS: UFCS before own consumption")

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), err.msg)
        exit(1)
    }
}

// Test 7: Inline .clone() as argument to function taking own param
// Reproduces init.til workaround: name.clone() can't be inlined into set()
test_inline_clone_to_own : proc() = {
    mut m1 := Map.new(Str, I64)
    mut m2 := Map.new(Str, I64)
    name := "world"

    // This should work: clone inline as argument to own param
    m1.set(name.clone(), 100)
    m2.set(name, 200)

    val1 := cast(I64, m1.get("world")?)
    assert_eq(loc(), 100, val1)
    val2 := cast(I64, m2.get("world")?)
    assert_eq(loc(), 200, val2)
    println("PASS: inline clone to own param")

    catch (err: KeyNotFoundError) {
        println("ERROR:", loc(), err.msg)
        exit(1)
    }
}

test_own_const()
test_own_if_else()
test_own_both_branches()
test_own_after_if()
test_own_vec_push()
test_ufcs_before_own_consumption()
test_inline_clone_to_own()

println("All Bug #162 tests passed")
