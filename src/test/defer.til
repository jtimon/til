mode test

// ============================================================
// defer - basic: return value is hoisted before defer runs
// ============================================================

test_basic_defer := func() returns I64 = {
    mut x := 0
    defer x = 99
    return x
}
// x hoisted to temp (0), then defer sets x=99, then temp (0) returned
assert_eq(loc(), 0, test_basic_defer())

// ============================================================
// defer - LIFO order: last defer runs first, first defer runs last
// Return value hoisted before any defer runs
// ============================================================

test_lifo := func() returns I64 = {
    mut x := 0
    defer x = 10
    defer x = 20
    return x
}
// x hoisted (0), then LIFO: x=20 first, x=10 second, return 0
assert_eq(loc(), 0, test_lifo())

// ============================================================
// defer - conditional: defer inside if (branch taken)
// Block-scoped: defer runs at end of if-body
// ============================================================

test_cond_true := func() returns I64 = {
    mut x := 10
    if true {
        defer x = 20
    }
    return x
}
// if-body ends, defer runs x=20, then return hoists x (20), returns 20
assert_eq(loc(), 20, test_cond_true())

// ============================================================
// defer - conditional: defer inside if (branch NOT taken)
// ============================================================

test_cond_false := func() returns I64 = {
    mut x := 10
    if false {
        defer x = 20
    }
    return x
}
// if-body never entered, defer never runs, returns 10
assert_eq(loc(), 10, test_cond_false())

// ============================================================
// defer - early return: only active defers run
// ============================================================

test_early_return := func(n: I64) returns I64 = {
    mut x := 0
    defer x = 100
    if n.eq(0) {
        return x
    }
    defer x = 200
    return x
}
// n=0: x hoisted (0), first defer runs (x=100), return 0
assert_eq(loc(), 0, test_early_return(0))
// n=5: x hoisted (0), both defers LIFO: x=200 then x=100, return 0
assert_eq(loc(), 0, test_early_return(5))

// ============================================================
// defer - inside switch case
// ============================================================

test_defer_in_switch := func(n: I64) returns I64 = {
    mut result := 0
    switch n {
    case 1:
        defer result = 42
    case:
        result = 0
    }
    return result
}
// n=1: switch-case body ends, defer runs result=42, then return hoists 42
assert_eq(loc(), 42, test_defer_in_switch(1))
assert_eq(loc(), 0, test_defer_in_switch(2))

// ============================================================
// defer - with throw: defer runs before throw propagates
// ============================================================

test_throw_inner := proc() throws Str = {
    mut x := 0
    defer x = 99
    throw "error"
}
test_throw := proc() = {
    test_throw_inner()?
    catch (err: Str) {}
}
test_throw()

// ============================================================
// defer - fall-through (no explicit return)
// ============================================================

test_fallthrough := proc() = {
    mut x := 0
    defer x = 42
}
test_fallthrough()

// ============================================================
// defer - Vec.delete() (the primary use case)
// ============================================================

test_defer_delete := func() returns I64 = {
    mut v := Vec.new(I64)
    defer v.delete()
    v.push(own 42)
    v.push(own 100)
    return v.len()
}
assert_eq(loc(), 2, test_defer_delete())

println("All defer tests passed")
