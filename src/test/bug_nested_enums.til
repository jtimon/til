mode test

// BUG #3: Nested enum payloads don't work
// Expected behavior: Enum constructor can be used directly as payload to another enum
// Actual behavior: Must assign inner enum to variable first
//
// Example from parser.til that required workaround:
// node_type = NodeType.Literal(LiteralNodeType.String(s))  // Doesn't work
// mut str_lit := LiteralNodeType.String(s)                 // Workaround
// node_type = NodeType.Literal(str_lit)                    // Now works

InnerEnum := enum {
    ValueA: I64,
    ValueB: Str,
}

OuterEnum := enum {
    WrapperA: InnerEnum,
    WrapperB: I64,
}

// Test 1: Direct nested enum construction (NOW FIXED!)
test_direct_nested_enum := proc() {
    println("Test 1: Testing direct nested enum construction...")

    // This now works! Bug #3 is FIXED
    mut outer := OuterEnum.WrapperA(InnerEnum.ValueA(42))

    // Extract and verify
    switch outer {
    case OuterEnum.WrapperA(inner):
        switch inner {
        case InnerEnum.ValueA(val):
            test(loc(), I64.eq(val, 42), "Should extract 42 from direct nested enum")
            println("PASS: Direct nested enum construction works!")
        case InnerEnum.ValueB(s):
            test(loc(), false, "Wrong inner variant")
        }
    case OuterEnum.WrapperB(i):
        test(loc(), false, "Wrong outer variant")
    }
}

// Test 2: Workaround - assign inner enum to variable first
test_workaround_nested_enum := proc() {
    println("Test 2: Using workaround (variable assignment)...")

    // Workaround: create inner enum first
    mut inner := InnerEnum.ValueB("hello")

    // Then use it as payload
    mut outer := OuterEnum.WrapperA(inner)

    // Extract and verify
    switch outer {
    case OuterEnum.WrapperA(inner_extracted):
        switch inner_extracted {
        case InnerEnum.ValueB(s):
            test(loc(), Str.eq(s, "hello"), "Should extract 'hello' from nested enum")
            println("PASS: Workaround (variable assignment) works")
        case InnerEnum.ValueA(i):
            panic(loc(), "Wrong inner variant")
        }
    case OuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }
}

// Test 3: Triple nesting (extreme case)
Level1 := enum {
    L1: Level2,
}

Level2 := enum {
    L2: Level3,
}

Level3 := enum {
    L3: I64,
}

test_triple_nesting := proc() {
    println("Test 3: Testing triple nesting with workaround...")

    // Can't do direct triple nesting due to bug, use workaround
    mut l3 := Level3.L3(99)
    mut l2 := Level2.L2(l3)
    mut triple := Level1.L1(l2)

    // Extract value
    switch triple {
    case Level1.L1(l2_extracted):
        switch l2_extracted {
        case Level2.L2(l3_extracted):
            switch l3_extracted {
            case Level3.L3(val):
                test(loc(), I64.eq(val, 99), "Should extract 99 from triple nested enum")
                println("PASS: Triple nesting with workaround works!")
            }
        }
    }
}

// Run tests
test_direct_nested_enum()
test_workaround_nested_enum()
test_triple_nesting()

println("")
println("Bug #3 Test Summary:")
println("FIXED! Direct nested enum construction now works!")
println("The workaround is no longer needed")
