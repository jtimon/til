mode test

// BUG #3: Nested enum payloads don't work
// Expected behavior: Enum constructor can be used directly as payload to another enum
// Actual behavior: Must assign inner enum to variable first
//
// Example from parser.til that required workaround:
// node_type = NodeType.Literal(LiteralNodeType.String(s))  // Doesn't work
// mut str_lit := LiteralNodeType.String(s)                 // Workaround
// node_type = NodeType.Literal(str_lit)                    // Now works

InnerEnum := enum {
    ValueA: I64,
    ValueB: Str,
}

OuterEnum := enum {
    WrapperA: InnerEnum,
    WrapperB: I64,
}

// Test 1: Direct nested enum construction (THE BUG)
// TODO FIX: This test demonstrates the bug - commented out because it causes runtime error
test_direct_nested_enum := proc() {
    println("Test 1: Attempting direct nested enum construction...")

    // BUG CONFIRMED: This throws error "Enum payload must be a variable identifier, got FCall"
    // mut outer := OuterEnum.WrapperA(InnerEnum.ValueA(42))

    println("BUG CONFIRMED: Direct nested enum construction fails")
    println("Error: 'Enum payload must be a variable identifier, got FCall'")
    println("Must use workaround (assign to variable first)")
}

// Test 2: Workaround - assign inner enum to variable first
test_workaround_nested_enum := proc() {
    println("Test 2: Using workaround (variable assignment)...")

    // Workaround: create inner enum first
    mut inner := InnerEnum.ValueB("hello")

    // Then use it as payload
    mut outer := OuterEnum.WrapperA(inner)

    // Extract and verify
    switch outer {
    case OuterEnum.WrapperA(inner_extracted):
        switch inner_extracted {
        case InnerEnum.ValueB(s):
            test(loc(), Str.eq(s, "hello"), "Should extract 'hello' from nested enum")
            println("PASS: Workaround (variable assignment) works")
        case InnerEnum.ValueA(i):
            panic(loc(), "Wrong inner variant")
        }
    case OuterEnum.WrapperB(i):
        panic(loc(), "Wrong outer variant")
    }
}

// Test 3: Triple nesting (extreme case)
Level1 := enum {
    L1: Level2,
}

Level2 := enum {
    L2: Level3,
}

Level3 := enum {
    L3: I64,
}

test_triple_nesting := proc() {
    println("Test 3: Testing triple nesting with workaround...")

    // Can't do direct triple nesting due to bug, use workaround
    mut l3 := Level3.L3(99)
    mut l2 := Level2.L2(l3)
    mut triple := Level1.L1(l2)

    // Extract value
    switch triple {
    case Level1.L1(l2_extracted):
        switch l2_extracted {
        case Level2.L2(l3_extracted):
            switch l3_extracted {
            case Level3.L3(val):
                test(loc(), I64.eq(val, 99), "Should extract 99 from triple nested enum")
                println("PASS: Triple nesting with workaround works!")
            }
        }
    }
}

// Run tests
test_direct_nested_enum()
test_workaround_nested_enum()
test_triple_nesting()

println("")
println("Bug #3 Test Summary:")
println("If all tests passed, Bug #3 (nested enum payloads) is NOT present")
println("or has been fixed in current rstil version")
