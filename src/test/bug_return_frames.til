mode test

// BUG #2: Return statements pop multiple stack frames
// Expected behavior: return should exit only the current function
// Actual behavior: return may pop multiple frames and exit the caller
//
// This bug was documented in commit 46a00bc as affecting self-hosted parser
// Workaround: inline logic or make functions standalone instead of methods

// Test 1: Simple return from function (baseline - should work)
test_simple_return := proc() returns I64 {
    return 42
}

test_simple_return_works := proc() {
    mut result := test_simple_return()
    test(loc(), I64.eq(result, 42), "Simple return should work")
    println("PASS: Simple return from function works")
}

// Test 2: Nested function calls with returns
inner_function := proc() returns I64 {
    return 100
}

middle_function := proc() returns I64 {
    mut val := inner_function()
    // BUG: If inner_function's return pops too many frames,
    // this line won't execute
    return add(val, 10)  // Should return 110
}

outer_function := proc() returns I64 {
    mut val := middle_function()
    // BUG: If middle_function's return pops too many frames,
    // this line won't execute
    return add(val, 1)  // Should return 111
}

test_nested_returns := proc() {
    mut result := outer_function()
    test(loc(), I64.eq(result, 111), "Nested returns should work correctly")

    if I64.eq(result, 111) {
        println("PASS: Nested function returns work correctly")
    } else {
        println("BUG DETECTED: Got ", I64.to_str(result), " expected 111")
        println("This suggests return popped multiple stack frames")
    }
}

// Test 3: Method-style return (struct associated function)
Calculator := struct {
    add_ten := func(x: I64) returns I64 {
        return add(x, 10)
    }
}

test_method_return := proc() {
    mut result := Calculator.add_ten(5)
    test(loc(), I64.eq(result, 15), "Method return should work")

    if I64.eq(result, 15) {
        println("PASS: Method returns work correctly")
    } else {
        println("BUG DETECTED: Method return got ", I64.to_str(result), " expected 15")
    }
}

// Test 4: Deep nesting (stress test)
level_4 := proc() returns I64 {
    return 4
}

level_3 := proc() returns I64 {
    mut v := level_4()
    return add(v, 3)  // Should be 7
}

level_2 := proc() returns I64 {
    mut v := level_3()
    return add(v, 2)  // Should be 9
}

level_1 := proc() returns I64 {
    mut v := level_2()
    return add(v, 1)  // Should be 10
}

test_deep_nesting := proc() {
    mut result := level_1()
    test(loc(), I64.eq(result, 10), "Deep nested returns should accumulate correctly")

    if I64.eq(result, 10) {
        println("PASS: Deep nested returns (4 levels) work correctly")
    } else {
        println("BUG DETECTED: Deep nesting got ", I64.to_str(result), " expected 10")
        println("Frames may have been skipped")
    }
}

// Run all tests
test_simple_return_works()
test_nested_returns()
test_method_return()
test_deep_nesting()

println("")
println("Bug #2 Test Summary:")
println("If all tests passed, Bug #2 (return frame popping) is NOT present")
println("or has been fixed in current rstil version")
