mode test

import("src/core/parser")

// Helper to parse TIL source code
parse_source := proc(source: Str) {
    // Lex and parse the source
    mut lexer := Lexer.new_from_src(source)
    ast := parse_tokens(lexer)
    catch (err: Str) {
        exit(1)
    }
    catch (err: AllocError) {
        exit(1)
    }
    catch (err: FullError) {
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        exit(1)
    }
    catch (err: I64_OverflowError) {
        exit(1)
    }
}

// Test parsing simple expressions
test_simple_expressions := proc() {
    parse_source("mode test\ny := 42")
    parse_source("mode test\ns := \"hello\"")
    parse_source("mode test\nb := true")
    parse_source("mode test\nz := x")
    parse_source("mode test\nresult := 1.add(2)")
    parse_source("mode test\nresult2 := x.add(1).mul(2)")
}

// Test parsing declarations
test_declarations := proc() {
    parse_source("mode test\nx := 42")
    parse_source("mode test\nx: I64 = 42")
    parse_source("mode test\nmut x := 42")
    parse_source("mode test\nmut x: I64 = 42")
}

// Test parsing functions
test_functions := proc() {
    parse_source("mode test\nf := func() returns I64 { return 42 }")
    parse_source("mode test\nf := func(x: I64) returns I64 { return x }")
    parse_source("mode test\nf := func() returns I64 throws Str { return 42 }")
    parse_source("mode test\np := proc() { println(\"hello\") }")
}

// Test parsing control flow
test_control_flow := proc() {
    parse_source("mode test\nif x { y := 1 }")
    parse_source("mode test\nif x { y := 1 } else { y := 2 }")
    parse_source("mode test\nwhile x.lt(10) { x = x.add(1) }")
    parse_source("mode test\nfor i in 0..10 { println(i.to_str()) }")
}

// Test parsing enums
test_enums := proc() {
    parse_source("mode test\nColor := enum { Red, Green, Blue }")
    parse_source("mode test\nOption := enum { Some: I64, None }")
}

// Test parsing structs
test_structs := proc() {
    parse_source("mode test\nPoint := struct { mut x: I64 = 0 mut y: I64 = 0 }")
    parse_source("mode test\nPoint := struct { mut x: I64 = 0 add := func(self: Point, n: I64) returns I64 { return self.x.add(n) } }")
}

// Test parsing switch statements
test_switch := proc() {
    parse_source("mode test\nswitch x { case 1: y := 1 case 2: y := 2 case: y := 0 }")
    parse_source("mode test\nswitch opt { case Option.Some(v): println(v.to_str()) case Option.None: println(\"none\") }")
}

// Test parsing a file
test_parse_file := proc(path: Str) {
    mut lexer := Lexer.new(path)
    ast := parse_tokens(lexer)
    catch (err: Str) {
        exit(1)
    }
    catch (err: AllocError) {
        exit(1)
    }
    catch (err: FullError) {
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        exit(1)
    }
    catch (err: I64_OverflowError) {
        exit(1)
    }
}

// Run all tests
// TODO: Re-enable after fixing runtime parsing issues in parser.til
// test_simple_expressions()
// test_declarations()
// test_functions()
// test_control_flow()
// test_enums()
// test_structs()
// test_switch()

// Test parsing real TIL files
// TODO: Re-enable after fixing runtime parsing issues in parser.til
// test_parse_file("src/core/parser.til")
// test_parse_file("src/core/lexer.til")
// test_parse_file("src/core/core.til")
