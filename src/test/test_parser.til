mode test

import("src.core.self.parser")

// Helper to parse TIL source code
parse_source := proc(source: Str) {
    // Just parse the body - parse_tokens doesn't handle mode declarations
    // (mode is handled separately when loading files via parse_mode)
    mut lexer := Lexer.new_from_src(source)
    ast := parse_tokens(lexer)
    catch (err: Str) {
        println("ERROR:", loc(), "Parse error in parse_source")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "AllocError in parse_source")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "FullError in parse_source")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "IndexOutOfBoundsError in parse_source")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "I64_OverflowError in parse_source")
        println(err.msg)
        exit(1)
    }
}

// Test parsing simple expressions
test_simple_expressions := proc() {
    parse_source("y := 42")
    parse_source("s := \"hello\"")
    parse_source("b := true")
    parse_source("z := x")
    parse_source("result := x.add(y)")
    parse_source("result2 := x.add(y).mul(z)")

}

// Test parsing declarations
test_declarations := proc() {
    parse_source("x := 42")
    parse_source("x: I64 = 42")
    parse_source("mut x := 42")
    parse_source("mut x: I64 = 42")

}

// Test parsing functions
test_functions := proc() {
    parse_source("f := func() returns I64 { return 42 }")
    parse_source("f := func(x: I64) returns I64 { return x }")
    parse_source("f := func() returns I64 throws Str { return 42 }")
    parse_source("p := proc() { println(\"hello\") }")

}

// Test parsing control flow
test_control_flow := proc() {
    parse_source("if x { y := 1 }")
    parse_source("if x { y := 1 } else { y := 2 }")
    parse_source("while x.lt(10) { x = x.add(1) }")
    parse_source("for i in 0..10 { println(i.to_str()) }")

}

// Test parsing enums
test_enums := proc() {
    parse_source("Color := enum { Red, Green, Blue }\n")
    parse_source("Option := enum { Some: I64, None }\n")

}

// Test parsing structs
test_structs := proc() {
    parse_source("Point := struct { mut x: I64 = 0 mut y: I64 = 0 }")
    // TODO: Parser bug - can't handle method bodies in structs yet
    // parse_source("Point := struct { mut x: I64 = 0 add := func(self: Point, n: I64) returns I64 { return self.x.add(n) } }")

}

// Test parsing switch statements
test_switch := proc() {
    println("test_switch: parsing simple switch...")
    parse_source("switch x { case 1: y := 1 case 2: y := 2 case: y := 0 }")
    println("test_switch: parsing switch with pattern matching...")
    parse_source("switch opt { case Option.Some(v): println(v.to_str()) case Option.None: println(\"none\") }")
    println("test_switch: done")

}

// Test parsing a file
test_parse_file := proc(path: Str) {
    mut lexer := Lexer.new(path)
    // Parse mode first (files have mode declarations)
    mode_def := parse_mode(path, lexer)
    // Then parse the body
    ast := parse_tokens(lexer)
    catch (err: Str) {
        exit(1)
    }
    catch (err: AllocError) {
        exit(1)
    }
    catch (err: FullError) {
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        exit(1)
    }
    catch (err: I64_OverflowError) {
        exit(1)
    }
}

// Test simple helper functions
// token_type_eq has been removed - now we use switch statements directly
// test_token_type_eq := proc() {
//     assert(loc(), token_type_eq(TokenType.Identifier, TokenType.Identifier))
//     assert(loc(), not(token_type_eq(TokenType.Identifier, TokenType.String)))
//     assert(loc(), token_type_eq(TokenType.LeftParen, TokenType.LeftParen))
// }

test_str_to_value_type := proc() {
    vt := str_to_value_type("func")
    // Just check it doesn't crash
    vt2 := str_to_value_type("proc")
    vt3 := str_to_value_type("enum")
}

test_is_literal := proc() {
    mut t := Token()
    t.token_type = TokenType.String
    t.token_str = "hello"
    t.line = 1
    t.col = 1
    assert(loc(), is_literal(t))

    mut t2 := Token()
    t2.token_type = TokenType.Identifier
    t2.token_str = "x"
    t2.line = 1
    t2.col = 1
    assert(loc(), not(is_literal(t2)))
}

test_parse_mode := proc() {
    mut lexer := Lexer.new_from_src("mode test")
    mode_def := parse_mode("test.til", lexer)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_literal := proc() {
    mut lexer := Lexer.new_from_src("42")
    mut t := Token()
    t.token_type = TokenType.Number
    t.token_str = "42"
    t.line = 1
    t.col = 1
    expr := parse_literal(lexer, t)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }

}

test_parse_body := proc() {
    mut lexer := Lexer.new_from_src("x := 42")
    body := parse_body(lexer, TokenType.Eof)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_statement := proc() {
    mut lexer := Lexer.new_from_src("x := 42")
    stmt := parse_statement(lexer)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_statement_identifier := proc() {
    mut lexer := Lexer.new_from_src("x := 42")
    stmt := parse_statement_identifier(lexer)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_declaration := proc() {
    mut lexer := Lexer.new_from_src("x := 42")
    decl := parse_declaration(lexer, false, false, INFER_TYPE)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_list := proc() {
    mut lexer := Lexer.new_from_src("(42, 43)")
    list := parse_list(lexer)
    catch (err: Str) {
        println("ERROR:", loc(), "Unexpected Str error")
        println(err)
        exit(1)
    }
    catch (err: AllocError) {
        println("ERROR:", loc(), "Unexpected AllocError")
        println(err.msg)
        exit(1)
    }
    catch (err: FullError) {
        println("ERROR:", loc(), "Unexpected FullError")
        println(err.msg)
        exit(1)
    }
    catch (err: IndexOutOfBoundsError) {
        println("ERROR:", loc(), "Unexpected IndexOutOfBoundsError")
        println(err.msg)
        exit(1)
    }
    catch (err: I64_OverflowError) {
        println("ERROR:", loc(), "Unexpected I64_OverflowError")
        println(err.msg)
        exit(1)
    }

}

test_parse_primary_identifier_fcall := proc() {
    mut lexer := Lexer.new_from_src("foo(42)")
    fcall := parse_primary_identifier(lexer)
    catch (err: Str) {
        println("Error in parse_primary_identifier")
        exit(1)
    }

}

// Run simple tests
// test_token_type_eq()  // Removed - token_type_eq function no longer exists
test_str_to_value_type()
test_is_literal()
test_parse_mode()
test_parse_literal()
test_parse_list()
test_parse_declaration()
test_parse_statement_identifier()
test_parse_primary_identifier_fcall()
test_parse_statement()
test_parse_body()

// Successfully enabled tests
test_simple_expressions()
test_declarations()
test_control_flow()
test_structs()  // Bug #26 FIXED - pass-by-reference now works for field access parameters
test_enums()  // FIXED - enum parsing now advances past closing brace correctly
test_functions()  // LEXER BUG FIXED - lexer.til now correctly handles string literals
test_switch()  // PARSER BUG FIXED - infinite loop fixed by using break flag workaround

// Test parsing real TIL files
// TODO: All hang (likely infinite loop in parser.til) - even small files like arithmetics.til hang
// test_parse_file("src/core/lexer.til")
// test_parse_file("src/core/parser.til")
// test_parse_file("src/core/core.til")
