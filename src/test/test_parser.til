mode test

import("src/core/parser")

// ===== value_type_to_str tests =====

test_value_type_to_str_function := proc() {
    vt := ValueType.TFunction
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Function", result)
}
test_value_type_to_str_function()

test_value_type_to_str_type := proc() {
    vt := ValueType.TType
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Type", result)
}
test_value_type_to_str_type()

test_value_type_to_str_multi := proc() {
    vt := ValueType.TMulti
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Multi", result)
}
test_value_type_to_str_multi()

test_value_type_to_str_custom := proc() {
    vt := ValueType.TCustom("MyStruct")
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "MyStruct", result)
}
test_value_type_to_str_custom()

test_value_type_to_str_i64 := proc() {
    vt := ValueType.TCustom("I64")
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "I64", result)
}
test_value_type_to_str_i64()

// ===== str_to_value_type tests =====

test_str_to_value_type_function := proc() {
    vt := str_to_value_type("Function")
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Function", result)
}
test_str_to_value_type_function()

test_str_to_value_type_type := proc() {
    vt := str_to_value_type("Type")
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Type", result)
}
test_str_to_value_type_type()

test_str_to_value_type_multi := proc() {
    vt := str_to_value_type("Multi")
    result := value_type_to_str(vt)
    assert_eq_str(loc(), "Multi", result)
}
test_str_to_value_type_multi()

// ===== is_literal tests =====

test_is_literal_string := proc() {
    mut t := Token()
    t.token_type = TokenType.String
    t.token_str = "hello"
    assert(loc(), is_literal(t))
}
test_is_literal_string()

test_is_literal_number := proc() {
    mut t := Token()
    t.token_type = TokenType.Number
    t.token_str = "42"
    assert(loc(), is_literal(t))
}
test_is_literal_number()

test_is_literal_true := proc() {
    mut t := Token()
    t.token_type = TokenType.True
    t.token_str = "true"
    assert(loc(), is_literal(t))
}
test_is_literal_true()

test_is_literal_identifier := proc() {
    mut t := Token()
    t.token_type = TokenType.Identifier
    t.token_str = "foo"
    assert(loc(), not(is_literal(t)))
}
test_is_literal_identifier()

test_is_literal_keyword := proc() {
    mut t := Token()
    t.token_type = TokenType.Func
    t.token_str = "func"
    assert(loc(), not(is_literal(t)))
}
test_is_literal_keyword()

// ===== get_combined_name tests =====
// NOTE: These tests are commented out due to a rstil type-checking limitation
// where enum variant construction with payloads (e.g. NodeType.Identifier("foo"))
// causes type errors in test mode, even though the code runs correctly.
// The get_combined_name function has been implemented and tested manually in script mode.

test_get_combined_name_simple := proc() {
    // NOTE: This test triggers the enum_extract_payload recursion bug
    // Create an identifier expression for "foo"
    node_type := NodeType.Identifier("foo")
    params := new_expr_array()
    e := Expr.new_explicit(node_type, params, 1, 1)

    result := get_combined_name(e)
    assert_eq_str(loc(), "foo", result)
    println("test_get_combined_name_simple: PASS")

    catch(err: Str) {
        println(loc(), "test_get_combined_name_simple failed")
        exit(1)
    }
    catch(err: AllocError) {
        println(loc(), "test_get_combined_name_simple: AllocError: ", err.msg)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), "test_get_combined_name_simple: IndexOutOfBoundsError: ", err.msg)
        exit(1)
    }
    catch(err: I64_OverflowError) {
        println(loc(), "test_get_combined_name_simple: I64_OverflowError: ", err.msg)
        exit(1)
    }
}
test_get_combined_name_simple()

// test_get_combined_name_dotted := proc() {
//     // NOTE: This test triggers a rstil bug where local string variables get
//     // corrupted during recursive calls when populated via enum_extract_payload
//     // TODO: Re-enable when the bug is fixed
// //
//     // Create an identifier expression for "Foo.bar"
//     // This is represented as Identifier("Foo") with params containing Identifier("bar")
//
//     // Create inner expression for "bar"
//     inner_node_type := NodeType.Identifier("bar")
//     inner_params := new_expr_array()
//     inner_expr := Expr.new_explicit(inner_node_type, inner_params, 1, 1)
//
//     // Create outer expression for "Foo" with "bar" as param
//     mut outer_params := new_expr_array()
//     outer_params.push(inner_expr)
//     outer_node_type := NodeType.Identifier("Foo")
//     e := Expr.new_explicit(outer_node_type, outer_params, 1, 1)
//
//     result := get_combined_name(e)
//     assert_eq_str(loc(), "Foo.bar", result)
//     println("test_get_combined_name_dotted: PASS")
//
//     catch(err: Str) {
//         println(loc(), "test_get_combined_name_dotted failed: ", err)
//         exit(1)
//     }
//     catch(err: AllocError) {
//         println(loc(), "test_get_combined_name_dotted: AllocError: ", err.msg)
//         exit(1)
//     }
//     catch(err: IndexOutOfBoundsError) {
//         println(loc(), "test_get_combined_name_dotted: IndexOutOfBoundsError: ", err.msg)
//         exit(1)
//     }
//     catch(err: FullError) {
//         println(loc(), "test_get_combined_name_dotted: FullError: ", err.msg)
//         exit(1)
//     }
//     catch(err: I64_OverflowError) {
//         println(loc(), "test_get_combined_name_dotted: I64_OverflowError: ", err.msg)
//         exit(1)
//     }
// }
// test_get_combined_name_dotted()

// ===== Lexer.new_from_src tests =====

test_lexer_new_from_src_basic := proc() {
    mut lexer := Lexer.new_from_src("42")
    tokens_len := lexer.len()
    // Should have the number token and EOF (so exactly 2)
    if I64.eq(tokens_len, 2) {
        println("test_lexer_new_from_src_basic: PASS")
    }
    else {
        println(loc(), " FAIL: Expected 2 tokens, got ", I64.to_str(tokens_len))
        exit(1)
    }

    catch(err: Str) {
        println(loc(), " FAIL: Lexer.new_from_src threw error")
        exit(1)
    }
}
test_lexer_new_from_src_basic()

test_lexer_new_from_src_identifier := proc() {
    mut lexer := Lexer.new_from_src("x")
    tokens_len := lexer.len()
    // Should have identifier token and EOF (so exactly 2)
    if I64.eq(tokens_len, 2) {
        println("test_lexer_new_from_src_identifier: PASS")
    }
    else {
        println(loc(), " FAIL: Expected 2 tokens, got ", I64.to_str(tokens_len))
        exit(1)
    }

    catch(err: Str) {
        println(loc(), " FAIL: Lexer.new_from_src threw error")
        exit(1)
    }
}
test_lexer_new_from_src_identifier()

// ===== parse_primary_identifier tests =====

test_parse_primary_identifier_simple := proc() {
    mut lexer := Lexer.new_from_src("foo")
    result := parse_primary_identifier(lexer)

    // Should be an Identifier node
    switch result.node_type {
    case NodeType.Identifier:
        // Success - this is what we expect
        println("test_parse_primary_identifier_simple: PASS")
    case:
        println(loc(), " FAIL: Expected NodeType.Identifier")
        exit(1)
    }

    catch(err: Str) {
        println(loc(), " test_parse_primary_identifier_simple failed:")
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), " test_parse_primary_identifier_simple: IndexOutOfBoundsError: ", err.msg)
        exit(1)
    }
    catch(err: AllocError) {
        println(loc(), " test_parse_primary_identifier_simple: AllocError: ", err.msg)
        exit(1)
    }
    catch(err: FullError) {
        println(loc(), " test_parse_primary_identifier_simple: FullError: ", err.msg)
        exit(1)
    }
    catch(err: I64_OverflowError) {
        println(loc(), " test_parse_primary_identifier_simple: I64_OverflowError: ", err.msg)
        exit(1)
    }
}
test_parse_primary_identifier_simple()

test_parse_primary_identifier_function_call := proc() {
    // NOTE: This test triggers an IndexOutOfBoundsError in parse_list
    // TODO: Debug and fix
    // Test with empty argument list
    mut lexer := Lexer.new_from_src("foo()")
    result := parse_primary_identifier(lexer)

    // Should be a FCall node
    node_type_str := enum_to_str(result.node_type)
    switch result.node_type {
    case NodeType.FCall:
        // Success - should be a function call
        println("test_parse_primary_identifier_function_call: PASS")
    case:
        println(loc(), " FAIL: Expected NodeType.FCall, got ", node_type_str)
        exit(1)
    }

    catch(err: Str) {
        println(loc(), " test_parse_primary_identifier_function_call failed: ", err)
        exit(1)
    }
    catch(err: IndexOutOfBoundsError) {
        println(loc(), " test_parse_primary_identifier_function_call: IndexOutOfBoundsError")
        exit(1)
    }
    catch(err: AllocError) {
        println(loc(), " test_parse_primary_identifier_function_call: AllocError")
        exit(1)
    }
    catch(err: FullError) {
        println(loc(), " test_parse_primary_identifier_function_call: FullError")
        exit(1)
    }
    catch(err: I64_OverflowError) {
        println(loc(), " test_parse_primary_identifier_function_call: I64_OverflowError")
        exit(1)
    }
}
test_parse_primary_identifier_function_call()

// TODO: Re-enable when parser runtime issues are fixed
// test_parse_primary_identifier_function_call_with_args := proc() {
//     mut lexer := Lexer.new_from_src("add(1, 2, 3)")
//     result := parse_primary_identifier(lexer)
// //
//     // Should be a FCall node with 4 params (identifier + 3 args)
//     switch result.node_type {
//     case NodeType.FCall:
//         result_params := result.params
//         params_len := result_params.len
//         if I64.eq(params_len, 4) {
//             println("test_parse_primary_identifier_function_call_with_args: PASS")
//         }
//         else {
//             println(loc(), " FAIL: Expected 4 params (1 identifier + 3 args), got ", I64.to_str(params_len))
//             exit(1)
//         }
//     case:
//         println(loc(), " FAIL: Expected NodeType.FCall")
//         exit(1)
//     }
// //
//     catch(err: Str) {
//         println(loc(), " test_parse_primary_identifier_function_call_with_args failed:")
//         exit(1)
//     }
//     catch(err: IndexOutOfBoundsError) {
//         println(loc(), " test_parse_primary_identifier_function_call_with_args: IndexOutOfBoundsError: ", err.msg)
//         exit(1)
//     }
//     catch(err: AllocError) {
//         println(loc(), " test_parse_primary_identifier_function_call_with_args: AllocError: ", err.msg)
//         exit(1)
//     }
//     catch(err: FullError) {
//         println(loc(), " test_parse_primary_identifier_function_call_with_args: FullError: ", err.msg)
//         exit(1)
//     }
//     catch(err: I64_OverflowError) {
//         println(loc(), " test_parse_primary_identifier_function_call_with_args: I64_OverflowError: ", err.msg)
//         exit(1)
//     }
// }
// test_parse_primary_identifier_function_call_with_args()

// test_parse_primary_identifier_dotted := proc() {
//     // NOTE: This test triggers an issue with Array when called from test mode
//     // The error occurs inside parse_primary_identifier when calling new_expr_array()
//     // TODO: Consider replacing Array with Array directly throughout parser.til
// //
//     mut lexer := Lexer.new_from_src("Str.eq")
//     result := parse_primary_identifier(lexer)
// 
//     // Should be an Identifier node with 1 param (the dotted part)
//     switch result.node_type {
//     case NodeType.Identifier:
//         params_count := result.params.len
//         if I64.eq(params_count, 1) {
//             println("test_parse_primary_identifier_dotted: PASS")
//         }
//         else {
//             println(loc(), " FAIL: Expected 1 param for dotted identifier, got ", I64.to_str(params_count))
//             exit(1)
//         }
//     case:
//         println(loc(), " FAIL: Expected NodeType.Identifier")
//         exit(1)
//     }
// 
//     catch(err: Str) {
//         println(loc(), " test_parse_primary_identifier_dotted failed: ", err)
//         exit(1)
//     }
//     catch(err: IndexOutOfBoundsError) {
//         println(loc(), " test_parse_primary_identifier_dotted: IndexOutOfBoundsError")
//         exit(1)
//     }
//     catch(err: AllocError) {
//         println(loc(), " test_parse_primary_identifier_dotted: AllocError")
//         exit(1)
//     }
//     catch(err: FullError) {
//         println(loc(), " test_parse_primary_identifier_dotted: FullError")
//         exit(1)
//     }
//     catch(err: I64_OverflowError) {
//         println(loc(), " test_parse_primary_identifier_dotted: I64_OverflowError")
//         exit(1)
//     }
// }
// test_parse_primary_identifier_dotted()

// TODO: Re-enable when parser runtime issues are fixed (Enum TokenType does not have variant eq)
// test_parse_primary_identifier_dotted_call := proc() {
//     mut lexer := Lexer.new_from_src("Str.eq(a, b)")
//     result := parse_primary_identifier(lexer)
// //
//     // Should be a FCall node
//     switch result.node_type {
//     case NodeType.FCall:
//         result_params := result.params
//         params_len := result_params.len
//         if I64.eq(params_len, 3) {
//             println("test_parse_primary_identifier_dotted_call: PASS")
//         }
//         else {
//             println(loc(), " FAIL: Expected 3 params (dotted identifier + 2 args), got ", I64.to_str(params_len))
//             exit(1)
//         }
//     case:
//         println(loc(), " FAIL: Expected NodeType.FCall")
//         exit(1)
//     }
// //
//     catch(err: Str) {
//         println(loc(), " test_parse_primary_identifier_dotted_call failed:")
//         exit(1)
//     }
//     catch(err: IndexOutOfBoundsError) {
//         println(loc(), " test_parse_primary_identifier_dotted_call: IndexOutOfBoundsError: ", err.msg)
//         exit(1)
//     }
//     catch(err: AllocError) {
//         println(loc(), " test_parse_primary_identifier_dotted_call: AllocError: ", err.msg)
//         exit(1)
//     }
//     catch(err: FullError) {
//         println(loc(), " test_parse_primary_identifier_dotted_call: FullError: ", err.msg)
//         exit(1)
//     }
//     catch(err: I64_OverflowError) {
//         println(loc(), " test_parse_primary_identifier_dotted_call: I64_OverflowError: ", err.msg)
//         exit(1)
//     }
// }
// test_parse_primary_identifier_dotted_call()

// TODO: Re-enable when parser runtime issues are fixed
// test_parse_primary_identifier_method_chain := proc() {
//     mut lexer := Lexer.new_from_src("obj.method1().method2()")
//     result := parse_primary_identifier(lexer)
// //
//     // Should be a FCall node (outer call to method2)
//     switch result.node_type {
//     case NodeType.FCall:
//         println("test_parse_primary_identifier_method_chain: PASS")
//     case:
//         println(loc(), " FAIL: Expected NodeType.FCall")
//         exit(1)
//     }
// //
//     catch(err: Str) {
//         println(loc(), " test_parse_primary_identifier_method_chain failed:")
//         exit(1)
//     }
//     catch(err: IndexOutOfBoundsError) {
//         println(loc(), " test_parse_primary_identifier_method_chain: IndexOutOfBoundsError: ", err.msg)
//         exit(1)
//     }
//     catch(err: AllocError) {
//         println(loc(), " test_parse_primary_identifier_method_chain: AllocError: ", err.msg)
//         exit(1)
//     }
//     catch(err: FullError) {
//         println(loc(), " test_parse_primary_identifier_method_chain: FullError: ", err.msg)
//         exit(1)
//     }
//     catch(err: I64_OverflowError) {
//         println(loc(), " test_parse_primary_identifier_method_chain: I64_OverflowError: ", err.msg)
//         exit(1)
//     }
// }
// test_parse_primary_identifier_method_chain()

