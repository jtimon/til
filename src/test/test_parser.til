mode test

import("src/core/parser")

// Helper to parse TIL source code
parse_source := proc(source: Str) {
    // Lex and parse the source
    mut lexer := Lexer.new_from_src(source)
    ast := parse_tokens(lexer)
    catch (err: Str) {
        panic(loc(), format("Parse error: ", err))
    }
    catch (err: AllocError) {
        panic(loc(), format("AllocError: ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("FullError: ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("IndexOutOfBoundsError: ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("I64_OverflowError: ", err.msg))
    }
}

// Test parsing simple expressions
test_simple_expressions := proc() {
    parse_source("42")
    parse_source("\"hello\"")
    parse_source("true")
    parse_source("x")
    parse_source("1.add(2)")
    parse_source("x.add(1).mul(2)")
}

// Test parsing declarations
test_declarations := proc() {
    parse_source("x := 42")
    parse_source("x: I64 = 42")
    parse_source("mut x := 42")
    parse_source("mut x: I64 = 42")
}

// Test parsing functions
test_functions := proc() {
    parse_source("f := func() returns I64 { return 42 }")
    parse_source("f := func(x: I64) returns I64 { return x }")
    parse_source("f := func() returns I64 throws Str { return 42 }")
    parse_source("p := proc() { println(\"hello\") }")
}

// Test parsing control flow
test_control_flow := proc() {
    parse_source("if x { y := 1 }")
    parse_source("if x { y := 1 } else { y := 2 }")
    parse_source("while x.lt(10) { x = x.add(1) }")
    parse_source("for i in 0..10 { println(i.to_str()) }")
}

// Test parsing enums
test_enums := proc() {
    parse_source("Color := enum { Red, Green, Blue }")
    parse_source("Option := enum { Some: I64, None }")
}

// Test parsing structs
test_structs := proc() {
    parse_source("Point := struct { mut x: I64 = 0 mut y: I64 = 0 }")
    parse_source("Point := struct { mut x: I64 = 0 add := func(self: Point, n: I64) returns I64 { return self.x.add(n) } }")
}

// Test parsing switch statements
test_switch := proc() {
    parse_source("switch x { case 1: y := 1 case 2: y := 2 case: y := 0 }")
    parse_source("switch opt { case Option.Some(v): println(v.to_str()) case Option.None: println(\"none\") }")
}

// Test parsing a file
test_parse_file := proc(path: Str) {
    mut lexer := Lexer.new(path)
    ast := parse_tokens(lexer)
    catch (err: Str) {
        panic(loc(), format("Parse file error (", path, "): ", err))
    }
    catch (err: AllocError) {
        panic(loc(), format("AllocError in ", path, ": ", err.msg))
    }
    catch (err: FullError) {
        panic(loc(), format("FullError in ", path, ": ", err.msg))
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), format("IndexOutOfBoundsError in ", path, ": ", err.msg))
    }
    catch (err: I64_OverflowError) {
        panic(loc(), format("I64_OverflowError in ", path, ": ", err.msg))
    }
}

// Run all tests
test_simple_expressions()
test_declarations()
test_functions()
test_control_flow()
test_enums()
test_structs()
test_switch()

// Test parsing real TIL files
test_parse_file("src/core/parser.til")
test_parse_file("src/core/lexer.til")
test_parse_file("src/core/core.til")
