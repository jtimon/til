mode cli

import("src/core/parser")
import("src/core/modes/modes")

CURRENT_VERSION := "til_0.0.1" // REM: No point in advancing versions until it compiles itself
REPL_PATH       := "src/core/modes/repl.til"

// Tracks information about a declared symbol (variable, constant, etc.)
SymbolInfo := struct {
    mut value_type: Str = ""     // Type of the symbol (e.g., "I64", "Str", "Bool")
    mut is_mut: Bool = false     // Whether the symbol is mutable
}

// Global arena for interpreter memory (simplified version)
// In rstil.rs this is a singleton, here we'll pass it around
Arena := struct {
    mut memory: Array = Array()       // Byte array for storage
    mut next_offset: I64 = 1          // Next available offset (0 is reserved/NULL)

    // Create new arena
    new := proc() returns Arena throws AllocError {
        mut a := Arena()
        a.memory = Array.new_dyn("U8", size_of(U8))
        a.next_offset = 1  // Reserve 0 as invalid/NULL
        return a
    }
}

// Context for type checking and evaluation
// Mimics Context struct in rstil.rs (Phase 1: simplified version)
Context := struct {
    mut mode_def: ModeDef = ModeDef()          // Mode definition
    mut path: Str = ""                         // File path for error reporting
    mut symbols: StrMap = StrMap()             // symbol_name -> SymbolInfo (as JSON for now)
    mut funcs: StrMap = StrMap()               // func_name -> SFuncDef (as JSON for now)
    mut arena_index: StrMap = StrMap()         // var_name -> arena_offset (as str)
    mut arena: Arena = Arena()                 // Memory storage

    // Create new context
    new := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
        mut ctx := Context()
        ctx.mode_def = mode_def
        ctx.path = path
        ctx.symbols = StrMap.new()
        ctx.funcs = StrMap.new()
        ctx.arena_index = StrMap.new()
        ctx.arena = Arena.new()
        return ctx
    }

    // Get I64 value from arena by variable name
    get_i64 := func(self: Context, var_name: Str) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: I64 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read 8 bytes from arena memory at offset
        // For now, simplified: convert back from string representation
        // TODO: Implement proper byte-level storage when needed
        mut value_bytes := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_bytes)

        // Parse back to I64
        mut value_str := value_bytes
        return value_str.to_i64()
    }

    // Insert I64 value into arena
    insert_i64 := proc(mut self: Context, var_name: Str, value: I64) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // For Phase 1: simplified storage - store as string representation
        // Later: store as actual bytes like rstil.rs does

        // Check if variable already exists (update vs insert)
        mut offset_str := self.arena_index.get(var_name)
        mut value_str := value.to_str()

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory (as string for now)
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read string from arena memory at offset
        mut value := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value)
        return value
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read bool from arena memory (stored as "true"/"false" string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Convert string to bool
        return value_str.eq("true")
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert bool to string
        mut value_str := "false"
        if value {
            value_str = "true"
        }

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }
}

// Evaluate an expression - Phase 2: minimal version
// Mimics eval_expr in rstil.rs
eval_expr := proc(mut context: Context, e: Expr) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError, AllocError, FullError {
    // Get node type as string for matching
    node_type_str := enum_to_str(e.node_type)

    // Handle literals
    if node_type_str.eq("NodeType.Literal") {
        return eval_literal(context, e)
    }

    // Handle identifiers (variable lookup)
    if node_type_str.eq("NodeType.Identifier") {
        return eval_identifier(context, e)
    }

    // Handle declarations
    if node_type_str.eq("NodeType.Declaration") {
        return eval_declaration(context, e)
    }

    // Handle assignments
    if node_type_str.eq("NodeType.Assignment") {
        return eval_assignment(context, e)
    }

    // Handle function calls
    if node_type_str.eq("NodeType.FCall") {
        return eval_fcall(context, e)
    }

    // Handle body (sequence of statements)
    if node_type_str.eq("NodeType.Body") {
        return eval_body(context, e)
    }

    // Not implemented yet
    throw format(loc(), " ERROR: eval_expr not implemented for node type: ", node_type_str)
}

// Evaluate a literal expression
eval_literal := proc(context: Context, e: Expr) returns Str throws Str {
    // Extract the literal type and value
    mut literal_type := e.node_type
    literal_str := enum_to_str(literal_type)

    if literal_str.eq("NodeType.Literal") {
        // Extract payload to get LiteralNodeType
        mut lit_node_type: LiteralNodeType = LiteralNodeType.String("")
        enum_extract_payload(literal_type, lit_node_type)

        lit_type_str := enum_to_str(lit_node_type)

        if lit_type_str.eq("LiteralNodeType.String") {
            mut str_val := ""
            enum_extract_payload(lit_node_type, str_val)
            return str_val
        }

        if lit_type_str.eq("LiteralNodeType.I64") {
            mut i64_val := 0
            enum_extract_payload(lit_node_type, i64_val)
            mut i64_copy := i64_val
            return i64_copy.to_str()
        }

        if lit_type_str.eq("LiteralNodeType.Bool") {
            mut bool_val := false
            enum_extract_payload(lit_node_type, bool_val)
            if bool_val {
                return "true"
            }
            return "false"
        }

        if lit_type_str.eq("LiteralNodeType.List") {
            // Lists not implemented yet
            throw format(loc(), " ERROR: List literals not yet implemented")
        }
    }

    throw format(loc(), " ERROR: Unknown literal type: ", literal_str)
}

// Evaluate an identifier (variable lookup)
eval_identifier := proc(context: Context, e: Expr) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
    // Get identifier name from node_type payload
    mut node_type := e.node_type
    mut var_name := ""
    enum_extract_payload(node_type, var_name)

    // Look up in symbol table to get type
    mut symbols_map := context.symbols
    mut symbol_info_str := symbols_map.get(var_name)
    if symbol_info_str.eq("") {
        throw format(loc(), " ERROR: Variable '", var_name, "' not found")
    }

    // For now, try each type - later we'll parse SymbolInfo properly
    // For Phase 2, we'll just try I64, Str, Bool in order until one works

    // Try I64 first
    mut i64_result := context.get_i64(var_name)
    mut str_result := ""
    mut bool_result := false
    mut which_type := "i64"

    catch (err: Str) {
        // Not I64, try Str
        which_type = "str"
        str_result = context.get_str(var_name)
        catch (err2: Str) {
            // Not Str, try Bool
            which_type = "bool"
            bool_result = context.get_bool(var_name)
            catch (err3: Str) {
                throw format(loc(), " ERROR: Could not retrieve variable '", var_name, "' as any known type")
            }
        }
    }

    // Return based on which type succeeded
    mut wt_copy := which_type
    if wt_copy.eq("i64") {
        mut val_copy := i64_result
        return val_copy.to_str()
    }

    if wt_copy.eq("str") {
        return str_result
    }

    // Must be bool
    if bool_result {
        return "true"
    }
    return "false"
}

// Evaluate a declaration - Phase 2: simple types only
// Handles I64, Str, Bool declarations with initializers
eval_declaration := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Extract Declaration from node_type
    mut node_type := e.node_type
    mut decl := Declaration()
    enum_extract_payload(node_type, decl)

    // Get the initializer expression (params[0])
    mut params_array := e.params
    if lt(params_array.len(), 1) {
        throw format(loc(), " ERROR: Declaration of '", decl.name, "' has no initializer expression")
    }

    mut init_expr := Expr()
    params_array.get(0, init_expr)

    // Evaluate the initializer
    init_value := eval_expr(context, init_expr)

    // Store in symbol table (simplified: just store type as string)
    mut symbols_map := context.symbols
    symbols_map.insert(decl.name, decl.value_type)

    // Store the actual value based on type
    mut value_type := decl.value_type
    if value_type.eq("I64") {
        mut init_val_str := init_value
        init_i64 := init_val_str.to_i64()
        context.insert_i64(decl.name, init_i64)
    }
    else if value_type.eq("Str") {
        context.insert_str(decl.name, init_value)
    }
    else if value_type.eq("Bool") {
        // Parse "true" or "false" string to boolean
        mut init_val_str := init_value
        is_true := init_val_str.eq("true")
        context.insert_bool(decl.name, is_true)
    }
    else {
        throw format(loc(), " ERROR: Declaration of '", decl.name, "' has unsupported type '", value_type, "' (Phase 2 only supports I64, Str, Bool)")
    }

    return ""
}

// Evaluate an assignment
// Phase 2: simple types only, no mutability checking yet
eval_assignment := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Extract variable name from node_type
    mut node_type := e.node_type
    mut var_name := ""
    enum_extract_payload(node_type, var_name)

    // Look up symbol to verify it exists and get its type
    mut symbols_map := context.symbols
    mut value_type_str := symbols_map.get(var_name)
    if value_type_str.eq("") {
        throw format(loc(), " ERROR: Variable '", var_name, "' not found in assignment")
    }

    // Get the value expression (params[0])
    mut params_array := e.params
    if lt(params_array.len(), 1) {
        throw format(loc(), " ERROR: Assignment to '", var_name, "' has no value expression")
    }

    mut value_expr := Expr()
    params_array.get(0, value_expr)

    // Evaluate the value expression
    new_value := eval_expr(context, value_expr)

    // Update the value based on type
    mut vt_copy := value_type_str
    if vt_copy.eq("I64") {
        mut new_val_str := new_value
        new_i64 := new_val_str.to_i64()
        context.insert_i64(var_name, new_i64)
    }
    else if vt_copy.eq("Str") {
        context.insert_str(var_name, new_value)
    }
    else if vt_copy.eq("Bool") {
        mut new_val_str := new_value
        is_true := new_val_str.eq("true")
        context.insert_bool(var_name, is_true)
    }
    else {
        throw format(loc(), " ERROR: Assignment to '", var_name, "' has unsupported type '", value_type_str, "' (Phase 2 only supports I64, Str, Bool)")
    }

    return ""
}

// Evaluate a function call
// Phase 2: basic arithmetic and core functions only
eval_fcall := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Get function name from params[0]
    mut params_array := e.params
    if lt(params_array.len(), 1) {
        throw format(loc(), " ERROR: Function call has no function name")
    }

    mut func_name_expr := Expr()
    params_array.get(0, func_name_expr)

    mut func_node_type := func_name_expr.node_type
    mut func_name := ""
    enum_extract_payload(func_node_type, func_name)

    // For Phase 2, handle core arithmetic functions
    // TODO: Full function dispatch with user-defined functions

    // Binary arithmetic operations
    if func_name.eq("add") {
        return eval_binary_i64_op(context, params_array, "add")
    }
    if func_name.eq("sub") {
        return eval_binary_i64_op(context, params_array, "sub")
    }
    if func_name.eq("mul") {
        return eval_binary_i64_op(context, params_array, "mul")
    }
    if func_name.eq("div") {
        return eval_binary_i64_op(context, params_array, "div")
    }
    if func_name.eq("mod") {
        return eval_binary_i64_op(context, params_array, "mod")
    }

    // Comparison operations
    if func_name.eq("lt") {
        return eval_comparison_op(context, params_array, "lt")
    }
    if func_name.eq("gt") {
        return eval_comparison_op(context, params_array, "gt")
    }
    if func_name.eq("eq") {
        return eval_comparison_op(context, params_array, "eq")
    }

    throw format(loc(), " ERROR: Function '", func_name, "' not implemented (Phase 2 only supports add, sub, mul, div, mod, lt, gt, eq)")
}

// Helper: evaluate binary I64 operations
eval_binary_i64_op := proc(mut context: Context, params: ExprArray, op: Str) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    if lt(params.len(), 3) {
        throw format(loc(), " ERROR: ", op, " requires 2 arguments")
    }

    // Get arg1 and arg2 (params[1] and params[2])
    mut arg1_expr := Expr()
    mut arg2_expr := Expr()
    params.get(1, arg1_expr)
    params.get(2, arg2_expr)

    // Evaluate arguments
    arg1_str := eval_expr(context, arg1_expr)
    arg2_str := eval_expr(context, arg2_expr)

    // Convert to I64
    mut a1_copy := arg1_str
    mut a2_copy := arg2_str
    a1 := a1_copy.to_i64()
    a2 := a2_copy.to_i64()

    // Perform operation
    mut result := 0
    mut op_copy := op
    if op_copy.eq("add") {
        result = add(a1, a2)
    }
    else if op_copy.eq("sub") {
        result = sub(a1, a2)
    }
    else if op_copy.eq("mul") {
        result = mul(a1, a2)
    }
    else if op_copy.eq("div") {
        result = div(a1, a2)
    }
    else if op_copy.eq("mod") {
        result = mod(a1, a2)
    }

    mut res_copy := result
    return res_copy.to_str()
}

// Helper: evaluate comparison operations
eval_comparison_op := proc(mut context: Context, params: ExprArray, op: Str) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    if lt(params.len(), 3) {
        throw format(loc(), " ERROR: ", op, " requires 2 arguments")
    }

    // Get arg1 and arg2
    mut arg1_expr := Expr()
    mut arg2_expr := Expr()
    params.get(1, arg1_expr)
    params.get(2, arg2_expr)

    // Evaluate arguments
    arg1_str := eval_expr(context, arg1_expr)
    arg2_str := eval_expr(context, arg2_expr)

    // Convert to I64 for numeric comparison
    mut a1_copy := arg1_str
    mut a2_copy := arg2_str
    a1 := a1_copy.to_i64()
    a2 := a2_copy.to_i64()

    // Perform comparison
    mut result := false
    mut op_copy := op
    if op_copy.eq("lt") {
        result = lt(a1, a2)
    }
    else if op_copy.eq("gt") {
        result = gt(a1, a2)
    }
    else if op_copy.eq("eq") {
        result = eq(a1, a2)
    }

    if result {
        return "true"
    }
    return "false"
}

// Evaluate a body (sequence of statements)
// Phase 2: simplified version without catch/throw/return handling
eval_body := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Get the statements array
    mut params_array := e.params
    mut num_stmts := params_array.len()

    // Evaluate each statement in sequence
    mut i := 0
    mut last_result := ""
    while lt(i, num_stmts) {
        mut stmt := Expr()
        params_array.get(i, stmt)

        last_result = eval_expr(context, stmt)

        i = add(i, 1)
    }

    // Return the last result (or empty string if no statements)
    return last_result
}

// FIX Cannot use 'main_args' of type 'StrArray' as an argument. Only name of struct instances allowed for struct arguments for now.
// run_file_or_exit := proc(path: Str, main_args: StrArray) {
run_file_or_exit := proc(path: Str) {
    println("[INFO] '", LANG_NAME, "': Reading file '", path, "'")
    src := readfile(path)
    tokens := scan_tokens(src) // REM don't call scan_tokens from here
    catch (err: Str) {
        println(err)
        exit(1)
    }
    println("Lexer: ", I64.to_str(tokens.len), " tokens scanned.")

    // FIX Lexer.new(path) and we stop callig scan_tokens(src)
    // lexer := Lexer.new(path)
    // lexer.print_lex_errors()
}

usage := proc() {
    println("Usage: ", LANG_NAME, " [command] [path]\n");
    println("Entering no arguments is equavalent to: '", LANG_NAME, " repl'");
    println("Entering a single argument that's not a command is interpreted as a path, equivalent to: '", LANG_NAME, " interpret <path>'\n");

    println("Commands:\n");

    println("repl: read eval print loop.");
    println("interpret: reads a file in provided <path> and evaluates it.");
    // println("ast: reads a file in provided <path> and prints its abstract syntax tree (aka (lisp-like-syntax ast-from-now-on ) ).");
    println("build: reads a file in provided <path> and compiles it. Not implemented yet.");
    println("run: reads a file in provided <path> and runs it if it compiles. Not implemented yet.");
    println("help: Prints this.\n");
    println("version, --version, -v: Prints version.\n");
}

main := proc(args: ..Str) {

    if gt(args.len, 1) {
        mut main_args := Array.new("Str", size_of(Str), sub(args.len, 1))
        for i in 1..args.len {
            mut val := ""
            args.get(i, val)
            main_args.set(add(i, 0), val)
            catch(err: IndexOutOfBoundsError) {
                // REM: It is fine to args.set(0) here, we just checked
            }
        }

        mut cmd := ""
        args.get(0, cmd)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        mut val1 := ""
        args.get(1, val1)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(1) here, we just checked
        }
        switch cmd {
        case "interpret" : run_file_or_exit(val1)
        // case "interpret" : run_file_or_exit(args.get(1), main_args) // TODO FIX
        case "repl"      : usage()
        case "build"     : usage()
        case "run"       : usage()
        case:
            println("command '", cmd, "' not implemented.")
            usage()
        }

    } else if gt(args.len, 0) {
        mut path := ""
        args.get(0, path)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        switch path {
        // case "version" | "--version" | "-v": println(CURRENT_VERSION) // TODO Some syntax to 'or' cases
        case "repl"      : runfile(REPL_PATH)

        case "version"   : println(CURRENT_VERSION)
        case "--version" : println(CURRENT_VERSION)
        case "-v"        : println(CURRENT_VERSION)

        case "--help"    : usage()
        case "-help"     : usage()
        case "help"      : usage()

        case "ast"       : usage()
        case "build"     : usage()
        case "interpret" : usage()
        case "run"       : usage()
        case:
            run_file_or_exit(path)
            // run_file_or_exit(path, Array.new("Str", size_of(Str), 0)) // TODO FIX
        }
    } else {
        runfile(REPL_PATH)
    }
}
