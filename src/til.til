mode cli

import("self.builder")      // interpreter, ext (via chain) - main_run, run_file, run_file_with_context
import("self.eval_arena")   // g_arena
import("self.lexer")        // LANG_NAME
import("std.sys")           // run_cmd

CURRENT_VERSION := "til_0.0.1" // REM: No point in advancing versions until it compiles itself
REPL_PATH       := "src/modes/repl.til"

// ---------- interpret, build, run commands

// Run a file using run_file
interpret_file_or_exit := proc(path: Str, args: Vec) {
    _ := run_file(path, args)
    catch (err: Str) {
        println("ERROR: ", err)
        exit(1)
    }
    if path.ends_with("tests.til") {
        println("Total memory used by interpreted program: ", g_arena.len().to_str(), " bytes")
    }
}

build_file_or_exit := proc(path: Str) {
    _ := build(path)
    catch (err: Str) {
        println("Build error: ", err)
        exit(1)
    }
}

translate_file_or_exit := proc(path: Str) {
    _ := build(path)
    // Compute output path (same logic as builder.til)
    mut c_filename := path.replace(".til", ".c")
    mut output_path := c_filename
    if c_filename.starts_with("src/") {
        output_path = c_filename.replacen("src/", "gen/c/", 1)
    } else {
        output_path = concat("gen/c/", c_filename)
    }
    println("Generated: ", output_path)

    catch (err: Str) {
        println("Build error: ", err)
        exit(1)
    }
    catch (err: AllocError) {
        println("Build error: ", err.msg)
        exit(1)
    }
}

run_file_or_exit := proc(path: Str) {
    _ := build(path)
    catch (err: Str) {
        println("Build error: ", err)
        exit(1)
    }
    // Run the compiled binary
    mut exe_path := path.replace(".til", "")
    _ := run_cmd(exe_path)
    catch (err: AllocError) {
        println("Failed to run binary: ", err.msg)
        exit(1)
    }
}

usage := proc() {
    println("Usage: ", LANG_NAME, " [command] [path]\n");
    println("Entering no arguments is equavalent to: '", LANG_NAME, " repl'");
    println("Entering a single argument that's not a command is interpreted as a path, equivalent to: '", LANG_NAME, " interpret <path>'\n");

    println("Commands:\n");

    println("repl: read eval print loop.");
    println("interpret: reads a file in provided <path> and evaluates it.");
    println("build: reads a file in provided <path> and compiles it.");
    println("translate: reads a file in provided <path> and generates source code (no compilation).");
    println("run: reads a file in provided <path>, compiles and runs it.");
    println("help: Prints this.\n");
    println("version, --version, -v: Prints version.\n");
}

main := proc(args: ..Str) {

    if gt(args.len(), 1) {
        mut main_args := Vec.new(Str)
        mut i := 0
        for arg: Str in args {
            if i.gt(0) {
                main_args.push(arg)
            }
            i.inc()
        }
        catch(e: AllocError) {
            println("Fatal: Failed to allocate argument array")
            return
        }

        mut cmd := ""
        args.get(0, cmd)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        mut val1 := ""
        args.get(1, val1)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(1) here, we just checked
        }
        switch cmd {
        case "interpret" :
            // Pass remaining args after path (like Rust's args[3..])
            mut interp_args := Vec.new(Str)
            mut j := 2
            while j.lt(args.len()) {
                mut arg := ""
                args.get(j, arg)
                interp_args.push(arg)
                j.inc()
            }
            interpret_file_or_exit(val1, interp_args)
            catch (err: IndexOutOfBoundsError) { }
            catch (err: AllocError) {
                println("Fatal: Failed to allocate argument array")
                exit(1)
            }
        case "repl"      :
            interpret_file_or_exit(REPL_PATH, Vec.new(Str))
        case "build"     :
            build_file_or_exit(val1)
        case "translate" :
            translate_file_or_exit(val1)
        case "run"       :
            run_file_or_exit(val1)
        case:
            println("command '", cmd, "' not implemented.")
            usage()
            exit(1)
        }

    } else if gt(args.len(), 0) {
        mut path := ""
        args.get(0, path)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        switch path {
        // case "version" | "--version" | "-v": println(CURRENT_VERSION) // TODO Some syntax to 'or' cases
        case "repl"      :
            interpret_file_or_exit(REPL_PATH, Vec.new(Str))

        case "version"   : println(CURRENT_VERSION)
        case "--version" : println(CURRENT_VERSION)
        case "-v"        : println(CURRENT_VERSION)

        case "--help"    : usage()
        case "-help"     : usage()
        case "help"      : usage()

        case "ast"       : usage()
        case "build"     : usage()
        case "translate" : usage()
        case "interpret" : usage()
        case "run"       : usage()
        case:
            interpret_file_or_exit(path, Vec.new(Str))
        }
    } else {
        // If no arguments, then repl/interactive "mode"
        interpret_file_or_exit(REPL_PATH, Vec.new(Str))
    }
}
