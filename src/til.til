mode cli

import("src.core.array")
import("src.core.modes.modes")
import("src.core.self.runner")

// LANG_NAME is defined in lexer.til
CURRENT_VERSION := "til_0.0.1" // REM: No point in advancing versions until it compiles itself
REPL_PATH       := "src/core/modes/repl.til"

// Run a file: read, lex, parse, and evaluate
interpret_file_or_exit := proc(path: Str) throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    println("Running file '", path, "'")

    // Create lexer (reads file internally)
    mut lexer := Lexer.new(path)

    // For Phase 2, assume 'test' mode (simple mode that allows everything)
    mut mode_def := ModeDef()
    mode_def.name = "test"
    mode_def.allows_procs = true
    mode_def.allows_base_mut = true
    mode_def.allows_base_calls = true
    mode_def.allows_base_anything = true
    mode_def.needs_main_proc = false

    println("Mode: ", mode_def.name)

    // Skip mode directive if present
    // TODO Phase 3: Implement proper mode parsing
    mut first_token := lexer.peek()
    mut first_token_str := first_token.token_str
    if first_token_str.eq("mode") {
        lexer.advance(1) // skip 'mode'
        lexer.advance(1) // skip mode name
    }

    // Parse the file body (sequence of statements until EOF)
    mut ast := parse_body(lexer, TokenType.Eof)

    // Create context for evaluation
    mut context := Context.new(mode_def, path)

    // Process declarations (register symbols, functions, types)
    mut init_errors := init_context(context, ast)
    if gt(init_errors.len, 0) {
        mut i := 0
        while i.lt(init_errors.len) {
            mut err_msg := ""
            init_errors.get(i, err_msg)
            println(err_msg)
            i = i.add(1)
        }
        println("Initialization failed - exiting")
        exit(1)
    }

    // Evaluate the AST
    mut eval_result := eval_expr(context, ast)

    // Handle throw/return
    if eval_result.is_throw {
        println("Uncaught exception: ", eval_result.thrown_type, " - ", eval_result.value)
        exit(1)
    }
    // For script mode, result value is ignored

    // Success - no need to print result for test mode
}

build_file_or_exit := proc(path: Str) {
    TODO(loc(), "build_file_or_exit")
}

run_file_or_exit := proc(path: Str) {
    TODO(loc(), "run_file_or_exit")
}

usage := proc() {
    println("Usage: ", LANG_NAME, " [command] [path]\n");
    println("Entering no arguments is equavalent to: '", LANG_NAME, " repl'");
    println("Entering a single argument that's not a command is interpreted as a path, equivalent to: '", LANG_NAME, " interpret <path>'\n");

    println("Commands:\n");

    println("repl: read eval print loop.");
    println("interpret: reads a file in provided <path> and evaluates it.");
    // println("ast: reads a file in provided <path> and prints its abstract syntax tree (aka (lisp-like-syntax ast-from-now-on ) ).");
    println("build: reads a file in provided <path> and compiles it. Not implemented yet.");
    println("run: reads a file in provided <path> and runs it if it compiles. Not implemented yet.");
    println("help: Prints this.\n");
    println("version, --version, -v: Prints version.\n");
}

main := proc(args: ..Str) {

    if gt(args.len, 1) {
        mut main_args := Array.new(Str, sub(args.len, 1))
        catch(e: AllocError) {
            println("Fatal: Failed to allocate argument array")
            return
        }
        for i in 1..args.len {
            mut val := ""
            args.get(i, val)
            main_args.set(add(i, 0), val)
            catch(err: IndexOutOfBoundsError) {
                // REM: It is fine to args.set(0) here, we just checked
            }
        }

        mut cmd := ""
        args.get(0, cmd)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        mut val1 := ""
        args.get(1, val1)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(1) here, we just checked
        }
        switch cmd {
        case "interpret" :
            interpret_file_or_exit(val1)
            catch (err: Str) {
                println("Error during file execution: ", err)
                exit(1)
            }
            catch (err: AllocError) {
                println("AllocError during file execution")
                exit(1)
            }
            catch (err: IndexOutOfBoundsError) {
                println("IndexOutOfBoundsError during file execution")
                exit(1)
            }
            catch (err: I64_OverflowError) {
                println("I64_OverflowError during file execution")
                exit(1)
            }
            catch (err: FullError) {
                println("FullError during file execution")
                exit(1)
            }
        // case "interpret" : interpret_file_or_exit(args.get(1), main_args) // TODO FIX
        case "repl"      : usage()
        case "build"     : build_file_or_exit(val1)
        case "run"       : run_file_or_exit(val1)
        case:
            println("command '", cmd, "' not implemented.")
            usage()
        }

    } else if gt(args.len, 0) {
        mut path := ""
        args.get(0, path)
        catch(err: IndexOutOfBoundsError) {
            // REM: It is fine to args.get(0) here, we just checked
        }
        switch path {
        // case "version" | "--version" | "-v": println(CURRENT_VERSION) // TODO Some syntax to 'or' cases
        case "repl"      : runfile(REPL_PATH)

        case "version"   : println(CURRENT_VERSION)
        case "--version" : println(CURRENT_VERSION)
        case "-v"        : println(CURRENT_VERSION)

        case "--help"    : usage()
        case "-help"     : usage()
        case "help"      : usage()

        case "ast"       : usage()
        case "build"     : usage()
        case "interpret" : usage()
        case "run"       : usage()
        case:
            interpret_file_or_exit(path)
            catch (err: Str) {
                println("Error during execution:")
                println(err)
                exit(1)
            }
            catch (err: AllocError) {
                println("AllocError during execution")
                exit(1)
            }
            catch (err: IndexOutOfBoundsError) {
                println("IndexOutOfBoundsError during execution")
                exit(1)
            }
            catch (err: I64_OverflowError) {
                println("I64_OverflowError during execution")
                exit(1)
            }
            catch (err: FullError) {
                println("FullError during execution")
                exit(1)
            }
        }
    } else {
        // TEMP: Testing self-hosted compiler on hello_script.til
        interpret_file_or_exit("src/test/hello/hello_script.til")
        catch (err: Str) {
            println("Error during file execution: ", err)
            exit(1)
        }
        catch (err: AllocError) {
            println("AllocError during file execution")
            exit(1)
        }
        catch (err: IndexOutOfBoundsError) {
            println("IndexOutOfBoundsError during file execution")
            exit(1)
        }
        catch (err: I64_OverflowError) {
            println("I64_OverflowError during file execution")
            exit(1)
        }
        catch (err: FullError) {
            println("FullError during file execution")
            exit(1)
        }
    }
}
