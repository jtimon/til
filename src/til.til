// TIL self-hosted main entry point
// Mirrors src/rstil.rs

mode cli

import("self.builder")
import("self.interpreter")
import("self.lexer")
import("self.target")
import("std.sys")

REPL_PATH := "src/modes/repl.til"

// Parse --target=X and --lang=X options from args, return (remaining_args, target, lang, cc, translate_only, force_rebuild)
// Returns ParseBuildOptionsResult struct (TIL doesn't have tuples)
ParseBuildOptionsResult := struct {
    mut remaining: Vec = Vec.new(Str)
    mut target: Target = Target.LinuxX64
    mut lang: Lang = Lang.C
    mut cc: Str = ""  // Issue #131: --cc=COMPILER flag (empty = use default)
    mut translate_only: Bool = false
    mut force_rebuild: Bool = false
}

parse_build_options := proc(args: Vec) returns ParseBuildOptionsResult throws Str {
    mut remaining := Vec.new(Str)
    mut target_set := false
    mut target := Target.LinuxX64
    mut lang_set := false
    mut lang := Lang.C
    mut cc := ""
    mut translate_only := false
    mut force_rebuild := false

    for opt_arg: Str in args {
        if opt_arg.starts_with("--target=") {
            target_value := opt_arg.get_substr(9, opt_arg.len())?
            target = target_from_str(target_value)?
            target_set = true
        } else if opt_arg.starts_with("--lang=") {
            lang_value := opt_arg.get_substr(7, opt_arg.len())?
            lang = lang_from_str(lang_value)?
            lang_set = true
        } else if opt_arg.starts_with("--cc=") {
            // Issue #131: Allow specifying C compiler (e.g., --cc=clang)
            cc = opt_arg.get_substr(5, opt_arg.len())?
        } else if opt_arg.eq("--translate") {
            translate_only = true
        } else if opt_arg.eq("--force-rebuild") {
            force_rebuild = true
        } else {
            remaining.push(opt_arg.clone())
        }
    }

    // Default target is current platform
    mut final_target := target
    if not(target_set) {
        final_target = detect_current_target()
    }
    // Default lang is determined by target
    mut final_lang := lang
    if not(lang_set) {
        final_lang = default_lang_for_target(final_target)
    }

    mut result := ParseBuildOptionsResult()
    result.remaining = remaining
    result.target = final_target
    result.lang = final_lang
    result.cc = cc
    result.translate_only = translate_only
    result.force_rebuild = force_rebuild

    catch (err: IndexOutOfBoundsError) { throw err.msg }

    return result
}

// Compute the binary output path from a TIL source path
// Mirrors the logic in builder.til
// Bug #141: Use LANG_NAME_141 to separate rstil (rs) and til outputs
source_to_binary_path := func(path: Str, target: Target) returns Str {
    exe_extension := executable_extension(target)
    bin_filename := path.replace(".til", exe_extension)
    bin_prefix := concat("bin/", LANG_NAME_141).concat("/")
    if bin_filename.starts_with("src/") {
        return bin_filename.replace("src/", bin_prefix)
    } else {
        return concat(bin_prefix, bin_filename)
    }
}

// Check if binary needs to be rebuilt based on source file modification times
// Returns true if binary doesn't exist or any dependency is newer than binary
needs_rebuild := proc(binary_path: Str, deps: Vec) returns Bool {
    binary_mtime := file_mtime(binary_path)
    neg_one := sub(0, 1)
    if binary_mtime.eq(neg_one) {
        return true  // Binary doesn't exist
    }

    for dep: Str in deps {
        dep_mtime := file_mtime(dep)
        if dep_mtime.gt(binary_mtime) {
            return true  // Dependency is newer
        }
    }
    return false
}

// ---------- main, usage, args, etc

usage := proc() {
    println("Usage: ", LANG_NAME, " [command] [path] [options]\n")
    println("Entering no arguments is equavalent to: ", LANG_NAME, " repl")
    println("Entering a single argument that's not a command is interpreted as a path, equivalent to: ", LANG_NAME, " interpret <path>\n")

    println("Commands:\n")

    println("repl: read eval print loop.")
    println("interpret: reads a file in provided <path> and evaluates it.")
    println("build: reads a file in provided <path> and compiles it.")
    println("translate: reads a file in provided <path> and generates source code (no compilation).")
    println("run: reads a file in provided <path>, compiles and runs it.")
    println("help: Prints this.\n")

    println("Build/Translate Options:\n")
    println("--target=TARGET   Cross-compile for target platform.")
    println("                  Supported: linux-x64, linux-arm64, windows-x64, macos-x64, macos-arm64")
    println("--lang=LANG       Output language for codegen (default: c).")
    println("                  Supported: c")
    println("--force-rebuild   Force rebuild even if binary is up-to-date.\n")
}

interpret_file_or_exit := proc(path: Str, args: Vec) {
    _ := interpret_file(path, args)?
    catch (err: Str) {
        println("ERROR: ", err)
        exit(1)
    }
    if path.ends_with("tests.til") {
        println("Total memory used by interpreted program: ", g_arena.len().to_str(), " bytes")
    }
}

build_file_or_exit := proc(path: Str, target: Target, lang: Lang, cc: Str, translate_only: Bool, force_rebuild: Bool) {
    // Skip rebuild check for translate (always regenerate source)
    if not(translate_only).and(not(force_rebuild)) {
        exe_path := source_to_binary_path(path, target)
        mut should_rebuild := true
        deps := collect_all_deps(path)?
        should_rebuild = needs_rebuild(exe_path, deps)
        catch (err: Str) {
            should_rebuild = true
        }
        if not(should_rebuild) {
            return  // Binary is up-to-date
        }
    }

    output_path := build(path, target, lang, cc, translate_only)?
    if translate_only {
        println("Generated: ", output_path)
    }
    catch (err: Str) {
        println("ERROR: ", err)
        exit(1)
    }
}

run_file_or_exit := proc(path: Str, target: Target, lang: Lang, cc: Str, extra_args: Vec, force_rebuild: Bool) {
    // Compute expected binary path
    exe_path := source_to_binary_path(path, target)

    // Collect dependencies and check if rebuild is needed
    mut should_rebuild := true
    if force_rebuild {
        should_rebuild = true
    } else {
        deps := collect_all_deps(path)?
        should_rebuild = needs_rebuild(exe_path, deps)
        catch (err: Str) {
            // If we can't collect deps, assume rebuild needed
            should_rebuild = true
        }
    }

    // Only build if needed
    if should_rebuild {
        _ := build(path, target, lang, cc, false)?
        catch (err: Str) {
            println("ERROR: ", err)
            exit(1)
        }
    }

    // Run the compiled binary with any extra arguments
    // Use run_cmd_vec_print to inherit stdout/stderr like rstil does
    exit_code := run_cmd_vec_print(exe_path, extra_args)
    if not(exit_code.eq(0)) {
        exit(exit_code)
    }
}

main := proc(args: ..Str) {
    // args already collected by TIL runtime

    if args.len().gt(1) {
        mut command := ""
        args.get(0, command)?
        catch (err: IndexOutOfBoundsError) { }

        mut remaining_args := Vec.new(Str)
        mut i := 1
        while i.lt(args.len()) {
            mut arg := ""
            args.get(i, arg)?
            remaining_args.push(arg)
            i.inc()
        }
        catch (err: IndexOutOfBoundsError) { }

        if command.eq("interpret") {
            // interpret doesn't use build options, just pass remaining args
            mut path := ""
            args.get(1, path)?
            mut main_args := Vec.new(Str)
            mut j := 2
            while j.lt(args.len()) {
                mut interp_arg := ""
                args.get(j, interp_arg)?
                main_args.push(interp_arg)
                j.inc()
            }
            interpret_file_or_exit(path, main_args)
            catch (err: IndexOutOfBoundsError) { }
            return
        } else if command.eq("build") {
            // Parse build options from remaining args
            build_opts := parse_build_options(remaining_args)?
            if build_opts.remaining.is_empty() {
                println("Error: No path specified")
                usage()
                exit(1)
            }
            mut build_first_path := ""
            build_opts.remaining.get(0, build_first_path)?
            translate_only := build_opts.translate_only
            build_file_or_exit(build_first_path, build_opts.target, build_opts.lang, build_opts.cc, translate_only, build_opts.force_rebuild)
            catch (err: Str) {
                println("Error: ", err)
                exit(1)
            }
            catch (err: IndexOutOfBoundsError) { }
            return
        } else if command.eq("translate") {
            // Parse build options from remaining args
            translate_opts := parse_build_options(remaining_args)?
            if translate_opts.remaining.is_empty() {
                println("Error: No path specified")
                usage()
                exit(1)
            }
            mut translate_first_path := ""
            translate_opts.remaining.get(0, translate_first_path)?
            build_file_or_exit(translate_first_path, translate_opts.target, translate_opts.lang, translate_opts.cc, true, translate_opts.force_rebuild)
            catch (err: Str) {
                println("Error: ", err)
                exit(1)
            }
            catch (err: IndexOutOfBoundsError) { }
            return
        } else if command.eq("run") {
            // Parse build options from remaining args
            run_opts := parse_build_options(remaining_args)?
            if run_opts.remaining.is_empty() {
                println("Error: No path specified")
                usage()
                exit(1)
            }
            mut run_first_path := ""
            run_opts.remaining.get(0, run_first_path)?
            // Pass remaining paths as arguments to the compiled program
            mut extra_args := Vec.new(Str)
            if run_opts.remaining.len().gt(1) {
                mut k := 1
                while k.lt(run_opts.remaining.len()) {
                    mut run_arg := ""
                    run_opts.remaining.get(k, run_arg)?
                    extra_args.push(run_arg)
                    k.inc()
                }
            }
            run_file_or_exit(run_first_path, run_opts.target, run_opts.lang, run_opts.cc, extra_args, run_opts.force_rebuild)
            catch (err: Str) {
                println("Error: ", err)
                exit(1)
            }
            catch (err: IndexOutOfBoundsError) { }
            return
        } else if command.eq("repl") {
            usage()
            return
        } else {
            println("command '", command, "' not implemented.")
            usage()
            exit(1)
        }
    } else if args.len().gt(0) {
        mut first_arg := ""
        args.get(0, first_arg)?
        catch (err: IndexOutOfBoundsError) { }
        switch first_arg {
        case "repl":
            interpret_file_or_exit(REPL_PATH, Vec.new(Str))
        case "ast":
            usage()
        case "interpret":
            usage()
        case "build":
            usage()
        case "translate":
            usage()
        case "run":
            usage()
        case "help":
            usage()
        case "-help":
            usage()
        case "--help":
            usage()
        case "--version":
            usage()
        case "-v":
            usage()
        case:
            interpret_file_or_exit(first_arg, Vec.new(Str))
        }
        return
    }

    // If no arguments, then repl/interactive "mode"
    interpret_file_or_exit(REPL_PATH, Vec.new(Str))
}
