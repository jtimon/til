mode cli

import("std.sys")
import("std.io")
import("modes.test")

// tests.til - TIL test runner
// Runs compiled tests and compares output against .out files

// .out file format:
// args: <args>
// expected_status: <exit_code>
// output:
// <actual output>

// Test entry struct - explicit about path, args, and expected status
TestEntry := struct {
    mut path: Str = ""              // Path to the .til file
    mut cmd_args: Str = ""          // Command line arguments (empty string if none)
    mut expected_status: I64 = 0    // Expected exit status (0 for success)
}

// Parse time output like "real\t0m0.042s" -> milliseconds
// Assumes LC_ALL=C format (dot as decimal separator)
// Returns -1 if parsing fails
parse_time_ms := func(time_output: Str) returns I64 throws AllocError, IndexOutOfBoundsError {
    // Find "real" line
    lines := time_output.split("\n")
    for line: Str in lines {
        if line.starts_with("real") {
            // Format: "real\t0m0.042s"
            // Find position of 'm' using index_of
            m_pos := line.find("m")
            s_pos := line.find("s")
            if m_pos.gt(0) {
                if s_pos.gt(m_pos) {
                    // Extract seconds part between 'm' and 's'
                    sec_str := get_substr(line, m_pos.add(1), s_pos)
                    // Convert to milliseconds (multiply by 1000)
                    // Parse as float by splitting on dot
                    parts := sec_str.split(".")
                    if parts.len().eq(2) {
                        mut whole := ""
                        mut frac := ""
                        parts.get(0, whole)
                        parts.get(1, frac)
                        // Pad or truncate frac to 3 digits for ms
                        while frac.len().lt(3) {
                            frac = frac.concat("0")
                        }
                        if frac.len().gt(3) {
                            frac = get_substr(frac, 0, 3)
                        }
                        return whole.to_i64().mul(1000).add(frac.to_i64())
                    }
                }
            }
        }
    }
    return sub(0, 1)
}

// Run a command with timing, returns exit code and stores time in ms
// Output goes to mut output param, time goes to mut time_ms param
// Uses LC_ALL=C for consistent time format
run_timed := proc(mut output: Str, mut time_ms: I64, cmd: Str) returns I64 {
    // Wrap command to capture both output and timing
    // Uses LC_ALL=C for consistent time format (dot as decimal separator)
    mut wrapped := "LC_ALL=C bash -c 'time "
    wrapped = wrapped.concat(cmd).concat("' 2>&1")
    mut full_output := ""
    exit_code := full_output.run_cmd("bash", "-c", wrapped)

    // Truncate huge outputs (e.g., gcc errors) to prevent hangs
    // Str.find() is O(n*m) and slow in interpreter for large strings
    // Keep the END of output since timing info is at the end
    max_output := 1000
    if full_output.len().gt(max_output) {
        start_pos := full_output.len().sub(max_output)
        full_output = get_substr(full_output, start_pos, full_output.len())
    }

    // Split output at "\nreal" - everything before is command output, after is time
    // Also handle case where output starts with "real" (no program output)
    split_pos := full_output.find("\nreal")
    if split_pos.gt(0) {
        // Normal case: program output before time
        output = get_substr(full_output, 0, split_pos)
        time_output := get_substr(full_output, split_pos, full_output.len())
        time_ms = parse_time_ms(time_output)
    } else {
        if split_pos.eq(0) {
            // Time at very start (only newline before real)
            output = ""
            time_ms = parse_time_ms(full_output)
        } else {
            // Try finding "real" at start (no newline before)
            if full_output.starts_with("real") {
                output = ""
                time_ms = parse_time_ms(full_output)
            } else {
                output = full_output
                time_ms = sub(0, 1)
            }
        }
    }

    catch (err: IndexOutOfBoundsError) {
        output = full_output
        time_ms = sub(0, 1)
    }
    catch (err: AllocError) {
        output = full_output
        time_ms = sub(0, 1)
    }

    return exit_code
}

// Format milliseconds as "0.042s"
format_time := func(ms: I64) returns Str {
    if ms.lt(0) {
        return "N/A"
    }
    secs := ms.div(1000)
    millis := ms.mod(1000)
    mut millis_str := millis.to_str()
    while millis_str.len().lt(3) {
        millis_str = concat("0", millis_str)
    }
    return secs.to_str().concat(".").concat(millis_str).concat("s")
}

// Path transform: src/examples/foo.til -> gen/out/examples/foo.interpreted.out
// test_mode: "interpreted" or "compiled"
// cmd_args: "" for default, "help" for .help.out, etc.
get_out_path := func(src_path: Str, test_mode: Str, cmd_args: Str) returns Str throws AllocError {
    base := src_path.replace(".til", "").replace("src/", "gen/out/")
    mut suffix := ""
    if not(cmd_args.eq("")) {
        // Replace spaces with dots for filename: "help foo" -> ".help.foo"
        suffix = concat(".", cmd_args.replace(" ", "."))
    }
    return base.concat(suffix).concat(".").concat(test_mode).concat(".out")
}

// Format output file content
format_expected := func(cmd_args: Str, exit_code: I64, output: Str) returns Str {
    mut result := "args: "
    result = result.concat(cmd_args).concat("\n")
    result = result.concat("expected_status: ").concat(exit_code.to_str()).concat("\n")
    result = result.concat("output:\n")
    result = result.concat(output)
    return result
}

// Unified test function - runs a test with given command prefix
// cmd_prefix: "./bin/rstil interpret ", "./bin/rstil run ", etc.
// fail_label: label for error messages (e.g., "interpret", "run", "til interpret", "til run")
// out_mode: "interpreted" or "compiled" - determines which .out file to compare against
test_with_cmd := proc(entry: TestEntry, cmd_prefix: Str, fail_label: Str, out_mode: Str, mut time_ms: I64) returns Bool {
    out_path := get_out_path(entry.path, out_mode, entry.cmd_args)
    ensure_out_file(entry.path, entry.cmd_args, out_path, out_mode)

    mut output := ""
    mut run_time := 0
    mut cmd := cmd_prefix
    cmd = cmd.concat(entry.path)
    if not(entry.cmd_args.eq("")) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    actual_exit_code := run_timed(output, run_time, cmd)
    time_ms = run_time

    // Check exit code
    if not(actual_exit_code.eq(entry.expected_status)) {
        println("FAIL (", fail_label, " exit code): ", entry.path)
        println("  expected: ", entry.expected_status.to_str())
        println("  actual: ", actual_exit_code.to_str())
        if not(output.eq("")) {
            println("  output: ", output)
        }
        return true
    }

    // Check output via diff
    tmp_actual := "gen/out/actual.out"
    actual_content := format_expected(entry.cmd_args, actual_exit_code, output)
    _ := writefile(tmp_actual, actual_content)
    mut diff_u_result := ""
    _ := diff_u_result.run_cmd("diff", "-u", out_path, tmp_actual)
    mut rm_result := ""
    _ := rm_result.run_cmd("rm", tmp_actual)
    if not(diff_u_result.eq("")) {
        println("FAIL (", fail_label, " output): ", entry.path)
        println(diff_u_result)
        return true
    }

    catch (err: AllocError) { panic(loc(), err.msg) }

    return false
}

// Wrapper functions
test_rs_interpreted := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil interpret ", "rstil interpret", "interpreted", time_ms)
}

test_rs_compiled := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil run ", "rstil run", "compiled", time_ms)
}

test_til_interpreted := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil run src/til.til interpret ", "til interpret", "interpreted", time_ms)
}

test_til_compiled := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil run src/til.til run ", "til run", "compiled", time_ms)
}

run_all_tests := proc(til_interpreted: Vec, til_compiled: Vec, til_common: Vec, rs_interpreted: Vec, rs_compiled: Vec, rs_common: Vec) {
    mut errors_found := 0
    total_tests := til_interpreted.len().add(til_compiled.len()).add(til_common.len()).add(rs_interpreted.len()).add(rs_compiled.len()).add(rs_common.len())
    mut total_interpret_ms := 0
    mut total_compile_ms := 0
    mut total_til_interp_ms := 0
    mut total_til_compile_ms := 0
    mut benchmark_content := ""

    println("\n=== til_interpreted (", til_interpreted.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("* til_interpreted\n")
    for i in 0..til_interpreted.len() {
        mut entry := TestEntry()
        til_interpreted.get(i, entry)
        mut time_ms := 0
        if test_til_interpreted(entry, time_ms) {
            errors_found.inc()
        }
        total_til_interp_ms = total_til_interp_ms.add(time_ms)
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", til_interpreted.len().to_str(), "] ", entry.path, args_display, " (til interpreted: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: til interpreted: ").concat(format_time(time_ms)).concat("\n")
    }

    println("\n=== til_compiled (", til_compiled.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("\n* til_compiled\n")
    for i in 0..til_compiled.len() {
        mut entry := TestEntry()
        til_compiled.get(i, entry)
        mut time_ms := 0
        if test_til_compiled(entry, time_ms) {
            errors_found.inc()
        }
        total_til_compile_ms = total_til_compile_ms.add(time_ms)
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", til_compiled.len().to_str(), "] ", entry.path, args_display, " (til compiled: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: til compiled: ").concat(format_time(time_ms)).concat("\n")
    }

    println("\n=== til_common (", til_common.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("\n* til_common\n")
    for i in 0..til_common.len() {
        mut entry := TestEntry()
        til_common.get(i, entry)
        mut interp_ms := 0
        mut compile_ms := 0
        errors_found = errors_found.add(test_til_common(entry, interp_ms, compile_ms))
        total_til_interp_ms = total_til_interp_ms.add(interp_ms)
        total_til_compile_ms = total_til_compile_ms.add(compile_ms)
        mut faster := ""
        if interp_ms.lt(compile_ms) {
            faster = " (faster interpreted)"
        } else {
            if compile_ms.lt(interp_ms) {
                faster = " (faster compiled)"
            }
        }
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", til_common.len().to_str(), "] ", entry.path, args_display, " (til interpreted: ", format_time(interp_ms), ", til compiled: ", format_time(compile_ms), ")", faster)
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: til interpreted: ").concat(format_time(interp_ms)).concat(", til compiled: ").concat(format_time(compile_ms)).concat(faster).concat("\n")
    }

    println("\n=== rs_interpreted (", rs_interpreted.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("\n* rs_interpreted\n")
    for i in 0..rs_interpreted.len() {
        mut entry := TestEntry()
        rs_interpreted.get(i, entry)
        mut time_ms := 0
        if test_rs_interpreted(entry, time_ms) {
            errors_found.inc()
        }
        total_interpret_ms = total_interpret_ms.add(time_ms)
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", rs_interpreted.len().to_str(), "] ", entry.path, args_display, " (interpreted: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: interpreted: ").concat(format_time(time_ms)).concat("\n")
    }

    println("\n=== rs_compiled (", rs_compiled.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("\n* rs_compiled\n")
    for i in 0..rs_compiled.len() {
        mut entry := TestEntry()
        rs_compiled.get(i, entry)
        mut time_ms := 0
        if test_rs_compiled(entry, time_ms) {
            errors_found.inc()
        }
        total_compile_ms = total_compile_ms.add(time_ms)
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", rs_compiled.len().to_str(), "] ", entry.path, args_display, " (compiled: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: compiled: ").concat(format_time(time_ms)).concat("\n")
    }

    println("\n=== rs_common (", rs_common.len().to_str(), " tests) ===\n")
    benchmark_content = benchmark_content.concat("\n* rs_common\n")
    for i in 0..rs_common.len() {
        mut entry := TestEntry()
        rs_common.get(i, entry)
        mut interp_ms := 0
        mut compile_ms := 0
        errors_found = errors_found.add(test_rs_common(entry, interp_ms, compile_ms))
        total_interpret_ms = total_interpret_ms.add(interp_ms)
        total_compile_ms = total_compile_ms.add(compile_ms)
        mut faster := ""
        if interp_ms.lt(compile_ms) {
            faster = " (faster interpreted)"
        } else {
            if compile_ms.lt(interp_ms) {
                faster = " (faster compiled)"
            }
        }
        mut args_display := ""
        if not(entry.cmd_args.eq("")) {
            args_display = concat(" ", entry.cmd_args)
        }
        println("[", i.add(1).to_str(), "/", rs_common.len().to_str(), "] ", entry.path, args_display, " (interpreted: ", format_time(interp_ms), ", compiled: ", format_time(compile_ms), ")", faster)
        benchmark_content = benchmark_content.concat("- ").concat(entry.path).concat(" :: interpreted: ").concat(format_time(interp_ms)).concat(", compiled: ").concat(format_time(compile_ms)).concat(faster).concat("\n")
    }

    // Print and write totals
    println("")
    println("=== Totals ===")
    println("Total rust interpreted:  ", format_time(total_interpret_ms))
    println("Total rust compiled:     ", format_time(total_compile_ms))
    println("Total til interpreted:   ", format_time(total_til_interp_ms))
    println("Total til compiled:      ", format_time(total_til_compile_ms))
    println("Total:                   ", format_time(total_interpret_ms.add(total_compile_ms).add(total_til_interp_ms).add(total_til_compile_ms)))
    println("Failed:                  ", errors_found.to_str(), "/", total_tests.to_str())

    // Build totals section and prepend it
    mut totals := "* Totals\n"
    totals = totals.concat("- Total rust interpreted :: ").concat(format_time(total_interpret_ms)).concat("\n")
    totals = totals.concat("- Total rust compiled :: ").concat(format_time(total_compile_ms)).concat("\n")
    totals = totals.concat("- Total til interpreted :: ").concat(format_time(total_til_interp_ms)).concat("\n")
    totals = totals.concat("- Total til compiled :: ").concat(format_time(total_til_compile_ms)).concat("\n")
    totals = totals.concat("- Total :: ").concat(format_time(total_interpret_ms.add(total_compile_ms).add(total_til_interp_ms).add(total_til_compile_ms))).concat("\n\n")

    _ := writefile("gen/benchmark.org", totals.concat(benchmark_content))

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    if errors_found.gt(0) {
        panic(loc(), errors_found.to_str().concat("/").concat(total_tests.to_str()).concat(" tests failed."))
    }
}

regen := proc(files: Vec, rs_common: Vec, rs_compiled: Vec, rs_interpreted: Vec) {
    // Note: til_interpreted uses same .out files as rs_interpreted, no separate regen needed
    if files.len().eq(0) {
        // regen all
        for entry: TestEntry in rs_common {
            regen_test(entry)
        }
        for entry: TestEntry in rs_compiled {
            regen_test_compiled(entry)
        }
        for entry: TestEntry in rs_interpreted {
            regen_test(entry)
        }
    } else {
        // regen specific files - find matching entries in lists
        // Match by full path or by suffix (e.g., "loops.til" matches "src/test/loops.til")
        for file: Str in files {
            // Search in each list for entries with matching path
            for entry: TestEntry in rs_common {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test(entry)
                }
            }
            for entry: TestEntry in rs_compiled {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test_compiled(entry)
                }
            }
            for entry: TestEntry in rs_interpreted {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test(entry)
                }
            }
        }
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
}

// Ensure parent directory exists for a file path
ensure_parent_dir := proc(file_path: Str) throws AllocError {
    // Extract directory by finding last /
    mut last_slash := 0
    for i in 0..file_path.len() {
        if file_path.get_char(i).eq("/") {
            last_slash = i
        }
    }
    if last_slash.gt(0) {
        dir := get_substr(file_path, 0, last_slash)
        mut result := ""
        _ := result.run_cmd("mkdir", "-p", dir)
    }

    catch (err: IndexOutOfBoundsError) { /* ignore */ }
}

// Auto-generate missing .out files
// test_mode: "interpreted" uses rstil interpret, "compiled" uses rstil run
ensure_out_file := proc(path: Str, cmd_args: Str, out_path: Str, test_mode: Str) {
    mut ls_result := ""
    _ := ls_result.run_cmd("ls", out_path)
    if not(ls_result.contains(".out")) {
        mut output := ""
        mut cmd := ""
        if test_mode.eq("compiled") {
            cmd = concat("./bin/rstil run ", path)
        } else {
            cmd = concat("./bin/rstil interpret ", path)
        }
        if not(cmd_args.eq("")) {
            cmd = cmd.concat(" ").concat(cmd_args)
        }
        exit_code := output.run_cmd("bash", "-c", cmd)
        formatted := format_expected(cmd_args, exit_code, output)
        ensure_parent_dir(out_path)
        _ := writefile(out_path, formatted)
        println("Created: ", out_path)
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
}

// _common tests compare both modes against same .interpreted.out file
test_rs_common := proc(entry: TestEntry, mut interpret_ms: I64, mut compile_ms: I64) returns I64 {
    mut errors_found := 0
    if test_with_cmd(entry, "./bin/rstil interpret ", "interpret", "interpreted", interpret_ms) {
        errors_found.inc()
    }
    if test_with_cmd(entry, "./bin/rstil run ", "run", "interpreted", compile_ms) {
        errors_found.inc()
    }
    return errors_found
}

test_til_common := proc(entry: TestEntry, mut interpret_ms: I64, mut compile_ms: I64) returns I64 {
    mut errors_found := 0
    if test_with_cmd(entry, "./bin/rstil run src/til.til interpret ", "til interpret", "interpreted", interpret_ms) {
        errors_found.inc()
    }
    if test_with_cmd(entry, "./bin/rstil run src/til.til run ", "til run", "interpreted", compile_ms) {
        errors_found.inc()
    }
    return errors_found
}

regen_test := proc(entry: TestEntry) throws AllocError {
    out_path := get_out_path(entry.path, "interpreted", entry.cmd_args)

    mut output := ""
    mut exit_code := 0
    if entry.cmd_args.eq("") {
        exit_code = output.run_cmd("./bin/rstil", "interpret", entry.path)
    } else {
        cmd := concat(concat("./bin/rstil interpret ", entry.path), concat(" ", entry.cmd_args))
        exit_code = output.run_cmd("bash", "-c", cmd)
    }
    formatted := format_expected(entry.cmd_args, exit_code, output)
    ensure_parent_dir(out_path)
    _ := writefile(out_path, formatted)
    println("Regenerated: ", out_path)
}

regen_test_compiled := proc(entry: TestEntry) throws AllocError {
    out_path := get_out_path(entry.path, "compiled", entry.cmd_args)

    mut output := ""
    mut exit_code := 0
    if entry.cmd_args.eq("") {
        exit_code = output.run_cmd("./bin/rstil", "run", entry.path)
    } else {
        cmd := concat(concat("./bin/rstil run ", entry.path), concat(" ", entry.cmd_args))
        exit_code = output.run_cmd("bash", "-c", cmd)
    }
    formatted := format_expected(entry.cmd_args, exit_code, output)
    ensure_parent_dir(out_path)
    _ := writefile(out_path, formatted)
    println("Regenerated (compiled): ", out_path)
}

usage := proc() {
    println("Usage: tests [command] [options]")
    println("")
    println("Entering no arguments is equivalent to: 'tests test'")
    println("")
    println("Commands:")
    println("")
    println("test: runs all tests.")
    println("test <mode> <file> [args]: runs single file with mode's behavior.")
    println("regen: regenerates all .out files.")
    println("regen <mode> <status> <file> [args]: regenerates specific .out file.")
    println("help: prints this.")
    println("")
    println("Modes: rs_interpreted, rs_compiled, rs_common, til_interpreted, til_compiled, til_common")
}

main := proc(args: ..Str) {
    mut rs_common := Vec.new(TestEntry)
    // test a part of posix compatibility, it doesn't require the mode to be script, it can be compiled too, like roc
    // Ideally we should benchmark against at least bash, python, roc, Rust, C and HolyC for this kind of mode, both interpreted and compiled
    rs_common.push(TestEntry(path="src/examples/hello_cli.til"))
    rs_common.push(TestEntry(path="src/examples/hello_lib.til"))
    rs_common.push(TestEntry(path="src/examples/hello_liba.til"))
    rs_common.push(TestEntry(path="src/examples/hello_pura.til"))
    rs_common.push(TestEntry(path="src/examples/hello_pure.til"))
    rs_common.push(TestEntry(path="src/examples/hello_script.til"))
    rs_common.push(TestEntry(path="src/examples/hello_test.til"))
    rs_common.push(TestEntry(path="src/examples/lolalalo.til"))
    rs_common.push(TestEntry(path="src/test/arenas.til"))
    rs_common.push(TestEntry(path="src/test/args.til"))
    rs_common.push(TestEntry(path="src/test/arithmetics.til"))
    rs_common.push(TestEntry(path="src/test/arrays.til"))
    rs_common.push(TestEntry(path="src/test/boolean.til"))
    rs_common.push(TestEntry(path="src/test/branchless.til"))
    rs_common.push(TestEntry(path="src/test/bug41.til"))
    rs_common.push(TestEntry(path="src/test/bug43.til"))
    rs_common.push(TestEntry(path="src/test/bug46.til"))
    rs_common.push(TestEntry(path="src/test/bug47.til"))
    rs_common.push(TestEntry(path="src/test/bug48.til", expected_status=1))
    rs_common.push(TestEntry(path="src/test/bug49.til", expected_status=1))
    rs_common.push(TestEntry(path="src/test/bug50.til", expected_status=1))
    rs_common.push(TestEntry(path="src/test/bug52.til"))
    rs_common.push(TestEntry(path="src/test/bug55.til"))
    rs_common.push(TestEntry(path="src/test/bug56.til"))
    rs_common.push(TestEntry(path="src/test/bug57.til"))
    rs_common.push(TestEntry(path="src/test/c_mem.til"))
    rs_common.push(TestEntry(path="src/test/circular_test.til"))
    rs_common.push(TestEntry(path="src/test/clone.til"))
    rs_common.push(TestEntry(path="src/test/comparisons.til"))
    rs_common.push(TestEntry(path="src/test/constfold.til"))
    rs_common.push(TestEntry(path="src/test/cross_file_forward.til"))
    rs_common.push(TestEntry(path="src/test/deterministic.til"))
    rs_common.push(TestEntry(path="src/test/editor_mode_test.til"))
    rs_common.push(TestEntry(path="src/test/enums.til"))
    rs_common.push(TestEntry(path="src/test/errors.til"))
    rs_common.push(TestEntry(path="src/test/eval.til"))
    rs_common.push(TestEntry(path="src/test/exit.til", expected_status=69))
    rs_common.push(TestEntry(path="src/test/fibonacci.til"))
    rs_common.push(TestEntry(path="src/test/flow.til"))
    rs_common.push(TestEntry(path="src/test/forward_declarations.til"))
    rs_common.push(TestEntry(path="src/test/func_purity.til"))
    rs_common.push(TestEntry(path="src/test/function_pointers.til"))
    rs_common.push(TestEntry(path="src/test/intro.til"))
    // rs_common.push(TestEntry(path="src/test/introspections.til")) // TODO: Add C impl for Introspection.has_const/has_field in src/ext.c
    rs_common.push(TestEntry(path="src/test/lists.til"))
    rs_common.push(TestEntry(path="src/test/loops.til"))
    rs_common.push(TestEntry(path="src/test/maps.til"))
    rs_common.push(TestEntry(path="src/test/modes.til"))
    rs_common.push(TestEntry(path="src/test/mut_test.til"))
    rs_common.push(TestEntry(path="src/test/namespaces.til"))
    rs_common.push(TestEntry(path="src/test/optional_args.til"))
    rs_common.push(TestEntry(path="src/test/pointers.til"))
    rs_common.push(TestEntry(path="src/test/return_value_usage.til"))
    rs_common.push(TestEntry(path="src/test/scope_isolation.til"))
    rs_common.push(TestEntry(path="src/test/sets.til"))
    rs_common.push(TestEntry(path="src/test/strings.til"))
    rs_common.push(TestEntry(path="src/test/structs.til"))
    rs_common.push(TestEntry(path="src/test/temp.til"))
    rs_common.push(TestEntry(path="src/test/test_lexer.til"))
    rs_common.push(TestEntry(path="src/test/test_parser.til"))
    rs_common.push(TestEntry(path="src/test/todo.til")) // permanent TODO, design notes for future features
    rs_common.push(TestEntry(path="src/test/u8.til"))
    rs_common.push(TestEntry(path="src/test/ufcs.til"))
    rs_common.push(TestEntry(path="src/test/undefined.til", expected_status=1)) // in both rs_interpreted and rs_compiled because interpret/run produce different output wrappers
    rs_common.push(TestEntry(path="src/test/underscore.til"))
    rs_common.push(TestEntry(path="src/test/variadic.til"))
    rs_common.push(TestEntry(path="src/test/vecs.til"))
    rs_common.push(TestEntry(path="src/til.til", cmd_args="help"))

    mut rs_compiled := Vec.new(TestEntry)

    rs_compiled.push(TestEntry(path="src/test/memcmp_str_compiled.til")) // TODO decide: compiles but runtime: memcmp on Str structs compares pointers not content
    rs_compiled.push(TestEntry(path="src/test/precomp_throw.til", expected_status=1)) // Bug #54: should fail at precomp, currently fails at runtime

    mut rs_interpreted := Vec.new(TestEntry)

    rs_interpreted.push(TestEntry(path="src/examples/hello_safe_script.til", expected_status=1)) // TODO: compiled version doesn't enforce safe_script whitelist
    rs_interpreted.push(TestEntry(path="src/test/memcmp_str_interpreted.til")) // TODO decide: compiles but runtime: memcmp on Str structs compares pointers not content
    rs_interpreted.push(TestEntry(path="src/test/precomp_throw.til", expected_status=1)) // Bug #54: should fail at precomp, currently fails at runtime
    rs_interpreted.push(TestEntry(path="src/test/introspections.til")) // TODO: Add C impl for Introspection.has_const/has_field in src/ext.c

    // REPL test - requires stdin piping (e.g., echo "exit(0)" | ./bin/rstil repl)
    // run_cmd doesn't support stdin, would need bash -c wrapper or new ext_proc
    // Input must end with exit(0) to break out of the infinite while loop
    // rs_interpreted.push(TestEntry(path="src/modes/repl.til"))

    // til_interpreted: tests run with the self-hosted TIL interpreter only
    mut til_interpreted := Vec.new(TestEntry)
    til_interpreted.push(TestEntry(path="src/examples/empty.til", expected_status=0))
    til_interpreted.push(TestEntry(path="src/examples/hello_cli.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_lib.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_liba.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_pura.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_pure.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_script.til"))
    til_interpreted.push(TestEntry(path="src/examples/hello_test.til"))
    til_interpreted.push(TestEntry(path="src/examples/lolalalo.til"))
    // til_interpreted.push(TestEntry(path="src/test/arenas.til"))  // TODO: arena overflow
    til_interpreted.push(TestEntry(path="src/test/args.til"))
    til_interpreted.push(TestEntry(path="src/test/arithmetics.til"))
    // til_interpreted.push(TestEntry(path="src/test/arrays.til"))  // TODO: Source '10' not found in caller context
    til_interpreted.push(TestEntry(path="src/test/boolean.til"))
    til_interpreted.push(TestEntry(path="src/test/branchless.til"))
    til_interpreted.push(TestEntry(path="src/test/bug41.til"))
    // til_interpreted.push(TestEntry(path="src/test/bug43.til"))  // TODO: assert_eq failed: expected '0', found '65536'
    til_interpreted.push(TestEntry(path="src/test/bug46.til"))
    // til_interpreted.push(TestEntry(path="src/test/bug47.til"))  // TODO: Undefined symbol 'vt' in parser.til
    til_interpreted.push(TestEntry(path="src/test/bug48.til", expected_status=1))
    // til_interpreted.push(TestEntry(path="src/test/bug49.til", expected_status=1))  // TODO: output mismatch (different error format)
    // til_interpreted.push(TestEntry(path="src/test/bug50.til", expected_status=1))  // TODO: output mismatch (rstil vs til prefix)
    // til_interpreted.push(TestEntry(path="src/test/bug52.til"))  // TODO: type error with assert_eq_str
    // til_interpreted.push(TestEntry(path="src/test/bug55.til"))  // TODO: assert_eq_str failed: expected 'hello', found ''
    // til_interpreted.push(TestEntry(path="src/test/bug56.til"))  // TODO: Enum variant payload type 'unknown' not supported
    til_interpreted.push(TestEntry(path="src/test/bug57.til"))
    til_interpreted.push(TestEntry(path="src/test/c_mem.til"))
    til_interpreted.push(TestEntry(path="src/test/circular_test.til"))
    // til_interpreted.push(TestEntry(path="src/test/clone.til"))  // TODO: Source '10' not found in caller context
    til_interpreted.push(TestEntry(path="src/test/comparisons.til"))
    til_interpreted.push(TestEntry(path="src/test/constfold.til"))
    til_interpreted.push(TestEntry(path="src/test/cross_file_forward.til"))
    // til_interpreted.push(TestEntry(path="src/test/deterministic.til"))  // TODO: Source '1' not found in caller context
    // til_interpreted.push(TestEntry(path="src/test/editor_mode_test.til"))  // TODO: enum payload type 'unknown' not supported
    // til_interpreted.push(TestEntry(path="src/test/enums.til"))  // TODO: Enum variant payload type 'unknown' not supported
    // til_interpreted.push(TestEntry(path="src/test/errors.til"))  // TODO: string_from_context out of bounds
    til_interpreted.push(TestEntry(path="src/test/eval.til"))
    til_interpreted.push(TestEntry(path="src/test/exit.til", expected_status=69))
    til_interpreted.push(TestEntry(path="src/test/fibonacci.til"))
    til_interpreted.push(TestEntry(path="src/test/flow.til"))
    // til_interpreted.push(TestEntry(path="src/test/forward_declarations.til"))  // TODO: enum payload type 'unknown' not supported
    til_interpreted.push(TestEntry(path="src/test/func_purity.til"))
    til_interpreted.push(TestEntry(path="src/test/function_pointers.til"))
    til_interpreted.push(TestEntry(path="src/test/intro.til"))
    // til_interpreted.push(TestEntry(path="src/test/lists.til"))  // TODO: Source '42' not found in caller context
    // til_interpreted.push(TestEntry(path="src/test/loops.til"))  // TODO: Source '10' not found in caller context
    // til_interpreted.push(TestEntry(path="src/test/maps.til"))  // TODO: Source '100' not found in caller context
    // til_interpreted.push(TestEntry(path="src/test/modes.til"))  // TODO: Source 'panic' not found in caller context
    // til_interpreted.push(TestEntry(path="src/test/mut_test.til"))  // TODO: Source '10' not found in caller context
    til_interpreted.push(TestEntry(path="src/test/namespaces.til"))
    // til_interpreted.push(TestEntry(path="src/test/optional_args.til"))  // TODO: exit code 1 (no output)
    til_interpreted.push(TestEntry(path="src/test/pointers.til"))
    til_interpreted.push(TestEntry(path="src/test/return_value_usage.til"))
    til_interpreted.push(TestEntry(path="src/test/scope_isolation.til"))
    // til_interpreted.push(TestEntry(path="src/test/sets.til"))  // TODO: Source 'hello' not found in caller context
    til_interpreted.push(TestEntry(path="src/test/strings.til"))
    // til_interpreted.push(TestEntry(path="src/test/structs.til"))  // TODO: assert_eq failed: expected '10', found garbage
    til_interpreted.push(TestEntry(path="src/test/temp.til"))
    // til_interpreted.push(TestEntry(path="src/test/test_lexer.til"))  // TODO: String range comparisons not yet supported
    // til_interpreted.push(TestEntry(path="src/test/test_parser.til"))  // TODO: Undefined symbol 'vt'
    til_interpreted.push(TestEntry(path="src/test/todo.til"))
    til_interpreted.push(TestEntry(path="src/test/u8.til"))
    // til_interpreted.push(TestEntry(path="src/test/ufcs.til"))  // TODO: exit code 1 (no output)
    // til_interpreted.push(TestEntry(path="src/test/undefined.til", expected_status=1))  // TODO: output mismatch (missing enum variant error)
    til_interpreted.push(TestEntry(path="src/test/underscore.til"))
    til_interpreted.push(TestEntry(path="src/test/variadic.til"))
    // til_interpreted.push(TestEntry(path="src/test/vecs.til"))  // TODO: Undefined symbol 'p1'
    // til_interpreted.push(TestEntry(path="src/til.til", cmd_args="help"))  // TODO: exit code 1 (no output)

    // til_compiled: tests run with the self-hosted TIL compiler only
    mut til_compiled := Vec.new(TestEntry)
    // til_compiled.push(TestEntry(path="src/examples/empty.til", expected_status=0)) // TODO: Fix "func 'Bool' returns multiple values" error

    // til_common: tests run with BOTH self-hosted TIL interpreter and compiler
    mut til_common := Vec.new(TestEntry)
    // til_common.push(TestEntry(path="src/examples/empty.til", expected_status=0)) // TODO: Fix "func 'Bool' returns multiple values" error

    // Parse args
    if args.len().eq(0) {
        // Default: run tests
        run_all_tests(til_interpreted, til_compiled, til_common, rs_interpreted, rs_compiled, rs_common)
    } else {
        mut cmd := ""
        args.get(0, cmd)
        switch cmd {
        case "test":
            if args.len().eq(1) {
                run_all_tests(til_interpreted, til_compiled, til_common, rs_interpreted, rs_compiled, rs_common)
            } else if args.len().lt(3) {
                println("Error: test requires <mode> and <file>")
                usage()
                exit(1)
            } else {
                mut test_mode := ""
                mut file := ""
                args.get(1, test_mode)
                args.get(2, file)
                // Collect optional args
                mut cmd_args := ""
                for i in 3..args.len() {
                    mut arg := ""
                    args.get(i, arg)
                    if cmd_args.len().gt(0) {
                        cmd_args = cmd_args.concat(" ")
                    }
                    cmd_args = cmd_args.concat(arg)
                }
                entry := TestEntry(path=file, cmd_args=cmd_args)
                mut time_ms := 0
                mut time_ms2 := 0
                switch test_mode {
                case "rs_interpreted":
                    _ := test_rs_interpreted(entry, time_ms)
                case "rs_compiled":
                    _ := test_rs_compiled(entry, time_ms)
                case "rs_common":
                    _ := test_rs_common(entry, time_ms, time_ms2)
                case "til_interpreted":
                    _ := test_til_interpreted(entry, time_ms)
                case "til_compiled":
                    _ := test_til_compiled(entry, time_ms)
                case "til_common":
                    _ := test_til_common(entry, time_ms, time_ms2)
                case:
                    println("Error: unknown mode '", test_mode, "'")
                    usage()
                    exit(1)
                }
            }
        case "regen":
            mut files := Vec.new(Str)
            for i in 1..args.len() {
                mut path := ""
                args.get(i, path)
                files.push(path)
            }
            regen(files, rs_common, rs_compiled, rs_interpreted)
        case:
            usage()
        }
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
