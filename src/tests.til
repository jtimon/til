mode cli

import("std.sys")
import("std.io")
import("modes.test")

// tests2.til - TIL test runner
// Runs compiled tests and compares output against .out files

// .out file format: _TIL_TESTS_{exit_code}_TIL_TESTS_\n{output}
MARKER_PREFIX := "_TIL_TESTS_"
MARKER_SUFFIX := "_TIL_TESTS_"

// Path transform: src/examples/foo.til -> src/examples/foo.out
get_out_path := func(src_path: Str) returns Str throws AllocError {
    return src_path.replace(".til", ".out")
}

// Format output with exit code marker
format_expected := func(exit_code: I64, output: Str) returns Str {
    return concat(concat(concat(concat(MARKER_PREFIX, exit_code.to_str()), MARKER_SUFFIX), "\n"), output)
}

// Parse expected file: extract exit code and output
parse_expected := proc(content: Str, mut exit_code: I64, mut output: Str) throws AllocError, IndexOutOfBoundsError {
    // Format: _TIL_TESTS_{code}_TIL_TESTS_\n{output}
    prefix_len := MARKER_PREFIX.len()

    // Search for suffix AFTER the prefix (skip first marker)
    rest_after_prefix := get_substr(content, prefix_len, content.len())
    suffix_pos_in_rest := rest_after_prefix.find(MARKER_SUFFIX)

    // suffix_start is position in original string
    suffix_start := prefix_len.add(suffix_pos_in_rest)

    code_str := get_substr(content, prefix_len, suffix_start)
    exit_code = code_str.to_i64()

    // Find newline after marker and get rest as output
    output_start := suffix_start.add(MARKER_SUFFIX.len()).add(1)
    if output_start.gteq(content.len()) {
        output = ""
    } else {
        output = get_substr(content, output_start, content.len())
    }
}

run_all_tests := proc(rs_common: Vec, rs_compiled: Vec, rs_interpret: Vec) {
    mut errors_found := false
    for i in 0..rs_common.len() {
        mut path := ""
        rs_common.get(i, path)
        if test_rs_common(path) {
            errors_found = true
        }
    }
    for i in 0..rs_compiled.len() {
        mut path := ""
        rs_compiled.get(i, path)
        if test_rs_compiled(path) {
            errors_found = true
        }
    }
    for i in 0..rs_interpret.len() {
        mut path := ""
        rs_interpret.get(i, path)
        if test_rs_interpreted(path) {
            errors_found = true
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    if errors_found {
        panic(loc(), "tests failed")
    }
}

regen := proc(files: Vec, rs_common: Vec, rs_compiled: Vec, rs_interpret: Vec) {
    if files.len().eq(0) {
        // regen all
        for i in 0..rs_common.len() {
            mut path := ""
            rs_common.get(i, path)
            regen_test(path)
        }
        for i in 0..rs_compiled.len() {
            mut path := ""
            rs_compiled.get(i, path)
            regen_test(path)
        }
        for i in 0..rs_interpret.len() {
            mut path := ""
            rs_interpret.get(i, path)
            regen_test(path)
        }
    } else {
        // regen specific files
        for i in 0..files.len() {
            mut path := ""
            files.get(i, path)
            regen_test(path)
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

ensure_out_file := proc(path: Str, out_path: Str) {
    mut ls_result := ""
    _ := ls_result.run_cmd("ls", out_path)
    if not(ls_result.contains(".out")) {
        mut output := ""
        exit_code := output.run_cmd("./bin/rstil", "interpret", path)
        formatted := format_expected(exit_code, output)
        _ := writefile(out_path, formatted)
        println("Created: ", out_path)
    }
}

test_rs_interpreted := proc(path: Str) returns Bool {
    out_path := get_out_path(path)
    ensure_out_file(path, out_path)

    // Read expected file and parse exit code + output
    expected_content := readfile(out_path)
    mut expected_exit_code := 0
    mut expected_output := ""
    parse_expected(expected_content, expected_exit_code, expected_output)

    // Run interpreter and capture exit code + output
    mut interp_output := ""
    actual_exit_code := interp_output.run_cmd("./bin/rstil", "interpret", path)

    // Check exit code
    if not(actual_exit_code.eq(expected_exit_code)) {
        println("FAIL (interpret exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", actual_exit_code.to_str())
        return true
    }

    // Check output via diff
    _ := writefile(path.replace(".til", ".interpret.out"), interp_output)
    _ := writefile(path.replace(".til", ".expected.out"), expected_output)
    mut interp_diff := ""
    _ := interp_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".interpret.out"))
    if not(interp_diff.eq("")) {
        println("FAIL (interpret output): ", path)
        println(interp_diff)
        return true
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    return false
}

test_rs_compiled := proc(path: Str) returns Bool {
    out_path := get_out_path(path)
    ensure_out_file(path, out_path)

    // Read expected file and parse exit code + output
    expected_content := readfile(out_path)
    mut expected_exit_code := 0
    mut expected_output := ""
    parse_expected(expected_content, expected_exit_code, expected_output)

    // Run compiled and capture exit code + output
    mut run_output := ""
    actual_exit_code := run_output.run_cmd("./bin/rstil", "run", path)

    // Check exit code
    if not(actual_exit_code.eq(expected_exit_code)) {
        println("FAIL (run exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", actual_exit_code.to_str())
        return true
    }

    // Check output via diff
    _ := writefile(path.replace(".til", ".run.out"), run_output)
    _ := writefile(path.replace(".til", ".expected.out"), expected_output)
    mut run_diff := ""
    _ := run_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".run.out"))
    if not(run_diff.eq("")) {
        println("FAIL (run output): ", path)
        println(run_diff)
        return true
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    return false
}

test_rs_common := proc(path: Str) returns Bool {
    mut errors_found := test_rs_interpreted(path)
    if test_rs_compiled(path) {
        errors_found = true
    }

    return errors_found
}

regen_test := proc(path: Str) {
    mut output := ""
    exit_code := output.run_cmd("./bin/rstil", "interpret", path)
    out_path := get_out_path(path)
    formatted := format_expected(exit_code, output)
    _ := writefile(out_path, formatted)
    println("Regenerated: ", out_path)

    catch (err: AllocError) { panic(loc(), err.msg) }
}

usage := proc() {
    println("tests2 - TIL test runner")
    println("")
    println("Usage:")
    println("  tests2              Run all tests (default)")
    println("  tests2 test         Run all tests")
    println("  tests2 regen        Regenerate all .out files")
    println("  tests2 regen <path> Regenerate specific .out file")
    println("")
    println("Example:")
    println("  tests2 regen src/examples/hello_script.til")
}

main := proc(args: ..Str) {
    mut rs_common := Vec.new(Str)
    // test a part of posix compatibility, it doesn't require the mode to be script, it can be compiled too, like roc
    // Ideally we should benchmark against at least bash, python, roc, Rust, C and HolyC for this kind of mode, both interpreted and compiled
    rs_common.push("src/examples/hello_script.til")
    rs_common.push("src/examples/hello_test.til")
    rs_common.push("src/examples/hello_cli.til")
    rs_common.push("src/examples/hello_lib.til")

    mut rs_compiled := Vec.new(Str)
    rs_compiled.push("src/core/core.til")
    rs_compiled.push("src/test/enums_simple.til")
    rs_compiled.push("src/test/throw_simple.til")

    mut rs_interpret := Vec.new(Str)

    // hello_pure.til can't be compiled - mode pure forbids procs but core.til has procs
    rs_interpret.push("src/examples/hello_pure.til")
    // rs_interpret.push("src/examples/hello_script_safe.til") // TODO this is much harder than it sounds

    rs_interpret.push("src/test/args.til")
    rs_interpret.push("src/test/arithmetics.til")
    rs_interpret.push("src/test/arrays.til")
    rs_interpret.push("src/test/boolean.til")
    rs_interpret.push("src/test/branchless.til")
    rs_interpret.push("src/test/c_mem.til")
    rs_interpret.push("src/test/circular_test.til")
    rs_interpret.push("src/test/comparisons.til")
    rs_interpret.push("src/test/editor_mode_test.til")
    rs_interpret.push("src/test/enums.til")
    rs_interpret.push("src/test/exit.til")
    rs_interpret.push("src/test/errors.til")
    rs_interpret.push("src/test/fibonacci.til") // recursive examples
    rs_interpret.push("src/test/flow.til") // control flow, execution path examples
    rs_interpret.push("src/test/forward_declarations.til")
    rs_interpret.push("src/test/func_purity.til")
    rs_interpret.push("src/test/function_pointers.til")
    rs_interpret.push("src/test/intro.til")
    rs_interpret.push("src/test/lists.til")
    rs_interpret.push("src/test/maps.til")
    rs_interpret.push("src/test/mut_test.til")
    rs_interpret.push("src/test/namespaces.til")
    rs_interpret.push("src/test/pointers.til")
    rs_interpret.push("src/test/run_cmd.til")
    rs_interpret.push("src/test/scope_isolation.til") // scope isolation tests
    rs_interpret.push("src/test/sets.til")
    rs_interpret.push("src/test/strings.til")
    rs_interpret.push("src/test/structs.til")
    rs_interpret.push("src/test/temp.til")
    rs_interpret.push("src/test/test_lexer.til")
    rs_interpret.push("src/test/test_parser.til")
    rs_interpret.push("src/test/u8.til")
    rs_interpret.push("src/test/ufcs.til")
    // rs_interpret.push("src/test/undefined.til") // REM Should produce compile-time errors for undefined types
    rs_interpret.push("src/test/variadic.til")
    // rs_interpret.push("src/test/clone.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/cross_file_forward.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/enums_payload.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/loops.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/return_value_usage.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/switch_simple.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/throw_simple.til") // TODO Not sure why this one is commented, uncomment
    // rs_interpret.push("src/test/throw_test2.til") // TODO Not sure why this one is commented, uncomment
    rs_interpret.push("src/test/vecs.til")

    // next level:
    rs_interpret.push("src/test/eval.til")
    rs_interpret.push("src/test/introspections.til")
    rs_interpret.push("src/test/modes.til")
    rs_interpret.push("src/test/todo.til") // permanent TODO, design notes for future features

    // Self-hosting interpreter tests
    // run the self hosting libs just to see they pass typer checks
    rs_interpret.push("src/self/interpreter.til")
    rs_interpret.push("src/tests_self_hosted.til")
    rs_interpret.push("src/test/builders.til")

    // REPL test - requires stdin piping (e.g., echo "exit(0)" | ./bin/rstil repl)
    // run_cmd doesn't support stdin, would need bash -c wrapper or new ext_proc
    // Input must end with exit(0) to break out of the infinite while loop
    // rs_interpret.push("src/modes/repl.til")

    // Parse args
    if args.len().eq(0) {
        // Default: run tests
        run_all_tests(rs_common, rs_compiled, rs_interpret)
    } else {
        mut cmd := ""
        args.get(0, cmd)
        switch cmd {
        case "test":
            run_all_tests(rs_common, rs_compiled, rs_interpret)
        case "regen":
            mut files := Vec.new(Str)
            for i in 1..args.len() {
                mut path := ""
                args.get(i, path)
                files.push(path)
            }
            regen(files, rs_common, rs_compiled, rs_interpret)
        case:
            usage()
        }
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
