mode cli

import("std.sys")
import("std.io")
import("modes.test")

// tests.til - TIL test runner
// Runs compiled tests and compares output against .out files

// .out file format:
// args: <args>
// expected_status: <exit_code>
// output:
// <actual output>

// Parse time output like "real\t0m0.042s" -> milliseconds
// Assumes LC_ALL=C format (dot as decimal separator)
// Returns -1 if parsing fails
parse_time_ms := func(time_output: Str) returns I64 throws AllocError, IndexOutOfBoundsError {
    // Find "real" line
    lines := time_output.split("\n")
    for i in 0..lines.len() {
        mut line := ""
        lines.get(i, line)
        if line.starts_with("real") {
            // Format: "real\t0m0.042s"
            // Find position of 'm' using index_of
            m_pos := line.find("m")
            s_pos := line.find("s")
            if m_pos.gt(0) {
                if s_pos.gt(m_pos) {
                    // Extract seconds part between 'm' and 's'
                    sec_str := get_substr(line, m_pos.add(1), s_pos)
                    // Convert to milliseconds (multiply by 1000)
                    // Parse as float by splitting on dot
                    parts := sec_str.split(".")
                    if parts.len().eq(2) {
                        mut whole := ""
                        mut frac := ""
                        parts.get(0, whole)
                        parts.get(1, frac)
                        // Pad or truncate frac to 3 digits for ms
                        while frac.len().lt(3) {
                            frac = frac.concat("0")
                        }
                        if frac.len().gt(3) {
                            frac = get_substr(frac, 0, 3)
                        }
                        return whole.to_i64().mul(1000).add(frac.to_i64())
                    }
                }
            }
        }
    }
    return sub(0, 1)
}

// Run a command with timing, returns exit code and stores time in ms
// Output goes to mut output param, time goes to mut time_ms param
// Uses LC_ALL=C for consistent time format
run_timed := proc(mut output: Str, mut time_ms: I64, cmd: Str) returns I64 {
    // Wrap command to capture both output and timing
    // Uses LC_ALL=C for consistent time format (dot as decimal separator)
    mut wrapped := "LC_ALL=C bash -c 'time "
    wrapped = wrapped.concat(cmd).concat("' 2>&1")
    mut full_output := ""
    exit_code := full_output.run_cmd("bash", "-c", wrapped)

    // Split output at "\nreal" - everything before is command output, after is time
    // Also handle case where output starts with "real" (no program output)
    split_pos := full_output.find("\nreal")
    if split_pos.gt(0) {
        // Normal case: program output before time
        output = get_substr(full_output, 0, split_pos)
        time_output := get_substr(full_output, split_pos, full_output.len())
        time_ms = parse_time_ms(time_output)
    } else {
        if split_pos.eq(0) {
            // Time at very start (only newline before real)
            output = ""
            time_ms = parse_time_ms(full_output)
        } else {
            // Try finding "real" at start (no newline before)
            if full_output.starts_with("real") {
                output = ""
                time_ms = parse_time_ms(full_output)
            } else {
                output = full_output
                time_ms = sub(0, 1)
            }
        }
    }

    catch (err: IndexOutOfBoundsError) {
        output = full_output
        time_ms = sub(0, 1)
    }
    catch (err: AllocError) {
        output = full_output
        time_ms = sub(0, 1)
    }

    return exit_code
}

// Format milliseconds as "0.042s"
format_time := func(ms: I64) returns Str {
    if ms.lt(0) {
        return "N/A"
    }
    secs := ms.div(1000)
    millis := ms.mod(1000)
    mut millis_str := millis.to_str()
    while millis_str.len().lt(3) {
        millis_str = concat("0", millis_str)
    }
    return secs.to_str().concat(".").concat(millis_str).concat("s")
}

// Parse "src/til.til:version" -> (path="src/til.til", variant="version")
// Parse "src/til.til" -> (path="src/til.til", variant="")
parse_test_entry := proc(entry: Str, mut path: Str, mut variant: Str) throws AllocError, IndexOutOfBoundsError {
    colon_pos := entry.find(":")
    if colon_pos.gt(sub(0, 1)) {
        path = get_substr(entry, 0, colon_pos)
        variant = get_substr(entry, colon_pos.add(1), entry.len())
    } else {
        path = entry
        variant = ""
    }
}

// Path transform: src/examples/foo.til -> src/examples/foo.interpreted.out or foo.compiled.out
// test_mode: "compiled" -> .compiled.out, anything else -> .interpreted.out
// variant: "" for default, "version" for .version.out, etc.
get_out_path := func(src_path: Str, test_mode: Str, variant: Str) returns Str throws AllocError {
    base := src_path.replace(".til", "")
    mut suffix := ""
    if test_mode.eq("compiled") {
        suffix = ".compiled"
    } else {
        suffix = ".interpreted"
    }
    if not(variant.eq("")) {
        suffix = suffix.concat(".").concat(variant)
    }
    return base.concat(suffix).concat(".out")
}

// Format output with args, exit code, and output
format_expected := func(args_str: Str, exit_code: I64, output: Str) returns Str {
    mut result := "args: "
    result = result.concat(args_str).concat("\n")
    result = result.concat("expected_status: ").concat(exit_code.to_str()).concat("\n")
    result = result.concat("output:\n")
    result = result.concat(output)
    return result
}

// Parse expected file: extract args, exit code, and output
parse_expected := proc(content: Str, mut args_str: Str, mut exit_code: I64, mut output: Str) throws AllocError, IndexOutOfBoundsError, Str {
    // Format:
    // args: <args>
    // expected_status: <exit_code>
    // output:
    // <actual output>

    lines := content.split("\n")
    if lt(lines.len(), 3) {
        throw "Invalid .out file format: need at least 3 lines. Use 'rstil interpret src/tests.til regen' to regenerate."
    }

    // Parse args line
    mut args_line := ""
    lines.get(0, args_line)
    if not(args_line.starts_with("args: ")) {
        throw "Invalid .out file format: first line must start with 'args: '. Use 'rstil interpret src/tests.til regen' to regenerate."
    }
    if args_line.len().gt(6) {
        args_str = get_substr(args_line, 6, args_line.len())
    } else {
        args_str = ""
    }

    // Parse expected_status line
    mut status_line := ""
    lines.get(1, status_line)
    if not(status_line.starts_with("expected_status: ")) {
        throw "Invalid .out file format: second line must start with 'expected_status: '. Use 'rstil interpret src/tests.til regen' to regenerate."
    }
    status_str := get_substr(status_line, 17, status_line.len())
    exit_code = status_str.to_i64()

    // Parse output line marker
    mut output_line := ""
    lines.get(2, output_line)
    if not(output_line.eq("output:")) {
        throw "Invalid .out file format: third line must be 'output:'. Use 'rstil interpret src/tests.til regen' to regenerate."
    }

    // Join remaining lines as output
    output = ""
    for i in 3..lines.len() {
        mut line := ""
        lines.get(i, line)
        if i.gt(3) {
            output = output.concat("\n")
        }
        output = output.concat(line)
    }
}

run_all_tests := proc(rs_common: Vec, rs_compiled: Vec, rs_interpreted: Vec) {
    mut errors_found := false
    mut total_interpret_ms := 0
    mut total_compile_ms := 0
    mut benchmark_content := ""

    println("=== rs_common (", rs_common.len().to_str(), " tests) ===")
    benchmark_content = benchmark_content.concat("* rs_common\n")
    for i in 0..rs_common.len() {
        mut entry := ""
        rs_common.get(i, entry)
        mut interp_ms := 0
        mut compile_ms := 0
        if test_rs_common(entry, interp_ms, compile_ms) {
            errors_found = true
        }
        total_interpret_ms = total_interpret_ms.add(interp_ms)
        total_compile_ms = total_compile_ms.add(compile_ms)
        // Compare times and add "faster" label
        mut faster := ""
        if interp_ms.lt(compile_ms) {
            faster = " (faster interpreted)"
        } else {
            if compile_ms.lt(interp_ms) {
                faster = " (faster compiled)"
            }
        }
        println("[", i.to_str(), "/", rs_common.len().to_str(), "] ", entry, " (interpreted: ", format_time(interp_ms), ", compiled: ", format_time(compile_ms), ")", faster)
        benchmark_content = benchmark_content.concat("- ").concat(entry).concat(" :: interpreted: ").concat(format_time(interp_ms)).concat(", compiled: ").concat(format_time(compile_ms)).concat(faster).concat("\n")
    }

    println("=== rs_compiled (", rs_compiled.len().to_str(), " tests) ===")
    benchmark_content = benchmark_content.concat("\n* rs_compiled\n")
    for i in 0..rs_compiled.len() {
        mut entry := ""
        rs_compiled.get(i, entry)
        mut time_ms := 0
        if test_rs_compiled(entry, time_ms) {
            errors_found = true
        }
        total_compile_ms = total_compile_ms.add(time_ms)
        println("[", i.to_str(), "/", rs_compiled.len().to_str(), "] ", entry, " (compiled: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry).concat(" :: compiled: ").concat(format_time(time_ms)).concat("\n")
    }

    println("=== rs_interpreted (", rs_interpreted.len().to_str(), " tests) ===")
    benchmark_content = benchmark_content.concat("\n* rs_interpreted\n")
    for i in 0..rs_interpreted.len() {
        mut entry := ""
        rs_interpreted.get(i, entry)
        mut time_ms := 0
        if test_rs_interpreted(entry, time_ms) {
            errors_found = true
        }
        total_interpret_ms = total_interpret_ms.add(time_ms)
        println("[", i.to_str(), "/", rs_interpreted.len().to_str(), "] ", entry, " (interpreted: ", format_time(time_ms), ")")
        benchmark_content = benchmark_content.concat("- ").concat(entry).concat(" :: interpreted: ").concat(format_time(time_ms)).concat("\n")
    }

    // Print and write totals
    println("")
    println("=== Totals ===")
    println("Total interpreted: ", format_time(total_interpret_ms))
    println("Total compiled:    ", format_time(total_compile_ms))
    println("Total:             ", format_time(total_interpret_ms.add(total_compile_ms)))

    // Build totals section and prepend it
    mut totals := "* Totals\n"
    totals = totals.concat("- Total interpreted :: ").concat(format_time(total_interpret_ms)).concat("\n")
    totals = totals.concat("- Total compiled :: ").concat(format_time(total_compile_ms)).concat("\n")
    totals = totals.concat("- Total :: ").concat(format_time(total_interpret_ms.add(total_compile_ms))).concat("\n\n")

    _ := writefile("benchmark.org", totals.concat(benchmark_content))

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

    if errors_found {
        panic(loc(), "tests failed")
    }
}

regen := proc(files: Vec, rs_common: Vec, rs_compiled: Vec, rs_interpreted: Vec) {
    if files.len().eq(0) {
        // regen all
        for i in 0..rs_common.len() {
            mut entry := ""
            rs_common.get(i, entry)
            regen_test(entry)
        }
        for i in 0..rs_compiled.len() {
            mut entry := ""
            rs_compiled.get(i, entry)
            regen_test_compiled(entry)
        }
        for i in 0..rs_interpreted.len() {
            mut entry := ""
            rs_interpreted.get(i, entry)
            regen_test(entry)
        }
    } else {
        // regen specific entries - check which lists they're in
        for i in 0..files.len() {
            mut entry := ""
            files.get(i, entry)
            // Entry can be in multiple lists, regen all applicable
            if rs_common.contains(entry) {
                regen_test(entry)
            }
            if rs_compiled.contains(entry) {
                regen_test_compiled(entry)
            }
            if rs_interpreted.contains(entry) {
                regen_test(entry)
            }
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

ensure_out_file := proc(path: Str, out_path: Str, test_mode: Str) {
    mut ls_result := ""
    _ := ls_result.run_cmd("ls", out_path)
    if not(ls_result.contains(".out")) {
        mut output := ""
        mut exit_code := 0
        if test_mode.eq("compiled") {
            exit_code = output.run_cmd("./bin/rstil", "run", path)
        } else {
            exit_code = output.run_cmd("./bin/rstil", "interpret", path)
        }
        formatted := format_expected("", exit_code, output)
        _ := writefile(out_path, formatted)
        println("Created: ", out_path)
    }
}

test_rs_interpreted := proc(entry: Str, mut time_ms: I64) returns Bool {
    mut path := ""
    mut variant := ""
    parse_test_entry(entry, path, variant)
    out_path := get_out_path(path, "interpreted", variant)
    ensure_out_file(path, out_path, "interpreted")

    // Read expected file and parse args, exit code, and output
    expected_content := readfile(out_path)
    mut args_str := ""
    mut expected_exit_code := 0
    mut expected_output := ""
    parse_expected(expected_content, args_str, expected_exit_code, expected_output)

    // Run interpreter with timing
    mut interp_output := ""
    mut interp_time := 0
    mut cmd := "./bin/rstil interpret "
    cmd = cmd.concat(path)
    if not(args_str.eq("")) {
        cmd = cmd.concat(" ").concat(args_str)
    }
    actual_exit_code := run_timed(interp_output, interp_time, cmd)
    time_ms = interp_time

    // Check exit code
    if not(actual_exit_code.eq(expected_exit_code)) {
        println("FAIL (interpret exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", actual_exit_code.to_str())
        return true
    }

    // Check output via diff
    _ := writefile(path.replace(".til", ".interpret.out"), interp_output)
    _ := writefile(path.replace(".til", ".expected.out"), expected_output)
    mut interp_diff := ""
    _ := interp_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".interpret.out"))
    if not(interp_diff.eq("")) {
        println("FAIL (interpret output): ", path)
        println(interp_diff)
        return true
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: Str) { panic(loc(), err) }

    return false
}

test_rs_compiled := proc(entry: Str, mut time_ms: I64) returns Bool {
    mut path := ""
    mut variant := ""
    parse_test_entry(entry, path, variant)
    out_path := get_out_path(path, "compiled", variant)
    ensure_out_file(path, out_path, "compiled")

    // Read expected file and parse args, exit code, and output
    expected_content := readfile(out_path)
    mut args_str := ""
    mut expected_exit_code := 0
    mut expected_output := ""
    parse_expected(expected_content, args_str, expected_exit_code, expected_output)

    // Run compiled with timing
    mut run_output := ""
    mut run_time := 0
    mut cmd := "./bin/rstil run "
    cmd = cmd.concat(path)
    if not(args_str.eq("")) {
        cmd = cmd.concat(" ").concat(args_str)
    }
    actual_exit_code := run_timed(run_output, run_time, cmd)
    time_ms = run_time

    // Check exit code
    if not(actual_exit_code.eq(expected_exit_code)) {
        println("FAIL (run exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", actual_exit_code.to_str())
        return true
    }

    // Check output via diff
    _ := writefile(path.replace(".til", ".run.out"), run_output)
    _ := writefile(path.replace(".til", ".expected.out"), expected_output)
    mut run_diff := ""
    _ := run_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".run.out"))
    if not(run_diff.eq("")) {
        println("FAIL (run output): ", path)
        println(run_diff)
        return true
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: Str) { panic(loc(), err) }

    return false
}

test_rs_common := proc(entry: Str, mut interpret_ms: I64, mut compile_ms: I64) returns Bool {
    mut path := ""
    mut variant := ""
    parse_test_entry(entry, path, variant)
    // rs_common tests use .interpreted.out for BOTH modes (same expected output)
    out_path := get_out_path(path, "interpreted", variant)
    ensure_out_file(path, out_path, "interpreted")

    // Read expected file once and use for both modes
    expected_content := readfile(out_path)
    mut args_str := ""
    mut expected_exit_code := 0
    mut expected_output := ""
    parse_expected(expected_content, args_str, expected_exit_code, expected_output)

    mut errors_found := false

    // Test interpreted mode with timing
    mut interp_output := ""
    mut interp_time := 0
    mut cmd := "./bin/rstil interpret "
    cmd = cmd.concat(path)
    if not(args_str.eq("")) {
        cmd = cmd.concat(" ").concat(args_str)
    }
    interp_exit_code := run_timed(interp_output, interp_time, cmd)
    interpret_ms = interp_time

    if not(interp_exit_code.eq(expected_exit_code)) {
        println("FAIL (interpret exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", interp_exit_code.to_str())
        errors_found = true
    } else {
        _ := writefile(path.replace(".til", ".interpret.out"), interp_output)
        _ := writefile(path.replace(".til", ".expected.out"), expected_output)
        mut interp_diff := ""
        _ := interp_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".interpret.out"))
        if not(interp_diff.eq("")) {
            println("FAIL (interpret output): ", path)
            println(interp_diff)
            errors_found = true
        }
    }

    // Test compiled mode with timing
    mut run_output := ""
    mut run_time := 0
    cmd = "./bin/rstil run "
    cmd = cmd.concat(path)
    if not(args_str.eq("")) {
        cmd = cmd.concat(" ").concat(args_str)
    }
    run_exit_code := run_timed(run_output, run_time, cmd)
    compile_ms = run_time

    if not(run_exit_code.eq(expected_exit_code)) {
        println("FAIL (run exit code): ", path)
        println("  expected: ", expected_exit_code.to_str())
        println("  actual: ", run_exit_code.to_str())
        errors_found = true
    } else {
        _ := writefile(path.replace(".til", ".run.out"), run_output)
        mut run_diff := ""
        _ := run_diff.run_cmd("diff", path.replace(".til", ".expected.out"), path.replace(".til", ".run.out"))
        if not(run_diff.eq("")) {
            println("FAIL (run output): ", path)
            println(run_diff)
            errors_found = true
        }
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: Str) { panic(loc(), err) }

    return errors_found
}

regen_test := proc(entry: Str) {
    mut path := ""
    mut variant := ""
    parse_test_entry(entry, path, variant)
    out_path := get_out_path(path, "interpreted", variant)
    // Read existing args if .out file exists, otherwise use empty args
    mut args_str := ""
    mut existing := readfile(out_path)
    if existing.len().gt(0) {
        mut dummy_exit := 0
        mut dummy_output := ""
        parse_expected(existing, args_str, dummy_exit, dummy_output)
    }

    // Catch errors from readfile or parse_expected - use empty args
    catch (err: Str) { args_str = "" }

    mut output := ""
    mut exit_code := 0
    if args_str.eq("") {
        exit_code = output.run_cmd("./bin/rstil", "interpret", path)
    } else {
        cmd := concat(concat(concat("./bin/rstil interpret ", path), " "), args_str)
        exit_code = output.run_cmd("bash", "-c", cmd)
    }
    formatted := format_expected(args_str, exit_code, output)
    _ := writefile(out_path, formatted)
    println("Regenerated: ", out_path)

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

regen_test_compiled := proc(entry: Str) {
    mut path := ""
    mut variant := ""
    parse_test_entry(entry, path, variant)
    out_path := get_out_path(path, "compiled", variant)
    // Read existing args from .compiled.out - it must exist for rs_compiled tests
    mut args_str := ""
    mut existing := readfile(out_path)
    if existing.len().gt(0) {
        mut dummy_exit := 0
        mut dummy_output := ""
        parse_expected(existing, args_str, dummy_exit, dummy_output)
    }

    mut output := ""
    mut exit_code := 0
    if args_str.eq("") {
        exit_code = output.run_cmd("./bin/rstil", "run", path)
    } else {
        cmd := concat(concat(concat("./bin/rstil run ", path), " "), args_str)
        exit_code = output.run_cmd("bash", "-c", cmd)
    }
    formatted := format_expected(args_str, exit_code, output)
    _ := writefile(out_path, formatted)
    println("Regenerated (compiled): ", out_path)

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: Str) { panic(loc(), err) }
}

usage := proc() {
    println("tests - TIL test runner")
    println("")
    println("Usage:")
    println("  tests                    Run all tests (default)")
    println("  tests test               Run all tests")
    println("  tests regen              Regenerate all .out files")
    println("  tests regen <path>       Regenerate specific .out file")
    println("  tests regen <path>:<var> Regenerate specific variant")
    println("")
    println("Examples:")
    println("  tests regen src/examples/hello_script.til")
    println("  tests regen src/til.til:version")
}

main := proc(args: ..Str) {
    mut rs_common := Vec.new(Str)
    // test a part of posix compatibility, it doesn't require the mode to be script, it can be compiled too, like roc
    // Ideally we should benchmark against at least bash, python, roc, Rust, C and HolyC for this kind of mode, both interpreted and compiled
    rs_common.push("src/examples/hello_cli.til")
    rs_common.push("src/examples/hello_lib.til")
    rs_common.push("src/examples/hello_script.til")
    rs_common.push("src/examples/hello_test.til")
    rs_common.push("src/test/arithmetics.til")
    rs_common.push("src/test/arrays.til")
    rs_common.push("src/test/boolean.til")
    rs_common.push("src/test/branchless.til")
    rs_common.push("src/test/circular_test.til")
    rs_common.push("src/test/comparisons.til")
    rs_common.push("src/test/exit.til")
    rs_common.push("src/test/function_pointers.til")
    rs_common.push("src/test/loops.til")
    rs_common.push("src/test/pointers.til")
    rs_common.push("src/test/strings.til")
    rs_common.push("src/test/structs.til")
    rs_common.push("src/test/temp.til")
    rs_common.push("src/test/u8.til")
    rs_common.push("src/test/eval.til")
    rs_common.push("src/test/func_purity.til")
    rs_common.push("src/test/constfold.til")
    rs_common.push("src/test/c_mem.til")
    rs_common.push("src/test/flow.til")
    rs_common.push("src/test/fibonacci.til")
    rs_common.push("src/test/run_cmd.til")
    rs_common.push("src/test/variadic.til")
    rs_common.push("src/test/intro.til")
    rs_common.push("src/test/namespaces.til")
    rs_common.push("src/test/editor_mode_test.til")
    rs_common.push("src/test/mut_test.til")
    rs_common.push("src/test/return_value_usage.til")

    mut rs_compiled := Vec.new(Str)
    rs_compiled.push("src/test/enums_simple.til")
    rs_compiled.push("src/test/throw_simple.til")
    rs_compiled.push("src/test/memcmp_str_compiled.til")
    // precomp_throw.til is in both rs_interpreted and rs_compiled because interpret/run produce different outputs
    rs_compiled.push("src/test/precomp_throw.til")
    // TODO: til.til can be unified to rs_common once til.til compiles without C errors
    // rs_compiled.push("src/til.til")  // disabled: compiling til.til takes too long (3.5MB C output)
    // TODO FIX: enum constructors called as functions instead of struct init
    // rs_compiled.push("src/test/enums_payload.til")
    // TODO FIX: switch_simple.til - same issue plus:
    // - case labels missing til_ prefix (Color_Red vs til_Color_Red)
    // - payload extraction variable not declared (til_n)
    // - enum constructors called as functions instead of struct init
    // rs_compiled.push("src/test/switch_simple.til")

    mut rs_interpreted := Vec.new(Str)

    rs_interpreted.push("src/examples/hello_pure.til") // TODO FIX: mode pure forbids procs but core.til has procs
    rs_interpreted.push("src/test/args.til") // TODO FIX: mut Str* assignment, nested field access on mut param
    rs_interpreted.push("src/test/memcmp_str_interpreted.til")
    rs_interpreted.push("src/test/enums.til") // TODO FIX: enum payload field has incomplete type
    rs_interpreted.push("src/test/errors.til") // TODO FIX: throwing func result used directly in expression (needs temp var)
    rs_interpreted.push("src/test/forward_declarations.til") // TODO FIX: enum constructors emitted as function calls not struct init
    rs_interpreted.push("src/test/lists.til") // TODO FIX: AllocError() needs struct init not func call, throwing func in catch
    rs_interpreted.push("src/test/maps.til") // TODO FIX: Dynamic param expects void* but Str passed
    rs_interpreted.push("src/test/scope_isolation.til") // TODO FIX: nested func forward decl has const, definition has pointer
    rs_interpreted.push("src/test/sets.til") // TODO FIX: nested field access on self.elements->ptr/len, or() with no args, struct init vs func call
    rs_interpreted.push("src/test/test_lexer.til") // TODO FIX: throwing func (format) in catch block needs temp var
    rs_interpreted.push("src/test/test_parser.til") // TODO FIX: enum payload has incomplete type, throwing func in catch
    rs_interpreted.push("src/test/ufcs.til") // TODO FIX: throwing functions in struct initializers (get_substr, Vec.new)
    rs_interpreted.push("src/test/vecs.til") // TODO FIX: compiles but fails at runtime - compiled doesn't throw IndexOutOfBoundsError on bad index
    // precomp_throw.til is in both rs_interpreted and rs_compiled because interpret/run produce different outputs
    rs_interpreted.push("src/test/precomp_throw.til")

    // rs_interpreted.push("src/examples/hello_script_safe.til") // TODO this is much harder than it sounds
    // rs_interpreted.push("src/test/undefined.til")
    // rs_interpreted.push("src/test/clone.til") // TODO FIX: I64_OverflowError has no method 'clone'
    // rs_interpreted.push("src/test/cross_file_forward.til") // TODO FIX: Vec field access needs pointer, not value
    // rs_interpreted.push("src/test/enums_payload.til") // TODO FIX: enum constructors emitted as function calls not struct init
    // rs_interpreted.push("src/test/switch_simple.til") // TODO FIX: enum constructors as func calls, case payload var undeclared

    // next level:
    // eval.til moved to rs_common
    // flow.til moved to rs_common (const folding fixed switch case expressions)
    rs_interpreted.push("src/test/introspections.til") // TODO FIX: AllocError() needs struct init not func call, throwing func in catch
    rs_interpreted.push("src/test/modes.til") // TODO FIX: throwing func (format) in catch block needs temp var
    rs_interpreted.push("src/test/todo.til") // permanent TODO, design notes for future features

    // Self-hosting interpreter tests
    // run the self hosting libs just to see they pass typer checks
    rs_interpreted.push("src/self/interpreter.til") // TODO FIX: symbols already declared (double import?)
    // TODO: til.til can be unified to rs_common once til.til compiles without C errors
    rs_interpreted.push("src/til.til") // Type-check til.til by running with "help" argument (args in .out file)
    rs_interpreted.push("src/til.til:version") // Test version command
    // rs_interpreted.push("src/test/builders.til") // TODO FIX: compilation times out (too large or infinite loop)

    // REPL test - requires stdin piping (e.g., echo "exit(0)" | ./bin/rstil repl)
    // run_cmd doesn't support stdin, would need bash -c wrapper or new ext_proc
    // Input must end with exit(0) to break out of the infinite while loop
    // rs_interpreted.push("src/modes/repl.til")

    // Parse args
    if args.len().eq(0) {
        // Default: run tests
        run_all_tests(rs_common, rs_compiled, rs_interpreted)
    } else {
        mut cmd := ""
        args.get(0, cmd)
        switch cmd {
        case "test":
            run_all_tests(rs_common, rs_compiled, rs_interpreted)
        case "regen":
            mut files := Vec.new(Str)
            for i in 1..args.len() {
                mut path := ""
                args.get(i, path)
                files.push(path)
            }
            regen(files, rs_common, rs_compiled, rs_interpreted)
        case:
            usage()
        }
    }

    catch (err: AllocError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
