#!/usr/bin/env -S ./bin/rstil run
mode cli

import("std.sys")
import("std.io")
import("modes.test")
import("core.set")

// Global flag: run only Rust-based tests, skip all TIL self-hosted modes (set by --rust-only arg)
mut g_rust_only := false

// Global flag: --cc=COMPILER override (Issue #131)
mut g_cc := ""

// Global flag: enable heap memory profiling in compiled tests (set by --mem-report arg)
mut g_mem_report := false

// Global accumulators for per-test mem reports (only populated when g_mem_report=true)
mut g_mem_rs_compiled := ""
mut g_mem_til_compiled := ""

// tests.til - TIL test runner
// Runs compiled tests and compares output against .out files

// .out file format:
// args: <args>
// expected_status: <exit_code>
// output:
// <actual output>

// Test entry struct - explicit about path, args, and expected status
TestEntry := struct {
    mut path: Str = ""              // Path to the .til file
    mut cmd_args: Str = ""          // Command line arguments (empty string if none)
    mut expected_status: I64 = 0    // Expected exit status (0 for success)
}

// A phase describes one execution mode for test.til
TestPhase := struct {
    mut test_mode: Str = ""         // e.g. "rs_interpreted", "til_compiled"
    mut out_mode: Str = ""          // "interpreted" or "compiled" - which .out file to use
    mut label: Str = ""             // for display, e.g. "interpreted", "til compiled"
}

// Running test - tracks a test in progress for parallel execution
RunningTest := struct {
    mut pid: I64 = 0                // Current process ID
    mut entry: TestEntry = TestEntry()
    mut actual_file: Str = ""       // Unique actual output file path
    mut current_phase: I64 = 0      // Index into phases vec (0, 1, ...)
    mut phase_build_times: Vec = Vec.new(I64) // Build times for completed phases (0 for interpreted)
    mut phase_times: Vec = Vec.new(I64)    // Run times for completed phases
    mut phase_maxrss: Vec = Vec.new(I64)   // Max RSS (KB) for completed phases
    mut phase_mem_reports: Vec = Vec.new(Str)  // HeapState reports for completed phases
}

// Helper to add music.til tests to a Vec
// music.til: 14 tests covering all 7 modes, accidentals, languages, and notation
// All tests now show pentagram and triads by default
// Accidentals use suffix notation: sib (si flat), fax (fa sharp, x = #)
add_music_tests := proc(mut tests: Vec) {
    MUSIC_PATH := "src/examples/music.til"
    // 3 tests with default language (pt)
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="jonio do"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="dorico re"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="frigio mi"))
    // 3 tests with -lang=pt
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=pt lidio fax"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=pt mixolidio sol"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=pt eolio lab"))
    // 3 tests with -lang=en
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=en locrian six"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=en aeolian la"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=en ionian solx"))
    // 3 tests with -lang=es
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=es jonico mib"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=es locrio rex"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-lang=es eolico sib"))
    // 2 tests with -notation=american (input uses American notation: C, D, E, F, G, A, B)
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-notation=american ionian C"))
    tests.push(TestEntry(path=MUSIC_PATH, cmd_args="-notation=american phrygian G"))
}

// Parse wall-clock time from /usr/bin/time -v output
// Looks for "Elapsed (wall clock) time (h:mm:ss or m:ss): M:SS.SS"
// Format: m:ss.ss (under 1 hour) or h:mm:ss (over 1 hour)
// Returns milliseconds, or -1 if parsing fails
parse_time_ms := func(time_output: Str) returns I64 throws IndexOutOfBoundsError {
    lines := time_output.split("\n")?
    for line: Str in lines {
        if line.find("Elapsed (wall clock)").gt(I64_MINUS1) {
            // Extract value after last ": "
            parts := line.split(": ")?
            if parts.len().gt(1) {
                mut time_str := ""
                parts.get(parts.len().sub(1), time_str)?
                time_str = time_str.replace("\r", "")
                // Find first colon (separates minutes from seconds, or hours from minutes)
                colon_pos := time_str.find(":")
                if colon_pos.lt(0) {
                    return I64_MINUS1
                }
                dot_pos := time_str.find(".")
                if dot_pos.gt(0) {
                    // m:ss.ss format (under 1 hour)
                    min_str := get_substr(time_str, 0, colon_pos)?
                    sec_str := get_substr(time_str, colon_pos.add(1), dot_pos)?
                    frac_str := get_substr(time_str, dot_pos.add(1), time_str.len())?
                    // Pad or truncate frac to 3 digits for ms
                    mut frac := frac_str
                    while frac.len().lt(3) {
                        frac = frac.concat("0")
                    }
                    if frac.len().gt(3) {
                        frac = get_substr(frac, 0, 3)?
                    }
                    return min_str.to_i64().mul(60000).add(sec_str.to_i64().mul(1000)).add(frac.to_i64())
                } else {
                    // h:mm:ss format (over 1 hour, no fractional seconds)
                    after_first := get_substr(time_str, colon_pos.add(1), time_str.len())?
                    second_colon := after_first.find(":")
                    if second_colon.gt(0) {
                        hour_str := get_substr(time_str, 0, colon_pos)?
                        min_str := get_substr(after_first, 0, second_colon)?
                        sec_str := get_substr(after_first, second_colon.add(1), after_first.len())?
                        return hour_str.to_i64().mul(3600000).add(min_str.to_i64().mul(60000)).add(sec_str.to_i64().mul(1000))
                    }
                }
            }
        }
    }
    return I64_MINUS1
}

// Parse max RSS from /usr/bin/time -v output
// Looks for "Maximum resident set size (kbytes): N"
// Returns kilobytes, or -1 if parsing fails
parse_maxrss_kb := func(time_output: Str) returns I64 throws IndexOutOfBoundsError {
    lines := time_output.split("\n")?
    for line: Str in lines {
        if line.find("Maximum resident set size").gt(I64_MINUS1) {
            parts := line.split(": ")?
            if parts.len().gt(1) {
                mut val_str := ""
                parts.get(parts.len().sub(1), val_str)?
                val_str = val_str.replace("\r", "")
                return val_str.to_i64()
            }
        }
    }
    return I64_MINUS1
}

// Format kilobytes as human-readable MB string
format_maxrss := func(kb: I64) returns Str {
    if kb.lt(0) {
        return "N/A"
    }
    mb := kb.div(1024)
    return mb.to_str().concat("MB")
}

// Run a command with timing, returns exit code and stores time/maxrss
// Output goes to mut output param, time goes to mut time_ms param
// Linux: /usr/bin/time -v for wall-clock time and max RSS
// macOS: bash builtin time with TIMEFORMAT for wall-clock time (no RSS)
run_timed := proc(mut output: Str, mut time_ms: I64, mut maxrss_kb: I64, cmd: Str) returns I64 {
    // Build wrapped command based on OS
    mut wrapped := ""
    if g_is_linux {
        wrapped = format("LC_ALL=C /usr/bin/time -v bash -c '", cmd, "' 2>&1")
    } else {
        // Group braces + 2>&1 needed so bash time stderr output gets captured
        wrapped = format("{ TIMEFORMAT=%3R; time bash -c '", cmd, "'; } 2>&1")
    }
    mut full_output := ""
    exit_code := full_output.run_cmd("bash", "-c", wrapped)

    if g_is_linux {
        // Linux: parse GNU time output using markers
        // Truncate huge outputs (e.g., gcc errors) to prevent hangs
        max_output := 2000
        mut truncated := full_output
        if truncated.len().gt(max_output) {
            start_pos := truncated.len().sub(max_output)
            truncated = get_substr(truncated, start_pos, truncated.len())?
        }

        time_pos := truncated.find("Command being timed")
        exit_pos := truncated.find("Command exited with non-zero")

        mut output_split := time_pos
        mut backup := 1  // back up past \t before "Command being timed"
        if exit_pos.gt(I64_MINUS1) {
            if output_split.lt(0).or(exit_pos.lt(output_split)) {
                output_split = exit_pos
                backup = 0  // "Command exited" has no \t prefix, just \n before it
            }
        }

        if output_split.gt(I64_MINUS1) {
            mut output_end_in_truncated := output_split.sub(backup)
            if output_end_in_truncated.lt(0) {
                output_end_in_truncated = 0
            }
            output_end_in_full := full_output.len().sub(truncated.len()).add(output_end_in_truncated)
            if output_end_in_full.gt(0) {
                output = get_substr(full_output, 0, output_end_in_full)?
            } else {
                output = ""
            }
            if time_pos.gt(I64_MINUS1) {
                time_output := get_substr(truncated, time_pos, truncated.len())?
                time_ms = parse_time_ms(time_output)?
                maxrss_kb = parse_maxrss_kb(time_output)?
            }
        } else {
            output = full_output
            time_ms = I64_MINUS1
            maxrss_kb = I64_MINUS1
        }
    } else {
        // macOS: last line is time value (e.g., "0.042"), no RSS available
        maxrss_kb = I64_MINUS1
        // Strip trailing newline
        mut trimmed := full_output
        if trimmed.len().gt(0) {
            if trimmed.get_char(trimmed.len().sub(1))?.eq("\n") {
                trimmed = get_substr(trimmed, 0, trimmed.len().sub(1))?
            }
        }
        // Find last newline by scanning from end
        mut last_nl := I64_MINUS1
        mut ci := trimmed.len().sub(1)
        while ci.gt(I64_MINUS1) {
            if trimmed.get_char(ci)?.eq("\n") {
                last_nl = ci
                break
            }
            ci = ci.sub(1)
        }
        if last_nl.gt(I64_MINUS1) {
            output = get_substr(full_output, 0, last_nl.add(1))?
            time_line := get_substr(trimmed, last_nl.add(1), trimmed.len())?.replace("\r", "")
            // Parse "N.NNN" as milliseconds
            dot_pos := time_line.find(".")
            if dot_pos.gt(I64_MINUS1) {
                sec_str := get_substr(time_line, 0, dot_pos)?
                frac_str := get_substr(time_line, dot_pos.add(1), time_line.len())?
                mut frac := frac_str
                while frac.len().lt(3) {
                    frac = frac.concat("0")
                }
                if frac.len().gt(3) {
                    frac = get_substr(frac, 0, 3)?
                }
                time_ms = sec_str.to_i64().mul(1000).add(frac.to_i64())
            } else {
                time_ms = I64_MINUS1
            }
        } else {
            // No newline found - no program output, just time (or can't parse)
            output = ""
            time_ms = I64_MINUS1
        }
    }

    catch (err: IndexOutOfBoundsError) {
        output = full_output
        time_ms = I64_MINUS1
        maxrss_kb = I64_MINUS1
    }

    return exit_code
}

// Format milliseconds as "0.042s"
format_time := func(ms: I64) returns Str {
    if ms.lt(0) {
        return "N/A"
    }
    secs := ms.div(1000)
    millis := ms.mod(1000)
    mut millis_str := millis.to_str()
    while millis_str.len().lt(3) {
        millis_str = concat("0", millis_str)
    }
    return secs.to_str().concat(".").concat(millis_str).concat("s")
}

// Path transform: src/examples/foo.til -> gen/out/examples/foo.interpreted.out
// test_mode: "interpreted" or "compiled"
// cmd_args: "" for default, "help" for .help.out, etc.
get_out_path := func(src_path: Str, test_mode: Str, cmd_args: Str) returns Str {
    base := src_path.replace(".til", "").replace("src/", "gen/out/")
    mut suffix := ""
    if not(cmd_args.eq("")) {
        // Replace spaces with dots for filename: "help foo" -> ".help.foo"
        suffix = concat(".", cmd_args.replace(" ", "."))
    }
    return base.concat(suffix).concat(".").concat(test_mode).concat(".out")
}

// Format output file content
format_expected := func(cmd_args: Str, exit_code: I64, output: Str) returns Str {
    mut result := "args: "
    result = result.concat(cmd_args).concat("\n")
    result = result.concat("expected_status: ").concat(exit_code.to_str()).concat("\n")
    result = result.concat("output:\n")
    result = result.concat(output)
    return result
}

// Unified test function - runs a test with given command prefix
// cmd_prefix: "./bin/rstil interpret ", "./bin/rstil run ", etc.
// fail_label: label for error messages (e.g., "interpret", "run", "til interpret", "til run")?
// out_mode: "interpreted" or "compiled" - determines which .out file to compare against
test_with_cmd := proc(entry: TestEntry, cmd_prefix: Str, fail_label: Str, out_mode: Str, mut time_ms: I64) returns Bool {
    out_path := get_out_path(entry.path, out_mode, entry.cmd_args)

    mut output := ""
    mut run_time := 0
    mut run_maxrss := 0
    mut cmd := cmd_prefix
    cmd = cmd.concat(entry.path)
    // Only add --mem-report for compiled modes with expected_status=0
    // Error-status tests fail at compile time, no HeapState data to collect
    if g_mem_report.and(cmd_prefix.find(" run ").gt(I64_MINUS1)).and(entry.expected_status.eq(0)) {
        cmd = cmd.concat(" --mem-report")
    }
    if not(entry.cmd_args.eq("")) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    actual_exit_code := run_timed(output, run_time, run_maxrss, cmd)
    time_ms = run_time

    // Strip HEAP_STATE report line from output
    heap_pos := output.find("\nHEAP_STATE:")
    if heap_pos.gt(I64_MINUS1) {
        output = get_substr(output, 0, heap_pos.add(1))?
    } else if output.starts_with("HEAP_STATE:") {
        output = ""
    }

    // Check exit code
    if not(actual_exit_code.eq(entry.expected_status)) {
        println("FAIL (", fail_label, " exit code): ", entry.path)
        println("  expected: ", entry.expected_status.to_str())
        println("  actual: ", actual_exit_code.to_str())
        if not(output.eq("")) {
            println("  output: ", output)
        }
        return true
    }

    // Check output via diff
    tmp_actual := "gen/out/actual.out"
    actual_content := format_expected(entry.cmd_args, actual_exit_code, output)
    writefile(tmp_actual, actual_content)?
    mut diff_u_result := ""
    _ := diff_u_result.run_cmd("diff", "-u", out_path, tmp_actual)
    mut rm_result := ""
    _ := rm_result.run_cmd("rm", tmp_actual)
    if not(diff_u_result.eq("")) {
        println("FAIL (", fail_label, " output): ", entry.path)
        println(diff_u_result)
        return true
    }

    return false

    catch (err: WriteError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

// Wrapper functions
test_rs_interpreted := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil interpret ", "rstil interpret", "interpreted", time_ms)
}

test_rs_compiled := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    return test_with_cmd(entry, "./bin/rstil run ", "rstil run", "compiled", time_ms)
}

test_til_interpreted := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    // Bug #141: Use bin/rs/til (til built by rstil)
    return test_with_cmd(entry, "./bin/rs/til interpret ", "til interpret", "interpreted", time_ms)
}

test_til_compiled := proc(entry: TestEntry, mut time_ms: I64) returns Bool {
    // Bug #141: Use bin/rs/til (til built by rstil)
    return test_with_cmd(entry, "./bin/rs/til run ", "til run", "compiled", time_ms)
}

// ============ Parallel execution ============

// Kill all running test processes and panic
kill_running_and_panic := proc(running: Vec, msg: Str) {
    for rt: RunningTest in running {
        if rt.pid.gt(0) {
            mut output := ""
            _ := output.run_cmd("kill", "-9", rt.pid.to_str())
        }
    }
    panic(loc(), msg)
}

// Generate unique actual output file path for test.til
// path: src/test/foo.til -> gen/out/test/foo
// mode: rs_interpreted, til_compiled, etc.
// args: "help" -> ".help", "help foo" -> ".help_foo", "" -> ""
get_actual_path := func(path: Str, test_mode: Str, cmd_args: Str) returns Str {
    base := path.replace(".til", "").replace("src/", "gen/out/")
    mut args_part := ""
    if cmd_args.len().gt(0) {
        args_part = concat(".", cmd_args.replace(" ", "_"))
    }
    return format(base, ".", test_mode, args_part, ".actual.out")
}

// Spawn a test using test.til
// test.til handles: run command, compare output, report result
// Output is redirected to a result file for later reading
spawn_test := proc(entry: TestEntry, phase: TestPhase, test_id: I64) returns RunningTest throws SpawnError {
    // Build command: ./bin/rs/test_runner test <mode> <out_mode> <expected_status> <file> [args...]
    // Issue #131: Pass --cc flag to test_runner
    mut cc_flag := ""
    if not(g_cc.is_empty()) {
        cc_flag = concat(" --cc=", g_cc)
    }
    // Don't pass --mem-report to test_runner itself (flag file handles detection)
    // Passing it would enable HeapState in test_runner's C runtime, adding noise
    mut cmd := format("./bin/rs/test_runner test ", phase.test_mode, " ", phase.out_mode, " ", entry.expected_status.to_str(), " ", entry.path, cc_flag)
    if entry.cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }

    // Redirect output to a unique result file
    result_file := format("tmp/test_result_", test_id.to_str(), ".txt")
    cmd = format(cmd, " > ", result_file, " 2>&1")

    pid := spawn_cmd(cmd)?

    mut rt := RunningTest(pid=pid, entry=entry, actual_file=result_file, current_phase=0)
    rt.phase_build_times = Vec.new(I64)
    rt.phase_times = Vec.new(I64)
    rt.phase_maxrss = Vec.new(I64)
    rt.phase_mem_reports = Vec.new(Str)
    return rt
}

// Parse test_runner result file
// On success: "PASS <build_ms> <run_ms> <maxrss_kb> [mem_report_line]"
// On failure: error output (and exit code was non-zero)
// Returns true if passed, false if failed
parse_test_result := proc(result_file: Str, exit_status: I64, mut build_ms: I64, mut time_ms: I64, mut maxrss_kb: I64, mut error_output: Str, mut mem_report_line: Str) returns Bool throws IndexOutOfBoundsError, ReadError {
    output := readfile(result_file)?

    if exit_status.eq(0) {
        // Success - parse "PASS <build_ms> <run_ms> <maxrss_kb> [mem_report_line]"
        if output.starts_with("PASS ") {
            rest := get_substr(output, 5, output.len())?.replace("\n", "")
            // Parse build_ms
            sp1 := rest.find(" ")
            if sp1.gt(0) {
                build_str := get_substr(rest, 0, sp1)?
                build_ms = build_str.to_i64()
                rest2 := get_substr(rest, sp1.add(1), rest.len())?
                // Parse run_ms
                sp2 := rest2.find(" ")
                if sp2.gt(0) {
                    time_str := get_substr(rest2, 0, sp2)?
                    time_ms = time_str.to_i64()
                    rss_str := get_substr(rest2, sp2.add(1), rest2.len())?
                    // rss_str may contain "456 HEAP_STATE:..."
                    sp3 := rss_str.find(" ")
                    if sp3.gt(0) {
                        actual_rss := get_substr(rss_str, 0, sp3)?
                        mem_report_line = get_substr(rss_str, sp3.add(1), rss_str.len())?
                        maxrss_kb = actual_rss.to_i64()
                    } else {
                        maxrss_kb = rss_str.to_i64()
                    }
                } else {
                    time_ms = rest2.to_i64()
                    maxrss_kb = 0
                }
            } else {
                build_ms = 0
                time_ms = rest.to_i64()
                maxrss_kb = 0
            }
        } else {
            build_ms = 0
            time_ms = 0
            maxrss_kb = 0
        }
        return true
    } else {
        // Failure - output contains error message
        error_output = output
        build_ms = 0
        time_ms = 0
        maxrss_kb = 0
        return false
    }
}

// Unified parallel test runner
// phases: Vec of TestPhase (1 for single-mode, 2 for common tests)
// phase_totals: mut Vec of I64, one per phase for accumulating times
// phase_maxrss_maxes: mut Vec of I64, one per phase for tracking max RSS (keeps highest)
run_parallel := proc(tests: Vec, phases: Vec, parallelism: I64, mut phase_build_totals: Vec, mut phase_totals: Vec, mut phase_maxrss_maxes: Vec, mut benchmark_content: Str, section_name: Str) returns I64 {
    // Ensure tmp directory exists for result files
    mut mkdir_out := ""
    _ := mkdir_out.run_cmd("mkdir", "-p", "tmp")

    // Build step moved to test_runner.til - each test builds its own binary
    // via rstil/til build (with smart needs_rebuild staleness detection)

    mut errors := 0
    mut pending_idx := 0
    mut running := Vec.new(RunningTest)
    mut next_id := 0
    mut completed_count := 0
    num_phases := phases.len()

    // Start initial batch
    while running.len().lt(parallelism) {
        if pending_idx.lt(tests.len()) {
            mut entry := TestEntry()
            tests.get(pending_idx, entry)?
            mut phase := TestPhase()
            phases.get(0, phase)?
            rt := spawn_test(entry, phase, next_id)?
            running.push(rt)
            pending_idx.inc()
            next_id.inc()
        } else {
            break
        }
    }

    // Poll loop
    while running.len().gt(0) {
        mut i := 0
        while i.lt(running.len()) {
            mut current := RunningTest()
            running.get(i, current)?

            status := check_cmd_status(current.pid)
            if not(status.eq(I64_MINUS1)) {
                // Phase finished - parse result from test.til
                mut current_phase := TestPhase()
                phases.get(current.current_phase, current_phase)?

                mut build_ms := 0
                mut time_ms := 0
                mut maxrss_kb := 0
                mut error_output := ""
                mut mem_report_line := ""
                passed := parse_test_result(current.actual_file, status, build_ms, time_ms, maxrss_kb, error_output, mem_report_line)?

                // Record build time, run time, maxrss, and mem report for this phase
                current.phase_build_times.push(build_ms.clone())
                current.phase_times.push(time_ms.clone())
                current.phase_maxrss.push(maxrss_kb.clone())
                current.phase_mem_reports.push(mem_report_line)

                // Accumulate to phase total (time: sum, build: sum, maxrss: keep max)
                mut old_build := 0
                phase_build_totals.get(current.current_phase, old_build)?
                phase_build_totals.set(current.current_phase, old_build.add(build_ms))?
                mut old_total := 0
                phase_totals.get(current.current_phase, old_total)?
                phase_totals.set(current.current_phase, old_total.add(time_ms))?
                mut old_maxrss := 0
                phase_maxrss_maxes.get(current.current_phase, old_maxrss)?
                if maxrss_kb.gt(old_maxrss) {
                    phase_maxrss_maxes.set(current.current_phase, maxrss_kb)?
                }

                if not(passed) {
                    // Phase failed - test.til already printed details
                    errors.inc()
                    println(error_output)
                    completed_count.inc()
                    println("[", completed_count.to_str(), "/", tests.len().to_str(), "] ", current.entry.path, " - FAILED (", current_phase.label, ")")

                    // Remove from running
                    last_idx := running.len().sub(1)
                    if i.lt(last_idx) {
                        mut last := RunningTest()
                        running.get(last_idx, last)?
                        running.set(i, last)?
                    }
                    mut popped := RunningTest()
                    running.pop(popped)?

                    // Start next test
                    if pending_idx.lt(tests.len()) {
                        mut fail_next_entry := TestEntry()
                        tests.get(pending_idx, fail_next_entry)?
                        mut fail_first_phase := TestPhase()
                        phases.get(0, fail_first_phase)?
                        fail_rt := spawn_test(fail_next_entry, fail_first_phase, next_id)?
                        running.push(fail_rt)
                        pending_idx.inc()
                        next_id.inc()
                    }
                } else {
                    // Phase passed
                    next_phase_idx := current.current_phase.add(1)
                    if next_phase_idx.lt(num_phases) {
                        // More phases to run - spawn next with test_runner
                        mut next_phase := TestPhase()
                        phases.get(next_phase_idx, next_phase)?

                        // Issue #131: Pass --cc flag to test_runner
                        mut cc_flag := ""
                        if not(g_cc.is_empty()) {
                            cc_flag = concat(" --cc=", g_cc)
                        }
                        // Don't pass --mem-report to test_runner (flag file handles detection)
                        mut cmd := format("./bin/rs/test_runner test ", next_phase.test_mode, " ", next_phase.out_mode, " ", current.entry.expected_status.to_str(), " ", current.entry.path, cc_flag)
                        if current.entry.cmd_args.len().gt(0) {
                            cmd = cmd.concat(" ").concat(current.entry.cmd_args)
                        }
                        new_result := format("tmp/test_result_", next_id.to_str(), ".txt")
                        cmd = format(cmd, " > ", new_result, " 2>&1")
                        new_pid := spawn_cmd(cmd)?
                        next_id.inc()

                        current.pid = new_pid
                        current.actual_file = new_result
                        current.current_phase = next_phase_idx
                        running.set(i, current)?
                        i.inc()
                    } else {
                        // All phases complete - print result
                        completed_count.inc()

                        mut args_display := ""
                        if not(current.entry.cmd_args.eq("")) {
                            args_display = concat(" ", current.entry.cmd_args)
                        }

                        // Build timing string (includes memory)
                        mut timing_str := ""
                        // CSV columns
                        mut csv_rs_interp_ms := ""
                        mut csv_rs_interp_kb := ""
                        mut csv_rs_built_ms := ""
                        mut csv_rs_comp_ms := ""
                        mut csv_rs_comp_kb := ""
                        mut csv_til_interp_ms := ""
                        mut csv_til_interp_kb := ""
                        mut csv_til_built_ms := ""
                        mut csv_til_comp_ms := ""
                        mut csv_til_comp_kb := ""
                        for p_idx in 0..num_phases {
                            mut p := TestPhase()
                            phases.get(p_idx, p)?
                            mut bt := 0
                            mut t := 0
                            mut rss := 0
                            current.phase_build_times.get(p_idx, bt)?
                            current.phase_times.get(p_idx, t)?
                            current.phase_maxrss.get(p_idx, rss)?
                            if p_idx.gt(0) {
                                timing_str = timing_str.concat(", ")
                            }
                            timing_str = timing_str.concat(p.label).concat(": ").concat(format_time(t)).concat(" ").concat(format_maxrss(rss))
                            // Map to CSV columns by test_mode
                            if p.test_mode.eq("rs_interpreted") {
                                csv_rs_interp_ms = t.to_str()
                                csv_rs_interp_kb = rss.to_str()
                            } else if p.test_mode.eq("rs_compiled") {
                                csv_rs_built_ms = bt.to_str()
                                csv_rs_comp_ms = t.to_str()
                                csv_rs_comp_kb = rss.to_str()
                            } else if p.test_mode.eq("til_interpreted") {
                                csv_til_interp_ms = t.to_str()
                                csv_til_interp_kb = rss.to_str()
                            } else if p.test_mode.eq("til_compiled") {
                                csv_til_built_ms = bt.to_str()
                                csv_til_comp_ms = t.to_str()
                                csv_til_comp_kb = rss.to_str()
                            }
                        }

                        // For 2-phase tests, add "faster" annotation
                        mut faster := ""
                        if num_phases.eq(2) {
                            mut t0 := 0
                            mut t1 := 0
                            current.phase_times.get(0, t0)?
                            current.phase_times.get(1, t1)?
                            if t0.lt(t1) {
                                mut p0 := TestPhase()
                                phases.get(0, p0)?
                                faster = format(" (faster ", p0.label, ")")
                            } else {
                                if t1.lt(t0) {
                                    mut p1 := TestPhase()
                                    phases.get(1, p1)?
                                    faster = format(" (faster ", p1.label, ")")
                                }
                            }
                        }
                        // For 4-phase tests (all_common: rs_interpreted, rs_compiled, til_interpreted, til_compiled)
                        if num_phases.eq(4) {
                            mut rs_interp := 0  // rs_interpreted
                            mut rs_comp := 0    // rs_compiled
                            mut til_interp := 0 // til_interpreted
                            mut til_comp := 0   // til_compiled
                            current.phase_times.get(0, rs_interp)?
                            current.phase_times.get(1, rs_comp)?
                            current.phase_times.get(2, til_interp)?
                            current.phase_times.get(3, til_comp)?
                            // Compare rstil modes: interpreted vs compiled
                            mut rstil_faster := ""
                            if rs_interp.lt(rs_comp) {
                                rstil_faster = "interpreted"
                            } else if rs_comp.lt(rs_interp) {
                                rstil_faster = "compiled"
                            }
                            // Compare interpreted: rstil vs til
                            mut interp_faster := ""
                            if rs_interp.lt(til_interp) {
                                interp_faster = "rstil"
                            } else if til_interp.lt(rs_interp) {
                                interp_faster = "til"
                            }
                            // Compare compiled: rstil vs til
                            mut compiled_faster := ""
                            if rs_comp.lt(til_comp) {
                                compiled_faster = "rstil"
                            } else if til_comp.lt(rs_comp) {
                                compiled_faster = "til"
                            }
                            // Build annotation
                            mut parts := Vec.new(Str)
                            if rstil_faster.len().gt(0) {
                                parts.push(format("rstil: faster ", rstil_faster))
                            }
                            if interp_faster.len().gt(0) {
                                parts.push(format("interpreted: faster ", interp_faster))
                            }
                            if compiled_faster.len().gt(0) {
                                parts.push(format("compiled: faster ", compiled_faster))
                            }
                            if parts.len().gt(0) {
                                faster = " ("
                                mut pi := 0
                                while pi.lt(parts.len()) {
                                    if pi.gt(0) {
                                        faster = faster.concat(", ")
                                    }
                                    mut part := ""
                                    parts.get(pi, part)?
                                    faster = faster.concat(part)
                                    pi.inc()
                                }
                                faster = faster.concat(")")
                            }
                        }

                        println("[", completed_count.to_str(), "/", tests.len().to_str(), "] ", current.entry.path, args_display, " (", timing_str, ")", faster)
                        // CSV row: test,args,section,rs_interp_ms,rs_interp_kb,rs_comp_ms,rs_comp_kb,til_interp_ms,til_interp_kb,til_comp_ms,til_comp_kb
                        csv_row := format(current.entry.path, ",", current.entry.cmd_args, ",", section_name, ",", csv_rs_interp_ms, ",", csv_rs_interp_kb, ",", csv_rs_built_ms, ",", csv_rs_comp_ms, ",", csv_rs_comp_kb, ",", csv_til_interp_ms, ",", csv_til_interp_kb, ",", csv_til_built_ms, ",", csv_til_comp_ms, ",", csv_til_comp_kb, "\n")
                        benchmark_content = benchmark_content.concat(csv_row)

                        // Accumulate mem reports to globals
                        if g_mem_report {
                            for p_idx2 in 0..num_phases {
                                mut p2 := TestPhase()
                                phases.get(p_idx2, p2)?
                                mut mem_line := ""
                                current.phase_mem_reports.get(p_idx2, mem_line)?
                                if mem_line.len().gt(0) {
                                    mut entry_line := concat("- ", current.entry.path)
                                    if current.entry.cmd_args.len().gt(0) {
                                        entry_line = entry_line.concat(" ").concat(current.entry.cmd_args)
                                    }
                                    entry_line = entry_line.concat(" :: ").concat(mem_line).concat("\n")
                                    if p2.test_mode.eq("rs_compiled") {
                                        g_mem_rs_compiled = g_mem_rs_compiled.concat(entry_line)
                                    } else if p2.test_mode.eq("til_compiled") {
                                        g_mem_til_compiled = g_mem_til_compiled.concat(entry_line)
                                    }
                                }
                            }
                        }

                        // Remove from running
                        success_last_idx := running.len().sub(1)
                        if i.lt(success_last_idx) {
                            mut success_last := RunningTest()
                            running.get(success_last_idx, success_last)?
                            running.set(i, success_last)?
                        }
                        mut success_popped := RunningTest()
                        running.pop(success_popped)?

                        // Start next test
                        if pending_idx.lt(tests.len()) {
                            mut next_entry := TestEntry()
                            tests.get(pending_idx, next_entry)?
                            mut next_first_phase := TestPhase()
                            phases.get(0, next_first_phase)?
                            next_rt := spawn_test(next_entry, next_first_phase, next_id)?
                            running.push(next_rt)
                            pending_idx.inc()
                            next_id.inc()
                        }
                    }
                }
            } else {
                i.inc()
            }
        }

        if running.len().gt(0) {
            sleep(10)?
        }
    }

    catch (err: SpawnError) { kill_running_and_panic(running, err.msg) }
    catch (err: SleepError) { kill_running_and_panic(running, err.msg) }
    catch (err: IndexOutOfBoundsError) { kill_running_and_panic(running, err.msg) }
    catch (err: ReadError) { kill_running_and_panic(running, err.msg) }

    return errors
}

// ============ End parallel execution ============

run_all_tests := proc(rs_interpreted: Vec, rs_compiled: Vec, rs_common: Vec, til_interpreted: Vec, til_compiled: Vec, til_common: Vec, all_common: Vec, parallelism: I64, start_epoch: I64) {
    mut errors_found := 0
    total_tests := til_interpreted.len().add(til_compiled.len()).add(til_common.len()).add(rs_interpreted.len()).add(rs_compiled.len()).add(rs_common.len()).add(all_common.len())
    mut benchmark_content := "test,args,section,rs_interp_ms,rs_interp_kb,rs_built_ms,rs_comp_ms,rs_comp_kb,til_interp_ms,til_interp_kb,til_built_ms,til_comp_ms,til_comp_kb\n"

    // rs_interpreted
    mut rs_interp_build_totals := Vec.new(I64)
    rs_interp_build_totals.push(0)
    mut rs_interp_totals := Vec.new(I64)
    rs_interp_totals.push(0)
    mut rs_interp_maxrss := Vec.new(I64)
    rs_interp_maxrss.push(0)
    if rs_interpreted.len().gt(0) {
        println("\n=== rs_interpreted (", rs_interpreted.len().to_str(), " tests) ===\n")
        mut rs_interp_phases := Vec.new(TestPhase)
        rs_interp_phases.push(TestPhase(test_mode="rs_interpreted", out_mode="rs_interpreted", label="interpreted"))
        errors_found = errors_found.add(run_parallel(rs_interpreted, rs_interp_phases, parallelism, rs_interp_build_totals, rs_interp_totals, rs_interp_maxrss, benchmark_content, "rs_interpreted"))
    }

    // rs_compiled
    mut rs_compile_build_totals := Vec.new(I64)
    rs_compile_build_totals.push(0)
    mut rs_compile_totals := Vec.new(I64)
    rs_compile_totals.push(0)
    mut rs_compile_maxrss := Vec.new(I64)
    rs_compile_maxrss.push(0)
    if rs_compiled.len().gt(0) {
        println("\n=== rs_compiled (", rs_compiled.len().to_str(), " tests) ===\n")
        mut rs_compile_phases := Vec.new(TestPhase)
        rs_compile_phases.push(TestPhase(test_mode="rs_compiled", out_mode="rs_compiled", label="compiled"))
        errors_found = errors_found.add(run_parallel(rs_compiled, rs_compile_phases, parallelism, rs_compile_build_totals, rs_compile_totals, rs_compile_maxrss, benchmark_content, "rs_compiled"))
    }

    // rs_common (both modes per test)
    mut rs_common_build_totals := Vec.new(I64)
    rs_common_build_totals.push(0)
    rs_common_build_totals.push(0)
    mut rs_common_totals := Vec.new(I64)
    rs_common_totals.push(0)
    rs_common_totals.push(0)
    mut rs_common_maxrss := Vec.new(I64)
    rs_common_maxrss.push(0)
    rs_common_maxrss.push(0)
    if rs_common.len().gt(0) {
        println("\n=== rs_common (", rs_common.len().to_str(), " tests) ===\n")
        mut rs_common_phases := Vec.new(TestPhase)
        rs_common_phases.push(TestPhase(test_mode="rs_interpreted", out_mode="rs_interpreted", label="interpreted"))
        rs_common_phases.push(TestPhase(test_mode="rs_compiled", out_mode="rs_interpreted", label="compiled"))
        errors_found = errors_found.add(run_parallel(rs_common, rs_common_phases, parallelism, rs_common_build_totals, rs_common_totals, rs_common_maxrss, benchmark_content, "rs_common"))
    }

    // til_interpreted
    mut til_interp_build_totals := Vec.new(I64)
    til_interp_build_totals.push(0)
    mut til_interp_totals := Vec.new(I64)
    til_interp_totals.push(0)
    mut til_interp_maxrss := Vec.new(I64)
    til_interp_maxrss.push(0)
    if til_interpreted.len().gt(0).and(not(g_rust_only)) {
        println("\n=== til_interpreted (", til_interpreted.len().to_str(), " tests) ===\n")
        mut til_interp_phases := Vec.new(TestPhase)
        til_interp_phases.push(TestPhase(test_mode="til_interpreted", out_mode="til_interpreted", label="til interpreted"))
        errors_found = errors_found.add(run_parallel(til_interpreted, til_interp_phases, parallelism, til_interp_build_totals, til_interp_totals, til_interp_maxrss, benchmark_content, "til_interpreted"))
    }

    // til_compiled
    mut til_compile_build_totals := Vec.new(I64)
    til_compile_build_totals.push(0)
    mut til_compile_totals := Vec.new(I64)
    til_compile_totals.push(0)
    mut til_compile_maxrss := Vec.new(I64)
    til_compile_maxrss.push(0)
    if til_compiled.len().gt(0).and(not(g_rust_only)) {
        println("\n=== til_compiled (", til_compiled.len().to_str(), " tests) ===\n")
        mut til_compile_phases := Vec.new(TestPhase)
        til_compile_phases.push(TestPhase(test_mode="til_compiled", out_mode="til_compiled", label="til compiled"))
        errors_found = errors_found.add(run_parallel(til_compiled, til_compile_phases, parallelism, til_compile_build_totals, til_compile_totals, til_compile_maxrss, benchmark_content, "til_compiled"))
    }

    // til_common (both modes per test)
    mut til_common_build_totals := Vec.new(I64)
    til_common_build_totals.push(0)
    til_common_build_totals.push(0)
    mut til_common_totals := Vec.new(I64)
    til_common_totals.push(0)
    til_common_totals.push(0)
    mut til_common_maxrss := Vec.new(I64)
    til_common_maxrss.push(0)
    til_common_maxrss.push(0)
    if til_common.len().gt(0).and(not(g_rust_only)) {
        println("\n=== til_common (", til_common.len().to_str(), " tests) ===\n")
        mut til_common_phases := Vec.new(TestPhase)
        til_common_phases.push(TestPhase(test_mode="til_interpreted", out_mode="til_interpreted", label="til interpreted"))
        til_common_phases.push(TestPhase(test_mode="til_compiled", out_mode="til_interpreted", label="til compiled"))
        errors_found = errors_found.add(run_parallel(til_common, til_common_phases, parallelism, til_common_build_totals, til_common_totals, til_common_maxrss, benchmark_content, "til_common"))
    }

    // all_common (4 modes: rs_interpreted, rs_compiled, til_interpreted, til_compiled)
    // When --rust-only: run as rs_common (2 phases) instead of all 4
    mut all_common_build_totals := Vec.new(I64)
    all_common_build_totals.push(0)
    all_common_build_totals.push(0)
    mut all_common_totals := Vec.new(I64)
    all_common_totals.push(0)
    all_common_totals.push(0)
    mut all_common_maxrss := Vec.new(I64)
    all_common_maxrss.push(0)
    all_common_maxrss.push(0)
    if not(g_rust_only) {
        all_common_build_totals.push(0)
        all_common_build_totals.push(0)
        all_common_totals.push(0)
        all_common_totals.push(0)
        all_common_maxrss.push(0)
        all_common_maxrss.push(0)
    }
    if all_common.len().gt(0) {
        if g_rust_only {
            // Run as rs_common (2 phases)
            println("\n=== all_common [rust-only] (", all_common.len().to_str(), " tests) ===\n")
            mut rs_only_phases := Vec.new(TestPhase)
            rs_only_phases.push(TestPhase(test_mode="rs_interpreted", out_mode="rs_interpreted", label="interpreted"))
            rs_only_phases.push(TestPhase(test_mode="rs_compiled", out_mode="rs_interpreted", label="compiled"))
            errors_found = errors_found.add(run_parallel(all_common, rs_only_phases, parallelism, all_common_build_totals, all_common_totals, all_common_maxrss, benchmark_content, "all_common"))
        } else {
            println("\n=== all_common (", all_common.len().to_str(), " tests) ===\n")
            mut all_common_phases := Vec.new(TestPhase)
            all_common_phases.push(TestPhase(test_mode="rs_interpreted", out_mode="rs_interpreted", label="rs interpreted"))
            all_common_phases.push(TestPhase(test_mode="rs_compiled", out_mode="rs_interpreted", label="rs compiled"))
            all_common_phases.push(TestPhase(test_mode="til_interpreted", out_mode="rs_interpreted", label="til interpreted"))
            all_common_phases.push(TestPhase(test_mode="til_compiled", out_mode="rs_interpreted", label="til compiled"))
            errors_found = errors_found.add(run_parallel(all_common, all_common_phases, parallelism, all_common_build_totals, all_common_totals, all_common_maxrss, benchmark_content, "all_common"))
        }
    }

    // Compute totals (only for non-empty categories)
    // Time totals (sum across tests)
    mut total_rs_interp := 0
    mut total_rs_built := 0
    mut total_rs_compile := 0
    mut total_til_interp := 0
    mut total_til_built := 0
    mut total_til_compile := 0
    // Max RSS totals (max across all sections per mode)
    mut maxrss_rs_interp := 0
    mut maxrss_rs_compile := 0
    mut maxrss_til_interp := 0
    mut maxrss_til_compile := 0

    if rs_interpreted.len().gt(0) {
        rs_interp_totals.get(0, total_rs_interp)?
        mut rss := 0
        rs_interp_maxrss.get(0, rss)?
        if rss.gt(maxrss_rs_interp) { maxrss_rs_interp = rss }
    }
    if rs_compiled.len().gt(0) {
        mut bt := 0
        rs_compile_build_totals.get(0, bt)?
        total_rs_built = total_rs_built.add(bt)
        rs_compile_totals.get(0, total_rs_compile)?
        mut rss := 0
        rs_compile_maxrss.get(0, rss)?
        if rss.gt(maxrss_rs_compile) { maxrss_rs_compile = rss }
    }
    if rs_common.len().gt(0) {
        mut rs_common_interp := 0
        mut rs_common_compile := 0
        rs_common_totals.get(0, rs_common_interp)?
        rs_common_totals.get(1, rs_common_compile)?
        total_rs_interp = total_rs_interp.add(rs_common_interp)
        total_rs_compile = total_rs_compile.add(rs_common_compile)
        mut bt := 0
        rs_common_build_totals.get(1, bt)?
        total_rs_built = total_rs_built.add(bt)
        mut rss0 := 0
        mut rss1 := 0
        rs_common_maxrss.get(0, rss0)?
        rs_common_maxrss.get(1, rss1)?
        if rss0.gt(maxrss_rs_interp) { maxrss_rs_interp = rss0 }
        if rss1.gt(maxrss_rs_compile) { maxrss_rs_compile = rss1 }
    }
    if til_interpreted.len().gt(0) {
        til_interp_totals.get(0, total_til_interp)?
        mut rss := 0
        til_interp_maxrss.get(0, rss)?
        if rss.gt(maxrss_til_interp) { maxrss_til_interp = rss }
    }
    if til_compiled.len().gt(0) {
        mut bt := 0
        til_compile_build_totals.get(0, bt)?
        total_til_built = total_til_built.add(bt)
        til_compile_totals.get(0, total_til_compile)?
        mut rss := 0
        til_compile_maxrss.get(0, rss)?
        if rss.gt(maxrss_til_compile) { maxrss_til_compile = rss }
    }
    if til_common.len().gt(0) {
        mut til_common_interp := 0
        mut til_common_compile := 0
        til_common_totals.get(0, til_common_interp)?
        til_common_totals.get(1, til_common_compile)?
        total_til_interp = total_til_interp.add(til_common_interp)
        total_til_compile = total_til_compile.add(til_common_compile)
        mut bt := 0
        til_common_build_totals.get(1, bt)?
        total_til_built = total_til_built.add(bt)
        mut rss0 := 0
        mut rss1 := 0
        til_common_maxrss.get(0, rss0)?
        til_common_maxrss.get(1, rss1)?
        if rss0.gt(maxrss_til_interp) { maxrss_til_interp = rss0 }
        if rss1.gt(maxrss_til_compile) { maxrss_til_compile = rss1 }
    }
    if all_common.len().gt(0) {
        mut all_common_rs_interp := 0
        mut all_common_rs_compile := 0
        all_common_totals.get(0, all_common_rs_interp)?
        all_common_totals.get(1, all_common_rs_compile)?
        total_rs_interp = total_rs_interp.add(all_common_rs_interp)
        total_rs_compile = total_rs_compile.add(all_common_rs_compile)
        mut bt_rs := 0
        all_common_build_totals.get(1, bt_rs)?
        total_rs_built = total_rs_built.add(bt_rs)
        mut rss0 := 0
        mut rss1 := 0
        all_common_maxrss.get(0, rss0)?
        all_common_maxrss.get(1, rss1)?
        if rss0.gt(maxrss_rs_interp) { maxrss_rs_interp = rss0 }
        if rss1.gt(maxrss_rs_compile) { maxrss_rs_compile = rss1 }
        if not(g_rust_only) {
            mut all_common_til_interp := 0
            mut all_common_til_compile := 0
            all_common_totals.get(2, all_common_til_interp)?
            all_common_totals.get(3, all_common_til_compile)?
            total_til_interp = total_til_interp.add(all_common_til_interp)
            total_til_compile = total_til_compile.add(all_common_til_compile)
            mut bt_til := 0
            all_common_build_totals.get(3, bt_til)?
            total_til_built = total_til_built.add(bt_til)
            mut rss2 := 0
            mut rss3 := 0
            all_common_maxrss.get(2, rss2)?
            all_common_maxrss.get(3, rss3)?
            if rss2.gt(maxrss_til_interp) { maxrss_til_interp = rss2 }
            if rss3.gt(maxrss_til_compile) { maxrss_til_compile = rss3 }
        }
    }

    // Print and write totals
    println("")
    println("=== Totals ===")
    println("Total rust interpreted:  ", format_time(total_rs_interp), ", max ", format_maxrss(maxrss_rs_interp))
    println("Total rust built:        ", format_time(total_rs_built))
    println("Total rust compiled:     ", format_time(total_rs_compile), ", max ", format_maxrss(maxrss_rs_compile))
    println("Total til interpreted:   ", format_time(total_til_interp), ", max ", format_maxrss(maxrss_til_interp))
    println("Total til built:         ", format_time(total_til_built))
    println("Total til compiled:      ", format_time(total_til_compile), ", max ", format_maxrss(maxrss_til_compile))
    total_all := total_rs_interp.add(total_rs_built).add(total_rs_compile).add(total_til_interp).add(total_til_built).add(total_til_compile)
    println("Total:                   ", format_time(total_all))
    println("Failed:                  ", errors_found.to_str(), "/", total_tests.to_str())

    // Wall-clock elapsed time
    mut end_time_str := ""
    _ := end_time_str.run_cmd("date", "+%s")
    end_time_str = end_time_str.replace("\n", "")
    end_epoch := I64.from_str(end_time_str)
    wall_clock_ms := end_epoch.sub(start_epoch).mul(1000)
    println("Wall-clock:              ", format_time(wall_clock_ms))

    writefile("gen/benchmark.csv", benchmark_content)?

    // Totals in separate org file for easy git history tracking
    mut totals := "* Totals\n"
    totals = totals.concat("- Total rust interpreted :: ").concat(format_time(total_rs_interp)).concat(", max ").concat(format_maxrss(maxrss_rs_interp)).concat("\n")
    totals = totals.concat("- Total rust built :: ").concat(format_time(total_rs_built)).concat("\n")
    totals = totals.concat("- Total rust compiled :: ").concat(format_time(total_rs_compile)).concat(", max ").concat(format_maxrss(maxrss_rs_compile)).concat("\n")
    totals = totals.concat("- Total til interpreted :: ").concat(format_time(total_til_interp)).concat(", max ").concat(format_maxrss(maxrss_til_interp)).concat("\n")
    totals = totals.concat("- Total til built :: ").concat(format_time(total_til_built)).concat("\n")
    totals = totals.concat("- Total til compiled :: ").concat(format_time(total_til_compile)).concat(", max ").concat(format_maxrss(maxrss_til_compile)).concat("\n")
    totals = totals.concat("- Total :: ").concat(format_time(total_all)).concat("\n")
    totals = totals.concat("- Wall-clock :: ").concat(format_time(wall_clock_ms)).concat("\n")
    writefile("gen/totals.org", totals)?

    if g_mem_report {
        mut mem_totals := "* Memory Report (HeapState)\n"
        mem_totals = mem_totals.concat("** rs_compiled\n").concat(g_mem_rs_compiled)
        mem_totals = mem_totals.concat("** til_compiled\n").concat(g_mem_til_compiled)
        writefile("gen/totals_mem.org", mem_totals)?
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: WriteError) { panic(loc(), err.msg) }

    if errors_found.gt(0) {
        panic(loc(), errors_found.to_str().concat("/").concat(total_tests.to_str()).concat(" tests failed."))
    }
}

regen := proc(files: Vec, rs_interpreted: Vec, rs_compiled: Vec, rs_common: Vec, til_interpreted: Vec, til_compiled: Vec, til_common: Vec, all_common: Vec) {
    // rs_interpreted, rs_common, all_common -> .rs_interpreted.out (via regen_test)
    // rs_compiled -> .rs_compiled.out (via regen_test_compiled)
    // til_interpreted, til_common -> .til_interpreted.out (via regen_test_til)
    // til_compiled -> .til_compiled.out (via regen_test_til_compiled)
    if files.len().eq(0) {
        // regen all
        for entry: TestEntry in rs_interpreted {
            regen_test(entry)
        }
        for entry: TestEntry in rs_compiled {
            regen_test_compiled(entry)
        }
        for entry: TestEntry in rs_common {
            regen_test(entry)
        }
        for entry: TestEntry in til_interpreted {
            regen_test_til(entry)
        }
        for entry: TestEntry in til_compiled {
            regen_test_til_compiled(entry)
        }
        for entry: TestEntry in til_common {
            regen_test_til(entry)
        }
        for entry: TestEntry in all_common {
            regen_test(entry)
        }
    } else {
        // regen specific files - find matching entries in lists
        // Match by full path or by suffix (e.g., "loops.til" matches "src/test/loops.til")
        for file: Str in files {
            // Search in each list for entries with matching path
            for entry: TestEntry in rs_interpreted {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test(entry)
                }
            }
            for entry: TestEntry in rs_compiled {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test_compiled(entry)
                }
            }
            for entry: TestEntry in rs_common {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test(entry)
                }
            }
            for entry: TestEntry in til_interpreted {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test_til(entry)
                }
            }
            for entry: TestEntry in til_compiled {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test_til_compiled(entry)
                }
            }
            for entry: TestEntry in til_common {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test_til(entry)
                }
            }
            for entry: TestEntry in all_common {
                if entry.path.eq(file).or(entry.path.ends_with(file)) {
                    regen_test(entry)
                }
            }
        }
    }
}

// _common tests compare both modes against same .interpreted.out file
test_rs_common := proc(entry: TestEntry, mut interpret_ms: I64, mut compile_ms: I64) returns I64 {
    mut errors_found := 0
    if test_with_cmd(entry, "./bin/rstil interpret ", "interpret", "interpreted", interpret_ms) {
        errors_found.inc()
    }
    if test_with_cmd(entry, "./bin/rstil run ", "run", "interpreted", compile_ms) {
        errors_found.inc()
    }
    return errors_found
}

test_til_common := proc(entry: TestEntry, mut interpret_ms: I64, mut compile_ms: I64) returns I64 {
    mut errors_found := 0
    // Bug #141: Use bin/rs/til (til built by rstil)
    if test_with_cmd(entry, "./bin/rs/til interpret ", "til interpret", "interpreted", interpret_ms) {
        errors_found.inc()
    }
    if test_with_cmd(entry, "./bin/rs/til run ", "til run", "interpreted", compile_ms) {
        errors_found.inc()
    }
    return errors_found
}

regen_test := proc(entry: TestEntry) {
    // Issue #131: Pass --cc flag to test_runner
    mut cc_flag := ""
    if not(g_cc.is_empty()) {
        cc_flag = concat(" --cc=", g_cc)
    }
    mut cmd := format("./bin/rs/test_runner regen rs_interpreted rs_interpreted ", entry.expected_status.to_str(), " ", entry.path, cc_flag)
    if entry.cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    mut output := ""
    _ := output.run_cmd("bash", "-c", cmd)
    print(output)
}

regen_test_compiled := proc(entry: TestEntry) {
    // Issue #131: Pass --cc flag to test_runner
    mut cc_flag := ""
    if not(g_cc.is_empty()) {
        cc_flag = concat(" --cc=", g_cc)
    }
    mut cmd := format("./bin/rs/test_runner regen rs_compiled rs_compiled ", entry.expected_status.to_str(), " ", entry.path, cc_flag)
    if entry.cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    mut output := ""
    _ := output.run_cmd("bash", "-c", cmd)
    print(output)
}

regen_test_til := proc(entry: TestEntry) {
    // Issue #131: Pass --cc flag to test_runner
    mut cc_flag := ""
    if not(g_cc.is_empty()) {
        cc_flag = concat(" --cc=", g_cc)
    }
    mut cmd := format("./bin/rs/test_runner regen til_interpreted til_interpreted ", entry.expected_status.to_str(), " ", entry.path, cc_flag)
    if entry.cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    mut output := ""
    _ := output.run_cmd("bash", "-c", cmd)
    print(output)
}

regen_test_til_compiled := proc(entry: TestEntry) {
    // Issue #131: Pass --cc flag to test_runner
    mut cc_flag := ""
    if not(g_cc.is_empty()) {
        cc_flag = concat(" --cc=", g_cc)
    }
    mut cmd := format("./bin/rs/test_runner regen til_compiled til_compiled ", entry.expected_status.to_str(), " ", entry.path, cc_flag)
    if entry.cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(entry.cmd_args)
    }
    mut output := ""
    _ := output.run_cmd("bash", "-c", cmd)
    print(output)
}

usage := proc() {
    println("Usage: tests [command] [options]")
    println("")
    println("Entering no arguments is equivalent to: 'tests test'")
    println("")
    println("Options:")
    println("  -jN          Run up to N tests in parallel (default: CPU thread count)")
    println("  --rust-only   Run only Rust-based tests, skip all TIL self-hosted modes")
    println("  --mem-report  Enable heap memory profiling for compiled tests")
    println("")
    println("Commands:")
    println("")
    println("test: runs all tests.")
    println("test <mode> <file> [args]: runs single file with mode's behavior.")
    println("regen: regenerates all .out files.")
    println("regen <file> [file2...]: regenerates .out files for specific test files.")
    println("help: prints this.")
    println("")
    println("Modes: rs_interpreted, rs_compiled, rs_common, til_interpreted, til_compiled, til_common, all_common")
}

main := proc(args: ..Str) {
    detect_os()

    // Capture wall-clock start time
    mut start_time_str := ""
    _ := start_time_str.run_cmd("date", "+%s")
    start_time_str = start_time_str.replace("\n", "")
    start_epoch := I64.from_str(start_time_str)

    // Parse options first (before other args processing)
    // -jN: parallelism (e.g., -j8, -j32) - like make
    // Issue #117: use quarter the threads to reduce memory pressure
    mut parallelism := get_thread_count().div(4)
    if parallelism.lt(1) {
        parallelism = 1
    }
    mut remaining_args := Vec.new(Str)
    for arg: Str in args {
        if arg.starts_with("-j") {
            // Extract number after -j
            j_str := get_substr(arg, 2, arg.len())?
            if j_str.len().gt(0) {
                parallelism = j_str.to_i64()
                if parallelism.lt(1) {
                    parallelism = 1
                }
            }
        } else if arg.eq("--rust-only") {
            g_rust_only = true
        } else if arg.eq("--mem-report") {
            g_mem_report = true
        } else if arg.starts_with("--cc=") {
            // Issue #131: --cc=COMPILER override
            g_cc = arg.get_substr(5, arg.len())?
        } else {
            remaining_args.push(arg)
        }
    }

    // Check flag file for --mem-report (C runtime strips --mem-report from argv
    // before TIL main sees it, so make.til writes this flag file instead)
    if file_mtime("tmp/.mem_report_flag").gt(I64_MINUS1) {
        g_mem_report = true
    }

    // rs_interpreted: tests that pass with rstil interpret only
    mut rs_interpreted := Vec.new(TestEntry)
    // TODO: Disabled to save test time -- rs_interpreted section runs 0 tests so tests.til skips it entirely
    // rs_interpreted.push(TestEntry(path="src/examples/hello_safe_script.til", expected_status=1)) // TODO: compiled version doesn't enforce safe_script whitelist

    // REPL test - requires stdin piping (e.g., echo "exit(0)" | ./bin/rstil repl)
    // run_cmd doesn't support stdin, would need bash -c wrapper or new ext_proc
    // Input must end with exit(0) to break out of the infinite while loop
    // rs_interpreted.push(TestEntry(path="src/modes/repl.til"))

    // rs_compiled: tests that pass with rstil run only
    mut rs_compiled := Vec.new(TestEntry)
    // TODO: Disabled to save test time -- rs_compiled section runs 0 tests so tests.til skips it entirely
    // rs_compiled.push(TestEntry(path="src/test/extra_syscalls.til"))  // TODO: list_dir/glob_files wrappers timeout in interpreted modes

    // rs_common: tests that pass with rstil but NOT yet with til (interpreted or compiled)
    // (tests that pass all 4 modes are in all_common)
    mut rs_common := Vec.new(TestEntry)
    rs_common.push(TestEntry(path="src/test/introspections.til")) // TODO: Actually use Introspection from func that is called from const initialization
    rs_common.push(TestEntry(path="src/test/precomp_throw.til", expected_status=1)) // Bug #54: rstil fails at precomp (correct), til fails at runtime (wrong catch ordering in precomp.til)
    rs_common.push(TestEntry(path="src/test/bug47.til"))  // TODO: til both modes timeout (>120s), rstil interpreted ~9.5s
    // TODO: test_parser.til disabled to save benchmark time (~40s rstil interpreted). Works, just slow.
    // rs_common.push(TestEntry(path="src/test/test_parser.til"))
    rs_common.push(TestEntry(path="src/til.til", cmd_args="help"))  // TODO: slow (~4min) but works

    // til_interpreted: tests that pass with til interpret but NOT yet with til_compiled
    // (tests that pass all 4 modes are in all_common)
    mut til_interpreted := Vec.new(TestEntry)

    // til_compiled: tests run with the self-hosted TIL compiler only
    mut til_compiled := Vec.new(TestEntry)
    // til_compiled.push(TestEntry(path="src/test/test_parser.til"))  // TODO: fails on CI, til_interpreted too slow (~23s)

    // til_common: tests run with BOTH self-hosted TIL interpreter and compiler
    // (for tests where output differs between rstil and til, e.g. error messages)
    mut til_common := Vec.new(TestEntry)

    // all_common: tests run with ALL 4 modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled)
    mut all_common := Vec.new(TestEntry)
    all_common.push(TestEntry(path="src/test/arenas.til"))
    all_common.push(TestEntry(path="src/test/args.til"))
    all_common.push(TestEntry(path="src/test/arrays.til"))
    all_common.push(TestEntry(path="src/test/bug43.til"))
    all_common.push(TestEntry(path="src/test/bug52.til"))
    all_common.push(TestEntry(path="src/test/bug55.til"))
    all_common.push(TestEntry(path="src/test/bug56.til"))
    all_common.push(TestEntry(path="src/test/bug57.til"))
    all_common.push(TestEntry(path="src/test/bug139.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/bug157.til"))
    all_common.push(TestEntry(path="src/test/bug159.til"))
    all_common.push(TestEntry(path="src/test/bug162.til"))
    all_common.push(TestEntry(path="src/test/c_mem.til"))
    all_common.push(TestEntry(path="src/test/cross_file_forward.til"))
    all_common.push(TestEntry(path="src/test/deterministic.til"))
    all_common.push(TestEntry(path="src/examples/empty.til"))
    all_common.push(TestEntry(path="src/examples/hello_cli.til"))
    all_common.push(TestEntry(path="src/examples/hello_lib.til"))
    all_common.push(TestEntry(path="src/examples/hello_liba.til"))
    all_common.push(TestEntry(path="src/examples/hello_pure.til"))
    all_common.push(TestEntry(path="src/examples/hello_pura.til"))
    all_common.push(TestEntry(path="src/examples/hello_script.til"))
    all_common.push(TestEntry(path="src/examples/hello_test.til"))
    all_common.push(TestEntry(path="src/examples/lolalalo.til"))
    all_common.push(TestEntry(path="src/test/arithmetics.til"))
    all_common.push(TestEntry(path="src/test/boolean.til"))
    all_common.push(TestEntry(path="src/test/branchless.til"))
    all_common.push(TestEntry(path="src/test/bug41.til"))
    all_common.push(TestEntry(path="src/test/bug46.til"))
    all_common.push(TestEntry(path="src/test/bug48.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/bug49.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/bug50.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/circular_test.til"))
    all_common.push(TestEntry(path="src/test/clone.til"))
    all_common.push(TestEntry(path="src/test/comparisons.til"))
    all_common.push(TestEntry(path="src/test/constfold.til"))
    all_common.push(TestEntry(path="src/test/editor_mode_test.til"))
    all_common.push(TestEntry(path="src/test/enums.til"))
    all_common.push(TestEntry(path="src/test/errors.til"))
    all_common.push(TestEntry(path="src/test/eval.til"))
    all_common.push(TestEntry(path="src/test/exit.til", expected_status=69))
    all_common.push(TestEntry(path="src/test/fibonacci.til"))
    all_common.push(TestEntry(path="src/test/flow.til"))
    all_common.push(TestEntry(path="src/test/forward_declarations.til"))
    all_common.push(TestEntry(path="src/test/function_pointers.til"))
    all_common.push(TestEntry(path="src/test/func_purity.til"))
    all_common.push(TestEntry(path="src/test/intro.til"))
    all_common.push(TestEntry(path="src/test/lists.til"))
    all_common.push(TestEntry(path="src/test/literals.til"))
    all_common.push(TestEntry(path="src/test/loops.til"))
    all_common.push(TestEntry(path="src/test/macros.til"))
    all_common.push(TestEntry(path="src/test/maps.til"))
    all_common.push(TestEntry(path="src/test/memcmp_str.til"))
    all_common.push(TestEntry(path="src/test/modes.til"))
    all_common.push(TestEntry(path="src/test/mut_test.til"))
    all_common.push(TestEntry(path="src/test/namespaces.til"))
    all_common.push(TestEntry(path="src/test/optional_args.til"))
    all_common.push(TestEntry(path="src/test/panic.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/parallel_cmd.til"))
    all_common.push(TestEntry(path="src/test/pointers.til"))

    all_common.push(TestEntry(path="src/test/return_value_usage.til"))
    all_common.push(TestEntry(path="src/test/scope_isolation.til"))
    all_common.push(TestEntry(path="src/test/sets.til"))
    all_common.push(TestEntry(path="src/test/sugar.til", expected_status=1))  // Issue #69: fixed, output now matches across all 4 modes
    all_common.push(TestEntry(path="src/test/strings.til"))
    all_common.push(TestEntry(path="src/test/structs.til"))
    all_common.push(TestEntry(path="src/test/syscalls.til"))
    all_common.push(TestEntry(path="src/test/test_lexer.til"))
    // all_common.push(TestEntry(path="src/test/test_parser.til")) // TODO too slow (~23s), moved to rs_common + til_compiled
    all_common.push(TestEntry(path="src/test/u8.til"))
    all_common.push(TestEntry(path="src/test/underscore.til"))
    all_common.push(TestEntry(path="src/test/ufcs.til"))
    all_common.push(TestEntry(path="src/test/undefined.til", expected_status=1))
    all_common.push(TestEntry(path="src/test/variadic.til"))
    all_common.push(TestEntry(path="src/test/vecs.til"))
    add_music_tests(all_common)

    // Parse remaining args (after -j was extracted)
    if remaining_args.len().eq(0) {
        // Default: run tests
        run_all_tests(rs_interpreted, rs_compiled, rs_common, til_interpreted, til_compiled, til_common, all_common, parallelism, start_epoch)
    } else {
        mut cmd := ""
        remaining_args.get(0, cmd)?
        switch cmd {
        case "test":
            if remaining_args.len().eq(1) {
                run_all_tests(rs_interpreted, rs_compiled, rs_common, til_interpreted, til_compiled, til_common, all_common, parallelism, start_epoch)
            } else if remaining_args.len().lt(3) {
                println("Error: test requires <mode> and <file>")
                usage()
                exit(1)
            } else {
                mut test_mode := ""
                mut file := ""
                remaining_args.get(1, test_mode)?
                remaining_args.get(2, file)?
                // Collect optional args
                mut cmd_args := ""
                for i in 3..remaining_args.len() {
                    mut arg := ""
                    remaining_args.get(i, arg)?
                    if cmd_args.len().gt(0) {
                        cmd_args = cmd_args.concat(" ")
                    }
                    cmd_args = cmd_args.concat(arg)
                }
                entry := TestEntry(path=file, cmd_args=cmd_args)
                mut time_ms := 0
                mut time_ms2 := 0
                switch test_mode {
                case "rs_interpreted":
                    _ := test_rs_interpreted(entry, time_ms)
                case "rs_compiled":
                    _ := test_rs_compiled(entry, time_ms)
                case "rs_common":
                    _ := test_rs_common(entry, time_ms, time_ms2)
                case "til_interpreted":
                    _ := test_til_interpreted(entry, time_ms)
                case "til_compiled":
                    _ := test_til_compiled(entry, time_ms)
                case "til_common":
                    _ := test_til_common(entry, time_ms, time_ms2)
                case:
                    println("Error: unknown mode '", test_mode, "'")
                    usage()
                    exit(1)
                }
            }
        case "regen":
            mut files := Vec.new(Str)
            for regen_idx in 1..remaining_args.len() {
                mut path := ""
                remaining_args.get(regen_idx, path)?
                files.push(path)
            }
            regen(files, rs_interpreted, rs_compiled, rs_common, til_interpreted, til_compiled, til_common, all_common)
        case:
            usage()
        }
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
