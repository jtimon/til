// music.til  - CLI for diatonic modes (EN/ES/PT)
// Generates scale from given mode + root (with accidentals)
// Output shows: scale notes, ASCII pentagram, and triads
//
// Triads are grouped by type:
// 4 types: mayor (1-3-5), menor (1-b3-5), aumentado (1-3-#5), disminuido (1-b3-b5)

mode cli

create_chromatic := func() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("do#")
    v.push("re")
    v.push("re#")
    v.push("mi")
    v.push("fa")
    v.push("fa#")
    v.push("sol")
    v.push("sol#")
    v.push("la")
    v.push("la#")
    v.push("si")
    return v
}

// Solfege notation: do, re, mi, fa, sol, la, si
create_notes_solfege := func() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("re")
    v.push("mi")
    v.push("fa")
    v.push("sol")
    v.push("la")
    v.push("si")
    return v
}

// American notation: C, D, E, F, G, A, B
create_notes_american := func() returns Vec {
    mut v := Vec.new(Str)
    v.push("C")
    v.push("D")
    v.push("E")
    v.push("F")
    v.push("G")
    v.push("A")
    v.push("B")
    return v
}

// Get notes array for given notation
get_notes_for_notation := proc(notation: Str) returns Vec {
    if notation.eq("american") {
        return create_notes_american()
    }
    return create_notes_solfege()
}

// Base notes for American input parsing (lowercase)
create_base_notes_american := func() returns Vec {
    mut v := Vec.new(Str)
    v.push("c")
    v.push("d")
    v.push("e")
    v.push("f")
    v.push("g")
    v.push("a")
    v.push("b")
    return v
}

// Input always uses solfege (user types do, re, mi, etc.)
create_base_notes := func() returns Vec {
    return create_notes_solfege()
}

// Mode intervals ordered from brightest to darkest.
// Major tonality: lydian, ionian, mixolydian (have major 3rd)
// Minor tonality: dorian, aeolian, phrygian, locrian (have minor 3rd)
create_mode_intervals := func() returns Vec {
    mut all := Vec.new(Vec)

    // Lydian - brightest (major, raised 4th degree)
    mut lydian := Vec.new(I64)
    lydian.push(2)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    all.push(lydian)

    // Ionian - major scale (reference)
    mut ionian := Vec.new(I64)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    ionian.push(2)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    all.push(ionian)

    // Mixolydian - major with flat 7th degree
    mut mixolydian := Vec.new(I64)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    all.push(mixolydian)

    // Dorian - minor with natural 6th degree
    mut dorian := Vec.new(I64)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    dorian.push(2)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    all.push(dorian)

    // Aeolian - natural minor scale (reference)
    mut aeolian := Vec.new(I64)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    all.push(aeolian)

    // Phrygian - minor with flat 2nd degree
    mut phrygian := Vec.new(I64)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    all.push(phrygian)

    // Locrian - darkest (minor, flat 2nd and 5th degrees)
    mut locrian := Vec.new(I64)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(2)
    all.push(locrian)

    return all
}

chromatic := create_chromatic()
base_notes := create_base_notes()
mode_intervals := create_mode_intervals()

// Maps diatonic index (0-6) to chromatic index (0-11)
// do=0, re=2, mi=4, fa=5, sol=7, la=9, si=11
diatonic_to_chromatic := func(diatonic_idx: I64) returns I64 {
    switch diatonic_idx {
    case 0: return 0   // do
    case 1: return 2   // re
    case 2: return 4   // mi
    case 3: return 5   // fa
    case 4: return 7   // sol
    case 5: return 9   // la
    case 6: return 11  // si
    case: return 0
    }
}

// Returns diatonic index (0-6) for a base note name (solfege)
get_diatonic_index := proc(note_base: Str) returns I64 {
    mut i := 0
    target := note_base.to_lowercase()
    while i.lt(base_notes.len()) {
        note := cast(Str, base_notes.get(i)?)
        if note.eq(target) {
            return i
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    neg_one := I64.sub(0, 1)
    return neg_one
}

// Returns diatonic index (0-6) for a base note name, using given notation
get_diatonic_index_for_notation := proc(note_base: Str, notation: Str) returns I64 {
    mut i := 0
    target := note_base.to_lowercase()
    mut search_notes := base_notes
    if notation.eq("american") {
        search_notes = create_base_notes_american()
    }
    while i.lt(search_notes.len()) {
        note := cast(Str, search_notes.get(i)?)
        if note.eq(target) {
            return i
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    neg_one := I64.sub(0, 1)
    return neg_one
}

// Returns chromatic index for a base note name
get_base_index := proc(note_base: Str) returns I64 {
    diatonic := get_diatonic_index(note_base)
    if diatonic.lt(0) {
        return diatonic
    }
    return diatonic_to_chromatic(diatonic)
}

// Format a note given its diatonic index, chromatic position, and notes array
format_note_with := proc(diatonic_idx: I64, chromatic_pos: I64, notes: Vec) returns Str {
    mut note_name := cast(Str, notes.get(diatonic_idx)?)
    natural_chromatic := diatonic_to_chromatic(diatonic_idx)

    mut diff := chromatic_pos.sub(natural_chromatic)
    // Handle wraparound
    if diff.gt(6) {
        diff = diff.sub(12)
    } else if diff.lt(I64.sub(0, 6)) {
        diff = diff.add(12)
    }

    // Add accidentals
    mut acc_i := 0
    if diff.gt(0) {
        while acc_i.lt(diff) {
            note_name = note_name.concat("#")
            acc_i = acc_i.add(1)
        }
    } else if diff.lt(0) {
        mut abs_diff := I64.sub(0, diff)
        while acc_i.lt(abs_diff) {
            note_name = note_name.concat("b")
            acc_i = acc_i.add(1)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return note_name
}

// Format a note using default solfege notation
format_note := proc(diatonic_idx: I64, chromatic_pos: I64) returns Str {
    return format_note_with(diatonic_idx, chromatic_pos, base_notes)
}

apply_accidentals := proc(base_idx: I64, acc_str: Str) returns I64 {
    mut semitones := 0
    mut j := 0
    while j.lt(acc_str.len()) {
        ch := acc_str.get_char(j)?
        // TODO: 'x' is a workaround for '#' which causes issues in test filenames
        if ch.eq("#").or(ch.eq("x")) {
            semitones = semitones.add(1)
        } else if ch.eq("b") {
            semitones = semitones.sub(1)
        }
        j = j.add(1)
    }
    mut idx := base_idx.add(semitones).mod(12)
    if idx.lt(0) {
        idx = idx.add(12)
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return idx
}

generate_scale := proc(root_idx: I64, root_diatonic: I64, steps: Vec, notes: Vec) returns Str {
    mut result := ""
    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic
    mut k := 0
    while k.lt(steps.len()) {
        if k.gt(0) {
            result = result.concat(" ")
        }
        note := format_note_with(diatonic_pos, chromatic_pos, notes)
        result = result.concat(note)
        step := cast(I64, steps.get(k)?)
        chromatic_pos = chromatic_pos.add(step).mod(12)
        diatonic_pos = diatonic_pos.add(1).mod(7)
        k = k.add(1)
    }
    // Add octave note in parentheses
    root_note := format_note_with(root_diatonic, root_idx, notes)
    result = result.concat(" (")
    result = result.concat(root_note)
    result = result.concat(")")

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return result
}

canonical_mode := proc(mode_arg: Str) returns Str {
    mut lower := mode_arg.to_lowercase()

    switch lower {
    case "ionian":      return "ionian"
    case "jonico":      return "ionian"
    case "jonio":       return "ionian"

    case "dorian":      return "dorian"
    case "dorico":      return "dorian"

    case "phrygian":    return "phrygian"
    case "frigio":      return "phrygian"

    case "lydian":      return "lydian"
    case "lidio":       return "lydian"

    case "mixolydian":  return "mixolydian"
    case "mixolidio":   return "mixolydian"

    case "aeolian":     return "aeolian"
    case "eolico":      return "aeolian"
    case "eolio":       return "aeolian"

    case "locrian":     return "locrian"
    case "locrio":      return "locrian"

    case:
        return ""
    }
}

// Index matches order in create_mode_intervals (brightest to darkest)
mode_index_from_canonical := proc(canonical: Str) returns I64 {
    switch canonical {
    case "lydian":     return 0  // brightest (major)
    case "ionian":     return 1  // major
    case "mixolydian": return 2  // major
    case "dorian":     return 3  // minor
    case "aeolian":    return 4  // minor
    case "phrygian":   return 5  // minor
    case "locrian":    return 6  // darkest (minor)
    case:              neg_one := I64.sub(0, 1)
    return neg_one
    }
}

localized_mode_name := proc(canonical: Str, lang: Str) returns Str {
    mut lower_lang := lang.to_lowercase()

    switch canonical {
    case "ionian":
        switch lower_lang {
        case "en": return "Ionian (Major)"
        case "es": return "Jonico (Mayor)"
        case "pt": return "Jonio (Maior)"
        case:      return "Jonio (Maior)"
        }

    case "dorian":
        switch lower_lang {
        case "en": return "Dorian"
        case "es": return "Dorico"
        case "pt": return "Dorico"
        case:      return "Dorico"
        }

    case "phrygian":
        switch lower_lang {
        case "en": return "Phrygian"
        case "es": return "Frigio"
        case "pt": return "Frigio"
        case:      return "Frigio"
        }

    case "lydian":
        switch lower_lang {
        case "en": return "Lydian"
        case "es": return "Lidio"
        case "pt": return "Lidio"
        case:      return "Lidio"
        }

    case "mixolydian":
        switch lower_lang {
        case "en": return "Mixolydian"
        case "es": return "Mixolidio"
        case "pt": return "Mixolidio"
        case:      return "Mixolidio"
        }

    case "aeolian":
        switch lower_lang {
        case "en": return "Aeolian (Natural Minor)"
        case "es": return "Eolico (Menor Natural)"
        case "pt": return "Eolio (Menor Natural)"
        case:      return "Eolio (Menor Natural)"
        }

    case "locrian":
        switch lower_lang {
        case "en": return "Locrian"
        case "es": return "Locrio"
        case "pt": return "Locrio"
        case:      return "Locrio"
        }

    case:
        return "Unknown mode"
    }
}

// Returns the triad type based on intervals from root to 3rd and 3rd to 5th
// mayor: 4+3, menor: 3+4, aumentado: 4+4, disminuido: 3+3
get_triad_type := func(interval_to_3rd: I64, interval_to_5th: I64) returns Str {
    if interval_to_3rd.eq(4).and(interval_to_5th.eq(7)) {
        return "mayor"
    } else if interval_to_3rd.eq(3).and(interval_to_5th.eq(7)) {
        return "menor"
    } else if interval_to_3rd.eq(4).and(interval_to_5th.eq(8)) {
        return "aumentado"
    } else if interval_to_3rd.eq(3).and(interval_to_5th.eq(6)) {
        return "disminuido"
    }
    return "?"
}

// Get the roman numeral for a scale degree (1-7)
get_roman := func(degree: I64, triad_type: Str) returns Str {
    mut roman := ""
    switch degree {
    case 1: roman = "I"
    case 2: roman = "II"
    case 3: roman = "III"
    case 4: roman = "IV"
    case 5: roman = "V"
    case 6: roman = "VI"
    case 7: roman = "VII"
    case: roman = "?"
    }
    // Lowercase for minor/diminished
    if triad_type.eq("menor").or(triad_type.eq("disminuido")) {
        roman = roman.to_lowercase()
    }
    return roman
}

// Build triads for a scale and print them grouped by type
print_triads := proc(root_idx: I64, root_diatonic: I64, steps: Vec, notes: Vec) {
    // Build array of chromatic positions for each scale degree
    mut scale_chromatic := Vec.new(I64)
    mut scale_diatonic := Vec.new(I64)
    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic

    mut k := 0
    while k.lt(7) {
        scale_chromatic.push(chromatic_pos.clone())
        scale_diatonic.push(diatonic_pos.clone())
        step := cast(I64, steps.get(k)?)
        chromatic_pos = chromatic_pos.add(step).mod(12)
        diatonic_pos = diatonic_pos.add(1).mod(7)
        k = k.add(1)
    }

    // Collect triads by type
    mut mayor_triads := Vec.new(Str)
    mut menor_triads := Vec.new(Str)
    mut aumentado_triads := Vec.new(Str)
    mut disminuido_triads := Vec.new(Str)

    mut degree := 0
    while degree.lt(7) {
        // Get chromatic positions for root, 3rd, 5th of this triad
        root_chrom := cast(I64, scale_chromatic.get(degree)?)
        third_chrom := cast(I64, scale_chromatic.get(degree.add(2).mod(7))?)
        fifth_chrom := cast(I64, scale_chromatic.get(degree.add(4).mod(7))?)

        // Get diatonic positions for note names
        root_dia := cast(I64, scale_diatonic.get(degree)?)
        third_dia := cast(I64, scale_diatonic.get(degree.add(2).mod(7))?)
        fifth_dia := cast(I64, scale_diatonic.get(degree.add(4).mod(7))?)

        // Calculate intervals
        mut interval_to_3rd := third_chrom.sub(root_chrom)
        if interval_to_3rd.lt(0) {
            interval_to_3rd = interval_to_3rd.add(12)
        }
        mut interval_to_5th := fifth_chrom.sub(root_chrom)
        if interval_to_5th.lt(0) {
            interval_to_5th = interval_to_5th.add(12)
        }

        triad_type := get_triad_type(interval_to_3rd, interval_to_5th)
        roman := get_roman(degree.add(1), triad_type)

        // Format the triad notes
        root_note := format_note_with(root_dia, root_chrom, notes)
        third_note := format_note_with(third_dia, third_chrom, notes)
        fifth_note := format_note_with(fifth_dia, fifth_chrom, notes)

        mut triad_str := root_note.concat("-")
        triad_str = triad_str.concat(third_note)
        triad_str = triad_str.concat("-")
        triad_str = triad_str.concat(fifth_note)
        triad_str = triad_str.concat(" (")
        triad_str = triad_str.concat(roman)
        triad_str = triad_str.concat(")")

        // Add to appropriate list
        if triad_type.eq("mayor") {
            mayor_triads.push(triad_str)
        } else if triad_type.eq("menor") {
            menor_triads.push(triad_str)
        } else if triad_type.eq("aumentado") {
            aumentado_triads.push(triad_str)
        } else if triad_type.eq("disminuido") {
            disminuido_triads.push(triad_str)
        }

        degree = degree.add(1)
    }

    // Print grouped by type
    println("")
    println("Triades:")

    // Helper to print a triad list
    print_triad_line("  Mayor: ", mayor_triads)
    print_triad_line("  Menor: ", menor_triads)
    print_triad_line("  Disminuido: ", disminuido_triads)
    print_triad_line("  Aumentado: ", aumentado_triads)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

print_triad_line := proc(label: Str, triads: Vec) {
    mut line := label
    if triads.len().eq(0) {
        line = line.concat("-")
    } else {
        mut i := 0
        while i.lt(triads.len()) {
            if i.gt(0) {
                line = line.concat(", ")
            }
            t := cast(Str, triads.get(i)?)
            line = line.concat(t)
            i = i.add(1)
        }
    }
    println(line)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

// Get staff position for a note (mi=0, fa=1, sol=2, la=3, si=4, do'=5, etc.)
// Lines are at even positions: 0(mi), 2(sol), 4(si), 6(re'), 8(fa')
// Spaces are at odd positions: 1(fa), 3(la), 5(do'), 7(mi')
get_staff_position := func(diatonic_idx: I64, octave: I64) returns I64 {
    return diatonic_idx.sub(2).add(octave.mul(7))
}

// Get natural note name for a staff position (for side labels)
get_position_note_name := proc(pos: I64, notes: Vec) returns Str {
    // Map position back to diatonic: pos = diatonic - 2 + octave*7
    // So diatonic = (pos + 2) mod 7
    mut diatonic := pos.add(2).mod(7)
    if diatonic.lt(0) {
        diatonic = diatonic.add(7)
    }
    name := cast(Str, notes.get(diatonic)?)

    catch (err: IndexOutOfBoundsError) {
        return "?"
    }
    return name
}

// Extract accidental from a note name (e.g., "fa#" -> "#", "sib" -> "b", "do" -> "")
get_accidental := proc(note_name: Str) returns Str {
    mut acc := ""
    mut i := 0
    while i.lt(note_name.len()) {
        ch := note_name.get_char(i)?
        if ch.eq("#").or(ch.eq("b")) {
            acc = acc.concat(ch)
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    return acc
}

// Pad string to width (right-aligned for notes)
pad_right := func(s: Str, width: I64) returns Str {
    mut result := s
    while result.len().lt(width) {
        result = result.concat(" ")
    }
    return result
}

// Repeat a character n times
repeat_char := func(ch: Str, n: I64) returns Str {
    mut result := ""
    mut i := 0
    while i.lt(n) {
        result = result.concat(ch)
        i = i.add(1)
    }
    return result
}

print_pentagram := proc(root_idx: I64, root_diatonic: I64, steps: Vec, notes: Vec) {
    // Build scale notes with their staff positions
    mut note_names := Vec.new(Str)
    mut note_positions := Vec.new(I64)

    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic
    mut octave := 0
    mut prev_diatonic := root_diatonic

    mut k := 0
    while k.lt(8) {
        // Get note name with accidentals
        note := format_note_with(diatonic_pos, chromatic_pos, notes)
        note_names.push(note)

        // Calculate staff position
        staff_pos := get_staff_position(diatonic_pos, octave)
        note_positions.push(staff_pos)

        // Move to next note
        if k.lt(7) {
            step := cast(I64, steps.get(k)?)
            chromatic_pos = chromatic_pos.add(step).mod(12)
            prev_diatonic = diatonic_pos
            diatonic_pos = diatonic_pos.add(1).mod(7)
            // Check if we wrapped to a new octave
            if diatonic_pos.lt(prev_diatonic) {
                octave = octave.add(1)
            }
        }
        k = k.add(1)
    }

    // Find min and max staff positions
    mut min_pos := 100
    mut max_pos := I64.sub(0, 100)
    k = 0
    while k.lt(note_positions.len()) {
        pos := cast(I64, note_positions.get(k)?)
        if pos.lt(min_pos) {
            min_pos = pos
        }
        if pos.gt(max_pos) {
            max_pos = pos
        }
        k = k.add(1)
    }

    // Ensure we show at least the 5 staff lines (positions 0,2,4,6,8)
    if min_pos.gt(0) {
        min_pos = 0
    }
    if max_pos.lt(8) {
        max_pos = 8
    }

    // Column width for each note
    col_width := 7

    // Render from top to bottom
    println("")
    println("Pentagram:")

    mut row := max_pos
    while row.gt(min_pos).or(row.eq(min_pos)) {
        mut line := "  "

        // Determine if this row is a staff line (positions 0,2,4,6,8)
        is_staff_line := row.gt(I64.sub(0,1)).and(row.lt(9)).and(row.mod(2).eq(0))
        // Ledger line below staff
        is_ledger_below := row.lt(0).and(row.mod(2).eq(0))
        // Ledger line above staff
        is_ledger_above := row.gt(8).and(row.mod(2).eq(0))

        // Build the row
        mut col := 0
        while col.lt(8) {
            note_pos := cast(I64, note_positions.get(col)?)

            note_name := cast(Str, note_names.get(col)?)
            acc := get_accidental(note_name)

            // Check if note is at this row
            if note_pos.eq(row) {
                // Note is here
                if is_staff_line {
                    // Note on a staff line: ---o--- or --#o--- or --bo---
                    if acc.eq("#") {
                        line = line.concat("--#o---")
                    } else if acc.eq("b") {
                        line = line.concat("--bo---")
                    } else if acc.eq("##") {
                        line = line.concat("-##o---")
                    } else if acc.eq("bb") {
                        line = line.concat("-bbo---")
                    } else {
                        line = line.concat("---o---")
                    }
                } else if is_ledger_below.or(is_ledger_above) {
                    // Note on a ledger line: -o- centered
                    if acc.eq("#") {
                        line = line.concat("  -#o- ")
                    } else if acc.eq("b") {
                        line = line.concat("  -bo- ")
                    } else {
                        line = line.concat("  -o-  ")
                    }
                } else {
                    // Note in a space: just the note symbol
                    if acc.eq("#") {
                        line = line.concat("  #o   ")
                    } else if acc.eq("b") {
                        line = line.concat("  bo   ")
                    } else if acc.eq("##") {
                        line = line.concat("  ##o  ")
                    } else if acc.eq("bb") {
                        line = line.concat("  bbo  ")
                    } else {
                        line = line.concat("   o   ")
                    }
                }
            } else {
                // No note at this position
                if is_staff_line {
                    line = line.concat("-------")
                } else {
                    line = line.concat("       ")
                }
            }

            col = col.add(1)
        }

        // Add side label (natural note name)
        note_label := get_position_note_name(row, notes)
        line = line.concat("  ")
        line = line.concat(note_label)

        println(line)
        row = row.sub(1)
    }

    // Print note labels at bottom
    println("")
    mut label_line := "  "
    k = 0
    while k.lt(note_names.len()) {
        mut name := cast(Str, note_names.get(k)?)
        // Add ' for octave note (last note)
        if k.eq(7) {
            name = name.concat("'")
        }
        label_line = label_line.concat(pad_right(name, col_width))
        k = k.add(1)
    }
    println(label_line)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

print_scale := proc(mode_arg: Str, root_arg: Str, lang: Str, notation: Str) {
    mut canon := canonical_mode(mode_arg)
    if canon.eq("") {
        msg := "Unknown mode: "
        println(msg.concat(mode_arg))
        println("Try: jonio ionian jonico dorico dorian frigio phrygian lidio lydian mixolidio mixolydian eolio aeolian locrio locrian")
        return
    }

    mut mode_index := mode_index_from_canonical(canon)
    mut mode_name := localized_mode_name(canon, lang)
    notes := get_notes_for_notation(notation)

    // Parse root note with suffix accidentals (e.g., "fa#", "sib", "solx")
    // 'x' is a workaround for '#' which causes issues in test filenames
    mut acc := ""
    mut base := ""
    mut i := 0
    input := root_arg.to_lowercase()
    // Find where accidentals start (first #, x, or b after the note name)
    while i.lt(input.len()) {
        ch := input.get_char(i)?
        if ch.eq("#").or(ch.eq("x")).or(ch.eq("b")) {
            break
        }
        i = i.add(1)
    }
    base = input.get_substr(0, i)?
    acc = input.get_substr(i, input.len())?

    root_diatonic := get_diatonic_index_for_notation(base, notation)
    if root_diatonic.lt(0) {
        msg2 := "Invalid base note: "
        println(msg2.concat(base))
        if notation.eq("american") {
            println("Use: C D E F G A B")
        } else {
            println("Use: do re mi fa sol la si")
        }
        return
    }

    base_idx := diatonic_to_chromatic(root_diatonic)
    root_idx := apply_accidentals(base_idx, acc)

    steps := cast(Vec, mode_intervals.get(mode_index)?)

    scale_str := generate_scale(root_idx, root_diatonic, steps, notes)

    header := mode_name.concat(" starting on ")
    header2 := header.concat(root_arg)
    println(header2.concat(":"))
    println(scale_str)

    print_pentagram(root_idx, root_diatonic, steps, notes)
    print_triads(root_idx, root_diatonic, steps, notes)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

usage := proc(lang: Str) {
    mut lower_lang := lang.to_lowercase()
    if lower_lang.eq("en") {
        println("Usage: ./bin/til music.til [-lang=pt|en|es] [-notation=solfege|american] <mode> [root]")
        println("Examples:")
        println("  ./bin/til music.til ionian do")
        println("  ./bin/til music.til -lang=en lydian fax")
        println("  ./bin/til music.til -notation=american dorian C")
    } else if lower_lang.eq("es") {
        println("Uso: ./bin/til music.til [-lang=pt|en|es] [-notation=solfege|american] <modo> [raiz]")
        println("Ejemplos:")
        println("  ./bin/til music.til jonico do")
        println("  ./bin/til music.til -lang=es lidio fax")
        println("  ./bin/til music.til -notation=american dorico C")
    } else {  // pt
        println("Uso: ./bin/til music.til [-lang=pt|en|es] [-notation=solfege|american] <modo> [raiz]")
        println("Exemplos:")
        println("  ./bin/til music.til jonio do")
        println("  ./bin/til music.til -lang=pt lidio fax")
        println("  ./bin/til music.til -notation=american dorico C")
    }
}

main := proc(args: ..Str) {
    mut lang := "pt"
    mut notation := "solfege"
    mut mode_arg := ""
    mut root_arg := "do"

    for arg: Str in args {
        mut lower_arg := arg.to_lowercase()

        if lower_arg.starts_with("-lang=") {
            mut val := lower_arg.get_substr(6, lower_arg.len())?

            switch val {
            case "pt": lang = "pt"
            case "en": lang = "en"
            case "es": lang = "es"
            case:
                warn1 := "TODO: unsupported language '"
                warn2 := warn1.concat(val)
                println(warn2.concat("' - using pt"))
            }

            continue
        }

        if lower_arg.starts_with("-notation=") {
            mut notation_val := lower_arg.get_substr(10, lower_arg.len())?

            switch notation_val {
            case "solfege": notation = "solfege"
            case "american": notation = "american"
            case:
                notation_warn1 := "Unknown notation '"
                notation_warn2 := notation_warn1.concat(notation_val)
                println(notation_warn2.concat("' - using solfege"))
            }

            continue
        }

        if mode_arg.eq("") {
            mode_arg = arg
        } else if root_arg.eq("do") {
            root_arg = arg
        }
    }

    if or(mode_arg.eq(""), mode_arg.eq("help")) {
        usage(lang)
        return
    }

    print_scale(mode_arg, root_arg, lang, notation)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}
