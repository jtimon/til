// music.til  - CLI for diatonic modes (EN/ES/PT)
// Generates scale from given mode + root (with accidentals)
// Output shows the 7 notes + octave repeat in parentheses

mode cli

// TODO: Bug #133 workaround - using proc instead of func to prevent precomputation
// of heap values. The returned Vec has pointers that are invalid at compile time.
create_chromatic := proc() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("do#")
    v.push("re")
    v.push("re#")
    v.push("mi")
    v.push("fa")
    v.push("fa#")
    v.push("sol")
    v.push("sol#")
    v.push("la")
    v.push("la#")
    v.push("si")
    return v
}

// TODO: Bug #133 workaround - using proc instead of func
create_base_notes := proc() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("re")
    v.push("mi")
    v.push("fa")
    v.push("sol")
    v.push("la")
    v.push("si")
    return v
}

// TODO: Bug #133 workaround - using proc instead of func
create_mode_intervals := proc() returns Vec {
    mut all := Vec.new(Vec)

    mut ionian := Vec.new(I64)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    ionian.push(2)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    all.push(ionian)

    mut dorian := Vec.new(I64)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    dorian.push(2)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    all.push(dorian)

    mut phrygian := Vec.new(I64)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    all.push(phrygian)

    mut lydian := Vec.new(I64)
    lydian.push(2)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    all.push(lydian)

    mut mixolydian := Vec.new(I64)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    all.push(mixolydian)

    mut aeolian := Vec.new(I64)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    all.push(aeolian)

    mut locrian := Vec.new(I64)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(2)
    all.push(locrian)

    return all
}

chromatic := create_chromatic()
base_notes := create_base_notes()
mode_intervals := create_mode_intervals()

// Maps diatonic index (0-6) to chromatic index (0-11)
// do=0, re=2, mi=4, fa=5, sol=7, la=9, si=11
diatonic_to_chromatic := func(diatonic_idx: I64) returns I64 {
    switch diatonic_idx {
    case 0: return 0   // do
    case 1: return 2   // re
    case 2: return 4   // mi
    case 3: return 5   // fa
    case 4: return 7   // sol
    case 5: return 9   // la
    case 6: return 11  // si
    case: return 0
    }
}

// Returns diatonic index (0-6) for a base note name
get_diatonic_index := proc(note_base: Str) returns I64 {
    mut i := 0
    target := note_base.to_lowercase()
    while i.lt(base_notes.len()) {
        mut note := ""
        base_notes.get(i, note)
        if note.eq(target) {
            return i
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    neg_one := I64.sub(0, 1)
    return neg_one
}

// Returns chromatic index for a base note name
get_base_index := proc(note_base: Str) returns I64 {
    diatonic := get_diatonic_index(note_base)
    if diatonic.lt(0) {
        return diatonic
    }
    return diatonic_to_chromatic(diatonic)
}

// Format a note given its diatonic index and target chromatic position
format_note := proc(diatonic_idx: I64, chromatic_pos: I64) returns Str {
    mut note_name := ""
    base_notes.get(diatonic_idx, note_name)
    natural_chromatic := diatonic_to_chromatic(diatonic_idx)

    mut diff := chromatic_pos.sub(natural_chromatic)
    // Handle wraparound
    if diff.gt(6) {
        diff = diff.sub(12)
    } else if diff.lt(I64.sub(0, 6)) {
        diff = diff.add(12)
    }

    // Add accidentals
    mut acc_i := 0
    if diff.gt(0) {
        while acc_i.lt(diff) {
            note_name = note_name.concat("#")
            acc_i = acc_i.add(1)
        }
    } else if diff.lt(0) {
        mut abs_diff := I64.sub(0, diff)
        while acc_i.lt(abs_diff) {
            note_name = note_name.concat("b")
            acc_i = acc_i.add(1)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return note_name
}

apply_accidentals := proc(base_idx: I64, acc_str: Str) returns I64 {
    mut semitones := 0
    mut j := 0
    while j.lt(acc_str.len()) {
        ch := acc_str.get_char(j)
        // TODO: 'x' is a workaround for '#' which causes issues in test filenames
        if ch.eq("#").or(ch.eq("x")) {
            semitones = semitones.add(1)
        } else if ch.eq("b") {
            semitones = semitones.sub(1)
        }
        j = j.add(1)
    }
    mut idx := base_idx.add(semitones).mod(12)
    if idx.lt(0) {
        idx = idx.add(12)
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return idx
}

generate_scale := proc(root_idx: I64, root_diatonic: I64, steps: Vec) returns Str {
    mut result := ""
    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic
    mut k := 0
    while k.lt(steps.len()) {
        if k.gt(0) {
            result = result.concat(" ")
        }
        note := format_note(diatonic_pos, chromatic_pos)
        result = result.concat(note)
        mut step := 0
        steps.get(k, step)
        chromatic_pos = chromatic_pos.add(step).mod(12)
        diatonic_pos = diatonic_pos.add(1).mod(7)
        k = k.add(1)
    }
    // Add octave note in parentheses
    root_note := format_note(root_diatonic, root_idx)
    result = result.concat(" (")
    result = result.concat(root_note)
    result = result.concat(")")

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return result
}

canonical_mode := proc(mode_arg: Str) returns Str {
    mut lower := mode_arg.to_lowercase()

    switch lower {
    case "ionian":      return "ionian"
    case "jonico":      return "ionian"
    case "jonio":       return "ionian"

    case "dorian":      return "dorian"
    case "dorico":      return "dorian"

    case "phrygian":    return "phrygian"
    case "frigio":      return "phrygian"

    case "lydian":      return "lydian"
    case "lidio":       return "lydian"

    case "mixolydian":  return "mixolydian"
    case "mixolidio":   return "mixolydian"

    case "aeolian":     return "aeolian"
    case "eolico":      return "aeolian"
    case "eolio":       return "aeolian"

    case "locrian":     return "locrian"
    case "locrio":      return "locrian"

    case:
        return ""
    }
}

mode_index_from_canonical := proc(canonical: Str) returns I64 {
    switch canonical {
    case "ionian":     return 0
    case "dorian":     return 1
    case "phrygian":   return 2
    case "lydian":     return 3
    case "mixolydian": return 4
    case "aeolian":    return 5
    case "locrian":    return 6
    case:              neg_one := I64.sub(0, 1)
    return neg_one
    }
}

localized_mode_name := proc(canonical: Str, lang: Str) returns Str {
    mut lower_lang := lang.to_lowercase()

    switch canonical {
    case "ionian":
        switch lower_lang {
        case "en": return "Ionian (Major)"
        case "es": return "Jonico (Mayor)"
        case "pt": return "Jonio (Maior)"
        case:      return "Jonio (Maior)"
        }

    case "dorian":
        switch lower_lang {
        case "en": return "Dorian"
        case "es": return "Dorico"
        case "pt": return "Dorico"
        case:      return "Dorico"
        }

    case "phrygian":
        switch lower_lang {
        case "en": return "Phrygian"
        case "es": return "Frigio"
        case "pt": return "Frigio"
        case:      return "Frigio"
        }

    case "lydian":
        switch lower_lang {
        case "en": return "Lydian"
        case "es": return "Lidio"
        case "pt": return "Lidio"
        case:      return "Lidio"
        }

    case "mixolydian":
        switch lower_lang {
        case "en": return "Mixolydian"
        case "es": return "Mixolidio"
        case "pt": return "Mixolidio"
        case:      return "Mixolidio"
        }

    case "aeolian":
        switch lower_lang {
        case "en": return "Aeolian (Natural Minor)"
        case "es": return "Eolico (Menor Natural)"
        case "pt": return "Eolio (Menor Natural)"
        case:      return "Eolio (Menor Natural)"
        }

    case "locrian":
        switch lower_lang {
        case "en": return "Locrian"
        case "es": return "Locrio"
        case "pt": return "Locrio"
        case:      return "Locrio"
        }

    case:
        return "Unknown mode"
    }
}

print_scale := proc(mode_arg: Str, root_arg: Str, lang: Str) {
    mut canon := canonical_mode(mode_arg)
    if canon.eq("") {
        msg := "Unknown mode: "
        println(msg.concat(mode_arg))
        println("Try: jonio ionian jonico dorico dorian frigio phrygian lidio lydian mixolidio mixolydian eolio aeolian locrio locrian")
        return
    }

    mut mode_index := mode_index_from_canonical(canon)
    mut mode_name := localized_mode_name(canon, lang)

    // Parse root note with suffix accidentals (e.g., "fa#", "sib", "solx")
    // 'x' is a workaround for '#' which causes issues in test filenames
    mut acc := ""
    mut base := ""
    mut i := 0
    input := root_arg.to_lowercase()
    // Find where accidentals start (first #, x, or b after the note name)
    while i.lt(input.len()) {
        ch := input.get_char(i)
        if ch.eq("#").or(ch.eq("x")).or(ch.eq("b")) {
            break
        }
        i = i.add(1)
    }
    base = input.get_substr(0, i)
    acc = input.get_substr(i, input.len())

    root_diatonic := get_diatonic_index(base)
    if root_diatonic.lt(0) {
        msg2 := "Invalid base note: "
        println(msg2.concat(base))
        println("Use: do re mi fa sol la si")
        return
    }

    base_idx := diatonic_to_chromatic(root_diatonic)
    root_idx := apply_accidentals(base_idx, acc)

    mut steps := Vec.new(I64)
    mode_intervals.get(mode_index, steps)

    scale_str := generate_scale(root_idx, root_diatonic, steps)

    header := mode_name.concat(" starting on ")
    header2 := header.concat(root_arg)
    println(header2.concat(":"))
    println(scale_str)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

usage := proc(lang: Str) {
    mut lower_lang := lang.to_lowercase()
    if lower_lang.eq("en") {
        println("Usage: ./bin/til music.til [-lang=pt|en|es] <mode> [root]")
        println("Examples:")
        println("  ./bin/til music.til ionian do")
        println("  ./bin/til music.til -lang=en lydian fax")
        println("  ./bin/til music.til -lang=es eolico reb")
    } else if lower_lang.eq("es") {
        println("Uso: ./bin/til music.til [-lang=pt|en|es] <modo> [raiz]")
        println("Ejemplos:")
        println("  ./bin/til music.til jonico do")
        println("  ./bin/til music.til -lang=es lidio fax")
        println("  ./bin/til music.til -lang=es eolico reb")
    } else {  // pt
        println("Uso: ./bin/til music.til [-lang=pt|en|es] <modo> [raiz]")
        println("Exemplos:")
        println("  ./bin/til music.til jonio do")
        println("  ./bin/til music.til -lang=pt lidio fax")
        println("  ./bin/til music.til -lang=es eolico reb")
    }
}

main := proc(args: ..Str) {
    mut lang := "pt"
    mut mode_arg := ""
    mut root_arg := "do"

    for arg: Str in args {
        mut lower_arg := arg.to_lowercase()

        if lower_arg.starts_with("-lang=") {
            mut val := lower_arg.get_substr(6, lower_arg.len())

            switch val {
            case "pt": lang = "pt"
            case "en": lang = "en"
            case "es": lang = "es"
            case:
                warn1 := "TODO: unsupported language '"
                warn2 := warn1.concat(val)
                println(warn2.concat("' - using pt"))
            }

            continue
        }

        if mode_arg.eq("") {
            mode_arg = arg
        } else if root_arg.eq("do") {
            root_arg = arg
        }
    }

    if or(mode_arg.eq(""), mode_arg.eq("help")) {
        usage(lang)
        return
    }

    print_scale(mode_arg, root_arg, lang)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}
