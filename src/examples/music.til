// music.til  - CLI for diatonic modes (EN/ES/PT)
// Generates scale from given mode + root (with accidentals)
// Output shows the 7 notes + octave repeat in parentheses
//
// Use --triades flag to show triads grouped by type after the scale
// 4 types: mayor (1-3-5), menor (1-b3-5), aumentado (1-3-#5), disminuido (1-b3-b5)

mode cli

// TODO: Bug #133 workaround - using proc instead of func to prevent precomputation
// of heap values. The returned Vec has pointers that are invalid at compile time.
create_chromatic := proc() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("do#")
    v.push("re")
    v.push("re#")
    v.push("mi")
    v.push("fa")
    v.push("fa#")
    v.push("sol")
    v.push("sol#")
    v.push("la")
    v.push("la#")
    v.push("si")
    return v
}

// TODO: Bug #133 workaround - using proc instead of func
create_base_notes := proc() returns Vec {
    mut v := Vec.new(Str)
    v.push("do")
    v.push("re")
    v.push("mi")
    v.push("fa")
    v.push("sol")
    v.push("la")
    v.push("si")
    return v
}

// TODO: Bug #133 workaround - using proc instead of func
create_mode_intervals := proc() returns Vec {
    mut all := Vec.new(Vec)

    mut ionian := Vec.new(I64)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    ionian.push(2)
    ionian.push(2)
    ionian.push(2)
    ionian.push(1)
    all.push(ionian)

    mut dorian := Vec.new(I64)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    dorian.push(2)
    dorian.push(2)
    dorian.push(1)
    dorian.push(2)
    all.push(dorian)

    mut phrygian := Vec.new(I64)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(2)
    phrygian.push(1)
    phrygian.push(2)
    phrygian.push(2)
    all.push(phrygian)

    mut lydian := Vec.new(I64)
    lydian.push(2)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    lydian.push(2)
    lydian.push(2)
    lydian.push(1)
    all.push(lydian)

    mut mixolydian := Vec.new(I64)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    mixolydian.push(2)
    mixolydian.push(1)
    mixolydian.push(2)
    all.push(mixolydian)

    mut aeolian := Vec.new(I64)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    aeolian.push(1)
    aeolian.push(2)
    aeolian.push(2)
    all.push(aeolian)

    mut locrian := Vec.new(I64)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(1)
    locrian.push(2)
    locrian.push(2)
    locrian.push(2)
    all.push(locrian)

    return all
}

chromatic := create_chromatic()
base_notes := create_base_notes()
mode_intervals := create_mode_intervals()

// Maps diatonic index (0-6) to chromatic index (0-11)
// do=0, re=2, mi=4, fa=5, sol=7, la=9, si=11
diatonic_to_chromatic := func(diatonic_idx: I64) returns I64 {
    switch diatonic_idx {
    case 0: return 0   // do
    case 1: return 2   // re
    case 2: return 4   // mi
    case 3: return 5   // fa
    case 4: return 7   // sol
    case 5: return 9   // la
    case 6: return 11  // si
    case: return 0
    }
}

// Returns diatonic index (0-6) for a base note name
get_diatonic_index := proc(note_base: Str) returns I64 {
    mut i := 0
    target := note_base.to_lowercase()
    while i.lt(base_notes.len()) {
        mut note := ""
        base_notes.get(i, note)?
        if note.eq(target) {
            return i
        }
        i = i.add(1)
    }
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    neg_one := I64.sub(0, 1)
    return neg_one
}

// Returns chromatic index for a base note name
get_base_index := proc(note_base: Str) returns I64 {
    diatonic := get_diatonic_index(note_base)
    if diatonic.lt(0) {
        return diatonic
    }
    return diatonic_to_chromatic(diatonic)
}

// Format a note given its diatonic index and target chromatic position
format_note := proc(diatonic_idx: I64, chromatic_pos: I64) returns Str {
    mut note_name := ""
    base_notes.get(diatonic_idx, note_name)?
    natural_chromatic := diatonic_to_chromatic(diatonic_idx)

    mut diff := chromatic_pos.sub(natural_chromatic)
    // Handle wraparound
    if diff.gt(6) {
        diff = diff.sub(12)
    } else if diff.lt(I64.sub(0, 6)) {
        diff = diff.add(12)
    }

    // Add accidentals
    mut acc_i := 0
    if diff.gt(0) {
        while acc_i.lt(diff) {
            note_name = note_name.concat("#")
            acc_i = acc_i.add(1)
        }
    } else if diff.lt(0) {
        mut abs_diff := I64.sub(0, diff)
        while acc_i.lt(abs_diff) {
            note_name = note_name.concat("b")
            acc_i = acc_i.add(1)
        }
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return note_name
}

apply_accidentals := proc(base_idx: I64, acc_str: Str) returns I64 {
    mut semitones := 0
    mut j := 0
    while j.lt(acc_str.len()) {
        ch := acc_str.get_char(j)?
        // TODO: 'x' is a workaround for '#' which causes issues in test filenames
        if ch.eq("#").or(ch.eq("x")) {
            semitones = semitones.add(1)
        } else if ch.eq("b") {
            semitones = semitones.sub(1)
        }
        j = j.add(1)
    }
    mut idx := base_idx.add(semitones).mod(12)
    if idx.lt(0) {
        idx = idx.add(12)
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return idx
}

generate_scale := proc(root_idx: I64, root_diatonic: I64, steps: Vec) returns Str {
    mut result := ""
    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic
    mut k := 0
    while k.lt(steps.len()) {
        if k.gt(0) {
            result = result.concat(" ")
        }
        note := format_note(diatonic_pos, chromatic_pos)
        result = result.concat(note)
        mut step := 0
        steps.get(k, step)?
        chromatic_pos = chromatic_pos.add(step).mod(12)
        diatonic_pos = diatonic_pos.add(1).mod(7)
        k = k.add(1)
    }
    // Add octave note in parentheses
    root_note := format_note(root_diatonic, root_idx)
    result = result.concat(" (")
    result = result.concat(root_note)
    result = result.concat(")")

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    return result
}

canonical_mode := proc(mode_arg: Str) returns Str {
    mut lower := mode_arg.to_lowercase()

    switch lower {
    case "ionian":      return "ionian"
    case "jonico":      return "ionian"
    case "jonio":       return "ionian"

    case "dorian":      return "dorian"
    case "dorico":      return "dorian"

    case "phrygian":    return "phrygian"
    case "frigio":      return "phrygian"

    case "lydian":      return "lydian"
    case "lidio":       return "lydian"

    case "mixolydian":  return "mixolydian"
    case "mixolidio":   return "mixolydian"

    case "aeolian":     return "aeolian"
    case "eolico":      return "aeolian"
    case "eolio":       return "aeolian"

    case "locrian":     return "locrian"
    case "locrio":      return "locrian"

    case:
        return ""
    }
}

mode_index_from_canonical := proc(canonical: Str) returns I64 {
    switch canonical {
    case "ionian":     return 0
    case "dorian":     return 1
    case "phrygian":   return 2
    case "lydian":     return 3
    case "mixolydian": return 4
    case "aeolian":    return 5
    case "locrian":    return 6
    case:              neg_one := I64.sub(0, 1)
    return neg_one
    }
}

localized_mode_name := proc(canonical: Str, lang: Str) returns Str {
    mut lower_lang := lang.to_lowercase()

    switch canonical {
    case "ionian":
        switch lower_lang {
        case "en": return "Ionian (Major)"
        case "es": return "Jonico (Mayor)"
        case "pt": return "Jonio (Maior)"
        case:      return "Jonio (Maior)"
        }

    case "dorian":
        switch lower_lang {
        case "en": return "Dorian"
        case "es": return "Dorico"
        case "pt": return "Dorico"
        case:      return "Dorico"
        }

    case "phrygian":
        switch lower_lang {
        case "en": return "Phrygian"
        case "es": return "Frigio"
        case "pt": return "Frigio"
        case:      return "Frigio"
        }

    case "lydian":
        switch lower_lang {
        case "en": return "Lydian"
        case "es": return "Lidio"
        case "pt": return "Lidio"
        case:      return "Lidio"
        }

    case "mixolydian":
        switch lower_lang {
        case "en": return "Mixolydian"
        case "es": return "Mixolidio"
        case "pt": return "Mixolidio"
        case:      return "Mixolidio"
        }

    case "aeolian":
        switch lower_lang {
        case "en": return "Aeolian (Natural Minor)"
        case "es": return "Eolico (Menor Natural)"
        case "pt": return "Eolio (Menor Natural)"
        case:      return "Eolio (Menor Natural)"
        }

    case "locrian":
        switch lower_lang {
        case "en": return "Locrian"
        case "es": return "Locrio"
        case "pt": return "Locrio"
        case:      return "Locrio"
        }

    case:
        return "Unknown mode"
    }
}

// Returns the triad type based on intervals from root to 3rd and 3rd to 5th
// mayor: 4+3, menor: 3+4, aumentado: 4+4, disminuido: 3+3
get_triad_type := func(interval_to_3rd: I64, interval_to_5th: I64) returns Str {
    if interval_to_3rd.eq(4).and(interval_to_5th.eq(7)) {
        return "mayor"
    } else if interval_to_3rd.eq(3).and(interval_to_5th.eq(7)) {
        return "menor"
    } else if interval_to_3rd.eq(4).and(interval_to_5th.eq(8)) {
        return "aumentado"
    } else if interval_to_3rd.eq(3).and(interval_to_5th.eq(6)) {
        return "disminuido"
    }
    return "?"
}

// Get the roman numeral for a scale degree (1-7)
get_roman := func(degree: I64, triad_type: Str) returns Str {
    mut roman := ""
    switch degree {
    case 1: roman = "I"
    case 2: roman = "II"
    case 3: roman = "III"
    case 4: roman = "IV"
    case 5: roman = "V"
    case 6: roman = "VI"
    case 7: roman = "VII"
    case: roman = "?"
    }
    // Lowercase for minor/diminished
    if triad_type.eq("menor").or(triad_type.eq("disminuido")) {
        roman = roman.to_lowercase()
    }
    return roman
}

// Build triads for a scale and print them grouped by type
print_triads := proc(root_idx: I64, root_diatonic: I64, steps: Vec, _lang: Str) {
    // Build array of chromatic positions for each scale degree
    mut scale_chromatic := Vec.new(I64)
    mut scale_diatonic := Vec.new(I64)
    mut chromatic_pos := root_idx
    mut diatonic_pos := root_diatonic

    mut k := 0
    while k.lt(7) {
        scale_chromatic.push(chromatic_pos)
        scale_diatonic.push(diatonic_pos)
        mut step := 0
        steps.get(k, step)?
        chromatic_pos = chromatic_pos.add(step).mod(12)
        diatonic_pos = diatonic_pos.add(1).mod(7)
        k = k.add(1)
    }

    // Collect triads by type
    mut mayor_triads := Vec.new(Str)
    mut menor_triads := Vec.new(Str)
    mut aumentado_triads := Vec.new(Str)
    mut disminuido_triads := Vec.new(Str)

    mut degree := 0
    while degree.lt(7) {
        // Get chromatic positions for root, 3rd, 5th of this triad
        mut root_chrom := 0
        mut third_chrom := 0
        mut fifth_chrom := 0
        scale_chromatic.get(degree, root_chrom)?
        scale_chromatic.get(degree.add(2).mod(7), third_chrom)?
        scale_chromatic.get(degree.add(4).mod(7), fifth_chrom)?

        // Get diatonic positions for note names
        mut root_dia := 0
        mut third_dia := 0
        mut fifth_dia := 0
        scale_diatonic.get(degree, root_dia)?
        scale_diatonic.get(degree.add(2).mod(7), third_dia)?
        scale_diatonic.get(degree.add(4).mod(7), fifth_dia)?

        // Calculate intervals
        mut interval_to_3rd := third_chrom.sub(root_chrom)
        if interval_to_3rd.lt(0) {
            interval_to_3rd = interval_to_3rd.add(12)
        }
        mut interval_to_5th := fifth_chrom.sub(root_chrom)
        if interval_to_5th.lt(0) {
            interval_to_5th = interval_to_5th.add(12)
        }

        triad_type := get_triad_type(interval_to_3rd, interval_to_5th)
        roman := get_roman(degree.add(1), triad_type)

        // Format the triad notes
        root_note := format_note(root_dia, root_chrom)
        third_note := format_note(third_dia, third_chrom)
        fifth_note := format_note(fifth_dia, fifth_chrom)

        mut triad_str := root_note.concat("-")
        triad_str = triad_str.concat(third_note)
        triad_str = triad_str.concat("-")
        triad_str = triad_str.concat(fifth_note)
        triad_str = triad_str.concat(" (")
        triad_str = triad_str.concat(roman)
        triad_str = triad_str.concat(")")

        // Add to appropriate list
        if triad_type.eq("mayor") {
            mayor_triads.push(triad_str)
        } else if triad_type.eq("menor") {
            menor_triads.push(triad_str)
        } else if triad_type.eq("aumentado") {
            aumentado_triads.push(triad_str)
        } else if triad_type.eq("disminuido") {
            disminuido_triads.push(triad_str)
        }

        degree = degree.add(1)
    }

    // Print grouped by type
    println("")
    println("Triades:")

    // Helper to print a triad list
    print_triad_line("  Mayor: ", mayor_triads)
    print_triad_line("  Menor: ", menor_triads)
    print_triad_line("  Disminuido: ", disminuido_triads)
    print_triad_line("  Aumentado: ", aumentado_triads)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

print_triad_line := proc(label: Str, triads: Vec) {
    mut line := label
    if triads.len().eq(0) {
        line = line.concat("-")
    } else {
        mut i := 0
        while i.lt(triads.len()) {
            if i.gt(0) {
                line = line.concat(", ")
            }
            mut t := ""
            triads.get(i, t)?
            line = line.concat(t)
            i = i.add(1)
        }
    }
    println(line)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

print_scale := proc(mode_arg: Str, root_arg: Str, lang: Str, show_triads: Bool) {
    mut canon := canonical_mode(mode_arg)
    if canon.eq("") {
        msg := "Unknown mode: "
        println(msg.concat(mode_arg))
        println("Try: jonio ionian jonico dorico dorian frigio phrygian lidio lydian mixolidio mixolydian eolio aeolian locrio locrian")
        return
    }

    mut mode_index := mode_index_from_canonical(canon)
    mut mode_name := localized_mode_name(canon, lang)

    // Parse root note with suffix accidentals (e.g., "fa#", "sib", "solx")
    // 'x' is a workaround for '#' which causes issues in test filenames
    mut acc := ""
    mut base := ""
    mut i := 0
    input := root_arg.to_lowercase()
    // Find where accidentals start (first #, x, or b after the note name)
    while i.lt(input.len()) {
        ch := input.get_char(i)?
        if ch.eq("#").or(ch.eq("x")).or(ch.eq("b")) {
            break
        }
        i = i.add(1)
    }
    base = input.get_substr(0, i)?
    acc = input.get_substr(i, input.len())?

    root_diatonic := get_diatonic_index(base)
    if root_diatonic.lt(0) {
        msg2 := "Invalid base note: "
        println(msg2.concat(base))
        println("Use: do re mi fa sol la si")
        return
    }

    base_idx := diatonic_to_chromatic(root_diatonic)
    root_idx := apply_accidentals(base_idx, acc)

    mut steps := Vec.new(I64)
    mode_intervals.get(mode_index, steps)?

    scale_str := generate_scale(root_idx, root_diatonic, steps)

    header := mode_name.concat(" starting on ")
    header2 := header.concat(root_arg)
    println(header2.concat(":"))
    println(scale_str)

    if show_triads {
        print_triads(root_idx, root_diatonic, steps, lang)
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}

usage := proc(lang: Str) {
    mut lower_lang := lang.to_lowercase()
    if lower_lang.eq("en") {
        println("Usage: ./bin/til music.til [-lang=pt|en|es] [--triades] <mode> [root]")
        println("Examples:")
        println("  ./bin/til music.til ionian do")
        println("  ./bin/til music.til -lang=en lydian fax")
        println("  ./bin/til music.til --triades dorian re")
    } else if lower_lang.eq("es") {
        println("Uso: ./bin/til music.til [-lang=pt|en|es] [--triades] <modo> [raiz]")
        println("Ejemplos:")
        println("  ./bin/til music.til jonico do")
        println("  ./bin/til music.til -lang=es lidio fax")
        println("  ./bin/til music.til --triades dorico re")
    } else {  // pt
        println("Uso: ./bin/til music.til [-lang=pt|en|es] [--triades] <modo> [raiz]")
        println("Exemplos:")
        println("  ./bin/til music.til jonio do")
        println("  ./bin/til music.til -lang=pt lidio fax")
        println("  ./bin/til music.til --triades dorico re")
    }
}

main := proc(args: ..Str) {
    mut lang := "pt"
    mut mode_arg := ""
    mut root_arg := "do"
    mut show_triads := false

    for arg: Str in args {
        mut lower_arg := arg.to_lowercase()

        if lower_arg.starts_with("-lang=") {
            mut val := lower_arg.get_substr(6, lower_arg.len())?

            switch val {
            case "pt": lang = "pt"
            case "en": lang = "en"
            case "es": lang = "es"
            case:
                warn1 := "TODO: unsupported language '"
                warn2 := warn1.concat(val)
                println(warn2.concat("' - using pt"))
            }

            continue
        }

        if lower_arg.eq("--triades").or(lower_arg.eq("--triads")) {
            show_triads = true
            continue
        }

        if mode_arg.eq("") {
            mode_arg = arg
        } else if root_arg.eq("do") {
            root_arg = arg
        }
    }

    if or(mode_arg.eq(""), mode_arg.eq("help")) {
        usage(lang)
        return
    }

    print_scale(mode_arg, root_arg, lang, show_triads)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
}
