mode test

test_lolalalo : proc() = {
    /**
     * Generate all 4-syllable permutations of s1 and s2
     * Plus variants with "lei" as the third syllable
     */
    make_poem_recursive : func(s1: Str, s2: Str) returns Str = {

        /** Recursively build all permutations.
         *  At depth 2 (third syllable), include "lei" as third option. */
        poem : func(depth: I64, current: Str, s1: Str, s2: Str) returns Str = {
            if depth.eq(4) {
                return current.concat("\n")
            }

            mut result := ""
            result = result.concat(poem(depth.add(1), current.concat(s1), s1, s2))
            result = result.concat(poem(depth.add(1), current.concat(s2), s1, s2))

            if depth.eq(2) {
                result = result.concat(poem(depth.add(1), current.concat("lei"), s1, s2))
            }

            return result
        }

        return poem(0, "", s1, s2)
    }

    make_poem_iterative : func(own s1: Str, own s2: Str) returns Str = {
        mut poem := ""
        mut silabes := Array.new(Str, 2)
        silabes.set(0, own s1)?
        silabes.set(1, own s2)?

        verse : func(i0: I64, i1: I64, i2: I64, i3: I64, silabes: Array) returns Str = {
            s0 := cast(Str, silabes.get(i0)?)
            s1_v := cast(Str, silabes.get(i1)?)
            mut s2_v := ""
            if i2.eq(2) {
                s2_v = "lei"
            } else {
                s2_v_alias := cast(Str, silabes.get(i2)?)
                s2_v = s2_v_alias
            }
            s3 := cast(Str, silabes.get(i3)?)

            catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

            return s0.concat(s1_v).concat(s2_v).concat(s3).concat("\n")
        }

        /** All permutations with "lei" interleaved at position 2 */
        for i0 in 0..2 {
            for i1 in 0..2 {
                for i2 in 0..3 {
                    for i3 in 0..2 {
                        poem = poem.concat(verse(i0, i1, i2, i3, silabes))
                    }
                }
            }
        }

        catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }

        return poem
    }

    // Issue #89: pure func calls now folded inside function bodies too
    recursive_lo_la := make_poem_recursive("lo", "la")
    iterative_lo_la := make_poem_iterative(own "lo", own "la")
    recursive_la_lo := make_poem_recursive("la", "lo")
    iterative_la_lo := make_poem_iterative(own "la", own "lo")

    if Str.eq(recursive_lo_la, iterative_lo_la) {
        println("PASS: recursive and iterative produce same output for lo la")
        println("\nPara lola:")
        println(recursive_lo_la)
    } else {
        println("FAIL: outputs differ for lo la")
        println("=== Recursive ===")
        println(recursive_lo_la)
        println("=== Iterative ===")
        println(iterative_lo_la)
    }

    if Str.eq(recursive_la_lo, iterative_la_lo) {
        println("PASS: recursive and iterative produce same output for la lo")
        println("\nPara lalo:")
        println(recursive_la_lo)
    } else {
        println("FAIL: outputs differ for la lo")
        println("=== Recursive ===")
        println(recursive_la_lo)
        println("=== Iterative ===")
        println(iterative_la_lo)
    }
}

test_lolalalo()
