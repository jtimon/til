// til2rs.til - TIL to Rust translator
// Translates TIL code to Rust
// Grows incrementally - only handles what's been tested

mode cli

import("core.vec")
import("std.io")
import("tools.lex.lex")

// TIL reserved words
get_til_reserved := func() returns Vec throws AllocError {
    mut words := Vec.new(Str)
    words.push("mode")
    words.push("import")
    words.push("struct")
    words.push("func")
    words.push("proc")
    words.push("if")
    words.push("else")
    words.push("while")
    words.push("for")
    words.push("in")
    words.push("switch")
    words.push("case")
    words.push("return")
    words.push("throw")
    words.push("catch")
    words.push("mut")
    words.push("true")
    words.push("false")
    words.push("and")
    words.push("or")
    words.push("not")
    return words
}

// Translator state
TranslatorState := struct {
    mut tokens: Vec = Vec.new(Token)
    mut pos: I64 = 0
    mut mode_name: Str = ""
}

// Check if at end
is_eof := func(state: TranslatorState) returns Bool {
    if state.pos.gteq(state.tokens.len()) {
        return true
    }
    mut t := Token()
    state.tokens.get(state.pos, t)
    switch t.token_type {
    case TokenType.Eof:
        return true
    case:
        return false
    }
    catch (err: IndexOutOfBoundsError) {
        return true
    }
}

// Peek current token
peek := func(state: TranslatorState) returns Token {
    mut t := Token()
    state.tokens.get(state.pos, t)
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    return t
}

// Advance to next token
next_token := proc(mut state: TranslatorState) returns Token {
    mut t := Token()
    state.tokens.get(state.pos, t)
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    state.pos = state.pos.add(1)
    return t
}

// Check if current token is a specific reserved word
check_reserved := func(state: TranslatorState, word: Str) returns Bool {
    if state.pos.gteq(state.tokens.len()) {
        return false
    }
    t := peek(state)
    switch t.token_type {
    case TokenType.Reserved:
        return t.token_str.eq(word)
    case:
        return false
    }
}

// Translate mode declaration
translate_mode := proc(mut state: TranslatorState) returns Str {
    // Skip 'mode'
    _ := next_token(state)

    // Get mode name
    mode_token := next_token(state)
    state.mode_name = mode_token.token_str

    // mode script -> fn main() {}
    // mode lib -> (nothing needed)
    return ""
}

// Generate Rust output based on mode
generate_output := func(state: TranslatorState) returns Str {
    m := state.mode_name
    if m.eq("script") {
        return "fn main() {}\n"
    }
    if m.eq("cli") {
        return "fn main() {}\n"
    }
    // lib, pure, etc - no main needed
    return ""
}

// Translate source code
translate := proc(source: Str) returns Str throws Str {
    reserved := get_til_reserved()
    tokens := scan_tokens(source, reserved)
    catch (err: AllocError) { throw err.msg }

    mut state := TranslatorState()
    state.tokens = tokens

    while not(is_eof(state)) {
        if check_reserved(state, "mode") {
            _ := translate_mode(state)
        } else {
            t := next_token(state)
            throw format("Line ", t.line.to_str(), ": Unexpected token '", t.token_str, "'")
        }
    }

    output := generate_output(state)
    return output
}

// Main entry point
main := proc(input_file: Str) {
    println("til2rs.til - TIL to Rust translator")
    println("Input: ", input_file)

    source := readfile(input_file)
    output := translate(source)

    println("")
    println("Output:")
    println(output)

    catch (err: Str) {
        println("Error: ", err)
        exit(1)
    }
}
