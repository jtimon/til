#!/usr/bin/env -S ./bin/rstil run
mode cli

import("std.sys")
import("std.io")

// Global flag: --cc=COMPILER override (Issue #131)
mut g_cc := ""

// Global flag: enable heap memory profiling for compiled tests (set by --mem-report arg)
mut g_mem_report := false

// test_runner.til - Single test executor
// Called by tests.til for parallel execution
//
// Usage: test_runner <command> <mode> <out_mode> <expected_status> <file> [args...]
//
// Commands:
//   test  - Run test. If .out file missing, generate it. Then compare output.
//   regen - Run test and write .out file (always, regardless of whether it exists).
//
// Modes: rs_interpreted, rs_compiled, til_interpreted, til_compiled
// out_mode: Which .out file to compare against (e.g., rs_interpreted, til_interpreted)
// For "common" tests, tests.til calls this twice with different modes.
//
// Output file naming: gen/out/<path_without_src>.<mode>.<args_with_underscores>.actual.out
// Example: gen/out/test/foo.rs_interpreted.actual.out
// Example: gen/out/til.rs_interpreted.help.actual.out

// Parse wall-clock time from /usr/bin/time -v output
// Looks for "Elapsed (wall clock) time (h:mm:ss or m:ss): M:SS.SS"
// Format: m:ss.ss (under 1 hour) or h:mm:ss (over 1 hour)
// Returns milliseconds, or -1 if parsing fails
parse_time_ms := func(time_output: Str) returns I64 throws IndexOutOfBoundsError {
    lines := time_output.split("\n")?
    for line: Str in lines {
        if line.find("Elapsed (wall clock)").gt(I64_MINUS1) {
            // Extract value after last ": "
            parts := line.split(": ")?
            if parts.len().gt(1) {
                ts := cast(Str, parts.get(parts.len().sub(1))?)
                mut time_str := Str.replace(ts, "\r", "")
                // Find first colon (separates minutes from seconds, or hours from minutes)
                colon_pos := time_str.find(":")
                if colon_pos.lt(0) {
                    return I64_MINUS1
                }
                dot_pos := time_str.find(".")
                if dot_pos.gt(0) {
                    // m:ss.ss format (under 1 hour)
                    min_str := get_substr(time_str, 0, colon_pos)?
                    sec_str := get_substr(time_str, colon_pos.add(1), dot_pos)?
                    frac_str := get_substr(time_str, dot_pos.add(1), time_str.len())?
                    // Pad or truncate frac to 3 digits for ms
                    mut frac := frac_str
                    while frac.len().lt(3) {
                        frac = frac.concat("0")
                    }
                    if frac.len().gt(3) {
                        frac = get_substr(frac, 0, 3)?
                    }
                    return min_str.to_i64().mul(60000).add(sec_str.to_i64().mul(1000)).add(frac.to_i64())
                } else {
                    // h:mm:ss format (over 1 hour, no fractional seconds)
                    after_first := get_substr(time_str, colon_pos.add(1), time_str.len())?
                    second_colon := after_first.find(":")
                    if second_colon.gt(0) {
                        hour_str := get_substr(time_str, 0, colon_pos)?
                        hms_min_str := get_substr(after_first, 0, second_colon)?
                        hms_sec_str := get_substr(after_first, second_colon.add(1), after_first.len())?
                        return hour_str.to_i64().mul(3600000).add(hms_min_str.to_i64().mul(60000)).add(hms_sec_str.to_i64().mul(1000))
                    }
                }
            }
        }
    }
    return I64_MINUS1
}

// Parse max RSS from /usr/bin/time -v output
// Looks for "Maximum resident set size (kbytes): N"
// Returns kilobytes, or -1 if parsing fails
parse_maxrss_kb := func(time_output: Str) returns I64 throws IndexOutOfBoundsError {
    lines := time_output.split("\n")?
    for line: Str in lines {
        if line.find("Maximum resident set size").gt(I64_MINUS1) {
            parts := line.split(": ")?
            if parts.len().gt(1) {
                vs := cast(Str, parts.get(parts.len().sub(1))?)
                mut val_str := vs.replace("\r", "")
                return val_str.to_i64()
            }
        }
    }
    return I64_MINUS1
}

// Format milliseconds as "0.042s"
format_time := func(ms: I64) returns Str {
    if ms.lt(0) {
        return "N/A"
    }
    secs := ms.div(1000)
    millis := ms.mod(1000)
    mut millis_str := millis.to_str()
    while millis_str.len().lt(3) {
        millis_str = concat("0", millis_str)
    }
    return secs.to_str().concat(".").concat(millis_str).concat("s")
}

// Generate unique actual output file path
// path: src/test/foo.til -> gen/out/test/foo
// mode: rs_interpreted, til_compiled, etc.
// args: "help" -> ".help", "help foo" -> ".help_foo", "" -> ""
get_actual_path := func(path: Str, test_mode: Str, cmd_args: Str) returns Str {
    // Convert src/test/foo.til -> gen/out/test/foo
    base := path.replace(".til", "").replace("src/", "gen/out/")

    mut args_part := ""
    if cmd_args.len().gt(0) {
        // Replace spaces with underscores for filename safety
        args_part = concat(".", cmd_args.replace(" ", "_"))
    }

    return format(base, ".", test_mode, args_part, ".actual.out")
}

// Get expected .out file path (same as tests.til's get_out_path)
// For common tests, both modes compare against .interpreted.out
get_expected_path := func(path: Str, test_mode: Str, cmd_args: Str) returns Str {
    base := path.replace(".til", "").replace("src/", "gen/out/")
    mut suffix := ""
    if not(cmd_args.eq("")) {
        suffix = concat(".", cmd_args.replace(" ", "."))
    }
    return base.concat(suffix).concat(".").concat(test_mode).concat(".out")
}

// Format expected file content
format_expected := func(cmd_args: Str, exit_code: I64, output: Str) returns Str {
    mut result := "args: "
    result = result.concat(cmd_args).concat("\n")
    result = result.concat("expected_status: ").concat(exit_code.to_str()).concat("\n")
    result = result.concat("output:\n")
    result = result.concat(output)
    return result
}

// Get command prefix for running a test
// Bug #141: Use bin/rs/til (til built by rstil) for til modes
// Issue #131: Include --cc flag for compiled modes
get_cmd_prefix := func(test_mode: Str) returns Str {
    // Build --cc suffix for compiled modes
    mut cc_suffix := ""
    if not(g_cc.is_empty()) {
        cc_suffix = concat(" --cc=", g_cc)
    }

    switch test_mode {
    case "rs_interpreted":
        return "./bin/rstil interpret "
    case "rs_compiled":
        return concat("./bin/rstil run", cc_suffix).concat(" ")
    case "til_interpreted":
        return "./bin/rs/til interpret "
    case "til_compiled":
        return concat("./bin/rs/til run", cc_suffix).concat(" ")
    case:
        return ""
    }
}

// Get build command prefix for compiled modes
// Returns "" for interpreted modes (no build step needed)
get_build_prefix := func(test_mode: Str) returns Str {
    mut cc_suffix := ""
    if not(g_cc.is_empty()) {
        cc_suffix = concat(" --cc=", g_cc)
    }

    switch test_mode {
    case "rs_compiled":
        return concat("./bin/rstil build", cc_suffix).concat(" ")
    case "til_compiled":
        return concat("./bin/rs/til build", cc_suffix).concat(" ")
    case:
        return ""
    }
}

// Run a command with timing, returns exit code and stores time/maxrss
// Output goes to mut output param, time goes to mut time_ms param
// Linux: /usr/bin/time -v for wall-clock time and max RSS
// macOS: bash builtin time with TIMEFORMAT for wall-clock time (no RSS)
run_timed := proc(mut output: Str, mut time_ms: I64, mut maxrss_kb: I64, cmd: Str) returns I64 {
    // Build wrapped command based on OS
    mut wrapped := ""
    if g_is_linux {
        wrapped = format("LC_ALL=C time -v bash -c '", cmd, "' 2>&1")
    } else {
        // Group braces + 2>&1 needed so bash time stderr output gets captured
        wrapped = format("{ TIMEFORMAT=%3R; time bash -c '", cmd, "'; } 2>&1")
    }
    mut full_output := ""
    exit_code := full_output.run_cmd("bash", "-c", wrapped)

    if g_is_linux {
        // Linux: parse GNU time output using markers
        max_output := 2000
        mut truncated := full_output
        if truncated.len().gt(max_output) {
            start_pos := truncated.len().sub(max_output)
            truncated = get_substr(truncated, start_pos, truncated.len())?
        }

        time_pos := truncated.find("Command being timed")
        exit_pos := truncated.find("Command exited with non-zero")

        mut output_split := time_pos
        mut backup := 1  // back up past \t before "Command being timed"
        if exit_pos.gt(I64_MINUS1) {
            if output_split.lt(0).or(exit_pos.lt(output_split)) {
                output_split = exit_pos
                backup = 0  // "Command exited" has no \t prefix, just \n before it
            }
        }

        if output_split.gt(I64_MINUS1) {
            mut output_end_in_truncated := output_split.sub(backup)
            if output_end_in_truncated.lt(0) {
                output_end_in_truncated = 0
            }
            output_end_in_full := full_output.len().sub(truncated.len()).add(output_end_in_truncated)
            if output_end_in_full.gt(0) {
                output = get_substr(full_output, 0, output_end_in_full)?
            } else {
                output = ""
            }
            if time_pos.gt(I64_MINUS1) {
                time_output := get_substr(truncated, time_pos, truncated.len())?
                time_ms = parse_time_ms(time_output)?
                maxrss_kb = parse_maxrss_kb(time_output)?
            }
        } else {
            output = full_output
            time_ms = I64_MINUS1
            maxrss_kb = I64_MINUS1
        }
    } else {
        // macOS: last line is time value (e.g., "0.042"), no RSS available
        maxrss_kb = I64_MINUS1
        // Strip trailing newline
        mut trimmed := full_output
        if trimmed.len().gt(0) {
            if trimmed.get_char(trimmed.len().sub(1))?.eq("\n") {
                trimmed = get_substr(trimmed, 0, trimmed.len().sub(1))?
            }
        }
        // Find last newline by scanning from end
        mut last_nl := I64_MINUS1
        mut ci := trimmed.len().sub(1)
        while ci.gt(I64_MINUS1) {
            if trimmed.get_char(ci)?.eq("\n") {
                last_nl = ci
                break
            }
            ci = ci.sub(1)
        }
        if last_nl.gt(I64_MINUS1) {
            output = get_substr(full_output, 0, last_nl.add(1))?
            time_line := get_substr(trimmed, last_nl.add(1), trimmed.len())?.replace("\r", "")
            // Parse "N.NNN" as milliseconds
            dot_pos := time_line.find(".")
            if dot_pos.gt(I64_MINUS1) {
                sec_str := get_substr(time_line, 0, dot_pos)?
                frac_str := get_substr(time_line, dot_pos.add(1), time_line.len())?
                mut frac := frac_str
                while frac.len().lt(3) {
                    frac = frac.concat("0")
                }
                if frac.len().gt(3) {
                    frac = get_substr(frac, 0, 3)?
                }
                time_ms = sec_str.to_i64().mul(1000).add(frac.to_i64())
            } else {
                time_ms = I64_MINUS1
            }
        } else {
            // No newline found - no program output, just time (or can't parse)
            output = ""
            time_ms = I64_MINUS1
        }
    }

    catch (err: IndexOutOfBoundsError) {
        output = full_output
        time_ms = I64_MINUS1
        maxrss_kb = I64_MINUS1
    }

    return exit_code
}

// Ensure parent directory exists
ensure_parent_dir := proc(file_path: Str) {
    mut last_slash := 0
    for i in 0..file_path.len() {
        if file_path.get_char(i)?.eq("/") {
            last_slash = i
        }
    }
    if last_slash.gt(0) {
        dir := get_substr(file_path, 0, last_slash)?
        mut result := ""
        _ := result.run_cmd("mkdir", "-p", dir)
    }

    catch (err: IndexOutOfBoundsError) { /* ignore */ }
}

// Regenerate .out file for a test
do_regen := proc(test_mode: Str, out_mode: Str, file: Str, cmd_args: Str) {
    cmd_prefix := get_cmd_prefix(test_mode)
    if cmd_prefix.eq("") {
        panic(loc(), format("Unknown mode '", test_mode, "'"))
    }
    mut cmd := cmd_prefix.concat(file)
    // Only add --mem-report for compiled modes (interpreted has no C runtime to handle it)
    if g_mem_report.and(test_mode.find("compiled").gt(I64_MINUS1)) {
        cmd = cmd.concat(" --mem-report")
    }
    if cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(cmd_args)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", cmd)
    // Strip HEAP_STATE report line from output
    heap_pos := output.find("\nHEAP_STATE:")
    if heap_pos.gt(I64_MINUS1) {
        output = get_substr(output, 0, heap_pos.add(1))?
    } else if output.starts_with("HEAP_STATE:") {
        output = ""
    }
    formatted := format_expected(cmd_args, exit_code, output)
    expected_path := get_expected_path(file, out_mode, cmd_args)
    ensure_parent_dir(expected_path)
    writefile(expected_path, formatted)?
    println("Regenerated: ", expected_path)

    catch (err: WriteError) { panic(loc(), err.msg) }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}

// Run test and compare against .out file (with timing)
// For compiled modes: builds first (timed separately), then runs (timed separately)
// Output format: PASS <build_ms> <run_ms> <maxrss_kb>
do_test := proc(test_mode: Str, out_mode: Str, expected_status: I64, file: Str, cmd_args: Str) {
    is_compiled := test_mode.find("compiled").gt(I64_MINUS1)

    // Step 1: Build (compiled modes only)
    mut build_ms := 0
    if is_compiled {
        build_prefix := get_build_prefix(test_mode)
        build_cmd := build_prefix.concat(file)
        mut build_output := ""
        mut build_time := 0
        mut build_maxrss := 0
        build_exit := run_timed(build_output, build_time, build_maxrss, build_cmd)
        build_ms = build_time

        if not(build_exit.eq(0)) {
            if not(expected_status.eq(0)) {
                // Build failure IS the expected error (e.g., compile-time error tests)
                // Use build output as the test output
                mut build_out := build_output
                build_exit_code := build_exit

                // Strip HEAP_STATE report line from output
                mut build_mem_report := ""
                build_heap_pos := build_out.find("\nHEAP_STATE:")
                if build_heap_pos.gt(I64_MINUS1) {
                    build_mem_report = get_substr(build_out, build_heap_pos.add(1), build_out.len())?
                    build_out = get_substr(build_out, 0, build_heap_pos.add(1))?
                } else if build_out.starts_with("HEAP_STATE:") {
                    build_mem_report = build_out
                    build_out = ""
                }

                // Check exit code matches expected
                if not(build_exit_code.eq(expected_status)) {
                    println("FAIL (exit code): ", file)
                    println("  mode: ", test_mode)
                    println("  expected: ", expected_status.to_str())
                    println("  actual: ", build_exit_code.to_str())
                    if build_out.len().gt(0) {
                        println("  output: ", build_out)
                    }
                    exit(1)
                }

                // Compare output against expected
                build_expected_path := get_expected_path(file, out_mode, cmd_args)
                mut build_args_str := ""
                if cmd_args.len().gt(0) {
                    build_args_str = cmd_args
                }
                build_formatted := format("args: ", build_args_str, "\nexpected_status: ", expected_status.to_str(), "\noutput:\n", build_out)
                if file_mtime(build_expected_path).lt(0) {
                    ensure_parent_dir(build_expected_path)
                    writefile(build_expected_path, build_formatted)?
                }
                build_expected := readfile(build_expected_path)?
                if not(build_formatted.eq(build_expected)) {
                    build_actual_path := get_actual_path(file, test_mode, cmd_args)
                    ensure_parent_dir(build_actual_path)
                    writefile(build_actual_path, build_formatted)?
                    mut build_diff := ""
                    _ := build_diff.run_cmd("diff", "-u", build_expected_path, build_actual_path)
                    println("FAIL (output): ", file)
                    println("  mode: ", test_mode)
                    println(build_diff)
                    exit(1)
                }

                // Success - build failure was the expected result
                // Format: PASS <build_ms> <build_maxrss_kb> <run_ms> <run_maxrss_kb>
                // run_ms=0 since we didn't run, run_maxrss=0
                if g_mem_report.and(build_mem_report.len().gt(0)) {
                    println("PASS ", build_ms.to_str(), " ", build_maxrss.to_str(), " 0 0 ", build_mem_report)
                } else {
                    println("PASS ", build_ms.to_str(), " ", build_maxrss.to_str(), " 0 0")
                }
                return
            }

            // Unexpected build failure
            println("FAIL (build): ", file)
            println("  mode: ", test_mode)
            println("  build exit code: ", build_exit.to_str())
            if build_output.len().gt(0) {
                println("  output: ", build_output)
            }
            exit(1)
        }
    }

    // Step 2: Run the test
    cmd_prefix := get_cmd_prefix(test_mode)
    if cmd_prefix.eq("") {
        panic(loc(), format("Unknown mode '", test_mode, "'"))
    }
    mut cmd := cmd_prefix.concat(file)
    // Only add --mem-report for compiled modes with expected_status=0
    // Error-status tests fail at compile time, no HeapState data to collect
    if g_mem_report.and(is_compiled).and(expected_status.eq(0)) {
        cmd = cmd.concat(" --mem-report")
    }
    if cmd_args.len().gt(0) {
        cmd = cmd.concat(" ").concat(cmd_args)
    }

    mut output := ""
    mut time_ms := 0
    mut maxrss_kb := 0
    exit_code := run_timed(output, time_ms, maxrss_kb, cmd)

    // Strip HEAP_STATE report line from output (appended by compiled programs when TIL_MEM_REPORT is set)
    mut mem_report_line := ""
    heap_pos := output.find("\nHEAP_STATE:")
    if heap_pos.gt(I64_MINUS1) {
        mem_report_line = get_substr(output, heap_pos.add(1), output.len())?
        output = get_substr(output, 0, heap_pos.add(1))?
    } else if output.starts_with("HEAP_STATE:") {
        mem_report_line = output
        output = ""
    }

    // Check exit code
    if not(exit_code.eq(expected_status)) {
        println("FAIL (exit code): ", file)
        println("  mode: ", test_mode)
        println("  expected: ", expected_status.to_str())
        println("  actual: ", exit_code.to_str())
        if output.len().gt(0) {
            println("  output: ", output)
        }
        exit(1)
    }

    // Compare output against expected
    expected_path := get_expected_path(file, out_mode, cmd_args)

    // Build formatted output (used for both auto-generation and comparison)
    mut args_str := ""
    if cmd_args.len().gt(0) {
        args_str = cmd_args
    }
    formatted := format("args: ", args_str, "\nexpected_status: ", expected_status.to_str(), "\noutput:\n", output)

    // Auto-generate .out file if missing (file_mtime returns -1 if file doesn't exist)
    if file_mtime(expected_path).lt(0) {
        ensure_parent_dir(expected_path)
        writefile(expected_path, formatted)?
        // Don't print here - stdout is captured for parsing "PASS <time>"
    }

    expected := readfile(expected_path)?

    if not(formatted.eq(expected)) {
        // Write actual output for diff
        actual_path := get_actual_path(file, test_mode, cmd_args)
        ensure_parent_dir(actual_path)
        writefile(actual_path, formatted)?

        mut diff_output := ""
        _ := diff_output.run_cmd("diff", "-u", expected_path, actual_path)

        println("FAIL (output): ", file)
        println("  mode: ", test_mode)
        println(diff_output)
        exit(1)
    }

    // Success - print timing info for tests.til to parse
    // Format: PASS <build_ms> <build_maxrss_kb> <run_ms> <run_maxrss_kb>
    if g_mem_report.and(mem_report_line.len().gt(0)) {
        println("PASS ", build_ms.to_str(), " ", build_maxrss.to_str(), " ", time_ms.to_str(), " ", maxrss_kb.to_str(), " ", mem_report_line)
    } else {
        println("PASS ", build_ms.to_str(), " ", build_maxrss.to_str(), " ", time_ms.to_str(), " ", maxrss_kb.to_str())
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: ReadError) { panic(loc(), err.msg) }
    catch (err: WriteError) { panic(loc(), err.msg) }
}

// test_mode: rs_interpreted, rs_compiled, til_interpreted, til_compiled
// out_mode: which .out file to compare against (e.g., rs_interpreted, til_interpreted)
main := proc(args: ..Str) {
    detect_os()

    if args.len().lt(5) {
        panic(loc(), "Usage: test_runner <command> <mode> <out_mode> <expected_status> <file> [args...]")
    }

    // Extract required args
    command := cast(Str, args.get(0)?)
    test_mode := cast(Str, args.get(1)?)
    out_mode := cast(Str, args.get(2)?)
    expected_status_str := cast(Str, args.get(3)?)
    file := cast(Str, args.get(4)?)

    expected_status := expected_status_str.to_i64()

    // Collect extra args into single string, filtering out --cc= (Issue #131)
    mut cmd_args := ""
    for i in 5..args.len() {
        arg := cast(Str, args.get(i)?)
        if arg.starts_with("--cc=") {
            g_cc = arg.get_substr(5, arg.len())?
        } else if arg.eq("--mem-report") {
            g_mem_report = true
        } else {
            if cmd_args.len().gt(0) {
                cmd_args = cmd_args.concat(" ")
            }
            cmd_args = cmd_args.concat(arg)
        }
    }

    // Check flag file for --mem-report (C runtime strips --mem-report from argv
    // before TIL main sees it, so make.til writes this flag file instead)
    if file_mtime("tmp/.mem_report_flag").gt(I64_MINUS1) {
        g_mem_report = true
    }

    switch command {
    case "regen":
        do_regen(test_mode, out_mode, file, cmd_args)
    case "test":
        do_test(test_mode, out_mode, expected_status, file, cmd_args)
    case:
        panic(loc(), format("Unknown command '", command, "'"))
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
