mode lib

import("core.bounds")
import("core.mem")
import("core.ptr")

/**
 * Array - Fixed-size array.
 * For growable arrays, use Vec instead.
 */
Array := struct {
    mut ptr       : Ptr  = Ptr()
    mut _len      : I64  = 0

namespace:
    /** Get number of elements in array. */
    len : func(self: Array) returns I64 = {
        return self._len
    }

    /** Get total size in bytes. */
    size : func(self: Array) returns I64 = {
        return mul(self._len, self.ptr.elem_size)
    }

    /** Create new array with specified element type and capacity. */
    new : proc(T: Type, capacity: I64) returns Array = {
        mut arr := Array()
        size_bytes := mul(capacity, size_of(T))
        // Use malloc directly (not Ptr.new_by_size) to avoid circular dependency:
        // panic -> Array.new (variadic args) -> Ptr.new_by_size -> panic
        mut p := Ptr()
        p.data = malloc(size_bytes)?
        catch (err: BadAlloc) { panic(loc(), "Array.new: malloc failed") }
        p.alloc_size = size_bytes
        p.elem_size = size_of(T)
        zero : U8 = 0
        memset(p.data, zero, size_bytes)
        arr.ptr = p
        arr._len = capacity
        return arr
    }

    /** Get borrowed Ptr to element at index. No copy - points into array memory. */
    get : proc(self: Array, index: I64) returns Ptr throws IndexOutOfBoundsError = {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Array.get: index out of bounds"))
        }
        return self.ptr.offset(mul(index, self.ptr.elem_size))
    }

    /** Set element at index. */
    set : proc(mut self: Array, index: I64, own value: Dynamic) throws IndexOutOfBoundsError = {
        dont_delete(value)
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Array.set: index out of bounds"))
        }

        mut dest := self.ptr.offset(mul(index, self.ptr.elem_size))
        dest.copy_from_dynamic(value, self.ptr.elem_size)
    }

    /** Free array memory. */
    delete : proc(mut self: Array) = {
        if not(self.ptr.is_null()) {
            self.ptr.delete()
        }
        self._len = 0
    }

    /** Clone the array. */
    clone : func(self: Array) returns Array = {
        mut cloned := Array()
        cloned._len = self._len
        mut total_bytes := mul(self._len, self.ptr.elem_size)
        // Use malloc directly (not Ptr.new_by_size) to avoid circular dependency
        mut p := Ptr()
        p.data = malloc(total_bytes)?
        catch (err: BadAlloc) { panic(loc(), "Array.clone: malloc failed") }
        p.alloc_size = total_bytes
        p.elem_size = self.ptr.elem_size
        memcpy(p.data, self.ptr.data, total_bytes)
        cloned.ptr = p
        return cloned
    }

    /** Check if array contains value (for Str arrays). */
    contains : proc(self: Array, value: Str) returns Bool = {
        for elem: Str in self {
            if elem.eq(value) {
                return true
            }
        }
        return false
    }
}
