mode lib

import("src.core.mem")

print := proc(args: ..Str) {
    for i in 0..args.len() {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "print: IndexOutOfBoundsError should never happen")
    }
}

println := proc(args: ..Str) {
    for i in 0..args.len() {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    single_print("\n")
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "println: IndexOutOfBoundsError should never happen")
    }
}

/** Str - String type with c_string pointer and capacity. */
// TODO get rid of special cases for Str besides literals
Str := struct {
    mut c_string : I64 = 0
    mut cap      : I64 = 0
    // mut len : I64 = 0 // TODO make sure double declarations inside the same struct give type errors

    len := func(self: Str) returns I64 {
        return self.cap
    }

    eq := func(self: Str, other: Str) returns Bool {
        if not(self.cap.eq(other.cap)) {
            return false
        }

        for i in 0..self.cap {
            mut self_byte  : U8 = 0
            mut other_byte : U8 = 0
            memcpy(to_ptr(self_byte), add(self.c_string, i), 1)
            memcpy(to_ptr(other_byte), add(other.c_string, i), 1)

            if not(U8.eq(self_byte, other_byte)) {
                return false
            }
        }

        return true
    }

    to_i64 := func(self: Str) returns I64 {
        return I64.from_str(self)
    }

    clone := func(self: Str) returns Str throws AllocError {
        mut cloned := Str()
        cloned.cap = self.cap
        cloned.c_string = malloc(cloned.cap)
        if NULL.eq(cloned.c_string) {
            throw AllocError.new(format(loc(), "Str.clone: malloc failed for ", I64.to_str(cloned.cap), " bytes"))
        }
        memcpy(cloned.c_string, self.c_string, self.cap)
        return cloned
    }

    size := func(self: Str) returns I64 {
        return self.cap
    }
}

/** Get a substring from start (inclusive) to end (exclusive). */
get_substr := func(s: Str, start: I64, end: I64) returns Str throws IndexOutOfBoundsError, AllocError {

    if start.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " cannot be negative"))
    }
    if end.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " cannot be negative"))
    }
    if start.gt(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " is greater than end index ", end.to_str()))
    }
    if end.gt(s.len()) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " is greater than string length ", I64.to_str(s.len())))
    }
    if start.eq(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start and end are the same (", start.to_str(), "), no substring"))
    }

    mut substr := Str()
    substr.cap = end.sub(start)
    substr.c_string = malloc(substr.cap)
    if NULL.eq(substr.c_string) {
        throw AllocError.new(format(loc(), "Str.get_substr: failed to allocate ", I64.to_str(substr.cap), " bytes"))
    }
    memcpy(substr.c_string, add(s.c_string, start), substr.cap)

    return substr
}

/** Get a single character at position pos as a Str. */
get_char := func(s: Str, pos: I64) returns Str throws IndexOutOfBoundsError, AllocError {
    return s.get_substr(pos, add(pos, 1))
}

/**
 * Simple 2-argument string concatenation that panics on error.
 * Use this in catch blocks where throwing is not allowed.
 */
concat := func(a: Str, b: Str) returns Str {
    mut result := Str()
    result.cap = add(a.cap, b.cap)

    if lt(result.cap, a.cap) {
        panic(loc(), "concat: integer overflow")
    }

    result.c_string = malloc(result.cap)
    if NULL.eq(result.c_string) {
        panic(loc(), "concat: malloc failed")
    }

    memcpy(result.c_string, a.c_string, a.cap)
    memcpy(add(result.c_string, a.cap), b.c_string, b.cap)

    catch (err: AllocError) {
        panic(loc(), err.msg)
    }

    return result
}

/** Format a prefix with variadic string arguments, concatenating them all. */
format := func(prefix: Str, args: ..Str) returns Str throws I64_OverflowError, IndexOutOfBoundsError, AllocError {
    mut result := Str()
    result.cap = prefix.cap

    for i in 0..args.len() {
        mut arg := ""
        args.get(i, arg)
        result.cap = add(result.cap, arg.cap)
        if lt(result.cap, arg.cap) {
            throw I64_OverflowError.new(format(loc(), "format: integer overflow while summing cap for arg ", i.to_str()))
        }
    }

    result.c_string = malloc(result.cap)
    if NULL.eq(result.c_string) {
        throw AllocError.new(format(loc(), "format: malloc failed for cap = ", I64.to_str(result.cap)))
    }

    mut offset := 0
    memcpy(result.c_string, prefix.c_string, prefix.cap)
    offset = prefix.cap

    for i in 0..args.len() {
        mut s := ""
        args.get(i, s)
        memcpy(add(result.c_string, offset), s.c_string, s.cap)
        offset = add(offset, s.cap)
    }

    return result
}
