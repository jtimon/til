mode liba

import("core.bounds")
import("core.mem")
import("core.ptr")
import("core.vec")

/** Str - String type with c_string pointer, length, and capacity. */
// TODO get rid of special cases for Str besides literals
Str := struct {
    mut c_string : Ptr = Ptr()  // Pointer to null-terminated C string
    mut _len     : I64 = 0      // Length of string (not including null terminator)
    mut cap      : I64 = 0      // Allocated capacity (0 = literal/unowned, >0 = owned)

namespace:
    len : func(self: Str) returns I64 = {
        return self._len
    }

    is_empty : func(self: Str) returns Bool = {
        return self._len.eq(0)
    }

    eq : func(self: Str, other: Str) returns Bool = {
        if not(self._len.eq(other._len)) {
            return false
        }

        for i in 0..self._len {
            mut self_byte  : U8 = 0
            mut other_byte : U8 = 0
            memcpy(to_ptr(self_byte), self.c_string.offset(i).data, 1)
            memcpy(to_ptr(other_byte), other.c_string.offset(i).data, 1)

            if not(U8.eq(self_byte, other_byte)) {
                return false
            }
        }

        return true
    }

    to_i64 : func(self: Str) returns I64 = {
        return I64.from_str(self)
    }

    clone : func(self: Str) returns Str = {
        mut cloned := Str()
        cloned._len = self._len
        cloned.cap = cloned._len.add(1)  // Allocated capacity
        cloned.c_string = Ptr.new_by_size(cloned.cap)
        cloned.c_string.is_borrowed = 0
        cloned.c_string.copy_from(self.c_string, self._len)
        // Null-terminate the string
        zero : U8 = 0
        memset(cloned.c_string.offset(cloned._len).data, zero, 1)
        return cloned
    }

    delete : proc(mut self: Str) = {
        // Only free if the string is owned (cap > 0)
        if self.cap.gt(0) {
            self.c_string.delete()
        }
        self.c_string = Ptr()
        self._len = 0
        self.cap = 0
    }

    /// Convert a single byte to a 1-character string
    from_byte : func(byte: U8) returns Str = {
        mut s := Str()
        s.c_string = Ptr.new_by_size(2)  // 1 byte + null terminator
        s.c_string.is_borrowed = 0
        s._len = 1
        s.cap = 2
        memcpy(s.c_string.data, to_ptr(byte), 1)
        mut zero : U8 = 0
        memcpy(s.c_string.offset(1).data, to_ptr(zero), 1)
        return s
    }

    /** Append a string to self (mutates self). Equivalent to Rust's push_str. */
    push_str : proc(mut self: Str, s: Str) = {
        self = self.concat(s)
    }

    size : func(self: Str) returns I64 = {
        return self._len
    }

    /** Check if all characters in the string are uppercase (A-Z).
     *  Returns false for empty strings or strings containing non-uppercase chars.
     *  To check only the first character, use: str.get_substr(0, 1).is_uppercase()
     */
    is_uppercase : func(self: Str) returns Bool = {
        if self._len.eq(0) {
            return false
        }
        for i in 0..self._len {
            mut byte : U8 = 0
            memcpy(to_ptr(byte), self.c_string.offset(i).data, 1)
            // A = 65, Z = 90. Convert to I64 for comparison.
            mut byte_val : I64 = 0
            byte_val = U8.to_i64(byte)
            if byte_val.lt(65) {
                return false
            }
            if byte_val.gt(90) {
                return false
            }
        }
        return true
    }

    /** Convert string to lowercase (a-z).
     *  Only converts ASCII uppercase letters (A-Z to a-z).
     */
    to_lowercase : func(self: Str) returns Str = {
        mut result := self.clone()
        for i in 0..result._len {
            mut byte : U8 = 0
            memcpy(to_ptr(byte), result.c_string.offset(i).data, 1)
            mut byte_val : I64 = 0
            byte_val = U8.to_i64(byte)
            // A = 65, Z = 90. Add 32 to convert to lowercase.
            if byte_val.gteq(65) {
                if byte_val.lteq(90) {
                    byte_val = byte_val.add(32)
                    byte = U8.from_i64(byte_val)?
                    memcpy(result.c_string.offset(i).data, to_ptr(byte), 1)
                }
            }
        }

        catch (err: U8_Overflow) {
            panic(loc(), err.msg)
        }

        return result
    }

    contains : func(self: Str, needle: Str) returns Bool = {
        # Returns true if needle is found in self
        if needle.len().gt(self.len()) {
            return false
        }
        if needle.len().eq(0) {
            return false
        }

        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), self.c_string.offset(start_idx.add(needle_idx)).data, 1)
                memcpy(to_ptr(needle_byte), needle.c_string.offset(needle_idx).data, 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                return true
            }
        }

        return false
    }

    find : func(self: Str, needle: Str) returns I64 = {
        # Returns the first index where needle starts in self, or -1 if not found
        if needle.len().gt(self.len()) {
            return I64.sub(0, 1)
        }
        if needle.len().eq(0) {
            return I64.sub(0, 1)
        }

        mut max_start := self.len().sub(needle.len())

        // Use while loops instead of for loops to avoid issues with
        // escape characters in strings being counted incorrectly
        mut start_idx := 0
        while start_idx.lteq(max_start) {
            mut matches := true
            mut needle_idx := 0
            while needle_idx.lt(needle.len()) {
                if not(matches) {
                    // Already failed, skip rest (simulated break)
                    needle_idx = needle.len()
                } else {
                    mut self_byte : U8 = 0
                    mut needle_byte : U8 = 0
                    memcpy(to_ptr(self_byte), self.c_string.offset(start_idx.add(needle_idx)).data, 1)
                    memcpy(to_ptr(needle_byte), needle.c_string.offset(needle_idx).data, 1)

                    if not(U8.eq(self_byte, needle_byte)) {
                        matches = false
                    }
                    needle_idx.inc()
                }
            }
            if matches {
                return start_idx
            }
            start_idx.inc()
        }

        return I64.sub(0, 1)
    }

    rfind : func(self: Str, needle: Str) returns I64 = {
        # Returns the last index where needle starts in self, or I64.sub(0, 1) if not found
        if needle.len().gt(self.len()) {
            return I64.sub(0, 1)
        }
        if needle.len().eq(0) {
            return I64.sub(0, 1)
        }

        mut last_found := I64.sub(0, 1)
        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), self.c_string.offset(start_idx.add(needle_idx)).data, 1)
                memcpy(to_ptr(needle_byte), needle.c_string.offset(needle_idx).data, 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                last_found = start_idx
            }
        }

        return last_found
    }

    replace : func(self: Str, from: Str, to: Str) returns Str = {
        # Replace all occurrences of 'from' with 'to' in self
        if from.len().eq(0) {
            return self.clone()
        }

        # First, count occurrences to calculate result size
        mut count := 0
        mut search_start := 0
        while search_start.lteq(self.len().sub(from.len())) {
            mut matches := true
            for i in 0..from.len() {
                mut self_byte : U8 = 0
                mut from_byte : U8 = 0
                memcpy(to_ptr(self_byte), self.c_string.offset(search_start.add(i)).data, 1)
                memcpy(to_ptr(from_byte), from.c_string.offset(i).data, 1)
                if not(U8.eq(self_byte, from_byte)) {
                    matches = false
                }
            }
            if matches {
                count.inc()
                search_start = search_start.add(from.len())
            } else {
                search_start.inc()
            }
        }

        if count.eq(0) {
            return self.clone()
        }

        # Calculate new size: original - (count * from.len) + (count * to.len)
        mut new_len := self.len().sub(count.mul(from.len())).add(count.mul(to.len()))

        mut result := Str()
        result._len = new_len
        result.cap = new_len.add(1)  // Allocated capacity
        result.c_string = Ptr.new_by_size(result.cap)
        result.c_string.is_borrowed = 0

        # Now build the result
        mut src_idx := 0
        mut dst_idx := 0
        while src_idx.lt(self.len()) {
            # Check if 'from' matches at current position
            mut found_match := true
            if src_idx.lteq(self.len().sub(from.len())) {
                for j in 0..from.len() {
                    mut src_byte : U8 = 0
                    mut pattern_byte : U8 = 0
                    memcpy(to_ptr(src_byte), self.c_string.offset(src_idx.add(j)).data, 1)
                    memcpy(to_ptr(pattern_byte), from.c_string.offset(j).data, 1)
                    if not(U8.eq(src_byte, pattern_byte)) {
                        found_match = false
                    }
                }
            } else {
                found_match = false
            }

            if found_match {
                # Copy 'to' string
                memcpy(result.c_string.offset(dst_idx).data, to.c_string.data, to.len())
                dst_idx = dst_idx.add(to.len())
                src_idx = src_idx.add(from.len())
            } else {
                # Copy single byte
                memcpy(result.c_string.offset(dst_idx).data, self.c_string.offset(src_idx).data, 1)
                dst_idx.inc()
                src_idx.inc()
            }
        }

        // Null-terminate the string
        zero : U8 = 0
        memset(result.c_string.offset(result._len).data, zero, 1)

        return result
    }

    /** Get byte value at index */
    char_at : func(self: Str, index: I64) returns U8 = {
        mut result: U8 = 0
        if index.lt(0) {
            return result
        }
        if index.gteq(self.len()) {
            return result
        }
        memcpy(to_ptr(result), self.c_string.offset(index).data, 1)
        return result
    }

    /** Lexicographic comparison: returns negative if self < other, 0 if equal, positive if self > other */
    cmp : func(self: Str, other: Str) returns I64 = {
        mut min_len := self.len()
        if other.len().lt(min_len) {
            min_len = other.len()
        }
        for i in 0..min_len {
            a_byte := self.char_at(i)
            b_byte := other.char_at(i)
            a_val := U8.to_i64(a_byte)
            b_val := U8.to_i64(b_byte)
            if a_val.lt(b_val) {
                return I64.sub(0, 1)
            }
            if a_val.gt(b_val) {
                return 1
            }
        }
        return sub(self.len(), other.len())
    }

    /** Less than comparison */
    lt : func(self: Str, other: Str) returns Bool = {
        return self.cmp(other).lt(0)
    }

    /** Greater than comparison */
    gt : func(self: Str, other: Str) returns Bool = {
        return self.cmp(other).gt(0)
    }

    /** Less than or equal comparison */
    lteq : func(self: Str, other: Str) returns Bool = {
        return self.cmp(other).lteq(0)
    }

    /** Greater than or equal comparison */
    gteq : func(self: Str, other: Str) returns Bool = {
        return self.cmp(other).gteq(0)
    }

    /** Increment single-character string (e.g., "a" -> "b").
     *  Only works on single-character strings. Wraps on overflow.
     *  Allocates new memory to handle string literals in read-only memory. */
    inc : proc(mut self: Str) = {
        if self.len().eq(1) {
            mut byte_val : U8 = 0
            memcpy(to_ptr(byte_val), self.c_string.data, 1)
            one : U8 = 1
            byte_val = U8.add(byte_val, one)
            // Allocate new memory for the result
            mut new_ptr := Ptr.new_by_size(2)
            new_ptr.is_borrowed = 0
            memcpy(new_ptr.data, to_ptr(byte_val), 1)
            memset(new_ptr.offset(1).data, ZERO_U8, 1)
            self.c_string = new_ptr
            self.cap = 2
        }
    }

    /** Decrement single-character string (e.g., "b" -> "a").
     *  Only works on single-character strings. Wraps on underflow.
     *  Allocates new memory to handle string literals in read-only memory. */
    dec : proc(mut self: Str) = {
        if self.len().eq(1) {
            mut byte_val : U8 = 0
            memcpy(to_ptr(byte_val), self.c_string.data, 1)
            one : U8 = 1
            byte_val = U8.sub(byte_val, one)
            // Allocate new memory for the result
            mut new_ptr := Ptr.new_by_size(2)
            new_ptr.is_borrowed = 0
            memcpy(new_ptr.data, to_ptr(byte_val), 1)
            memset(new_ptr.offset(1).data, ZERO_U8, 1)
            self.c_string = new_ptr
            self.cap = 2
        }
    }

    /** Replace first n occurrences of 'from' with 'to' */
    replacen : func(self: Str, from: Str, to: Str, n: I64) returns Str = {
        if from.len().eq(0) {
            return self.clone()
        }
        if n.eq(0) {
            return self.clone()
        }

        // Find first occurrence
        mut idx := self.find(from)
        if idx.lt(0) {
            return self.clone()
        }

        // Build result: prefix + to + suffix
        mut prefix := self.get_substr(0, idx)?
        mut suffix := self.get_substr(idx.add(from.len()), self.len())?

        mut result := prefix.concat(to).concat(suffix)

        if n.gt(1) {
            // Recursively replace remaining
            mut rest := suffix.replacen(from, to, n.sub(1))
            result = prefix.concat(to).concat(rest)
        }

        catch (err: IndexOutOfBoundsError) { result = self.clone() }

        return result
    }

    split : func(self: Str, delimiter: Str) returns Vec throws IndexOutOfBoundsError = {
        # Split string by delimiter, return Vec of Str
        mut parts := Vec.new(Str)

        if delimiter.len().eq(0) {
            parts.push(self.clone())
            return parts
        }

        mut start := 0
        mut pos := 0

        while pos.lteq(self.len().sub(delimiter.len())) {
            mut matches := true
            for i in 0..delimiter.len() {
                mut self_byte : U8 = 0
                mut delim_byte : U8 = 0
                memcpy(to_ptr(self_byte), self.c_string.offset(pos.add(i)).data, 1)
                memcpy(to_ptr(delim_byte), delimiter.c_string.offset(i).data, 1)
                if not(U8.eq(self_byte, delim_byte)) {
                    matches = false
                }
            }

            if matches {
                # Found delimiter - extract part from start to pos
                if pos.gt(start) {
                    part := self.get_substr(start, pos)?
                    parts.push(part)
                } else {
                    # Empty part
                    parts.push("")
                }
                start = pos.add(delimiter.len())
                pos = start
            } else {
                pos.inc()
            }
        }

        # Add remaining part after last delimiter
        if start.lt(self.len()) {
            remaining_part := self.get_substr(start, self.len())?
            parts.push(remaining_part)
        } else {
            if start.eq(self.len()) {
                parts.push("")
            }
        }

        return parts
    }

    /** Repeat the string n times. */
    repeat : func(self: Str, n: I64) returns Str = {
        if n.lteq(0) {
            return ""
        }
        if n.eq(1) {
            return self.clone()
        }

        mut result := Str()
        result._len = self._len.mul(n)
        result.cap = result._len.add(1)  // Allocated capacity
        result.c_string = Ptr.new_by_size(result.cap)
        result.c_string.is_borrowed = 0

        mut offset := 0
        for i in 0..n {
            memcpy(result.c_string.offset(offset).data, self.c_string.data, self._len)
            offset = offset.add(self._len)
        }

        // Null-terminate the string
        memset(result.c_string.offset(result._len).data, ZERO_U8, 1)

        return result
    }

    /** FNV-1a hash function for strings.
     *  Returns a 64-bit hash value.
     *  Good distribution, simple implementation. */
    hash : func(self: Str) returns I64 = {
        // FNV-1a 64-bit constants (signed representation of unsigned values)
        // Unsigned 14695981039346656037 = signed -3750763034362895579
        FNV_OFFSET_BASIS : I64 = sub(0, 3750763034362895579)
        FNV_PRIME : I64 = 1099511628211

        mut h := FNV_OFFSET_BASIS
        for i in 0..self._len {
            mut byte_val : U8 = 0
            memcpy(to_ptr(byte_val), self.c_string.offset(i).data, 1)
            // h = h XOR byte
            h = I64.xor(h, U8.to_i64(byte_val))
            // h = h * FNV_PRIME (overflow is fine, we want wrapping multiplication)
            h = h.mul(FNV_PRIME)
        }
        return h
    }
}

/** Get a substring from start (inclusive) to end (exclusive). */
get_substr : func(s: Str, start: I64, end: I64) returns Str throws IndexOutOfBoundsError = {

    if start.lt(0) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: start index ", start.to_str(), " cannot be negative"))
    }
    if end.lt(0) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: end index ", end.to_str(), " cannot be negative"))
    }
    if start.gt(end) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: start index ", start.to_str(), " is greater than end index ", end.to_str()))
    }
    if end.gt(s.len()) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: end index ", end.to_str(), " is greater than string length ", I64.to_str(s.len())))
    }
    if start.eq(end) {
        // Return empty string when start==end (like Rust's s[0..0])
        return ""
    }

    mut substr := Str()
    substr._len = end.sub(start)
    substr.cap = substr._len.add(1)  // Allocated capacity
    substr.c_string = Ptr.new_by_size(substr.cap)
    substr.c_string.is_borrowed = 0
    memcpy(substr.c_string.data, s.c_string.offset(start).data, substr._len)
    // Null-terminate the string
    zero : U8 = 0
    memset(substr.c_string.offset(substr._len).data, zero, 1)

    return substr
}

/** Get a single character at position pos as a Str. */
get_char : func(s: Str, pos: I64) returns Str throws IndexOutOfBoundsError = {
    return s.get_substr(pos, pos.add(1))?
}

/** Check if string starts with the given prefix. */
starts_with : func(s: Str, prefix: Str) returns Bool = {
    if prefix.len().gt(s.len()) {
        return false
    }
    mut i := 0
    while i.lt(prefix.len()) {
        mut s_byte : U8 = 0
        mut p_byte : U8 = 0
        memcpy(to_ptr(s_byte), s.c_string.offset(i).data, 1)
        memcpy(to_ptr(p_byte), prefix.c_string.offset(i).data, 1)
        if not(U8.eq(s_byte, p_byte)) {
            return false
        }
        i = i.add(1)
    }
    return true
}

/** Check if string ends with the given suffix. */
ends_with : func(s: Str, suffix: Str) returns Bool = {
    if suffix.len().gt(s.len()) {
        return false
    }
    mut str_offset := s.len().sub(suffix.len())
    mut i := 0
    while i.lt(suffix.len()) {
        mut s_byte : U8 = 0
        mut suffix_byte : U8 = 0
        memcpy(to_ptr(s_byte), s.c_string.offset(str_offset.add(i)).data, 1)
        memcpy(to_ptr(suffix_byte), suffix.c_string.offset(i).data, 1)
        if not(U8.eq(s_byte, suffix_byte)) {
            return false
        }
        i = i.add(1)
    }
    return true
}

/** Returns rest of string after prefix, or empty string if no match. */
strip_prefix : func(s: Str, prefix: Str) returns Str = {
    if not(starts_with(s, prefix)) {
        return ""
    }
    result := get_substr(s, prefix.len(), s.len())?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    return result
}

/** Returns rest of string before suffix, or empty string if no match. */
strip_suffix : func(s: Str, suffix: Str) returns Str = {
    if not(ends_with(s, suffix)) {
        return ""
    }
    result := get_substr(s, 0, s.len().sub(suffix.len()))?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    return result
}

/**
 * Simple 2-argument string concatenation that panics on error.
 * Use this in catch blocks where throwing is not allowed.
 */
concat : func(a: Str, b: Str) returns Str = {
    mut result := Str()
    result._len = a._len.add(b._len)

    if result._len.lt(a._len) {
        panic(loc(), "concat: integer overflow")
    }

    result.cap = result._len.add(1)  // Allocated capacity
    result.c_string = Ptr.new_by_size(result.cap)
    result.c_string.is_borrowed = 0

    memcpy(result.c_string.data, a.c_string.data, a._len)
    memcpy(result.c_string.offset(a._len).data, b.c_string.data, b._len)
    // Null-terminate the string
    zero : U8 = 0
    memset(result.c_string.offset(result._len).data, zero, 1)

    return result
}

/** Format a prefix with variadic string arguments, concatenating them all. */
format : func(prefix: Str, args: ..Str) returns Str = {
    mut result := Str()
    result._len = prefix._len

    for arg: Str in args {
        result._len = result._len.add(arg._len)
        if result._len.lt(arg._len) {
            panic(loc(), "format: integer overflow while summing cap")
        }
    }

    result.cap = result._len.add(1)  // Allocated capacity
    result.c_string = Ptr.new_by_size(result.cap)
    result.c_string.is_borrowed = 0

    mut fmt_offset := 0
    memcpy(result.c_string.data, prefix.c_string.data, prefix._len)
    fmt_offset = prefix._len

    for s: Str in args {
        memcpy(result.c_string.offset(fmt_offset).data, s.c_string.data, s._len)
        fmt_offset = fmt_offset.add(s._len)
    }

    // Null-terminate the string
    zero : U8 = 0
    memset(result.c_string.offset(result._len).data, zero, 1)

    return result
}

/** Join a Vec of Str with a separator. */
join : func(parts: Vec, sep: Str) returns Str = {
    if parts.is_empty() {
        return ""
    }

    // Calculate total length needed
    mut total_len := 0
    mut first := true
    for part: Str in parts {
        if not(first) {
            total_len = total_len.add(sep.len())
        }
        total_len = total_len.add(part.len())
        first = false
    }

    // Allocate result
    mut result := Str()
    result._len = total_len
    result.cap = total_len.add(1)  // Allocated capacity
    result.c_string = Ptr.new_by_size(result.cap)
    result.c_string.is_borrowed = 0

    // Copy parts with separator
    mut join_offset := 0
    first = true
    for part: Str in parts {
        if not(first) {
            memcpy(result.c_string.offset(join_offset).data, sep.c_string.data, sep.len())
            join_offset = join_offset.add(sep.len())
        }
        memcpy(result.c_string.offset(join_offset).data, part.c_string.data, part.len())
        join_offset = join_offset.add(part.len())
        first = false
    }

    // Null-terminate
    zero : U8 = 0
    memset(result.c_string.offset(result._len).data, zero, 1)

    return result
}
