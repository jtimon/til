mode liba

import("core.bounds")
import("core.mem")
import("core.vec")

/** Str - String type with c_string pointer and capacity. */
// TODO get rid of special cases for Str besides literals
Str := struct {
    mut c_string : I64 = 0  // Pointer to null-terminated C string
    mut cap      : I64 = 0
    // mut len : I64 = 0 // TODO make sure double declarations inside the same struct give type errors

    len := func(self: Str) returns I64 {
        return self.cap
    }

    is_empty := func(self: Str) returns Bool {
        return self.cap.eq(0)
    }

    eq := func(self: Str, other: Str) returns Bool {
        if not(self.cap.eq(other.cap)) {
            return false
        }

        for i in 0..self.cap {
            mut self_byte  : U8 = 0
            mut other_byte : U8 = 0
            memcpy(to_ptr(self_byte), add(self.c_string, i), 1)
            memcpy(to_ptr(other_byte), add(other.c_string, i), 1)

            if not(U8.eq(self_byte, other_byte)) {
                return false
            }
        }

        return true
    }

    to_i64 := func(self: Str) returns I64 {
        return I64.from_str(self)
    }

    clone := func(self: Str) returns Str throws AllocError {
        mut cloned := Str()
        cloned.cap = self.cap
        cloned.c_string = malloc(cloned.cap.add(1))  // +1 for null terminator
        if NULL.eq(cloned.c_string) {
            throw AllocError(msg=format(loc(), "Str.clone: malloc failed for ", I64.to_str(cloned.cap.add(1)), " bytes"))
        }
        memcpy(cloned.c_string, self.c_string, self.cap)
        // Null-terminate the string
        zero : U8 = 0
        memset(add(cloned.c_string, cloned.cap), zero, 1)
        return cloned
    }

    /** Append a string to self (mutates self). Equivalent to Rust's push_str. */
    push_str := proc(mut self: Str, s: Str) {
        self = self.concat(s)
    }

    size := func(self: Str) returns I64 {
        return self.cap
    }

    /** Check if all characters in the string are uppercase (A-Z).
     *  Returns false for empty strings or strings containing non-uppercase chars.
     *  To check only the first character, use: str.get_substr(0, 1).is_uppercase()
     */
    is_uppercase := func(self: Str) returns Bool {
        if self.cap.eq(0) {
            return false
        }
        for i in 0..self.cap {
            mut byte : U8 = 0
            memcpy(to_ptr(byte), add(self.c_string, i), 1)
            // A = 65, Z = 90. Convert to I64 for comparison.
            mut byte_val : I64 = 0
            byte_val = U8.to_i64(byte)
            if lt(byte_val, 65) {
                return false
            }
            if gt(byte_val, 90) {
                return false
            }
        }
        return true
    }

    /** Convert string to lowercase (a-z).
     *  Only converts ASCII uppercase letters (A-Z to a-z).
     */
    to_lowercase := func(self: Str) returns Str {
        mut result := self.clone()
        for i in 0..result.cap {
            mut byte : U8 = 0
            memcpy(to_ptr(byte), add(result.c_string, i), 1)
            mut byte_val : I64 = 0
            byte_val = U8.to_i64(byte)
            // A = 65, Z = 90. Add 32 to convert to lowercase.
            if byte_val.gteq(65) {
                if byte_val.lteq(90) {
                    byte_val = byte_val.add(32)
                    byte = U8.from_i64(byte_val)
                    memcpy(add(result.c_string, i), to_ptr(byte), 1)
                }
            }
        }

        catch (err: AllocError) {
            panic(loc(), err.msg)
        }
        catch (err: U8_OverflowError) {
            panic(loc(), err.msg)
        }

        return result
    }

    contains := func(self: Str, needle: Str) returns Bool {
        # Returns true if needle is found in self
        if needle.len().gt(self.len()) {
            return false
        }
        if needle.len().eq(0) {
            return false
        }

        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                return true
            }
        }

        return false
    }

    find := func(self: Str, needle: Str) returns I64 {
        # Returns the first index where needle starts in self, or -1 if not found
        if needle.len().gt(self.len()) {
            return sub(0, 1)
        }
        if needle.len().eq(0) {
            return sub(0, 1)
        }

        mut max_start := self.len().sub(needle.len())

        // Use while loops instead of for loops to avoid issues with
        // escape characters in strings being counted incorrectly
        mut start_idx := 0
        while start_idx.lteq(max_start) {
            mut matches := true
            mut needle_idx := 0
            while needle_idx.lt(needle.len()) {
                if not(matches) {
                    // Already failed, skip rest (simulated break)
                    needle_idx = needle.len()
                } else {
                    mut self_byte : U8 = 0
                    mut needle_byte : U8 = 0
                    memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                    memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                    if not(U8.eq(self_byte, needle_byte)) {
                        matches = false
                    }
                    needle_idx.inc()
                }
            }
            if matches {
                return start_idx
            }
            start_idx.inc()
        }

        return sub(0, 1)
    }

    rfind := func(self: Str, needle: Str) returns I64 {
        # Returns the last index where needle starts in self, or sub(0, 1) if not found
        if needle.len().gt(self.len()) {
            return sub(0, 1)
        }
        if needle.len().eq(0) {
            return sub(0, 1)
        }

        mut last_found := sub(0, 1)
        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                last_found = start_idx
            }
        }

        return last_found
    }

    replace := func(self: Str, from: Str, to: Str) returns Str throws AllocError {
        # Replace all occurrences of 'from' with 'to' in self
        if from.len().eq(0) {
            return self.clone()
        }

        # First, count occurrences to calculate result size
        mut count := 0
        mut search_start := 0
        while search_start.lteq(self.len().sub(from.len())) {
            mut matches := true
            for i in 0..from.len() {
                mut self_byte : U8 = 0
                mut from_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, search_start.add(i)), 1)
                memcpy(to_ptr(from_byte), add(from.c_string, i), 1)
                if not(U8.eq(self_byte, from_byte)) {
                    matches = false
                }
            }
            if matches {
                count.inc()
                search_start = search_start.add(from.len())
            } else {
                search_start.inc()
            }
        }

        if count.eq(0) {
            return self.clone()
        }

        # Calculate new size: original - (count * from.len) + (count * to.len)
        mut new_len := self.len().sub(count.mul(from.len())).add(count.mul(to.len()))

        mut result := Str()
        result.cap = new_len
        result.c_string = malloc(new_len.add(1))  // +1 for null terminator
        if NULL.eq(result.c_string) {
            throw AllocError(msg=format(loc(), "Str.replace: malloc failed for ", I64.to_str(new_len.add(1)), " bytes"))
        }

        # Now build the result
        mut src_idx := 0
        mut dst_idx := 0
        while src_idx.lt(self.len()) {
            # Check if 'from' matches at current position
            mut found_match := true
            if src_idx.lteq(self.len().sub(from.len())) {
                for j in 0..from.len() {
                    mut src_byte : U8 = 0
                    mut pattern_byte : U8 = 0
                    memcpy(to_ptr(src_byte), add(self.c_string, src_idx.add(j)), 1)
                    memcpy(to_ptr(pattern_byte), add(from.c_string, j), 1)
                    if not(U8.eq(src_byte, pattern_byte)) {
                        found_match = false
                    }
                }
            } else {
                found_match = false
            }

            if found_match {
                # Copy 'to' string
                memcpy(add(result.c_string, dst_idx), to.c_string, to.len())
                dst_idx = dst_idx.add(to.len())
                src_idx = src_idx.add(from.len())
            } else {
                # Copy single byte
                memcpy(add(result.c_string, dst_idx), add(self.c_string, src_idx), 1)
                dst_idx.inc()
                src_idx.inc()
            }
        }

        // Null-terminate the string
        zero : U8 = 0
        memset(add(result.c_string, result.cap), zero, 1)

        return result
    }

    /** Get byte value at index */
    char_at := func(self: Str, index: I64) returns U8 {
        mut result: U8 = 0
        if index.lt(0) {
            return result
        }
        if index.gteq(self.len()) {
            return result
        }
        memcpy(to_ptr(result), add(self.c_string, index), 1)
        return result
    }

    /** Lexicographic comparison: returns negative if self < other, 0 if equal, positive if self > other */
    cmp := func(self: Str, other: Str) returns I64 {
        mut min_len := self.len()
        if other.len().lt(min_len) {
            min_len = other.len()
        }
        for i in 0..min_len {
            a_byte := self.char_at(i)
            b_byte := other.char_at(i)
            a_val := U8.to_i64(a_byte)
            b_val := U8.to_i64(b_byte)
            if a_val.lt(b_val) {
                return sub(0, 1)
            }
            if a_val.gt(b_val) {
                return 1
            }
        }
        return sub(self.len(), other.len())
    }

    /** Replace first n occurrences of 'from' with 'to' */
    replacen := func(self: Str, from: Str, to: Str, n: I64) returns Str throws AllocError {
        if from.len().eq(0) {
            return self.clone()
        }
        if n.eq(0) {
            return self.clone()
        }

        // Find first occurrence
        mut idx := self.find(from)
        if idx.lt(0) {
            return self.clone()
        }

        // Build result: prefix + to + suffix
        mut prefix := self.get_substr(0, idx)
        mut suffix := self.get_substr(idx.add(from.len()), self.len())

        mut result := prefix.concat(to).concat(suffix)

        if n.gt(1) {
            // Recursively replace remaining
            mut rest := suffix.replacen(from, to, n.sub(1))
            result = prefix.concat(to).concat(rest)
        }

        catch (err: IndexOutOfBoundsError) { result = self.clone() }

        return result
    }

    split := func(self: Str, delimiter: Str) returns Vec throws AllocError, IndexOutOfBoundsError {
        # Split string by delimiter, return Vec of Str
        mut parts := Vec.new(Str)

        if delimiter.len().eq(0) {
            parts.push(self.clone())
            return parts
        }

        mut start := 0
        mut pos := 0

        while pos.lteq(self.len().sub(delimiter.len())) {
            mut matches := true
            for i in 0..delimiter.len() {
                mut self_byte : U8 = 0
                mut delim_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, pos.add(i)), 1)
                memcpy(to_ptr(delim_byte), add(delimiter.c_string, i), 1)
                if not(U8.eq(self_byte, delim_byte)) {
                    matches = false
                }
            }

            if matches {
                # Found delimiter - extract part from start to pos
                if pos.gt(start) {
                    part := self.get_substr(start, pos)
                    parts.push(part)
                } else {
                    # Empty part
                    parts.push("")
                }
                start = pos.add(delimiter.len())
                pos = start
            } else {
                pos.inc()
            }
        }

        # Add remaining part after last delimiter
        if start.lt(self.len()) {
            remaining_part := self.get_substr(start, self.len())
            parts.push(remaining_part)
        } else {
            if start.eq(self.len()) {
                parts.push("")
            }
        }

        return parts
    }

    /** Repeat the string n times. */
    repeat := func(self: Str, n: I64) returns Str throws AllocError {
        if n.lteq(0) {
            return ""
        }
        if n.eq(1) {
            return self.clone()
        }

        mut result := Str()
        result.cap = self.cap.mul(n)
        result.c_string = malloc(result.cap.add(1))
        if NULL.eq(result.c_string) {
            throw AllocError(msg=format(loc(), "Str.repeat: malloc failed for ", I64.to_str(result.cap.add(1)), " bytes"))
        }

        mut offset := 0
        for i in 0..n {
            memcpy(add(result.c_string, offset), self.c_string, self.cap)
            offset = offset.add(self.cap)
        }

        // Null-terminate the string
        memset(add(result.c_string, result.cap), ZERO_U8, 1)

        return result
    }
}

/** Get a substring from start (inclusive) to end (exclusive). */
get_substr := func(s: Str, start: I64, end: I64) returns Str throws IndexOutOfBoundsError, AllocError {

    if start.lt(0) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: start index ", start.to_str(), " cannot be negative"))
    }
    if end.lt(0) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: end index ", end.to_str(), " cannot be negative"))
    }
    if start.gt(end) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: start index ", start.to_str(), " is greater than end index ", end.to_str()))
    }
    if end.gt(s.len()) {
        throw IndexOutOfBoundsError(msg=format(loc(), "get_substr: end index ", end.to_str(), " is greater than string length ", I64.to_str(s.len())))
    }
    if start.eq(end) {
        // Return empty string when start==end (like Rust's s[0..0])
        return ""
    }

    mut substr := Str()
    substr.cap = end.sub(start)
    substr.c_string = malloc(substr.cap.add(1))  // +1 for null terminator
    if NULL.eq(substr.c_string) {
        throw AllocError(msg=format(loc(), "Str.get_substr: failed to allocate ", I64.to_str(substr.cap.add(1)), " bytes"))
    }
    memcpy(substr.c_string, add(s.c_string, start), substr.cap)
    // Null-terminate the string
    zero : U8 = 0
    memset(add(substr.c_string, substr.cap), zero, 1)

    return substr
}

/** Get a single character at position pos as a Str. */
get_char := func(s: Str, pos: I64) returns Str throws IndexOutOfBoundsError, AllocError {
    return s.get_substr(pos, add(pos, 1))
}

/** Check if string starts with the given prefix. */
starts_with := func(s: Str, prefix: Str) returns Bool {
    if prefix.len().gt(s.len()) {
        return false
    }
    mut i := 0
    while i.lt(prefix.len()) {
        mut s_byte : U8 = 0
        mut p_byte : U8 = 0
        memcpy(to_ptr(s_byte), add(s.c_string, i), 1)
        memcpy(to_ptr(p_byte), add(prefix.c_string, i), 1)
        if not(U8.eq(s_byte, p_byte)) {
            return false
        }
        i = add(i, 1)
    }
    return true
}

/** Check if string ends with the given suffix. */
ends_with := func(s: Str, suffix: Str) returns Bool {
    if suffix.len().gt(s.len()) {
        return false
    }
    mut offset := s.len().sub(suffix.len())
    mut i := 0
    while i.lt(suffix.len()) {
        mut s_byte : U8 = 0
        mut suffix_byte : U8 = 0
        memcpy(to_ptr(s_byte), add(s.c_string, offset.add(i)), 1)
        memcpy(to_ptr(suffix_byte), add(suffix.c_string, i), 1)
        if not(U8.eq(s_byte, suffix_byte)) {
            return false
        }
        i = add(i, 1)
    }
    return true
}

/**
 * Simple 2-argument string concatenation that panics on error.
 * Use this in catch blocks where throwing is not allowed.
 */
concat := func(a: Str, b: Str) returns Str {
    mut result := Str()
    result.cap = add(a.cap, b.cap)

    if lt(result.cap, a.cap) {
        panic(loc(), "concat: integer overflow")
    }

    result.c_string = malloc(result.cap.add(1))  // +1 for null terminator
    if NULL.eq(result.c_string) {
        panic(loc(), "concat: malloc failed")
    }

    memcpy(result.c_string, a.c_string, a.cap)
    memcpy(add(result.c_string, a.cap), b.c_string, b.cap)
    // Null-terminate the string
    zero : U8 = 0
    memset(add(result.c_string, result.cap), zero, 1)

    catch (err: AllocError) {
        panic(loc(), err.msg)
    }

    return result
}

/** Format a prefix with variadic string arguments, concatenating them all. */
format := func(prefix: Str, args: ..Str) returns Str {
    mut result := Str()
    result.cap = prefix.cap

    for i in 0..args.len() {
        mut arg := ""
        args.get(i, arg)
        result.cap = add(result.cap, arg.cap)
        if lt(result.cap, arg.cap) {
            panic(loc(), "format: integer overflow while summing cap")
        }
    }

    result.c_string = malloc(result.cap.add(1))  // +1 for null terminator
    if NULL.eq(result.c_string) {
        panic(loc(), "format: malloc failed, size=", result.cap.to_str())
    }

    mut offset := 0
    memcpy(result.c_string, prefix.c_string, prefix.cap)
    offset = prefix.cap

    for s: Str in args {
        memcpy(add(result.c_string, offset), s.c_string, s.cap)
        offset = add(offset, s.cap)
    }

    // Null-terminate the string
    zero : U8 = 0
    memset(add(result.c_string, result.cap), zero, 1)

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), err.msg)
    }
    catch (err: AllocError) {
        panic(loc(), err.msg)
    }

    return result
}

/** Join a Vec of Str with a separator. */
join := func(parts: Vec, sep: Str) returns Str {
    if parts.is_empty() {
        return ""
    }

    // Calculate total length needed
    mut total_len := 0
    mut first := true
    for part: Str in parts {
        if not(first) {
            total_len = total_len.add(sep.len())
        }
        total_len = total_len.add(part.len())
        first = false
    }

    // Allocate result
    mut result := Str()
    result.cap = total_len
    result.c_string = malloc(total_len.add(1))
    catch (err: AllocError) {
        panic(loc(), "join: malloc failed: ", err.msg)
    }
    if NULL.eq(result.c_string) {
        panic(loc(), "join: malloc failed")
    }

    // Copy parts with separator
    mut offset := 0
    first = true
    for part: Str in parts {
        if not(first) {
            memcpy(add(result.c_string, offset), sep.c_string, sep.len())
            offset = offset.add(sep.len())
        }
        memcpy(add(result.c_string, offset), part.c_string, part.len())
        offset = offset.add(part.len())
        first = false
    }

    // Null-terminate
    zero : U8 = 0
    memset(add(result.c_string, result.cap), zero, 1)

    return result
}
