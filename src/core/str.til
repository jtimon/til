mode lib

import("src.core.bounds")
import("src.core.mem")
import("src.core.std.vec")

print := proc(args: ..Str) {
    for i in 0..args.len() {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "print: IndexOutOfBoundsError should never happen")
    }
}

println := proc(args: ..Str) {
    for i in 0..args.len() {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    single_print("\n")
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "println: IndexOutOfBoundsError should never happen")
    }
}

/** Str - String type with c_string pointer and capacity. */
// TODO get rid of special cases for Str besides literals
Str := struct {
    mut c_string : I64 = 0
    mut cap      : I64 = 0
    // mut len : I64 = 0 // TODO make sure double declarations inside the same struct give type errors

    len := func(self: Str) returns I64 {
        return self.cap
    }

    eq := func(self: Str, other: Str) returns Bool {
        if not(self.cap.eq(other.cap)) {
            return false
        }

        for i in 0..self.cap {
            mut self_byte  : U8 = 0
            mut other_byte : U8 = 0
            memcpy(to_ptr(self_byte), add(self.c_string, i), 1)
            memcpy(to_ptr(other_byte), add(other.c_string, i), 1)

            if not(U8.eq(self_byte, other_byte)) {
                return false
            }
        }

        return true
    }

    to_i64 := func(self: Str) returns I64 {
        return I64.from_str(self)
    }

    clone := func(self: Str) returns Str throws AllocError {
        mut cloned := Str()
        cloned.cap = self.cap
        cloned.c_string = malloc(cloned.cap)
        if NULL.eq(cloned.c_string) {
            throw AllocError.new(format(loc(), "Str.clone: malloc failed for ", I64.to_str(cloned.cap), " bytes"))
        }
        memcpy(cloned.c_string, self.c_string, self.cap)
        return cloned
    }

    size := func(self: Str) returns I64 {
        return self.cap
    }

    /** Check if all characters in the string are uppercase (A-Z).
     *  Returns false for empty strings or strings containing non-uppercase chars.
     *  To check only the first character, use: str.get_substr(0, 1).is_uppercase()
     */
    is_uppercase := func(self: Str) returns Bool {
        if self.cap.eq(0) {
            return false
        }
        for i in 0..self.cap {
            mut byte : U8 = 0
            memcpy(to_ptr(byte), add(self.c_string, i), 1)
            // A = 65, Z = 90. Convert to I64 for comparison.
            mut byte_val : I64 = 0
            byte_val = U8.to_i64(byte)
            if lt(byte_val, 65) {
                return false
            }
            if gt(byte_val, 90) {
                return false
            }
        }
        return true
    }

    contains := func(self: Str, needle: Str) returns Bool {
        # Returns true if needle is found in self
        if needle.len().gt(self.len()) {
            return false
        }
        if needle.len().eq(0) {
            return false
        }

        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                return true
            }
        }

        return false
    }

    find := func(self: Str, needle: Str) returns I64 {
        # Returns the first index where needle starts in self, or -1 if not found
        if needle.len().gt(self.len()) {
            return sub(0, 1)
        }
        if needle.len().eq(0) {
            return sub(0, 1)
        }

        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                return start_idx
            }
        }

        return sub(0, 1)
    }

    rfind := func(self: Str, needle: Str) returns I64 {
        # Returns the last index where needle starts in self, or sub(0, 1) if not found
        if needle.len().gt(self.len()) {
            return sub(0, 1)
        }
        if needle.len().eq(0) {
            return sub(0, 1)
        }

        mut last_found := sub(0, 1)
        mut max_start := self.len().sub(needle.len())

        for start_idx in 0..max_start.add(1) {
            mut matches := true
            for needle_idx in 0..needle.len() {
                mut self_byte : U8 = 0
                mut needle_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, start_idx.add(needle_idx)), 1)
                memcpy(to_ptr(needle_byte), add(needle.c_string, needle_idx), 1)

                if not(U8.eq(self_byte, needle_byte)) {
                    matches = false
                }
            }
            if matches {
                last_found = start_idx
            }
        }

        return last_found
    }

    replace := func(self: Str, from: Str, to: Str) returns Str throws AllocError {
        # Replace all occurrences of 'from' with 'to' in self
        if from.len().eq(0) {
            return self.clone()
        }

        # First, count occurrences to calculate result size
        mut count := 0
        mut search_start := 0
        while search_start.lteq(self.len().sub(from.len())) {
            mut matches := true
            for i in 0..from.len() {
                mut self_byte : U8 = 0
                mut from_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, search_start.add(i)), 1)
                memcpy(to_ptr(from_byte), add(from.c_string, i), 1)
                if not(U8.eq(self_byte, from_byte)) {
                    matches = false
                }
            }
            if matches {
                count = count.add(1)
                search_start = search_start.add(from.len())
            } else {
                search_start = search_start.add(1)
            }
        }

        if count.eq(0) {
            return self.clone()
        }

        # Calculate new size: original - (count * from.len) + (count * to.len)
        mut new_len := self.len().sub(count.mul(from.len())).add(count.mul(to.len()))

        mut result := Str()
        result.cap = new_len
        result.c_string = malloc(new_len)
        if NULL.eq(result.c_string) {
            throw AllocError.new(format(loc(), "Str.replace: malloc failed for ", I64.to_str(new_len), " bytes"))
        }

        # Now build the result
        mut src_idx := 0
        mut dst_idx := 0
        while src_idx.lt(self.len()) {
            # Check if 'from' matches at current position
            mut matches := true
            if src_idx.lteq(self.len().sub(from.len())) {
                for i in 0..from.len() {
                    mut self_byte : U8 = 0
                    mut from_byte : U8 = 0
                    memcpy(to_ptr(self_byte), add(self.c_string, src_idx.add(i)), 1)
                    memcpy(to_ptr(from_byte), add(from.c_string, i), 1)
                    if not(U8.eq(self_byte, from_byte)) {
                        matches = false
                    }
                }
            } else {
                matches = false
            }

            if matches {
                # Copy 'to' string
                memcpy(add(result.c_string, dst_idx), to.c_string, to.len())
                dst_idx = dst_idx.add(to.len())
                src_idx = src_idx.add(from.len())
            } else {
                # Copy single byte
                memcpy(add(result.c_string, dst_idx), add(self.c_string, src_idx), 1)
                dst_idx = dst_idx.add(1)
                src_idx = src_idx.add(1)
            }
        }

        return result
    }

    split := func(self: Str, delimiter: Str) returns Vec throws AllocError, IndexOutOfBoundsError {
        # Split string by delimiter, return Vec of Str
        mut parts := Vec.new(Str)

        if delimiter.len().eq(0) {
            parts.push(self.clone())
            return parts
        }

        mut start := 0
        mut pos := 0

        while pos.lteq(self.len().sub(delimiter.len())) {
            mut matches := true
            for i in 0..delimiter.len() {
                mut self_byte : U8 = 0
                mut delim_byte : U8 = 0
                memcpy(to_ptr(self_byte), add(self.c_string, pos.add(i)), 1)
                memcpy(to_ptr(delim_byte), add(delimiter.c_string, i), 1)
                if not(U8.eq(self_byte, delim_byte)) {
                    matches = false
                }
            }

            if matches {
                # Found delimiter - extract part from start to pos
                if pos.gt(start) {
                    part := self.get_substr(start, pos)
                    parts.push(part)
                } else {
                    # Empty part
                    parts.push("")
                }
                start = pos.add(delimiter.len())
                pos = start
            } else {
                pos = pos.add(1)
            }
        }

        # Add remaining part after last delimiter
        if start.lt(self.len()) {
            part := self.get_substr(start, self.len())
            parts.push(part)
        } else {
            if start.eq(self.len()) {
                parts.push("")
            }
        }

        return parts
    }
}

/** Get a substring from start (inclusive) to end (exclusive). */
get_substr := func(s: Str, start: I64, end: I64) returns Str throws IndexOutOfBoundsError, AllocError {

    if start.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " cannot be negative"))
    }
    if end.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " cannot be negative"))
    }
    if start.gt(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " is greater than end index ", end.to_str()))
    }
    if end.gt(s.len()) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " is greater than string length ", I64.to_str(s.len())))
    }
    if start.eq(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start and end are the same (", start.to_str(), "), no substring"))
    }

    mut substr := Str()
    substr.cap = end.sub(start)
    substr.c_string = malloc(substr.cap)
    if NULL.eq(substr.c_string) {
        throw AllocError.new(format(loc(), "Str.get_substr: failed to allocate ", I64.to_str(substr.cap), " bytes"))
    }
    memcpy(substr.c_string, add(s.c_string, start), substr.cap)

    return substr
}

/** Get a single character at position pos as a Str. */
get_char := func(s: Str, pos: I64) returns Str throws IndexOutOfBoundsError, AllocError {
    return s.get_substr(pos, add(pos, 1))
}

/** Check if string starts with the given prefix. */
starts_with := func(s: Str, prefix: Str) returns Bool {
    if prefix.len().gt(s.len()) {
        return false
    }
    mut i := 0
    while i.lt(prefix.len()) {
        mut s_byte : U8 = 0
        mut p_byte : U8 = 0
        memcpy(to_ptr(s_byte), add(s.c_string, i), 1)
        memcpy(to_ptr(p_byte), add(prefix.c_string, i), 1)
        if not(U8.eq(s_byte, p_byte)) {
            return false
        }
        i = add(i, 1)
    }
    return true
}

/**
 * Simple 2-argument string concatenation that panics on error.
 * Use this in catch blocks where throwing is not allowed.
 */
concat := func(a: Str, b: Str) returns Str {
    mut result := Str()
    result.cap = add(a.cap, b.cap)

    if lt(result.cap, a.cap) {
        panic(loc(), "concat: integer overflow")
    }

    result.c_string = malloc(result.cap)
    if NULL.eq(result.c_string) {
        panic(loc(), "concat: malloc failed")
    }

    memcpy(result.c_string, a.c_string, a.cap)
    memcpy(add(result.c_string, a.cap), b.c_string, b.cap)

    catch (err: AllocError) {
        panic(loc(), err.msg)
    }

    return result
}

/** Format a prefix with variadic string arguments, concatenating them all. */
format := func(prefix: Str, args: ..Str) returns Str throws I64_OverflowError, IndexOutOfBoundsError, AllocError {
    mut result := Str()
    result.cap = prefix.cap

    for i in 0..args.len() {
        mut arg := ""
        args.get(i, arg)
        result.cap = add(result.cap, arg.cap)
        if lt(result.cap, arg.cap) {
            throw I64_OverflowError.new(format(loc(), "format: integer overflow while summing cap for arg ", i.to_str()))
        }
    }

    result.c_string = malloc(result.cap)
    if NULL.eq(result.c_string) {
        throw AllocError.new(format(loc(), "format: malloc failed for cap = ", I64.to_str(result.cap)))
    }

    mut offset := 0
    memcpy(result.c_string, prefix.c_string, prefix.cap)
    offset = prefix.cap

    for i in 0..args.len() {
        mut s := ""
        args.get(i, s)
        memcpy(add(result.c_string, offset), s.c_string, s.cap)
        offset = add(offset, s.cap)
    }

    return result
}
