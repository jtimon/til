mode lib

import("core.mem")

/**
 * Vec - Dynamic/growable array.
 * Replaces Array.new_dyn() for cases where you need to grow the array.
 */
Vec := struct {
    mut type_name : Str  = ""
    mut type_size : I64  = 0
    mut ptr       : I64  = 0
    mut _len      : I64  = 0
    mut cap       : I64  = 0

    INIT_CAP : I64 = 0
    MAX_CAP  : I64 = 1073741824  // 1G elements - safety cap

    /** Get number of elements in vec. */
    len := func(self: Vec) returns I64 {
        return self._len
    }

    /** Check if vec is empty. */
    is_empty := func(self: Vec) returns Bool {
        return self._len.eq(0)
    }

    /** Clear all elements from vec (keeps capacity). */
    clear := proc(mut self: Vec) {
        self._len = 0
    }

    /** Get total size in bytes. */
    size := func(self: Vec) returns I64 {
        return mul(self._len, self.type_size)
    }

    /** Create new empty vec with specified element type. */
    new := proc(T: Type) returns Vec {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        vec.ptr = NULL
        vec._len = 0
        vec.cap = 0
        return vec
    }

    /** Internal helper for Map.new() - creates Vec from type info.
     *  TODO: Remove this workaround once we can pass Dynamic params through nested calls. */
    new_from_type_info := proc(type_name: Str, type_size: I64) returns Vec {
        mut vec := Vec()
        vec.type_name = type_name
        vec.type_size = type_size
        vec.ptr = NULL
        vec._len = 0
        vec.cap = 0
        return vec
    }

    /** Create new empty vec with pre-allocated capacity.
     *  Use when you know approximately how many elements you'll need. */
    with_capacity := proc(T: Type, capacity: I64) returns Vec throws AllocError {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        vec._len = 0
        vec.cap = capacity
        if capacity.gt(0) {
            if capacity.gt(Vec.MAX_CAP) {
                panic(loc(), "Vec.with_capacity: capacity exceeded Vec.MAX_CAP")
            }
            vec.ptr = malloc(mul(capacity, vec.type_size))
            if NULL.eq(vec.ptr) {
                throw AllocError(msg=format(loc(), "Vec.with_capacity: malloc failed"))
            }
        } else {
            vec.ptr = NULL
        }
        return vec
    }

    /** Push element to end of vec. */
    push := proc(mut self: Vec, value: Dynamic) throws AllocError {
        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.push: value type mismatch")
        // }

        // Grow if needed (handles cap=0 case with max(1, cap*2))
        if self._len.eq(self.cap) {
            mut new_cap := mul(self.cap, 2)
            if lt(new_cap, 1) {
                new_cap = 1
            }
            if gt(new_cap, Vec.MAX_CAP) {
                panic(loc(), "Vec.push: capacity exceeded Vec.MAX_CAP")
            }

            mut new_ptr := malloc(mul(new_cap, self.type_size))
            if gt(self._len, 0) {
                memcpy(new_ptr, self.ptr, mul(self._len, self.type_size))
            }
            if gt(self.ptr, 0) {
                free(self.ptr)
            }
            self.ptr = new_ptr
            self.cap = new_cap
        }

        mut dest := add(self.ptr, mul(self._len, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
        self._len = add(self._len, 1)
    }

    /** Get element at index. */
    get := proc(self: Vec, index: I64, mut T: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.get: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(T), self.type_name)) { // TODO FIX
        //     throw format(loc(), format("Vec.get: destination type mismatch: expected '", self.type_name, "' found '", type_as_str(T), "'"))
        // }

        src := add(self.ptr, mul(index, self.type_size))
        mut dest := to_ptr(T)
        memcpy(dest, src, self.type_size)
    }

    /** Set element at index. */
    set := proc(mut self: Vec, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.set: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.set: value type mismatch")
        // }

        mut dest := add(self.ptr, mul(index, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
    }

    /** Pop last element from vec. */
    pop := proc(mut self: Vec, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.pop: cannot pop from empty Vec"))
        }

        // Get last element
        mut last_index := sub(self._len, 1)
        self.get(last_index, dest)

        // Decrement length
        self._len = last_index
    }

    /** Free vec memory. */
    delete := proc(mut self: Vec) {
        if gt(self.ptr, 0) {
            free(self.ptr)
        }
        self.ptr = 0
        self._len = 0
        self.cap = 0
    }

    /** Clone the vec (allocates new memory, copies elements). */
    clone := func(self: Vec) returns Vec throws AllocError {
        mut cloned := Vec()
        cloned.type_name = self.type_name
        cloned.type_size = self.type_size
        cloned._len = self._len
        cloned.cap = self.cap
        if gt(self.cap, 0) {
            mut total_bytes := mul(self.cap, self.type_size)
            cloned.ptr = malloc(total_bytes)
            if NULL.eq(cloned.ptr) {
                throw AllocError(msg=format(loc(), "Vec.clone: malloc failed"))
            }
            if gt(self._len, 0) {
                mut used_bytes := mul(self._len, self.type_size)
                memcpy(cloned.ptr, self.ptr, used_bytes)
            }
        } else {
            cloned.ptr = NULL
        }
        return cloned
    }

    /** Extend vec with all elements from another vec. */
    extend := proc(mut self: Vec, other: Vec) throws AllocError {
        mut i := 0
        while i.lt(other._len) {
            // Copy element from other to self
            src := add(other.ptr, mul(i, other.type_size))

            // Ensure capacity (handles cap=0 case with max(1, cap*2))
            if self._len.eq(self.cap) {
                mut new_cap := mul(self.cap, 2)
                if lt(new_cap, 1) {
                    new_cap = 1
                }
                if gt(new_cap, Vec.MAX_CAP) {
                    panic(loc(), "Vec.extend: capacity exceeded Vec.MAX_CAP")
                }
                mut new_ptr := malloc(mul(new_cap, self.type_size))
                if gt(self._len, 0) {
                    memcpy(new_ptr, self.ptr, mul(self._len, self.type_size))
                }
                if gt(self.ptr, 0) {
                    free(self.ptr)
                }
                self.ptr = new_ptr
                self.cap = new_cap
            }

            mut dest := add(self.ptr, mul(self._len, self.type_size))
            memcpy(dest, src, self.type_size)
            self._len = add(self._len, 1)
            i = add(i, 1)
        }
    }

    /** Extend vec with `count` copies of `value`. */
    extend_with := proc(mut self: Vec, value: Dynamic, count: I64) throws AllocError {
        for _ in 0..count {
            self.push(value)
        }
    }

    /** Check if vec contains element.
     *  Uses Str.eq() for Str elements, memcmp for others. */
    contains := func(self: Vec, value: Dynamic) returns Bool {
        mut i := 0
        while lt(i, self._len) {
            src := add(self.ptr, mul(i, self.type_size))
            // Special case for Str: compare content, not struct bytes
            if Str.eq(self.type_name, "Str") {
                mut existing := ""
                memcpy(to_ptr(existing), src, self.type_size)
                mut val_str := ""
                memcpy(to_ptr(val_str), to_ptr(value), self.type_size)
                if val_str.eq(existing) {
                    return true
                }
            } else {
                if memcmp(to_ptr(value), src, self.type_size).eq(0) {
                    return true
                }
            }
            i = add(i, 1)
        }
        return false
    }

    /** Remove element at index, shifting remaining elements left. */
    remove := proc(mut self: Vec, index: I64) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.remove: index out of bounds"))
        }

        // Shift elements left
        mut i := index
        while i.lt(sub(self._len, 1)) {
            src := add(self.ptr, mul(add(i, 1), self.type_size))
            mut dest := add(self.ptr, mul(i, self.type_size))
            memcpy(dest, src, self.type_size)
            i = add(i, 1)
        }

        self._len = sub(self._len, 1)
    }

    /** Convert vec to string representation (like Rust's {:?} format).
     *  Only works for Vec of Str elements. */
    to_str := func(self: Vec) returns Str {
        mut result := "["
        for i in 0..self._len {
            if i.gt(0) {
                result = result.concat(", ")
            }
            // For Str elements, wrap in quotes
            if Str.eq(self.type_name, "Str") {
                mut elem := ""
                src := add(self.ptr, mul(i, self.type_size))
                memcpy(to_ptr(elem), src, self.type_size)
                result = result.concat("\"").concat(elem).concat("\"")
            }
        }
        result = result.concat("]")
        return result
    }
}

// Sort a Vec<Str> in-place (simple bubble sort)
sort_str_vec := proc(mut v: Vec) {
    mut n := v.len()
    while gt(n, 1) {
        mut new_n := 0
        for i in 1..n {
            mut prev := ""
            mut curr := ""
            v.get(i.sub(1), prev)
            v.get(i, curr)
            if gt(prev.cmp(curr), 0) {
                v.set(i.sub(1), curr)
                v.set(i, prev)
                new_n = i
            }
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "sort_str_vec: ", err.msg)
            }
        }
        n = new_n
    }
}
