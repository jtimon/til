mode lib

import("core.mem")
import("core.ptr")

/**
 * Vec - Dynamic/growable array.
 * Replaces Array.new_dyn() for cases where you need to grow the array.
 */
Vec := struct {
    mut type_name : Str  = ""
    mut type_size : I64  = 0
    mut ptr       : Ptr  = Ptr()
    mut _len      : I64  = 0
    mut cap       : I64  = 0

    INIT_CAP : I64 = 0
    MAX_CAP  : I64 = 1073741824  // 1G elements - safety cap

    /** Get number of elements in vec. */
    len := func(self: Vec) returns I64 {
        return self._len
    }

    /** Check if vec is empty. */
    is_empty := func(self: Vec) returns Bool {
        return self._len.eq(0)
    }

    /** Clear all elements from vec (keeps capacity). */
    clear := proc(mut self: Vec) {
        self._len = 0
    }

    /** Get total size in bytes. */
    size := func(self: Vec) returns I64 {
        return mul(self._len, self.type_size)
    }

    /** Create new empty vec with specified element type. */
    new := proc(T: Type) returns Vec {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        vec.ptr = Ptr()
        vec._len = 0
        vec.cap = 0
        return vec
    }

    /** Internal helper for Map.new() - creates Vec from type info.
     *  TODO: Remove this workaround once we can pass Dynamic params through nested calls. */
    new_from_type_info := proc(type_name: Str, type_size: I64) returns Vec {
        mut vec := Vec()
        vec.type_name = type_name
        vec.type_size = type_size
        vec.ptr = Ptr()
        vec._len = 0
        vec.cap = 0
        return vec
    }

    /** Create new empty vec with pre-allocated capacity.
     *  Use when you know approximately how many elements you'll need. */
    with_capacity := proc(T: Type, capacity: I64) returns Vec {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        vec._len = 0
        vec.cap = capacity
        if capacity.gt(0) {
            if capacity.gt(Vec.MAX_CAP) {
                panic(loc(), "Vec.with_capacity: capacity exceeded Vec.MAX_CAP")
            }
            vec.ptr = Ptr.new_by_size(capacity.mul(vec.type_size))
        } else {
            vec.ptr = Ptr()
        }
        return vec
    }

    /** Push element to end of vec. */
    push := proc(mut self: Vec, value: Dynamic) {
        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.push: value type mismatch")
        // }

        // Grow if needed (handles cap=0 case with max(1, cap*2))
        if self._len.eq(self.cap) {
            mut new_cap := self.cap.mul(2)
            if new_cap.lt(1) {
                new_cap = 1
            }
            if new_cap.gt(Vec.MAX_CAP) {
                panic(loc(), "Vec.push: capacity exceeded Vec.MAX_CAP")
            }

            mut new_ptr := Ptr.new_by_size(new_cap.mul(self.type_size))
            if self._len.gt(0) {
                new_ptr.copy_from(self.ptr, self._len.mul(self.type_size))
            }
            if not(self.ptr.is_null()) {
                self.ptr.delete()
            }
            self.ptr = new_ptr
            self.cap = new_cap
        }

        mut dest := self.ptr.offset(self._len.mul(self.type_size))
        dest.copy_from_dynamic(value, self.type_size)
        self._len = self._len.add(1)
    }

    /** Get element at index. */
    get := proc(self: Vec, index: I64, mut T: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.get: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(T), self.type_name)) { // TODO FIX
        //     throw format(loc(), format("Vec.get: destination type mismatch: expected '", self.type_name, "' found '", type_as_str(T), "'"))
        // }

        src := self.ptr.offset(index.mul(self.type_size))
        src.copy_to_dynamic(T, self.type_size)
    }

    /** Set element at index. */
    set := proc(mut self: Vec, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.set: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.set: value type mismatch")
        // }

        mut dest := self.ptr.offset(index.mul(self.type_size))
        dest.copy_from_dynamic(value, self.type_size)
    }

    /** Pop last element from vec. */
    pop := proc(mut self: Vec, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.pop: cannot pop from empty Vec"))
        }

        // Get last element
        mut last_index := sub(self._len, 1)
        self.get(last_index, dest)?

        // Decrement length
        self._len = last_index
    }

    /** Free vec memory. */
    delete := proc(mut self: Vec) {
        if not(self.ptr.is_null()) {
            self.ptr.delete()
        }
        self.ptr = Ptr()
        self._len = 0
        self.cap = 0
    }

    /** Clone the vec (allocates new memory, copies elements). */
    clone := func(self: Vec) returns Vec {
        mut cloned := Vec()
        cloned.type_name = self.type_name
        cloned.type_size = self.type_size
        cloned._len = self._len
        cloned.cap = self.cap
        if self.cap.gt(0) {
            cloned.ptr = Ptr.new_by_size(self.cap.mul(self.type_size))
            if self._len.gt(0) {
                cloned.ptr.copy_from(self.ptr, self._len.mul(self.type_size))
            }
        } else {
            cloned.ptr = Ptr()
        }
        return cloned
    }

    /** Extend vec with all elements from another vec. */
    extend := proc(mut self: Vec, other: Vec) {
        mut i := 0
        while i.lt(other._len) {
            // Copy element from other to self
            src := other.ptr.offset(i.mul(other.type_size))

            // Ensure capacity (handles cap=0 case with max(1, cap*2))
            if self._len.eq(self.cap) {
                mut new_cap := self.cap.mul(2)
                if new_cap.lt(1) {
                    new_cap = 1
                }
                if new_cap.gt(Vec.MAX_CAP) {
                    panic(loc(), "Vec.extend: capacity exceeded Vec.MAX_CAP")
                }
                mut new_ptr := Ptr.new_by_size(new_cap.mul(self.type_size))
                if self._len.gt(0) {
                    new_ptr.copy_from(self.ptr, self._len.mul(self.type_size))
                }
                if not(self.ptr.is_null()) {
                    self.ptr.delete()
                }
                self.ptr = new_ptr
                self.cap = new_cap
            }

            mut dest := self.ptr.offset(self._len.mul(self.type_size))
            dest.copy_from(src, self.type_size)
            self._len = self._len.add(1)
            i = i.add(1)
        }
    }

    /** Extend vec with `count` copies of `value`. */
    extend_with := proc(mut self: Vec, value: Dynamic, count: I64) {
        for _ in 0..count {
            self.push(value)
        }
    }

    /** Check if vec contains element.
     *  Uses Str.eq() for Str elements, memcmp for others. */
    contains := func(self: Vec, value: Dynamic) returns Bool {
        mut i := 0
        while i.lt(self._len) {
            src := self.ptr.offset(i.mul(self.type_size))
            // Special case for Str: compare content, not struct bytes
            if Str.eq(self.type_name, "Str") {
                mut existing := ""
                src.copy_to_dynamic(existing, self.type_size)
                mut val_str := ""
                memcpy(to_ptr(val_str), to_ptr(value), self.type_size)
                if val_str.eq(existing) {
                    return true
                }
            } else {
                if memcmp(to_ptr(value), src.data, self.type_size).eq(0) {
                    return true
                }
            }
            i = i.add(1)
        }
        return false
    }

    /** Remove element at index, shifting remaining elements left. */
    remove := proc(mut self: Vec, index: I64) throws IndexOutOfBoundsError {
        if index.gteq(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.remove: index out of bounds"))
        }

        // Shift elements left
        mut i := index
        while i.lt(self._len.sub(1)) {
            src := self.ptr.offset(i.add(1).mul(self.type_size))
            mut dest := self.ptr.offset(i.mul(self.type_size))
            dest.copy_from(src, self.type_size)
            i = i.add(1)
        }

        self._len = self._len.sub(1)
    }

    /** Insert element at index, shifting remaining elements right.
     *  Index must be in range [0, len] (can insert at end). */
    insert_at := proc(mut self: Vec, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if index.gt(self._len) {
            throw IndexOutOfBoundsError(msg=format(loc(), "Vec.insert_at: index out of bounds"))
        }

        // Grow if needed (same logic as push)
        if self._len.eq(self.cap) {
            mut new_cap := self.cap.mul(2)
            if new_cap.lt(1) {
                new_cap = 1
            }
            if new_cap.gt(Vec.MAX_CAP) {
                panic(loc(), "Vec.insert_at: capacity exceeded Vec.MAX_CAP")
            }

            mut new_ptr := Ptr.new_by_size(new_cap.mul(self.type_size))
            if self._len.gt(0) {
                new_ptr.copy_from(self.ptr, self._len.mul(self.type_size))
            }
            if not(self.ptr.is_null()) {
                self.ptr.delete()
            }
            self.ptr = new_ptr
            self.cap = new_cap
        }

        // Shift elements right (from end to index)
        mut i := self._len
        while i.gt(index) {
            shift_src := self.ptr.offset(i.sub(1).mul(self.type_size))
            mut shift_dest := self.ptr.offset(i.mul(self.type_size))
            shift_dest.copy_from(shift_src, self.type_size)
            i = i.sub(1)
        }

        // Insert value at index
        mut insert_dest := self.ptr.offset(index.mul(self.type_size))
        insert_dest.copy_from_dynamic(value, self.type_size)
        self._len = self._len.add(1)
    }

    /** Convert vec to string representation (like Rust's {:?} format).
     *  Only works for Vec of Str elements. */
    to_str := func(self: Vec) returns Str {
        mut result := "["
        for i in 0..self._len {
            if i.gt(0) {
                result = result.concat(", ")
            }
            // For Str elements, wrap in quotes
            if Str.eq(self.type_name, "Str") {
                mut elem := ""
                src := self.ptr.offset(i.mul(self.type_size))
                src.copy_to_dynamic(elem, self.type_size)
                result = result.concat("\"").concat(elem).concat("\"")
            }
        }
        result = result.concat("]")
        return result
    }
}

// Sort a Vec<Str> in-place (simple bubble sort)
sort_str_vec := proc(mut v: Vec) {
    mut n := v.len()
    while gt(n, 1) {
        mut new_n := 0
        for i in 1..n {
            mut prev := ""
            mut curr := ""
            v.get(i.sub(1), prev)?
            v.get(i, curr)?
            if gt(prev.cmp(curr), 0) {
                v.set(i.sub(1), curr)?
                v.set(i, prev)?
                new_n = i
            }
            catch (err: IndexOutOfBoundsError) {
                panic(loc(), "sort_str_vec: ", err.msg)
            }
        }
        n = new_n
    }
}
