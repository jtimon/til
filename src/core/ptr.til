mode lib

import("core.mem")

/** Ptr - Pointer type wrapping a raw memory address with type info for deep cloning. */
Ptr := struct {
    mut data: I64 = NULL
    mut is_borrowed: I64 = 0  // 0 = owned, 1 = borrowed (don't free)
    // Dynamic type info for deep cloning (Bug #159)
    mut alloc_size: I64 = 0   // Total bytes allocated
    mut elem_type: I64 = NULL // Ptr to null-terminated type name C string (avoids Str circular dep)
    mut elem_size: I64 = 0    // Bytes per element (0 = single value, not array)

namespace:
    new_by_size : proc(size: I64) returns Ptr = {
        if size.lteq(0) {
            panic(loc(), "Ptr.new_by_size: invalid size")
        }
        mut p := Ptr()
        p.data = malloc(size)?
        catch (err: BadAlloc) { panic(loc(), "Ptr.new_by_size: malloc failed") }
        p.alloc_size = size
        return p
    }

    new : proc(T: Type) returns Ptr = {
        mut p := Ptr.new_by_size(size_of(T))
        p.elem_size = size_of(T)
        // elem_type must be set by caller if deep cloning is needed
        return p
    }

    /** Create a Ptr for an array of elements. */
    new_array : proc(T: Type, count: I64) returns Ptr = {
        elem_sz := size_of(T)
        total := elem_sz.mul(count)
        mut p := Ptr.new_by_size(total)
        p.elem_size = elem_sz
        // elem_type must be set by caller if deep cloning is needed
        return p
    }

    delete : proc(mut self: Ptr) = {
        if NULL.eq(self.data) {
            // Already deleted or never allocated - safe to call multiple times
            return
        }
        if self.is_borrowed.eq(0) {
            free(self.data)
        }
        self.data = NULL
    }

    clone : proc(self: Ptr) returns Ptr = {
        // Deep clone - allocates new memory and copies data.
        // For element-wise deep cloning (calling elem.clone()), use clone_deep().
        if NULL.eq(self.data) {
            return Ptr()
        }
        if self.alloc_size.lteq(0) {
            // No size info - fall back to borrowed shallow clone
            mut borrowed := Ptr()
            borrowed.data = self.data
            borrowed.is_borrowed = 1
            return borrowed
        }
        // Allocate new memory and copy bytes
        mut cloned := Ptr.new_by_size(self.alloc_size)
        cloned.elem_type = self.elem_type  // Just copy the C string pointer (static/interned)
        cloned.elem_size = self.elem_size
        memcpy(cloned.data, self.data, self.alloc_size)
        return cloned
    }

    /** Ptr.offset is danger-ous, also known as "pointer arythmetics". */
    offset : proc(self: Ptr, byte_offset: I64) returns Ptr = {
        mut p := Ptr()
        p.data = self.data.add(byte_offset)
        p.is_borrowed = 1  // Offset pointers don't own the memory
        p.elem_type = self.elem_type  // Just copy the C string pointer
        p.elem_size = self.elem_size
        // alloc_size not set - offset ptr doesn't know remaining size
        return p
    }

    copy_from : proc(mut self: Ptr, src: Ptr, size: I64) = {
        // TODO this should fail if self arg is not declared as mut
        memcpy(self.data, src.data, size)
    }

    copy_to : proc(self: Ptr, mut dest: Ptr, size: I64) = {
        memcpy(dest.data, self.data, size)
    }

    set_zero : proc(mut self: Ptr, size: I64) = {
        zero : U8 = 0
        memset(self.data, zero, size)
    }

    /** Copy from a Dynamic value into this Ptr. */
    copy_from_dynamic : proc(mut self: Ptr, value: Dynamic, size: I64) = {
        memcpy(self.data, to_ptr(value), size)
    }

    /** Copy from this Ptr into a Dynamic destination. */
    copy_to_dynamic : proc(self: Ptr, mut dest: Dynamic, size: I64) = {
        memcpy(to_ptr(dest), self.data, size)
    }

    /** Dereference pointer - copy value at this address into dest. */
    dereference : proc(self: Ptr, T: Type, mut dest: Dynamic) = {
        memcpy(to_ptr(dest), self.data, size_of(T))
    }

    // TODO FIX should type error because size is already declared
    size_of : func() returns I64 = { return size_of(I64) }

    is_null : func(self: Ptr) returns Bool = {
        return NULL.eq(self.data)
    }
}
