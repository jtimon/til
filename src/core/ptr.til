mode lib

import("core.mem")

/** Ptr - Pointer type wrapping a raw memory address. */
Ptr := struct {
    mut data: I64 = NULL

    // TODO FIX should type error because size is already declared
    size_of := func() returns I64 { return size_of(I64) }

    is_null := func(self: Ptr) returns Bool {
        return NULL.eq(self.data)
    }

    new_by_size := proc(size: I64) returns Ptr {
        if size.lteq(0) {
            panic(loc(), "Ptr.new_by_size: invalid size")
        }
        mut p := Ptr()
        p.data = malloc(size)
        catch (err: BadAlloc) { panic(loc(), "Ptr.new_by_size: malloc failed") }
        return p
    }

    new := proc(T: Type) returns Ptr {
        return Ptr.new_by_size(size_of(T))
    }

    /** Free pointer memory. Idempotent - safe to call multiple times. */
    delete := proc(mut self: Ptr) {
        if not(NULL.eq(self.data)) {
            free(self.data)
        }
        self.data = 0
    }

    /** Ptr.offset is danger-ous, also known as "pointer arythmetics". */
    offset := proc(self: Ptr, offset: I64) returns Ptr {
        mut p := Ptr()
        p.data = self.data.add(offset)
        return p
    }

    // cast := macro(self: Ptr, type_name: Str) returns Dynamic {
    //     // TODO: This cast is purely cosmetic for now.
    //     // Proper type-changing macros are not implemented yet.
    //     return self
    // }

    copy_from := proc(mut self: Ptr, src: Ptr, size: I64) {
        // TODO this should fail if self arg is not declared as mut
        memcpy(self.data, src.data, size)
    }

    copy_to := proc(self: Ptr, mut dest: Ptr, size: I64) {
        memcpy(dest.data, self.data, size)
    }

    set_zero := proc(mut self: Ptr, size: I64) {
        memset(self.data, U8.from_i64(0), size)
    }
}
