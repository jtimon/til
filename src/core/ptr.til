mode lib

import("core.mem")

/** Ptr - Pointer type wrapping a raw memory address. */
Ptr := struct {
    mut data: I64 = NULL
    mut is_borrowed: I64 = 0  // 0 = owned, 1 = borrowed (don't free)
}

namespace Ptr {
    new_by_size := proc(size: I64) returns Ptr {
        if size.lteq(0) {
            panic(loc(), "Ptr.new_by_size: invalid size")
        }
        mut p := Ptr()
        p.data = malloc(size)?
        catch (err: BadAlloc) { panic(loc(), "Ptr.new_by_size: malloc failed") }
        return p
    }

    new := proc(T: Type) returns Ptr {
        return Ptr.new_by_size(size_of(T))
    }

    delete := proc(mut self: Ptr) {
        if NULL.eq(self.data) {
            // Already deleted or never allocated - safe to call multiple times
            return
        }
        if self.is_borrowed.eq(0) {
            free(self.data)
        }
        self.data = NULL
    }

    clone := func(self: Ptr) returns Ptr {
        // Shallow clone - copies the pointer value, not the pointed-to data.
        // The clone is marked as borrowed to prevent double-free.
        mut p := Ptr()
        p.data = self.data
        p.is_borrowed = 1
        return p
    }

    /** Ptr.offset is danger-ous, also known as "pointer arythmetics". */
    offset := proc(self: Ptr, offset: I64) returns Ptr {
        mut p := Ptr()
        p.data = self.data.add(offset)
        return p
    }

    copy_from := proc(mut self: Ptr, src: Ptr, size: I64) {
        // TODO this should fail if self arg is not declared as mut
        memcpy(self.data, src.data, size)
    }

    copy_to := proc(self: Ptr, mut dest: Ptr, size: I64) {
        memcpy(dest.data, self.data, size)
    }

    set_zero := proc(mut self: Ptr, size: I64) {
        zero : U8 = 0
        memset(self.data, zero, size)
    }

    /** Copy from a Dynamic value into this Ptr. */
    copy_from_dynamic := proc(mut self: Ptr, value: Dynamic, size: I64) {
        memcpy(self.data, to_ptr(value), size)
    }

    /** Copy from this Ptr into a Dynamic destination. */
    copy_to_dynamic := proc(self: Ptr, mut dest: Dynamic, size: I64) {
        memcpy(to_ptr(dest), self.data, size)
    }

    /** Dereference pointer - copy value at this address into dest. */
    dereference := proc(self: Ptr, T: Type, mut dest: Dynamic) {
        memcpy(to_ptr(dest), self.data, size_of(T))
    }

    // TODO FIX should type error because size is already declared
    size_of := func() returns I64 { return size_of(I64) }

    is_null := func(self: Ptr) returns Bool {
        return NULL.eq(self.data)
    }
}
