mode lib

import("core.vec")
import("core.mem")

HeapEntry := struct {
    mut ptr: I64 = 0
    mut size: I64 = 0
}

mut g_entries := Vec()
mut g_enabled := false

HeapState := struct {

namespace:

    enable : proc() = {
        g_entries = Vec.new(HeapEntry)
        g_enabled = true
    }

    disable : proc() = {
        g_enabled = false
    }

    add : proc(ptr: I64, size: I64) = {
        if not(g_enabled) { return }
        mut entry := HeapEntry(ptr=ptr, size=size)
        g_entries.push(own entry)
    }

    remove : proc(ptr: I64) = {
        if not(g_enabled) { return }
        if ptr.eq(0) { return }
        for i in 0..g_entries.len() {
            entry := cast(HeapEntry, g_entries.get(i)?)
            if entry.ptr.eq(ptr) {
                mut freed := HeapEntry(ptr=0, size=entry.size)
                g_entries.set(i, own freed)?
                return
            }
        }
        println("HEAP_STATE PANIC: double-free for pointer", ptr.to_str())
        exit(1)

        catch (err: IndexOutOfBoundsError) {
            println("HEAP_STATE: unexpected index error in remove")
            exit(1)
        }
    }

    report : proc() = {
        if not(g_enabled) { return }
        mut leaked := 0
        mut leaked_bytes := 0
        for entry: HeapEntry in g_entries {
            if not(entry.ptr.eq(0)) {
                leaked = leaked.add(1)
                leaked_bytes = leaked_bytes.add(entry.size)
            }
        }
        println(format("HEAP_STATE: leaked ", leaked.to_str(), " allocations, ", leaked_bytes.to_str(), " bytes"))
    }
}
