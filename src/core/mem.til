mode lib

BadAlloc := struct {}

// Memory operations
NULL   := 0
size_of := ext_func(type: Type) returns I64 {}
to_ptr := ext_func(var_identifier: Dynamic) returns I64 {}
type_as_str := ext_func(type: Type) returns Str {}
// TODO Use throws for memory operations, don't return 0 from malloc
malloc := ext_func(size: I64) returns I64 throws BadAlloc {}
free   := ext_func(ptr: I64) {}
memcpy := ext_func(dest: I64, src: I64, size: I64) {}
memcmp := ext_func(ptr1: I64, ptr2: I64, size: I64) returns I64 {}
memset := ext_func(dest: I64, value: U8, size: I64) {}

// dont_delete(var) - directive for the garbager, not a real function.
// Tells Step 10 (auto-delete) to skip deletion of this variable.
// Stripped from AST by the garbager phase before execution.
dont_delete := ext_func(var_identifier: Dynamic) {}

// Bug #144: create_alias(var, type, addr) - compound directive.
// Declares var of given type and rebinds its arena offset to addr.
// Zero-copy aliasing: var reads directly from addr. Skips auto-delete.
create_alias := ext_func(var_identifier: Dynamic, type_name: Type, source_addr: I64) {}
