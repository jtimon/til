mode lib

import("src/core/typer")

// Interpreter phase: Runtime evaluation and execution
// Corresponds to src/rs/interpreter.rs in the Rust implementation

// Global arena for interpreter memory (simplified version)
// In rstil.rs this is a singleton, here we'll pass it around
Arena := struct {
    mut memory: Array = Array()       // Byte array for storage
    mut next_offset: I64 = 1          // Next available offset (0 is reserved/NULL)

    // Create new arena
    new := proc() returns Arena throws AllocError {
        mut a := Arena()
        a.memory = Array.new_dyn("U8", size_of(U8))
        a.next_offset = 1  // Reserve 0 as invalid/NULL
        return a
    }
}

// Result of evaluating an expression
// Corresponds to EvalResult in interpreter.rs
EvalResult := struct {
    mut value: Str = ""                // The result value as string
    mut is_return: Bool = false        // True if this is a return statement
    mut is_throw: Bool = false         // True if this is a throw statement
    mut thrown_type: Str = ""          // Type of thrown value (if is_throw)

    // Create normal result
    new := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    // Create return result
    new_return := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = true
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    // Create throw result
    new_throw := proc(value: Str, thrown_type: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = true
        result.thrown_type = thrown_type
        return result
    }
}

// Evaluate an expression
// Returns EvalResult (not throws - errors returned as EvalResult)
// Corresponds to eval_expr in interpreter.rs
eval_expr := proc(mut context: Context, e: Expr) returns EvalResult throws Str, AllocError, IndexOutOfBoundsError {
    // Match on node type
    switch e.node_type {
    case NodeType.Body:
        // TODO: eval_body
        TODO(loc(), "eval_body not yet implemented")
        return EvalResult.new("")

    case NodeType.Literal(lit):
        // Handle literals - return value directly
        switch lit {
        case LiteralNodeType.Bool(b):
            if b {
                return EvalResult.new("true")
            }
            return EvalResult.new("false")
        case LiteralNodeType.I64(i):
            return EvalResult.new(I64.to_str(i))
        case LiteralNodeType.String(s):
            return EvalResult.new(s)
        case LiteralNodeType.List(l):
            return EvalResult.new(l)
        }

    case NodeType.FCall:
        // TODO: eval_func_proc_call
        TODO(loc(), "eval_func_proc_call not yet implemented")
        return EvalResult.new("")

    case NodeType.Declaration(decl):
        // TODO: eval_declaration
        TODO(loc(), format("eval_declaration not yet implemented for '", decl.name, "'"))
        return EvalResult.new("")

    case NodeType.Assignment(var_name):
        // TODO: eval_assignment
        TODO(loc(), format("eval_assignment not yet implemented for '", var_name, "'"))
        return EvalResult.new("")

    case NodeType.Identifier(name):
        // TODO: eval_identifier_expr
        TODO(loc(), format("eval_identifier_expr not yet implemented for '", name, "'"))
        return EvalResult.new("")

    case NodeType.If:
        // TODO: eval if statement
        TODO(loc(), "if statement eval not yet implemented")
        return EvalResult.new("")

    case NodeType.While:
        // TODO: eval while loop
        TODO(loc(), "while loop eval not yet implemented")
        return EvalResult.new("")

    case NodeType.Switch:
        // TODO: eval switch statement
        TODO(loc(), "switch statement eval not yet implemented")
        return EvalResult.new("")

    case NodeType.Return:
        // TODO: eval return statement
        TODO(loc(), "return statement eval not yet implemented")
        return EvalResult.new("")

    case NodeType.Throw:
        // TODO: eval throw statement
        TODO(loc(), "throw statement eval not yet implemented")
        return EvalResult.new("")

    case NodeType.Catch:
        // TODO: eval catch statement
        TODO(loc(), "catch statement eval not yet implemented")
        return EvalResult.new("")

    case NodeType.FuncDef(_):
        // Function definitions don't eval to a value
        return EvalResult.new("")

    case NodeType.EnumDef(_):
        // Enum definitions don't eval to a value
        return EvalResult.new("")

    case NodeType.StructDef(_):
        // Struct definitions don't eval to a value
        return EvalResult.new("")

    case NodeType.Range:
        // Ranges are only valid in for-loops (already desugared)
        TODO(loc(), "Range should not appear in eval (should be desugared)")
        return EvalResult.new("")

    case NodeType.DefaultCase:
        // Default case only appears in switch (handled above)
        TODO(loc(), "DefaultCase should not appear in eval outside switch")
        return EvalResult.new("")

    case NodeType.Pattern(_, _):
        // Pattern only appears in switch (handled above)
        TODO(loc(), "Pattern should not appear in eval outside switch")
        return EvalResult.new("")

    case:
        // Unhandled node type
        TODO(loc(), "eval_expr: Unhandled node type")
        return EvalResult.new("")
    }
}

// Evaluate a literal expression
eval_literal := proc(context: Context, e: Expr) returns Str throws Str {
    // Extract the literal type and value
    mut literal_type := e.node_type
    literal_str := enum_to_str(literal_type)

    // Use pattern matching to extract LiteralNodeType from NodeType.Literal
    switch literal_type {
    case NodeType.Literal(lit_node_type):
        // Now extract primitive payloads from LiteralNodeType
        switch lit_node_type {
        case LiteralNodeType.String(str_val):
            return str_val
        case LiteralNodeType.I64(i64_val):
            mut i64_copy := i64_val
            return i64_copy.to_str()
        case LiteralNodeType.Bool(bool_val):
            if bool_val {
                return "true"
            }
            return "false"
        case LiteralNodeType.List:
            // Lists not implemented yet
            throw format(loc(), " ERROR: List literals not yet implemented")
        case:
            // Unknown literal types
            lit_type_str := enum_to_str(lit_node_type)
            throw format(loc(), " ERROR: Unknown literal type: ", lit_type_str)
        }
    case:
        throw format(loc(), " ERROR: Unknown literal type: ", literal_str)
    }
}

// Evaluate an identifier (variable lookup)
eval_identifier := proc(context: Context, e: Expr) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
    // Get identifier name from node_type payload using pattern matching
    mut node_type := e.node_type
    mut var_name := ""
    switch node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        // Should never happen for this eval function
    }

    // Look up in symbol table to get type
    mut symbols_map := context.symbols
    mut symbol_info_str := symbols_map.get(var_name)
    if symbol_info_str.eq("") {
        throw format(loc(), " ERROR: Variable '", var_name, "' not found")
    }

    // For now, try each type - later we'll parse SymbolInfo properly
    // For Phase 2, we'll just try I64, Str, Bool in order until one works

    // Try I64 first
    mut i64_result := context.get_i64(var_name)
    mut str_result := ""
    mut bool_result := false
    mut which_type := "i64"

    catch (err: Str) {
        // Not I64, try Str
        which_type = "str"
        str_result = context.get_str(var_name)
        catch (err2: Str) {
            // Not Str, try Bool
            which_type = "bool"
            bool_result = context.get_bool(var_name)
            catch (err3: Str) {
                throw format(loc(), " ERROR: Could not retrieve variable '", var_name, "' as any known type")
            }
        }
    }

    // Return based on which type succeeded
    mut wt_copy := which_type
    if wt_copy.eq("i64") {
        mut val_copy := i64_result
        return val_copy.to_str()
    }

    if wt_copy.eq("str") {
        return str_result
    }

    // Must be bool
    if bool_result {
        return "true"
    }
    return "false"
}

// Evaluate a declaration - Phase 2: simple types only
// Handles I64, Str, Bool declarations with initializers
eval_declaration := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Extract Declaration from node_type
    mut node_type := e.node_type
    mut decl := Declaration()
    switch node_type {
    case NodeType.Declaration(d):
        decl = d
    case:
        // Other node types
    }

    // Get the initializer expression (params[0])
    mut params_array := e.params
    if lt(params_array.len, 1) {
        throw format(loc(), " ERROR: Declaration of '", decl.name, "' has no initializer expression")
    }

    mut init_expr := Expr()
    params_array.get(0, init_expr)

    // Evaluate the initializer
    init_value := eval_expr(context, init_expr)

    // Store in symbol table (simplified: just store type as string)
    mut symbols_map := context.symbols
    symbols_map.insert(decl.name, decl.value_type)

    // Store the actual value based on type
    mut value_type := decl.value_type
    if value_type.eq("I64") {
        mut init_val_str := init_value
        init_i64 := init_val_str.to_i64()
        context.insert_i64(decl.name, init_i64)
    }
    else if value_type.eq("Str") {
        context.insert_str(decl.name, init_value)
    }
    else if value_type.eq("Bool") {
        // Parse "true" or "false" string to boolean
        mut init_val_str := init_value
        is_true := init_val_str.eq("true")
        context.insert_bool(decl.name, is_true)
    }
    else {
        throw format(loc(), " ERROR: Declaration of '", decl.name, "' has unsupported type '", value_type, "' (Phase 2 only supports I64, Str, Bool)")
    }

    return ""
}

// Evaluate an assignment
// Phase 2: simple types only, no mutability checking yet
eval_assignment := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Extract variable name from node_type using pattern matching
    mut node_type := e.node_type
    mut var_name := ""
    switch node_type {
    case NodeType.Identifier(name):
        var_name = name
    case:
        // Should never happen for this eval function
    }

    // Look up symbol to verify it exists and get its type
    mut symbols_map := context.symbols
    mut value_type_str := symbols_map.get(var_name)
    if value_type_str.eq("") {
        throw format(loc(), " ERROR: Variable '", var_name, "' not found in assignment")
    }

    // Get the value expression (params[0])
    mut params_array := e.params
    if lt(params_array.len, 1) {
        throw format(loc(), " ERROR: Assignment to '", var_name, "' has no value expression")
    }

    mut value_expr := Expr()
    params_array.get(0, value_expr)

    // Evaluate the value expression
    new_value := eval_expr(context, value_expr)

    // Update the value based on type
    mut vt_copy := value_type_str
    if vt_copy.eq("I64") {
        mut new_val_str := new_value
        new_i64 := new_val_str.to_i64()
        context.insert_i64(var_name, new_i64)
    }
    else if vt_copy.eq("Str") {
        context.insert_str(var_name, new_value)
    }
    else if vt_copy.eq("Bool") {
        mut new_val_str := new_value
        is_true := new_val_str.eq("true")
        context.insert_bool(var_name, is_true)
    }
    else {
        throw format(loc(), " ERROR: Assignment to '", var_name, "' has unsupported type '", value_type_str, "' (Phase 2 only supports I64, Str, Bool)")
    }

    return ""
}

// Helper: evaluate println function
eval_println := proc(mut context: Context, params: Array) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Print each argument (skip params[0] which is the function name)
    for i in 1..params.len {
        mut arg_expr := Expr()
        params.get(i, arg_expr)

        // Evaluate the argument and print its string representation
        result_str := eval_expr(context, arg_expr)
        print(result_str)
    }
    println("")
    return ""
}

// Evaluate a function call
// Phase 2: basic arithmetic and core functions only
eval_fcall := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Get function name from params[0]
    mut params_array := e.params
    if lt(params_array.len, 1) {
        throw format(loc(), " ERROR: Function call has no function name")
    }

    mut func_name_expr := Expr()
    params_array.get(0, func_name_expr)

    mut func_node_type := func_name_expr.node_type

    // WORKAROUND for rstil bug: rsonly_enum_extract_payload corrupts strings during recursive calls
    // enum_to_str() doesn't include payload, so we can't distinguish between functions
    // TEMPORARY HACK: For hello_script.til test, just assume all calls are println
    // TODO: Fix this properly - possibly by using switch statement to extract payload
    println("DEBUG: Calling eval_println (assuming all functions are println due to rstil bug)")
    return eval_println(context, params_array)

    // TODO: Restore proper function dispatch once rstil bug is fixed or switch-based workaround is implemented
    // The code below is commented out because it's unreachable after the return above
    /*
    // Binary arithmetic operations
    if node_type_full_str.eq("NodeType.Identifier(add)") {
        return eval_binary_i64_op(context, params_array, "add")
    }
    if node_type_full_str.eq("NodeType.Identifier(sub)") {
        return eval_binary_i64_op(context, params_array, "sub")
    }
    if node_type_full_str.eq("NodeType.Identifier(mul)") {
        return eval_binary_i64_op(context, params_array, "mul")
    }
    if node_type_full_str.eq("NodeType.Identifier(div)") {
        return eval_binary_i64_op(context, params_array, "div")
    }
    if node_type_full_str.eq("NodeType.Identifier(mod)") {
        return eval_binary_i64_op(context, params_array, "mod")
    }

    // Comparison operations
    if node_type_full_str.eq("NodeType.Identifier(lt)") {
        return eval_comparison_op(context, params_array, "lt")
    }
    if node_type_full_str.eq("NodeType.Identifier(gt)") {
        return eval_comparison_op(context, params_array, "gt")
    }
    if node_type_full_str.eq("NodeType.Identifier(eq)") {
        return eval_comparison_op(context, params_array, "eq")
    }

    if node_type_full_str.eq("NodeType.Identifier(readfile)") {
        // For now, just call the external readfile function
        // TODO Phase 4: Full implementation
        if lt(params_array.len, 2) {
            throw format(loc(), " ERROR: readfile requires 1 argument")
        }
        mut path_expr := Expr()
        params_array.get(1, path_expr)
        path_str := eval_expr(context, path_expr)
        return readfile(path_str)
    }

    if node_type_full_str.eq("NodeType.Identifier(scan_tokens)") {
        // For now, just call the external scan_tokens function
        // TODO Phase 4: Full implementation - this should call the self-hosted lexer
        if lt(params_array.len, 2) {
            throw format(loc(), " ERROR: scan_tokens requires 1 argument")
        }
        mut source_expr := Expr()
        params_array.get(1, source_expr)
        source_str := eval_expr(context, source_expr)
        // scan_tokens returns a TokenArray, but we can't return that from eval_expr (which returns Str)
        // This is a limitation - we need proper struct support
        // For now, just throw an error
        throw format(loc(), " ERROR: scan_tokens not yet supported in self-hosted interpreter (needs struct return values)")
    }

    throw format(loc(), " ERROR: Function not implemented (Phase 2 only supports add, sub, mul, div, mod, lt, gt, eq, println, readfile)")
    */
}

// Helper: evaluate binary I64 operations
eval_binary_i64_op := proc(mut context: Context, params: Array, op: Str) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    if lt(params.len, 3) {
        throw format(loc(), " ERROR: ", op, " requires 2 arguments")
    }

    // Get arg1 and arg2 (params[1] and params[2])
    mut arg1_expr := Expr()
    mut arg2_expr := Expr()
    params.get(1, arg1_expr)
    params.get(2, arg2_expr)

    // Evaluate arguments
    arg1_str := eval_expr(context, arg1_expr)
    arg2_str := eval_expr(context, arg2_expr)

    // Convert to I64
    mut a1_copy := arg1_str
    mut a2_copy := arg2_str
    a1 := a1_copy.to_i64()
    a2 := a2_copy.to_i64()

    // Perform operation
    mut result := 0
    mut op_copy := op
    if op_copy.eq("add") {
        result = add(a1, a2)
    }
    else if op_copy.eq("sub") {
        result = sub(a1, a2)
    }
    else if op_copy.eq("mul") {
        result = mul(a1, a2)
    }
    else if op_copy.eq("div") {
        result = div(a1, a2)
    }
    else if op_copy.eq("mod") {
        result = mod(a1, a2)
    }

    mut res_copy := result
    return res_copy.to_str()
}

// Helper: evaluate comparison operations
eval_comparison_op := proc(mut context: Context, params: Array, op: Str) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    if lt(params.len, 3) {
        throw format(loc(), " ERROR: ", op, " requires 2 arguments")
    }

    // Get arg1 and arg2
    mut arg1_expr := Expr()
    mut arg2_expr := Expr()
    params.get(1, arg1_expr)
    params.get(2, arg2_expr)

    // Evaluate arguments
    arg1_str := eval_expr(context, arg1_expr)
    arg2_str := eval_expr(context, arg2_expr)

    // Convert to I64 for numeric comparison
    mut a1_copy := arg1_str
    mut a2_copy := arg2_str
    a1 := a1_copy.to_i64()
    a2 := a2_copy.to_i64()

    // Perform comparison
    mut result := false
    mut op_copy := op
    if op_copy.eq("lt") {
        result = lt(a1, a2)
    }
    else if op_copy.eq("gt") {
        result = gt(a1, a2)
    }
    else if op_copy.eq("eq") {
        result = eq(a1, a2)
    }

    if result {
        return "true"
    }
    return "false"
}

// Evaluate a body (sequence of statements)
// Phase 3: basic catch support (skips catch blocks, doesn't actually handle errors)
eval_body := proc(mut context: Context, e: Expr) returns Str throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // Get the statements array
    mut params_array := e.params
    mut num_stmts := params_array.len

    // Evaluate each statement in sequence
    mut i := 0
    mut last_result := ""
    while lt(i, num_stmts) {
        mut stmt := Expr()
        params_array.get(i, stmt)

        // Phase 3: Skip catch blocks (don't evaluate them unless there's a pending throw)
        // TODO: Implement proper throw/catch mechanism
        mut stmt_type_str := enum_to_str(stmt.node_type)
        mut is_catch := stmt_type_str.eq("NodeType.Catch")

        if not(is_catch) {
            last_result = eval_expr(context, stmt)
        }

        i = add(i, 1)
    }

    // Return the last result (or empty string if no statements)
    return last_result
}
