mode lib

import("src.core.mem")

/**
 * Vec - Dynamic/growable array.
 * Replaces Array.new_dyn() for cases where you need to grow the array.
 */
Vec := struct {
    mut type_name : Str  = ""
    mut type_size : I64  = 0
    mut ptr       : I64  = 0
    mut _len      : I64  = 0
    mut cap       : I64  = 0

    INIT_CAP : I64 = 16
    MAX_CAP  : I64 = 1024

    /** Get number of elements in vec. */
    len := func(self: Vec) returns I64 {
        return self._len
    }

    /** Get total size in bytes. */
    size := func(self: Vec) returns I64 {
        return mul(self._len, self.type_size)
    }

    /** Create new empty vec with specified element type. */
    new := proc(T: Type) returns Vec throws AllocError {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        size_bytes := mul(Vec.INIT_CAP, vec.type_size)
        vec.ptr = malloc(size_bytes)
        vec._len = 0
        vec.cap = Vec.INIT_CAP
        return vec
    }

    /** Internal helper for Map.new() - creates Vec from type info.
     *  TODO: Remove this workaround once we can pass Dynamic params through nested calls. */
    new_from_type_info := proc(type_name: Str, type_size: I64) returns Vec throws AllocError {
        mut vec := Vec()
        vec.type_name = type_name
        vec.type_size = type_size
        size_bytes := mul(Vec.INIT_CAP, vec.type_size)
        vec.ptr = malloc(size_bytes)
        vec._len = 0
        vec.cap = Vec.INIT_CAP
        return vec
    }

    /** Push element to end of vec. */
    push := proc(mut self: Vec, value: Dynamic) throws AllocError {
        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.push: value type mismatch")
        // }

        if self._len.eq(self.cap) {
            new_cap := mul(self.cap, 2)
            if gt(new_cap, Vec.MAX_CAP) {
                panic(loc(), "Vec.push: capacity exceeded Vec.MAX_CAP")
            }

            mut new_ptr := malloc(mul(new_cap, self.type_size))
            memcpy(new_ptr, self.ptr, mul(self._len, self.type_size))
            free(self.ptr)
            self.ptr = new_ptr
            self.cap = new_cap
        }

        mut dest := add(self.ptr, mul(self._len, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
        self._len = add(self._len, 1)
    }

    /** Get element at index. */
    get := proc(self: Vec, index: I64, mut T: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.get: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(T), self.type_name)) { // TODO FIX
        //     throw format(loc(), format("Vec.get: destination type mismatch: expected '", self.type_name, "' found '", type_as_str(T), "'"))
        // }

        src := add(self.ptr, mul(index, self.type_size))
        mut dest := to_ptr(T)
        memcpy(dest, src, self.type_size)
    }

    /** Set element at index. */
    set := proc(mut self: Vec, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.set: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.set: value type mismatch")
        // }

        mut dest := add(self.ptr, mul(index, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
    }

    /** Pop last element from vec. */
    pop := proc(mut self: Vec, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.pop: cannot pop from empty Vec"))
        }

        // Get last element
        mut last_index := sub(self._len, 1)
        self.get(last_index, dest)

        // Decrement length
        self._len = last_index
    }

    /** Free vec memory. */
    delete := proc(mut self: Vec) {
        free(self.ptr)
        self.ptr = 0
        self._len = 0
        self.cap = 0
    }

    /** Clone the vec. */
    clone := func(self: Vec) returns Vec throws AllocError {
        mut cloned := Vec()
        cloned.type_name = self.type_name
        cloned.type_size = self.type_size
        cloned._len = self._len
        cloned.cap = self.cap
        mut total_bytes := mul(self.cap, self.type_size)
        cloned.ptr = malloc(total_bytes)
        if NULL.eq(cloned.ptr) {
            throw AllocError.new(format(loc(), "Vec.clone: malloc failed for ", I64.to_str(total_bytes), " bytes"))
        }
        // Copy only the used portion (_len), not the entire capacity
        mut used_bytes := mul(self._len, self.type_size)
        memcpy(cloned.ptr, self.ptr, used_bytes)
        return cloned
    }

    /** Extend vec with all elements from another vec. */
    extend := proc(mut self: Vec, other: Vec) throws AllocError {
        mut i := 0
        while i.lt(other._len) {
            // Copy element from other to self
            src := add(other.ptr, mul(i, other.type_size))

            // Ensure capacity
            if self._len.eq(self.cap) {
                new_cap := mul(self.cap, 2)
                if gt(new_cap, Vec.MAX_CAP) {
                    panic(loc(), "Vec.extend: capacity exceeded Vec.MAX_CAP")
                }
                mut new_ptr := malloc(mul(new_cap, self.type_size))
                memcpy(new_ptr, self.ptr, mul(self._len, self.type_size))
                free(self.ptr)
                self.ptr = new_ptr
                self.cap = new_cap
            }

            mut dest := add(self.ptr, mul(self._len, self.type_size))
            memcpy(dest, src, self.type_size)
            self._len = add(self._len, 1)
            i = add(i, 1)
        }
    }

    /** Remove element at index, shifting remaining elements left. */
    remove := proc(mut self: Vec, index: I64) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.remove: index out of bounds"))
        }

        // Shift elements left
        mut i := index
        while i.lt(sub(self._len, 1)) {
            src := add(self.ptr, mul(add(i, 1), self.type_size))
            dest := add(self.ptr, mul(i, self.type_size))
            memcpy(dest, src, self.type_size)
            i = add(i, 1)
        }

        self._len = sub(self._len, 1)
    }
}
