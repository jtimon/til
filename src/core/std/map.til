mode lib

import("src.core.std.vec")

DuplicatedKeyError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns DuplicatedKeyError {
        mut err := DuplicatedKeyError()
        err.msg = msg
        return err
    }
}

KeyNotFoundError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns KeyNotFoundError {
        mut err := KeyNotFoundError()
        err.msg = msg
        return err
    }
}

/**
 * Generic Map implementation - ordered, not hashed.
 * Uses parallel arrays for keys and values (maintains insertion order).
 * Type parameters passed as strings (key_type_name, value_type_name).
 * No generics syntax needed - uses dynamic typing like Array.
 *
 * Key type support:
 *   - Str: Fully supported (uses Str.eq() for content comparison)
 *   - I64, U8, Bool: Fully supported (uses memcmp for byte comparison)
 *   - Other primitives: Should work with memcmp
 *   - Structs: NOT recommended as keys (memcmp compares raw bytes including padding)
 *
 * Value type support:
 *   - Fully dynamic: Any type works (I64, Str, Bool, U8, Vec2, Array, etc.)
 *   - Uses memcpy for storage and retrieval
 */
Map := struct {
    mut key_type_name: Str = ""       // e.g., "Str", "I64"
    mut key_type_size: I64 = 0        // from size_of(KeyType)
    mut value_type_name: Str = ""     // e.g., "Str", "Bool", "Expr"
    mut value_type_size: I64 = 0      // from size_of(ValueType)
    mut keys: Vec = Vec()         // Dynamic array of keys
    mut values: Vec = Vec()       // Dynamic array of values (parallel)
    mut _size: I64 = 0                // Number of entries (internal, use len() to access)

    /** Create new empty map with specified key and value types.
     *  Example: Map.new(Str, I64) */
    new := proc(KeyType: Type, ValueType: Type) returns Map throws AllocError {
        mut m := Map()
        m.key_type_name = type_as_str(KeyType)
        m.key_type_size = size_of(KeyType)
        m.value_type_name = type_as_str(ValueType)
        m.value_type_size = size_of(ValueType)
        // Can't pass Dynamic params to Vec.new(), so use type info directly
        m.keys = Vec.new_from_type_info(m.key_type_name, m.key_type_size)
        m.values = Vec.new_from_type_info(m.value_type_name, m.value_type_size)
        m._size = 0
        return m
    }

    /** Insert new key-value pair.
     *  Throws DuplicatedKeyError if key already exists.
     *  Use set() instead if you want to overwrite existing keys. */
    insert := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError, DuplicatedKeyError {
        // Check if key already exists
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                // For other types, use memcmp
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key already exists - throw error
                throw DuplicatedKeyError.new(format(loc(), "Key already exists in map"))
            }
            i = add(i, 1)
        }

        // Key doesn't exist - add it
        // Workaround for bug: pushing Dynamic parameters doesn't work
        // Instead, manually grow the array and memcpy directly
        if self.keys._len.eq(self.keys.cap) {
            // Need to grow
            mut new_cap := mul(self.keys.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.keys.type_size))
            memcpy(new_ptr, self.keys.ptr, mul(self.keys._len, self.keys.type_size))
            free(self.keys.ptr)
            self.keys.ptr = new_ptr
            self.keys.cap = new_cap
        }
        // Copy key directly into array memory
        mut dest_ptr := add(self.keys.ptr, mul(self.keys._len, self.keys.type_size))
        memcpy(dest_ptr, to_ptr(key), self.keys.type_size)
        self.keys._len = add(self.keys._len, 1)

        // Same workaround for values
        if self.values._len.eq(self.values.cap) {
            mut new_cap := mul(self.values.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.values.type_size))
            memcpy(new_ptr, self.values.ptr, mul(self.values._len, self.values.type_size))
            free(self.values.ptr)
            self.values.ptr = new_ptr
            self.values.cap = new_cap
        }
        mut dest_ptr := add(self.values.ptr, mul(self.values._len, self.values.type_size))
        memcpy(dest_ptr, to_ptr(value), self.values.type_size)
        self.values._len = add(self.values._len, 1)

        self._size = add(self._size, 1)
    }

    /** Set key-value pair.
     *  Overwrites value if key already exists.
     *  Creates new entry if key doesn't exist. */
    set := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError {
        // Try to find existing key
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key found - update value
                mut values_arr := self.values
                mut value_ptr := add(values_arr.ptr, mul(i, self.value_type_size))
                memcpy(value_ptr, to_ptr(value), self.value_type_size)
                return
            }
            i = add(i, 1)
        }

        // Key not found - insert new entry (use same workaround as insert())
        if self.keys._len.eq(self.keys.cap) {
            mut new_cap := mul(self.keys.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.keys.type_size))
            memcpy(new_ptr, self.keys.ptr, mul(self.keys._len, self.keys.type_size))
            free(self.keys.ptr)
            self.keys.ptr = new_ptr
            self.keys.cap = new_cap
        }
        mut dest_ptr := add(self.keys.ptr, mul(self.keys._len, self.keys.type_size))
        memcpy(dest_ptr, to_ptr(key), self.keys.type_size)
        self.keys._len = add(self.keys._len, 1)

        if self.values._len.eq(self.values.cap) {
            mut new_cap := mul(self.values.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.values.type_size))
            memcpy(new_ptr, self.values.ptr, mul(self.values._len, self.values.type_size))
            free(self.values.ptr)
            self.values.ptr = new_ptr
            self.values.cap = new_cap
        }
        mut dest_ptr2 := add(self.values.ptr, mul(self.values._len, self.values.type_size))
        memcpy(dest_ptr2, to_ptr(value), self.values.type_size)
        self.values._len = add(self.values._len, 1)

        self._size = add(self._size, 1)
    }

    /** Get value for given key.
     *  Copies value into dest parameter.
     *  Throws KeyNotFoundError if key doesn't exist. */
    get := proc(self: Map, key: Dynamic, mut dest: Dynamic) throws KeyNotFoundError {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key found - get value
                mut values_arr := self.values
                mut value_ptr := add(values_arr.ptr, mul(i, self.value_type_size))
                memcpy(to_ptr(dest), value_ptr, self.value_type_size)
                return
            }
            i = add(i, 1)
        }

        // Key not found
        throw KeyNotFoundError.new(format(loc(), "Key not found in map"))
    }

    /** Check if key exists in map. */
    contains_key := proc(self: Map, key: Dynamic) returns Bool {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                return true
            }
            i = add(i, 1)
        }
        return false
    }

    /** Remove key from map. Does nothing if key doesn't exist. */
    remove := proc(mut self: Map, key: Dynamic) {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key found - remove by shifting all subsequent elements down
                mut j := i
                while lt(j, sub(self._size, 1)) {
                    // Shift keys
                    mut src_key_ptr := add(self.keys.ptr, mul(add(j, 1), self.key_type_size))
                    mut dst_key_ptr := add(self.keys.ptr, mul(j, self.key_type_size))
                    memcpy(dst_key_ptr, src_key_ptr, self.key_type_size)

                    // Shift values
                    mut src_val_ptr := add(self.values.ptr, mul(add(j, 1), self.value_type_size))
                    mut dst_val_ptr := add(self.values.ptr, mul(j, self.value_type_size))
                    memcpy(dst_val_ptr, src_val_ptr, self.value_type_size)

                    j = add(j, 1)
                }

                // Decrease size
                self._size = sub(self._size, 1)
                self.keys._len = sub(self.keys._len, 1)
                self.values._len = sub(self.values._len, 1)
                return
            }
            i = add(i, 1)
        }
        // Key not found - do nothing
    }

    /** Get position (index) of key in insertion order.
     *  Returns -1 if key not found.
     *  Useful for enum variant tags which depend on insertion order. */
    position := proc(self: Map, key: Dynamic) returns I64 {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                return i
            }
            i = add(i, 1)
        }
        return sub(0, 1)  // -1 for not found
    }

    /** Get number of entries in map. */
    len := proc(self: Map) returns I64 {
        return self._size
    }

    /** Get total size in bytes (keys + values). */
    size := func(self: Map) returns I64 {
        mut keys_size := mul(self._size, self.key_type_size)
        mut values_size := mul(self._size, self.value_type_size)
        return add(keys_size, values_size)
    }

    /** Free map memory and reset. */
    delete := proc(mut self: Map) {
        mut keys_arr := self.keys
        keys_arr.delete()

        mut values_arr := self.values
        values_arr.delete()

        self._size = 0
    }

    clone := func(self: Map) returns Map throws AllocError {
        mut cloned := Map()
        cloned.key_type_name = self.key_type_name
        cloned.key_type_size = self.key_type_size
        cloned.value_type_name = self.value_type_name
        cloned.value_type_size = self.value_type_size
        cloned.keys = self.keys.clone()
        cloned.values = self.values.clone()
        cloned._size = self._size
        return cloned
    }
}
