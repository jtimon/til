mode lib

import("src.core.array")
import("src.core.bool")
import("src.core.i64")
import("src.core.str")
import("src.core.u8")

Dynamic := struct {} // For dynamic arguments not checked at type checking phase
Type := struct {} // For type name parameters (like Vec.new(T: Type))

// DivideByZero := struct {} // REM Apparently Roc tried this and rolled it back

IndexOutOfBoundsError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns IndexOutOfBoundsError {
        mut err := IndexOutOfBoundsError()
        err.msg = msg
        return err
    }
}

FullError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns FullError {
        mut err := FullError()
        err.msg = msg
        return err
    }
}

AllocError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns AllocError {
        mut err := AllocError()
        err.msg = msg
        return err
    }
}

DuplicatedKeyError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns DuplicatedKeyError {
        mut err := DuplicatedKeyError()
        err.msg = msg
        return err
    }
}

KeyNotFoundError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns KeyNotFoundError {
        mut err := KeyNotFoundError()
        err.msg = msg
        return err
    }
}

loc := ext_func() returns Str; // Returns the current source location as "<file>:<line>:<col>:" TODO: rename to _loc for consistency

// Individual location components for flexible error formatting
_file := ext_func() returns Str; // Returns current file path
_line := ext_func() returns I64; // Returns current line number
_col  := ext_func() returns I64; // Returns current column number

single_print := ext_proc(args: ..Str);
// TODO temporary optimization since things are really slow since we have so many Array implementations here (loaded and checked with each test)
print_flush  := ext_proc();
exit         := ext_func(code: I64);
// Import paths use dots (like Python, Java, etc.) for cross-platform compatibility
// Example: import("src.core.std") resolves to src/core/std.til (Unix) or src\core\std.til (Windows)
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import       := ext_proc(path: Str);

// Memory operations
NULL   := 0
size_of := ext_func(type: Type) returns I64;
to_ptr := ext_func(var_identifier: Dynamic) returns I64;
type_as_str := ext_func(type: Type) returns Str;
// TODO Use throws for memory operations, don't return 0 from malloc
malloc := ext_func(size: I64) returns I64 throws AllocError;
free   := ext_func(ptr: I64);
memcpy := ext_func(mut dest: I64, src: I64, size: I64);
memcmp := ext_func(ptr1: I64, ptr2: I64, size: I64) returns I64;
memset := ext_func(mut dest: I64, value: U8, size: I64);

panic := proc(loc_str: Str, msg: Str) {
    println(loc_str.format(msg))
    exit(1)
}
