mode lib

import("src.core.str")
import("src.core.bool")
import("src.core.array")
import("src.core.constants")
import("src.core.introspection")

Dynamic := struct {} // For dynamic arguments not checked at type checking phase
Type := struct {} // For type name parameters (like Vec.new(T: Type))

// DivideByZero := struct {} // REM Apparently Roc tried this and rolled it back

I64_OverflowError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns I64_OverflowError {
        mut err := I64_OverflowError()
        err.msg = msg
        return err
    }

    clone := func(self: I64_OverflowError) returns I64_OverflowError throws AllocError {
        mut cloned := I64_OverflowError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

U8_OverflowError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns U8_OverflowError {
        mut err := U8_OverflowError()
        err.msg = msg
        return err
    }

    clone := func(self: U8_OverflowError) returns U8_OverflowError throws AllocError {
        mut cloned := U8_OverflowError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

IndexOutOfBoundsError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns IndexOutOfBoundsError {
        mut err := IndexOutOfBoundsError()
        err.msg = msg
        return err
    }

    clone := func(self: IndexOutOfBoundsError) returns IndexOutOfBoundsError throws AllocError {
        mut cloned := IndexOutOfBoundsError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

FullError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns FullError {
        mut err := FullError()
        err.msg = msg
        return err
    }

    clone := func(self: FullError) returns FullError throws AllocError {
        mut cloned := FullError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

AllocError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns AllocError {
        mut err := AllocError()
        err.msg = msg
        return err
    }

    clone := func(self: AllocError) returns AllocError throws AllocError {
        mut cloned := AllocError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

DuplicatedKeyError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns DuplicatedKeyError {
        mut err := DuplicatedKeyError()
        err.msg = msg
        return err
    }

    clone := func(self: DuplicatedKeyError) returns DuplicatedKeyError throws AllocError {
        mut cloned := DuplicatedKeyError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

KeyNotFoundError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns KeyNotFoundError {
        mut err := KeyNotFoundError()
        err.msg = msg
        return err
    }

    clone := func(self: KeyNotFoundError) returns KeyNotFoundError throws AllocError {
        mut cloned := KeyNotFoundError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

loc := ext_func() returns Str; // Returns the current source location as "<file>:<line>:<col>:" TODO: rename to _loc for consistency

// Individual location components for flexible error formatting
_file := ext_func() returns Str; // Returns current file path
_line := ext_func() returns I64; // Returns current line number
_col  := ext_func() returns I64; // Returns current column number

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool;
gt        := ext_func(a: I64, b: I64) returns Bool;

// Minimal arithmehics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64;
sub       := ext_func(a: I64, b: I64) returns I64;
mul       := ext_func(a: I64, b: I64) returns I64;
div       := ext_func(a: I64, b: I64) returns I64;
mod       := ext_func(a: I64, b: I64) returns I64;

single_print := ext_proc(args: ..Str);
// TODO temporary optimization since things are really slow since we have so many Array implementations here (loaded and checked with each test)
print_flush  := ext_proc();
exit         := ext_func(code: I64);
// Import paths use dots (like Python, Java, etc.) for cross-platform compatibility
// Example: import("src.core.std") resolves to src/core/std.til (Unix) or src\core\std.til (Windows)
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import       := ext_proc(path: Str);

// Memory operations
NULL   := 0
size_of := ext_func(type: Type) returns I64;
to_ptr := ext_func(var_identifier: Dynamic) returns I64;
type_as_str := ext_func(type: Type) returns Str;
// TODO Use throws for memory operations, don't return 0 from malloc
malloc := ext_func(size: I64) returns I64 throws AllocError;
free   := ext_func(ptr: I64);
memcpy := ext_func(mut dest: I64, src: I64, size: I64);
memcmp := ext_func(ptr1: I64, ptr2: I64, size: I64) returns I64;
memset := ext_func(mut dest: I64, value: U8, size: I64);

print := proc(args: ..Str) {
    for i in 0..args._len {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "print: IndexOutOfBoundsError should never happen")
    }
}

println := proc(args: ..Str) {
    for i in 0..args._len {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    single_print("\n")
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "println: IndexOutOfBoundsError should never happen")
    }
}

panic := proc(loc_str: Str, msg: Str) {
    println(loc_str.format(msg))
    exit(1)
}

Ptr := struct {
    mut data: I64 = NULL

    // TODO FIX should type error because size is already declared
    size_of := func() returns I64 { return size_of(I64) }

    new_by_size := proc(size: I64) returns Ptr throws AllocError {
        if size.lteq(0) {
            throw AllocError.new(format(loc(), "Ptr.new_by_size: invalid size ", size.to_str()))
        }
        mut p := Ptr()
        p.data = malloc(size)
        if NULL.eq(p.data) {
            throw AllocError.new(format(loc(), "Ptr.new: failed to allocate ", size.to_str(), " bytes"))
        }
        return p
    }

    new := proc(T: Type) returns Ptr throws AllocError {
        return Ptr.new_by_size(size_of(T))
    }

    delete := proc(self: Ptr) throws AllocError {
        if NULL.eq(self.data) {
            throw AllocError.new(format(loc(), "Ptr.free: trying to free a NULL pointer"))
        }
        free(self.data)
    }

    /** Ptr.offset is danger-ous, also known as "pointer arythmetics" */
    offset := proc(self: Ptr, offset: I64) returns Ptr {
        mut p := Ptr()
        p.data = add(self.data, offset)
        return p
    }

    // cast := macro(self: Ptr, type_name: Str) returns Dynamic {
    //     // TODO: This cast is purely cosmetic for now.
    //     // Proper type-changing macros are not implemented yet.
    //     return self
    // }

    copy_from := proc(mut self: Ptr, src: Ptr, size: I64) {
        // TODO this should fail if self arg is not declared as mut
        memcpy(self.data, src.data, size)
    }

    copy_to := proc(self: Ptr, mut dest: Ptr, size: I64) {
        memcpy(dest.data, self.data, size)
    }

    set_zero := proc(mut self: Ptr, size: I64) {
        memset(self.data, U8.from_i64(0), size)
    }
}

not := func(b: Bool) returns Bool {
    if b {
        return false
    }
    return true
}

or := func(args: ..Bool) returns Bool {
    for i in 0..args._len {
        mut val := false
        args.get(i, val)
        if val {
            return true
        }
    }

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "or: IndexOutOfBoundsError should never happen")
    }

    return false
}

and := func(args: ..Bool) returns Bool {
    for i in 0..args._len {
        mut val := false
        args.get(i, val)
        if not(val) {
            return false
        }
    }

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "and: IndexOutOfBoundsError should never happen")
    }

    return true
}

lteq := func(a: I64, b: I64) returns Bool {
    if lt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

gteq := func(a: I64, b: I64) returns Bool {
    if gt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

// Note that I64 and U8 don't have fields because the're the "real core types"
// think of them as "half-external types" for now
U8 := struct {
    // TODO FIX can't use itself as base data, can it?
    // TODO This is the base of data storage, not I64
    // mut data: I8 = 0

    len := func(self: I64) returns I64 {
        return 1
    }

    eq := func(self: U8, other: U8) returns Bool {
        return U8.to_i64(self).eq(U8.to_i64(other))
    }

    to_i64 := func(self: U8) returns I64 {
        // return cast("I64", self) // TODO implement cast, start easy with U8 to I64
        u8_to_i64 := ext_func(u8: U8) returns I64;
        return u8_to_i64(self)
    }

    // TODO do the rest of the operations, first fake them with i64, until real compilation
    // TODO rename add into i64_add or something
    // TODO rename add into I64.add directly in the rust/interpreter side, afterwards
    u8_add := func(a: U8, b: U8) returns U8 throws U8_OverflowError {
        return U8.from_i64(add(a.to_i64(), b.to_i64()))
    }

    from_i64 := func(self: I64) returns U8 throws U8_OverflowError {
        if lt(self, 0) {
            throw U8_OverflowError.new(format(loc(), "Negative values cannot be cast into 'U8'"))
        }
        if gt(self, MAX_U8) {
            throw U8_OverflowError.new(format(loc(), "U8: cannot be casted from an I64 greater than: ", I64.to_str(MAX_U8)))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8;
        return i64_to_u8(self)
    }

    to_str := func(self: U8) returns Str {
        return I64.to_str(U8.to_i64(self))
    }

    size := func() returns I64 {
        return 1
    }
}

I64 := struct {
    // mut data : Array = Array.new("U8", size_of(U8), 8) // TODO Use [8]U8 for this one

    eq := func(a: I64, b: I64) returns Bool {
        // REM We can't use the variadic or from here without mutual recusrion and a stack overflow
        if gt(a, b) {
            return false
        }
        if gt(b, a) {
            return false
        }
        if lt(a, b) {
            return false
        }
        if lt(b, a) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns Str {
        i64_to_str := ext_func(a: I64) returns Str;
        return i64_to_str(self)
    }

    from_str := func(str: Str) returns I64 {
        str_to_i64 := ext_func(a: Str) returns I64;
        return str_to_i64(str) // TODO: this can fail and panic from rust
    }

    inc := proc(mut self: I64) {
        self = add(self, 1)
    }

    dec := proc(mut self: I64) {
        self = sub(self, 1)
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }

    size := func() returns I64 {
        return 8
    }
}

