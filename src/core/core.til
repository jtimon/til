mode lib

import("src.core.constants")
import("src.core.introspection")

Dynamic := struct {} // For dynamic arguments not checked at type checking phase
Type := struct {} // For type name parameters (like Vec.new(T: Type))

// DivideByZero := struct {} // REM Apparently Roc tried this and rolled it back

I64_OverflowError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns I64_OverflowError {
        mut err := I64_OverflowError()
        err.msg = msg
        return err
    }

    clone := func(self: I64_OverflowError) returns I64_OverflowError throws AllocError {
        mut cloned := I64_OverflowError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

U8_OverflowError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns U8_OverflowError {
        mut err := U8_OverflowError()
        err.msg = msg
        return err
    }

    clone := func(self: U8_OverflowError) returns U8_OverflowError throws AllocError {
        mut cloned := U8_OverflowError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

IndexOutOfBoundsError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns IndexOutOfBoundsError {
        mut err := IndexOutOfBoundsError()
        err.msg = msg
        return err
    }

    clone := func(self: IndexOutOfBoundsError) returns IndexOutOfBoundsError throws AllocError {
        mut cloned := IndexOutOfBoundsError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

FullError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns FullError {
        mut err := FullError()
        err.msg = msg
        return err
    }

    clone := func(self: FullError) returns FullError throws AllocError {
        mut cloned := FullError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

AllocError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns AllocError {
        mut err := AllocError()
        err.msg = msg
        return err
    }

    clone := func(self: AllocError) returns AllocError throws AllocError {
        mut cloned := AllocError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

DuplicatedKeyError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns DuplicatedKeyError {
        mut err := DuplicatedKeyError()
        err.msg = msg
        return err
    }

    clone := func(self: DuplicatedKeyError) returns DuplicatedKeyError throws AllocError {
        mut cloned := DuplicatedKeyError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

KeyNotFoundError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns KeyNotFoundError {
        mut err := KeyNotFoundError()
        err.msg = msg
        return err
    }

    clone := func(self: KeyNotFoundError) returns KeyNotFoundError throws AllocError {
        mut cloned := KeyNotFoundError()
        cloned.msg = self.msg.clone()
        return cloned
    }
}

loc := ext_func() returns Str; // Returns the current source location as "<file>:<line>:<col>:" TODO: rename to _loc for consistency

// Individual location components for flexible error formatting
_file := ext_func() returns Str; // Returns current file path
_line := ext_func() returns I64; // Returns current line number
_col  := ext_func() returns I64; // Returns current column number

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool;
gt        := ext_func(a: I64, b: I64) returns Bool;

// Minimal arithmehics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64;
sub       := ext_func(a: I64, b: I64) returns I64;
mul       := ext_func(a: I64, b: I64) returns I64;
div       := ext_func(a: I64, b: I64) returns I64;
mod       := ext_func(a: I64, b: I64) returns I64;

single_print := ext_proc(args: ..Str);
// TODO temporary optimization since things are really slow since we have so many Array implementations here (loaded and checked with each test)
print_flush  := ext_proc();
exit         := ext_func(code: I64);
// Import paths use dots (like Python, Java, etc.) for cross-platform compatibility
// Example: import("src.core.std") resolves to src/core/std.til (Unix) or src\core\std.til (Windows)
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import       := ext_proc(path: Str);

// Memory operations
NULL   := 0
size_of := ext_func(type: Type) returns I64;
to_ptr := ext_func(var_identifier: Dynamic) returns I64;
type_as_str := ext_func(type: Type) returns Str;
// TODO Use throws for memory operations, don't return 0 from malloc
malloc := ext_func(size: I64) returns I64 throws AllocError;
free   := ext_func(ptr: I64);
memcpy := ext_func(mut dest: I64, src: I64, size: I64);
memcmp := ext_func(ptr1: I64, ptr2: I64, size: I64) returns I64;
memset := ext_func(mut dest: I64, value: U8, size: I64);

print := proc(args: ..Str) {
    for i in 0..args._len {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "print: IndexOutOfBoundsError should never happen")
    }
}

println := proc(args: ..Str) {
    for i in 0..args._len {
        mut val := ""
        args.get(i, val)
        single_print(val)
    }
    single_print("\n")
    print_flush()

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "println: IndexOutOfBoundsError should never happen")
    }
}

panic := proc(loc_str: Str, msg: Str) {
    println(loc_str.format(msg))
    exit(1)
}

Ptr := struct {
    mut data: I64 = NULL

    // TODO FIX should type error because size is already declared
    size_of := func() returns I64 { return size_of(I64) }

    new_by_size := proc(size: I64) returns Ptr throws AllocError {
        if size.lteq(0) {
            throw AllocError.new(format(loc(), "Ptr.new_by_size: invalid size ", size.to_str()))
        }
        mut p := Ptr()
        p.data = malloc(size)
        if NULL.eq(p.data) {
            throw AllocError.new(format(loc(), "Ptr.new: failed to allocate ", size.to_str(), " bytes"))
        }
        return p
    }

    new := proc(T: Type) returns Ptr throws AllocError {
        return Ptr.new_by_size(size_of(T))
    }

    delete := proc(self: Ptr) throws AllocError {
        if NULL.eq(self.data) {
            throw AllocError.new(format(loc(), "Ptr.free: trying to free a NULL pointer"))
        }
        free(self.data)
    }

    /** Ptr.offset is danger-ous, also known as "pointer arythmetics" */
    offset := proc(self: Ptr, offset: I64) returns Ptr {
        mut p := Ptr()
        p.data = add(self.data, offset)
        return p
    }

    // cast := macro(self: Ptr, type_name: Str) returns Dynamic {
    //     // TODO: This cast is purely cosmetic for now.
    //     // Proper type-changing macros are not implemented yet.
    //     return self
    // }

    copy_from := proc(mut self: Ptr, src: Ptr, size: I64) {
        // TODO this should fail if self arg is not declared as mut
        memcpy(self.data, src.data, size)
    }

    copy_to := proc(self: Ptr, mut dest: Ptr, size: I64) {
        memcpy(dest.data, self.data, size)
    }

    set_zero := proc(mut self: Ptr, size: I64) {
        memset(self.data, U8.from_i64(0), size)
    }
}

not := func(b: Bool) returns Bool {
    if b {
        return false
    }
    return true
}

or := func(args: ..Bool) returns Bool {
    for i in 0..args._len {
        mut val := false
        args.get(i, val)
        if val {
            return true
        }
    }
    return false

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "or: IndexOutOfBoundsError should never happen")
    }
}

and := func(args: ..Bool) returns Bool {
    for i in 0..args._len {
        mut val := false
        args.get(i, val)
        if not(val) {
            return false
        }
    }
    return true

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "and: IndexOutOfBoundsError should never happen")
    }
}

Bool := struct {
    mut data: U8 = 0

    len := func(self: Bool) returns I64 {
        return 1
    }

    eq := func(a: Bool, b: Bool) returns Bool {
        return or(and(a, b), and(not(b), not(a)))
    }

    to_str := func(self: Bool) returns Str {
        if self {
            return "true"
        }
        return "false"
    }

    // necessary for branchless arithmetics (but it must be implemented as a cast for it to make sense that way)
    to_i64 := func(self: Bool) returns I64 {
        if self {
            return 1
        }
        return 0
    }

    to_u8 := func(self: Bool) returns U8 {
        return self.data
    }

    from_i64 := func(i: I64) returns Bool {
        mut b := Bool()
        if gt(i, 0) {
            b.data = 1
        }
        return b
    }

    size := func() returns I64 {
        return 1
    }
}
false := Bool.from_i64(0)
true := Bool.from_i64(1)

lteq := func(a: I64, b: I64) returns Bool {
    if lt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

gteq := func(a: I64, b: I64) returns Bool {
    if gt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

// Note that I64 and U8 don't have fields because the're the "real core types"
// think of them as "half-external types" for now
U8 := struct {
    // TODO FIX can't use itself as base data, can it?
    // TODO This is the base of data storage, not I64
    // mut data: I8 = 0

    len := func(self: I64) returns I64 {
        return 1
    }

    eq := func(self: U8, other: U8) returns Bool {
        return U8.to_i64(self).eq(U8.to_i64(other))
    }

    to_i64 := func(self: U8) returns I64 {
        // return cast("I64", self) // TODO implement cast, start easy with U8 to I64
        u8_to_i64 := ext_func(u8: U8) returns I64;
        return u8_to_i64(self)
    }

    // TODO do the rest of the operations, first fake them with i64, until real compilation
    // TODO rename add into i64_add or something
    // TODO rename add into I64.add directly in the rust/interpreter side, afterwards
    u8_add := func(a: U8, b: U8) returns U8 throws U8_OverflowError {
        return U8.from_i64(add(a.to_i64(), b.to_i64()))
    }

    from_i64 := func(self: I64) returns U8 throws U8_OverflowError {
        if lt(self, 0) {
            throw U8_OverflowError.new(format(loc(), "Negative values cannot be cast into 'U8'"))
        }
        if gt(self, MAX_U8) {
            throw U8_OverflowError.new(format(loc(), "U8: cannot be casted from an I64 greater than: ", I64.to_str(MAX_U8)))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8;
        return i64_to_u8(self)
    }

    to_str := func(self: U8) returns Str {
        return I64.to_str(U8.to_i64(self))
    }

    size := func() returns I64 {
        return 1
    }
}

I64 := struct {
    // mut data : Array = Array.new("U8", size_of(U8), 8) // TODO Use [8]U8 for this one

    eq := func(a: I64, b: I64) returns Bool {
        // REM We can't use the variadic or from here without mutual recusrion and a stack overflow
        if gt(a, b) {
            return false
        }
        if gt(b, a) {
            return false
        }
        if lt(a, b) {
            return false
        }
        if lt(b, a) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns Str {
        i64_to_str := ext_func(a: I64) returns Str;
        return i64_to_str(self)
    }

    from_str := func(str: Str) returns I64 {
        str_to_i64 := ext_func(a: Str) returns I64;
        return str_to_i64(str) // TODO: this can fail and panic from rust
    }

    inc := proc(mut self: I64) {
        self = add(self, 1)
    }

    dec := proc(mut self: I64) {
        self = sub(self, 1)
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }

    size := func() returns I64 {
        return 8
    }
}

// TODO get rid of special cases for Str besides literals
Str := struct {
    mut c_string : I64 = 0
    mut cap      : I64 = 0
    // mut len : I64 = 0 // TODO make sure double declarations inside the same struct give type errors

    len := func(self: Str) returns I64 {
        return self.cap
    }

    eq := func(self: Str, other: Str) returns Bool {
        if not(self.cap.eq(other.cap)) {
            return false
        }

        for i in 0..self.cap {
            mut self_byte  : U8 = 0
            mut other_byte : U8 = 0
            memcpy(to_ptr(self_byte), add(self.c_string, i), 1)
            memcpy(to_ptr(other_byte), add(other.c_string, i), 1)

            if not(U8.eq(self_byte, other_byte)) {
                return false
            }
        }

        return true
    }

    to_i64 := func(self: Str) returns I64 {
        return I64.from_str(self)
    }

    clone := func(self: Str) returns Str throws AllocError {
        mut cloned := Str()
        cloned.cap = self.cap
        cloned.c_string = malloc(cloned.cap)
        if NULL.eq(cloned.c_string) {
            throw AllocError.new(format(loc(), "Str.clone: malloc failed for ", I64.to_str(cloned.cap), " bytes"))
        }
        memcpy(cloned.c_string, self.c_string, self.cap)
        return cloned
    }

    size := func(self: Str) returns I64 {
        return self.cap
    }
}

get_substr := func(s: Str, start: I64, end: I64) returns Str throws IndexOutOfBoundsError, AllocError {

    if start.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " cannot be negative"))
    }
    if end.lt(0) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " cannot be negative"))
    }
    if start.gt(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start index ", start.to_str(), " is greater than end index ", end.to_str()))
    }
    if end.gt(s.len()) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: end index ", end.to_str(), " is greater than string length ", I64.to_str(s.len())))
    }
    if start.eq(end) {
        throw IndexOutOfBoundsError.new(format(loc(), "get_substr: start and end are the same (", start.to_str(), "), no substring"))
    }

    mut substr := Str()
    substr.cap = end.sub(start)
    substr.c_string = malloc(substr.cap)
    if NULL.eq(substr.c_string) {
        throw AllocError.new(format(loc(), "Str.get_substr: failed to allocate ", I64.to_str(substr.cap), " bytes"))
    }
    memcpy(substr.c_string, add(s.c_string, start), substr.cap)

    return substr
}

get_char := func(s: Str, pos: I64) returns Str throws IndexOutOfBoundsError, AllocError {
    return s.get_substr(pos, add(pos, 1))
}

format := func(prefix: Str, args: ..Str) returns Str throws I64_OverflowError, IndexOutOfBoundsError, AllocError {
    mut result := Str()
    result.cap = prefix.cap

    for i in 0..args._len {
        mut arg := ""
        args.get(i, arg)
        result.cap = add(result.cap, arg.cap)
        if lt(result.cap, arg.cap) {
            throw I64_OverflowError.new(format(loc(), "format: integer overflow while summing cap for arg ", i.to_str()))
        }
    }

    result.c_string = malloc(result.cap)
    if NULL.eq(result.c_string) {
        throw AllocError.new(format(loc(), "format: malloc failed for cap = ", I64.to_str(result.cap)))
    }

    mut offset := 0
    memcpy(result.c_string, prefix.c_string, prefix.cap)
    offset = prefix.cap

    for i in 0..args._len {
        mut s := ""
        args.get(i, s)
        memcpy(add(result.c_string, offset), s.c_string, s.cap)
        offset = add(offset, s.cap)
    }

    return result
}

Array := struct {
    mut type_name : Str  = ""
    mut type_size : I64  = 0
    mut ptr       : I64  = 0
    mut _len      : I64  = 0

    len := func(self: Array) returns I64 {
        return self._len
    }

    size := func(self: Array) returns I64 {
        return mul(self._len, self.type_size)
    }

    new := proc(T: Type, capacity: I64) returns Array throws AllocError {
        mut arr := Array()
        arr.type_name = type_as_str(T)
        arr.type_size = size_of(T)
        size_bytes := mul(capacity, arr.type_size)
        arr.ptr = malloc(size_bytes)
        memset(arr.ptr, U8.from_i64(0), size_bytes)
        arr._len = capacity
        return arr
    }

    get := proc(self: Array, index: I64, mut T: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Array.get: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(T), self.type_name)) { // TODO FIX
        //     throw format(loc(), format("Array.get: destination type mismatch: expected '", self.type_name, "' found '", type_as_str(T), "'"))
        // }

        src := add(self.ptr, mul(index, self.type_size))
        mut dest := to_ptr(T)
        memcpy(dest, src, self.type_size)
    }

    set := proc(mut self: Array, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Array.set: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Array.set: value type mismatch")
        // }

        mut dest := add(self.ptr, mul(index, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
    }

    delete := proc(mut self: Array) {
        free(self.ptr)
        self.ptr = 0
        self._len = 0
    }

    clone := func(self: Array) returns Array throws AllocError {
        mut cloned := Array()
        cloned.type_name = self.type_name
        cloned.type_size = self.type_size
        cloned._len = self._len
        mut total_bytes := mul(self._len, self.type_size)
        cloned.ptr = malloc(total_bytes)
        if NULL.eq(cloned.ptr) {
            throw AllocError.new(format(loc(), "Array.clone: malloc failed for ", I64.to_str(total_bytes), " bytes"))
        }
        memcpy(cloned.ptr, self.ptr, total_bytes)
        return cloned
    }
}

// Vec (dynamic/growable array) - replaces Array.new_dyn()
Vec := struct {
    mut type_name : Str  = ""
    mut type_size : I64  = 0
    mut ptr       : I64  = 0
    mut _len      : I64  = 0
    mut cap       : I64  = 0

    INIT_CAP : I64 = 16
    MAX_CAP  : I64 = 1024

    len := func(self: Vec) returns I64 {
        return self._len
    }

    size := func(self: Vec) returns I64 {
        return mul(self._len, self.type_size)
    }

    new := proc(T: Type) returns Vec throws AllocError {
        mut vec := Vec()
        vec.type_name = type_as_str(T)
        vec.type_size = size_of(T)
        size_bytes := mul(Vec.INIT_CAP, vec.type_size)
        vec.ptr = malloc(size_bytes)
        vec._len = 0
        vec.cap = Vec.INIT_CAP
        return vec
    }

    // TODO: Remove this workaround once we can pass Dynamic params through nested calls
    // Internal helper for Map.new() - creates Vec from type info stored in Dynamic params
    // This is needed because we can't pass a Dynamic parameter to another function expecting a type
    new_from_type_info := proc(type_name: Str, type_size: I64) returns Vec throws AllocError {
        mut vec := Vec()
        vec.type_name = type_name
        vec.type_size = type_size
        size_bytes := mul(Vec.INIT_CAP, vec.type_size)
        vec.ptr = malloc(size_bytes)
        vec._len = 0
        vec.cap = Vec.INIT_CAP
        return vec
    }

    push := proc(mut self: Vec, value: Dynamic) throws FullError, AllocError {
        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.push: value type mismatch")
        // }

        if self._len.eq(self.cap) {
            new_cap := mul(self.cap, 2)
            if gt(new_cap, Vec.MAX_CAP) {
                throw FullError.new(format(loc(), "Vec.push: capacity exceeded Vec.MAX_CAP"))
            }

            mut new_ptr := malloc(mul(new_cap, self.type_size))
            memcpy(new_ptr, self.ptr, mul(self._len, self.type_size))
            free(self.ptr)
            self.ptr = new_ptr
            self.cap = new_cap
        }

        mut dest := add(self.ptr, mul(self._len, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
        self._len = add(self._len, 1)
    }

    get := proc(self: Vec, index: I64, mut T: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.get: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(T), self.type_name)) { // TODO FIX
        //     throw format(loc(), format("Vec.get: destination type mismatch: expected '", self.type_name, "' found '", type_as_str(T), "'"))
        // }

        src := add(self.ptr, mul(index, self.type_size))
        mut dest := to_ptr(T)
        memcpy(dest, src, self.type_size)
    }

    set := proc(mut self: Vec, index: I64, value: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.set: index out of bounds"))
        }

        // if not(Str.eq(type_as_str(type_of(value)), self.type_name)) { // TODO FIX
        //     throw format(loc(), "Vec.set: value type mismatch")
        // }

        mut dest := add(self.ptr, mul(index, self.type_size))
        memcpy(dest, to_ptr(value), self.type_size)
    }

    pop := proc(mut self: Vec, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError.new(format(loc(), "Vec.pop: cannot pop from empty Vec"))
        }

        // Get last element
        mut last_index := sub(self._len, 1)
        self.get(last_index, dest)

        // Decrement length
        self._len = last_index
    }

    delete := proc(mut self: Vec) {
        free(self.ptr)
        self.ptr = 0
        self._len = 0
        self.cap = 0
    }

    clone := func(self: Vec) returns Vec throws AllocError {
        mut cloned := Vec()
        cloned.type_name = self.type_name
        cloned.type_size = self.type_size
        cloned._len = self._len
        cloned.cap = self.cap
        mut total_bytes := mul(self.cap, self.type_size)
        cloned.ptr = malloc(total_bytes)
        if NULL.eq(cloned.ptr) {
            throw AllocError.new(format(loc(), "Vec.clone: malloc failed for ", I64.to_str(total_bytes), " bytes"))
        }
        // Copy only the used portion (_len), not the entire capacity
        mut used_bytes := mul(self._len, self.type_size)
        memcpy(cloned.ptr, self.ptr, used_bytes)
        return cloned
    }
}

// Generic Map implementation - ordered, not hashed
// Uses parallel arrays for keys and values (maintains insertion order)
// Type parameters passed as strings (key_type_name, value_type_name)
// No generics syntax needed - uses dynamic typing like Array
//
// Key type support:
//   - Str: Fully supported (uses Str.eq() for content comparison)
//   - I64, U8, Bool: Fully supported (uses memcmp for byte comparison)
//   - Other primitives: Should work with memcmp
//   - Structs: NOT recommended as keys (memcmp compares raw bytes including padding)
//
// Value type support:
//   - Fully dynamic: Any type works (I64, Str, Bool, U8, Vec2, Array, etc.)
//   - Uses memcpy for storage and retrieval
Map := struct {
    mut key_type_name: Str = ""       // e.g., "Str", "I64"
    mut key_type_size: I64 = 0        // from size_of(KeyType)
    mut value_type_name: Str = ""     // e.g., "Str", "Bool", "Expr"
    mut value_type_size: I64 = 0      // from size_of(ValueType)
    mut keys: Vec = Vec()         // Dynamic array of keys
    mut values: Vec = Vec()       // Dynamic array of values (parallel)
    mut _size: I64 = 0                // Number of entries (internal, use len() to access)

    // Create new empty map with specified key and value types
    // Example: Map.new(Str, I64)
    new := proc(KeyType: Type, ValueType: Type) returns Map throws AllocError {
        mut m := Map()
        m.key_type_name = type_as_str(KeyType)
        m.key_type_size = size_of(KeyType)
        m.value_type_name = type_as_str(ValueType)
        m.value_type_size = size_of(ValueType)
        // Can't pass Dynamic params to Vec.new(), so use type info directly
        m.keys = Vec.new_from_type_info(m.key_type_name, m.key_type_size)
        m.values = Vec.new_from_type_info(m.value_type_name, m.value_type_size)
        m._size = 0
        return m
    }

    // Insert new key-value pair
    // Throws DuplicatedKeyError if key already exists
    // Use set() instead if you want to overwrite existing keys
    insert := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError, DuplicatedKeyError {
        // Check if key already exists
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                // For other types, use memcmp
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key already exists - throw error
                throw DuplicatedKeyError.new("Key already exists in map")
            }
            i = add(i, 1)
        }

        // Key doesn't exist - add it
        // Workaround for bug: pushing Dynamic parameters doesn't work
        // Instead, manually grow the array and memcpy directly
        if self.keys._len.eq(self.keys.cap) {
            // Need to grow
            mut new_cap := mul(self.keys.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.keys.type_size))
            memcpy(new_ptr, self.keys.ptr, mul(self.keys._len, self.keys.type_size))
            free(self.keys.ptr)
            self.keys.ptr = new_ptr
            self.keys.cap = new_cap
        }
        // Copy key directly into array memory
        mut dest_ptr := add(self.keys.ptr, mul(self.keys._len, self.keys.type_size))
        memcpy(dest_ptr, to_ptr(key), self.keys.type_size)
        self.keys._len = add(self.keys._len, 1)

        // Same workaround for values
        if self.values._len.eq(self.values.cap) {
            mut new_cap := mul(self.values.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.values.type_size))
            memcpy(new_ptr, self.values.ptr, mul(self.values._len, self.values.type_size))
            free(self.values.ptr)
            self.values.ptr = new_ptr
            self.values.cap = new_cap
        }
        mut dest_ptr := add(self.values.ptr, mul(self.values._len, self.values.type_size))
        memcpy(dest_ptr, to_ptr(value), self.values.type_size)
        self.values._len = add(self.values._len, 1)

        self._size = add(self._size, 1)
    }

    // Set key-value pair
    // Overwrites value if key already exists
    // Creates new entry if key doesn't exist
    set := proc(mut self: Map, key: Dynamic, value: Dynamic) throws AllocError {
        // Try to find existing key
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key found - update value
                mut values_arr := self.values
                mut value_ptr := add(values_arr.ptr, mul(i, self.value_type_size))
                memcpy(value_ptr, to_ptr(value), self.value_type_size)
                return
            }
            i = add(i, 1)
        }

        // Key not found - insert new entry (use same workaround as insert())
        if self.keys._len.eq(self.keys.cap) {
            mut new_cap := mul(self.keys.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.keys.type_size))
            memcpy(new_ptr, self.keys.ptr, mul(self.keys._len, self.keys.type_size))
            free(self.keys.ptr)
            self.keys.ptr = new_ptr
            self.keys.cap = new_cap
        }
        mut dest_ptr := add(self.keys.ptr, mul(self.keys._len, self.keys.type_size))
        memcpy(dest_ptr, to_ptr(key), self.keys.type_size)
        self.keys._len = add(self.keys._len, 1)

        if self.values._len.eq(self.values.cap) {
            mut new_cap := mul(self.values.cap, 2)
            mut new_ptr := malloc(mul(new_cap, self.values.type_size))
            memcpy(new_ptr, self.values.ptr, mul(self.values._len, self.values.type_size))
            free(self.values.ptr)
            self.values.ptr = new_ptr
            self.values.cap = new_cap
        }
        mut dest_ptr2 := add(self.values.ptr, mul(self.values._len, self.values.type_size))
        memcpy(dest_ptr2, to_ptr(value), self.values.type_size)
        self.values._len = add(self.values._len, 1)

        self._size = add(self._size, 1)
    }

    // Get value for given key
    // Copies value into dest parameter
    // Throws KeyNotFoundError if key doesn't exist
    get := proc(self: Map, key: Dynamic, mut dest: Dynamic) throws KeyNotFoundError {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                // Key found - get value
                mut values_arr := self.values
                mut value_ptr := add(values_arr.ptr, mul(i, self.value_type_size))
                memcpy(to_ptr(dest), value_ptr, self.value_type_size)
                return
            }
            i = add(i, 1)
        }

        // Key not found
        throw KeyNotFoundError.new("Key not found in map")
    }

    // Check if key exists in map
    contains_key := proc(self: Map, key: Dynamic) returns Bool {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                return true
            }
            i = add(i, 1)
        }
        return false
    }

    // Get position (index) of key in insertion order
    // Returns -1 if key not found
    // Useful for enum variant tags which depend on insertion order
    position := proc(self: Map, key: Dynamic) returns I64 {
        mut i := 0
        mut keys_arr := self.keys
        while lt(i, self._size) {
            // Special case for Str keys: compare content, not struct bytes
            mut keys_match := 0
            if Str.eq(self.key_type_name, "Str") {
                // For Str keys, use Str.eq() to compare content
                mut existing_key := ""
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                memcpy(to_ptr(existing_key), existing_key_ptr, self.key_type_size)
                mut key_str := ""
                memcpy(to_ptr(key_str), to_ptr(key), self.key_type_size)
                if key_str.eq(existing_key) {
                    keys_match = 0
                } else {
                    keys_match = 1
                }
            } else {
                mut existing_key_ptr := add(keys_arr.ptr, mul(i, self.key_type_size))
                keys_match = memcmp(to_ptr(key), existing_key_ptr, self.key_type_size)
            }

            if keys_match.eq(0) {
                return i
            }
            i = add(i, 1)
        }
        return sub(0, 1)  // -1 for not found
    }

    // Get number of entries in map
    len := proc(self: Map) returns I64 {
        return self._size
    }

    // Get total size in bytes (keys + values)
    size := func(self: Map) returns I64 {
        mut keys_size := mul(self._size, self.key_type_size)
        mut values_size := mul(self._size, self.value_type_size)
        return add(keys_size, values_size)
    }

    // Free map memory and reset
    delete := proc(mut self: Map) {
        mut keys_arr := self.keys
        keys_arr.delete()

        mut values_arr := self.values
        values_arr.delete()

        self._size = 0
    }

    clone := func(self: Map) returns Map throws AllocError {
        mut cloned := Map()
        cloned.key_type_name = self.key_type_name
        cloned.key_type_size = self.key_type_size
        cloned.value_type_name = self.value_type_name
        cloned.value_type_size = self.value_type_size
        cloned.keys = self.keys.clone()
        cloned.values = self.values.clone()
        cloned._size = self._size
        return cloned
    }
}

// List - Dynamic heterogeneous collection (also known as Tuple)
// Stores elements of different types in contiguous memory
// Type information tracked via parallel metadata vectors
List := struct {
    mut data : I64  = 0     // Pointer to raw memory blob
    mut _len : I64 = 0      // Number of elements stored
    mut type_names : Vec = Vec()  // Vec<Str> - type name per element
    mut type_sizes : Vec = Vec()  // Vec<I64> - size per element

    len := func(self: List) returns I64 {
        return self._len
    }

    size := func(self: List) returns I64 throws IndexOutOfBoundsError {
        return self.calc_used()
    }

    // Create new empty list
    new := proc() returns List throws AllocError {
        mut list := List()
        // Allocate enough for reasonable number of elements
        list.data = malloc(1024)

        if I64.eq(list.data, 0) {
            throw AllocError("List.new: malloc failed")
        }

        list._len = 0
        list.type_names = Vec.new(Str)
        list.type_sizes = Vec.new(I64)

        return list
    }

    // Calculate byte offset for element at index
    calc_offset := proc(self: List, index: I64) returns I64 throws IndexOutOfBoundsError {
        mut offset := 0
        mut i := 0
        while lt(i, index) {
            mut size := 0
            self.type_sizes.get(i, size)
            offset = add(offset, size)
            i = add(i, 1)
        }
        return offset
    }

    // Calculate total bytes used
    calc_used := proc(self: List) returns I64 throws IndexOutOfBoundsError {
        return self.calc_offset(self._len)
    }

    // Append element to list
    // Takes the type as first parameter (like Vec.new) and value as second
    // Example: list.push(I64, 42), list.push(Str, "hello")
    push := proc(mut self: List, T: Type, value: Dynamic) throws AllocError, FullError, IndexOutOfBoundsError {
        mut type_name := type_as_str(T)
        mut type_size := size_of(T)

        // Copy value to data blob at current end
        mut offset := self.calc_used()
        mut value_ptr := to_ptr(value)
        memcpy(add(self.data, offset), value_ptr, type_size)

        // Record metadata
        self.type_names.push(type_name)
        self.type_sizes.push(type_size)
        self._len = add(self._len, 1)
    }

    // Get element at index
    get := proc(self: List, index: I64, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(format("List.get: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw IndexOutOfBoundsError(format("List.get: negative index ", index.to_str()))
        }

        // Get type info for validation
        mut stored_type := ""
        self.type_names.get(index, stored_type)

        mut dest_type := type_as_str(dest)

        // TODO FIX type checking when Dynamic type checking is enabled
        // if not(Str.eq(stored_type, dest_type)) {
        //     throw TypeMismatchError(...)
        // }

        // Calculate offset and size
        mut offset := self.calc_offset(index)
        mut size := 0
        self.type_sizes.get(index, size)

        // Copy data to destination
        mut dest_ptr := to_ptr(dest)
        memcpy(dest_ptr, add(self.data, offset), size)
    }

    // Set element at index
    // Takes the type as second parameter and value as third
    // Example: list.set(0, I64, 99), list.set(1, Str, "world")
    set := proc(mut self: List, index: I64, T: Type, value: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(format("List.set: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw IndexOutOfBoundsError(format("List.set: negative index ", index.to_str()))
        }

        mut new_type := type_as_str(T)
        mut new_size := size_of(T)

        mut old_type := ""
        self.type_names.get(index, old_type)

        mut old_size := 0
        self.type_sizes.get(index, old_size)

        // Case 1: Same size - simple overwrite
        if I64.eq(new_size, old_size) {
            mut offset := self.calc_offset(index)
            mut value_ptr := to_ptr(value)
            memcpy(add(self.data, offset), value_ptr, new_size)

            // Update type name if different
            if not(Str.eq(new_type, old_type)) {
                self.type_names.set(index, new_type)
            }
            return
        }

        // Case 2: Different size - need to shift elements
        mut old_offset := self.calc_offset(index)
        mut after_offset := add(old_offset, old_size)
        mut used := self.calc_used()
        mut bytes_after := sub(used, after_offset)

        // Shift elements after index
        if gt(bytes_after, 0) {
            mut new_after_offset := add(old_offset, new_size)
            memcpy(add(self.data, new_after_offset), add(self.data, after_offset), bytes_after)
        }

        // Write new value
        mut value_ptr := to_ptr(value)
        memcpy(add(self.data, old_offset), value_ptr, new_size)

        // Update metadata
        self.type_names.set(index, new_type)
        self.type_sizes.set(index, new_size)
    }

    pop := proc(mut self: List, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError(format(loc(), "List.pop: cannot pop from empty List"))
        }

        // Get last element FIRST before modifying anything
        mut last_index := sub(self._len, 1)
        mut offset := self.calc_offset(last_index)
        mut size := 0
        self.type_sizes.get(last_index, size)

        // Copy data to destination directly
        mut dest_ptr := to_ptr(dest)
        memcpy(dest_ptr, add(self.data, offset), size)

        // Now safe to remove from metadata
        mut dummy_name := ""
        self.type_names.pop(dummy_name)
        mut dummy_size := 0
        self.type_sizes.pop(dummy_size)

        // Decrement length
        self._len = last_index
    }

    // Free list memory
    delete := proc(mut self: List) {
        free(self.data)
        self.data = 0
        self._len = 0

        mut names := self.type_names
        names.delete()

        mut sizes := self.type_sizes
        sizes.delete()
    }

    clone := func(self: List) returns List throws AllocError, IndexOutOfBoundsError {
        mut cloned := List()
        cloned._len = self._len
        cloned.type_names = self.type_names.clone()
        cloned.type_sizes = self.type_sizes.clone()

        // Calculate total bytes used and allocate data buffer
        mut total_bytes := self.calc_used()
        cloned.data = malloc(total_bytes)
        if NULL.eq(cloned.data) {
            throw AllocError.new(format(loc(), "List.clone: malloc failed for ", I64.to_str(total_bytes), " bytes"))
        }
        memcpy(cloned.data, self.data, total_bytes)
        return cloned
    }
}
