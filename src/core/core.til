mode lib

// Low-level print primitives (before str.til so it can use them)
single_print := ext_proc(s: Str);
print_flush  := ext_proc();

import("src.core.array")
import("src.core.bool")
import("src.core.i64")
import("src.core.str")
import("src.core.u8")

Dynamic := struct {} // For dynamic arguments not checked at type checking phase
Type := struct {} // For type name parameters (like Vec.new(T: Type))

loc := ext_func() returns Str; // Returns the current source location as "<file>:<line>:<col>:" TODO: rename to _loc for consistency

// Individual location components for flexible error formatting
_file := ext_func() returns Str; // Returns current file path
_line := ext_func() returns I64; // Returns current line number
_col  := ext_func() returns I64; // Returns current column number

exit := ext_func(code: I64);
panic := proc(loc_str: Str, msgs: ..Str) {
    single_print(loc_str)
    for i in 0..msgs.len() {
        mut val := ""
        msgs.get(i, val)
        single_print(val)
    }
    single_print("\n")
    print_flush()
    exit(1)

    catch(err: IndexOutOfBoundsError) {
        single_print("panic: IndexOutOfBoundsError should never happen\n")
        print_flush()
        exit(1)
    }
}

// Import paths use dots (like Python, Java, etc.) for cross-platform compatibility
// Example: import("src.std.std") resolves to src/std/std.til (Unix) or src\std\std.til (Windows)
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import       := ext_proc(path: Str);
