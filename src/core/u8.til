mode lib

U8_SIZE   := 1
MIN_U8    := 0
MAX_U8    := 255
ZERO_U8   : U8 = 0

/** Error thrown when U8 conversion fails (negative or > 255). */
U8_Overflow := struct {
    mut msg: Str = ""
}

/** U8 - Unsigned 8-bit integer type. */
// Note that I64 and U8 don't have fields because they're the "real core types"
// think of them as "half-external types" for now
U8 := struct {
    // TODO FIX can't use itself as base data, can it?
    // TODO This is the base of data storage, not I64
    // mut data: I8 = 0

    len := func(_self: U8) returns I64 {
        return 1
    }

    lt := func(self: U8, other: U8) returns Bool {
        u8_lt := ext_func(a: U8, b: U8) returns Bool {}
        return u8_lt(self, other)
    }

    gt := func(self: U8, other: U8) returns Bool {
        u8_gt := ext_func(a: U8, b: U8) returns Bool {}
        return u8_gt(self, other)
    }

    eq := func(a: U8, b: U8) returns Bool {
        if a.gt(b) {
            return false
        }
        if b.gt(a) {
            return false
        }
        if a.lt(b) {
            return false
        }
        if b.lt(a) {
            return false
        }
        return true
    }

    to_i64 := func(self: U8) returns I64 {
        // return cast("I64", self) // TODO implement cast, start easy with U8 to I64
        u8_to_i64 := ext_func(u8: U8) returns I64 {}
        return u8_to_i64(self)
    }

    /** Addition that wraps on overflow (returns result mod 256).
     *  This is the default, silent behavior - no error, no throw.
     *  Use safe_add() if you want to catch overflow errors. */
    add := func(a: U8, b: U8) returns U8 {
        u8_add := ext_func(a: U8, b: U8) returns U8 {}
        return u8_add(a, b)
    }

    /** Addition that throws U8_Overflow when result > 255.
     *  Use add() if you want silent wrapping behavior. */
    safe_add := func(a: U8, b: U8) returns U8 throws U8_Overflow {
        sum := a.to_i64().add(b.to_i64())
        if sum.gt(MAX_U8) {
            throw U8_Overflow(msg=format(loc(), "U8 overflow: ", a.to_str(), " + ", b.to_str(), " = ", sum.to_str()))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(sum)
    }

    /** Subtraction that wraps on underflow (returns result mod 256).
     *  This is the default, silent behavior - no error, no throw.
     *  Use safe_sub() if you want to catch underflow errors. */
    sub := func(a: U8, b: U8) returns U8 {
        u8_sub := ext_func(a: U8, b: U8) returns U8 {}
        return u8_sub(a, b)
    }

    /** Subtraction that throws U8_Overflow when result < 0.
     *  Use sub() if you want silent wrapping behavior. */
    safe_sub := func(a: U8, b: U8) returns U8 throws U8_Overflow {
        diff := a.to_i64().sub(b.to_i64())
        if diff.lt(0) {
            throw U8_Overflow(msg=format(loc(), "U8 underflow: ", a.to_str(), " - ", b.to_str(), " = ", diff.to_str()))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(diff)
    }

    /** Multiplication that wraps on overflow (returns result mod 256).
     *  This is the default, silent behavior - no error, no throw.
     *  Use safe_mul() if you want to catch overflow errors. */
    mul := func(a: U8, b: U8) returns U8 {
        u8_mul := ext_func(a: U8, b: U8) returns U8 {}
        return u8_mul(a, b)
    }

    /** Multiplication that throws U8_Overflow when result > 255.
     *  Use mul() if you want silent wrapping behavior. */
    safe_mul := func(a: U8, b: U8) returns U8 throws U8_Overflow {
        product := a.to_i64().mul(b.to_i64())
        if product.gt(MAX_U8) {
            throw U8_Overflow(msg=format(loc(), "U8 overflow: ", a.to_str(), " * ", b.to_str(), " = ", product.to_str()))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(product)
    }

    /** Division that returns 0 when dividing by zero.
     *  This is the default, silent behavior - no error, no throw.
     *  Use safe_div() if you want to catch division by zero errors. */
    div := func(a: U8, b: U8) returns U8 {
        u8_div := ext_func(a: U8, b: U8) returns U8 {}
        return u8_div(a, b)
    }

    /** Division that throws DivideByZero when dividing by zero.
     *  Use div() if you want silent behavior (returns 0). */
    safe_div := func(a: U8, b: U8) returns U8 throws DivideByZero {
        if b.eq(ZERO_U8) {
            throw DivideByZero()
        }
        u8_div := ext_func(a: U8, b: U8) returns U8 {}
        return u8_div(a, b)
    }

    /** Modulo operation. Returns 0 when dividing by zero. */
    mod := func(a: U8, b: U8) returns U8 {
        u8_mod := ext_func(a: U8, b: U8) returns U8 {}
        return u8_mod(a, b)
    }

    // Bitwise operations
    xor := func(a: U8, b: U8) returns U8 {
        u8_xor := ext_func(a: U8, b: U8) returns U8 {}
        return u8_xor(a, b)
    }

    and := func(a: U8, b: U8) returns U8 {
        u8_and := ext_func(a: U8, b: U8) returns U8 {}
        return u8_and(a, b)
    }

    or := func(a: U8, b: U8) returns U8 {
        u8_or := ext_func(a: U8, b: U8) returns U8 {}
        return u8_or(a, b)
    }

    from_i64 := func(self: I64) returns U8 throws U8_Overflow {
        if self.lt(0) {
            throw U8_Overflow(msg=format(loc(), "Negative values cannot be cast into 'U8'"))
        }
        if self.gt(MAX_U8) {
            throw U8_Overflow(msg=format(loc(), "U8: cannot be casted from an I64 greater than: ", MAX_U8.to_str()))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(self)
    }

    to_str := func(self: U8) returns Str {
        return self.to_i64().to_str()
    }

    from_str := func(s: Str) returns U8 throws U8_Overflow {
        return U8.from_i64(I64.from_str(s))
    }

    inc := proc(mut self: U8) {
        one : U8 = 1
        self = self.add(one)
    }

    dec := proc(mut self: U8) {
        one : U8 = 1
        self = self.sub(one)
    }

    gteq := func(a: U8, b: U8) returns Bool {
        if a.gt(b) {
            return true
        }
        if a.lt(b) {
            return false
        }
        return true  // equal
    }

    lteq := func(a: U8, b: U8) returns Bool {
        if a.lt(b) {
            return true
        }
        if a.gt(b) {
            return false
        }
        return true  // equal
    }

    size := func() returns I64 {
        return 1
    }
}
