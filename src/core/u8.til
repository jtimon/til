mode lib

U8_SIZE   := 1
MIN_U8    := 0
MAX_U8    := 255
ZERO_U8   : U8 = 0

/** Error thrown when U8 conversion fails (negative or > 255). */
U8_Overflow := struct {
    mut msg: Str = ""
}

/** U8 - Unsigned 8-bit integer type. */
// Note that I64 and U8 don't have fields because they're the "real core types"
// think of them as "half-external types" for now
U8 := struct {
    // TODO FIX can't use itself as base data, can it?
    // TODO This is the base of data storage, not I64
    // mut data: I8 = 0

    len := func(_self: U8) returns I64 {
        return 1
    }

    eq := func(self: U8, other: U8) returns Bool {
        return U8.to_i64(self).eq(U8.to_i64(other))
    }

    lt := func(self: U8, other: U8) returns Bool {
        return U8.to_i64(self).lt(U8.to_i64(other))
    }

    gt := func(self: U8, other: U8) returns Bool {
        return U8.to_i64(self).gt(U8.to_i64(other))
    }

    to_i64 := func(self: U8) returns I64 {
        // return cast("I64", self) // TODO implement cast, start easy with U8 to I64
        u8_to_i64 := ext_func(u8: U8) returns I64 {}
        return u8_to_i64(self)
    }

    /** Addition that wraps on overflow (returns result mod 256).
     *  This is the default, silent behavior - no error, no throw.
     *  Use safe_add() if you want to catch overflow errors. */
    add := func(a: U8, b: U8) returns U8 {
        u8_add := ext_func(a: U8, b: U8) returns U8 {}
        return u8_add(a, b)
    }

    /** Addition that throws U8_Overflow when result > 255.
     *  Use add() if you want silent wrapping behavior. */
    safe_add := func(a: U8, b: U8) returns U8 throws U8_Overflow {
        sum := a.to_i64().add(b.to_i64())
        if sum.gt(MAX_U8) {
            throw U8_Overflow(msg=format(loc(), "U8 overflow: ", a.to_str(), " + ", b.to_str(), " = ", sum.to_str()))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(sum)
    }

    from_i64 := func(self: I64) returns U8 throws U8_Overflow {
        if lt(self, 0) {
            throw U8_Overflow(msg=format(loc(), "Negative values cannot be cast into 'U8'"))
        }
        if gt(self, MAX_U8) {
            throw U8_Overflow(msg=format(loc(), "U8: cannot be casted from an I64 greater than: ", I64.to_str(MAX_U8)))
        }
        i64_to_u8 := ext_func(i64: I64) returns U8 {}
        return i64_to_u8(self)
    }

    to_str := func(self: U8) returns Str {
        return I64.to_str(U8.to_i64(self))
    }

    from_str := func(s: Str) returns U8 throws U8_Overflow {
        return U8.from_i64(I64.from_str(s))
    }

    size := func() returns I64 {
        return 1
    }
}
