mode lib

import("src.core.self.parser")

// Init phase: Declaration indexing and import processing
// This module handles the "context priming" phase that runs before type checking.
// No eval, no arena access - declarations only.
//
// Translated from src/rs/init.rs

SymbolInfo := struct {
    mut value_type: ValueType = ValueType.TFunction
    mut is_mut: Bool = false
    mut is_copy: Bool = false
    mut is_own: Bool = false
}

EnumVal := struct {
    mut enum_type: Str = ""
    mut enum_name: Str = ""
    // Payload for tagged unions: stores the associated data
    // For now, supports Bool (1 byte) and I64 (8 bytes)
    mut payload: Option = Option.None  // Option<Vec<u8>>
    mut payload_type: Option = Option.None  // Option<ValueType>
}

// Scope stack for proper lexical scoping
// Top-level module scope, Function body, Generic block (if, else, loop body), Catch block (for error handling)
ScopeType := enum {
    Global,
    Function,
    Block,
    Catch
}

ScopeFrame := struct {
    // maps variable names to their offsets in the arena
    mut arena_index: Map = Map.new(Str, I64)  // HashMap<String, usize> in Rust (stores offsets)

    // All declared symbols (types, constants, variables, and function names)
    // This is necessary for so called "context priming" or "declaration indexing"
    // aka declaring things in whatever order, aka not needing forward declarations
    // in theory it should only be needed for the "type" phase after the init context phase
    // but it can be convenient at times in eval or compile phases too, I guess.
    mut symbols: Map = Map.new(Str, SymbolInfo)

    // All functions, with their function types, signatures and bodies (functions, methods, macros, etc).
    mut funcs: Map = Map.new(Str, SFuncDef)

    // Enum type definitions (variants and associated data)
    mut enums: Map = Map.new(Str, SEnumDef)

    // Struct type definitions (fields and associated constants [including functions, structs are namespaces, almost])
    mut structs: Map = Map.new(Str, SStructDef)

    // Scope type (helps with cleanup and debugging)
    mut scope_type: ScopeType = ScopeType.Global
}

ScopeStack := struct {
    // Stack of scope frames
    mut frames: Vec = Vec.new(ScopeFrame)

    new := func() returns ScopeStack throws AllocError {
        mut stack := ScopeStack()
        stack.frames = Vec.new(ScopeFrame)
        return stack
    }

    push := proc(mut self: ScopeStack, scope_type: ScopeType) throws AllocError {
        mut frame := ScopeFrame()
        frame.arena_index = Map.new(Str, I64)
        frame.symbols = Map.new(Str, SymbolInfo)
        frame.funcs = Map.new(Str, SFuncDef)
        frame.enums = Map.new(Str, SEnumDef)
        frame.structs = Map.new(Str, SStructDef)
        frame.scope_type = scope_type
        self.frames.push(frame)
    }

    pop := proc(mut self: ScopeStack) returns Result throws Str, IndexOutOfBoundsError {
        if lteq(self.frames.len, 1) {
            return Result.Err("Cannot pop global scope")
        }

        if eq(self.frames.len, 0) {
            return Result.Err("Scope stack underflow")
        }

        mut new_len := sub(self.frames.len, 1)
        mut popped := ScopeFrame()
        self.frames.get(new_len, popped)
        self.frames._len = new_len
        return Result.Ok(popped)
    }

    lookup_var := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        // Walk up the stack from innermost to outermost
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.arena_index.contains_key(name) {
                mut offset_str := frame.arena_index.get(name)
                return Option.Some(offset_str)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    lookup_symbol := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.symbols.contains_key(name) {
                mut sym := frame.symbols.get(name)
                return Option.Some(sym)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_var := proc(mut self: ScopeStack, name: Str, offset: I64, symbol: SymbolInfo) returns Result throws Str, IndexOutOfBoundsError {
        if eq(self.frames.len, 0) {
            return Result.Err("No active scope")
        }

        mut last_idx := sub(self.frames.len, 1)
        mut current_frame := ScopeFrame()
        self.frames.get(last_idx, current_frame)

        // Check for redeclaration in current scope only
        if current_frame.arena_index.contains_key(name) {
            return Result.Err(format("Variable '", name, "' already declared in this scope"))
        }

        current_frame.arena_index.insert(name, offset.to_str())
        current_frame.symbols.insert(name, symbol)
        self.frames.set(last_idx, current_frame)
        return Result.Ok("")
    }

    declare_symbol := proc(mut self: ScopeStack, name: Str, symbol: SymbolInfo) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.symbols.insert(name, symbol)
            self.frames.set(last_idx, current_frame)
        }
    }

    remove_symbol := proc(mut self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.symbols.contains_key(name) {
                mut sym := current_frame.symbols.get(name)
                current_frame.symbols.remove(name)
                self.frames.set(last_idx, current_frame)
                return Option.Some(sym)
            }
        }
        return Option.None
    }

    remove_var := proc(mut self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.arena_index.contains_key(name) {
                mut offset_str := current_frame.arena_index.get(name)
                current_frame.arena_index.remove(name)
                self.frames.set(last_idx, current_frame)
                return Option.Some(offset_str)
            }
        }
        return Option.None
    }

    // Insert a variable without a corresponding symbol (simpler than declare_var)
    insert_var := proc(mut self: ScopeStack, name: Str, offset: I64) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.arena_index.insert(name, offset.to_str())
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_func := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.funcs.contains_key(name) {
                mut func_def := frame.funcs.get(name)
                return Option.Some(func_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_func := proc(mut self: ScopeStack, name: Str, func_def: SFuncDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.funcs.insert(name, func_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_enum := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.enums.contains_key(name) {
                mut enum_def := frame.enums.get(name)
                return Option.Some(enum_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_enum := proc(mut self: ScopeStack, name: Str, enum_def: SEnumDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.enums.insert(name, enum_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_struct := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.structs.contains_key(name) {
                mut struct_def := frame.structs.get(name)
                return Option.Some(struct_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_struct := proc(mut self: ScopeStack, name: Str, struct_def: SStructDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.structs.insert(name, struct_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    get_symbols_with_prefix := func(self: ScopeStack, prefix: Str) returns Vec throws IndexOutOfBoundsError {
        // Collect all keys from all scopes that start with the given prefix
        mut keys := Vec.new(Str)
        mut i := 0
        while lt(i, self.frames.len) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            mut symbol_keys := frame.symbols.keys
            mut j := 0
            while lt(j, symbol_keys.len) {
                mut key := ""
                symbol_keys.get(j, key)
                if key.starts_with(prefix) {
                    keys.push(key)
                }
                j = add(j, 1)
            }
            i = add(i, 1)
        }
        return keys
    }
}

get_func_name_in_call := func(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw e.exit_error("type", "get_func_name_in_call(): expected fcall node.")
    }
    if eq(e.params.len, 0) {
        throw e.exit_error("type", "get_func_name_in_call(): fcall nodes must have at least 1 parameter.")
    }
    mut param := Expr()
    e.params.get(0, param)
    mut func_name := ""
    switch param.node_type {
    case NodeType.Identifier(f_name):
        func_name = f_name
    case node_type:
        throw e.exit_error("type", format("in get_func_name_in_call(): Identifiers can only contain identifiers, found '", enum_to_str(node_type), "'"))
    }
    return func_name
}

value_type_func_proc := func(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str, IndexOutOfBoundsError {
    mut returns_len := func_def.return_types.len
    if eq(returns_len, 0) {
        throw e.error(path, "type", format("func '", name, "' does not return anything"))
    }
    if eq(returns_len, 1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)
        switch return_type {
        case ValueType.TCustom(type_str):
            return ValueType.TCustom(type_str)
        case other:
            throw e.error(path, "type", format("func '", name, "' returns unsupported type ", value_type_to_str(other)))
        }
    }
    throw e.todo_error(path, "type", format("func '", name, "' returns multiple values"))
}

// NOTE: This file is approximately 400 lines so far.
// The complete translation continues with all remaining functions from init.rs.
// Due to token limits, I need to continue this in subsequent sections.
// Remaining sections to translate:
// - get_ufcs_fcall_value_type (lines 267-309)
// - get_fcall_value_type (lines 311-628) - LARGE FUNCTION
// - get_value_type (lines 630-719)
// - import_path_to_file_path (lines 721-726)
// - init_import_declarations (lines 728-850)
// - init_context (lines 852-1019)
// - Context struct and all its methods (lines 1020-2207)

// I'll create a complete version by adding all remaining sections...
