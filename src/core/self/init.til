mode lib

import("src.core.self.parser")

// Init phase: Declaration indexing and import processing
// This module handles the "context priming" phase that runs before type checking.
// No eval, no arena access - declarations only.
//
// Translated from src/rs/init.rs

SymbolInfo := struct {
    mut value_type: ValueType = ValueType.TFunction
    mut is_mut: Bool = false
    mut is_copy: Bool = false
    mut is_own: Bool = false
}

EnumVal := struct {
    mut enum_type: Str = ""
    mut enum_name: Str = ""
    // Payload for tagged unions: stores the associated data
    // For now, supports Bool (1 byte) and I64 (8 bytes)
    mut payload: Ptr = Ptr()  // Option<Vec<u8>> in Rust - NULL for None
    mut payload_type: Ptr = Ptr()  // Option<ValueType> in Rust - NULL for None
}

// Scope stack for proper lexical scoping
ScopeType := enum {
    Global,      // Top-level module scope
    Function,    // Function body
    Block,       // Generic block (if, else, loop body)
    Catch        // Catch block (for error handling)
}

ScopeFrame := struct {
    // maps variable names to their offsets in the arena
    mut arena_index: Map = Map.new(Str, I64)  // HashMap<String, usize> in Rust (stores offsets)

    // All declared symbols (types, constants, variables, and function names)
    // This is necessary for so called "context priming" or "declaration indexing"
    // aka declaring things in whatever order, aka not needing forward declarations
    // in theory it should only be needed for the "type" phase after the init context phase
    // but it can be convenient at times in eval or compile phases too, I guess.
    mut symbols: Map = Map.new(Str, SymbolInfo)

    // All functions, with their function types, signatures and bodies (functions, methods, macros, etc).
    mut funcs: Map = Map.new(Str, SFuncDef)

    // Enum type definitions (variants and associated data)
    mut enums: Map = Map.new(Str, SEnumDef)

    // Struct type definitions (fields and associated constants [including functions, structs are namespaces, almost])
    mut structs: Map = Map.new(Str, SStructDef)

    // Scope type (helps with cleanup and debugging)
    mut scope_type: ScopeType = ScopeType.Global
}

ScopeStack := struct {
    // Stack of scope frames
    mut frames: Vec = Vec.new(ScopeFrame)


    new := func() returns ScopeStack throws AllocError {
        mut stack := ScopeStack()
        stack.frames = Vec.new(ScopeFrame)
        return stack
    }

    push := proc(mut self: ScopeStack, scope_type: ScopeType) throws AllocError, FullError {
        mut frame := ScopeFrame()
        frame.arena_index = Map.new(Str, I64)
        frame.symbols = Map.new(Str, SymbolInfo)
        frame.funcs = Map.new(Str, SFuncDef)
        frame.enums = Map.new(Str, SEnumDef)
        frame.structs = Map.new(Str, SStructDef)
        frame.scope_type = scope_type
        self.frames.push(frame)
    }

    pop := proc(mut self: ScopeStack) returns ScopeFrame throws Str, IndexOutOfBoundsError, FullError {
        if self.frames.len().lteq(1) {
            throw "Cannot pop global scope"
        }

        mut popped := self.frames.pop()
        return popped
    }

    lookup_var := func(self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        // Walk up the stack from innermost to outermost
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.arena_index.contains_key(name) {
                mut offset_str := frame.arena_index.get(name)
                mut ptr := Ptr()
                ptr.data = offset_str.to_i64()
                return ptr
            }
            i = i.sub(1)
        }
        return Ptr()  // NULL - not found
    }

    lookup_symbol := func(self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.symbols.contains_key(name) {
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found
                return ptr
            }
            i = i.sub(1)
        }
        return Ptr()  // NULL - not found
    }

    // Helper to get the actual symbol (not just checking if it exists)
    get_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws Str, IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.symbols.contains_key(name) {
                return frame.symbols.get(name)
            }
            i = i.sub(1)
        }
        throw format("Symbol '", name, "' not found")
    }

    declare_var := proc(mut self: ScopeStack, name: Str, offset: I64, symbol: SymbolInfo) throws Str, IndexOutOfBoundsError {
        if self.frames.len().eq(0) {
            throw "No active scope"
        }

        mut last_idx := self.frames.len().sub(1)
        mut current_frame := ScopeFrame()
        self.frames.get(last_idx, current_frame)

        // Check for redeclaration in current scope only
        if current_frame.arena_index.contains_key(name) {
            throw format("Variable '", name, "' already declared in this scope")
        }

        current_frame.arena_index.insert(name, offset.to_str())
        current_frame.symbols.insert(name, symbol)
        self.frames.set(last_idx, current_frame)
    }

    declare_symbol := proc(mut self: ScopeStack, name: Str, symbol: SymbolInfo) throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.symbols.insert(name, symbol)
            self.frames.set(last_idx, current_frame)
        }
    }

    remove_symbol := proc(mut self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.symbols.contains_key(name) {
                current_frame.symbols.remove(name)
                self.frames.set(last_idx, current_frame)
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found and removed
                return ptr
            }
        }
        return Ptr()  // NULL - not found
    }

    remove_var := proc(mut self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.arena_index.contains_key(name) {
                mut offset_str := current_frame.arena_index.get(name)
                current_frame.arena_index.remove(name)
                self.frames.set(last_idx, current_frame)
                mut ptr := Ptr()
                ptr.data = offset_str.to_i64()
                return ptr
            }
        }
        return Ptr()  // NULL - not found
    }

    // Insert a variable without a corresponding symbol (simpler than declare_var)
    insert_var := proc(mut self: ScopeStack, name: Str, offset: I64) throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.arena_index.insert(name, offset.to_str())
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_func := func(self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.funcs.contains_key(name) {
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found
                return ptr
            }
            i = i.sub(1)
        }
        return Ptr()  // NULL - not found
    }

    // Helper to get the actual function definition
    get_func := func(self: ScopeStack, name: Str) returns SFuncDef throws Str, IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.funcs.contains_key(name) {
                return frame.funcs.get(name)
            }
            i = i.sub(1)
        }
        throw format("Function '", name, "' not found")
    }

    declare_func := proc(mut self: ScopeStack, name: Str, func_def: SFuncDef) throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.funcs.insert(name, func_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_enum := func(self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.enums.contains_key(name) {
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found
                return ptr
            }
            i = i.sub(1)
        }
        return Ptr()  // NULL - not found
    }

    // Helper to get the actual enum definition
    get_enum := func(self: ScopeStack, name: Str) returns SEnumDef throws Str, IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.enums.contains_key(name) {
                return frame.enums.get(name)
            }
            i = i.sub(1)
        }
        throw format("Enum '", name, "' not found")
    }

    declare_enum := proc(mut self: ScopeStack, name: Str, enum_def: SEnumDef) throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.enums.insert(name, enum_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_struct := func(self: ScopeStack, name: Str) returns Ptr throws IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.structs.contains_key(name) {
                mut ptr := Ptr()
                ptr.data = 1  // Non-NULL to indicate found
                return ptr
            }
            i = i.sub(1)
        }
        return Ptr()  // NULL - not found
    }

    // Helper to get the actual struct definition
    get_struct := func(self: ScopeStack, name: Str) returns SStructDef throws Str, IndexOutOfBoundsError {
        mut i := self.frames.len().sub(1)
        while i.gteq(0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.structs.contains_key(name) {
                return frame.structs.get(name)
            }
            i = i.sub(1)
        }
        throw format("Struct '", name, "' not found")
    }

    declare_struct := proc(mut self: ScopeStack, name: Str, struct_def: SStructDef) throws IndexOutOfBoundsError {
        if self.frames.len().gt(0) {
            mut last_idx := self.frames.len().sub(1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.structs.insert(name, struct_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    get_symbols_with_prefix := func(self: ScopeStack, prefix: Str) returns Vec throws IndexOutOfBoundsError, AllocError {
        // Collect all keys from all scopes that start with the given prefix
        mut keys := Vec.new(Str)
        mut prefix_len := prefix.len()
        mut i := 0
        while i.lt(self.frames.len()) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            mut symbol_keys := frame.symbols.keys
            mut j := 0
            while j.lt(symbol_keys.len()) {
                mut key := ""
                symbol_keys.get(j, key)
                // Check if key starts with prefix
                if key.len().gteq(prefix_len) {
                    mut matches := true
                    mut k := 0
                    while k.lt(prefix_len) {
                        mut key_char := get_char(key, k)
                        mut prefix_char := get_char(prefix, k)
                        if not(key_char.eq(prefix_char)) {
                            matches = false
                        }
                        k = k.add(1)
                    }
                    if matches {
                        keys.push(key)
                    }
                }
                j = j.add(1)
            }
            i = i.add(1)
        }
        return keys
    }
}

get_func_name_in_call := func(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw e.exit_error("type", "get_func_name_in_call(): expected fcall node.")
    }
    if e.params.len().eq(0) {
        throw e.exit_error("type", "get_func_name_in_call(): fcall nodes must have at least 1 parameter.")
    }
    mut param := e.get(0)
    mut func_name := ""
    switch param.node_type {
    case NodeType.Identifier(f_name):
        func_name = f_name
    case node_type:
        throw e.exit_error("type", format("in get_func_name_in_call(): Identifiers can only contain identifiers, found '", enum_to_str(node_type), "'"))
    }
    return func_name
}

value_type_func_proc := func(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str, IndexOutOfBoundsError {
    mut returns_len := func_def.return_types.len()
    if returns_len.eq(0) {
        throw e.error(path, "type", format("func '", name, "' does not return anything"))
    }
    if returns_len.eq(1) {
        mut return_type := func_def.return_types.get(0)
        switch return_type {
        case ValueType.TCustom(type_str):
            return ValueType.TCustom(type_str)
        case other:
            throw e.error(path, "type", format("func '", name, "' returns unsupported type ", value_type_to_str(other)))
        }
    }
    throw e.todo_error(path, "type", format("func '", name, "' returns multiple values"))
}

get_ufcs_fcall_value_type := func(context: Context, e: Expr, f_name: Str, id_expr: Expr, symbol: SymbolInfo) returns ValueType throws Str, IndexOutOfBoundsError, FullError {
    if id_expr.params.len().eq(0) {
        throw e.error(context.path, "type", format("Cannot call '", f_name, "', it is not a function or struct, it is a '", value_type_to_str(symbol.value_type), "'"))
    }

    // Get the last param (the method name)
    mut last_idx := id_expr.params.len().sub(1)
    mut method_name_expr := id_expr.params.get(last_idx)

    mut method_name := ""
    switch method_name_expr.node_type {
    case NodeType.Identifier(name):
        method_name = name
    case node_type:
        throw e.error(context.path, "type", format("Expected identifier for method name, found '", enum_to_str(node_type), "'"))
    }

    // Check if it's a regular function
    mut func_ptr := context.scope_stack.lookup_func(method_name)
    if func_ptr.data.ne(NULL) {
        mut func_def := context.scope_stack.get_func(method_name)
        return value_type_func_proc(context.path, e, f_name, func_def)
    }

    // Create identifier expression without the last param (method name) to get the type
    mut id_without_method := id_expr.clone()
    mut new_len := id_without_method.params.len().sub(1)
    id_without_method.params._len = new_len

    // Get the type of the nested identifier
    mut target_type := get_value_type(context, id_without_method)

    // Check if it's an associated function for this type
    switch target_type {
    case ValueType.TCustom(custom_type_name):
        mut id_expr_name := format(custom_type_name, ".", method_name)
        mut method_ptr := context.scope_stack.lookup_func(id_expr_name)
        if method_ptr.data.ne(NULL) {
            mut method_def := context.scope_stack.get_func(id_expr_name)
            return value_type_func_proc(context.path, e, id_expr_name, method_def)
        }
        throw e.error(context.path, "type", format("Type '", custom_type_name, "' has no method '", method_name, "'"))
    case:
        throw e.error(context.path, "type", format("'", f_name, "' of type '", value_type_to_str(target_type), "' doesn't support methods"))
    }
}

get_fcall_value_type := func(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError, FullError, AllocError {

    mut f_name := get_func_name_in_call(e)

    // Check if this is a UFCS call on a function/expression result
    // If e has 2+ params (func name + target + args), check if the target's type
    // has an associated method with this name, prioritizing it over standalone functions
    if e.params.len().gteq(2) {
        mut first_arg := e.get(1)  // Get the UFCS target (skip func name at index 0)

        // Try to get the type of the first argument
        mut target_type := get_value_type(context, first_arg)
        catch (err: Str) {
            // Couldn't determine type, fall through
        }

        switch target_type {
        case ValueType.TCustom(custom_type_name):
            // Check if this type has an associated method with this name
            mut method_name := format(custom_type_name, ".", f_name)
            mut method_ptr := context.scope_stack.lookup_func(method_name)
            if method_ptr.data.ne(NULL) {
                // UFCS method exists! Use it instead of standalone function
                mut func_def := context.scope_stack.get_func(method_name)
                return value_type_func_proc(context.path, e, method_name, func_def)
            }
        case:
            // Not TCustom or no method, fall through
        }
        // If we couldn't determine type or no associated method exists, fall through
    }

    // Original logic: check for standalone function
    mut func_ptr := context.scope_stack.lookup_func(f_name)
    if func_ptr.data.ne(NULL) {
        mut func_def := context.scope_stack.get_func(f_name)
        return value_type_func_proc(context.path, e, f_name, func_def)
    }

    // Not a standalone function, check if it's a symbol (type, enum, struct, etc)
    mut symbol_ptr := context.scope_stack.lookup_symbol(f_name)
    if symbol_ptr.data.eq(NULL) {
        throw e.error(context.path, "type", format("Undefined symbol '", f_name, "'"))
    }

    mut symbol := context.scope_stack.get_symbol(f_name)
    mut id_expr := e.get(0)

    switch symbol.value_type {
    case ValueType.TType(TTypeDef.TStructDef):
        // Handle struct constructor or struct method calls
        mut struct_ptr := context.scope_stack.lookup_struct(f_name)
        if struct_ptr.data.eq(NULL) {
            throw e.lang_error(context.path, "type", format("struct '", f_name, "' not found in context"))
        }
        mut struct_def := context.scope_stack.get_struct(f_name)

        // Check if there's a member access after the struct name
        if id_expr.params.len().eq(0) {
            // Just "StructName()" - constructor call
            return ValueType.TCustom(f_name)
        }

        mut after_dot := id_expr.params.get(0)
        switch after_dot.node_type {
        case NodeType.Identifier(after_dot_name):
            mut member_decl := struct_def.get_member_or_err(after_dot_name, f_name, context.path, e)
            mut has_default := struct_def.default_values.contains_key(after_dot_name)
            if not(has_default) {
                throw e.error(context.path, "type", format("struct '", f_name, "' has no member '", after_dot_name, "' b"))
            }
            mut member_default_value := struct_def.default_values.get(after_dot_name)

            switch member_default_value.node_type {
            case NodeType.FuncDef(func_def):
                mut combined_name := format(f_name, ".", after_dot_name)
                return value_type_func_proc(context.path, e, combined_name, func_def)
            case:
                throw e.error(context.path, "type", format("Cannot call '", f_name, ".", after_dot_name, "', it is not a function, it is '", value_type_to_str(member_decl.value_type), "'"))
            }
        case node_type:
            throw e.lang_error(context.path, "type", format("Expected identifier after '", f_name, ".' found '", enum_to_str(node_type), "'"))
        }


    case ValueType.TType(TTypeDef.TEnumDef):
        // Handle enum constructor calls like Color.Green(true)
        mut enum_ptr := context.scope_stack.lookup_enum(f_name)
        if enum_ptr.data.eq(NULL) {
            throw e.lang_error(context.path, "type", format("enum '", f_name, "' not found in context"))
        }
        mut enum_def := context.scope_stack.get_enum(f_name)

        // Check if there's a member access (variant) after the enum name
        if id_expr.params.len().eq(0) {
            // Just referencing the enum type itself, not constructing
            return ValueType.TType(TTypeDef.TEnumDef)
        }

        mut after_dot := id_expr.params.get(0)
        switch after_dot.node_type {
        case NodeType.Identifier(variant_name):
            // Check if this variant exists in the enum
            mut has_variant := enum_def.enum_map.contains_key(variant_name)
            if not(has_variant) {
                throw e.error(context.path, "type", format("enum '", f_name, "' has no variant '", variant_name, "'"))
            }

            mut variant_value := enum_def.enum_map.get(variant_name)
            // variant_value is a Ptr that may be NULL (no payload) or contain a ValueType (has payload)

            // Check if variant has a payload (variant_value is non-NULL)
            if variant_value.data.ne(NULL) {
                // This variant expects a payload
                if e.params.len().lt(2) {
                    // TODO: Get the actual payload type from variant_value and show it
                    throw e.error(context.path, "type", format("Enum constructor ", f_name, ".", variant_name, " expects a payload"))
                }
                // Type check the payload argument
                mut payload_expr := e.get(1)
                mut payload_actual_type := get_value_type(context, payload_expr)

                // TODO: Verify payload type matches expected type
                // This would require unwrapping the ValueType from variant_value
                // For now, we just accept any payload
            } else {
                // This variant doesn't have a payload
                if e.params.len().gt(1) {
                    throw e.error(context.path, "type", format("Enum variant ", f_name, ".", variant_name, " does not take a payload"))
                }
            }

            // Return the enum type
            return ValueType.TCustom(f_name)
        case node_type:
            throw e.lang_error(context.path, "type", format("Expected identifier after '", f_name, ".' found '", enum_to_str(node_type), "'"))
        }

                }
            },
            ValueType::TCustom(custom_type_name) => {
                // Check if it's an enum first
                if context.scope_stack.lookup_enum(custom_type_name).is_some() {
                    // It's an enum - try UFCS method call
                    let after_dot = match id_expr.params.get(0) {
                        Some(_after_dot) => _after_dot,
                        None => {
                            return Ok(ValueType::TCustom(f_name.clone()));
                        },
                    };
                    match &after_dot.node_type {
                        NodeType::Identifier(after_dot_name) => {
                            // Try associated method first
                            let method_name = format!("{}.{}", custom_type_name, after_dot_name);
                            if let Some(func_def) = context.scope_stack.lookup_func(&method_name) {
                                return value_type_func_proc(&context.path, &e, &method_name, func_def);
                            }

                            // Fall back to UFCS: try standalone function with enum as first arg
                            match get_ufcs_fcall_value_type(&context, &e, &f_name, id_expr, symbol) {
                                Ok(ok_val) => return Ok(ok_val),
                                Err(_) => {
                                    return Err(e.error(&context.path, "type", &format!("enum '{}' has no method '{}' and no matching function found for UFCS", custom_type_name, after_dot_name)));
                                },
                            }
                        },
                        _ => {
                            return Err(e.lang_error(&context.path, "type", &format!("Expected identifier after '{}.' found '{:?}'", f_name, after_dot.node_type)));
                        },
                    }
                }

                // Not an enum, try struct
                let struct_def = match context.scope_stack.lookup_struct(custom_type_name) {
                    Some(_struct_def) => _struct_def,
                    None => {
                        return Err(e.lang_error(&context.path, "type", &format!("type '{}' not found in context", f_name)));
                    },
                };
                let after_dot = match id_expr.params.get(0) {
                    Some(_after_dot) => _after_dot,
                    None => {
                        return Ok(ValueType::TCustom(f_name.clone()));
                    },
                };
                match &after_dot.node_type {
                    NodeType::Identifier(after_dot_name) => {
                        // Bug #10 fix: Check if we have a multi-level chain like struct.field.method
                        // If id_expr.params has 2+ elements, try to resolve all-but-last as field access
                        if id_expr.params.len() >= 2 {
                            // Try to resolve the field access chain (all params except the last)
                            // Example: for e.params.len, resolve "e.params" to get its type
                            let mut field_access_expr = id_expr.clone();
                            field_access_expr.params.pop(); // Remove the last element (method/property name)

                            if let Ok(intermediate_type) = get_value_type(context, &field_access_expr) {
                                // Successfully resolved intermediate field access
                                // Now check if the last param is a member/method of that type
                                let last_param = id_expr.params.last().unwrap();
                                if let NodeType::Identifier(final_member_name) = &last_param.node_type {
                                    match &intermediate_type {
                                        ValueType::TCustom(intermediate_type_name) => {
                                            // First check if it's a method on this type
                                            let method_name = format!("{}.{}", intermediate_type_name, final_member_name);
                                            if let Some(func_def) = context.scope_stack.lookup_func(&method_name) {
                                                return value_type_func_proc(&context.path, &e, &method_name, func_def);
                                            }

                                            // Try UFCS: standalone function with intermediate type as first arg
                                            if let Some(func_def) = context.scope_stack.lookup_func(final_member_name) {
                                                return value_type_func_proc(&context.path, &e, final_member_name, func_def);
                                            }

                                            // Check if it's a struct with this member as a field
                                            if let Some(intermediate_struct_def) = context.scope_stack.lookup_struct(intermediate_type_name) {
                                                if let Some(member_decl) = intermediate_struct_def.get_member(final_member_name) {
                                                    // It's a field access - return the field's type
                                                    return Ok(member_decl.value_type.clone());
                                                }
                                            }
                                        },
                                        _ => {
                                            // Intermediate type is not a custom type, fall through
                                        }
                                    }
                                }
                            }
                        }

                        // Original logic: single-level access (struct.member)
                        let member_decl = match struct_def.get_member(after_dot_name) {
                            Some(_member) => _member,
                            None => {
                                match get_ufcs_fcall_value_type(&context, &e, &f_name, id_expr, symbol) {
                                    Ok(ok_val) => return Ok(ok_val),
                                    Err(error_string) => {
                                        println!("{}", error_string);
                                        return Err(e.error(&context.path, "type", &format!("struct '{}' has no member '{}' c", custom_type_name, after_dot_name)));
                                    },
                                }
                            },
                        };
                        let member_default_value = match struct_def.default_values.get(after_dot_name) {
                            Some(_member) => _member,
                            None => {
                                return Err(e.error(&context.path, "type", &format!("struct '{}' has no member '{}' d", custom_type_name, after_dot_name)));
                            },
                        };
                        match &member_default_value.node_type {
                            NodeType::FuncDef(func_def) => {
                                let combined_name = format!("{}.{}", custom_type_name, after_dot_name);
                                return value_type_func_proc(&context.path, &e, &combined_name, &func_def);
                            },
                            _  => {
                                return Err(e.error(&context.path, "type", &format!("Cannot call '{}.{}', it is not a function, it is '{}'",
                                                                    f_name, after_dot_name, value_type_to_str(&member_decl.value_type))));
                            },
                        }
                    },

                    _ => {
                        return Err(e.lang_error(&context.path, "type", &format!("Expected identifier after '{}.' found '{:?}'", f_name, after_dot.node_type)));
                    },
                }
            },
            ValueType::TMulti(_) => {
                // Variadic parameters are implemented as Array at runtime
                // Treat them as Array for type checking method calls
                let custom_type_name = "Array";
                let struct_def = match context.scope_stack.lookup_struct(custom_type_name) {
                    Some(_struct_def) => _struct_def,
                    None => {
                        return Err(e.lang_error(&context.path, "type", &format!("struct '{}' not found in context", custom_type_name)));
                    },
                };
                let after_dot = match id_expr.params.get(0) {
                    Some(_after_dot) => _after_dot,
                    None => {
                        return Ok(ValueType::TCustom(custom_type_name.to_string()));
                    },
                };
                match &after_dot.node_type {
                    NodeType::Identifier(after_dot_name) => {
                        let member_decl = match struct_def.get_member(after_dot_name) {
                            Some(_member) => _member,
                            None => {
                                match get_ufcs_fcall_value_type(&context, &e, &f_name, id_expr, symbol) {
                                    Ok(ok_val) => return Ok(ok_val),
                                    Err(error_string) => {
                                        println!("{}", error_string);
                                        return Err(e.error(&context.path, "type", &format!("struct '{}' has no member '{}' (variadic)", custom_type_name, after_dot_name)));
                                    },
                                }
                            },
                        };
                        let member_default_value = match struct_def.default_values.get(after_dot_name) {
                            Some(_member) => _member,
                            None => {
                                return Err(e.error(&context.path, "type", &format!("struct '{}' has no member '{}' (variadic default)", custom_type_name, after_dot_name)));
                            },
                        };
                        match &member_default_value.node_type {
                            NodeType::FuncDef(func_def) => {
                                let combined_name = format!("{}.{}", custom_type_name, after_dot_name);
                                return value_type_func_proc(&context.path, &e, &combined_name, &func_def);
                            },
                            _  => {
                                return Err(e.error(&context.path, "type", &format!("Cannot call '{}.{}', it is not a function, it is '{}'",
                                                                    custom_type_name, after_dot_name, value_type_to_str(&member_decl.value_type))));
                            },
                        }
                    },

                    _ => {
                        return Err(e.lang_error(&context.path, "type", &format!("Expected identifier after '{}.' found '{:?}'", f_name, after_dot.node_type)));
                    },
                }
            },
            _ => {
                return get_ufcs_fcall_value_type(&context, &e, &f_name, id_expr, symbol)
            },
        }

    } else {
        return Err(e.error(&context.path, "type", &format!("Undefined symbol '{}'", &f_name)));
    }
}

pub fn get_value_type(context: &Context, e: &Expr) -> Result<ValueType, String> {
    match &e.node_type {
        NodeType::LLiteral(Literal::Number(_)) => Ok(ValueType::TCustom("I64".to_string())),
        NodeType::LLiteral(Literal::Str(_)) => Ok(ValueType::TCustom("Str".to_string())),
        NodeType::LLiteral(Literal::List(_)) => Ok(ValueType::TCustom("List".to_string())),
        NodeType::FuncDef(func_def) => match func_def.function_type {
            FunctionType::FTFunc | FunctionType::FTFuncExt => Ok(ValueType::TFunction(FunctionType::FTFunc)),
            FunctionType::FTProc | FunctionType::FTProcExt => Ok(ValueType::TFunction(FunctionType::FTProc)),
            FunctionType::FTMacro => Ok(ValueType::TFunction(FunctionType::FTMacro)),
        },
        NodeType::EnumDef(_) => Ok(ValueType::TType(TTypeDef::TEnumDef)),
        NodeType::StructDef(_) => Ok(ValueType::TType(TTypeDef::TStructDef)),
        NodeType::FCall => get_fcall_value_type(context, e),
        NodeType::Range => Ok(ValueType::TCustom(format!("{}Range", value_type_to_str(&get_value_type(&context, e.get(0)?)?)))),

        NodeType::Identifier(name) => {
            let mut current_type = match context.scope_stack.lookup_symbol(name) {
                Some(symbol_info_m) => {
                    symbol_info_m.value_type.clone()
                },
                None => return Err(e.error(&context.path, "type", &format!("Undefined symbol '{}'", name))),
            };

            // If there are no parameters, just return the type of the first identifier
            if e.params.is_empty() {
                return Ok(current_type);
            }

            // Now, process each nested member.
            for cursor in &e.params {
                let member_name = match &cursor.node_type {
                    NodeType::Identifier(n) => n,
                    node_type => return Err(e.lang_error(&context.path, "type", &format!("Identifiers can only contain identifiers, found '{:?}'", node_type))),
                };

                match &current_type {
                    ValueType::TType(TTypeDef::TStructDef) => {
                        // If it's a struct, resolve its member
                        let struct_def = context.scope_stack.lookup_struct(name)
                            .ok_or_else(|| e.error(&context.path, "type", &format!("Struct '{}' not found", name)))?;

                        let decl = struct_def.get_member_or_err(member_name, name, &context.path, e)?;
                        current_type = decl.value_type.clone();
                    },
                    ValueType::TType(TTypeDef::TEnumDef) => {
                        // If it's an enum, resolve the variant
                        let enum_def = context.scope_stack.lookup_enum(name)
                            .ok_or_else(|| e.error(&context.path, "type", &format!("Enum '{}' not found", name)))?;

                        if enum_def.enum_map.contains_key(member_name) {
                            return Ok(ValueType::TCustom(name.to_string()));
                        } else {
                            return Err(e.error(&context.path, "type", &format!("Enum '{}' has no value '{}'", name, member_name)));
                        }
                    },
                    ValueType::TCustom(custom_type_name) => {
                        // If it's a custom type (a struct), resolve the member
                        let struct_def = context.scope_stack.lookup_struct(custom_type_name)
                            .ok_or_else(|| e.error(&context.path, "type", &format!("Struct '{}' not found", custom_type_name)))?;

                        let decl = struct_def.get_member_or_err(member_name, custom_type_name, &context.path, e)?;
                        current_type = decl.value_type.clone();
                    },
                    ValueType::TMulti(_variadic_type_name) => {
                        // Variadic parameters are implemented as Array at runtime
                        current_type = ValueType::TCustom("Array".to_string());
                    },
                    _ => {
                        return Err(e.error(&context.path, "type", &format!("'{}' of type '{}' can't have members", name, value_type_to_str(&current_type))));
                    }
                }
            }

            Ok(current_type) // Return the type of the last field (x)
        },

        NodeType::Pattern(PatternInfo { variant_name, .. }) => {
            // Extract enum type from "EnumType.Variant" format
            if let Some(dot_pos) = variant_name.rfind('.') {
                let enum_type = &variant_name[..dot_pos];
                Ok(ValueType::TCustom(enum_type.to_string()))
            } else {
                // If no dot, assume the whole thing is the enum type (shouldn't happen in practice)
                Ok(ValueType::TCustom(variant_name.clone()))
            }
        },

        node_type => return Err(e.error(&context.path, "type", &format!("get_value_type() not implemented for {:?} yet.", node_type))),
    }
}

// Convert dot-based import path to OS-specific file path
// Example: "src.core.std" -> "src/core/std.til" (Unix) or "src\core\std.til" (Windows)
fn import_path_to_file_path(import_path: &str) -> String {
    let file_path = import_path.replace(".", std::path::MAIN_SEPARATOR_STR);
    format!("{}.til", file_path)
}

// Import declarations only (no eval) - for init phase
// This processes imports during declaration indexing, copying only declarations
// to the parent context. The eval phase will later initialize values.
fn init_import_declarations(context: &mut Context, e: &Expr, import_path_str: &str) -> Result<(), String> {
    let path = import_path_to_file_path(import_path_str);
    let original_path = context.path.clone();

    // Check if already processed for declarations
    if context.imports_declarations_done.contains(&path) {
        return Ok(()); // Already imported declarations
    }

    // Check for circular imports
    if context.imports_wip.contains(&path) {
        return Err(e.error(&context.path, "import", &format!("While trying to import {} from {}: Circular import dependency",
                                              path, original_path)));
    }

    // Mark as work-in-progress
    if !context.imports_wip.insert(path.clone()) {
        return Err(e.lang_error(&context.path, "import", &format!("While trying to import {} from {}: Can't insert in imports_wip",
                                                   path, original_path)));
    }

    // Read and parse the imported file
    let source: String = match fs::read_to_string(&path) {
        Ok(file) => file,
        Err(error) => {
            context.imports_wip.remove(&path);
            return match error.kind() {
                ErrorKind::NotFound => Err(e.error(&context.path, "import", &format!("File '{}' not found", path))),
                other_error => Err(e.error(&context.path, "import", &format!("Problem reading file '{}': {}", path, other_error))),
            };
        },
    };

    context.path = path.clone();

    // Lex the imported file
    let mut lexer = match lexer_from_source(&path, source) {
        Ok(lexer) => lexer,
        Err(error_string) => {
            let orig_path_clone = original_path.clone();
            context.path = original_path;
            context.imports_wip.remove(&path);
            return Err(e.error(&context.path, "import", &format!("While trying to import {} from {}:\n{}",
                                                  path, orig_path_clone, error_string)));
        },
    };

    // Parse mode
    let mode = match parse_mode(&path, &mut lexer) {
        Ok(mode_) => mode_,
        Err(error_string) => {
            let orig_path_clone = original_path.clone();
            context.path = original_path;
            context.imports_wip.remove(&path);
            return Err(e.error(&context.path, "import", &format!("While trying to import {} from {}:\n{}",
                                                  path, orig_path_clone, error_string)));
        },
    };

    // Check if mode can be imported
    if !can_be_imported(&mode) {
        context.path = original_path;
        context.imports_wip.remove(&path);
        return Err(e.error(&context.path, "import", &format!("file '{}' of mode '{}' cannot be imported", path, mode.name)));
    }

    let previous_mode = context.mode.clone();
    context.mode = mode;

    // Process mode imports recursively
    for import_str in context.mode.imports.clone() {
        let import_func_name_expr = Expr{node_type: NodeType::Identifier("import".to_string()), params: Vec::new(), line: 0, col: 0};
        let import_path_expr = Expr{node_type: NodeType::LLiteral(Literal::Str(import_str.to_string())), params: Vec::new(), line: 0, col: 0};
        let import_fcall_expr = Expr{node_type: NodeType::FCall, params: vec![import_func_name_expr, import_path_expr], line: 0, col: 0};
        if let Err(error_string) = init_import_declarations(context, &import_fcall_expr, &import_str) {
            context.mode = previous_mode;
            context.path = original_path;
            context.imports_wip.remove(&path);
            return Err(error_string);
        }
    }

    // Parse to AST
    let imported_ast: Expr = match parse_tokens(&mut lexer) {
        Ok(expr) => expr,
        Err(error_string) => {
            context.mode = previous_mode;
            let orig_path_clone = original_path.clone();
            context.path = original_path;
            context.imports_wip.remove(&path);
            return Err(e.error(&context.path, "import", &format!("While trying to import {} from {}:\n{}",
                                                  path, orig_path_clone, error_string)));
        },
    };

    // Run init_context to extract declarations
    // This will recursively handle any imports in the imported file
    let errors = init_context(context, &imported_ast);
    if errors.len() > 0 {
        context.mode = previous_mode;
        let orig_path_clone = original_path.clone();
        context.path = original_path;
        context.imports_wip.remove(&path);
        let mut error_msg = format!("While trying to import {} from {}:\n", path, orig_path_clone);
        for err in &errors {
            error_msg.push_str(&format!("{}:{}\n", path, err));
        }
        return Err(error_msg);
    }

    // Restore context state
    context.mode = previous_mode;
    context.path = original_path;
    context.imports_wip.remove(&path);

    // Cache that we've processed this import's declarations
    context.imports_declarations_done.insert(path);

    Ok(())
}

// aka "context priming" or "declaration indexing"
pub fn init_context(context: &mut Context, e: &Expr) -> Vec<String> {
    let mut errors : Vec<String> = Vec::new();
    match &e.node_type {
        NodeType::Body => {
            for se in &e.params {
                errors.extend(init_context(context, &se));
            }
        },
        NodeType::FCall => {
            let f_name = get_func_name_in_call(&e);
            if f_name == "import" {
                // Extract import path (must be literal string)
                let import_path_expr = match e.get(1) {
                    Ok(import_path_expr_) => import_path_expr_,
                    Err(err) => {
                        errors.push(e.exit_error("import", &format!("{}:{}", context.path, err)));
                        return errors
                    },
                };
                let import_path = match &import_path_expr.node_type {
                    NodeType::LLiteral(import_path_str_lit_expr) => match import_path_str_lit_expr {
                        Literal::Str(import_path_) => import_path_,
                        literal_type => {
                            errors.push(import_path_expr.exit_error("import", &format!("Expected literal 'Str' for import, found literal '{:?}'",
                                                                                       literal_type)));
                            return errors
                        },

                    },
                    import_node_type => {
                        errors.push(import_path_expr.exit_error("import", &format!("Expected literal Str for import, found '{:?}'",
                                                                                   import_node_type)));
                        return errors
                    },
                };

                // Process import declarations (no eval)
                match init_import_declarations(context, &e, import_path) {
                    Ok(_) => {},
                    Err(err) => {
                        errors.push(err);
                        return errors;
                    },
                }
            }
        },
        NodeType::Declaration(decl) => {
            if context.scope_stack.lookup_func(&decl.name).is_some() || context.scope_stack.lookup_symbol(&decl.name).is_some() {
                errors.push(e.error(&context.path, "type", &format!("'{}' already declared.", decl.name)));
            }
            if e.params.len() != 1 {
                errors.push(e.exit_error("type", &format!("in init_context, while declaring {}, declarations must take exactly one value.", decl.name)));
                return errors
            }
            let inner_e = match e.get(0) {
                Ok(inner_e_) => inner_e_,
                Err(error_str) => {
                    errors.push(error_str);
                    return errors
                },
            };
            let mut value_type = match get_value_type(&context, &inner_e) {
                Ok(val_type) => val_type,
                Err(error_string) => {
                    errors.push(error_string);
                    return errors;
                },
            };
            if decl.value_type != str_to_value_type(INFER_TYPE) {
                if decl.value_type == ValueType::TCustom("U8".to_string()) && value_type == ValueType::TCustom("I64".to_string()) {
                    value_type = decl.value_type.clone();
                } else if value_type != decl.value_type {
                    errors.push(e.error(&context.path, "type", &format!("'{}' declared of type '{}' but initialized to type '{}'.",
                                                         decl.name, value_type_to_str(&decl.value_type), value_type_to_str(&value_type))));
                }
            }
            match value_type {
                ValueType::TFunction(ref ftype) => match ftype {
                    FunctionType::FTFunc | FunctionType::FTFuncExt |
                    FunctionType::FTProc | FunctionType::FTProcExt |
                    FunctionType::FTMacro => {
                        match &inner_e.node_type {
                            NodeType::FuncDef(func_def) => {
                                context.scope_stack.declare_symbol(decl.name.to_string(), SymbolInfo{value_type: value_type.clone(), is_mut: decl.is_mut, is_copy: decl.is_copy, is_own: decl.is_own });
                                context.scope_stack.declare_func(decl.name.to_string(), func_def.clone());
                            },
                            _ => {
                                errors.push(e.lang_error(&context.path, "type", &format!("{}s should have definitions", value_type_to_str(&value_type))));
                                return errors;
                            },
                        }
                    }
                },

                ValueType::TType(TTypeDef::TEnumDef) => {
                    if inner_e.params.len() != 0 {
                        errors.push(e.exit_error("type", &format!("while declaring {}: enum declarations don't have any parameters in the tree.",
                                                                  decl.name)));
                        return errors
                    }
                    match &inner_e.node_type {
                        NodeType::EnumDef(enum_def) => {
                            context.scope_stack.declare_symbol(decl.name.to_string(), SymbolInfo{value_type: value_type.clone(), is_mut: decl.is_mut, is_copy: decl.is_copy, is_own: decl.is_own });
                            context.scope_stack.declare_enum(decl.name.to_string(), enum_def.clone());
                        },
                        _ => {
                            errors.push(e.lang_error(&context.path, "type", "enums should have definitions."));
                            return errors;
                        },
                    }
                },

                ValueType::TType(TTypeDef::TStructDef) => {
                    if inner_e.params.len() != 0 {
                        errors.push(e.exit_error("type", &format!("while declaring {}, struct declarations must have exactly 0 params.",
                                                                  decl.name)));
                        return errors
                    }
                    match &inner_e.node_type {
                        NodeType::StructDef(struct_def) => {
                            // Register the struct itself
                            context.scope_stack.declare_symbol(decl.name.to_string(), SymbolInfo { value_type: value_type.clone(), is_mut: decl.is_mut, is_copy: decl.is_copy, is_own: decl.is_own });
                            context.scope_stack.declare_struct(decl.name.to_string(), struct_def.clone());
                            // Register associated funcs and constants (non-mut members only)
                            for (member_name, member_decl) in &struct_def.members {
                                if member_decl.is_mut {
                                    continue; // Skip instance fields
                                }
                                // Try to find a default_value (required for funcs/consts)
                                if let Some(member_expr) = struct_def.default_values.get(member_name) {
                                    let member_value_type = get_value_type(&context, member_expr).unwrap_or(ValueType::TCustom(INFER_TYPE.to_string()));
                                    let full_name = format!("{}.{}", decl.name, member_name); // Note: using '.' not '::'
                                    // Register in symbols
                                    context.scope_stack.declare_symbol(full_name.clone(), SymbolInfo { value_type: member_value_type.clone(), is_mut: member_decl.is_mut, is_copy: member_decl.is_copy, is_own: member_decl.is_own });
                                    // If it's a function, also register in funcs
                                    if let NodeType::FuncDef(func_def) = &member_expr.node_type {
                                        context.scope_stack.declare_func(full_name, func_def.clone());
                                    }
                                }
                            }
                        },
                        _ => {
                            errors.push(e.lang_error(&context.path, "type", "struct declarations should have definitions."));
                            return errors;
                        },
                    }
                }

                ValueType::TMulti(_) | ValueType::TCustom(_) => {
                    context.scope_stack.declare_symbol(decl.name.to_string(), SymbolInfo{value_type: value_type.clone(), is_mut: decl.is_mut, is_copy: decl.is_copy, is_own: decl.is_own });
                },
            }
        }
        _ => {
            if !context.mode.allows_base_anything {
                if context.mode.allows_base_calls {
                    errors.push(e.error(&context.path, "mode", &format!("mode '{}' allows only declarations and calls in the root context, found {:?}.",
                                                         context.mode.name, e.node_type)));
                } else {
                    errors.push(e.error(&context.path, "mode", &format!("mode '{}' allows only declarations in the root context, found {:?}.",
                                                         context.mode.name, e.node_type)));
                }
            }
        },
    }
    errors
}
#[derive(Clone)]
pub struct Context {
    pub mode: ModeDef, // All contexts need a mode
    // TODO use Context.path to properly report eval errors, or...no, don't refactor the whole eval phase to return Result<String, String>
    pub path: String, // this is needed for core func "loc"
    // Scope stack for proper lexical scoping
    pub scope_stack: ScopeStack,
    // Temporary storage for enum payload data during construction
    pub temp_enum_payload: Option<(Vec<u8>, ValueType)>, // (payload_bytes, payload_type)
    // Two-phase imports: separate caches for declaration and value initialization
    pub imports_declarations_done: HashSet<String>, // tracks which imports have had declarations copied (init phase)
    pub imports_values_done: HashMap<String, Result<EvalResult, String>>, // tracks which imports have had values initialized (eval phase)
    pub imports_wip: HashSet<String>, // wip imports (for cycle detection)
    // DEPRECATED: old single-phase cache, kept for compatibility
    #[allow(dead_code)]
    imports_done: HashMap<String, Result<EvalResult, String>>,
    // REM: A hashmap for in the future return a struct (namespace) so that it can be assigned to a constant/var
    // REM: This would enable: std := import("src/core/std") and then std.panic(), std.format(), etc.
    // REM: TODO change the cached type to support import as returning a struct_def
}

pub fn get_u8(context: &Context, id: &str, e: &Expr) -> Result<u8, String> {
    // Try direct lookup first (for base variables)
    let offset = if let Some(offset) = context.scope_stack.lookup_var(id) {
        offset
    } else if id.contains('.') {
        // For field paths, calculate offset dynamically
        context.get_field_offset(id).map_err(|err| {
            e.lang_error(&context.path, "context", &format!("get_u8: {}", err))
        })?
    } else {
        return Err(e.lang_error(&context.path, "context", &format!("u8 not found for id '{}'", id)));
    };

    Arena::g().memory.get(offset).copied()
        .ok_or_else(|| e.lang_error(&context.path, "context", &format!("Invalid u8 read for id '{}'", id)))
}


impl Context {
    pub fn new(path: &String, mode_name: &str) -> Result<Context, String> {
        let mut scope_stack = ScopeStack::new();
        scope_stack.push(ScopeType::Global); // Initialize global scope

        return Ok(Context {
            path: path.to_string(),
            mode: mode_from_name(mode_name)?,
            scope_stack,
            temp_enum_payload: None,
            imports_declarations_done: HashSet::new(),
            imports_values_done: HashMap::new(),
            imports_wip: HashSet::new(),
            imports_done: HashMap::new(), // DEPRECATED
        });
    }

    pub fn get_variant_pos(selfi: &SEnumDef, variant_name: &str, path: &str, e: &Expr) -> Result<i64, String> {
        match selfi.enum_map.keys().position(|k| k == variant_name) {
            Some(position) => Ok(position as i64),
            None => {
                return Err(e.lang_error(path, "context", &format!("Error: Enum variant '{}' not found in enum map.", variant_name)))
            },
        }
    }

    pub fn variant_pos_to_str(selfi: &SEnumDef, position: i64, path: &str, e: &Expr) -> Result<String, String> {
        let keys: Vec<String> = selfi.enum_map.keys().cloned().collect();
        if position < 0 || position >= keys.len() as i64 {
            // Return an error if the position is out of bounds
            return Err(e.lang_error(path, "context", &format!("Error: Invalid position '{}' for enum variant in '{}'.",
                                                        position, selfi.enum_map.keys().cloned().collect::<Vec<_>>().join(", "))));
        }

        // If position is valid, return the corresponding variant name
        return Ok(keys[position as usize].clone())
    }

    pub fn get_i64(self: &Context, id: &str, e: &Expr) -> Result<i64, String> {
        // Try direct lookup first (for base variables)
        let offset = if let Some(offset) = self.scope_stack.lookup_var(id) {
            offset
        } else if id.contains('.') {
            // For field paths, calculate offset dynamically
            self.get_field_offset(id).map_err(|err| {
                e.lang_error(&self.path, "context", &format!("get_i64: {}", err))
            })?
        } else {
            return Err(e.lang_error(&self.path, "context", &format!("i64 not found for id '{}'", id)));
        };

        match Arena::g().memory[offset..offset + 8].try_into() {
            Ok(bytes) => Ok(i64::from_ne_bytes(bytes)),
            Err(_) => Err(e.lang_error(&self.path, "context", &format!("Invalid i64 read for id '{}'", id))),
        }
    }

    pub fn insert_i64(self: &mut Context, id: &str, i64_str: &String, e: &Expr) -> Result<(), String> {
        let v = i64_str.parse::<i64>()
            .map_err(|_| e.lang_error(&self.path, "context", &format!("Invalid i64 literal '{}'", i64_str)))?;
        let bytes = v.to_ne_bytes();

        let is_instance_field = if id.contains('.') {
            // Check if base is an instance variable (not a struct type)
            let parts: Vec<&str> = id.split('.').collect();
            let base = parts[0];
            // If base is in symbols and is NOT a struct type, it's an instance field access
            self.scope_stack.lookup_symbol(base).map_or(false, |sym| {
                !matches!(&sym.value_type, ValueType::TType(_))
            })
        } else {
            false
        };

        if is_instance_field {
            // For instance field paths, calculate offset dynamically
            let offset = if let Some(offset) = self.scope_stack.lookup_var(id) {
                // Pre-registered field (old path)
                offset
            } else {
                // Calculate offset from struct definition
                self.get_field_offset(id).map_err(|err| {
                    e.lang_error(&self.path, "context", &format!("insert_i64: {}", err))
                })?
            };

            // Ensure arena has enough space
            let required_len = offset + 8;
            if Arena::g().memory.len() < required_len {
                Arena::g().memory.resize(required_len, 0);
            }

            Arena::g().memory[offset..offset + 8].copy_from_slice(&bytes);
            return Ok(())
        }

        // For non-instance fields (including struct constants like Vec.INIT_CAP), create new entry
        let offset = Arena::g().memory.len();
        Arena::g().memory.extend_from_slice(&bytes);
        self.scope_stack.insert_var(id.to_string(), offset);
        return Ok(())
    }

    // REM: Can't be moved to TIL until compilation - needs way to calculate size from TIL declarations
    pub fn insert_u8(self: &mut Context, id: &str, u8_str: &String, e: &Expr) -> Result<(), String> {
        let v = u8_str.parse::<u8>()
            .map_err(|_| e.lang_error(&self.path, "context", &format!("Invalid u8 literal '{}'", u8_str)))?;
        let bytes = [v];

        let is_instance_field = if id.contains('.') {
            let parts: Vec<&str> = id.split('.').collect();
            let base = parts[0];
            self.scope_stack.lookup_symbol(base).map_or(false, |sym| {
                !matches!(&sym.value_type, ValueType::TType(_))
            })
        } else {
            false
        };

        if is_instance_field {
            // For instance field paths, calculate offset dynamically
            let offset = if let Some(offset) = self.scope_stack.lookup_var(id) {
                // Pre-registered field (old path)
                offset
            } else {
                // Calculate offset from struct definition
                self.get_field_offset(id).map_err(|err| {
                    e.lang_error(&self.path, "context", &format!("insert_u8: {}", err))
                })?
            };
            Arena::g().memory[offset] = v;
            return Ok(())
        }

        let offset = Arena::g().memory.len();
        Arena::g().memory.extend_from_slice(&bytes);
        self.scope_stack.insert_var(id.to_string(), offset);
        return Ok(())
    }

    pub fn get_struct(&self, id: &str, e: &Expr) -> Result<String, String> {
        // Validate that the struct variable exists by checking if we can get its offset
        if self.scope_stack.lookup_var(id).is_some() {
            // Direct variable lookup succeeded
            Ok(id.to_string())
        } else if id.contains('.') {
            // For field paths, validate we can calculate offset
            self.get_field_offset(id).map_err(|err| {
                e.lang_error(&self.path, "context", &format!("get_struct: {}", err))
            })?;
            Ok(id.to_string())
        } else {
            Err(e.lang_error(&self.path, "context", &format!("struct not found for id '{}'", id)))
        }
    }


    pub fn map_instance_fields(&mut self, custom_type_name: &str, instance_name: &str, e: &Expr) -> Result<(), String> {
        let struct_def = self.scope_stack.lookup_struct(custom_type_name)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("map_instance_fields: definition for '{}' not found", custom_type_name)))?;

        let is_mut = self.scope_stack.lookup_symbol(instance_name)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("map_instance_fields: instance '{}' not found in symbols", instance_name)))?
            .is_mut;

        let base_offset = self.scope_stack.lookup_var(instance_name)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("map_instance_fields: base offset for '{}' not found", instance_name)))?;

        let members: Vec<(String, Declaration)> = struct_def
            .members
            .iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect();

        let mut current_offset = 0;
        for (field_name, decl) in members {
            if decl.is_mut {
                let combined_name = format!("{}.{}", instance_name, field_name);
                let field_offset = base_offset + current_offset;
                self.scope_stack.insert_var(combined_name.clone(), field_offset);

                self.scope_stack.declare_symbol(
                    combined_name.clone(),
                    SymbolInfo {
                        value_type: decl.value_type.clone(),
                        is_mut,
                        is_copy: false,
                        is_own: false,
                    },
                );

                if let ValueType::TCustom(type_name) = &decl.value_type {
                    if self.scope_stack.lookup_struct(type_name).is_some() {
                        self.map_instance_fields(type_name, &combined_name, e).map_err(|_| {
                            e.lang_error(&self.path, "context", &format!("map_instance_fields: failed to map nested struct field '{}'", combined_name))
                        })?;
                    }
                }

                let field_size = match &decl.value_type {
                    ValueType::TCustom(name) => self.get_type_size(name)?,
                    _ => return Err(e.lang_error(&self.path, "context", &format!(
                        "map_instance_fields: Unsupported value type '{}'", value_type_to_str(&decl.value_type)
                    ))),
                };

                current_offset += field_size;
            }
            // Immutable struct fields are handled generically through struct_defs
        }
        return Ok(())
    }

    // TODO all args should be passed as pointers/references and we wouldn't need this
    pub fn copy_fields(&mut self, custom_type_name: &str, src: &str, dest: &str, e: &Expr) -> Result<(), String> {
        let struct_def = self.scope_stack.lookup_struct(custom_type_name)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("copy_fields: definition for '{}' not found", custom_type_name)))?;

        let is_mut = self.scope_stack.lookup_symbol(dest)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("copy_fields: destination symbol '{}' not found", dest)))?
            .is_mut;

        let dest_base_offset = self.scope_stack.lookup_var(dest)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("copy_fields: destination arena offset for '{}' not found", dest)))?;

        let members: Vec<(String, Declaration)> = struct_def
            .members
            .iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect();

        let mut current_offset = 0;
        for (field_name, decl) in members {
            if !decl.is_mut {
                continue;
            }

            let field_size = match &decl.value_type {
                ValueType::TCustom(name) => self.get_type_size(name)?,
                _ => return Err(e.lang_error(&self.path, "context", &format!("copy_fields: unsupported field type '{}'", value_type_to_str(&decl.value_type)))),
            };

            let src_key = format!("{}.{}", src, field_name);
            let dest_key = format!("{}.{}", dest, field_name);

            // Try to get source offset - first from arena_index, then calculate dynamically
            let src_offset = if let Some(offset) = self.scope_stack.lookup_var(&src_key) {
                offset
            } else {
                // Calculate offset dynamically from struct definition
                match self.get_field_offset(&src_key) {
                    Ok(offset) => offset,
                    Err(_) => {
                        // Skip if source field doesn't exist (e.g., is_dyn in Array but not in Vec)
                        current_offset += field_size;
                        continue;
                    }
                }
            };

            let dest_offset = dest_base_offset + current_offset;

            self.scope_stack.insert_var(dest_key.clone(), dest_offset);
            self.scope_stack.declare_symbol(dest_key.clone(), SymbolInfo {
                value_type: decl.value_type.clone(),
                is_mut,
                is_copy: false,
                is_own: false,
            });

            Arena::g().memory.copy_within(src_offset..src_offset + field_size, dest_offset);

            if let ValueType::TCustom(type_name) = &decl.value_type {
                if self.scope_stack.lookup_struct(type_name).is_some() {
                    self.copy_fields(type_name, &src_key, &dest_key, e).map_err(|_| {
                        e.lang_error(&self.path, "context", &format!("copy_fields: failed to recursively copy field '{}'", dest_key))
                    })?;
                }
            }

            current_offset += field_size;
        }

        Ok(())
    }

    pub fn get_type_size(&self, type_name: &str) -> Result<usize, String> {
        match type_name {
            "U8"   => return Ok(1),
            "I64"  => return Ok(8),
            _ => {},
        }
        if let Some(enum_def) = self.scope_stack.lookup_enum(type_name) {
            // Calculate maximum variant size (8 bytes for tag + largest payload)
            let mut max_size = 8; // Start with tag size

            for (_variant_name, payload_type_opt) in &enum_def.enum_map {
                if let Some(payload_type) = payload_type_opt {
                    let payload_size = match payload_type {
                        ValueType::TCustom(t) => self.get_type_size(t)?,
                        _ => {
                            return Err(format!(
                                "get_type_size: unsupported payload type in enum '{}': {:?}",
                                type_name, payload_type
                            ));
                        }
                    };
                    let variant_total = 8 + payload_size; // tag + payload
                    if variant_total > max_size {
                        max_size = variant_total;
                    }
                }
            }

            return Ok(max_size);
        }

        if let Some(struct_def) = self.scope_stack.lookup_struct(type_name) {
            // Check if struct has size() method (associated function)
            // If it does, ideally we'd use TIL's implementation, but we need an instance
            let has_size = struct_def.get_member("size")
                .map(|decl| !decl.is_mut)
                .unwrap_or(false);

            if has_size {
                // TODO: Type has size() method - ideally call TIL's implementation
                // But get_type_size() asks for type's struct size (for field offsets),
                // while instance.size() returns data size (which varies per instance)
                // For now, fall through to calculate struct field size
                // Consider: should we even be using get_type_size for collection types?
            }

            // Fallback: Calculate size of struct's fields manually
            let mut total_size = 0;

            for (field_name, decl) in &struct_def.members {
                if !decl.is_mut {
                    continue;
                }

                let field_size = match &decl.value_type {
                    ValueType::TCustom(t) => {
                        self.get_type_size(t)?
                    }
                    _ => {
                        return Err(format!(
                            "get_type_size: unsupported value type '{}' in '{}.{}'",
                            value_type_to_str(&decl.value_type),
                            type_name,
                            field_name
                        ));
                    }
                };

                total_size += field_size;
            }

            Ok(total_size)
        } else {
            Err(format!("get_type_size: type '{}' not found in struct or enum defs", type_name))
        }
    }

    /// Calculate the offset of a specific field within a struct type
    /// This walks through the struct definition and sums up field sizes until reaching the target field
    pub fn calculate_field_offset(&self, struct_type: &str, field_name: &str) -> Result<usize, String> {
        let struct_def = self.scope_stack.lookup_struct(struct_type)
            .ok_or_else(|| format!("calculate_field_offset: struct '{}' not found", struct_type))?;

        let mut current_offset = 0;

        for (member_name, decl) in &struct_def.members {
            if !decl.is_mut {
                continue; // Skip immutable fields
            }

            // If we found the target field, return its offset
            if member_name == field_name {
                return Ok(current_offset);
            }

            // Otherwise, add this field's size and continue
            let field_size = match &decl.value_type {
                ValueType::TCustom(type_name) => self.get_type_size(type_name)?,
                _ => return Err(format!(
                    "calculate_field_offset: unsupported field type '{}' in '{}.{}'",
                    value_type_to_str(&decl.value_type), struct_type, member_name
                )),
            };

            current_offset += field_size;
        }

        Err(format!("calculate_field_offset: field '{}' not found in struct '{}'", field_name, struct_type))
    }

    /// Get the absolute arena offset for a field path (e.g., "my_vec._len")
    /// Handles nested field access by walking the path and calculating offsets dynamically
    pub fn get_field_offset(&self, field_path: &str) -> Result<usize, String> {
        let parts: Vec<&str> = field_path.split('.').collect();
        if parts.is_empty() {
            return Err(format!("get_field_offset: empty field path"));
        }

        // Start with the base variable's offset
        let base_var = parts[0];
        let mut current_offset = self.scope_stack.lookup_var(base_var)
            .ok_or_else(|| format!("get_field_offset: base variable '{}' not found in arena_index", base_var))?;

        // Get the base variable's type
        let mut current_type = match self.scope_stack.lookup_symbol(base_var) {
            Some(symbol) => match &symbol.value_type {
                ValueType::TCustom(type_name) => type_name.clone(),
                _ => return Err(format!("get_field_offset: base variable '{}' is not a struct", base_var)),
            },
            None => return Err(format!("get_field_offset: base variable '{}' not found in symbols", base_var)),
        };

        // Walk through the remaining parts of the path
        for field_name in &parts[1..] {
            // Calculate the offset of this field within the current struct type
            let field_offset = self.calculate_field_offset(&current_type, field_name)?;
            current_offset += field_offset;

            // Update current_type to the type of this field (for nested access)
            let struct_def = self.scope_stack.lookup_struct(&current_type)
                .ok_or_else(|| format!("get_field_offset: struct '{}' not found", current_type))?;

            let field_decl = struct_def.members.iter()
                .find(|(name, _)| name == field_name)
                .ok_or_else(|| format!("get_field_offset: field '{}' not found in struct '{}'", field_name, current_type))?;

            current_type = match &field_decl.1.value_type {
                ValueType::TCustom(type_name) => type_name.clone(),
                _ => {
                    // If this is the last part and it's a primitive, that's fine
                    if field_name == parts.last().unwrap() {
                        break;
                    }
                    return Err(format!("get_field_offset: field '{}' in '{}' is not a struct, cannot continue path", field_name, current_type));
                }
            };
        }

        Ok(current_offset)
    }

    pub fn insert_struct(&mut self, id: &str, custom_type_name: &str, e: &Expr) -> Result<(), String> {
        self.insert_struct_at_offset(id, custom_type_name, None, e)
    }

    fn insert_struct_at_offset(&mut self, id: &str, custom_type_name: &str, existing_offset: Option<usize>, e: &Expr) -> Result<(), String> {
        // Lookup the struct definition
        let struct_def = match self.scope_stack.lookup_struct(custom_type_name) {
            Some(struct_def_) => struct_def_.clone(),
            None => return Err(e.lang_error(&self.path, "context", &format!("insert_struct: definition for '{}' not found", custom_type_name))),
        };

        // Determine mutability from symbols table
        let is_mut = match self.scope_stack.lookup_symbol(id) {
            Some(symbol_info_) => symbol_info_.is_mut,
            None => return Err(e.lang_error(&self.path, "context", &format!("insert_struct: id '{}' for struct '{}' not found in symbols", id, custom_type_name))),
        };

        // Calculate total size (for now no alignment)
        let mut total_size = 0;
        let mut field_offsets = HashMap::new();

        for (member_name, decl) in struct_def.members.iter() {
            if !decl.is_mut {
                continue;
            }

            let field_size = match &decl.value_type {
                ValueType::TCustom(type_name) => self.get_type_size(type_name)?,
                _ => return Err(e.lang_error(&self.path, "context", "insert_struct: Unsupported value type in struct")),
            };

            field_offsets.insert(member_name.clone(), total_size);
            total_size += field_size;
        }

        // Either use existing offset (for nested structs) or allocate new memory
        let offset = match existing_offset {
            Some(off) => off,
            None => {
                let off = Arena::g().memory.len();
                Arena::g().memory.resize(off + total_size, 0);
                off
            }
        };
        self.scope_stack.insert_var(id.to_string(), offset);

        // Store each field's default value
        for (member_name, decl) in struct_def.members.iter() {
            if !decl.is_mut {
                continue;
            }

            let field_offset = match field_offsets.get(member_name) {
                Some(offset) => offset,
                None => return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Missing field offset for '{}'", member_name))),
            };

            let default_expr = struct_def.default_values.get(member_name);
            let default_value = match default_expr {
                Some(e2) => {
                    let res = eval_expr(self, e2)?;
                    if res.is_throw {
                        return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Thrown '{}' while evaluating default value for field '{}'", res.thrown_type.unwrap_or_default(), member_name)));
                    }
                    res.value
                },
                None => return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Missing default value for field '{}'", member_name))),
            };

            match &decl.value_type {
                ValueType::TCustom(type_name) => {
                    if let Some(enum_def) = self.scope_stack.lookup_enum(type_name) {
                        let parts: Vec<&str> = default_value.split('.').collect();
                        if parts.len() != 2 || parts[0] != type_name {
                            return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Invalid enum default value '{}' for field '{}'", default_value, member_name)));
                        }
                        let variant = parts[1];
                        let index = match enum_def.enum_map.keys().position(|v| v == variant) {
                            Some(i) => i as i64,
                            None => return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Unknown enum variant '{}' for field '{}'", variant, member_name))),
                        };
                        Arena::g().memory[offset + field_offset..offset + field_offset + 8]
                            .copy_from_slice(&index.to_ne_bytes());
                    } else {
                        match type_name.as_str() {
                            "U8" => {
                                let v = default_value.parse::<u8>().map_err(|_| {
                                    e.lang_error(&self.path, "context", &format!("insert_struct: Invalid U8 default value '{}' for field '{}'", default_value, member_name))
                                })?;
                                Arena::g().memory[offset + field_offset] = v;
                            },
                            "I64" => {
                                let v = default_value.parse::<i64>().map_err(|_| {
                                    e.lang_error(&self.path, "context", &format!("insert_struct: Invalid I64 default value '{}' for field '{}'", default_value, member_name))
                                })?;
                                Arena::g().memory[offset + field_offset..offset + field_offset + 8]
                                    .copy_from_slice(&v.to_ne_bytes());
                            },
                            _ => {
                                if self.scope_stack.lookup_struct(type_name).is_some() {
                                    let combined_name = format!("{}.{}", id, member_name);
                                    self.scope_stack.declare_symbol(
                                        combined_name.clone(),
                                        SymbolInfo {
                                            value_type: ValueType::TCustom(type_name.clone()),
                                            is_mut: true,
                                            is_copy: false,
                                            is_own: false,
                                        },
                                    );
                                    self.scope_stack.frames.last_mut().unwrap().arena_index.insert(combined_name.clone(), offset + field_offset);

                                    // Special case: Str initialization with string literal
                                    if type_name == "Str" {
                                        self.insert_string(&combined_name, &default_value, e)?;
                                    } else {
                                        // Use existing offset for nested struct (inline allocation)
                                        self.insert_struct_at_offset(&combined_name, type_name, Some(offset + field_offset), e)
                                            .map_err(|_| e.lang_error(&self.path, "context", &format!("insert_struct: Failed to initialize nested struct '{}.{}'", id, member_name)))?;
                                    }
                                } else {
                                    return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Unknown field type '{}'", type_name)));
                                }
                            },
                        }
                    }
                },
                _ => {
                    return Err(e.lang_error(&self.path, "context", &format!("insert_struct: Unsupported field value type '{}'", value_type_to_str(&decl.value_type))));
                }
            }

            let combined_name = format!("{}.{}", id, member_name);
            let field_arena_offset = offset + field_offset;
            self.scope_stack.frames.last_mut().unwrap().arena_index.insert(combined_name.clone(), field_arena_offset);
            self.scope_stack.declare_symbol(
                combined_name,
                SymbolInfo {
                    value_type: decl.value_type.clone(),
                    is_mut,
                    is_copy: false,
                    is_own: false,
                },
            );
        }

        // Map immutable fields by copying arena_index entries from the type to the instance
        for (_member_name, decl) in struct_def.members.iter() {
            if decl.is_mut {
                continue; // Skip mutable fields (already handled above)
            }

            // Immutable struct fields are handled generically through struct_defs
            // No special cases needed anymore
        }

        Ok(())
    }

    // Register struct field symbols for type checking without evaluating defaults or allocating memory
    // This allows type checking of struct method bodies without triggering evaluation errors
    pub fn register_struct_fields_for_typecheck(&mut self, instance_name: &str, struct_type_name: &str) {
        // Get instance mutability from symbols
        let instance_is_mut = self.scope_stack.lookup_symbol(instance_name)
            .map(|info| info.is_mut || info.is_copy || info.is_own)
            .unwrap_or(false);

        if let Some(struct_def) = self.scope_stack.lookup_struct(struct_type_name).cloned() {
            for (member_name, decl) in &struct_def.members {
                let combined_name = format!("{}.{}", instance_name, member_name);
                // Field inherits mutability from instance (if instance is const, fields are const too)
                let field_is_mut = instance_is_mut && decl.is_mut;

                self.scope_stack.declare_symbol(
                    combined_name.clone(),
                    SymbolInfo {
                        value_type: decl.value_type.clone(),
                        is_mut: field_is_mut,
                        is_copy: decl.is_copy,
                        is_own: decl.is_own,
                    },
                );

                // Recursively register nested struct fields
                if let ValueType::TCustom(ref nested_type) = decl.value_type {
                    if self.scope_stack.lookup_struct(nested_type).is_some() {
                        self.register_struct_fields_for_typecheck(&combined_name, nested_type);
                    }
                }
            }
        }
    }

    pub fn insert_string(self: &mut Context, id: &str, value_str: &String, e: &Expr) -> Result<(), String> {
        let is_field = if id.contains('.') {
            let parts: Vec<&str> = id.split('.').collect();
            let base = parts[0];
            self.scope_stack.lookup_symbol(base).map_or(false, |sym| {
                !matches!(&sym.value_type, ValueType::TType(_))
            })
        } else {
            false
        };

        // Allocate string data
        let string_offset = Arena::g().memory.len();
        Arena::g().memory.extend_from_slice(value_str.as_bytes());
        Arena::g().memory.push(0); // null terminator
        let string_offset_bytes = (string_offset as i64).to_ne_bytes();
        let len_bytes = (value_str.len() as i64).to_ne_bytes();

        if is_field {
            if let Some(base_offset) = self.scope_stack.lookup_var(id) {
                if let Some(str_def) = self.scope_stack.lookup_struct("Str") {
                    let members = str_def.members.clone();
                    let mut current_offset = 0;

                    for (member_name, decl) in members.iter() {
                        if !decl.is_mut {
                            continue;
                        }

                        let type_size = self.get_type_size(&value_type_to_str(&decl.value_type))?;
                        let absolute_offset = base_offset + current_offset;
                        let target_slice = &mut Arena::g().memory[absolute_offset..absolute_offset + type_size];

                        if member_name == "c_string" {
                            target_slice.copy_from_slice(&string_offset_bytes);
                        } else if member_name == "cap" {
                            target_slice.copy_from_slice(&len_bytes);
                        }

                        self.scope_stack.frames.last_mut().unwrap().arena_index.insert(format!("{}.{}", id, member_name), absolute_offset);
                        current_offset += type_size;
                    }
                    return Ok(())
                }
                return Err(e.lang_error(&self.path, "context", "ERROR: 'Str' struct definition not found"))
            }

            // Not yet inserted  insert fresh inlined Str
            if let Some(str_def) = self.scope_stack.lookup_struct("Str") {
                let members = str_def.members.clone();
                let struct_offset = Arena::g().memory.len();
                let mut current_offset = 0;

                for (member_name, decl) in members.iter() {
                    if !decl.is_mut {
                        continue;
                    }

                    let type_size = self.get_type_size(&value_type_to_str(&decl.value_type))?;
                    if Arena::g().memory.len() < struct_offset + current_offset + type_size {
                        Arena::g().memory.resize(struct_offset + current_offset + type_size, 0);
                    }

                    let field_slice = &mut Arena::g().memory[struct_offset + current_offset..struct_offset + current_offset + type_size];
                    if member_name == "c_string" {
                        field_slice.copy_from_slice(&string_offset_bytes);
                    } else if member_name == "cap" {
                        field_slice.copy_from_slice(&len_bytes);
                    }

                    self.scope_stack.frames.last_mut().unwrap().arena_index.insert(format!("{}.{}", id, member_name), struct_offset + current_offset);
                    current_offset += type_size;
                }

                self.scope_stack.frames.last_mut().unwrap().arena_index.insert(id.to_string(), struct_offset);
                return Ok(())
            }
            return Err(e.lang_error(&self.path, "context", "'Str' struct definition not found"))
        }

        self.insert_struct(id, "Str", e)?;
        let c_string_offset = match self.scope_stack.lookup_var(&format!("{}.c_string", id)) {
            Some(offset) => offset,
            None => {
                return Err(e.lang_error(&self.path, "context", &format!("insert_string: missing '{}.c_string'", id)))
            }
        };
        let cap_offset = match self.scope_stack.lookup_var(&format!("{}.cap", id)) {
            Some(offset) => offset,
            None => {
                return Err(e.lang_error(&self.path, "context", &format!("insert_string: missing '{}.cap'", id)))
            }
        };

        Arena::g().memory[c_string_offset..c_string_offset + 8].copy_from_slice(&string_offset_bytes);
        Arena::g().memory[cap_offset..cap_offset + 8].copy_from_slice(&len_bytes);

        return Ok(())
    }

    /// Helper function to insert primitive types (I64, U8, Bool, Str) based on value_type
    pub fn insert_primitive(
        &mut self,
        var_name: &str,
        value_type: &ValueType,
        value: &str,
        e: &Expr
    ) -> Result<(), String> {
        match value_type {
            ValueType::TCustom(type_name) if type_name == "I64" => {
                self.insert_i64(var_name, &value.to_string(), e)
            },
            ValueType::TCustom(type_name) if type_name == "U8" => {
                self.insert_u8(var_name, &value.to_string(), e)
            },
            // TODO FIX: Bool special case for insert_primitive - needed for bootstrap and primitives handling
            ValueType::TCustom(type_name) if type_name == "Bool" => {
                insert_bool(self, var_name, &value.to_string(), e)
            },
            ValueType::TCustom(type_name) if type_name == "Str" => {
                self.insert_string(var_name, &value.to_string(), e)
            },
            _ => Err(e.lang_error(&self.path, "eval", &format!("insert_primitive: Unsupported type {:?}", value_type)))
        }
    }

    pub fn get_enum_at_offset(&self, enum_type: &str, offset: usize, e: &Expr) -> Result<EnumVal, String> {
        // Read enum from a specific offset (used for nested enum payloads)
        let enum_value_bytes = &Arena::g().memory[offset..offset + 8];
        let enum_value = i64::from_le_bytes(enum_value_bytes.try_into()
                                            .map_err(|_| e.lang_error(&self.path, "context", "get_enum_at_offset: Failed to convert bytes to i64"))?);

        let enum_def = self.scope_stack.lookup_enum(enum_type)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("get_enum_at_offset: Enum definition for '{}' not found", enum_type)))?;

        let enum_name = Context::variant_pos_to_str(enum_def, enum_value, &self.path, e)?;

        // Check if this variant has a payload type
        let variant_payload_type = enum_def.enum_map.get(&enum_name);
        let (payload_data, payload_type) = match variant_payload_type {
            Some(Some(vtype)) => {
                // This variant has a payload - recursively determine size
                let payload_size = self.get_payload_size_for_type(vtype, offset + 8, e)?;
                if payload_size > 0 {
                    let payload_offset = offset + 8;
                    let payload_end = payload_offset + payload_size;
                    if payload_end <= Arena::g().memory.len() {
                        let payload_bytes = Arena::g().memory[payload_offset..payload_end].to_vec();
                        (Some(payload_bytes), Some(vtype.clone()))
                    } else {
                        (None, None)
                    }
                } else {
                    (None, None)
                }
            },
            _ => (None, None),
        };

        Ok(EnumVal {
            enum_type: enum_type.to_string(),
            enum_name,
            payload: payload_data,
            payload_type,
        })
    }

    pub fn get_payload_size_for_type(&self, vtype: &ValueType, offset: usize, e: &Expr) -> Result<usize, String> {
        match vtype {
            ValueType::TCustom(type_name) if type_name == "I64" => Ok(8),
            ValueType::TCustom(type_name) => {
                match self.scope_stack.lookup_symbol(type_name) {
                    Some(type_symbol) => {
                        match &type_symbol.value_type {
                            ValueType::TType(TTypeDef::TStructDef) => {
                                self.get_type_size(type_name).map_err(|e| e.to_string())
                            },
                            ValueType::TType(TTypeDef::TEnumDef) => {
                                // Recursively get the inner enum's size
                                let inner_enum = self.get_enum_at_offset(type_name, offset, e)?;
                                let mut total_size = 8; // variant tag
                                if let Some(inner_payload) = &inner_enum.payload {
                                    total_size += inner_payload.len();
                                }
                                Ok(total_size)
                            },
                            _ => Ok(0),
                        }
                    },
                    None => Ok(0),
                }
            },
            _ => Ok(0),
        }
    }

    pub fn get_enum(&self, id: &str, e: &Expr) -> Result<EnumVal, String> {
        let symbol_info = self.scope_stack.lookup_symbol(id)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("get_enum: Symbol '{}' not found", id)))?;

        let enum_type = match &symbol_info.value_type {
            ValueType::TCustom(custom_type_name) => custom_type_name,
            _ => return Err(e.lang_error(&self.path, "context", &format!("get_enum: '{}' is not a custom enum type", id))),
        };

        let offset = self.scope_stack.lookup_var(id)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("get_enum: Arena index for '{}' not found", id)))?;

        let enum_value_bytes = &Arena::g().memory[offset..offset + 8];
        let enum_value = i64::from_le_bytes(enum_value_bytes.try_into()
                                            .map_err(|_| e.lang_error(&self.path, "context", &format!("get_enum: Failed to convert bytes to i64 for '{}'", id)))?);

        let enum_def = self.scope_stack.lookup_enum(enum_type)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("get_enum: Enum definition for '{}' not found", enum_type)))?;

        let enum_name = Context::variant_pos_to_str(enum_def, enum_value, &self.path, e)?;

        // Check if this variant has a payload type
        let variant_payload_type = enum_def.enum_map.get(&enum_name);
        let (payload_data, payload_type) = match variant_payload_type {
            Some(Some(vtype)) => {
                // This variant has a payload, read it from arena
                // TODO FIX: Bool payload size hardcoded to 1 byte - should get from struct definition
                let payload_size = match vtype {
                    ValueType::TCustom(type_name) if type_name == "Bool" => 1,
                    ValueType::TCustom(type_name) if type_name == "I64" => 8,
                    ValueType::TCustom(type_name) if type_name == "Str" => {
                        16  // Str is always 16 bytes (pointer + size)
                    },
                    ValueType::TCustom(type_name) => {
                        // Check if this is a struct or enum type
                        match self.scope_stack.lookup_symbol(type_name) {
                            Some(type_symbol) => {
                                match &type_symbol.value_type {
                                    ValueType::TType(TTypeDef::TStructDef) => {
                                        // Get struct size
                                        self.get_type_size(type_name).unwrap_or(0)
                                    },
                                    ValueType::TType(TTypeDef::TEnumDef) => {
                                        // For enum payloads, recursively get the enum to determine size
                                        let inner_enum = self.get_enum_at_offset(type_name, offset + 8, e)?;
                                        // Size is: 8 bytes (tag) + payload bytes
                                        let mut total_size = 8;
                                        if let Some(inner_payload) = &inner_enum.payload {
                                            total_size += inner_payload.len();
                                        }
                                        total_size
                                    },
                                    _ => 0,
                                }
                            },
                            None => 0,
                        }
                    },
                    _ => 0,
                };
                if payload_size > 0 {
                    let payload_offset = offset + 8;
                    let payload_end = payload_offset + payload_size;
                    if payload_end <= Arena::g().memory.len() {
                        let payload_bytes = Arena::g().memory[payload_offset..payload_end].to_vec();
                        (Some(payload_bytes), Some(vtype.clone()))
                    } else {
                        (None, None)
                    }
                } else {
                    (None, None)
                }
            },
            _ => (None, None),
        };

        Ok(EnumVal {
            enum_type: enum_type.to_string(),
            enum_name,
            payload: payload_data,
            payload_type,
        })
    }

    // TODO Context.insert_enum gets an Expr for errors, any Context method that can throw should too
    pub fn insert_enum(&mut self, id: &str, enum_type: &str, pre_normalized_enum_name: &str, e: &Expr) -> Result<EnumVal, String> {
        let enum_def = self.scope_stack.lookup_enum(enum_type)
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("insert_enum: Enum definition for '{}' not found", enum_type)))?;

        let enum_name = pre_normalized_enum_name.split('.').last()
            .ok_or_else(|| e.lang_error(&self.path, "context", &format!("insert_enum: Invalid enum name format '{}'", pre_normalized_enum_name)))?;

        let enum_value = Context::get_variant_pos(enum_def, enum_name, &self.path, e)?;

        // Check if there's payload data to store
        let (payload_data, payload_type) = match &self.temp_enum_payload {
            Some((data, vtype)) => (Some(data.clone()), Some(vtype.clone())),
            None => (None, None),
        };

        let is_field = id.contains('.');
        if is_field {
            if let Some(offset) = self.scope_stack.lookup_var(id) {
                // Update existing enum value
                Arena::g().memory[offset..offset + 8].copy_from_slice(&enum_value.to_le_bytes());
                // Store payload if present
                if let Some(payload_bytes) = &payload_data {
                    let payload_offset = offset + 8;
                    let payload_end = payload_offset + payload_bytes.len();
                    // Ensure arena has enough space
                    if Arena::g().memory.len() < payload_end {
                        Arena::g().memory.resize(payload_end, 0);
                    }
                    Arena::g().memory[payload_offset..payload_end].copy_from_slice(&payload_bytes);
                }
            } else {
                let offset = Arena::g().memory.len();
                Arena::g().memory.extend_from_slice(&enum_value.to_le_bytes());
                // Store payload if present
                if let Some(payload_bytes) = &payload_data {
                    Arena::g().memory.extend_from_slice(&payload_bytes);
                }
                self.scope_stack.frames.last_mut().unwrap().arena_index.insert(id.to_string(), offset);
            }
        } else {
            let offset = Arena::g().memory.len();
            Arena::g().memory.extend_from_slice(&enum_value.to_le_bytes());
            // Store payload if present
            if let Some(payload_bytes) = &payload_data {
                Arena::g().memory.extend_from_slice(&payload_bytes);
            }
            self.scope_stack.frames.last_mut().unwrap().arena_index.insert(id.to_string(), offset);
        }

        // Clear the temp payload after using it
        self.temp_enum_payload = None;

        Ok(EnumVal {
            enum_type: enum_type.to_string(),
            enum_name: enum_name.to_string(),
            payload: payload_data,
            payload_type,
        })
    }

    pub fn insert_array(&mut self, name: &str, elem_type: &str, values: &Vec<String>, e: &Expr) -> Result<(), String> {
        // All array types now use the generic Array
        let array_type = "Array".to_string();

        self.insert_struct(name, &array_type, e)?;

        let len = values.len() as i64;
        let elem_size = match self.get_type_size(elem_type) {
            Ok(sz) => sz,
            Err(err) => return Err(e.lang_error(&self.path, "context", &err)),
        };
        let total_size = (len as usize) * elem_size;

        // Allocate memory
        let ptr = Arena::g().memory.len();
        Arena::g().memory.resize(ptr + total_size, 0);

        // Write values into allocated buffer
        for (i, val) in values.iter().enumerate() {
            let offset = ptr + i * elem_size;
            // TODO FIX: Bool can't be removed yet - array initialization needs to parse "true"/"false" strings
            match elem_type {
                "Bool" => {
                    let stored = if val.as_str() == "true" { 1 } else { 0 };
                    Arena::g().memory[offset] = stored;
                },
                "U8" => {
                    match val.parse::<u8>() {
                        Ok(byte) => Arena::g().memory[offset] = byte,
                        Err(err) => return Err(e.lang_error(&self.path, "context", &format!("ERROR: insert_array: invalid U8 '{}'", &err)))
                    }
                },
                "I64" => {
                    match val.parse::<i64>() {
                        Ok(n) => {
                            let bytes = n.to_ne_bytes();
                            Arena::g().memory[offset..offset+8].copy_from_slice(&bytes);
                        },
                        Err(err) => return Err(e.lang_error(&self.path, "context", &format!("ERROR: insert_array: invalid I64 '{}'", &err)))
                    }
                },
                "Str" => {
                    for (i, val) in values.iter().enumerate() {
                        let offset = ptr + i * elem_size;

                        let temp_id = format!("{}_{}", name, i);
                        self.scope_stack.declare_symbol(temp_id.clone(), SymbolInfo {
                            value_type: ValueType::TCustom("Str".to_string()),
                            is_mut: false,
                            is_copy: false,
                            is_own: false,
                        });

                        self.insert_string(&temp_id, val, e)?;

                        let str_offset = match self.scope_stack.lookup_var(&temp_id) {
                            Some(off) => off,
                            None => return Err(e.lang_error(&self.path, "context", &format!("ERROR: insert_array: missing arena offset for '{}'", temp_id))),
                        };
                        Arena::g().memory[offset..offset + elem_size]
                            .copy_from_slice(&Arena::g().memory[str_offset..str_offset + elem_size]);
                    }
                }

                _ => {
                    return Err(e.lang_error(&self.path, "context", &format!("insert_array: unsupported element type '{}'", elem_type)))
                }
            }
        }

        // Write ptr, len (and cap for Vec) using calculated offsets
        let ptr_field_path = format!("{}.ptr", name);
        let ptr_offset = if let Some(offset) = self.scope_stack.lookup_var(&ptr_field_path) {
            offset
        } else {
            self.get_field_offset(&ptr_field_path).map_err(|err| {
                e.lang_error(&self.path, "context", &format!("insert_array: {}", err))
            })?
        };
        Arena::g().memory[ptr_offset..ptr_offset+8].copy_from_slice(&(ptr as i64).to_ne_bytes());

        // Set _len field (required for both Array and Vec)
        let len_bytes = len.to_ne_bytes();
        let len_field_path = format!("{}._len", name);
        let len_offset = if let Some(offset) = self.scope_stack.lookup_var(&len_field_path) {
            offset
        } else {
            self.get_field_offset(&len_field_path).map_err(|err| {
                e.lang_error(&self.path, "context", &format!("insert_array: {}", err))
            })?
        };
        Arena::g().memory[len_offset..len_offset+8].copy_from_slice(&len_bytes);

        // Set cap field (only exists in Vec, not in Array)
        let cap_field_path = format!("{}.cap", name);
        if let Ok(cap_offset) = self.get_field_offset(&cap_field_path) {
            Arena::g().memory[cap_offset..cap_offset+8].copy_from_slice(&len_bytes);
        } else if let Some(cap_offset) = self.scope_stack.lookup_var(&cap_field_path) {
            Arena::g().memory[cap_offset..cap_offset+8].copy_from_slice(&len_bytes);
        }

        // For generic Array, also set type_name and type_size fields
        if array_type == "Array" {
            // Set type_name field (it's a Str, so we need to store it properly)
            let type_name_offset_opt = self.scope_stack.lookup_var(&format!("{}.type_name", name));
            if let Some(type_name_offset) = type_name_offset_opt {
                let temp_id = format!("{}_type_name_temp", name);
                self.scope_stack.declare_symbol(temp_id.clone(), SymbolInfo {
                    value_type: ValueType::TCustom("Str".to_string()),
                    is_mut: false,
                    is_copy: false,
                    is_own: false,
                });
                self.insert_string(&temp_id, &elem_type.to_string(), e)?;
                if let Some(str_offset) = self.scope_stack.lookup_var(&temp_id) {
                    let str_size = self.get_type_size("Str")?;
                    Arena::g().memory[type_name_offset..type_name_offset + str_size]
                        .copy_from_slice(&Arena::g().memory[str_offset..str_offset + str_size]);
                }
            }

            // Set type_size field
            if let Some(type_size_offset) = self.scope_stack.lookup_var(&format!("{}.type_size", name)) {
                let size_bytes = (elem_size as i64).to_ne_bytes();
                Arena::g().memory[type_size_offset..type_size_offset + 8].copy_from_slice(&size_bytes);
            }
        }

        Ok(())
    }

}

// Helper function to insert a Bool value using insert_struct
pub fn insert_bool(context: &mut Context, id: &str, bool_str: &String, e: &Expr) -> Result<(), String> {
    // Parse the bool value
    let bool_to_insert = bool_str.parse::<bool>()
        .map_err(|_| e.lang_error(&context.path, "context", &format!("Invalid bool literal '{}'", bool_str)))?;
    let stored = if bool_to_insert { 1 } else { 0 };

    // Check if this is an assignment to an existing instance field
    let is_instance_field = if id.contains('.') {
        let parts: Vec<&str> = id.split('.').collect();
        let base = parts[0];
        context.scope_stack.lookup_symbol(base).map_or(false, |sym| {
            !matches!(&sym.value_type, ValueType::TType(_))
        })
    } else {
        false
    };

    if is_instance_field {
        // For instance field, write directly to the .data field
        let field_id = format!("{}.data", id);
        let offset = context.scope_stack.lookup_var(&field_id)
            .ok_or_else(|| e.lang_error(&context.path, "context", &format!("Bool field '{}.data' not found", id)))?;
        Arena::g().memory[offset] = stored;
    } else {
        // For new variable, create the struct and set value
        context.insert_struct(id, "Bool", e)?;
        let field_id = format!("{}.data", id);
        let offset = context.scope_stack.lookup_var(&field_id)
            .ok_or_else(|| e.lang_error(&context.path, "context", &format!("Bool field '{}.data' not found", id)))?;
        Arena::g().memory[offset] = stored;
    }

    Ok(())
}
