mode lib

import("src.core.self.parser")

// Init phase: Declaration indexing and import processing
// This module handles the "context priming" phase that runs before type checking.
// No eval, no arena access - declarations only.
//
// Translated from src/rs/init.rs

#[derive(Clone)]
SymbolInfo := struct {
    mut value_type: ValueType = ValueType.TFunction
    mut is_mut: Bool = false
    mut is_copy: Bool = false
    mut is_own: Bool = false
}

#[derive(Debug, Clone, PartialEq)]
EnumVal := struct {
    mut enum_type: Str = ""
    mut enum_name: Str = ""
    // Payload for tagged unions: stores the associated data
    // For now, supports Bool (1 byte) and I64 (8 bytes)
    mut payload: Option = Option.None  // Option<Vec<u8>>
    mut payload_type: Option = Option.None  // Option<ValueType>
}

// Scope stack for proper lexical scoping
#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
ScopeType := enum {
    Global      // Top-level module scope
    Function    // Function body
    Block       // Generic block (if, else, loop body)
    Catch       // Catch block (for error handling)
}

#[derive(Clone)]
#[allow(dead_code)]
ScopeFrame := struct {
    // maps variable names to their offsets in the arena
    mut arena_index: Map = Map.new(Str, I64)  // HashMap<String, usize> in Rust

    // All declared symbols (types, constants, variables, and function names)
    // This is necessary for so called "context priming" or "declaration indexing"
    // aka declaring things in whatever order, aka not needing forward declarations
    // in theory it should only be needed for the "type" phase after the init context phase
    // but it can be convenient at times in eval or compile phases too, I guess.
    mut symbols: Map = Map.new(Str, SymbolInfo)

    // All functions, with their function types, signatures and bodies (functions, methods, macros, etc).
    mut funcs: Map = Map.new(Str, SFuncDef)

    // Enum type definitions (variants and associated data)
    mut enums: Map = Map.new(Str, SEnumDef)

    // Struct type definitions (fields and associated constants [including functions, structs are namespaces, almost])
    mut structs: Map = Map.new(Str, SStructDef)

    // Scope type (helps with cleanup and debugging)
    mut scope_type: ScopeType = ScopeType.Global
}

#[derive(Clone)]
ScopeStack := struct {
    // Stack of scope frames
    mut frames: Vec = Vec.new(ScopeFrame)

    new := func() returns ScopeStack {
        mut stack := ScopeStack()
        stack.frames = Vec.new(ScopeFrame)
        return stack
    }

    push := proc(mut self: ScopeStack, scope_type: ScopeType) throws AllocError {
        mut frame := ScopeFrame()
        frame.arena_index = Map.new(Str, I64)
        frame.symbols = Map.new(Str, SymbolInfo)
        frame.funcs = Map.new(Str, SFuncDef)
        frame.enums = Map.new(Str, SEnumDef)
        frame.structs = Map.new(Str, SStructDef)
        frame.scope_type = scope_type
        self.frames.push(frame)
    }

    pop := proc(mut self: ScopeStack) returns Result throws Str {
        if lteq(self.frames.len, 1) {
            return Result.Err("Cannot pop global scope")
        }

        if eq(self.frames.len, 0) {
            return Result.Err("Scope stack underflow")
        }

        // Pop the last frame
        mut new_len := sub(self.frames.len, 1)
        mut popped := ScopeFrame()
        self.frames.get(new_len, popped)
        self.frames._len = new_len
        return Result.Ok(popped)
    }

    lookup_var := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        // Walk up the stack from innermost to outermost
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.arena_index.contains_key(name) {
                mut offset_str := frame.arena_index.get(name)
                return Option.Some(offset_str)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    lookup_symbol := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.symbols.contains_key(name) {
                mut sym := frame.symbols.get(name)
                return Option.Some(sym)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_var := proc(mut self: ScopeStack, name: Str, offset: I64, symbol: SymbolInfo) returns Result throws Str, IndexOutOfBoundsError {
        if eq(self.frames.len, 0) {
            return Result.Err("No active scope")
        }

        mut last_idx := sub(self.frames.len, 1)
        mut current_frame := ScopeFrame()
        self.frames.get(last_idx, current_frame)

        // Check for redeclaration in current scope only
        if current_frame.arena_index.contains_key(name) {
            return Result.Err(format("Variable '", name, "' already declared in this scope"))
        }

        current_frame.arena_index.insert(name, offset.to_str())
        current_frame.symbols.insert(name, symbol)
        self.frames.set(last_idx, current_frame)
        return Result.Ok("")
    }

    declare_symbol := proc(mut self: ScopeStack, name: Str, symbol: SymbolInfo) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.symbols.insert(name, symbol)
            self.frames.set(last_idx, current_frame)
        }
    }

    remove_symbol := proc(mut self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.symbols.contains_key(name) {
                mut sym := current_frame.symbols.get(name)
                current_frame.symbols.remove(name)
                self.frames.set(last_idx, current_frame)
                return Option.Some(sym)
            }
        }
        return Option.None
    }

    remove_var := proc(mut self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            if current_frame.arena_index.contains_key(name) {
                mut offset_str := current_frame.arena_index.get(name)
                current_frame.arena_index.remove(name)
                self.frames.set(last_idx, current_frame)
                return Option.Some(offset_str)
            }
        }
        return Option.None
    }

    // Insert a variable without a corresponding symbol (simpler than declare_var)
    insert_var := proc(mut self: ScopeStack, name: Str, offset: I64) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.arena_index.insert(name, offset.to_str())
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_func := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.funcs.contains_key(name) {
                mut func_def := frame.funcs.get(name)
                return Option.Some(func_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_func := proc(mut self: ScopeStack, name: Str, func_def: SFuncDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.funcs.insert(name, func_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_enum := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.enums.contains_key(name) {
                mut enum_def := frame.enums.get(name)
                return Option.Some(enum_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_enum := proc(mut self: ScopeStack, name: Str, enum_def: SEnumDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.enums.insert(name, enum_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    lookup_struct := func(self: ScopeStack, name: Str) returns Option throws IndexOutOfBoundsError {
        mut i := sub(self.frames.len, 1)
        while gteq(i, 0) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            if frame.structs.contains_key(name) {
                mut struct_def := frame.structs.get(name)
                return Option.Some(struct_def)
            }
            i = sub(i, 1)
        }
        return Option.None
    }

    declare_struct := proc(mut self: ScopeStack, name: Str, struct_def: SStructDef) throws IndexOutOfBoundsError {
        if gt(self.frames.len, 0) {
            mut last_idx := sub(self.frames.len, 1)
            mut current_frame := ScopeFrame()
            self.frames.get(last_idx, current_frame)
            current_frame.structs.insert(name, struct_def)
            self.frames.set(last_idx, current_frame)
        }
    }

    get_symbols_with_prefix := func(self: ScopeStack, prefix: Str) returns Vec throws IndexOutOfBoundsError {
        // Collect all keys from all scopes that start with the given prefix
        mut keys := Vec.new(Str)
        mut i := 0
        while lt(i, self.frames.len) {
            mut frame := ScopeFrame()
            self.frames.get(i, frame)
            mut symbol_keys := frame.symbols.keys
            mut j := 0
            while lt(j, symbol_keys.len) {
                mut key := ""
                symbol_keys.get(j, key)
                if key.starts_with(prefix) {
                    keys.push(key)
                }
                j = add(j, 1)
            }
            i = add(i, 1)
        }
        return keys
    }
}

get_func_name_in_call := func(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw e.exit_error("type", "get_func_name_in_call(): expected fcall node.")
    }
    if eq(e.params.len, 0) {
        throw e.exit_error("type", "get_func_name_in_call(): fcall nodes must have at least 1 parameter.")
    }
    mut param := Expr()
    e.params.get(0, param)
    mut func_name := ""
    switch param.node_type {
    case NodeType.Identifier(f_name):
        func_name = f_name
    case node_type:
        throw e.exit_error("type", format("in get_func_name_in_call(): Identifiers can only contain identifiers, found '", enum_to_str(node_type), "'"))
    }
    return func_name
}

value_type_func_proc := func(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str, IndexOutOfBoundsError {
    mut returns_len := func_def.return_types.len
    if eq(returns_len, 0) {
        throw e.error(path, "type", format("func '", name, "' does not return anything"))
    }
    if eq(returns_len, 1) {
        mut return_type := ValueType.TCustom("")
        func_def.return_types.get(0, return_type)
        switch return_type {
        case ValueType.TCustom(type_str):
            return ValueType.TCustom(type_str)
        case other:
            throw e.error(path, "type", format("func '", name, "' returns unsupported type ", value_type_to_str(other)))
        }
    }
    throw e.todo_error(path, "type", format("func '", name, "' returns multiple values"))
}

// TODO: Translate get_ufcs_fcall_value_type (lines 267-309)
// TODO: Translate get_fcall_value_type (lines 311-628)
// TODO: Translate get_value_type (lines 630-719)
// TODO: Translate import_path_to_file_path (lines 721-726)
// TODO: Translate init_import_declarations (lines 728-850)
// TODO: Translate init_context (lines 852-1019)

#[derive(Clone)]
Context := struct {
    mut mode: ModeDef = ModeDef()  // All contexts need a mode
    // TODO use Context.path to properly report eval errors, or...no, don't refactor the whole eval phase to return Result<String, String>
    mut path: Str = ""  // this is needed for core func "loc"
    // Scope stack for proper lexical scoping
    mut scope_stack: ScopeStack = ScopeStack.new()
    // Temporary storage for enum payload data during construction
    mut temp_enum_payload: Option = Option.None  // Option<(Vec<u8>, ValueType)>
    // Two-phase imports: separate caches for declaration and value initialization
    mut imports_declarations_done: Set = Set.new(Str)  // tracks which imports have had declarations copied (init phase)
    mut imports_values_done: Map = Map.new(Str, Result)  // tracks which imports have had values initialized (eval phase)
    mut imports_wip: Set = Set.new(Str)  // wip imports (for cycle detection)
    // DEPRECATED: old single-phase cache, kept for compatibility
    #[allow(dead_code)]
    mut imports_done: Map = Map.new(Str, Result)
    // REM: A hashmap for in the future return a struct (namespace) so that it can be assigned to a constant/var
    // REM: This would enable: std := import("src/core/std") and then std.panic(), std.format(), etc.
    // REM: TODO change the cached type to support import as returning a struct_def

    new := func(path: Str, mode_name: Str) returns Context throws Str, AllocError {
        mut ctx := Context()
        mut scope_stack := ScopeStack.new()
        scope_stack.push(ScopeType.Global)  // Initialize global scope
        ctx.path = path
        ctx.mode = mode_from_name(mode_name)
        ctx.scope_stack = scope_stack
        ctx.temp_enum_payload = Option.None
        ctx.imports_declarations_done = Set.new(Str)
        ctx.imports_values_done = Map.new(Str, Result)
        ctx.imports_wip = Set.new(Str)
        ctx.imports_done = Map.new(Str, Result)  // DEPRECATED
        return ctx
    }

    // TODO: Translate all Context methods (lines 1041-2207)
    // Including:
    // - get_u8, insert_u8
    // - get_i64, insert_i64
    // - get_struct, insert_struct, insert_struct_at_offset
    // - map_instance_fields, copy_fields
    // - get_type_size, calculate_field_offset, get_field_offset
    // - register_struct_fields_for_typecheck
    // - insert_string
    // - insert_primitive
    // - get_enum_at_offset, get_payload_size_for_type
    // - get_enum, insert_enum
    // - insert_array
    // - get_variant_pos, variant_pos_to_str
}

// TODO: Translate get_u8 standalone function (lines 1041-1056)
// TODO: Translate insert_bool standalone function (lines 2173-2207)
