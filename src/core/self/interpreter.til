mode lib

import("src.core.self.init")
import("src.core.self.parser")
import("src.core.self.typer")

// Interpreter phase: Runtime evaluation and execution
// Corresponds to src/rs/interpreter.rs in the Rust implementation

RETURN_INSTANCE_NAME := "___temp_return_val_"

// Global arena for interpreter memory
// In the Rust version this is a singleton, here we use Context.arena
Arena := struct {
    mut memory: Array = Array()
    mut temp_id_counter: I64 = 0

    // Create new arena
    new := proc() returns Arena throws AllocError {
        mut a := Arena()
        a.memory = Vec.new(U8)
        a.temp_id_counter = 0
        return a
    }

    // Get singleton instance (in Rust this uses unsafe static mut)
    // In Til we'll pass arena around via Context instead
    g := proc() returns mut Arena {
        // This would be implemented as Context.arena
        TODO(loc(), "Arena.g() should use Context.arena")
        return Arena.new()
    }
}

// Result of evaluating an expression
EvalResult := struct {
    mut value: Str = ""
    mut is_return: Bool = false
    mut is_throw: Bool = false
    mut thrown_type: Str = ""  // Option<String> in Rust, empty string means None

    // Create normal result
    new := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    // Create return result
    new_return := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = true
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    // Create throw result
    new_throw := proc(value: Str, thrown_type: ValueType) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = true
        result.thrown_type = value_type_to_str(thrown_type)
        return result
    }
}

// Helper function to extract bool value from a Bool struct instance
bool_from_context := proc(context: Context, id: Str, e: Expr) returns Bool throws Str {
    // Validate the Bool struct exists
    context.get_struct(id, e)

    // Read the .data field (which is a U8)
    data_field := format(id, ".data")
    u8_val := get_u8(context, data_field, e)

    // Convert U8 to bool (0 = false, non-zero = true)
    return not(eq(u8_val, 0))
}

// Helper function to extract String value from a Str struct instance
string_from_context := proc(context: Context, id: Str, e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    // Validate the Str struct exists
    context.get_struct(id, e)

    // Read the c_string field (I64 pointer to string data in Arena)
    c_string_field := format(id, ".c_string")
    c_string_ptr := context.get_i64(c_string_field, e)

    // Read the cap field (I64 length)
    cap_field := format(id, ".cap")
    length := context.get_i64(cap_field, e)

    // Bounds check
    arena := Arena.g()
    if gt(add(c_string_ptr, length), arena.memory.len()) {
        throw e.lang_error(context.path, "string_from_context", format("string content out of bounds for '", id, "'"))
    }

    // Read string bytes from Arena and convert to String
    // In Til this would use array slicing when available
    // For now, simplified version
    mut result := ""
    mut i := c_string_ptr
    while lt(i, add(c_string_ptr, length)) {
        mut byte := 0
        arena.memory.get(i, byte)
        // Convert byte to char and append
        // TODO: proper UTF-8 handling
        i = add(i, 1)
    }
    return result
}

// Helper function to validate conditional statement parameters
validate_conditional_params := proc(path: Str, e: Expr, stmt_type: Str, min: I64, max: I64) returns () throws Str {
    params_len := e.params.len()
    if or(lt(params_len, min), gt(params_len, max)) {
        if eq(min, max) {
            throw e.lang_error(path, "eval", format(stmt_type, " nodes must have exactly ", i64_to_str(min), " parameters."))
        }
        throw e.lang_error(path, "eval", format(stmt_type, " nodes must have ", i64_to_str(min), " or ", i64_to_str(max), " parameters."))
    }
}

// Helper to evaluate boolean conditions for if/while statements
// Supports both legacy string bools ("true"/"false") and Bool struct instances
eval_condition_to_bool := proc(context: Context, result: EvalResult, expr: Expr) returns Bool throws Str {
    // First try parsing as string bool (backwards compatibility)
    if result.value.eq("true") {
        return true
    }
    if result.value.eq("false") {
        return false
    }

    // Otherwise, assume it's a Bool struct instance - read its .data field
    bool_id := result.value
    data_field_id := format(bool_id, ".data")
    u8_val := get_u8(context, data_field_id, expr)
    return not(eq(u8_val, 0))
}

// Helper function to validate function/procedure argument counts
validate_func_arg_count := proc(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns () throws Str {
    provided_args := sub(e.params.len(), 1)
    has_multi_arg := func_proc_has_multi_arg(func_def)

    // Check exact count for non-variadic functions
    if and(not(has_multi_arg), not(eq(func_def.args.len(), provided_args))) {
        throw e.lang_error(path, "eval", format("func '", name, "' expected ", i64_to_str(func_def.args.len()), " args, but ", i64_to_str(provided_args), " were provided."))
    }

    // Check minimum count for variadic functions
    if and(has_multi_arg, gt(sub(func_def.args.len(), 1), provided_args)) {
        throw e.lang_error(path, "eval", format("func '", name, "' expected at least ", i64_to_str(sub(func_def.args.len(), 1)), " args, but ", i64_to_str(provided_args), " were provided."))
    }
}

// Main expression evaluator
eval_expr := proc(mut context: Context, e: Expr) returns EvalResult throws Str, AllocError, IndexOutOfBoundsError {
    switch e.node_type {
    case NodeType.Body:
        return eval_body(context, e.params)

    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(li64):
            return EvalResult.new(li64)
        case Literal.Str(lstring):
            return EvalResult.new(lstring)
        case Literal.List(llist):
            return EvalResult.new(llist)
        case:
            throw e.lang_error(context.path, "eval", "Unknown literal type")
        }

    case NodeType.FCall:
        f_name := get_func_name_in_call(e)
        return eval_func_proc_call(f_name, context, e)

    case NodeType.Declaration(declaration):
        return eval_declaration(declaration, context, e)

    case NodeType.Assignment(var_name):
        return eval_assignment(var_name, context, e)

    case NodeType.Identifier(name):
        return eval_identifier_expr(name, context, e)

    case NodeType.If:
        validate_conditional_params(context.path, e, "if", 2, 3)
        cond_expr := e.get(0)
        result_cond := eval_expr(context, cond_expr)
        if result_cond.is_throw {
            return result_cond
        }
        if eval_condition_to_bool(context, result_cond, cond_expr) {
            return eval_expr(context, e.get(1))
        }
        if eq(e.params.len(), 3) {
            return eval_expr(context, e.get(2))
        }
        return EvalResult.new("")

    case NodeType.While:
        validate_conditional_params(context.path, e, "while", 2, 2)
        mut cond_expr := e.get(0)
        mut result_cond := eval_expr(context, cond_expr)
        if result_cond.is_throw {
            return result_cond
        }
        while eval_condition_to_bool(context, result_cond, cond_expr) {
            result := eval_expr(context, e.get(1))
            if or(result.is_return, result.is_throw) {
                return result
            }
            cond_expr = e.get(0)
            result_cond = eval_expr(context, cond_expr)
            if result_cond.is_throw {
                return result_cond
            }
        }
        return EvalResult.new("")

    case NodeType.Switch:
        if lt(e.params.len(), 3) {
            throw e.lang_error(context.path, "eval", "switch nodes must have at least 3 parameters.")
        }
        to_switch := e.get(0)
        value_type := get_value_type(context, to_switch)
        result_to_switch := eval_expr(context, to_switch)
        if result_to_switch.is_throw {
            return result_to_switch
        }

        mut param_it := 1
        while lt(param_it, e.params.len()) {
            case_expr := e.get(param_it)
            if eq(case_expr.node_type, NodeType.DefaultCase) {
                param_it = add(param_it, 1)
                return eval_expr(context, e.get(param_it))
            }

            case_type := get_value_type(context, case_expr)
            vt_str := value_type_to_str(value_type)
            ct_str := value_type_to_str(case_type)
            if and(not(ct_str.eq(vt_str)), not(ct_str.eq(format(vt_str, "Range")))) {
                throw e.lang_error(context.path, "eval", format("switch value type ", vt_str, ", case value type ", ct_str))
            }

            // Handle pattern matching with payload extraction
            switch case_expr.node_type {
            case NodeType.Pattern(pattern_info):
                // Extract enum variant and binding variable
                variant_name := pattern_info.variant_name
                binding_var := pattern_info.binding_var

                // Get the enum variable name from to_switch
                mut enum_var_name := ""
                switch to_switch.node_type {
                case NodeType.Identifier(name):
                    enum_var_name = name
                case:
                    throw case_expr.error(context.path, "eval", "Pattern matching requires switch value to be a variable")
                }

                enum_val := context.get_enum(enum_var_name, case_expr)

                // Check if variant matches
                full_variant := format(enum_val.enum_type, ".", enum_val.enum_name)
                if or(full_variant.eq(variant_name), enum_val.enum_name.eq(variant_name)) {
                    // Match! Extract the payload and bind it to the variable
                    param_it = add(param_it, 1)

                    // TODO: Extract payload into the binding variable
                    // This requires handling different payload types (Bool, I64, Str, structs, enums)
                    // For now, simplified version
                    if enum_val.has_payload {
                        // Declare symbol for binding variable
                        // Insert payload value
                        // This is a complex section that needs full implementation
                        TODO(loc(), "Pattern matching payload extraction not fully implemented")
                    }

                    // Execute the case body with the bound variable available
                    return eval_expr(context, e.get(param_it))
                }
                // No match, continue to next case
                param_it = add(param_it, 2)
                continue

            case:
                // Regular case (not pattern matching)
                is_match := false

                switch case_expr.node_type {
                case NodeType.Range:
                    start := eval_expr(context, case_expr.params.get(0))
                    if start.is_throw {
                        return start
                    }
                    end_expr := eval_expr(context, case_expr.params.get(1))
                    if end_expr.is_throw {
                        return end_expr
                    }

                    // Check if value is in range
                    switch value_type {
                    case ValueType.TCustom(s):
                        if or(s.eq("I64"), s.eq("U8")) {
                            val := str_to_i64(result_to_switch.value)
                            start_val := str_to_i64(start.value)
                            end_val := str_to_i64(end_expr.value)
                            is_match = and(ge(val, start_val), le(val, end_val))
                        }
                    case:
                        // Lexicographical comparison for Str
                        is_match = and(ge(result_to_switch.value, start.value), le(result_to_switch.value, end_expr.value))
                    }

                case:
                    result_case := eval_expr(context, case_expr)
                    if result_case.is_throw {
                        return result_case
                    }
                    is_match = result_to_switch.value.eq(result_case.value)
                }

                param_it = add(param_it, 1)
                if is_match {
                    return eval_expr(context, e.get(param_it))
                }
                param_it = add(param_it, 1)
            }
        }
        return EvalResult.new("")

    case NodeType.Return:
        if eq(e.params.len(), 0) {
            return EvalResult.new_return("")
        }
        if gt(e.params.len(), 1) {
            throw e.lang_error(context.path, "eval", "multiple return values not implemented yet")
        }
        result := eval_expr(context, e.get(0))
        if result.is_throw {
            return result
        }
        return EvalResult.new_return(result.value)

    case NodeType.Throw:
        if not(eq(e.params.len(), 1)) {
            throw e.lang_error(context.path, "eval", "Throw can only return one value. This should have been caught before")
        }
        param_expr := e.get(0)
        result := eval_expr(context, param_expr)
        if result.is_throw {
            return result
        }
        thrown_type := get_value_type(context, param_expr)
        return EvalResult.new_throw(result.value, thrown_type)

    case NodeType.Catch:
        throw e.lang_error(context.path, "eval", "Catch statements should always be evaluated within bodies.")

    case:
        throw e.lang_error(context.path, "eval", format("Not implemented yet, found node type: ", enum_to_str(e.node_type)))
    }
}

// Function/procedure call dispatcher
eval_func_proc_call := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    if not(eq(e.node_type, NodeType.FCall)) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall node type")
    }

    if lt(e.params.len(), 1) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall with at least one param for the Identifier")
    }

    func_expr := e.params.get(0)

    // Check if this is a struct instantiation
    if context.scope_stack.lookup_struct(name).is_some() {
        id_expr := e.get(0)
        if eq(id_expr.params.len(), 0) {
            mut id_name := ""
            switch id_expr.node_type {
            case NodeType.Identifier(s):
                id_name = s
            case:
                throw e.todo_error(context.path, "eval", "Expected identifier name for struct instantiation")
            }

            context.insert_struct(id_name, name, e)

            // Return appropriate default value
            if id_name.eq("Bool") {
                return EvalResult.new("false")
            }
            if or(id_name.eq("U8"), id_name.eq("I64")) {
                return EvalResult.new("0")
            }
            if id_name.eq("Str") {
                return EvalResult.new("")
            }
            return EvalResult.new(id_name)
        }
    }

    combined_name := get_combined_name(context.path, func_expr)

    // Check if this is an enum constructor call (e.g., Color.Green(true))
    parts := combined_name.split('.')
    if eq(parts.len(), 2) {
        enum_type := parts.get(0)
        if context.scope_stack.lookup_enum(enum_type).is_some() {
            // This is an enum constructor!
            variant_name := parts.get(1)

            // Get the enum definition
            enum_def := context.scope_stack.lookup_enum(enum_type).unwrap()
            variant_type := enum_def.enum_map.get(variant_name)

            // TODO: Handle enum constructor with and without payload
            // This is complex logic that needs full implementation
            TODO(loc(), "Enum constructor handling not fully implemented")
        }
    }

    // Get function definition
    mut new_fcall_e := e.clone()
    func_def_option := get_func_def_for_fcall_with_expr(context, new_fcall_e)

    if func_def_option.is_none() {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Instantiations should be handled already")
    }

    func_def := func_def_option.unwrap()

    if func_def.is_ext() {
        // External/core functions
        is_proc := func_def.is_proc()
        parts_split := combined_name.split('.')
        last_name := parts_split.last().unwrap()
        return eval_core_func_proc_call(last_name, context, new_fcall_e, is_proc)
    }

    return eval_user_func_proc_call(func_def, combined_name, context, new_fcall_e)
}

// Evaluate a declaration
eval_declaration := proc(declaration: Declaration, mut context: Context, e: Expr) returns EvalResult throws Str {
    inner_e := e.get(0)
    mut value_type := get_value_type(context, inner_e)

    if not(eq(declaration.value_type, ValueType.TCustom(INFER_TYPE))) {
        if and(eq(declaration.value_type, ValueType.TCustom("U8")), eq(value_type, ValueType.TCustom("I64"))) {
            value_type = declaration.value_type.clone()
        }
        else if not(eq(value_type, declaration.value_type)) {
            throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type ", value_type_to_str(declaration.value_type), " but initialized to type ", value_type_to_str(value_type), "."))
        }
    }

    if not(eq(e.params.len(), 1)) {
        throw e.lang_error(context.path, "eval", "Declarations can have only one child expression")
    }

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("'", declaration.name, "' declared of type '", value_type_to_str(declaration.value_type), "' but still to infer type '", s, "'"))
        }

    case ValueType.TType(TTypeDef.TEnumDef):
        switch inner_e.node_type {
        case NodeType.EnumDef(enum_def):
            context.scope_stack.declare_enum(declaration.name.clone(), enum_def.clone())
            context.scope_stack.declare_symbol(
                declaration.name.to_string(),
                SymbolInfo.new(value_type.clone(), declaration.is_mut, declaration.is_copy, declaration.is_own)
            )
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected enum definition."))
        }

    case ValueType.TType(TTypeDef.TStructDef):
        switch inner_e.node_type {
        case NodeType.StructDef(struct_def):
            context.scope_stack.declare_struct(declaration.name.to_string(), struct_def.clone())
            context.scope_stack.declare_symbol(
                declaration.name.to_string(),
                SymbolInfo.new(value_type.clone(), declaration.is_mut, declaration.is_copy, declaration.is_own)
            )

            // Process struct members with default values
            // TODO: Full implementation of struct member processing
            TODO(loc(), "Struct member default value processing not fully implemented")

            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot declare ", declaration.name, " of type ", value_type_to_str(declaration.value_type), ", expected struct definition."))
        }

    case ValueType.TFunction(_):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(declaration.name.to_string(), func_def.clone())
            context.scope_stack.declare_symbol(
                declaration.name.to_string(),
                SymbolInfo.new(value_type.clone(), declaration.is_mut, declaration.is_copy, declaration.is_own)
            )
            return EvalResult.new("")
        case:
            throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "', expected '", value_type_to_str(value_type), "' definition."))
        }

    case ValueType.TCustom(custom_type_name):
        // Handle primitive and custom types
        if or(or(custom_type_name.eq("I64"), custom_type_name.eq("U8")), or(custom_type_name.eq("Bool"), custom_type_name.eq("Str"))) {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            context.scope_stack.declare_symbol(
                declaration.name.to_string(),
                SymbolInfo.new(value_type.clone(), declaration.is_mut, declaration.is_copy, declaration.is_own)
            )
            context.insert_primitive(declaration.name, value_type, expr_result_str, e)
            return EvalResult.new("")
        }

        // Handle custom struct/enum types
        context.scope_stack.declare_symbol(
            declaration.name.to_string(),
            SymbolInfo.new(value_type.clone(), declaration.is_mut, declaration.is_copy, declaration.is_own)
        )

        custom_symbol := context.scope_stack.lookup_symbol(custom_type_name)
        if custom_symbol.is_none() {
            throw e.lang_error(context.path, "eval", format("Symbol '", custom_type_name, "' not found in context"))
        }

        custom_sym := custom_symbol.unwrap()
        if eq(custom_sym.value_type, ValueType.TType(TTypeDef.TEnumDef)) {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            enum_expr_result_str := result.value
            context.insert_enum(declaration.name, custom_type_name, enum_expr_result_str, e)
        }
        else if eq(custom_sym.value_type, ValueType.TType(TTypeDef.TStructDef)) {
            // Handle struct instantiation and assignment
            // TODO: Full implementation
            TODO(loc(), "Struct declaration handling not fully implemented")
        }
        else {
            throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(custom_sym.value_type), "'. Only 'enum' and 'struct' custom types allowed."))
        }
        return EvalResult.new("")

    case ValueType.TMulti(_):
        throw e.error(context.path, "eval", format("Cannot declare '", declaration.name, "' of type '", value_type_to_str(declaration.value_type), "'"))

    case:
        throw e.lang_error(context.path, "eval", format("Unhandled value type in declaration: ", value_type_to_str(value_type)))
    }
}

// Evaluate an assignment
eval_assignment := proc(var_name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    // For field access (e.g., "v.x"), extract the base variable name
    base_var_name := if var_name.contains('.') {
        var_name.split('.').next().unwrap()
    } else {
        var_name
    }

    symbol_info := context.scope_stack.lookup_symbol(base_var_name)
    if symbol_info.is_none() {
        throw e.lang_error(context.path, "eval", format("Symbol '", base_var_name, "' not found in context"))
    }

    sym := symbol_info.unwrap()
    if and(and(not(sym.is_mut), not(sym.is_copy)), not(sym.is_own)) {
        throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': Assignments can only be to mut values."))
    }

    if not(eq(e.params.len(), 1)) {
        throw e.lang_error(context.path, "eval", format("in eval_assignment, while assigning to '", var_name, "': assignments must take exactly one value"))
    }

    inner_e := e.get(0)
    value_type := get_value_type(context, inner_e)

    switch value_type {
    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Cannot assign ", var_name, ", type should already be inferred of type '", value_type_to_str(sym.value_type), "'."))
        }

    case ValueType.TCustom(custom_type_name):
        if or(or(custom_type_name.eq("I64"), custom_type_name.eq("U8")), custom_type_name.eq("Str")) {
            result := eval_expr(context, inner_e)
            if result.is_throw {
                return result
            }
            expr_result_str := result.value
            context.insert_primitive(var_name, value_type, expr_result_str, e)
        }
        else {
            // Handle custom types (enum, struct)
            // TODO: Full implementation
            TODO(loc(), "Custom type assignment not fully implemented")
        }
        return EvalResult.new("")

    case ValueType.TFunction(_):
        switch inner_e.node_type {
        case NodeType.FuncDef(func_def):
            context.scope_stack.declare_func(var_name.to_string(), func_def.clone())
            return EvalResult.new("")
        case:
            throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' to function type '", value_type_to_str(value_type), "'"))
        }

    case:
        throw e.lang_error(context.path, "eval", format("Cannot assign '", var_name, "' of type '", value_type_to_str(value_type), "'."))
    }
}

// Evaluate an identifier expression (variable lookup)
eval_identifier_expr := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    symbol_info := context.scope_stack.lookup_symbol(name)

    if symbol_info.is_none() {
        throw e.lang_error(context.path, "eval", format("Undefined symbol '", name, "'. This should have been caught in the compile phase."))
    }

    sym := symbol_info.unwrap()

    switch sym.value_type {
    case ValueType.TFunction(_):
        return EvalResult.new(name)

    case ValueType.TType(TTypeDef.TEnumDef):
        inner_e := e.get(0)
        switch inner_e.node_type {
        case NodeType.Identifier(inner_name):
            return EvalResult.new(format(name, ".", inner_name))
        case:
            throw e.lang_error(context.path, "eval", format("identifier '", name, "' should only have identifiers inside."))
        }

    case ValueType.TType(TTypeDef.TStructDef):
        // TODO: Implement struct field access
        TODO(loc(), "Struct field access in eval_identifier_expr not fully implemented")
        return EvalResult.new("")

    case ValueType.TCustom(s):
        if s.eq(INFER_TYPE) {
            throw e.lang_error(context.path, "eval", format("Can't infer the type of identifier '", name, "'."))
        }

    case ValueType.TCustom(custom_type_name):
        if custom_type_name.eq("I64") {
            val := context.get_i64(name, e)
            return EvalResult.new(i64_to_str(val))
        }
        if custom_type_name.eq("U8") {
            val := get_u8(context, name, e)
            return EvalResult.new(i64_to_str(u8_to_i64(val)))
        }
        if custom_type_name.eq("Bool") {
            val := bool_from_context(context, name, e)
            return EvalResult.new(if val { "true" } else { "false" })
        }
        if custom_type_name.eq("Str") {
            if eq(e.params.len(), 0) {
                val := string_from_context(context, name, e)
                return EvalResult.new(val)
            }
            // Field access on Str
            // TODO: Implement
            TODO(loc(), "Str field access not implemented")
            return EvalResult.new("")
        }

        // Custom enum/struct types
        // TODO: Full implementation
        TODO(loc(), "Custom type identifier evaluation not fully implemented")
        return EvalResult.new("")

    case:
        throw e.todo_error(context.path, "eval", format("Can't use identifier '", name, "'. Type ", value_type_to_str(sym.value_type), " not supported yet."))
    }
}

// Evaluate a body (sequence of statements)
eval_body := proc(mut context: Context, statements: Array) returns EvalResult throws Str {
    mut i := 0
    mut pending_throw := EvalResult.new("")  // Using empty EvalResult as None equivalent
    pending_throw.thrown_type = ""  // Empty means no pending throw

    while lt(i, statements.len()) {
        stmt := statements.get(i)

        // Check if we have a pending throw
        has_pending_throw := not(pending_throw.thrown_type.eq(""))

        if has_pending_throw {
            // Look for catch block
            if eq(stmt.node_type, NodeType.Catch) {
                if eq(stmt.params.len(), 3) {
                    var_expr := stmt.params.get(0)
                    mut var_name := ""
                    switch var_expr.node_type {
                    case NodeType.Identifier(name):
                        var_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch variable must be an identifier")
                    }

                    type_expr := stmt.params.get(1)
                    mut type_name := ""
                    switch type_expr.node_type {
                    case NodeType.Identifier(name):
                        type_name = name
                    case:
                        throw stmt.lang_error(context.path, "eval", "Catch type must be an identifier")
                    }

                    if type_name.eq(pending_throw.thrown_type) {
                        // Match! Bind the error variable
                        context.scope_stack.declare_symbol(
                            var_name.to_string(),
                            SymbolInfo.new(
                                ValueType.TCustom(pending_throw.thrown_type.clone()),
                                false,
                                false,
                                false
                            )
                        )

                        // TODO: Map instance fields for the error variable
                        // This requires complex field mapping logic

                        body_expr := stmt.params.get(2)
                        result := eval_body(context, body_expr.params)

                        // Clean up the error variable binding
                        context.scope_stack.remove_symbol(var_name)
                        context.scope_stack.remove_var(var_name)

                        if result.is_return {
                            return result
                        }
                        if result.is_throw {
                            pending_throw = result
                        }
                        else {
                            pending_throw.thrown_type = ""  // Clear pending throw
                        }
                    }
                }
            }
        }
        else {
            // No pending throw, evaluate statements (skip catch blocks)
            if not(eq(stmt.node_type, NodeType.Catch)) {
                result := eval_expr(context, stmt)
                if result.is_return {
                    return result
                }
                if result.is_throw {
                    pending_throw = result
                }
            }
        }

        i = add(i, 1)
    }

    if not(pending_throw.thrown_type.eq("")) {
        return pending_throw
    }

    return EvalResult.new("")
}

// Evaluate user-defined function/procedure call
eval_user_func_proc_call := proc(func_def: SFuncDef, name: Str, mut context: Context, e: Expr) returns EvalResult throws Str {
    mut function_context := context.clone()
    function_context.path = func_def.source_path.clone()

    validate_func_arg_count(context.path, e, name, func_def)

    // TODO: Full implementation of argument passing
    // - Handle variadic arguments (TMulti)
    // - Handle pass-by-reference for non-copy types
    // - Handle ownership transfer for 'own' parameters
    // - Handle Dynamic/Type parameters
    // - Handle enum payload preservation
    // - Handle mut arguments with field access

    TODO(loc(), "User function call argument handling not fully implemented")

    // Evaluate function body
    result := eval_body(function_context, func_def.body)

    if result.is_throw {
        // TODO: Copy thrown struct's arena_index entries to calling context
        return result
    }

    result_str := result.value

    // TODO: Handle mut argument writeback
    // TODO: Handle return value struct/enum copying

    return EvalResult.new(result_str)
}

// Core function/procedure dispatcher
eval_core_func_proc_call := proc(name: Str, mut context: Context, e: Expr, is_proc: Bool) returns EvalResult throws Str {
    // Dispatch to external/core functions
    // These would be imported from ext module

    if name.eq("loc") {
        return ext_func_loc(context, e)
    }
    if name.eq("size_of") {
        return ext_func_size_of(context, e)
    }
    if name.eq("type_as_str") {
        return ext_func_type_as_str(context, e)
    }
    if name.eq("to_ptr") {
        return ext_func_to_ptr(context, e)
    }
    if name.eq("malloc") {
        return ext_func_malloc(context, e)
    }
    if name.eq("free") {
        return ext_func_free(context, e)
    }
    if name.eq("memset") {
        return ext_func_memset(context, e)
    }
    if name.eq("memcpy") {
        return ext_func_memcpy(context, e)
    }
    if name.eq("memcmp") {
        return ext_func_memcmp(context, e)
    }
    if name.eq("lt") {
        return ext_func_lt(context, e)
    }
    if name.eq("gt") {
        return ext_func_gt(context, e)
    }
    if name.eq("add") {
        return ext_func_add(context, e)
    }
    if name.eq("sub") {
        return ext_func_sub(context, e)
    }
    if name.eq("mul") {
        return ext_func_mul(context, e)
    }
    if name.eq("div") {
        return ext_func_div(context, e)
    }
    if name.eq("mod") {
        return ext_func_mod(context, e)
    }
    if name.eq("str_to_i64") {
        return ext_func_str_to_i64(context, e)
    }
    if name.eq("i64_to_str") {
        return ext_func_i64_to_str(context, e)
    }
    if name.eq("enum_to_str") {
        return ext_func_enum_to_str(context, e)
    }
    if name.eq("u8_to_i64") {
        return ext_func_u8_to_i64(context, e)
    }
    if name.eq("i64_to_u8") {
        return ext_func_i64_to_u8(context, e)
    }
    if name.eq("eval_to_str") {
        return ext_proc_eval_to_str(context, e)
    }
    if name.eq("exit") {
        return ext_func_exit(context, e)
    }
    if name.eq("import") {
        return ext_proc_import(context, e)
    }
    if name.eq("input_read_line") {
        return ext_proc_input_read_line(context, e)
    }
    if name.eq("single_print") {
        return ext_proc_single_print(context, e)
    }
    if name.eq("print_flush") {
        return ext_proc_print_flush(context, e)
    }
    if name.eq("readfile") {
        return ext_proc_readfile(context, e)
    }
    if name.eq("runfile") {
        return ext_proc_runfile(context, e)
    }
    if name.eq("has_const") {
        return ext_func_has_const(context, e)
    }
    if name.eq("has_field") {
        return ext_func_has_field(context, e)
    }

    // Unknown function
    if is_proc {
        throw e.lang_error(context.path, "eval", format("Core procedure '", name, "' not implemented."))
    }
    throw e.lang_error(context.path, "eval", format("Core function '", name, "' not implemented."))
}
