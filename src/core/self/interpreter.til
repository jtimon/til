mode lib

// use crate::rs::init::{Context, SymbolInfo, get_value_type, get_func_name_in_call, insert_bool, get_u8};
// use crate::rs::parser::{
//     INFER_TYPE,
//     Expr, NodeType, Literal, ValueType, TTypeDef, Declaration, PatternInfo, FunctionType, SFuncDef,
//     value_type_to_str, get_combined_name,
// };
// use crate::rs::typer::{get_func_def_for_fcall_with_expr, func_proc_has_multi_arg};
// use crate::rs::ext;

// Interpreter/Eval phase: Runtime evaluation and execution
// This module handles the eval phase that runs after type checking.
// Manages arena, memory allocation, and actual program execution.

RETURN_INSTANCE_NAME := "___temp_return_val_"

Arena := struct {
    mut memory: Vec<U8>
    mut temp_id_counter: I64
}

// heap/arena memory (starts at 1 to avoid NULL confusion)
// REM: first address 0 is reserved (invalid), malloc always >0
Arena_impl := struct {
    // This function gives access to the singleton instance of Arena
    // #[allow(static_mut_refs)]
    // pub fn g() -> &'static mut Arena {
    g := proc() returns mut Arena throws AllocError {
        // unsafe { // TODO research if we can do "safe" singletons in rust before self hosting, just out of curiosity
        //     static mut INSTANCE: Option<Arena> = None;
        //
        //     // Lazy initialization of the singleton instance
        //     INSTANCE.get_or_insert_with(|| Arena {
        //         memory: vec![0], // REM: first address 0 is reserved (invalid), malloc always >0
        //         temp_id_counter: 0, // A temporary ugly hack for return values
        //     })
        // }

        // TODO: Implement singleton pattern in Til
        // For now, create a new arena
        mut a := Arena()
        a.memory = Vec.new(U8)
        // REM: first address 0 is reserved (invalid), malloc always >0
        a.memory.push(0)
        a.temp_id_counter = 0  // A temporary ugly hack for return values
        return a
    }
}

// #[derive(Clone, Debug)]
// pub struct EvalResult {
//     pub value: String,
//     pub is_return: bool,
//     pub is_throw: bool,
//     pub thrown_type: Option<String>,
// }
EvalResult := struct {
    mut value: Str = ""
    mut is_return: Bool = false
    mut is_throw: Bool = false
    mut thrown_type: Str = ""  // Option<String> -> empty string for None
}

// impl EvalResult {
EvalResult_impl := struct {
    //     pub fn new(value: &str) -> EvalResult {
    //         return EvalResult{value: value.to_string(), is_return: false, is_throw: false, thrown_type: None}
    //     }
    new := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    //     pub fn new_return(value: &str) -> EvalResult {
    //         return EvalResult{value: value.to_string(), is_return: true, is_throw: false, thrown_type: None}
    //     }
    new_return := proc(value: Str) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = true
        result.is_throw = false
        result.thrown_type = ""
        return result
    }

    //     pub fn new_throw(value: &str, thrown_type: ValueType) -> EvalResult {
    //         return EvalResult{value: value.to_string(), is_return: false, is_throw: true, thrown_type: Some(value_type_to_str(&thrown_type))}
    //     }
    new_throw := proc(value: Str, thrown_type: ValueType) returns EvalResult {
        mut result := EvalResult()
        result.value = value
        result.is_return = false
        result.is_throw = true
        result.thrown_type = value_type_to_str(thrown_type)
        return result
    }
}

// Helper function to extract bool value from a Bool struct instance
// pub fn bool_from_context(context: &Context, id: &str, e: &Expr) -> Result<bool, String> {
bool_from_context := proc(context: Context, id: Str, e: Expr) returns Bool throws Str {
    // Validate the Bool struct exists
    // context.get_struct(id, e)?;
    context.get_struct(id, e)

    // Read the .data field (which is a U8)
    // let data_field = format!("{}.data", id);
    data_field := format(id, ".data")
    // let u8_val = get_u8(context, &data_field, e)?;
    u8_val := get_u8(context, data_field, e)

    // Convert U8 to bool (0 = false, non-zero = true)
    // Ok(u8_val != 0)
    return not(eq(u8_val, 0))
}

// Helper function to extract String value from a Str struct instance
// pub fn string_from_context(context: &Context, id: &str, e: &Expr) -> Result<String, String> {
string_from_context := proc(context: Context, id: Str, e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    // Validate the Str struct exists
    // context.get_struct(id, e)?;
    context.get_struct(id, e)

    // Read the c_string field (I64 pointer to string data in Arena)
    // let c_string_ptr = context.get_i64(&format!("{}.c_string", id), e)? as usize;
    c_string_field := format(id, ".c_string")
    c_string_ptr := context.get_i64(c_string_field, e)

    // Read the cap field (I64 length)
    // let length = context.get_i64(&format!("{}.cap", id), e)? as usize;
    cap_field := format(id, ".cap")
    length := context.get_i64(cap_field, e)

    // Bounds check
    // if c_string_ptr + length > Arena::g().memory.len() {
    //     return Err(e.lang_error(&context.path, "string_from_context", &format!("string content out of bounds for '{}'", id)));
    // }
    arena := Arena_impl.g()
    if gt(add(c_string_ptr, length), arena.memory.len()) {
        throw e.lang_error(context.path, "string_from_context", format("string content out of bounds for '", id, "'"))
    }

    // Read string bytes from Arena and convert to String
    // let bytes = &Arena::g().memory[c_string_ptr..c_string_ptr + length];
    // Ok(String::from_utf8_lossy(bytes).to_string())

    // TODO: Implement proper string slicing and UTF-8 conversion in Til
    // For now, build string byte by byte
    mut result := ""
    mut i := c_string_ptr
    end_pos := add(c_string_ptr, length)
    while lt(i, end_pos) {
        mut byte := 0
        arena.memory.get(i, byte)
        // Convert byte to char and append
        // TODO: Proper UTF-8 handling
        i = add(i, 1)
    }
    return result
}

// Helper function to validate conditional statement parameters
// fn validate_conditional_params(path: &str, e: &Expr, stmt_type: &str, min: usize, max: usize) -> Result<(), String> {
validate_conditional_params := proc(path: Str, e: Expr, stmt_type: Str, min: I64, max: I64) returns () throws Str {
    // if e.params.len() < min || e.params.len() > max {
    params_len := e.params.len()
    if or(lt(params_len, min), gt(params_len, max)) {
        // if min == max {
        if eq(min, max) {
            // return Err(e.lang_error(path, "eval", &format!("{} nodes must have exactly {} parameters.", stmt_type, min)));
            throw e.lang_error(path, "eval", format(stmt_type, " nodes must have exactly ", i64_to_str(min), " parameters."))
        }
        // } else {
        // return Err(e.lang_error(path, "eval", &format!("{} nodes must have {} or {} parameters.", stmt_type, min, max)));
        throw e.lang_error(path, "eval", format(stmt_type, " nodes must have ", i64_to_str(min), " or ", i64_to_str(max), " parameters."))
        // }
    }
    // Ok(())
}

// Helper to evaluate boolean conditions for if/while statements.
// Supports both legacy string bools ("true"/"false") and Bool struct instances.
// fn eval_condition_to_bool(context: &Context, result: &EvalResult, expr: &Expr) -> Result<bool, String> {
eval_condition_to_bool := proc(context: Context, result: EvalResult, expr: Expr) returns Bool throws Str {
    // First try parsing as string bool (backwards compatibility)
    // if let Ok(b) = result.value.parse::<bool>() {
    //     return Ok(b);
    // }
    if result.value.eq("true") {
        return true
    }
    if result.value.eq("false") {
        return false
    }

    // Otherwise, assume it's a Bool struct instance - read its .data field
    // The value should be the identifier name of the Bool instance
    // let bool_id = &result.value;
    bool_id := result.value
    // let data_field_id = format!("{}.data", bool_id);
    data_field_id := format(bool_id, ".data")
    // let u8_val = get_u8(context, &data_field_id, expr)?;
    u8_val := get_u8(context, data_field_id, expr)
    // Ok(u8_val != 0)
    return not(eq(u8_val, 0))
}

// Helper function to validate function/procedure argument counts
// fn validate_func_arg_count(path: &str, e: &Expr, name: &str, func_def: &SFuncDef) -> Result<(), String> {
validate_func_arg_count := proc(path: Str, e: Expr, name: Str, func_def: SFuncDef) returns () throws Str {
    // let provided_args = e.params.len() - 1;
    provided_args := sub(e.params.len(), 1)
    // let has_multi_arg = func_proc_has_multi_arg(func_def);
    has_multi_arg := func_proc_has_multi_arg(func_def)

    // Check exact count for non-variadic functions
    // if !has_multi_arg && func_def.args.len() != provided_args {
    if and(not(has_multi_arg), not(eq(func_def.args.len(), provided_args))) {
        // return Err(e.lang_error(path, "eval", &format!("func '{}' expected {} args, but {} were provided.",
        //                                          name, func_def.args.len(), provided_args)));
        throw e.lang_error(path, "eval", format("func '", name, "' expected ", i64_to_str(func_def.args.len()), " args, but ", i64_to_str(provided_args), " were provided."))
    }

    // Check minimum count for variadic functions
    // if has_multi_arg && func_def.args.len() - 1 > provided_args {
    if and(has_multi_arg, gt(sub(func_def.args.len(), 1), provided_args)) {
        // return Err(e.lang_error(path, "eval", &format!("func '{}' expected at least {} args, but {} were provided.",
        //                                          name, func_def.args.len() - 1, provided_args)));
        throw e.lang_error(path, "eval", format("func '", name, "' expected at least ", i64_to_str(sub(func_def.args.len(), 1)), " args, but ", i64_to_str(provided_args), " were provided."))
    }

    // Ok(())
}

// pub fn eval_expr(context: &mut Context, e: &Expr) -> Result<EvalResult, String> {
eval_expr := proc(mut context: Context, e: Expr) returns EvalResult throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // match &e.node_type {
    switch e.node_type {
    //     NodeType::Body => eval_body(context, &e.params),
    case NodeType.Body:
        return eval_body(context, e.params)

    //     NodeType::LLiteral(Literal::Number(li64)) => Ok(EvalResult::new(li64)),
    case NodeType.LLiteral(lit):
        switch lit {
        case Literal.Number(li64):
            return EvalResult_impl.new(li64)
        //     NodeType::LLiteral(Literal::Str(lstring)) => Ok(EvalResult::new(lstring)),
        case Literal.Str(lstring):
            return EvalResult_impl.new(lstring)
        //     NodeType::LLiteral(Literal::List(llist)) => Ok(EvalResult::new(llist)),
        case Literal.List(llist):
            return EvalResult_impl.new(llist)
        case:
            throw e.lang_error(context.path, "eval", "Unknown literal type")
        }

    //     NodeType::FCall => {
    //         let f_name = get_func_name_in_call(&e);
    //         eval_func_proc_call(&f_name, context, &e)
    //     },
    case NodeType.FCall:
        f_name := get_func_name_in_call(e)
        return eval_func_proc_call(f_name, context, e)

    //     NodeType::Declaration(declaration) => {
    //         eval_declaration(&declaration, context, &e)
    //     },
    case NodeType.Declaration(declaration):
        return eval_declaration(declaration, context, e)

    //     NodeType::Assignment(var_name) => {
    //         eval_assignment(&var_name, context, &e)
    //     },
    case NodeType.Assignment(var_name):
        return eval_assignment(var_name, context, e)

    //     NodeType::Identifier(name) => eval_identifier_expr(&name, context, &e),
    case NodeType.Identifier(name):
        return eval_identifier_expr(name, context, e)

    //     NodeType::If => {
    case NodeType.If:
        //         validate_conditional_params(&context.path, e, "if", 2, 3)?;
        validate_conditional_params(context.path, e, "if", 2, 3)
        //         let cond_expr = e.get(0)?;
        cond_expr := e.get(0)
        //         let result_cond = eval_expr(context, cond_expr)?;
        result_cond := eval_expr(context, cond_expr)
        //         if result_cond.is_throw {
        //             return Ok(result_cond)
        //         }
        if result_cond.is_throw {
            return result_cond
        }
        //         if eval_condition_to_bool(context, &result_cond, cond_expr)? {
        //             return eval_expr(context, e.get(1)?)
        //         } else if e.params.len() == 3 {
        //             return eval_expr(context, e.get(2)?)
        //         } else {
        //             return Ok(EvalResult::new(""))
        //         }
        if eval_condition_to_bool(context, result_cond, cond_expr) {
            return eval_expr(context, e.get(1))
        }
        if eq(e.params.len(), 3) {
            return eval_expr(context, e.get(2))
        }
        return EvalResult_impl.new("")
    //     },

    //     NodeType::While => {
    case NodeType.While:
        //         validate_conditional_params(&context.path, e, "while", 2, 2)?;
        validate_conditional_params(context.path, e, "while", 2, 2)
        //         let mut cond_expr = e.get(0)?;
        mut cond_expr := e.get(0)
        //         let mut result_cond = eval_expr(context, cond_expr)?;
        mut result_cond := eval_expr(context, cond_expr)
        //         if result_cond.is_throw {
        //             return Ok(result_cond.clone())
        //         }
        if result_cond.is_throw {
            return result_cond
        }
        //         while eval_condition_to_bool(context, &result_cond, cond_expr)? {
        while eval_condition_to_bool(context, result_cond, cond_expr) {
            //             let result = eval_expr(context, e.get(1)?)?;
            result := eval_expr(context, e.get(1))
            //             if result.is_return || result.is_throw {
            //                 return Ok(result)
            //             }
            if or(result.is_return, result.is_throw) {
                return result
            }
            //             cond_expr = e.get(0)?;
            cond_expr = e.get(0)
            //             result_cond = eval_expr(context, cond_expr)?;
            result_cond = eval_expr(context, cond_expr)
            //             if result_cond.is_throw {
            //                 return Ok(result_cond)
            //             }
            if result_cond.is_throw {
                return result_cond
            }
        //         }
        }
        //         Ok(EvalResult::new(""))
        return EvalResult_impl.new("")
    //     },

    //     NodeType::Switch => {
    case NodeType.Switch:
        //         if e.params.len() < 3 {
        //             return Err(e.lang_error(&context.path, "eval", "switch nodes must have at least 3 parameters."));
        //         }
        if lt(e.params.len(), 3) {
            throw e.lang_error(context.path, "eval", "switch nodes must have at least 3 parameters.")
        }
        //         let to_switch = e.get(0)?;
        to_switch := e.get(0)
        //         let value_type = get_value_type(&context, &to_switch)?;
        value_type := get_value_type(context, to_switch)
        //         let result_to_switch = eval_expr(context, &to_switch)?;
        result_to_switch := eval_expr(context, to_switch)
        //         if result_to_switch.is_throw {
        //             return Ok(result_to_switch);
        //         }
        if result_to_switch.is_throw {
            return result_to_switch
        }

        //         let mut param_it = 1;
        mut param_it := 1
        //         while param_it < e.params.len() {
        while lt(param_it, e.params.len()) {
            //             let case = e.get(param_it)?;
            case_expr := e.get(param_it)
            //             if case.node_type == NodeType::DefaultCase {
            //                 param_it += 1;
            //                 return eval_expr(context, e.get(param_it)?);
            //             }
            if eq(case_expr.node_type, NodeType.DefaultCase) {
                param_it = add(param_it, 1)
                return eval_expr(context, e.get(param_it))
            }

            //             let case_type = get_value_type(&context, &case)?;
            case_type := get_value_type(context, case_expr)
            //             let vt_str = value_type_to_str(&value_type);
            vt_str := value_type_to_str(value_type)
            //             let ct_str = value_type_to_str(&case_type);
            ct_str := value_type_to_str(case_type)
            //             if ct_str != vt_str && ct_str != format!("{}Range", vt_str) {
            //                 return Err(e.lang_error(&context.path, "eval", &format!("switch value type {:?}, case value type {:?}", value_type, case_type)));
            //             }
            range_type := format(vt_str, "Range")
            if and(not(ct_str.eq(vt_str)), not(ct_str.eq(range_type))) {
                throw e.lang_error(context.path, "eval", format("switch value type ", vt_str, ", case value type ", ct_str))
            }

            //             // Handle pattern matching with payload extraction
            //             if let NodeType::Pattern(PatternInfo { variant_name, binding_var }) = &case.node_type {
            switch case_expr.node_type {
            case NodeType.Pattern(pattern_info):
                variant_name := pattern_info.variant_name
                binding_var := pattern_info.binding_var

                //                 // Check if the switch value's enum variant matches the pattern
                //                 // The switch value should be an enum stored as EnumVal
                //                 // We need to extract the enum value - get the identifier name from to_switch
                //                 let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
                //                     name
                //                 } else {
                //                     return Err(case.error(&context.path, "eval", "Pattern matching requires switch value to be a variable"));
                //                 };
                mut enum_var_name := ""
                switch to_switch.node_type {
                case NodeType.Identifier(name):
                    enum_var_name = name
                case:
                    throw case_expr.error(context.path, "eval", "Pattern matching requires switch value to be a variable")
                }

                //                 let enum_val = context.get_enum(enum_var_name, &case)?;
                enum_val := context.get_enum(enum_var_name, case_expr)

                //                 // Check if variant matches (enum_val.enum_name should match variant_name)
                //                 let full_variant = format!("{}.{}", enum_val.enum_type, enum_val.enum_name);
                full_variant := format(enum_val.enum_type, ".", enum_val.enum_name)
                //                 if full_variant == *variant_name || enum_val.enum_name == *variant_name {
                if or(full_variant.eq(variant_name), enum_val.enum_name.eq(variant_name)) {
                    //                     // Match! Extract the payload and bind it to the variable
                    //                     param_it += 1;
                    param_it = add(param_it, 1)

                    //                     // Extract payload into the binding variable
                    //                     if let Some(payload_type) = &enum_val.payload_type {
                    //                         if let Some(payload_bytes) = &enum_val.payload {
                    if enum_val.has_payload_type {
                        if enum_val.has_payload {
                            // Use the existing payload extraction logic
                            // We need to insert the payload into context with the binding_var name
                            // TODO FIX: Bool enum payload extraction - needs special handling to read 1 byte and create Bool value

                            // TODO: Implement full payload extraction logic
                            // This requires handling different payload types (Bool, I64, Str, structs, enums)
                            // For now, mark as not fully implemented
                            TODO(loc(), "Pattern matching payload extraction not fully implemented in Til")
                        }
                    }

                    //                     // Execute the case body with the bound variable available
                    //                     return eval_expr(context, e.get(param_it)?);
                    return eval_expr(context, e.get(param_it))
                //                 } else {
                }
                //                     // No match, continue to next case
                //                     param_it += 2;
                //                     continue;
                //                 }
                param_it = add(param_it, 2)
                continue
            //             }

            case:
                // Regular case matching (not pattern)
                //             let is_match = match &case.node_type {
                mut is_match := false
                switch case_expr.node_type {
                //                 NodeType::Range => {
                case NodeType.Range:
                    //                     let start = eval_expr(context, &case.params[0])?;
                    start := eval_expr(context, case_expr.params.get(0))
                    //                     if start.is_throw {
                    //                         return Ok(start);
                    //                     }
                    if start.is_throw {
                        return start
                    }
                    //                     let end = eval_expr(context, &case.params[1])?;
                    end_result := eval_expr(context, case_expr.params.get(1))
                    //                     if end.is_throw {
                    //                         return Ok(end);
                    //                     }
                    if end_result.is_throw {
                        return end_result
                    }
                    //                     match &value_type {
                    switch value_type {
                    //                         ValueType::TCustom(s) if s == "I64" || s == "U8" => {
                    case ValueType.TCustom(s):
                        if or(s.eq("I64"), s.eq("U8")) {
                            //                             let val = result_to_switch.value.parse::<i64>();
                            //                             let start_val = start.value.parse::<i64>();
                            //                             let end_val = end.value.parse::<i64>();
                            //
                            //                             if let (Ok(val), Ok(start_val), Ok(end_val)) = (val, start_val, end_val) {
                            //                                 val >= start_val && val <= end_val
                            //                             } else {
                            //                                 false
                            //                             }
                            // Parse all values
                            val := str_to_i64(result_to_switch.value)
                            start_val := str_to_i64(start.value)
                            end_val := str_to_i64(end_result.value)
                            is_match = and(ge(val, start_val), le(val, end_val))
                        }
                    //                         }
                    //                         _ => {
                    case:
                        //                             // Lexicographical comparisons for Str
                        //                             result_to_switch.value >= start.value && result_to_switch.value <= end.value
                        is_match = and(ge(result_to_switch.value, start.value), le(result_to_switch.value, end_result.value))
                    //                         }
                    }
                //                     }
                //                 }

                //                 _ => {
                case:
                    //                     let result_case = eval_expr(context, &case)?;
                    result_case := eval_expr(context, case_expr)
                    //                     if result_case.is_throw {
                    //                         return Ok(result_case);
                    //                     }
                    if result_case.is_throw {
                        return result_case
                    }
                    //                     result_to_switch.value == result_case.value
                    is_match = result_to_switch.value.eq(result_case.value)
                //                 }
                }
                //             };

                //             param_it += 1;
                param_it = add(param_it, 1)
                //             if is_match {
                //                 return eval_expr(context, e.get(param_it)?);
                //             }
                if is_match {
                    return eval_expr(context, e.get(param_it))
                }
                //             param_it += 1;
                param_it = add(param_it, 1)
            }
        //         }
        }
        //         return Ok(EvalResult::new(""))
        return EvalResult_impl.new("")
    //     },

    //     NodeType::Return => {
    case NodeType.Return:
        //         if e.params.len() == 0 {
        //             return Ok(EvalResult::new_return(""))
        //         } else if e.params.len() > 1 {
        //             return Err(e.lang_error(&context.path, "eval", "multiple return values not implemented yet"))
        //         } else {
        //             let result = eval_expr(context, e.get(0)?)?;
        //             if result.is_throw {
                        return Ok(result)
        //             }
        //             return Ok(EvalResult::new_return(&result.value))
        //         }
        if eq(e.params.len(), 0) {
            return EvalResult_impl.new_return("")
        }
        if gt(e.params.len(), 1) {
            throw e.lang_error(context.path, "eval", "multiple return values not implemented yet")
        }
        result := eval_expr(context, e.get(0))
        if result.is_throw {
            return result
        }
        return EvalResult_impl.new_return(result.value)
    //     },

    //     NodeType::Throw => {
    case NodeType.Throw:
        //         if e.params.len() != 1 {
        //             return Err(e.lang_error(&context.path, "eval", "Throw can only return one value. This should have been caught before"))
        //         } else {
        //             let param_expr = e.get(0)?;
        //             let result = eval_expr(context, param_expr)?;
        //             if result.is_throw {
        //                 return Ok(result)
        //             }
        //             let thrown_type = get_value_type(context, param_expr)?;
        //             return Ok(EvalResult::new_throw(&result.value, thrown_type))
        //         }
        if not(eq(e.params.len(), 1)) {
            throw e.lang_error(context.path, "eval", "Throw can only return one value. This should have been caught before")
        }
        param_expr := e.get(0)
        result := eval_expr(context, param_expr)
        if result.is_throw {
            return result
        }
        thrown_type := get_value_type(context, param_expr)
        return EvalResult_impl.new_throw(result.value, thrown_type)
    //     },

    //     NodeType::Catch => {
    //         return Err(e.lang_error(&context.path, "eval", "Catch statements should always be evaluated within bodies."))
    //     },
    case NodeType.Catch:
        throw e.lang_error(context.path, "eval", "Catch statements should always be evaluated within bodies.")

    //     _ => Err(e.lang_error(&context.path, "eval", &format!("Not implemented yet, found node type {:?}.", e.node_type))),
    case:
        throw e.lang_error(context.path, "eval", format("Not implemented yet, found node type: ", enum_to_str(e.node_type)))
    }
}

// fn eval_func_proc_call(name: &str, context: &mut Context, e: &Expr) -> Result<EvalResult, String> {
eval_func_proc_call := proc(name: Str, mut context: Context, e: Expr) returns EvalResult throws Str, AllocError, IndexOutOfBoundsError, I64_OverflowError, FullError {
    // if e.node_type != NodeType::FCall {
    //     return Err(e.lang_error(&context.path, "eval", "eval_func_proc_call: Expected FCall node type"));
    // }
    if not(eq(e.node_type, NodeType.FCall)) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall node type")
    }
    // let func_expr = match e.params.first() {
    //     Some(expr) => expr,
    //     None => return Err(e.lang_error(&context.path, "eval", "eval_func_proc_call: Expected FCall with at least one param for the Identifier")),
    // };
    if lt(e.params.len(), 1) {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Expected FCall with at least one param for the Identifier")
    }
    func_expr := e.params.get(0)

    // if context.scope_stack.lookup_struct(name).is_some() {
    if context.scope_stack.lookup_struct(name).is_some() {
        // TODO allow instantiations with arguments
        //     let id_expr = e.get(0)?;
        id_expr := e.get(0)
        //     if id_expr.params.len() == 0 {
        if eq(id_expr.params.len(), 0) {
            //         let id_name = match &id_expr.node_type {
            //             NodeType::Identifier(s) => s,
            //             _ => return Err(e.todo_error(&context.path, "eval", "Expected identifier name for struct instantiation")),
            //         };
            mut id_name := ""
            switch id_expr.node_type {
            case NodeType.Identifier(s):
                id_name = s
            case:
                throw e.todo_error(context.path, "eval", "Expected identifier name for struct instantiation")
            }

            //         context.insert_struct(&id_name, &name, e)?;
            context.insert_struct(id_name, name, e)
            //         // TODO FIX: Bool can't be removed yet - Bool() constructor must return "false" string, not "Bool"
            //         return Ok(EvalResult::new(match id_name.as_str() {
            //             "Bool" => "false",
            //             "U8" | "I64" => "0",
            //             "Str" => "",
            //             _ => id_name, // TODO Where is the struct being inserted in this case? Is this returned value even used?
            //         }))
            if id_name.eq("Bool") {
                return EvalResult_impl.new("false")
            }
            if or(id_name.eq("U8"), id_name.eq("I64")) {
                return EvalResult_impl.new("0")
            }
            if id_name.eq("Str") {
                return EvalResult_impl.new("")
            }
            // TODO Where is the struct being inserted in this case? Is this returned value even used?
            return EvalResult_impl.new(id_name)
        //     }
        }
    // }
    }

    //let combined_name = &get_combined_name(&context.path, func_expr)?;
    combined_name := get_combined_name(context.path, func_expr)

    // Check if this is an enum constructor call (e.g., Color.Green(true))
    // let parts: Vec<&str> = combined_name.split('.').collect();
    parts := combined_name.split('.')
    // if parts.len() == 2 {
    if eq(parts.len(), 2) {
        //     let enum_type = parts[0];
        enum_type := parts.get(0)
        //     if context.scope_stack.lookup_enum(enum_type).is_some() {
        if context.scope_stack.lookup_enum(enum_type).is_some() {
            // This is an enum constructor!
            //         let variant_name = parts[1];
            variant_name := parts.get(1)

            // Get the enum definition to check if this variant has a payload type
            //         let enum_def = context.scope_stack.lookup_enum(enum_type).unwrap();
            enum_def := context.scope_stack.lookup_enum(enum_type).unwrap()
            //         let variant_type = enum_def.enum_map.get(variant_name).cloned();
            variant_type := enum_def.enum_map.get(variant_name)

            // TODO: Translate the massive enum constructor payload handling logic
            // This includes handling:
            // - Some(Some(payload_type)) - variant with payload
            // - Some(None) - variant without payload
            // - None - unknown variant
            // The payload handling includes support for I64, Bool, Str, custom structs, and nested enums
            // This is ~250 lines of complex Rust code that needs careful translation
            TODO(loc(), "Enum constructor payload handling not fully translated yet - requires init.til and typer.til")
        }
    }

    //     let mut new_fcall_e = e.clone();
    mut new_fcall_e := e.clone()
    //     let func_def = match get_func_def_for_fcall_with_expr(&context, &mut new_fcall_e)? {
    //         Some(func_def_) => func_def_,
    //         None  => {
    //             return Err(e.lang_error(&context.path, "eval", "eval_func_proc_call: Instantiations should be handled already"))
    //         },
    //     };
    func_def_option := get_func_def_for_fcall_with_expr(context, new_fcall_e)
    if func_def_option.is_none() {
        throw e.lang_error(context.path, "eval", "eval_func_proc_call: Instantiations should be handled already")
    }
    func_def := func_def_option.unwrap()

    //     if func_def.is_ext() {
    if func_def.is_ext() {
        // External/core functions are treated specially
        //         let is_proc = func_def.is_proc();
        is_proc := func_def.is_proc()
        //         let parts: Vec<&str> = combined_name.split('.').collect();
        parts_split := combined_name.split('.')
        //         let last_name = match parts.last() {
        //             Some(last_name_) => last_name_,
        //             None => {
        //                 return Err(e.lang_error(&context.path, "eval", "Somehow function without name"))
        //             }
        //         };
        if eq(parts_split.len(), 0) {
            throw e.lang_error(context.path, "eval", "Somehow function without name")
        }
        last_name := parts_split.last().unwrap()
        //         return eval_core_func_proc_call(&last_name, context, &new_fcall_e, is_proc)
        return eval_core_func_proc_call(last_name, context, new_fcall_e, is_proc)
    //     }
    }
    //     return eval_user_func_proc_call(&func_def, &combined_name, context, &new_fcall_e)
    return eval_user_func_proc_call(func_def, combined_name, context, new_fcall_e)
// }
}

// TODO: The following functions are partially translated stubs that require init.til and typer.til:
// - eval_declaration (~210 lines)
// - eval_assignment (~90 lines)
// - eval_identifier_expr and helpers (~260 lines)
// - eval_body (~170 lines)
// - eval_user_func_proc_call (~590 lines - most complex function)
// - eval_core_func_proc_call (~35 lines)
//
// Total remaining: ~1355 lines of Rust code to translate
// These will be completed after init.rs and typer.rs are translated to Til
