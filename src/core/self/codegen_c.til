mode lib

// C code generator for TIL
// Translates TIL AST to C source code

import("src.core.self.parser")  // Expr, NodeType, Literal

// Codegen context for tracking function info during code generation
CodegenContext := struct {
    // Map function name -> list of throw types (Map<Str, Vec<ValueType>>)
    mut func_throw_types: Map = Map.new(Str, Vec)
    // Currently generating function's throw types (if any)
    mut current_throw_types: Vec = Vec.new(ValueType)
    // Currently generating function's return types (if any)
    mut current_return_types: Vec = Vec.new(ValueType)
    // Counter for generating unique temporary variable names
    mut temp_counter: I64 = 0

    next_temp := proc(mut self: CodegenContext) returns Str {
        mut name := concat("_tmp", self.temp_counter.to_str())
        self.temp_counter = add(self.temp_counter, 1)
        return name
    }
}

// Convert TIL type to C type
til_type_to_c := func(til_type: ValueType) returns Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq("I64") { return "long long" }
        else if name.eq("Bool") { return "unsigned char" }
        else if name.eq("U8") { return "unsigned char" }
        else if name.eq("Str") { return "const char*" }
        else { return name }  // Assume struct type
    case:
        return "int"  // Default
    }
}

// Helper to get C type name for a ValueType (same as til_type_to_c but for error struct definitions)
value_type_to_c_name := func(vt: ValueType) returns Str {
    switch vt {
    case ValueType.TCustom(name):
        if name.eq("I64") { return "long long" }
        else if name.eq("Bool") { return "unsigned char" }
        else if name.eq("U8") { return "unsigned char" }
        else if name.eq("Str") { return "const char*" }
        else { return name }  // struct/error types
    case:
        return "int"
    }
}

// Collect function throw types from AST into context
// Handles both top-level functions and struct methods
collect_func_throw_types := proc(expr: Expr, mut ctx: CodegenContext) throws Str {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Top-level function
                if gt(func_def.throw_types.len(), 0) {
                    ctx.func_throw_types.insert(decl.name, func_def.throw_types)
                }
            case NodeType.StructDef(struct_def):
                // Struct methods - use mangled names (StructName_methodName)
                mut struct_name := decl.name
                mut keys := struct_def.default_values.keys
                mut i := 0
                while lt(i, keys.len()) {
                    mut member_name := ""
                    keys.get(i, member_name)
                    mut default_expr := Expr()
                    struct_def.default_values.get(member_name, default_expr)
                    switch default_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        if gt(func_def.throw_types.len(), 0) {
                            mut mangled_name := concat(struct_name, "_")
                            mangled_name = concat(mangled_name, member_name)
                            ctx.func_throw_types.insert(mangled_name, func_def.throw_types)
                        }
                    case:
                        // Not a function, skip
                    }
                    catch (err: KeyNotFoundError) { /* skip */ }
                    catch (err: AllocError) { throw err.msg }
                    catch (err: DuplicatedKeyError) { /* skip duplicates */ }
                    i = add(i, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
            case:
                // Not a function or struct, skip
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
            catch (err: DuplicatedKeyError) { /* skip duplicates */ }
        }
    case:
        // Not a declaration, skip
    }
}

// Emit function signature (used by both prototype and definition)
// For throwing functions:
//   int func_name(RetType* _ret, Error1* _err1, Error2* _err2, args...)
// For non-throwing:
//   RetType func_name(args...)
emit_func_signature := proc(func_name: Str, func_def: SFuncDef, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut is_throwing := gt(func_def.throw_types.len(), 0)

    if is_throwing {
        // Throwing function returns int status code
        result = concat(result, "int ")
    } else {
        // Non-throwing function returns its actual type
        if eq(func_def.return_types.len(), 0) {
            result = concat(result, "void ")
        } else {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = concat(result, til_type_to_c(ret_type))
            result = concat(result, " ")
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }
    }

    result = concat(result, func_name)
    result = concat(result, "(")

    mut param_count := 0

    if is_throwing {
        // Output params first: return value pointer, then error pointers
        if gt(func_def.return_types.len(), 0) {
            mut ret_type := ValueType.TCustom("")
            func_def.return_types.get(0, ret_type)
            result = concat(result, til_type_to_c(ret_type))
            result = concat(result, "* _ret")
            param_count = add(param_count, 1)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        // Error output parameters
        mut i := 0
        while lt(i, func_def.throw_types.len()) {
            if gt(param_count, 0) {
                result = concat(result, ", ")
            }
            mut throw_type := ValueType.TCustom("")
            func_def.throw_types.get(i, throw_type)
            mut err_type := value_type_to_c_name(throw_type)
            result = concat(result, err_type)
            result = concat(result, "* _err")
            result = concat(result, add(i, 1).to_str())
            param_count = add(param_count, 1)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    // Input parameters
    mut j := 0
    while lt(j, func_def.args.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        mut arg := Declaration()
        func_def.args.get(j, arg)
        result = concat(result, til_type_to_c(arg.value_type))
        result = concat(result, " ")
        result = concat(result, arg.name)
        param_count = add(param_count, 1)
        j = add(j, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    if eq(param_count, 0) {
        result = concat(result, "void")
    }

    result = concat(result, ")")
    return result
}

// Get the function name from an FCall expression
get_fcall_func_name := func(expr: Expr) returns Str {
    if eq(expr.params.len(), 0) {
        return ""
    }

    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { return "" }

    switch first.node_type {
    case NodeType.Identifier(name):
        if eq(first.params.len(), 0) {
            // Regular function call
            return name
        } else {
            // UFCS: receiver.method() - check for type-qualified call
            mut nested := Expr()
            first.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch nested.node_type {
            case NodeType.Identifier(method_name):
                // Check if receiver is PascalCase (type-qualified)
                mut first_char := name.get_substr(0, 1)
                if first_char.is_uppercase() {
                    // Type-qualified: Type.method -> Type_method
                    mut mangled := concat(name, "_")
                    mangled = concat(mangled, method_name)
                    return mangled
                }
                catch (err: IndexOutOfBoundsError) { return method_name }
                catch (err: AllocError) { return method_name }
                return method_name
            case:
                return ""
            }
        }
    case:
        return ""
    }
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Check if an expression is an enum declaration (Name := enum {...})
is_enum_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a struct declaration as a C typedef struct (only mut fields become struct fields)
emit_struct_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                result = concat(result, "typedef struct {\n")
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit mut fields as struct members
                    if member.is_mut {
                        result = concat(result, "    ")
                        result = concat(result, til_type_to_c(member.value_type))
                        result = concat(result, " ")
                        result = concat(result, member.name)
                        result = concat(result, ";\n")
                    }
                    i = add(i, 1)
                }
                result = concat(result, "} ")
                result = concat(result, decl.name)
                result = concat(result, ";\n\n")
                return result
            case:
                throw "emit_struct_declaration: not a struct"
            }
        }
        throw "emit_struct_declaration: empty params"
    case:
        throw "emit_struct_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
emit_struct_constants := proc(expr: Expr, output: Str, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        // Check if default_value is NOT a function (constants only)
                        mut is_func := false
                        mut default_val := Expr()
                        struct_def.default_values.get(member.name, default_val)
                        switch default_val.node_type {
                        case NodeType.FuncDef(fd):
                            is_func = true
                        case:
                            is_func = false
                        }
                        if not(is_func) {
                            result = concat(result, til_type_to_c(member.value_type))
                            result = concat(result, " ")
                            result = concat(result, struct_name)
                            result = concat(result, "_")
                            result = concat(result, member.name)
                            result = concat(result, " = ")
                            result = emit_expr(default_val, result, 0, ctx)
                            result = concat(result, ";\n")
                        }
                        catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Check if an enum has any payloads
enum_has_payloads := func(enum_def: SEnumDef) returns Bool {
    mut keys := enum_def.enum_map.keys
    mut i := 0
    while lt(i, keys.len()) {
        mut key := ""
        keys.get(i, key)
        catch (err: IndexOutOfBoundsError) { return false }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(key, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }
        // Check if payload_type is not the default empty value
        switch payload_type {
        case ValueType.TCustom(name):
            if gt(name.len(), 0) {
                return true
            }
        case:
            return true  // Any non-TCustom type means it has a payload
        }
        i = add(i, 1)
    }
    return false
}

// Check if a variant has a payload (non-empty type)
variant_has_payload := func(payload_type: ValueType) returns Bool {
    switch payload_type {
    case ValueType.TCustom(name):
        return gt(name.len(), 0)
    case:
        return true  // Any non-TCustom type means it has a payload
    }
}

// Emit an enum with payloads as a tagged union
emit_enum_with_payloads := proc(enum_name: Str, enum_def: SEnumDef, output: Str) returns Str throws Str {
    mut result := output
    mut variants := enum_def.enum_map.keys

    // 1. Emit tag enum: typedef enum { Color_Unknown = 0, ... } Color_Tag;
    result = concat(result, "typedef enum {\n")
    mut i := 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, "_")
        result = concat(result, variant_name)
        result = concat(result, " = ")
        result = concat(result, i.to_str())
        result = concat(result, ",\n")
        i = add(i, 1)
    }
    result = concat(result, "} ")
    result = concat(result, enum_name)
    result = concat(result, "_Tag;\n\n")

    // 2. Emit payload union (only for variants that have payloads)
    // typedef union { unsigned char Green; long long Number; } Color_Payload;
    mut has_any_payload := false
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(variant_name, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }
        if variant_has_payload(payload_type) {
            has_any_payload = true
        }
        i = add(i, 1)
    }

    if has_any_payload {
        result = concat(result, "typedef union {\n")
        i = 0
        while lt(i, variants.len()) {
            mut variant_name := ""
            variants.get(i, variant_name)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            mut payload_type := ValueType.TCustom("")
            enum_def.enum_map.get(variant_name, payload_type)
            catch (err: KeyNotFoundError) { /* no payload */ }
            if variant_has_payload(payload_type) {
                result = concat(result, "    ")
                result = concat(result, til_type_to_c(payload_type))
                result = concat(result, " ")
                result = concat(result, variant_name)
                result = concat(result, ";\n")
            }
            i = add(i, 1)
        }
        result = concat(result, "} ")
        result = concat(result, enum_name)
        result = concat(result, "_Payload;\n\n")
    }

    // 3. Emit wrapper struct: typedef struct { Color_Tag tag; Color_Payload payload; } Color;
    result = concat(result, "typedef struct {\n")
    result = concat(result, "    ")
    result = concat(result, enum_name)
    result = concat(result, "_Tag tag;\n")
    if has_any_payload {
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, "_Payload payload;\n")
    }
    result = concat(result, "} ")
    result = concat(result, enum_name)
    result = concat(result, ";\n\n")

    // 4. Emit constructor functions for ALL variants (including no-payload ones)
    // This ensures consistent calling convention: Color_make_Red(42), Color_make_Unknown()
    i = 0
    while lt(i, variants.len()) {
        mut variant_name := ""
        variants.get(i, variant_name)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        mut payload_type := ValueType.TCustom("")
        enum_def.enum_map.get(variant_name, payload_type)
        catch (err: KeyNotFoundError) { /* no payload */ }

        result = concat(result, "static inline ")
        result = concat(result, enum_name)
        result = concat(result, " ")
        result = concat(result, enum_name)
        result = concat(result, "_make_")
        result = concat(result, variant_name)
        result = concat(result, "(")

        // Parameter for payload (if any)
        if variant_has_payload(payload_type) {
            result = concat(result, til_type_to_c(payload_type))
            result = concat(result, " value) {\n")
        } else {
            result = concat(result, "void) {\n")
        }

        // Constructor body
        result = concat(result, "    ")
        result = concat(result, enum_name)
        result = concat(result, " result = { .tag = ")
        result = concat(result, enum_name)
        result = concat(result, "_")
        result = concat(result, variant_name)
        result = concat(result, " };\n")

        // Set payload if present
        if variant_has_payload(payload_type) {
            result = concat(result, "    result.payload.")
            result = concat(result, variant_name)
            result = concat(result, " = value;\n")
        }

        result = concat(result, "    return result;\n")
        result = concat(result, "}\n\n")

        i = add(i, 1)
    }

    return result
}

// Emit an enum declaration as a C typedef enum (for simple enums without payloads)
// or as a tagged union struct (for enums with payloads)
emit_enum_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.EnumDef(enum_def):
                mut enum_name := decl.name

                if enum_has_payloads(enum_def) {
                    // Phase 2: Enums with payloads - tagged union
                    return emit_enum_with_payloads(enum_name, enum_def, result)
                }

                // Phase 1: Simple enum without payloads
                // typedef enum { EnumName_Variant1 = 0, ... } EnumName;
                result = concat(result, "typedef enum {\n")

                // Get variant names (order matches insertion order from parser)
                mut variants := enum_def.enum_map.keys

                mut i := 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = concat(result, "    ")
                    result = concat(result, enum_name)
                    result = concat(result, "_")
                    result = concat(result, variant_name)
                    result = concat(result, " = ")
                    result = concat(result, i.to_str())
                    result = concat(result, ",\n")
                    i = add(i, 1)
                }

                result = concat(result, "} ")
                result = concat(result, enum_name)
                result = concat(result, ";\n\n")

                // Generate constructor functions for consistency with payload enums
                // static inline EnumName EnumName_make_Variant(void) { return EnumName_Variant; }
                i = 0
                while lt(i, variants.len()) {
                    mut variant_name := ""
                    variants.get(i, variant_name)
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    result = concat(result, "static inline ")
                    result = concat(result, enum_name)
                    result = concat(result, " ")
                    result = concat(result, enum_name)
                    result = concat(result, "_make_")
                    result = concat(result, variant_name)
                    result = concat(result, "(void) { return ")
                    result = concat(result, enum_name)
                    result = concat(result, "_")
                    result = concat(result, variant_name)
                    result = concat(result, "; }\n")
                    i = add(i, 1)
                }
                result = concat(result, "\n")

                return result
            case:
                throw "emit_enum_declaration: not an enum"
            }
        }
        throw "emit_enum_declaration: empty params"
    case:
        throw "emit_enum_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function prototypes with mangled names: StructName_funcname
emit_struct_func_prototypes := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Use emit_func_signature with mangled name
                            mut mangled_name := concat(struct_name, "_")
                            mangled_name = concat(mangled_name, member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = concat(result, ";\n")
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function bodies with mangled names: StructName_funcname
emit_struct_func_bodies := proc(expr: Expr, output: Str, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Set current function context
                            ctx.current_throw_types = func_def.throw_types
                            ctx.current_return_types = func_def.return_types

                            // Use emit_func_signature with mangled name
                            mut mangled_name := concat(struct_name, "_")
                            mangled_name = concat(mangled_name, member.name)
                            result = emit_func_signature(mangled_name, func_def, result, ctx)
                            result = concat(result, " {\n")

                            // Emit function body with catch pattern detection
                            result = emit_stmts(func_def.body, result, 1, ctx)

                            // For throwing void functions, add implicit return 0
                            if gt(func_def.throw_types.len(), 0) {
                                if eq(func_def.return_types.len(), 0) {
                                    result = concat(result, "    return 0;\n")
                                }
                            }

                            result = concat(result, "}\n\n")

                            // Clear current function context
                            ctx.current_throw_types = Vec.new(ValueType)
                            ctx.current_return_types = Vec.new(ValueType)
                            catch (err: AllocError) { throw err.msg }
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* skip member with no default */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr) returns Str throws Str {
    mut output := ""
    mut ctx := CodegenContext()

    // C boilerplate
    output = concat(output, "#include <stdio.h>\n")
    output = concat(output, "#include <stdlib.h>\n")
    output = concat(output, "#include <string.h>\n")
    output = concat(output, "#include <stdbool.h>\n\n")

    // Pass 0: collect function throw types for call-site generation
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            collect_func_throw_types(child, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip collect pass
    }

    // Pass 1: emit struct definitions (only mut fields become struct members)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_declaration(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct pass
    }

    // Pass 1b: emit enum definitions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_enum_declaration(child) {
                output = emit_enum_declaration(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip enum pass
    }

    // Pass 2: emit struct constants (non-mut, non-function fields with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_constants(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip constants pass
    }
    output = concat(output, "\n")

    // Pass 3: emit function prototypes (forward declarations)
    // 3a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_prototype(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip prototype pass
    }
    // 3b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_prototypes(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func prototype pass
    }
    output = concat(output, "\n")

    // Pass 4: emit function definitions
    // 4a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_declaration(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip function pass
    }
    // 4b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_bodies(child, output, ctx)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func body pass
    }

    // Main function
    output = concat(output, "int main() {\n")

    // Pass 5: emit non-struct, non-function, non-enum statements
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if not(is_func_declaration(child)) {
                if not(is_struct_declaration(child)) {
                    if not(is_enum_declaration(child)) {
                        output = emit_expr(child, output, 1, ctx)
                    }
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, emit directly
        output = emit_expr(ast, output, 1, ctx)
    }

    output = concat(output, "    return 0;\n")
    output = concat(output, "}\n")

    return output
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, output: Str, ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = concat(result, ";\n")
                return result
            case:
                throw "emit_func_prototype: not a function"
            }
        }
        throw "emit_func_prototype: empty params"
    case:
        throw "emit_func_prototype: not a declaration"
    }
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, output: Str, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Set current function context for return/throw generation
                ctx.current_throw_types = func_def.throw_types
                ctx.current_return_types = func_def.return_types

                // Use emit_func_signature for both throwing and non-throwing functions
                result = emit_func_signature(decl.name, func_def, result, ctx)
                result = concat(result, " {\n")

                // Emit function body with catch pattern detection
                result = emit_stmts(func_def.body, result, 1, ctx)

                // For throwing void functions, add implicit return 0
                if gt(func_def.throw_types.len(), 0) {
                    if eq(func_def.return_types.len(), 0) {
                        result = concat(result, "    return 0;\n")
                    }
                }

                result = concat(result, "}\n\n")

                // Clear current function context
                ctx.current_throw_types = Vec.new(ValueType)
                ctx.current_return_types = Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }

                return result
            case:
                throw "emit_func_declaration: not a function"
            }
        }
        throw "emit_func_declaration: empty params"
    case:
        throw "emit_func_declaration: not a declaration"
    }
}

emit_if := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if lt(expr.params.len(), 2) {
        throw "codegen_c: If requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "if (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0, ctx)
    result = concat(result, ") {\n")

    // Then body
    mut then_body := Expr()
    expr.params.get(1, then_body)
    result = emit_body(then_body, result, add(indent, 1), ctx)

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}")

    // Else branch (optional)
    if gt(expr.params.len(), 2) {
        mut else_part := Expr()
        expr.params.get(2, else_part)
        switch else_part.node_type {
        case NodeType.If:
            // else-if: emit inline
            result = concat(result, " else ")
            result = emit_if(else_part, result, indent, ctx)
        case:
            // else block
            result = concat(result, " else {\n")
            result = emit_body(else_part, result, add(indent, 1), ctx)
            i = 0
            while lt(i, indent) {
                result = concat(result, "    ")
                i = add(i, 1)
            }
            result = concat(result, "}\n")
        }
    } else {
        result = concat(result, "\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

emit_while := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    // While: params[0] = condition, params[1] = body
    if lt(expr.params.len(), 2) {
        throw "codegen_c: While requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "while (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0, ctx)
    result = concat(result, ") {\n")

    // Body
    mut body := Expr()
    expr.params.get(1, body)
    result = emit_body(body, result, add(indent, 1), ctx)

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

// Result struct for variant info extraction
VariantInfo := struct {
    mut type_name: Str = ""
    mut variant_name: Str = ""
}

// Extract enum type and variant names from a case pattern expression
// For FCall: Type.Variant -> VariantInfo { type_name: "Type", variant_name: "Variant" }
get_case_variant_info := func(expr: Expr) returns VariantInfo {
    mut result := VariantInfo()
    switch expr.node_type {
    case NodeType.FCall:
        // FCall for Type.Variant (without payload extraction)
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return result }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                if gt(first.params.len(), 0) {
                    mut nested := Expr()
                    first.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return result }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        result.type_name = type_name
                        result.variant_name = variant_name
                        return result
                    case:
                        return result
                    }
                }
                return result
            case:
                return result
            }
        }
        return result
    case NodeType.Identifier(name):
        // Identifier with nested params: Type.Variant
        if gt(expr.params.len(), 0) {
            mut nested := Expr()
            expr.params.get(0, nested)
            catch (err: IndexOutOfBoundsError) {
                result.variant_name = name
                return result
            }
            switch nested.node_type {
            case NodeType.Identifier(variant_name):
                result.type_name = name
                result.variant_name = variant_name
                return result
            case:
                result.variant_name = name
                return result
            }
        }
        result.variant_name = name
        return result
    case:
        return result
    }
}

// Extract type name and variant name from a Pattern's variant_name (e.g., "Color.Green")
parse_pattern_variant_name := func(variant_name: Str) returns VariantInfo {
    mut result := VariantInfo()
    mut dot_pos := variant_name.rfind(".")
    if gteq(dot_pos, 0) {
        result.type_name = variant_name.get_substr(0, dot_pos)
        result.variant_name = variant_name.get_substr(add(dot_pos, 1), variant_name.len())
        catch (err: IndexOutOfBoundsError) {
            result.variant_name = variant_name
        }
        catch (err: AllocError) {
            result.variant_name = variant_name
        }
        return result
    }
    // No dot - just variant name (shouldn't happen in practice)
    result.variant_name = variant_name
    return result
}

emit_switch := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    // Switch: params[0] = switch expression
    // params[1..] = alternating (case_pattern, body) pairs
    if eq(expr.params.len(), 0) {
        throw "codegen_c: Switch requires expression"
    }

    mut result := output

    // Indentation strings
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    mut case_indent := ""
    ind = 0
    while lt(ind, add(indent, 1)) {
        case_indent = concat(case_indent, "    ")
        ind = add(ind, 1)
    }

    mut body_indent := ""
    ind = 0
    while lt(ind, add(indent, 2)) {
        body_indent = concat(body_indent, "    ")
        ind = add(ind, 1)
    }

    // Get the switch expression
    mut switch_expr := Expr()
    expr.params.get(0, switch_expr)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Emit: switch (expr.tag) {
    result = concat(result, indent_str)
    result = concat(result, "switch (")
    result = emit_expr(switch_expr, result, 0, ctx)
    result = concat(result, ".tag) {\n")

    // Process case patterns and bodies in pairs
    mut i := 1
    while lt(i, expr.params.len()) {
        mut case_pattern := Expr()
        expr.params.get(i, case_pattern)
        catch (err: IndexOutOfBoundsError) { throw err.msg }

        mut has_body := lt(add(i, 1), expr.params.len())

        switch case_pattern.node_type {
        case NodeType.DefaultCase:
            // default: { ... break; }
            result = concat(result, case_indent)
            result = concat(result, "default: {\n")
            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        case NodeType.Pattern(pattern_info):
            // case Type_Variant: { PayloadType binding = expr.payload.Variant; ... break; }
            mut info := parse_pattern_variant_name(pattern_info.variant_name)

            result = concat(result, case_indent)
            result = concat(result, "case ")
            result = concat(result, info.type_name)
            result = concat(result, "_")
            result = concat(result, info.variant_name)
            result = concat(result, ": {\n")

            // Emit payload extraction: PayloadType binding_var = expr.payload.VariantName;
            result = concat(result, body_indent)
            result = concat(result, "__auto_type ")
            result = concat(result, pattern_info.binding_var)
            result = concat(result, " = ")
            result = emit_expr(switch_expr, result, 0, ctx)
            result = concat(result, ".payload.")
            result = concat(result, info.variant_name)
            result = concat(result, ";\n")

            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        case:
            // Regular case: Type.Variant -> case Type_Variant: { ... break; }
            mut info := get_case_variant_info(case_pattern)

            result = concat(result, case_indent)
            result = concat(result, "case ")
            if gt(info.type_name.len(), 0) {
                result = concat(result, info.type_name)
                result = concat(result, "_")
            }
            result = concat(result, info.variant_name)
            result = concat(result, ": {\n")

            if has_body {
                mut case_body := Expr()
                expr.params.get(add(i, 1), case_body)
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = emit_body(case_body, result, add(indent, 2), ctx)
            }
            result = concat(result, body_indent)
            result = concat(result, "break;\n")
            result = concat(result, case_indent)
            result = concat(result, "}\n")
        }

        i = add(i, 2)  // Move to next case pattern
    }

    result = concat(result, indent_str)
    result = concat(result, "}\n")

    return result
}

emit_expr := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Body:
        return emit_body(expr, output, indent, ctx)
    case NodeType.FCall:
        return emit_fcall(expr, output, indent, ctx)
    case NodeType.LLiteral(lit):
        return emit_literal(lit, output)
    case NodeType.Declaration(decl):
        return emit_declaration(decl.name, decl.is_mut, expr, output, indent, ctx)
    case NodeType.Identifier(name):
        // Check for type-qualified access (Type.field)
        if gt(expr.params.len(), 0) {
            mut first_char := name.get_substr(0, 1)
            if first_char.is_uppercase() {
                mut param := Expr()
                expr.params.get(0, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    mut field_first_char := field.get_substr(0, 1)
                    if field_first_char.is_uppercase() {
                        // Enum variant: Type.Variant -> Type_make_Variant()
                        mut result := concat(output, name)
                        result = concat(result, "_make_")
                        result = concat(result, field)
                        result = concat(result, "()")
                        return result
                    } else {
                        // Type-qualified constant: Type.constant -> Type_constant
                        mut result := concat(output, name)
                        result = concat(result, "_")
                        result = concat(result, field)
                        return result
                    }
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                    catch (err: AllocError) { throw err.msg }
                case:
                    // Fall through to regular handling
                }
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        // Regular identifier or field access (b.val -> b.val)
        mut result := concat(output, name)
        mut i := 0
        while lt(i, expr.params.len()) {
            mut param := Expr()
            expr.params.get(i, param)
            switch param.node_type {
            case NodeType.Identifier(field):
                result = concat(result, ".")
                result = concat(result, field)
            case:
                // Not a field access
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    case NodeType.FuncDef(func_def):
        return emit_funcdef(func_def, expr, output, indent, ctx)
    case NodeType.Assignment(name):
        return emit_assignment(name, expr, output, indent, ctx)
    case NodeType.Return:
        return emit_return(expr, output, indent, ctx)
    case NodeType.If:
        return emit_if(expr, output, indent, ctx)
    case NodeType.While:
        return emit_while(expr, output, indent, ctx)
    case NodeType.Catch:
        // Catch blocks handled at call site in emit_stmts
        return output
    case NodeType.Throw:
        return emit_throw(expr, output, indent, ctx)
    case NodeType.StructDef(s):
        throw "codegen_c: StructDef should be handled at top level, not in emit_expr"
    case NodeType.EnumDef(e):
        throw "codegen_c: EnumDef not yet supported"
    case NodeType.Switch:
        return emit_switch(expr, output, indent, ctx)
    case NodeType.DefaultCase:
        throw "codegen_c: DefaultCase should be handled inside emit_switch"
    case NodeType.Range:
        throw "codegen_c: Range not yet supported"
    case NodeType.Pattern(p):
        throw "codegen_c: Pattern not yet supported"
    }
}

emit_body := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    return emit_stmts(expr.params, output, indent, ctx)
}

// Emit a sequence of statements with catch pattern detection
// This is the core logic for handling throw/catch at call sites
emit_stmts := proc(stmts: Vec, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut i := 0

    while lt(i, stmts.len()) {
        mut stmt := Expr()
        stmts.get(i, stmt)

        // Check if this statement is followed by catch blocks
        // And if it's a call to a throwing function (FCall or Declaration with FCall)
        mut maybe_fcall := Expr()
        mut has_fcall := false
        mut maybe_decl_name := ""
        mut has_decl := false

        switch stmt.node_type {
        case NodeType.FCall:
            maybe_fcall = stmt
            has_fcall = true
        case NodeType.Declaration(decl):
            // Check if declaration has an FCall as initializer
            if gt(stmt.params.len(), 0) {
                mut first := Expr()
                stmt.params.get(0, first)
                switch first.node_type {
                case NodeType.FCall:
                    maybe_fcall = first
                    has_fcall = true
                    maybe_decl_name = decl.name
                    has_decl = true
                case:
                    // Not an FCall
                }
                catch (err: IndexOutOfBoundsError) { /* no initializer */ }
            }
        case:
            // Not FCall or Declaration
        }

        if has_fcall {
            // Get function name from the FCall
            mut func_name := get_fcall_func_name(maybe_fcall)

            // Check if this function is a throwing function
            if gt(func_name.len(), 0) {
                mut throw_types := Vec.new(ValueType)
                catch (err: AllocError) { throw err.msg }
                mut is_throwing := false
                ctx.func_throw_types.get(func_name, throw_types)
                is_throwing = gt(throw_types.len(), 0)
                catch (err: KeyNotFoundError) { is_throwing = false }

                if is_throwing {
                    // Collect subsequent catch blocks
                    mut catch_blocks := Vec.new(Expr)
                    catch (err: AllocError) { throw err.msg }
                    mut j := add(i, 1)
                    while lt(j, stmts.len()) {
                        mut next_stmt := Expr()
                        stmts.get(j, next_stmt)
                        switch next_stmt.node_type {
                        case NodeType.Catch:
                            catch_blocks.push(next_stmt)
                            catch (err: AllocError) { throw err.msg }
                            j = add(j, 1)
                        case:
                            // Not a catch block, stop
                            j = stmts.len()  // break out of loop
                        }
                        catch (err: IndexOutOfBoundsError) { j = stmts.len() }
                    }

                    if gt(catch_blocks.len(), 0) {
                        // Emit throwing call with catch handling
                        if has_decl {
                            result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, maybe_decl_name, result, indent, ctx)
                        } else {
                            result = emit_throwing_call(maybe_fcall, throw_types, catch_blocks, "", result, indent, ctx)
                        }
                        i = add(i, add(1, catch_blocks.len()))  // Skip past catch blocks
                    } else {
                        // No catch blocks, emit regular statement
                        result = emit_expr(stmt, result, indent, ctx)
                        i = add(i, 1)
                    }
                } else {
                    // Not a throwing function, emit regular statement
                    result = emit_expr(stmt, result, indent, ctx)
                    i = add(i, 1)
                }
            } else {
                // Couldn't get function name, emit regular statement
                result = emit_expr(stmt, result, indent, ctx)
                i = add(i, 1)
            }
        } else {
            // Regular statement handling
            result = emit_expr(stmt, result, indent, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }
    return result
}

// Emit a call to a throwing function with catch handling
// Generates: declare temps, call func, if/else chain for error handling
emit_throwing_call := proc(fcall: Expr, throw_types: Vec, catch_blocks: Vec, decl_name: Str, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output

    // Generate indentation string
    mut indent_str := ""
    mut ind := 0
    while lt(ind, indent) {
        indent_str = concat(indent_str, "    ")
        ind = add(ind, 1)
    }

    // Get function name
    mut func_name := get_fcall_func_name(fcall)
    if eq(func_name.len(), 0) {
        throw "emit_throwing_call: could not get function name"
    }

    // Generate unique temp name for this call
    mut temp_suffix := ctx.next_temp()

    // Declare local variables for return value and errors
    // For now, assume int return type (TODO: get actual return type from context)
    if gt(decl_name.len(), 0) {
        result = concat(result, indent_str)
        result = concat(result, "int _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
    }

    // Declare error structs for each throw type
    mut i := 0
    while lt(i, throw_types.len()) {
        mut throw_type := ValueType.TCustom("")
        throw_types.get(i, throw_type)
        switch throw_type {
        case ValueType.TCustom(type_name):
            result = concat(result, indent_str)
            result = concat(result, type_name)
            result = concat(result, " _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = {0};\n")
        case:
            // Non-custom type, use int
            result = concat(result, indent_str)
            result = concat(result, "int _err")
            result = concat(result, i.to_str())
            result = concat(result, "_")
            result = concat(result, temp_suffix)
            result = concat(result, " = 0;\n")
        }
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    // Generate the function call with output parameters
    result = concat(result, indent_str)
    result = concat(result, "int _status_")
    result = concat(result, temp_suffix)
    result = concat(result, " = ")
    result = concat(result, func_name)
    result = concat(result, "(")

    // First: return value pointer (if function returns something)
    mut param_count := 0
    if gt(decl_name.len(), 0) {
        result = concat(result, "&_ret_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
    }

    // Then: error pointers
    i = 0
    while lt(i, throw_types.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        result = concat(result, "&_err")
        result = concat(result, i.to_str())
        result = concat(result, "_")
        result = concat(result, temp_suffix)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }

    // Then: actual arguments (skip the function name which is params[0])
    i = 1
    while lt(i, fcall.params.len()) {
        if gt(param_count, 0) {
            result = concat(result, ", ")
        }
        mut arg := Expr()
        fcall.params.get(i, arg)
        result = emit_expr(arg, result, 0, ctx)
        param_count = add(param_count, 1)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = concat(result, ");\n")

    // Generate if/else chain for error handling
    result = concat(result, indent_str)
    result = concat(result, "if (_status_")
    result = concat(result, temp_suffix)
    result = concat(result, " == 0) {\n")

    // Success case: assign return value to declared variable
    if gt(decl_name.len(), 0) {
        mut inner_indent := ""
        ind = 0
        while lt(ind, add(indent, 1)) {
            inner_indent = concat(inner_indent, "    ")
            ind = add(ind, 1)
        }
        result = concat(result, inner_indent)
        result = concat(result, "int ")
        result = concat(result, decl_name)
        result = concat(result, " = _ret_")
        result = concat(result, temp_suffix)
        result = concat(result, ";\n")
        // Note: var_name goes out of scope at end of if block
        // This is a limitation - complex code might need refactoring
    }

    result = concat(result, indent_str)
    result = concat(result, "}")

    // Generate else-if branches for each catch block
    i = 0
    while lt(i, catch_blocks.len()) {
        mut catch_block := Expr()
        catch_blocks.get(i, catch_block)

        // Get the error type index from status code (i+1)
        result = concat(result, " else if (_status_")
        result = concat(result, temp_suffix)
        result = concat(result, " == ")
        result = concat(result, add(i, 1).to_str())
        result = concat(result, ") {\n")

        // Emit catch block body
        // The catch block params should have the binding variable and body
        if gt(catch_block.params.len(), 0) {
            // Get binding info - catch params[0] is the error binding expr, params[1..] is the body
            mut k := 1
            while lt(k, catch_block.params.len()) {
                mut body_stmt := Expr()
                catch_block.params.get(k, body_stmt)
                result = emit_expr(body_stmt, result, add(indent, 1), ctx)
                k = add(k, 1)
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
        }

        result = concat(result, indent_str)
        result = concat(result, "}")

        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    result = concat(result, "\n")
    return result
}

// Emit a throw statement
// For throwing functions: *_errN = value; return N;
emit_throw := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output

    // Generate indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Get throw value if present
    if gt(expr.params.len(), 0) {
        mut throw_value := Expr()
        expr.params.get(0, throw_value)

        // Find which error type this throw corresponds to
        // For now, assume it's the first error type (index 1)
        // TODO: Match throw type to the correct error index
        result = concat(result, "*_err1 = ")
        result = emit_expr(throw_value, result, 0, ctx)
        result = concat(result, ";\n")

        ind = 0
        while lt(ind, indent) {
            result = concat(result, "    ")
            ind = add(ind, 1)
        }
        result = concat(result, "return 1;\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    } else {
        // Throw with no value - just return error status
        result = concat(result, "return 1;\n")
    }

    return result
}

// Check if an expression is a struct construction call (TypeName())
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                // If it's a PascalCase identifier with no nested params and no other args, assume struct
                if gt(name.len(), 0) {
                    // Check if first character is uppercase
                    mut first_char := name.get_substr(0, 1)
                    if first_char.is_uppercase() {
                        if eq(expr.params.len(), 1) {
                            if eq(first.params.len(), 0) {
                                return name
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

// Check if an expression is an enum construction (Type.Variant or Type.Variant(value))
// Returns the type name if it is, empty string otherwise
// AST structure for Color.Red(42): FCall -> [Identifier("Color") -> [Identifier("Red")], Literal(42)]
// AST structure for Color.Unknown: Identifier("Color") -> [Identifier("Unknown")]
get_enum_construction_type := func(expr: Expr) returns Str {
    // Check FCall case: Type.Variant(value) or Type.Variant()
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(type_name):
                // Check if the type name is PascalCase
                if gt(type_name.len(), 0) {
                    mut type_first_char := type_name.get_substr(0, 1)
                    if type_first_char.is_uppercase() {
                        // Check if there's a nested identifier (the variant) that's also PascalCase
                        if gt(first.params.len(), 0) {
                            mut nested := Expr()
                            first.params.get(0, nested)
                            catch (err: IndexOutOfBoundsError) { return "" }
                            switch nested.node_type {
                            case NodeType.Identifier(variant_name):
                                if gt(variant_name.len(), 0) {
                                    mut variant_first_char := variant_name.get_substr(0, 1)
                                    if variant_first_char.is_uppercase() {
                                        return type_name
                                    }
                                    catch (err: IndexOutOfBoundsError) { return "" }
                                    catch (err: AllocError) { return "" }
                                }
                                return ""
                            case:
                                return ""
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case NodeType.Identifier(type_name):
        // Check Identifier case: Type.Variant (no parentheses, no payload)
        if gt(type_name.len(), 0) {
            mut type_first_char := type_name.get_substr(0, 1)
            if type_first_char.is_uppercase() {
                if gt(expr.params.len(), 0) {
                    mut nested := Expr()
                    expr.params.get(0, nested)
                    catch (err: IndexOutOfBoundsError) { return "" }
                    switch nested.node_type {
                    case NodeType.Identifier(variant_name):
                        if gt(variant_name.len(), 0) {
                            mut variant_first_char := variant_name.get_substr(0, 1)
                            if variant_first_char.is_uppercase() {
                                return type_name
                            }
                            catch (err: IndexOutOfBoundsError) { return "" }
                            catch (err: AllocError) { return "" }
                        }
                        return ""
                    case:
                        return ""
                    }
                }
            }
            catch (err: IndexOutOfBoundsError) { return "" }
            catch (err: AllocError) { return "" }
        }
        return ""
    case:
        return ""
    }
}

emit_declaration := proc(name: Str, is_mut: Bool, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Check if this is a function definition - skip in main pass
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            // Skip - already emitted before main
            return output
        case NodeType.StructDef(struct_def):
            // Skip - already emitted before functions
            return output
        case:
            // Continue with normal declaration
        }
    }

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        struct_type = get_struct_construction_type(first)
    }

    // Check if this is an enum construction (Type.Variant or Type.Variant(value))
    mut enum_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        enum_type = get_enum_construction_type(first)
    }

    if gt(struct_type.len(), 0) {
        // Struct variable declaration
        result = concat(result, struct_type)
        result = concat(result, " ")
        result = concat(result, name)
        result = concat(result, " = {0};\n")
    } else if gt(enum_type.len(), 0) {
        // Enum variable declaration
        result = concat(result, enum_type)
        result = concat(result, " ")
        result = concat(result, name)
        result = concat(result, " = ")
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx)
        result = concat(result, ";\n")
    } else if is_mut {
        result = concat(result, "int ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx)
        }
        result = concat(result, ";\n")
    } else {
        result = concat(result, "const int ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx)
        }
        result = concat(result, ";\n")
    }
    return result
}

emit_funcdef := proc(func_def: SFuncDef, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    // Inline function body (shouldn't be called for top-level funcs)
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "{\n")
    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, params_len) {
        mut stmt := Expr()
        expr.params.get(i, stmt)
        result = emit_expr(stmt, result, add(indent, 1), ctx)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    ind = 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "}\n")
    return result
}

emit_assignment := proc(name: Str, expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, name)
    result = concat(result, " = ")
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0, ctx)
    }
    result = concat(result, ";\n")
    return result
}

emit_return := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Check if we're in a throwing function
    if gt(ctx.current_throw_types.len(), 0) {
        // Throwing function: *_ret = value; return 0;
        if gt(expr.params.len(), 0) {
            result = concat(result, "*_ret = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx)
            result = concat(result, ";\n")
            ind = 0
            while lt(ind, indent) {
                result = concat(result, "    ")
                ind = add(ind, 1)
            }
        }
        result = concat(result, "return 0;\n")
    } else {
        // Non-throwing function: regular return
        result = concat(result, "return")
        if gt(expr.params.len(), 0) {
            result = concat(result, " ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0, ctx)
        }
        result = concat(result, ";\n")
    }
    return result
}

emit_fcall := proc(expr: Expr, output: Str, indent: I64, mut ctx: CodegenContext) returns Str throws Str {
    // First param is the function name (or UFCS receiver.method)
    mut params_len := expr.params.len()
    if lt(params_len, 1) {
        throw "codegen_c: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    mut func_name := ""
    mut has_ufcs_receiver := false

    switch first.node_type {
    case NodeType.Identifier(name):
        if gt(first.params.len(), 0) {
            // UFCS: receiver.method() - method name is in nested params
            mut method_expr := Expr()
            first.params.get(0, method_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch method_expr.node_type {
            case NodeType.Identifier(method_name):
                func_name = method_name
                has_ufcs_receiver = true
            case:
                throw "codegen_c: UFCS method name not Identifier"
            }
        } else {
            func_name = name
        }
    case:
        throw "codegen_c: FCall first param not Identifier"
    }

    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Hardcoded builtins
    if func_name.eq("println") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, "\"\\n\");\n")
        return result
    } else if func_name.eq("print") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, ");\n")
        return result
    } else if func_name.eq("add") {
        return emit_binop(expr, output, "+", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("sub") {
        return emit_binop(expr, output, "-", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("mul") {
        return emit_binop(expr, output, "*", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("div") {
        return emit_binop(expr, output, "/", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("mod") {
        return emit_binop(expr, output, "%", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("eq") {
        return emit_binop(expr, output, "==", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("lt") {
        return emit_binop(expr, output, "<", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("gt") {
        return emit_binop(expr, output, ">", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("lteq") {
        return emit_binop(expr, output, "<=", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("gteq") {
        return emit_binop(expr, output, ">=", has_ufcs_receiver, first, ctx)
    } else if func_name.eq("test") {
        // test(loc, cond, msg) -> if (!(cond)) { printf("FAIL: %s\n", msg); }
        if lt(params_len, 4) {
            throw "codegen_c: test requires 3 arguments"
        }
        result = concat(result, "if (!(")
        mut cond := Expr()
        expr.params.get(2, cond)
        result = emit_expr(cond, result, 0, ctx)
        result = concat(result, ")) { printf(\"FAIL: %s\\n\", ")
        mut msg := Expr()
        expr.params.get(3, msg)
        result = emit_expr(msg, result, 0, ctx)
        result = concat(result, "); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("assert_eq") {
        // assert_eq(loc, expected, actual) -> if ((expected) != (actual)) { printf("FAIL: assert_eq\n"); }
        if lt(params_len, 4) {
            throw "codegen_c: assert_eq requires 3 arguments"
        }
        result = concat(result, "if ((")
        mut expected := Expr()
        expr.params.get(2, expected)
        result = emit_expr(expected, result, 0, ctx)
        result = concat(result, ") != (")
        mut actual := Expr()
        expr.params.get(3, actual)
        result = emit_expr(actual, result, 0, ctx)
        result = concat(result, ")) { printf(\"FAIL: assert_eq\\n\"); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("loc") {
        return concat(output, "\"\"")
    } else {
        // User-defined function call
        // Check if this is a type-qualified call (Type.func(...))
        if has_ufcs_receiver {
            switch first.node_type {
            case NodeType.Identifier(receiver_name):
                mut first_char := receiver_name.get_substr(0, 1)
                if first_char.is_uppercase() {
                    // Check if this is an enum value (no arguments) vs function/constructor call
                    mut has_args := gt(params_len, 1)

                    if not(has_args) {
                        // Simple enum value: Type.Variant -> Type_Variant
                        result = concat(result, receiver_name)
                        result = concat(result, "_")
                        result = concat(result, func_name)
                        if gt(indent, 0) {
                            result = concat(result, ";\n")
                        }
                        return result
                    }

                    // Type-qualified call with args: Type.func(args...) -> Type_func(args...)
                    // For enum constructors with payloads: Type.Variant(val) -> Type_make_Variant(val)
                    // Enum variants are capitalized, function names are lowercase
                    result = concat(result, receiver_name)
                    result = concat(result, "_")
                    mut func_first_char := func_name.get_substr(0, 1)
                    if func_first_char.is_uppercase() {
                        // Enum constructor with payload
                        result = concat(result, "make_")
                    }
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    mut i := 1
                    while lt(i, params_len) {
                        if gt(i, 1) {
                            result = concat(result, ", ")
                        }
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0, ctx)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                } else {
                    // Instance UFCS: instance.func(args...) -> func(instance, args...)
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    result = concat(result, receiver_name)
                    mut i := 1
                    while lt(i, params_len) {
                        result = concat(result, ", ")
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0, ctx)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }
            case:
                throw "codegen_c: expected identifier for UFCS receiver"
            }
        }
        // Regular function call
        result = concat(result, func_name)
        result = concat(result, "(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0, ctx)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, ")")
        // Only add statement terminator if this is a statement (indent > 0)
        if gt(indent, 0) {
            result = concat(result, ";\n")
        }
        return result
    }
}

emit_binop := proc(expr: Expr, output: Str, op: Str, has_ufcs_receiver: Bool, first: Expr, mut ctx: CodegenContext) returns Str throws Str {
    mut result := concat(output, "(")

    // For UFCS: receiver.op(arg) -> (receiver op arg)
    // For type-qualified: Type.op(a, b) -> (a op b) - ignore type prefix
    // For regular: op(a, b) -> (a op b)
    if has_ufcs_receiver {
        // Check if this is a type-qualified call (Type.op(a, b)) vs instance call (x.op(y))
        // Type-qualified calls have 2+ args after the function name
        if gteq(expr.params.len(), 3) {
            // Type-qualified: Type.op(a, b) -> (a op b)
            mut arg1 := Expr()
            mut arg2 := Expr()
            expr.params.get(1, arg1)
            expr.params.get(2, arg2)
            result = emit_expr(arg1, result, 0, ctx)
            result = concat(result, " ")
            result = concat(result, op)
            result = concat(result, " ")
            result = emit_expr(arg2, result, 0, ctx)
        } else if gteq(expr.params.len(), 2) {
            // Instance UFCS: x.op(y) -> (x op y)
            switch first.node_type {
            case NodeType.Identifier(name):
                result = concat(result, name)
            case:
                throw "codegen_c: expected identifier"
            }
            result = concat(result, " ")
            result = concat(result, op)
            result = concat(result, " ")
            mut arg := Expr()
            expr.params.get(1, arg)
            result = emit_expr(arg, result, 0, ctx)
        } else {
            throw "codegen_c: UFCS binary op requires 1 argument"
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    } else {
        // Regular call: op(a, b) -> (a op b)
        if lt(expr.params.len(), 3) {
            throw "codegen_c: binary op requires 2 arguments"
        }
        mut arg1 := Expr()
        mut arg2 := Expr()
        expr.params.get(1, arg1)
        expr.params.get(2, arg2)
        result = emit_expr(arg1, result, 0, ctx)
        result = concat(result, " ")
        result = concat(result, op)
        result = concat(result, " ")
        result = emit_expr(arg2, result, 0, ctx)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    result = concat(result, ")")
    return result
}

// Emit identifier without its nested params (for UFCS receiver)
emit_identifier_without_nested := proc(expr: Expr, output: Str) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Identifier(name):
        return concat(output, name)
    case:
        throw "codegen_c: expected identifier"
    }
}

emit_literal := proc(lit: Literal, output: Str) returns Str throws Str {
    mut result := ""
    switch lit {
    case Literal.Str(s):
        result = format(output, "\"", s, "\"")
    case Literal.Number(n):
        result = concat(output, n)
    case Literal.List(l):
        throw "codegen_c: List literals not yet supported"
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return result
}
