mode lib

// C code generator for TIL
// Translates TIL AST to C source code

import("src.core.self.parser")  // Expr, NodeType, Literal

// Convert TIL type to C type
til_type_to_c := func(til_type: ValueType) returns Str {
    switch til_type {
    case ValueType.TCustom(name):
        if name.eq("I64") { return "long long" }
        else if name.eq("I32") { return "int" }
        else if name.eq("Bool") { return "unsigned char" }
        else if name.eq("U8") { return "unsigned char" }
        else if name.eq("Str") { return "const char*" }
        else { return name }  // Assume struct type
    case:
        return "int"  // Default
    }
}

// Check if an expression is a struct declaration (Name := struct {...})
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a struct declaration as a C typedef struct (only mut fields become struct fields)
emit_struct_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                result = concat(result, "typedef struct {\n")
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit mut fields as struct members
                    if member.is_mut {
                        result = concat(result, "    ")
                        result = concat(result, til_type_to_c(member.value_type))
                        result = concat(result, " ")
                        result = concat(result, member.name)
                        result = concat(result, ";\n")
                    }
                    i = add(i, 1)
                }
                result = concat(result, "} ")
                result = concat(result, decl.name)
                result = concat(result, ";\n\n")
                return result
            case:
                throw "emit_struct_declaration: not a struct"
            }
        }
        throw "emit_struct_declaration: empty params"
    case:
        throw "emit_struct_declaration: not a declaration"
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct constants (non-mut, non-function fields) with mangled names: StructName_constant
emit_struct_constants := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Only emit non-mut, non-function fields as constants
                    if not(member.is_mut) {
                        // Check if default_value is NOT a function (constants only)
                        mut is_func := false
                        mut default_val := Expr()
                        struct_def.default_values.get(member.name, default_val)
                        switch default_val.node_type {
                        case NodeType.FuncDef(fd):
                            is_func = true
                        case:
                            is_func = false
                        }
                        if not(is_func) {
                            result = concat(result, til_type_to_c(member.value_type))
                            result = concat(result, " ")
                            result = concat(result, struct_name)
                            result = concat(result, "_")
                            result = concat(result, member.name)
                            result = concat(result, " = ")
                            result = emit_expr(default_val, result, 0)
                            result = concat(result, ";\n")
                        }
                        catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function prototypes with mangled names: StructName_funcname
emit_struct_func_prototypes := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Return type
                            if eq(func_def.return_types.len(), 0) {
                                result = concat(result, "void ")
                            } else {
                                mut ret_type := ValueType.TCustom("")
                                func_def.return_types.get(0, ret_type)
                                result = concat(result, til_type_to_c(ret_type))
                                result = concat(result, " ")
                            }
                            // Mangled name
                            result = concat(result, struct_name)
                            result = concat(result, "_")
                            result = concat(result, member.name)
                            result = concat(result, "(")
                            // Parameters
                            mut j := 0
                            while lt(j, func_def.args.len()) {
                                if gt(j, 0) {
                                    result = concat(result, ", ")
                                }
                                mut arg := Declaration()
                                func_def.args.get(j, arg)
                                result = concat(result, til_type_to_c(arg.value_type))
                                result = concat(result, " ")
                                result = concat(result, arg.name)
                                j = add(j, 1)
                            }
                            result = concat(result, ");\n")
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* member has no default value, skip */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit struct function bodies with mangled names: StructName_funcname
emit_struct_func_bodies := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            switch first.node_type {
            case NodeType.StructDef(struct_def):
                mut struct_name := decl.name
                mut i := 0
                while lt(i, struct_def.members.len()) {
                    mut member := Declaration()
                    struct_def.members.get(i, member)
                    // Check if default_value is a function
                    mut func_expr := Expr()
                    struct_def.default_values.get(member.name, func_expr)
                    switch func_expr.node_type {
                    case NodeType.FuncDef(func_def):
                        // Skip external functions
                        if func_def.is_ext {
                            // do nothing
                        } else {
                            // Return type
                            if eq(func_def.return_types.len(), 0) {
                                result = concat(result, "void ")
                            } else {
                                mut ret_type := ValueType.TCustom("")
                                func_def.return_types.get(0, ret_type)
                                result = concat(result, til_type_to_c(ret_type))
                                result = concat(result, " ")
                            }
                            // Mangled name
                            result = concat(result, struct_name)
                            result = concat(result, "_")
                            result = concat(result, member.name)
                            result = concat(result, "(")
                            // Parameters
                            mut j := 0
                            while lt(j, func_def.args.len()) {
                                if gt(j, 0) {
                                    result = concat(result, ", ")
                                }
                                mut arg := Declaration()
                                func_def.args.get(j, arg)
                                result = concat(result, til_type_to_c(arg.value_type))
                                result = concat(result, " ")
                                result = concat(result, arg.name)
                                j = add(j, 1)
                            }
                            result = concat(result, ") {\n")
                            // Emit function body
                            mut k := 0
                            while lt(k, func_def.body.len()) {
                                mut stmt := Expr()
                                func_def.body.get(k, stmt)
                                result = emit_expr(stmt, result, 1)
                                k = add(k, 1)
                            }
                            result = concat(result, "}\n\n")
                        }
                    case:
                        // Not a function
                    }
                    catch (err: KeyNotFoundError) { /* skip member with no default */ }
                    i = add(i, 1)
                }
                return result
            case:
                return result
            }
        }
        return result
    case:
        return result
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}

// Emit C code from AST (multi-pass architecture)
emit := proc(ast: Expr) returns Str throws Str {
    mut output := ""

    // C boilerplate
    output = concat(output, "#include <stdio.h>\n")
    output = concat(output, "#include <stdlib.h>\n")
    output = concat(output, "#include <string.h>\n")
    output = concat(output, "#include <stdbool.h>\n\n")

    // Pass 1: emit struct definitions (only mut fields become struct members)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_declaration(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct pass
    }

    // Pass 2: emit struct constants (non-mut, non-function fields with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_constants(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip constants pass
    }
    output = concat(output, "\n")

    // Pass 3: emit function prototypes (forward declarations)
    // 3a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_prototype(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip prototype pass
    }
    // 3b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_prototypes(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func prototype pass
    }
    output = concat(output, "\n")

    // Pass 4: emit function definitions
    // 4a: top-level functions
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_func_declaration(child) {
                output = emit_func_declaration(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip function pass
    }
    // 4b: struct functions (with mangled names)
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if is_struct_declaration(child) {
                output = emit_struct_func_bodies(child, output)
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, skip struct func body pass
    }

    // Main function
    output = concat(output, "int main() {\n")

    // Pass 5: emit non-struct, non-function statements
    switch ast.node_type {
    case NodeType.Body:
        mut i := 0
        mut params_len := ast.params.len()
        while lt(i, params_len) {
            mut child := Expr()
            ast.params.get(i, child)
            if not(is_func_declaration(child)) {
                if not(is_struct_declaration(child)) {
                    output = emit_expr(child, output, 1)
                }
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    case:
        // Not a body, emit directly
        output = emit_expr(ast, output, 1)
    }

    output = concat(output, "    return 0;\n")
    output = concat(output, "}\n")

    return output
}

// Check if an expression is a function declaration (name := proc/func)
is_func_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                return true
            case:
                return false
            }
        }
        return false
    case:
        return false
    }
}

// Emit a function prototype (forward declaration)
emit_func_prototype := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Return type
                if eq(func_def.return_types.len(), 0) {
                    result = concat(result, "void ")
                } else {
                    mut ret_type := ValueType.TCustom("")
                    func_def.return_types.get(0, ret_type)
                    result = concat(result, til_type_to_c(ret_type))
                    result = concat(result, " ")
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                }

                result = concat(result, decl.name)
                result = concat(result, "(")

                // Parameters
                mut i := 0
                while lt(i, func_def.args.len()) {
                    if gt(i, 0) {
                        result = concat(result, ", ")
                    }
                    mut arg := Declaration()
                    func_def.args.get(i, arg)
                    result = concat(result, til_type_to_c(arg.value_type))
                    result = concat(result, " ")
                    result = concat(result, arg.name)
                    i = add(i, 1)
                }
                result = concat(result, ");\n")
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                return result
            case:
                throw "emit_func_prototype: not a function"
            }
        }
        throw "emit_func_prototype: empty params"
    case:
        throw "emit_func_prototype: not a declaration"
    }
}

// Emit a function declaration as a C function
emit_func_declaration := proc(expr: Expr, output: Str) returns Str throws Str {
    mut result := output
    switch expr.node_type {
    case NodeType.Declaration(decl):
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch first.node_type {
            case NodeType.FuncDef(func_def):
                // Skip external functions
                if func_def.is_ext {
                    return output
                }

                // Return type
                if eq(func_def.return_types.len(), 0) {
                    result = concat(result, "void ")
                } else {
                    mut ret_type := ValueType.TCustom("")
                    func_def.return_types.get(0, ret_type)
                    result = concat(result, til_type_to_c(ret_type))
                    result = concat(result, " ")
                    catch (err: IndexOutOfBoundsError) { throw err.msg }
                }

                result = concat(result, decl.name)
                result = concat(result, "(")

                // Parameters
                mut i := 0
                while lt(i, func_def.args.len()) {
                    if gt(i, 0) {
                        result = concat(result, ", ")
                    }
                    mut arg := Declaration()
                    func_def.args.get(i, arg)
                    result = concat(result, til_type_to_c(arg.value_type))
                    result = concat(result, " ")
                    result = concat(result, arg.name)
                    i = add(i, 1)
                }
                result = concat(result, ") {\n")

                // Emit function body
                mut j := 0
                mut body_len := func_def.body.len()
                while lt(j, body_len) {
                    mut stmt := Expr()
                    func_def.body.get(j, stmt)
                    result = emit_expr(stmt, result, 1)
                    j = add(j, 1)
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                result = concat(result, "}\n\n")
                return result
            case:
                throw "emit_func_declaration: not a function"
            }
        }
        throw "emit_func_declaration: empty params"
    case:
        throw "emit_func_declaration: not a declaration"
    }
}

emit_if := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    // If: params[0] = condition, params[1] = then-body, params[2] = else-body (optional)
    if lt(expr.params.len(), 2) {
        throw "codegen_c: If requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "if (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0)
    result = concat(result, ") {\n")

    // Then body
    mut then_body := Expr()
    expr.params.get(1, then_body)
    result = emit_body(then_body, result, add(indent, 1))

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}")

    // Else branch (optional)
    if gt(expr.params.len(), 2) {
        mut else_part := Expr()
        expr.params.get(2, else_part)
        switch else_part.node_type {
        case NodeType.If:
            // else-if: emit inline
            result = concat(result, " else ")
            result = emit_if(else_part, result, indent)
        case:
            // else block
            result = concat(result, " else {\n")
            result = emit_body(else_part, result, add(indent, 1))
            i = 0
            while lt(i, indent) {
                result = concat(result, "    ")
                i = add(i, 1)
            }
            result = concat(result, "}\n")
        }
    } else {
        result = concat(result, "\n")
    }

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

emit_while := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    // While: params[0] = condition, params[1] = body
    if lt(expr.params.len(), 2) {
        throw "codegen_c: While requires condition and body"
    }

    mut result := output
    mut i := 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "while (")

    mut cond := Expr()
    expr.params.get(0, cond)
    result = emit_expr(cond, result, 0)
    result = concat(result, ") {\n")

    // Body
    mut body := Expr()
    expr.params.get(1, body)
    result = emit_body(body, result, add(indent, 1))

    i = 0
    while lt(i, indent) {
        result = concat(result, "    ")
        i = add(i, 1)
    }
    result = concat(result, "}\n")

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

emit_expr := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    switch expr.node_type {
    case NodeType.Body:
        return emit_body(expr, output, indent)
    case NodeType.FCall:
        return emit_fcall(expr, output, indent)
    case NodeType.LLiteral(lit):
        return emit_literal(lit, output)
    case NodeType.Declaration(decl):
        return emit_declaration(decl.name, decl.is_mut, expr, output, indent)
    case NodeType.Identifier(name):
        // Check for type-qualified constant access (Type.CONSTANT -> Type_CONSTANT)
        if gt(expr.params.len(), 0) {
            mut first_char := name.get_substr(0, 1)
            if first_char.is_uppercase() {
                // Type-qualified access: Type.field -> Type_field
                mut param := Expr()
                expr.params.get(0, param)
                switch param.node_type {
                case NodeType.Identifier(field):
                    mut result := concat(output, name)
                    result = concat(result, "_")
                    result = concat(result, field)
                    return result
                case:
                    // Fall through to regular handling
                }
            }
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            catch (err: AllocError) { throw err.msg }
        }
        // Regular identifier or field access (b.val -> b.val)
        mut result := concat(output, name)
        mut i := 0
        while lt(i, expr.params.len()) {
            mut param := Expr()
            expr.params.get(i, param)
            switch param.node_type {
            case NodeType.Identifier(field):
                result = concat(result, ".")
                result = concat(result, field)
            case:
                // Not a field access
            }
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    case NodeType.FuncDef(func_def):
        return emit_funcdef(func_def, expr, output, indent)
    case NodeType.Assignment(name):
        return emit_assignment(name, expr, output, indent)
    case NodeType.Return:
        return emit_return(expr, output, indent)
    case NodeType.If:
        return emit_if(expr, output, indent)
    case NodeType.While:
        return emit_while(expr, output, indent)
    case NodeType.Catch:
        // Skip catch blocks in C codegen (no exception support yet)
        return output
    case NodeType.Throw:
        // Skip throw in C codegen (no exception support yet)
        return output
    case:
        throw format("codegen_c: unsupported node type: ", enum_to_str(expr.node_type))
    }
}

emit_body := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    mut result := output
    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, params_len) {
        mut child := Expr()
        expr.params.get(i, child)
        result = emit_expr(child, result, indent)
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    return result
}

// Check if an expression is a struct construction call (TypeName())
// Returns the type name if it is, empty string otherwise
get_struct_construction_type := func(expr: Expr) returns Str {
    switch expr.node_type {
    case NodeType.FCall:
        if gt(expr.params.len(), 0) {
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { return "" }
            switch first.node_type {
            case NodeType.Identifier(name):
                // If it's a PascalCase identifier with no nested params and no other args, assume struct
                if gt(name.len(), 0) {
                    // Check if first character is uppercase
                    mut first_char := name.get_substr(0, 1)
                    if first_char.is_uppercase() {
                        if eq(expr.params.len(), 1) {
                            if eq(first.params.len(), 0) {
                                return name
                            }
                        }
                    }
                    catch (err: IndexOutOfBoundsError) { return "" }
                    catch (err: AllocError) { return "" }
                }
                return ""
            case:
                return ""
            }
        }
        return ""
    case:
        return ""
    }
}

emit_declaration := proc(name: Str, is_mut: Bool, expr: Expr, output: Str, indent: I64) returns Str throws Str {
    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Check if this is a function definition - skip in main pass
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        switch first.node_type {
        case NodeType.FuncDef(func_def):
            // Skip - already emitted before main
            return output
        case NodeType.StructDef(struct_def):
            // Skip - already emitted before functions
            return output
        case:
            // Continue with normal declaration
        }
    }

    // Check if this is a struct construction (TypeName())
    mut struct_type := ""
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        struct_type = get_struct_construction_type(first)
    }

    if gt(struct_type.len(), 0) {
        // Struct variable declaration
        result = concat(result, struct_type)
        result = concat(result, " ")
        result = concat(result, name)
        result = concat(result, " = {0};\n")
    } else if is_mut {
        result = concat(result, "int ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0)
        }
        result = concat(result, ";\n")
    } else {
        result = concat(result, "const int ")
        result = concat(result, name)
        if gt(expr.params.len(), 0) {
            result = concat(result, " = ")
            mut first := Expr()
            expr.params.get(0, first)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            result = emit_expr(first, result, 0)
        }
        result = concat(result, ";\n")
    }
    return result
}

emit_funcdef := proc(func_def: SFuncDef, expr: Expr, output: Str, indent: I64) returns Str throws Str {
    // Inline function body (shouldn't be called for top-level funcs)
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "{\n")
    mut i := 0
    mut params_len := expr.params.len()
    while lt(i, params_len) {
        mut stmt := Expr()
        expr.params.get(i, stmt)
        result = emit_expr(stmt, result, add(indent, 1))
        i = add(i, 1)
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    ind = 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "}\n")
    return result
}

emit_assignment := proc(name: Str, expr: Expr, output: Str, indent: I64) returns Str throws Str {
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, name)
    result = concat(result, " = ")
    if gt(expr.params.len(), 0) {
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0)
    }
    result = concat(result, ";\n")
    return result
}

emit_return := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    mut result := output
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }
    result = concat(result, "return")
    if gt(expr.params.len(), 0) {
        result = concat(result, " ")
        mut first := Expr()
        expr.params.get(0, first)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = emit_expr(first, result, 0)
    }
    result = concat(result, ";\n")
    return result
}

emit_fcall := proc(expr: Expr, output: Str, indent: I64) returns Str throws Str {
    // First param is the function name (or UFCS receiver.method)
    mut params_len := expr.params.len()
    if lt(params_len, 1) {
        throw "codegen_c: FCall with no params"
    }

    mut first := Expr()
    expr.params.get(0, first)
    catch (err: IndexOutOfBoundsError) { throw err.msg }

    mut func_name := ""
    mut has_ufcs_receiver := false

    switch first.node_type {
    case NodeType.Identifier(name):
        if gt(first.params.len(), 0) {
            // UFCS: receiver.method() - method name is in nested params
            mut method_expr := Expr()
            first.params.get(0, method_expr)
            catch (err: IndexOutOfBoundsError) { throw err.msg }
            switch method_expr.node_type {
            case NodeType.Identifier(method_name):
                func_name = method_name
                has_ufcs_receiver = true
            case:
                throw "codegen_c: UFCS method name not Identifier"
            }
        } else {
            func_name = name
        }
    case:
        throw "codegen_c: FCall first param not Identifier"
    }

    mut result := output

    // Add indentation
    mut ind := 0
    while lt(ind, indent) {
        result = concat(result, "    ")
        ind = add(ind, 1)
    }

    // Hardcoded builtins
    if func_name.eq("println") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, "\"\\n\");\n")
        return result
    } else if func_name.eq("print") {
        result = concat(result, "printf(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, ");\n")
        return result
    } else if func_name.eq("add") {
        return emit_binop(expr, output, "+", has_ufcs_receiver, first)
    } else if func_name.eq("sub") {
        return emit_binop(expr, output, "-", has_ufcs_receiver, first)
    } else if func_name.eq("mul") {
        return emit_binop(expr, output, "*", has_ufcs_receiver, first)
    } else if func_name.eq("div") {
        return emit_binop(expr, output, "/", has_ufcs_receiver, first)
    } else if func_name.eq("mod") {
        return emit_binop(expr, output, "%", has_ufcs_receiver, first)
    } else if func_name.eq("eq") {
        return emit_binop(expr, output, "==", has_ufcs_receiver, first)
    } else if func_name.eq("lt") {
        return emit_binop(expr, output, "<", has_ufcs_receiver, first)
    } else if func_name.eq("gt") {
        return emit_binop(expr, output, ">", has_ufcs_receiver, first)
    } else if func_name.eq("lteq") {
        return emit_binop(expr, output, "<=", has_ufcs_receiver, first)
    } else if func_name.eq("gteq") {
        return emit_binop(expr, output, ">=", has_ufcs_receiver, first)
    } else if func_name.eq("test") {
        // test(loc, cond, msg) -> if (!(cond)) { printf("FAIL: %s\n", msg); }
        if lt(params_len, 4) {
            throw "codegen_c: test requires 3 arguments"
        }
        result = concat(result, "if (!(")
        mut cond := Expr()
        expr.params.get(2, cond)
        result = emit_expr(cond, result, 0)
        result = concat(result, ")) { printf(\"FAIL: %s\\n\", ")
        mut msg := Expr()
        expr.params.get(3, msg)
        result = emit_expr(msg, result, 0)
        result = concat(result, "); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("assert_eq") {
        // assert_eq(loc, expected, actual) -> if ((expected) != (actual)) { printf("FAIL: assert_eq\n"); }
        if lt(params_len, 4) {
            throw "codegen_c: assert_eq requires 3 arguments"
        }
        result = concat(result, "if ((")
        mut expected := Expr()
        expr.params.get(2, expected)
        result = emit_expr(expected, result, 0)
        result = concat(result, ") != (")
        mut actual := Expr()
        expr.params.get(3, actual)
        result = emit_expr(actual, result, 0)
        result = concat(result, ")) { printf(\"FAIL: assert_eq\\n\"); }\n")
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        return result
    } else if func_name.eq("loc") {
        return concat(output, "\"\"")
    } else {
        // User-defined function call
        // Check if this is a type-qualified call (Type.func(...))
        if has_ufcs_receiver {
            switch first.node_type {
            case NodeType.Identifier(receiver_name):
                mut first_char := receiver_name.get_substr(0, 1)
                if first_char.is_uppercase() {
                    // Type-qualified call: Type.func(args...) -> Type_func(args...)
                    result = concat(result, receiver_name)
                    result = concat(result, "_")
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    mut i := 1
                    while lt(i, params_len) {
                        if gt(i, 1) {
                            result = concat(result, ", ")
                        }
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                } else {
                    // Instance UFCS: instance.func(args...) -> func(instance, args...)
                    result = concat(result, func_name)
                    result = concat(result, "(")
                    result = concat(result, receiver_name)
                    mut i := 1
                    while lt(i, params_len) {
                        result = concat(result, ", ")
                        mut arg := Expr()
                        expr.params.get(i, arg)
                        result = emit_expr(arg, result, 0)
                        i = add(i, 1)
                    }
                    result = concat(result, ")")
                    if gt(indent, 0) {
                        result = concat(result, ";\n")
                    }
                    return result
                }
                catch (err: IndexOutOfBoundsError) { throw err.msg }
                catch (err: AllocError) { throw err.msg }
            case:
                throw "codegen_c: expected identifier for UFCS receiver"
            }
        }
        // Regular function call
        result = concat(result, func_name)
        result = concat(result, "(")
        mut i := 1
        while lt(i, params_len) {
            if gt(i, 1) {
                result = concat(result, ", ")
            }
            mut arg := Expr()
            expr.params.get(i, arg)
            result = emit_expr(arg, result, 0)
            i = add(i, 1)
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
        result = concat(result, ")")
        // Only add statement terminator if this is a statement (indent > 0)
        if gt(indent, 0) {
            result = concat(result, ";\n")
        }
        return result
    }
}

emit_binop := proc(expr: Expr, output: Str, op: Str, has_ufcs_receiver: Bool, first: Expr) returns Str throws Str {
    mut result := concat(output, "(")

    // For UFCS: receiver.op(arg) -> (receiver op arg)
    // For type-qualified: Type.op(a, b) -> (a op b) - ignore type prefix
    // For regular: op(a, b) -> (a op b)
    if has_ufcs_receiver {
        // Check if this is a type-qualified call (Type.op(a, b)) vs instance call (x.op(y))
        // Type-qualified calls have 2+ args after the function name
        if gteq(expr.params.len(), 3) {
            // Type-qualified: Type.op(a, b) -> (a op b)
            mut arg1 := Expr()
            mut arg2 := Expr()
            expr.params.get(1, arg1)
            expr.params.get(2, arg2)
            result = emit_expr(arg1, result, 0)
            result = concat(result, " ")
            result = concat(result, op)
            result = concat(result, " ")
            result = emit_expr(arg2, result, 0)
        } else if gteq(expr.params.len(), 2) {
            // Instance UFCS: x.op(y) -> (x op y)
            switch first.node_type {
            case NodeType.Identifier(name):
                result = concat(result, name)
            case:
                throw "codegen_c: expected identifier"
            }
            result = concat(result, " ")
            result = concat(result, op)
            result = concat(result, " ")
            mut arg := Expr()
            expr.params.get(1, arg)
            result = emit_expr(arg, result, 0)
        } else {
            throw "codegen_c: UFCS binary op requires 1 argument"
        }
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    } else {
        // Regular call: op(a, b) -> (a op b)
        if lt(expr.params.len(), 3) {
            throw "codegen_c: binary op requires 2 arguments"
        }
        mut arg1 := Expr()
        mut arg2 := Expr()
        expr.params.get(1, arg1)
        expr.params.get(2, arg2)
        result = emit_expr(arg1, result, 0)
        result = concat(result, " ")
        result = concat(result, op)
        result = concat(result, " ")
        result = emit_expr(arg2, result, 0)
        catch (err: IndexOutOfBoundsError) { throw err.msg }
    }

    result = concat(result, ")")
    return result
}

emit_literal := proc(lit: Literal, output: Str) returns Str throws Str {
    mut result := ""
    switch lit {
    case Literal.Str(s):
        result = format(output, "\"", s, "\"")
    case Literal.Number(n):
        result = concat(output, n)
    case:
        throw "codegen_c: unsupported literal type"
    }
    catch (err: AllocError) { throw err.msg }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: I64_OverflowError) { throw err.msg }
    return result
}
