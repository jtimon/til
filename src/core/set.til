mode lib

// Set depends on Vec, Str, Bool, I64, mem functions - all in core.til at this point

Set := struct {
    mut elements: Vec = Vec()         // Dynamic array of elements
    mut _size: I64 = 0                // Number of elements (internal, use len() to access)
}

namespace Set {
    /**
     * Create new empty set with specified element type
     * Example: Set.new(Str)
     */
    new := proc(T: Type) returns Set {
        mut s := Set()
        s.elements = Vec.new_from_type_info(type_as_str(T), size_of(T))
        s._size = 0
        return s
    }

    /**
     * Insert element into set
     * Returns true if element was inserted (not already present)
     * Returns false if element already exists
     */
    insert := proc(mut self: Set, own elem: Dynamic) returns Bool {
        dont_delete(elem)
        // Check if element already exists
        mut i := 0
        while i.lt(self._size) {
            mut elems_match := 0
            if Str.eq(self.elements.type_name, "Str") {
                // For Str elements, use Str.eq() to compare content
                mut existing_elem := ""
                existing_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                existing_elem_ptr.copy_to_dynamic(existing_elem, self.elements.type_size)
                mut elem_str := ""
                memcpy(to_ptr(elem_str), to_ptr(elem), self.elements.type_size)
                if elem_str.eq(existing_elem) {
                    elems_match = 0
                } else {
                    elems_match = 1
                }
            } else {
                cmp_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                elems_match = memcmp(to_ptr(elem), cmp_elem_ptr.data, self.elements.type_size)
            }

            if elems_match.eq(0) {
                // Element already exists
                return false
            }
            i = i.add(1)
        }

        // Element not found, add it
        self.elements.push(elem)
        self._size = self._size.add(1)
        return true
    }

    /** Remove element from set. Does nothing if element doesn't exist. */
    remove := proc(mut self: Set, elem: Dynamic) {
        mut i := 0
        while i.lt(self._size) {
            mut elems_match := 0
            if Str.eq(self.elements.type_name, "Str") {
                mut existing_elem := ""
                existing_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                existing_elem_ptr.copy_to_dynamic(existing_elem, self.elements.type_size)
                mut elem_str := ""
                memcpy(to_ptr(elem_str), to_ptr(elem), self.elements.type_size)
                if elem_str.eq(existing_elem) {
                    elems_match = 0
                } else {
                    elems_match = 1
                }
            } else {
                cmp_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                elems_match = memcmp(to_ptr(elem), cmp_elem_ptr.data, self.elements.type_size)
            }

            if elems_match.eq(0) {
                // Element found - remove by shifting all subsequent elements down
                mut j := i
                while j.lt(self._size.sub(1)) {
                    src_ptr := self.elements.ptr.offset(j.add(1).mul(self.elements.type_size))
                    mut dst_ptr := self.elements.ptr.offset(j.mul(self.elements.type_size))
                    dst_ptr.copy_from(src_ptr, self.elements.type_size)
                    j = j.add(1)
                }

                // Decrease size
                self._size = self._size.sub(1)
                self.elements._len = self.elements._len.sub(1)
                return
            }
            i = i.add(1)
        }
        // Element not found - do nothing
    }

    /** Check if element exists in set */
    contains := proc(self: Set, elem: Dynamic) returns Bool {
        mut i := 0
        while i.lt(self._size) {
            mut elems_match := 0
            if Str.eq(self.elements.type_name, "Str") {
                mut existing_elem := ""
                existing_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                existing_elem_ptr.copy_to_dynamic(existing_elem, self.elements.type_size)
                mut elem_str := ""
                memcpy(to_ptr(elem_str), to_ptr(elem), self.elements.type_size)
                if elem_str.eq(existing_elem) {
                    elems_match = 0
                } else {
                    elems_match = 1
                }
            } else {
                cmp_elem_ptr := self.elements.ptr.offset(i.mul(self.elements.type_size))
                elems_match = memcmp(to_ptr(elem), cmp_elem_ptr.data, self.elements.type_size)
            }

            if elems_match.eq(0) {
                return true
            }
            i = i.add(1)
        }
        return false
    }

    /** Get number of elements in set */
    len := proc(self: Set) returns I64 {
        return self._size
    }

    /** Get element at index (for iteration) */
    get := proc(self: Set, index: I64, mut out: Dynamic) throws IndexOutOfBoundsError {
        if index.lt(0).or(not(index.lt(self._size))) {
            throw IndexOutOfBoundsError(msg=format("Set.get: index ", I64.to_str(index), " out of bounds (size: ", I64.to_str(self._size), ")"))
        }
        src_ptr := self.elements.ptr.offset(index.mul(self.elements.type_size))
        src_ptr.copy_to_dynamic(out, self.elements.type_size)
    }

    /** Get borrowed Ptr to element at index. No copy - points into set memory. */
    get_by_ref := proc(self: Set, index: I64) returns Ptr throws IndexOutOfBoundsError {
        if index.lt(0).or(not(index.lt(self._size))) {
            throw IndexOutOfBoundsError(msg=format("Set.get_by_ref: index ", I64.to_str(index), " out of bounds (size: ", I64.to_str(self._size), ")"))
        }
        return self.elements.ptr.offset(index.mul(self.elements.type_size))
    }

    /** Get total size in bytes */
    size := func(self: Set) returns I64 {
        return self._size.mul(self.elements.type_size)
    }

    /** Free set memory and reset */
    clear := proc(mut self: Set) {
        self.delete()
    }

    /** Free set memory and reset */
    delete := proc(mut self: Set) {
        self.elements.delete()
        self._size = 0
    }

    clone := func(self: Set) returns Set {
        mut cloned := Set()
        cloned.elements = self.elements.clone()
        cloned._size = self._size
        return cloned
    }
}

// List - Dynamic heterogeneous collection (also known as Tuple)
// Stores elements of different types in contiguous memory
// Type information tracked via parallel metadata vectors
