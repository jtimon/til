mode lib

import("src/core/lexer")

INFER_TYPE := "auto"

// ==============================================================================
// Data Structures
// ==============================================================================

// PatternInfo: workaround for TIL's lack of tuple syntax (String, String)
// Used for switch case pattern matching with payload extraction
PatternInfo := struct {
    mut variant_name: Str = ""
    mut binding_var: Str = ""
}

// Literal types
Literal := enum {
    Number: Str,
    Str: Str,
    Bool: Str,
    List: Str,
}

// Function/procedure type
FunctionType := enum {
    FTFunc,
    FTProc,
    FTMacro,
    FTFuncExt,
    FTProcExt,
}

// Enum definition
SEnumDef := struct {
    mut enum_map: Map = Map()              // Map<Str, ValueType> - variant name to optional payload type
}

// Struct definition
SStructDef := struct {
    mut members: Array = Array()           // Array of (Str, Declaration) tuples (field name, declaration)
    mut default_values: Map = Map()        // Map<Str, Expr> - field name to default value expression
}

// Function/procedure definition
SFuncDef := struct {
    mut function_type: FunctionType = FunctionType.FTFunc
    mut args: Array = Array()              // Array of Declaration
    mut return_types: Array = Array()      // Array of ValueType (named return_types not "returns" - keyword conflict)
    mut throw_types: Array = Array()       // Array of ValueType (named throw_types not "throws" - keyword conflict)
    mut body: Array = Array()              // Array of Expr
}

// Value types that can be inferred or declared
ValueType := enum {
    TFunction,
    TProc,
    TMacro,
    TType,
    TMulti,
    TCustom: Str,
}

// Variable/parameter declaration
Declaration := struct {
    mut name: Str = ""
    mut value_type: ValueType = ValueType.TCustom("")
    mut is_mut: Bool = false
}

// AST node types
NodeType := enum {
    Body,
    LLiteral: Literal,
    FCall,
    Identifier: Str,
    Declaration: Declaration,
    Assignment: Str,
    FuncDef: SFuncDef,
    EnumDef: SEnumDef,
    StructDef: SStructDef,
    Return,
    Throw,
    Catch,
    If,
    While,
    Switch,
    DefaultCase,
    Range,
    Pattern: PatternInfo,
}

// Expression node in AST
Expr := struct {
    mut node_type: NodeType = NodeType.Body
    mut params: Array = Array()
    mut line: I64 = 0
    mut col: I64 = 0
}

// ==============================================================================
// Helper Functions
// ==============================================================================

// Placeholder for future implementation
parse_tokens := proc(lexer: Lexer) returns Expr throws Str {
    throw "parse_tokens not yet implemented"
}
