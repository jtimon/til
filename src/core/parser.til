mode lib

import("src/core/lexer")

INFER_TYPE := "auto"

// ==============================================================================
// Data Structures
// ==============================================================================

// Function/procedure type
FunctionType := enum {
    FTFunc,
    FTProc,
    FTMacro,
    FTFuncExt,
    FTProcExt,
}

// Enum definition
SEnumDef := struct {
    mut enum_map: Map = Map()              // Map<Str, ValueType> - variant name to optional payload type
}

// Function/procedure definition
SFuncDef := struct {
    mut function_type: FunctionType = FunctionType.FTFunc
    mut args: Array = Array()              // Array of Declaration
    mut return_types: Array = Array()      // Array of ValueType (named return_types not "returns" - keyword conflict)
    mut throw_types: Array = Array()       // Array of ValueType (named throw_types not "throws" - keyword conflict)
    mut body: Array = Array()              // Array of Expr
}

// Value types that can be inferred or declared
ValueType := enum {
    TFunction,
    TProc,
    TMacro,
    TType,
    TMulti,
    TCustom: Str,
}

// Variable/parameter declaration
Declaration := struct {
    mut name: Str = ""
    mut value_type: ValueType = ValueType.TCustom("")
    mut is_mut: Bool = false
}

// AST node types
NodeType := enum {
    Body,
    Literal,
}

// Expression node in AST
Expr := struct {
    mut node_type: NodeType = NodeType.Body
    mut params: Array = Array()
    mut line: I64 = 0
    mut col: I64 = 0
}

// ==============================================================================
// Helper Functions
// ==============================================================================

// Placeholder for future implementation
parse_tokens := proc(lexer: Lexer) returns Expr throws Str {
    throw "parse_tokens not yet implemented"
}
