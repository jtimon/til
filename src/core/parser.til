mode lib

import("src/core/lexer")

INFER_TYPE := "auto"

FunctionType := enum {
    FTFunc,
    FTProc,
    FTMacro,
    FTFuncExt,
    FTProcExt,
}

TTypeDef := enum {
    TEnumDef,
    TStructDef,
}

ValueType := enum {
    TFunction: FunctionType,
    TType: TTypeDef,
    TCustom: Str,
    TMulti: Str,
}

SEnumDef := struct {
    mut enum_map: Map = Map()  // Map<Str, ValueType> - variant name to optional payload type
}

Declaration := struct {
    mut name: Str = ""
    mut value_type: ValueType = ValueType.TCustom("")
    mut is_mut: Bool = false
}

// TODO: PatternInfo is a workaround for homogeneity with TIL's lack of tuple syntax
// Once TIL supports tuple notation like (Str, Str), this can be replaced with:
// Pattern(String, String)  // Pattern(variant_name, binding_var)
PatternInfo := struct {
    mut variant_name: Str = ""
    mut binding_var: Str = ""
}

SFuncDef := struct {
    mut function_type: FunctionType = FunctionType.FTFunc
    mut args: Array = Array()              // Array of Declaration
    mut return_types: Array = Array()      // Array of ValueType - "returns" conflicts with TIL keyword
    mut throw_types: Array = Array()       // Array of ValueType - "throws" conflicts with TIL keyword
    mut body: Array = Array()              // Array of Expr
}
sfuncdef_is_proc := func(self: SFuncDef) returns Bool {
    ft := self.function_type
    switch ft {
    case FunctionType.FTProc:
        return true
    case FunctionType.FTProcExt:
        return true
    case:
        return false
    }
}

sfuncdef_is_ext := func(self: SFuncDef) returns Bool {
    ft := self.function_type
    switch ft {
    case FunctionType.FTFuncExt:
        return true
    case FunctionType.FTProcExt:
        return true
    case:
        return false
    }
}

SStructDef := struct {
    mut members: Array = Array()           // Array of (Str, Declaration) - field name, declaration
    mut default_values: Map = Map()        // Map<Str, Expr> - field name to default value expression
}

Literal := enum {
    Number: Str,  // TODO support more kinds of numbers
    Str: Str,
    Bool: Str,
    List: Str,  // TODO You can call it tupple too. who cares? it's not even tested yet, just parsed
}

NodeType := enum {
    Body,
    LLiteral: Literal,
    FCall,
    Identifier: Str,
    Declaration: Declaration,
    Assignment: Str,
    FuncDef: SFuncDef,
    EnumDef: SEnumDef,
    StructDef: SStructDef,
    Return,
    Throw,
    Catch,
    If,
    While,
    Switch,
    DefaultCase,
    Range,
    Pattern: PatternInfo,  // Pattern matching for switch case with payload extraction
}

Expr := struct {
    mut node_type: NodeType = NodeType.Body
    mut params: Array = Array()
    mut line: I64 = 0
    mut col: I64 = 0
}
expr_new_parse := func(node_type: NodeType, token: Token, params: Array) returns Expr {
    mut e := Expr()
    e.node_type = node_type
    e.params = params
    e.line = token.line
    e.col = token.col
    return e
}

expr_new_explicit := func(node_type: NodeType, params: Array, line: I64, col: I64) returns Expr {
    mut e := Expr()
    e.node_type = node_type
    e.params = params
    e.line = line
    e.col = col
    return e
}

expr_new_clone := func(node_type: NodeType, e: Expr, params: Array) returns Expr {
    return expr_new_explicit(node_type, params, e.line, e.col)
}

is_literal := func(t: Token) returns Bool {
    tt := t.token_type
    switch tt {
    case TokenType.String:
        return true
    case TokenType.Number:
        return true
    case TokenType.True:
        return true
    case:
        return false
    }
}

ModeDef := struct {
    mut name: Str = ""
    mut allows_procs: Bool = false
    mut allows_base_mut: Bool = false
    mut allows_base_calls: Bool = false
    mut allows_base_anything: Bool = false
    mut needs_main_proc: Bool = false
    mut imports: Array = Array()  // Array of Str
}

can_be_imported := func(mode_def: ModeDef) returns Bool {
    if mode_def.needs_main_proc { return false }  // TODO think harder, why not?
    if mode_def.allows_base_mut { return false }
    if mode_def.allows_base_calls { return false }
    if mode_def.allows_base_anything { return false }
    return true
}

mode_from_name := func(mode_name: Str) returns ModeDef throws Str, FullError, AllocError {
    if mode_name.eq("lib") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = true
        m.allows_base_calls = false
        m.allows_base_mut = false
        m.allows_base_anything = false
        m.needs_main_proc = false
        m.imports = Array()
        return m
    }
    if mode_name.eq("pure") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = false
        m.allows_base_calls = false
        m.allows_base_mut = false
        m.allows_base_anything = false
        m.needs_main_proc = false
        m.imports = Array()
        return m
    }
    if mode_name.eq("script") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = true
        m.allows_base_calls = true
        m.allows_base_mut = true
        m.allows_base_anything = true
        m.needs_main_proc = false
        m.imports = Array()
        return m
    }
    if mode_name.eq("safe_script") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = true
        m.allows_base_calls = true
        m.allows_base_mut = true
        m.allows_base_anything = true
        m.needs_main_proc = false
        m.imports = Array()
        return m
    }
    if mode_name.eq("cli") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = true
        m.allows_base_calls = false
        m.allows_base_mut = true
        m.allows_base_anything = false
        m.needs_main_proc = true
        m.imports = Array()
        return m
    }
    if mode_name.eq("test") {
        mut m := ModeDef()
        m.name = mode_name
        m.allows_procs = true
        m.allows_base_calls = true
        m.allows_base_mut = true
        m.allows_base_anything = false
        m.needs_main_proc = false
        mut test_imports := Array()
        test_imports.push("src/core/modes/test")
        m.imports = test_imports
        return m
    }

    throw format("0:0: ", LANG_NAME, " interpreter implementation doesn't support mode '", mode_name, "'")
}

parse_mode := func(path: Str, mut lexer: Lexer) returns ModeDef throws Str, IndexOutOfBoundsError, I64_OverflowError, AllocError, FullError {
    lexer_expect(lexer, TokenType.Mode)  // Add one for mode

    t := lexer.peek()
    tt := t.token_type
    switch tt {
    case TokenType.Identifier:
        // continue
    case:
        throw "0:0: Expected identifier after 'mode'"
    }
    mode_name := t.token_str
    m := mode_from_name(mode_name)

    m_name := m.name
    if m_name.eq("safe_script") {
        throw format(path, ":0:0: mode '", m.name, "' is not properly supported in '", LANG_NAME, "' yet. Try mode 'script' instead")
    }

    lexer_expect(lexer, TokenType.Identifier)  // Add one for the identifier of the mode
    return m
}
