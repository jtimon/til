mode lib

/** Bool - Boolean type backed by U8. */
Bool := struct {
    mut data: U8 = 0

    len := func(self: Bool) returns I64 {
        return 1
    }

    eq := func(a: Bool, b: Bool) returns Bool {
        return or(and(a, b), and(not(b), not(a)))
    }

    to_str := func(self: Bool) returns Str {
        if self {
            return "true"
        }
        return "false"
    }

    /** Necessary for branchless arithmetics (but it must be implemented as a cast for it to make sense that way). */
    to_i64 := func(self: Bool) returns I64 {
        if self {
            return 1
        }
        return 0
    }

    to_u8 := func(self: Bool) returns U8 {
        return self.data
    }

    from_i64 := func(i: I64) returns Bool {
        mut b := Bool()
        if gt(i, 0) {
            b.data = 1
        }
        return b
    }

    size := func() returns I64 {
        return 1
    }
}

false := Bool.from_i64(0)
true := Bool.from_i64(1)

not := func(b: Bool) returns Bool {
    if b {
        return false
    }
    return true
}

or := func(args: ..Bool) returns Bool {
    for i in 0..args.len() {
        mut val := false
        args.get(i, val)
        if val {
            return true
        }
    }

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "or: IndexOutOfBoundsError should never happen")
    }

    return false
}

and := func(args: ..Bool) returns Bool {
    for i in 0..args.len() {
        mut val := false
        args.get(i, val)
        if not(val) {
            return false
        }
    }

    catch(err: IndexOutOfBoundsError) {
        panic(loc(), "and: IndexOutOfBoundsError should never happen")
    }

    return true
}

xor := func(a: Bool, b: Bool) returns Bool {
    return not(a.eq(b))
}

xnor := func(a: Bool, b: Bool) returns Bool {
    return a.eq(b)
}

branchless := func(cond: Bool, a: I64, b: I64) returns I64 {
    return add(mul(a, Bool.to_i64(cond)), mul(b, Bool.to_i64(not(cond))))
}
