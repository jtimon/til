mode lib

import("src/core/init")

// Typer phase: Type checking and validation
// Corresponds to src/rs/typer.rs in the Rust implementation

// Type check an AST expression
// Returns array of error strings (empty if success)
// Corresponds to check_types in typer.rs
check_types := proc(mut context: Context, e: Expr) returns Array throws Str, AllocError, IndexOutOfBoundsError {
    mut errors := Vec.new("Str", size_of(Str))

    // Match on node type
    switch e.node_type {
    case NodeType.Body:
        // Recursively check all children
        mut params := e.params
        mut i := 0
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            mut stmt_errors := check_types(context, stmt)
            // Extend errors
            mut j := 0
            while lt(j, stmt_errors.len) {
                mut err_str := ""
                stmt_errors.get(j, err_str)
                errors.push(err_str)
                j = add(j, 1)
            }
            i = add(i, 1)
        }

    case NodeType.EnumDef(enum_def):
        // TODO: check_enum_def
        TODO(loc(), "check_enum_def not yet implemented")

    case NodeType.StructDef(struct_def):
        // TODO: check_struct_def
        TODO(loc(), "check_struct_def not yet implemented")

    case NodeType.If:
        // TODO: check_if_statement
        TODO(loc(), "check_if_statement not yet implemented")

    case NodeType.While:
        // TODO: check_while_statement
        TODO(loc(), "check_while_statement not yet implemented")

    case NodeType.Switch:
        // TODO: check_switch_statement
        TODO(loc(), "check_switch_statement not yet implemented")

    case NodeType.Range:
        // TODO: Check range start/end types match
        TODO(loc(), "Range type checking not yet implemented")

    case NodeType.FCall:
        // TODO: check_fcall
        TODO(loc(), "check_fcall not yet implemented")

    case NodeType.FuncDef(func_def):
        // TODO: check_func_proc_types
        TODO(loc(), "check_func_proc_types not yet implemented")

    case NodeType.Identifier(name):
        // TODO: Check if symbol is defined
        TODO(loc(), format("Identifier type checking not yet implemented for '", name, "'"))

    case NodeType.Declaration(decl):
        // TODO: check_declaration
        TODO(loc(), format("Declaration type checking not yet implemented for '", decl.name, "'"))

    case NodeType.Assignment(var_name):
        // TODO: check_assignment
        TODO(loc(), format("Assignment type checking not yet implemented for '", var_name, "'"))

    case NodeType.Return:
        // Recursively check all return values
        mut params := e.params
        mut i := 0
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            mut stmt_errors := check_types(context, stmt)
            // Extend errors
            mut j := 0
            while lt(j, stmt_errors.len) {
                mut err_str := ""
                stmt_errors.get(j, err_str)
                errors.push(err_str)
                j = add(j, 1)
            }
            i = add(i, 1)
        }

    case NodeType.Throw:
        // Recursively check all throw values
        mut params := e.params
        mut i := 0
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            mut stmt_errors := check_types(context, stmt)
            // Extend errors
            mut j := 0
            while lt(j, stmt_errors.len) {
                mut err_str := ""
                stmt_errors.get(j, err_str)
                errors.push(err_str)
                j = add(j, 1)
            }
            i = add(i, 1)
        }

    case NodeType.Catch:
        // TODO: check_catch_statement
        TODO(loc(), "check_catch_statement not yet implemented")

    case NodeType.Literal(_):
        // Literals are always valid, no checking needed

    case NodeType.DefaultCase:
        // Default case in switch, no checking needed

    case NodeType.Pattern(_, _):
        // Pattern in switch, no checking needed

    case:
        // Unhandled node type
        TODO(loc(), format("check_types: Unhandled node type"))
    }

    return errors
}

// Check if statement - condition must be Bool
check_if_statement := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have 2 or 3 parameters (condition, then-body, optional else-body)
    if e.params.len.ne(2) {
        if e.params.len.ne(3) {
            throw e.exit_error("type", "if nodes must have 2 or 3 parameters.")
        }
    }

    // Check condition is Bool
    condition := e.params.get(0)
    condition_type := get_value_type(context, condition)

    type_str := value_type_to_str(condition_type)
    if type_str.ne("Bool") {
        throw condition.error("type", format("'if' can only accept a bool condition first, found ", type_str))
    }

    // Recursively check all branches
    i := 0
    while i.lt(e.params.len) {
        param := e.params.get(i)
        check_types(context, param)
        i = i.add(1)
    }
}

// Check function call - validate arguments match definition
check_fcall := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    f_name := get_func_name_in_call(e)

    // Get function definition
    func_def_opt := get_func_def_for_fcall(context, e)

    // REM: Allow None for struct instantiation
    switch func_def_opt {
    case Option.None:
        return
    case Option.Some(func_def):
        // Check argument count
        num_args_provided := e.params.len.sub(1)
        num_args_expected := func_def.args.len

        if num_args_expected.eq(0) {
            if num_args_provided.gt(0) {
                throw e.error("type", format("Function/procedure '", f_name, "' expects 0 args, but ", num_args_provided.to_str(), " were provided."))
            }
            return
        }

        // TODO: Handle variadic args properly
        has_multi_arg := func_proc_has_multi_arg(func_def)
        if has_multi_arg.not() {
            if num_args_expected.ne(num_args_provided) {
                throw e.error("type", format("Function/procedure '", f_name, "' expects ", num_args_expected.to_str(), " args, but ", num_args_provided.to_str(), " were provided."))
            }
        }

        // Check each argument type matches
        i := 0
        while i.lt(num_args_provided) {
            // Get expected arg definition
            arg_idx := i
            if arg_idx.ge(num_args_expected) {
                arg_idx = num_args_expected.sub(1) // Use last arg for variadic
            }
            arg_def := func_def.args.get(arg_idx)

            // Get actual argument expression
            arg_expr := e.params.get(i.add(1))

            // Recursively check the argument
            check_types(context, arg_expr)

            // Get the type of the argument
            found_type := get_value_type(context, arg_expr)
            expected_type := arg_def.value_type

            // Handle special types
            expected_type_str := value_type_to_str(expected_type)
            found_type_str := value_type_to_str(found_type)

            // Accept any type for Dynamic
            if expected_type_str.ne("Dynamic") {
                // Check types match
                if expected_type_str.ne(found_type_str) {
                    throw e.error("type", format("calling function '", f_name, "' expects '", expected_type_str, "' for arg '", arg_def.name, "', but '", found_type_str, "' was provided."))
                }
            }

            i = i.add(1)
        }
    }
}

// Check function definition
check_func_def := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // TODO: Implement function definition checking
    TODO(loc(), "check_func_def not yet implemented")
}

// Check variable declaration
check_declaration := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 1 parameter (the value being assigned)
    if e.params.len.ne(1) {
        // Extract declaration to get name
        mut decl := Declaration()
        switch e.node_type {
        case NodeType.Declaration(d):
            decl = d
        case:
            throw e.exit_error("type", "check_declaration called on non-declaration node")
        }
        throw e.exit_error("type", format("in declaration of ", decl.name, ", declaration nodes must take exactly 1 parameter."))
    }

    // Get the value expression
    value_expr := e.params.get(0)

    // Extract declaration info
    mut decl := Declaration()
    switch e.node_type {
    case NodeType.Declaration(d):
        decl = d
    case:
        throw e.exit_error("type", "check_declaration called on non-declaration node")
    }

    // Check if already exists in symbols
    has_symbol := context.symbols.has(decl.name)
    if has_symbol.not() {
        // Type inference: if type is INFER_TYPE, get from value expression
        mut value_type := decl.value_type
        type_str := value_type_to_str(value_type)

        if type_str.eq("INFER_TYPE") {
            value_type = get_value_type(context, value_expr)
        }

        // Add to symbol table
        symbol := SymbolInfo()
        symbol.value_type = value_type
        symbol.is_mut = decl.is_mut
        context.symbols.set(decl.name, symbol)

        // TODO: Register struct fields for type checking
        // TODO: Register function definitions
    }

    // Recursively check the value expression
    check_types(context, value_expr)
}

// Check assignment statement
check_assignment := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 1 parameter (the value being assigned)
    if e.params.len.ne(1) {
        // Extract var name
        mut var_name := ""
        switch e.node_type {
        case NodeType.Assignment(name):
            var_name = name
        case:
            throw e.exit_error("type", "check_assignment called on non-assignment node")
        }
        throw e.exit_error("type", format("in assignment to ", var_name, ", assignments must take exactly one value, not ", e.params.len.to_str(), "."))
    }

    // Extract var name
    mut var_name := ""
    switch e.node_type {
    case NodeType.Assignment(name):
        var_name = name
    case:
        throw e.exit_error("type", "check_assignment called on non-assignment node")
    }

    // Check if it's a function (can't assign to functions)
    has_func := context.funcs.has(var_name)
    if has_func {
        throw e.error("type", format("function '", var_name, "' cannot be assigned to."))
    }

    // Check if variable exists
    has_symbol := context.symbols.has(var_name)
    if has_symbol {
        // Check if it's mutable
        symbol := context.symbols.get(var_name)
        if symbol.is_mut.not() {
            throw e.error("type", format("Cannot assign to constant '", var_name, "', Suggestion: declare it as 'mut'."))
        }
    }

    if has_symbol.not() {
        throw e.error("type", format("Suggestion: try changing '", var_name, " =' for '", var_name, " :='\nExplanation: Cannot assign to undefined symbol '", var_name, "'."))
    }

    // Recursively check the value expression
    value_expr := e.params.get(0)
    check_types(context, value_expr)
}

// Check identifier exists
check_identifier := proc(context: Context, e: Expr) throws Str {
    // Extract identifier name
    mut name := ""
    switch e.node_type {
    case NodeType.Identifier(n):
        name = n
    case:
        throw e.exit_error("type", "check_identifier called on non-identifier node")
    }

    // Check if it exists as function or symbol
    has_func := context.funcs.has(name)
    has_symbol := context.symbols.has(name)

    if has_func.not() {
        if has_symbol.not() {
            throw e.error("type", format("Undefined symbol ", name))
        }
    }
}

// Check while statement - condition must be Bool
check_while_statement := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 2 parameters (condition, body)
    if e.params.len.ne(2) {
        throw e.exit_error("type", "while nodes must have exactly 2 parameters.")
    }

    // Check condition is Bool
    condition := e.params.get(0)
    condition_type := get_value_type(context, condition)

    type_str := value_type_to_str(condition_type)
    if type_str.ne("Bool") {
        throw condition.error("type", format("'while' can only accept a bool condition first, found ", type_str))
    }

    // Recursively check all params
    i := 0
    while i.lt(e.params.len) {
        param := e.params.get(i)
        check_types(context, param)
        i = i.add(1)
    }
}

// Check range - both sides must be same type
check_range := proc(context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 2 parameters (start, end)
    if e.params.len.ne(2) {
        throw e.lang_error("type", "Range expression must have exactly two elements")
    }

    // Get types of both sides
    left_expr := e.params.get(0)
    right_expr := e.params.get(1)

    left_type := get_value_type(context, left_expr)
    right_type := get_value_type(context, right_expr)

    left_type_str := value_type_to_str(left_type)
    right_type_str := value_type_to_str(right_type)

    // Check they match
    if left_type_str.ne(right_type_str) {
        throw e.error("type", format("Range start and end must be of same type, found '", left_type_str, "' and '", right_type_str, "'"))
    }
}
