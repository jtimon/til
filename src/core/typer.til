mode lib

import("src/core/init")

// Typer phase: Type checking and validation
// Corresponds to src/rs/typer.rs in the Rust implementation

// Type check an AST expression
// Corresponds to check_types in typer.rs
check_types := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    node_type_str := enum_to_str(e.node_type)

    // Match on node type
    switch node_type_str {
    case "NodeType.Body":
        // Recursively check all children
        i := 0
        while i.lt(e.params.len) {
            param := e.params.get(i)
            check_types(context, param)
            i = i.add(1)
        }
    case "NodeType.If":
        check_if_statement(context, e)
    case "NodeType.FCall":
        check_fcall(context, e)
    case "NodeType.FuncDef":
        check_func_def(context, e)
    case "NodeType.Declaration":
        check_declaration(context, e)
    case "NodeType.Assignment":
        check_assignment(context, e)
    case:
        TODO(loc(), format("check_types: Unimplemented node type ", node_type_str))
    }
}

// Check if statement - condition must be Bool
check_if_statement := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have 2 or 3 parameters (condition, then-body, optional else-body)
    if e.params.len.ne(2) {
        if e.params.len.ne(3) {
            throw e.exit_error("type", "if nodes must have 2 or 3 parameters.")
        }
    }

    // Check condition is Bool
    condition := e.params.get(0)
    condition_type := get_value_type(context, condition)

    type_str := value_type_to_str(condition_type)
    if type_str.ne("Bool") {
        throw condition.error("type", format("'if' can only accept a bool condition first, found ", type_str))
    }

    // Recursively check all branches
    i := 0
    while i.lt(e.params.len) {
        param := e.params.get(i)
        check_types(context, param)
        i = i.add(1)
    }
}

// Check function call - validate arguments match definition
check_fcall := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    f_name := get_func_name_in_call(e)

    // Get function definition
    func_def_opt := get_func_def_for_fcall(context, e)

    // REM: Allow None for struct instantiation
    switch func_def_opt {
    case Option.None:
        return
    case Option.Some(func_def):
        // Check argument count
        num_args_provided := e.params.len.sub(1)
        num_args_expected := func_def.args.len

        if num_args_expected.eq(0) {
            if num_args_provided.gt(0) {
                throw e.error("type", format("Function/procedure '", f_name, "' expects 0 args, but ", num_args_provided.to_str(), " were provided."))
            }
            return
        }

        // TODO: Handle variadic args properly
        has_multi_arg := func_proc_has_multi_arg(func_def)
        if has_multi_arg.not() {
            if num_args_expected.ne(num_args_provided) {
                throw e.error("type", format("Function/procedure '", f_name, "' expects ", num_args_expected.to_str(), " args, but ", num_args_provided.to_str(), " were provided."))
            }
        }

        // Check each argument type matches
        i := 0
        while i.lt(num_args_provided) {
            // Get expected arg definition
            arg_idx := i
            if arg_idx.ge(num_args_expected) {
                arg_idx = num_args_expected.sub(1) // Use last arg for variadic
            }
            arg_def := func_def.args.get(arg_idx)

            // Get actual argument expression
            arg_expr := e.params.get(i.add(1))

            // Recursively check the argument
            check_types(context, arg_expr)

            // Get the type of the argument
            found_type := get_value_type(context, arg_expr)
            expected_type := arg_def.value_type

            // Handle special types
            expected_type_str := value_type_to_str(expected_type)
            found_type_str := value_type_to_str(found_type)

            // Accept any type for Dynamic
            if expected_type_str.ne("Dynamic") {
                // Check types match
                if expected_type_str.ne(found_type_str) {
                    throw e.error("type", format("calling function '", f_name, "' expects '", expected_type_str, "' for arg '", arg_def.name, "', but '", found_type_str, "' was provided."))
                }
            }

            i = i.add(1)
        }
    }
}

// Check function definition
check_func_def := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // TODO: Implement function definition checking
    TODO(loc(), "check_func_def not yet implemented")
}

// Check variable declaration
check_declaration := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 1 parameter (the value being assigned)
    if e.params.len.ne(1) {
        // Extract declaration to get name
        mut decl := Declaration()
        switch e.node_type {
        case NodeType.Declaration(d):
            decl = d
        case:
            throw e.exit_error("type", "check_declaration called on non-declaration node")
        }
        throw e.exit_error("type", format("in declaration of ", decl.name, ", declaration nodes must take exactly 1 parameter."))
    }

    // Get the value expression
    value_expr := e.params.get(0)

    // Extract declaration info
    mut decl := Declaration()
    switch e.node_type {
    case NodeType.Declaration(d):
        decl = d
    case:
        throw e.exit_error("type", "check_declaration called on non-declaration node")
    }

    // Check if already exists in symbols
    has_symbol := context.symbols.has(decl.name)
    if has_symbol.not() {
        // Type inference: if type is INFER_TYPE, get from value expression
        mut value_type := decl.value_type
        type_str := value_type_to_str(value_type)

        if type_str.eq("INFER_TYPE") {
            value_type = get_value_type(context, value_expr)
        }

        // Add to symbol table
        symbol := SymbolInfo()
        symbol.value_type = value_type
        symbol.is_mut = decl.is_mut
        context.symbols.set(decl.name, symbol)

        // TODO: Register struct fields for type checking
        // TODO: Register function definitions
    }

    // Recursively check the value expression
    check_types(context, value_expr)
}

// Check assignment statement
check_assignment := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Must have exactly 1 parameter (the value being assigned)
    if e.params.len.ne(1) {
        // Extract var name
        mut var_name := ""
        switch e.node_type {
        case NodeType.Assignment(name):
            var_name = name
        case:
            throw e.exit_error("type", "check_assignment called on non-assignment node")
        }
        throw e.exit_error("type", format("in assignment to ", var_name, ", assignments must take exactly one value, not ", e.params.len.to_str(), "."))
    }

    // Extract var name
    mut var_name := ""
    switch e.node_type {
    case NodeType.Assignment(name):
        var_name = name
    case:
        throw e.exit_error("type", "check_assignment called on non-assignment node")
    }

    // Check if it's a function (can't assign to functions)
    has_func := context.funcs.has(var_name)
    if has_func {
        throw e.error("type", format("function '", var_name, "' cannot be assigned to."))
    }

    // Check if variable exists
    has_symbol := context.symbols.has(var_name)
    if has_symbol {
        // Check if it's mutable
        symbol := context.symbols.get(var_name)
        if symbol.is_mut.not() {
            throw e.error("type", format("Cannot assign to constant '", var_name, "', Suggestion: declare it as 'mut'."))
        }
    }

    if has_symbol.not() {
        throw e.error("type", format("Suggestion: try changing '", var_name, " =' for '", var_name, " :='\nExplanation: Cannot assign to undefined symbol '", var_name, "'."))
    }

    // Recursively check the value expression
    value_expr := e.params.get(0)
    check_types(context, value_expr)
}
