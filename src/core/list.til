mode lib

/**
 * List - Dynamic heterogeneous collection (also known as Tuple).
 * Stores elements of different types in contiguous memory.
 * Type information tracked via parallel metadata vectors.
 */
List := struct {
    mut data : I64  = 0     // Pointer to raw memory blob
    mut _len : I64 = 0      // Number of elements stored
    mut type_names : Vec = Vec()  // Vec<Str> - type name per element
    mut type_sizes : Vec = Vec()  // Vec<I64> - size per element

    /** Get number of elements in list. */
    len := func(self: List) returns I64 {
        return self._len
    }

    /** Get total size in bytes. */
    size := func(self: List) returns I64 throws IndexOutOfBoundsError {
        return self.calc_used()
    }

    /** Create new empty list. */
    new := proc() returns List throws AllocError {
        mut list := List()
        // Allocate enough for reasonable number of elements
        list.data = malloc(1024)

        if I64.eq(list.data, 0) {
            throw AllocError("List.new: malloc failed")
        }

        list._len = 0
        list.type_names = Vec.new(Str)
        list.type_sizes = Vec.new(I64)

        return list
    }

    /** Calculate byte offset for element at index. */
    calc_offset := proc(self: List, index: I64) returns I64 throws IndexOutOfBoundsError {
        mut offset := 0
        mut i := 0
        while lt(i, index) {
            mut size := 0
            self.type_sizes.get(i, size)
            offset = add(offset, size)
            i = add(i, 1)
        }
        return offset
    }

    /** Calculate total bytes used. */
    calc_used := proc(self: List) returns I64 throws IndexOutOfBoundsError {
        return self.calc_offset(self._len)
    }

    /** Append element to list.
     *  Takes the type as first parameter (like Vec.new) and value as second.
     *  Example: list.push(I64, 42), list.push(Str, "hello") */
    push := proc(mut self: List, T: Type, value: Dynamic) throws AllocError, FullError, IndexOutOfBoundsError {
        mut type_name := type_as_str(T)
        mut type_size := size_of(T)

        // Copy value to data blob at current end
        mut offset := self.calc_used()
        mut value_ptr := to_ptr(value)
        memcpy(add(self.data, offset), value_ptr, type_size)

        // Record metadata
        self.type_names.push(type_name)
        self.type_sizes.push(type_size)
        self._len = add(self._len, 1)
    }

    /** Get element at index. */
    get := proc(self: List, index: I64, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(format("List.get: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw IndexOutOfBoundsError(format("List.get: negative index ", index.to_str()))
        }

        // Get type info for validation
        mut stored_type := ""
        self.type_names.get(index, stored_type)

        mut dest_type := type_as_str(dest)

        // TODO FIX type checking when Dynamic type checking is enabled
        // if not(Str.eq(stored_type, dest_type)) {
        //     throw TypeMismatchError(...)
        // }

        // Calculate offset and size
        mut offset := self.calc_offset(index)
        mut size := 0
        self.type_sizes.get(index, size)

        // Copy data to destination
        mut dest_ptr := to_ptr(dest)
        memcpy(dest_ptr, add(self.data, offset), size)
    }

    /** Set element at index.
     *  Takes the type as second parameter and value as third.
     *  Example: list.set(0, I64, 99), list.set(1, Str, "world") */
    set := proc(mut self: List, index: I64, T: Type, value: Dynamic) throws IndexOutOfBoundsError {
        if gteq(index, self._len) {
            throw IndexOutOfBoundsError(format("List.set: index ",
                format(index.to_str(), format(" >= len ", self._len.to_str()))))
        }

        if lt(index, 0) {
            throw IndexOutOfBoundsError(format("List.set: negative index ", index.to_str()))
        }

        mut new_type := type_as_str(T)
        mut new_size := size_of(T)

        mut old_type := ""
        self.type_names.get(index, old_type)

        mut old_size := 0
        self.type_sizes.get(index, old_size)

        // Case 1: Same size - simple overwrite
        if I64.eq(new_size, old_size) {
            mut offset := self.calc_offset(index)
            mut value_ptr := to_ptr(value)
            memcpy(add(self.data, offset), value_ptr, new_size)

            // Update type name if different
            if not(Str.eq(new_type, old_type)) {
                self.type_names.set(index, new_type)
            }
            return
        }

        // Case 2: Different size - need to shift elements
        mut old_offset := self.calc_offset(index)
        mut after_offset := add(old_offset, old_size)
        mut used := self.calc_used()
        mut bytes_after := sub(used, after_offset)

        // Shift elements after index
        if gt(bytes_after, 0) {
            mut new_after_offset := add(old_offset, new_size)
            memcpy(add(self.data, new_after_offset), add(self.data, after_offset), bytes_after)
        }

        // Write new value
        mut value_ptr := to_ptr(value)
        memcpy(add(self.data, old_offset), value_ptr, new_size)

        // Update metadata
        self.type_names.set(index, new_type)
        self.type_sizes.set(index, new_size)
    }

    /** Pop last element from list. */
    pop := proc(mut self: List, mut dest: Dynamic) throws IndexOutOfBoundsError {
        if self._len.eq(0) {
            throw IndexOutOfBoundsError(format(loc(), "List.pop: cannot pop from empty List"))
        }

        // Get last element FIRST before modifying anything
        mut last_index := sub(self._len, 1)
        mut offset := self.calc_offset(last_index)
        mut size := 0
        self.type_sizes.get(last_index, size)

        // Copy data to destination directly
        mut dest_ptr := to_ptr(dest)
        memcpy(dest_ptr, add(self.data, offset), size)

        // Now safe to remove from metadata
        mut dummy_name := ""
        self.type_names.pop(dummy_name)
        mut dummy_size := 0
        self.type_sizes.pop(dummy_size)

        // Decrement length
        self._len = last_index
    }

    /** Free list memory. */
    delete := proc(mut self: List) {
        free(self.data)
        self.data = 0
        self._len = 0

        mut names := self.type_names
        names.delete()

        mut sizes := self.type_sizes
        sizes.delete()
    }

    /** Clone the list. */
    clone := func(self: List) returns List throws AllocError, IndexOutOfBoundsError {
        mut cloned := List()
        cloned._len = self._len
        cloned.type_names = self.type_names.clone()
        cloned.type_sizes = self.type_sizes.clone()

        // Calculate total bytes used and allocate data buffer
        mut total_bytes := self.calc_used()
        cloned.data = malloc(total_bytes)
        if NULL.eq(cloned.data) {
            throw AllocError.new(format(loc(), "List.clone: malloc failed for ", I64.to_str(total_bytes), " bytes"))
        }
        memcpy(cloned.data, self.data, total_bytes)
        return cloned
    }
}
