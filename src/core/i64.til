mode lib

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool {}
gt        := ext_func(a: I64, b: I64) returns Bool {}

// Minimal arithmetics
add       := ext_func(a: I64, b: I64) returns I64 {}

/** Division that returns 0 when dividing by zero.
 *  This is the default, silent behavior - no error, no throw.
 *  Use safe_div() if you want to catch division by zero errors. */
div       := ext_func(a: I64, b: I64) returns I64 {}

I64_SIZE  := 8

/** Error thrown by safe_add when overflow occurs. */
I64_Overflow := struct {
    mut msg: Str = ""
}

/** Error thrown by safe_div() when dividing by zero. */
DivideByZero := struct {}

/** I64 - Signed 64-bit integer type. */
// Note that I64 and U8 don't have fields because they're the "real core types"
// think of them as "half-external types" for now
I64 := struct {
    // mut data : Array = Array.new("U8", size_of(U8), 8) // TODO Use [8]U8 for this one

    /** Division that throws DivideByZero when dividing by zero.
     *  Use div() if you want silent behavior (returns 0). */
    safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
        if I64.eq(b, 0) {
            throw DivideByZero()
        }
        return div(a, b)
    }

    /** Addition that throws I64_Overflow when overflow occurs.
     *  Use add() if you want silent wrapping behavior. */
    safe_add := func(a: I64, b: I64) returns I64 throws I64_Overflow {
        result := add(a, b)
        // Overflow detection: adding positive gave smaller, or adding negative gave larger
        if gt(b, 0) {
            if lt(result, a) {
                throw I64_Overflow(msg=format(loc(), "I64 overflow: ", a.to_str(), " + ", b.to_str()))
            }
        }
        if lt(b, 0) {
            if gt(result, a) {
                throw I64_Overflow(msg=format(loc(), "I64 overflow: ", a.to_str(), " + ", b.to_str()))
            }
        }
        return result
    }

    /** Subtraction that throws I64_Overflow when underflow occurs.
     *  Use sub() if you want silent wrapping behavior. */
    safe_sub := func(a: I64, b: I64) returns I64 throws I64_Overflow {
        result := a.sub(b)
        // Underflow detection: subtracting positive gave larger, or subtracting negative gave smaller
        if gt(b, 0) {
            if gt(result, a) {
                throw I64_Overflow(msg=format(loc(), "I64 underflow: ", a.to_str(), " - ", b.to_str()))
            }
        }
        if lt(b, 0) {
            if lt(result, a) {
                throw I64_Overflow(msg=format(loc(), "I64 underflow: ", a.to_str(), " - ", b.to_str()))
            }
        }
        return result
    }

    /** Multiplication that throws I64_Overflow when overflow occurs.
     *  Use mul() if you want silent wrapping behavior. */
    safe_mul := func(a: I64, b: I64) returns I64 throws I64_Overflow {
        result := a.mul(b)
        // Overflow detection: if a != 0 and result / a != b, overflow occurred
        if not(I64.eq(a, 0)) {
            if not(I64.eq(div(result, a), b)) {
                throw I64_Overflow(msg=format(loc(), "I64 overflow: ", a.to_str(), " * ", b.to_str()))
            }
        }
        return result
    }

    // Bitwise operations
    xor := func(a: I64, b: I64) returns I64 {
        i64_xor := ext_func(a: I64, b: I64) returns I64 {}
        return i64_xor(a, b)
    }

    and := func(a: I64, b: I64) returns I64 {
        i64_and := ext_func(a: I64, b: I64) returns I64 {}
        return i64_and(a, b)
    }

    or := func(a: I64, b: I64) returns I64 {
        i64_or := ext_func(a: I64, b: I64) returns I64 {}
        return i64_or(a, b)
    }

    /** Modulo operation. Returns 0 when dividing by zero. */
    mod := func(a: I64, b: I64) returns I64 {
        i64_mod := ext_func(a: I64, b: I64) returns I64 {}
        return i64_mod(a, b)
    }

    /** Subtraction. */
    sub := func(a: I64, b: I64) returns I64 {
        i64_sub := ext_func(a: I64, b: I64) returns I64 {}
        return i64_sub(a, b)
    }

    /** Multiplication. */
    mul := func(a: I64, b: I64) returns I64 {
        i64_mul := ext_func(a: I64, b: I64) returns I64 {}
        return i64_mul(a, b)
    }

    eq := func(a: I64, b: I64) returns Bool {
        // REM We can't use the variadic or from here without mutual recusrion and a stack overflow
        if gt(a, b) {
            return false
        }
        if gt(b, a) {
            return false
        }
        if lt(a, b) {
            return false
        }
        if lt(b, a) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns Str {
        i64_to_str := ext_func(a: I64) returns Str {}
        return i64_to_str(self)
    }

    from_str := func(str: Str) returns I64 {
        str_to_i64 := ext_func(a: Str) returns I64 {}
        return str_to_i64(str) // TODO: this can fail and panic from rust
    }

    inc := proc(mut self: I64) {
        self = add(self, 1)
    }

    dec := proc(mut self: I64) {
        self = self.sub(1)
    }

    gteq := func(a: I64, b: I64) returns Bool {
        if gt(a, b) {
            return true
        }
        if lt(a, b) {
            return false
        }
        return true  // equal
    }

    lteq := func(a: I64, b: I64) returns Bool {
        if lt(a, b) {
            return true
        }
        if gt(a, b) {
            return false
        }
        return true  // equal
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }

    size := func() returns I64 {
        return 8
    }
}

// Constants defined after struct so I64.sub is available
MIN_I64   := I64.sub(0, 922337203)
MAX_I64   := 9223372036854775807
