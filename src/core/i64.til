mode lib

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool;
gt        := ext_func(a: I64, b: I64) returns Bool;

// Minimal arithmehics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64;
sub       := ext_func(a: I64, b: I64) returns I64;
mul       := ext_func(a: I64, b: I64) returns I64;
div       := ext_func(a: I64, b: I64) returns I64;
mod       := ext_func(a: I64, b: I64) returns I64;

I64_SIZE  := 8
// TODO we can't declare negative constants before declaring ext sub()
// TODO negative literal number support
MIN_I64   := sub(0, 922337203)
MAX_I64   := 9223372036854775807 // REM This is a lie, see bellow.
// MIN_I64   := sub(0, 9223372036854775808) // FIX Invalid number literal '9223372036854775808': number too large to fit in target t

I64_OverflowError := struct {
    mut msg: Str = ""

    new := func(msg: Str) returns I64_OverflowError {
        mut err := I64_OverflowError()
        err.msg = msg
        return err
    }
}

lteq := func(a: I64, b: I64) returns Bool {
    if lt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

gteq := func(a: I64, b: I64) returns Bool {
    if gt(a, b) {
        return true
    }
    if a.eq(b) {
        return true
    }
    return false
}

/** I64 - Signed 64-bit integer type. */
// Note that I64 and U8 don't have fields because they're the "real core types"
// think of them as "half-external types" for now
I64 := struct {
    // mut data : Array = Array.new("U8", size_of(U8), 8) // TODO Use [8]U8 for this one

    eq := func(a: I64, b: I64) returns Bool {
        // REM We can't use the variadic or from here without mutual recusrion and a stack overflow
        if gt(a, b) {
            return false
        }
        if gt(b, a) {
            return false
        }
        if lt(a, b) {
            return false
        }
        if lt(b, a) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns Str {
        i64_to_str := ext_func(a: I64) returns Str;
        return i64_to_str(self)
    }

    from_str := func(str: Str) returns I64 {
        str_to_i64 := ext_func(a: Str) returns I64;
        return str_to_i64(str) // TODO: this can fail and panic from rust
    }

    inc := proc(mut self: I64) {
        self = add(self, 1)
    }

    dec := proc(mut self: I64) {
        self = sub(self, 1)
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }

    size := func() returns I64 {
        return 8
    }
}
