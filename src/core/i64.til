mode lib

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool {}
gt        := ext_func(a: I64, b: I64) returns Bool {}

// Minimal arithmetics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64 {}
sub       := ext_func(a: I64, b: I64) returns I64 {}
mul       := ext_func(a: I64, b: I64) returns I64 {}

/** Division that returns 0 when dividing by zero.
 *  This is the default, silent behavior - no error, no throw.
 *  Use safe_div() if you want to catch division by zero errors. */
div       := ext_func(a: I64, b: I64) returns I64 {}

mod       := ext_func(a: I64, b: I64) returns I64 {}

// Bitwise operations
I64_xor   := ext_func(a: I64, b: I64) returns I64 {}
I64_and   := ext_func(a: I64, b: I64) returns I64 {}
I64_or    := ext_func(a: I64, b: I64) returns I64 {}

I64_SIZE  := 8
// TODO we can't declare negative constants before declaring ext sub()
// TODO negative literal number support
MIN_I64   := sub(0, 922337203)
MAX_I64   := 9223372036854775807 // REM This is a lie, see bellow.
// MIN_I64   := sub(0, 9223372036854775808) // FIX Invalid number literal '9223372036854775808': number too large to fit in target t

I64_OverflowError := struct {
    mut msg: Str = ""
}

/** Error thrown by safe_div() when dividing by zero. */
DivideByZero := struct {}

/** Division that throws DivideByZero when dividing by zero.
 *  Use div() if you want silent behavior (returns 0). */
safe_div := func(a: I64, b: I64) returns I64 throws DivideByZero {
    if I64.eq(b, 0) {
        throw DivideByZero()
    }
    return div(a, b)
}

/** I64 - Signed 64-bit integer type. */
// Note that I64 and U8 don't have fields because they're the "real core types"
// think of them as "half-external types" for now
I64 := struct {
    // mut data : Array = Array.new("U8", size_of(U8), 8) // TODO Use [8]U8 for this one

    eq := func(a: I64, b: I64) returns Bool {
        // REM We can't use the variadic or from here without mutual recusrion and a stack overflow
        if gt(a, b) {
            return false
        }
        if gt(b, a) {
            return false
        }
        if lt(a, b) {
            return false
        }
        if lt(b, a) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns Str {
        i64_to_str := ext_func(a: I64) returns Str {}
        return i64_to_str(self)
    }

    from_str := func(str: Str) returns I64 {
        str_to_i64 := ext_func(a: Str) returns I64 {}
        return str_to_i64(str) // TODO: this can fail and panic from rust
    }

    inc := proc(mut self: I64) {
        self = add(self, 1)
    }

    dec := proc(mut self: I64) {
        self = sub(self, 1)
    }

    gteq := func(a: I64, b: I64) returns Bool {
        if gt(a, b) {
            return true
        }
        if lt(a, b) {
            return false
        }
        return true  // equal
    }

    lteq := func(a: I64, b: I64) returns Bool {
        if lt(a, b) {
            return true
        }
        if gt(a, b) {
            return false
        }
        return true  // equal
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }

    size := func() returns I64 {
        return 8
    }
}
