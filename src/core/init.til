mode lib

import("src/core/parser")

// Init phase: Context creation and symbol table management
// Corresponds to src/rs/init.rs in the Rust implementation
//
// IMPLEMENTATION STATUS (1072/1750 lines, 61.3%):
//
// COMPLETED:
// - Context struct with all fields (arena, symbols, funcs, enum_defs, struct_defs, imports tracking)
// - Arena methods: get/insert for I64, U8, Bool, Str (simplified Phase 2 approach)
// - Enum helpers: get_variant_pos, variant_pos_to_str (fully functional)
// - Type helpers: get_type_size, get_payload_size_for_type, get_func_name_in_call
// - Type inference: get_value_type (handles literals, funcdefs, enums, structs, ranges, identifiers with member access)
// - Type inference: get_fcall_value_type (handles UFCS, standalone funcs, constructors)
// - Type inference: value_type_func_proc (function return type checking)
// - Declaration processing: process_declarations (registers funcs, enums, structs in context)
// - SymbolInfo and EnumVal structs
//
// PARTIALLY IMPLEMENTED (with TODOs for complex serialization):
// - get_fcall_value_type: needs SFuncDef parsing from storage
// - get_value_type identifier handling: needs SymbolInfo parsing
// - process_declarations: needs proper type checking, associated function registration
// - Struct methods: map_instance_fields, copy_fields, insert_struct, register_struct_fields_for_typecheck
// - Enum methods: get_enum, insert_enum, get_enum_at_offset
// - Array method: insert_array
//
// NOT YET IMPLEMENTED:
// - init_import_declarations: needs file I/O, lexing, parsing, recursive import handling
// - Complex type serialization: SFuncDef, SEnumDef, SStructDef storage in maps
// - Full struct size calculation with nested structs
// - Proper string storage with c_string/cap/len structure
// - Mode validation in declarations
// - Associated function registration for structs
//
// KEY LIMITATION:
// Currently storing complex types (SFuncDef, SEnumDef, SStructDef) as placeholder strings
// in maps. Full equivalence requires either JSON serialization or direct object storage.

// Tracks information about a declared symbol (variable, constant, etc.)
SymbolInfo := struct {
    mut value_type: Str = ""     // Type of the symbol (e.g., "I64", "Str", "Bool")
    mut is_mut: Bool = false     // Whether the symbol is mutable
}

// Represents an enum value with its type, variant name, and optional payload
EnumVal := struct {
    mut enum_type: Str = ""      // The enum type name
    mut enum_name: Str = ""      // The variant name
    mut has_payload: Bool = false // Whether payload exists
    mut payload: Str = ""         // Payload data (simplified as string for now)
}

// Context for type checking and evaluation
// Mimics Context struct in rstil.rs
Context := struct {
    mut mode_def: ModeDef = ModeDef()          // Mode definition
    mut path: Str = ""                         // File path for error reporting
    mut symbols: StrMap = StrMap()             // symbol_name -> SymbolInfo (as JSON for now)
    mut funcs: StrMap = StrMap()               // func_name -> SFuncDef (as JSON for now)
    mut enum_defs: StrMap = StrMap()           // enum_name -> SEnumDef (as JSON for now)
    mut struct_defs: StrMap = StrMap()         // struct_name -> SStructDef (as JSON for now)
    mut arena_index: StrMap = StrMap()         // var_name -> arena_offset (as str)
    mut arena: Arena = Arena()                 // Memory storage
    mut temp_enum_payload_exists: Bool = false // Whether temp enum payload exists
    mut temp_enum_payload: Str = ""            // Temp storage for enum payload during construction
    mut imports_declarations_done: StrMap = StrMap()  // Tracks imports with declarations copied
    mut imports_values_done: StrMap = StrMap() // Tracks imports with values initialized
    mut imports_wip: StrMap = StrMap()         // Work-in-progress imports for cycle detection

    // Create new context
    new := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
        mut ctx := Context()
        ctx.mode_def = mode_def
        ctx.path = path
        ctx.symbols = StrMap.new()
        ctx.funcs = StrMap.new()
        ctx.enum_defs = StrMap.new()
        ctx.struct_defs = StrMap.new()
        ctx.arena_index = StrMap.new()
        ctx.arena = Arena.new()
        ctx.temp_enum_payload_exists = false
        ctx.temp_enum_payload = ""
        ctx.imports_declarations_done = StrMap.new()
        ctx.imports_values_done = StrMap.new()
        ctx.imports_wip = StrMap.new()
        return ctx
    }

    // Get I64 value from arena by variable name
    get_i64 := func(self: Context, var_name: Str) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: I64 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read 8 bytes from arena memory at offset
        // For now, simplified: convert back from string representation
        // TODO: Implement proper byte-level storage when needed
        mut value_bytes := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_bytes)

        // Parse back to I64
        mut value_str := value_bytes
        return value_str.to_i64()
    }

    // Insert I64 value into arena
    insert_i64 := proc(mut self: Context, var_name: Str, value: I64) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // For Phase 1: simplified storage - store as string representation
        // Later: store as actual bytes like rstil.rs does

        // Check if variable already exists (update vs insert)
        mut offset_str := self.arena_index.get(var_name)
        mut value_str := value.to_str()

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory (as string for now)
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read string from arena memory at offset
        mut value := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value)
        return value
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read bool from arena memory (stored as "true"/"false" string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Convert string to bool
        return value_str.eq("true")
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert bool to string
        mut value_str := "false"
        if value {
            value_str = "true"
        }

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get U8 value from arena by variable name
    get_u8 := func(self: Context, var_name: Str) returns U8 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: U8 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read U8 from arena memory at offset
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to U8 (stored as string for now, like other types)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return u8(i64_val)
    }

    // Insert U8 value into arena
    insert_u8 := proc(mut self: Context, var_name: Str, value: U8) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert U8 to I64 then to string for storage
        i64_val := i64(value)
        mut value_str := i64_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read Bool from arena memory at offset (stored as U8: 0 or 1)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to I64 then check if 1 (true) or 0 (false)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return eq(i64_val, 1)
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert Bool to I64 (1 for true, 0 for false) then to string for storage
        mut stored_val := 0
        if value {
            stored_val = 1
        }
        mut value_str := stored_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get size in bytes of a type
    // Corresponds to get_type_size in init.rs
    get_type_size := func(self: Context, type_name: Str) returns I64 throws Str {
        // Handle primitive types
        mut tn_copy := type_name
        if tn_copy.eq("U8") {
            return 1
        }
        if tn_copy.eq("I64") {
            return 8
        }
        if tn_copy.eq("Bool") {
            return 1
        }
        if tn_copy.eq("Str") {
            return 24  // c_string (8 bytes ptr) + cap (8 bytes) + len (8 bytes)
        }

        // Check if it's an enum (all enums are 8 bytes)
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(type_name)
        if not(enum_def_str.eq("")) {
            return 8
        }

        // Check if it's a struct - need to calculate total size
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(type_name)
        if not(struct_def_str.eq("")) {
            // TODO: Parse SStructDef and calculate total size of all members
            // For now, just return a placeholder
            return 8
        }

        // Unknown type
        throw format(loc(), " ERROR: Unknown type '", type_name, "' in get_type_size")
    }

    // Get payload size for an enum type at a given offset
    // Corresponds to get_payload_size_for_type in init.rs
    get_payload_size_for_type := func(self: Context, vtype: ValueType, offset: I64) returns I64 throws Str {
        // TODO: Implement payload size calculation for enums
        // For now, just return a default size
        return 8
    }

    // Get enum value from arena by variable name
    get_enum := func(self: Context, var_name: Str) returns EnumVal throws Str, IndexOutOfBoundsError {
        // Look up symbol to verify it exists
        mut symbols_map := self.symbols
        mut symbol_str := symbols_map.get(var_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: get_enum: Symbol '", var_name, "' not found")
        }

        // TODO: Get enum type from symbol, read from arena, parse variant
        // For now, just throw TODO
        throw format(loc(), " TODO: get_enum not fully implemented for '", var_name, "'")
    }

    // Insert enum value into arena
    insert_enum := proc(mut self: Context, var_name: Str, enum_type: Str, enum_variant: Str) returns EnumVal throws Str, AllocError, IndexOutOfBoundsError {
        // TODO: Look up enum definition, calculate variant position, write to arena
        // For now, just throw TODO
        throw format(loc(), " TODO: insert_enum not fully implemented for '", var_name, "' type '", enum_type, "' variant '", enum_variant, "'")
    }

    // Map struct instance fields to arena offsets
    map_instance_fields := proc(mut self: Context, custom_type_name: Str, instance_name: Str) throws Str {
        // TODO: Look up struct definition, calculate field offsets, register in arena_index and symbols
        // For now, just throw TODO
        throw format(loc(), " TODO: map_instance_fields not fully implemented for '", instance_name, "' of type '", custom_type_name, "'")
    }

    // Copy struct fields from source to destination
    copy_fields := proc(mut self: Context, custom_type_name: Str, src: Str, dest: Str) throws Str {
        // TODO: Look up struct definition, copy all field values from src to dest in arena
        // For now, just throw TODO
        throw format(loc(), " TODO: copy_fields not fully implemented from '", src, "' to '", dest, "' of type '", custom_type_name, "'")
    }

    // Insert struct instance into arena
    insert_struct := proc(mut self: Context, var_name: Str, custom_type_name: Str) throws Str, AllocError {
        // TODO: Look up struct definition, calculate total size, allocate in arena, initialize fields
        // For now, just throw TODO
        throw format(loc(), " TODO: insert_struct not fully implemented for '", var_name, "' of type '", custom_type_name, "'")
    }

    // Register struct fields for type checking without evaluating defaults
    register_struct_fields_for_typecheck := proc(mut self: Context, instance_name: Str, struct_type_name: Str) throws Str, AllocError {
        // TODO: Look up struct definition, register all field symbols for type checking
        // For now, just throw TODO
        throw format(loc(), " TODO: register_struct_fields_for_typecheck not fully implemented for '", instance_name, "' of type '", struct_type_name, "'")
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read Str from arena memory at offset (stored directly as string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        return value_str
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Simplified storage: store string value directly (like I64/Bool)
        // TODO Phase 3+: Implement proper c_string/cap/len structure

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get enum value at specific arena offset
    get_enum_at_offset := func(self: Context, enum_type: Str, offset: I64) returns EnumVal throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // TODO: Read enum tag and payload from arena at offset
        // For now, just throw TODO
        throw format(loc(), " TODO: get_enum_at_offset not fully implemented for type '", enum_type, "'")
    }

    // Insert array into arena
    insert_array := proc(mut self: Context, var_name: Str, elem_type: Str) throws Str, AllocError {
        // TODO: Allocate Array struct, allocate buffer for elements, initialize fields
        // For now, just throw TODO
        throw format(loc(), " TODO: insert_array not fully implemented for '", var_name, "' with elem_type '", elem_type, "'")
    }
}

// Get enum variant position by name
// Corresponds to get_variant_pos in init.rs
get_variant_pos := proc(enum_def: SEnumDef, variant_name: Str) returns I64 throws Str, IndexOutOfBoundsError {
    // Get position of variant in enum_map (maintains insertion order)
    mut enum_map := enum_def.enum_map
    pos := enum_map.position(variant_name)

    if lt(pos, 0) {
        throw format(loc(), " ERROR: Enum variant '", variant_name, "' not found in enum map")
    }

    return pos
}

// Get enum variant name by position
// Corresponds to variant_pos_to_str in init.rs
variant_pos_to_str := proc(enum_def: SEnumDef, position: I64) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
    // Get keys array from enum_map
    mut enum_map := enum_def.enum_map
    mut map_size := enum_map.len()

    // Validate position
    if lt(position, 0) {
        mut pos_str := position.to_str()
        throw format(loc(), " ERROR: Invalid position '", pos_str, "' for enum variant (negative)")
    }

    if not(lt(position, map_size)) {
        mut pos_str := position.to_str()
        mut size_str := map_size.to_str()
        throw format(loc(), " ERROR: Invalid position '", pos_str, "' for enum variant (max ", size_str, ")")
    }

    // Get key at position from enum_map.keys array
    mut variant_name := ""
    mut keys_arr := enum_map.keys
    keys_arr.get(position, variant_name)

    return variant_name
}

// Check function/proc return type
// Corresponds to value_type_func_proc in init.rs
value_type_func_proc := proc(e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str {
    // Check that function returns exactly one value
    mut returns_len := func_def.return_types.len

    if eq(returns_len, 0) {
        throw format(loc(), " ERROR: func '", name, "' does not return anything")
    }

    if gt(returns_len, 1) {
        throw format(loc(), " TODO: func '", name, "' returns multiple values (not yet supported)")
    }

    // Get the return type (should be at index 0)
    mut returns_arr := func_def.return_types
    mut return_type := ValueType.TCustom("")
    returns_arr.get(0, return_type)

    return return_type
}

// Get value type for an expression (core type inference)
// Corresponds to get_value_type in init.rs
get_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle literals
    if node_type_str.eq("NodeType.Literal") {
        // Extract LiteralNodeType from payload
        mut lit_node_type: LiteralNodeType = LiteralNodeType.String("")
        mut node_type := e.node_type
        enum_extract_payload(node_type, lit_node_type)

        lit_type_str := enum_to_str(lit_node_type)

        if lit_type_str.eq("LiteralNodeType.I64") {
            return ValueType.TCustom("I64")
        }
        if lit_type_str.eq("LiteralNodeType.Bool") {
            return ValueType.TCustom("Bool")
        }
        if lit_type_str.eq("LiteralNodeType.String") {
            return ValueType.TCustom("Str")
        }
        if lit_type_str.eq("LiteralNodeType.List") {
            return ValueType.TCustom("List")
        }

        throw format(loc(), " ERROR: Unknown literal type: ", lit_type_str)
    }

    // Handle function definitions
    if node_type_str.eq("NodeType.FuncDef") {
        // Extract SFuncDef from payload
        mut func_def := SFuncDef()
        mut node_type := e.node_type
        enum_extract_payload(node_type, func_def)

        // Determine function type
        func_type := func_def.function_type
        func_type_str := enum_to_str(func_type)

        if func_type_str.eq("FunctionType.FTFunc") {
            return ValueType.TFunction(FunctionType.FTFunc)
        }
        if func_type_str.eq("FunctionType.FTFuncExt") {
            return ValueType.TFunction(FunctionType.FTFunc)
        }
        if func_type_str.eq("FunctionType.FTProc") {
            return ValueType.TFunction(FunctionType.FTProc)
        }
        if func_type_str.eq("FunctionType.FTProcExt") {
            return ValueType.TFunction(FunctionType.FTProc)
        }
        if func_type_str.eq("FunctionType.FTMacro") {
            return ValueType.TFunction(FunctionType.FTMacro)
        }

        throw format(loc(), " ERROR: Unknown function type: ", func_type_str)
    }

    // Handle enum definitions
    if node_type_str.eq("NodeType.EnumDef") {
        return ValueType.TType(TTypeDef.TEnumDef)
    }

    // Handle struct definitions
    if node_type_str.eq("NodeType.StructDef") {
        return ValueType.TType(TTypeDef.TStructDef)
    }

    // Handle function calls
    if node_type_str.eq("NodeType.FCall") {
        return get_fcall_value_type(context, e)
    }

    // Handle Range expressions
    if node_type_str.eq("NodeType.Range") {
        // TODO: Get type of range bounds and return appropriate RangeType
        // For now, assume I64Range
        return ValueType.TCustom("I64Range")
    }

    // Handle identifiers
    if node_type_str.eq("NodeType.Identifier") {
        // Extract identifier name
        mut id_name := ""
        mut node_type := e.node_type
        enum_extract_payload(node_type, id_name)

        // Look up symbol
        mut symbols_map := context.symbols
        mut symbol_str := symbols_map.get(id_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: Undefined symbol '", id_name, "'")
        }

        // TODO: Parse SymbolInfo to get actual value_type
        // For now, assume symbol_str contains the value type string
        mut current_type := ValueType.TCustom(id_name)

        // If there are no params, return the base type
        if eq(e.params.len, 0) {
            return current_type
        }

        // Process member access (e.params contains the chain like obj.field1.field2)
        mut i := 0
        mut params := e.params
        while lt(i, params.len) {
            mut member_expr := Expr()
            params.get(i, member_expr)

            // Get member name
            mut member_node_type := member_expr.node_type
            member_node_str := enum_to_str(member_node_type)
            if not(member_node_str.eq("NodeType.Identifier")) {
                throw format(loc(), " ERROR: Identifiers can only contain identifiers, found ", member_node_str)
            }

            mut member_name := ""
            enum_extract_payload(member_node_type, member_name)

            // Check current_type to determine how to resolve member
            current_type_str := enum_to_str(current_type)

            // Handle TType - accessing enum variant or struct member
            if current_type_str.eq("ValueType.TType") {
                mut ttype_def := TTypeDef.TEnumDef
                enum_extract_payload(current_type, ttype_def)
                ttype_str := enum_to_str(ttype_def)

                if ttype_str.eq("TTypeDef.TEnumDef") {
                    // Accessing enum variant - check if exists
                    mut enum_defs_map := context.enum_defs
                    mut enum_def_str := enum_defs_map.get(id_name)
                    if not(enum_def_str.eq("")) {
                        // TODO: Check if variant exists in enum_def
                        // For now, return TCustom(enum_name)
                        return ValueType.TCustom(id_name)
                    }
                }

                if ttype_str.eq("TTypeDef.TStructDef") {
                    // Accessing struct member
                    mut struct_defs_map := context.struct_defs
                    mut struct_def_str := struct_defs_map.get(id_name)
                    if not(struct_def_str.eq("")) {
                        // TODO: Get member type from struct_def
                        // For now, return placeholder
                        return ValueType.TCustom("StructMemberType")
                    }
                }
            }

            // Handle TCustom - accessing field on instance
            if current_type_str.eq("ValueType.TCustom") {
                mut custom_type_name := ""
                enum_extract_payload(current_type, custom_type_name)

                // Check if it's a struct instance
                mut struct_defs_map := context.struct_defs
                mut struct_def_str := struct_defs_map.get(custom_type_name)
                if not(struct_def_str.eq("")) {
                    // TODO: Get member type from struct_def
                    // For now, update current_type to placeholder
                    current_type = ValueType.TCustom("FieldType")
                }
            }

            i = add(i, 1)
        }

        return current_type
    }

    // Not implemented for other node types
    throw format(loc(), " TODO: get_value_type not fully implemented for node type: ", node_type_str)
}

// Get value type for function call expressions
// Corresponds to get_fcall_value_type in init.rs
get_fcall_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Get function name
    f_name := get_func_name_in_call(e)

    // Check for UFCS call (2+ params means target + args)
    if not(lt(e.params.len, 2)) {
        // Get first arg (the UFCS target)
        mut first_arg := Expr()
        mut params := e.params
        params.get(1, first_arg)

        // Try to get type of first argument
        mut target_type := get_value_type(context, first_arg)
        catch (err: Str) {
            // If we can't determine type, fall through to regular function lookup
        }

        // Check if target type has an associated method
        target_type_str := enum_to_str(target_type)
        if target_type_str.eq("ValueType.TCustom") {
            mut custom_type_name := ""
            enum_extract_payload(target_type, custom_type_name)

            // Check for associated method
            mut method_name := ""
            method_name = custom_type_name
            method_name = method_name.concat(".")
            method_name = method_name.concat(f_name)

            mut funcs_map := context.funcs
            mut method_def_str := funcs_map.get(method_name)
            if not(method_def_str.eq("")) {
                // TODO: Parse func_def and return its type
                // For now, return TCustom placeholder
                return ValueType.TCustom("MethodReturnType")
            }
        }
    }

    // Check if it's a standalone function
    mut funcs_map := context.funcs
    mut func_def_str := funcs_map.get(f_name)
    if not(func_def_str.eq("")) {
        // TODO: Parse SFuncDef from storage and call value_type_func_proc
        // For now, return placeholder
        return ValueType.TCustom("FunctionReturnType")
    }

    // Check if it's a struct or enum constructor
    mut symbols_map := context.symbols
    mut symbol_str := symbols_map.get(f_name)
    if not(symbol_str.eq("")) {
        // Check if it's a type (struct or enum)
        if symbol_str.eq("ValueType.TType") {
            // Get params[0] to check for member access (Struct.field or Enum.Variant)
            mut params := e.params
            mut id_expr := Expr()
            params.get(0, id_expr)

            // Check if id_expr has params (means Struct.field or Enum.Variant)
            if eq(id_expr.params.len, 0) {
                // Just the type itself - return TCustom(type_name)
                return ValueType.TCustom(f_name)
            }

            // Has params - check enum_defs and struct_defs
            mut enum_defs_map := context.enum_defs
            mut enum_def_str := enum_defs_map.get(f_name)
            if not(enum_def_str.eq("")) {
                // It's an enum - return TCustom(enum_name)
                return ValueType.TCustom(f_name)
            }

            mut struct_defs_map := context.struct_defs
            mut struct_def_str := struct_defs_map.get(f_name)
            if not(struct_def_str.eq("")) {
                // It's a struct - TODO: check if accessing field or calling method
                // For now, return TCustom(struct_name)
                return ValueType.TCustom(f_name)
            }
        }

        // Other symbol types - return as custom type
        return ValueType.TCustom(f_name)
    }

    // Function not found
    throw format(loc(), " ERROR: Unknown function or constructor '", f_name, "'")
}

// Get value type for UFCS (Uniform Function Call Syntax) calls
// Corresponds to get_ufcs_fcall_value_type in init.rs
get_ufcs_fcall_value_type := proc(context: Context, e: Expr, f_name: Str, id_expr: Expr, symbol: SymbolInfo) returns ValueType throws Str, IndexOutOfBoundsError {
    // Check if id_expr has params (for method calls like obj.method())
    if lt(id_expr.params.len, 1) {
        throw format(loc(), " ERROR: Cannot call '", f_name, "', it is not a function or struct, it is a '", symbol.value_type, "'")
    }

    // TODO: Full UFCS implementation
    // For now, just throw an error indicating it's not yet supported
    throw format(loc(), " TODO: UFCS method calls not yet fully implemented for '", f_name, "'")
}

// Get function name from function call expression
// Corresponds to get_func_name_in_call in init.rs
get_func_name_in_call := proc(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    // Check that this is an FCall node
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected FCall node, got ", node_type_str)
    }

    // Check that we have at least one parameter
    if lt(e.params.len, 1) {
        throw format(loc(), " ERROR: get_func_name_in_call(): FCall nodes must have at least 1 parameter")
    }

    // Get first parameter (function name)
    mut params := e.params
    mut func_name_expr := Expr()
    params.get(0, func_name_expr)

    // Extract identifier from node_type
    mut func_node_type := func_name_expr.node_type
    mut func_node_type_str := enum_to_str(func_node_type)
    if not(func_node_type_str.eq("NodeType.Identifier")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected Identifier in params[0], got ", func_node_type_str)
    }

    // Extract the function name string from the Identifier payload
    mut func_name := ""
    enum_extract_payload(func_node_type, func_name)
    return func_name
}

// Process declarations in AST and register them in context
// Corresponds to init_context in init.rs (the declaration processing part)
process_declarations := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle Body - recursively process all statements
    if node_type_str.eq("NodeType.Body") {
        mut i := 0
        mut params := e.params
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            process_declarations(context, stmt)
            i = add(i, 1)
        }
        return
    }

    // Handle FCall - check for import()
    if node_type_str.eq("NodeType.FCall") {
        f_name := get_func_name_in_call(e)
        mut f_name_copy := f_name
        if f_name_copy.eq("import") {
            // TODO: Process import declarations
            return
        }
    }

    // Handle Declaration nodes
    if node_type_str.eq("NodeType.Declaration") {
        // Extract Declaration from node_type
        mut decl := Declaration()
        mut node_type := e.node_type
        enum_extract_payload(node_type, decl)

        // Check if already declared
        mut funcs_map := context.funcs
        mut symbols_map := context.symbols
        if funcs_map.contains_key(decl.name) {
            throw format(loc(), " ERROR: '", decl.name, "' already declared")
        }
        if symbols_map.contains_key(decl.name) {
            throw format(loc(), " ERROR: '", decl.name, "' already declared")
        }

        // Must have exactly one param (the initializer expression)
        if not(eq(e.params.len, 1)) {
            throw format(loc(), " ERROR: Declaration of '", decl.name, "' must have exactly one value")
        }

        // Get the initializer expression
        mut inner_e := Expr()
        mut params := e.params
        params.get(0, inner_e)

        // Get value type of initializer
        value_type := get_value_type(context, inner_e)

        // TODO: Type checking - verify declared type matches inferred type
        // For now, just use the inferred type

        // Register based on value type
        value_type_str := enum_to_str(value_type)

        // Handle functions
        if value_type_str.eq("ValueType.TFunction") {
            // Extract function definition from inner_e
            mut inner_node_type := inner_e.node_type
            inner_node_type_str := enum_to_str(inner_node_type)

            if inner_node_type_str.eq("NodeType.FuncDef") {
                mut func_def := SFuncDef()
                enum_extract_payload(inner_node_type, func_def)

                // Register in symbols and funcs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // TODO: Store func_def properly (currently storing as string)
                funcs_map.insert(decl.name, "func_def_placeholder")
                context.funcs = funcs_map
            }
            return
        }

        // Handle enum definitions
        if value_type_str.eq("ValueType.TType") {
            mut ttype_def := TTypeDef.TEnumDef
            enum_extract_payload(value_type, ttype_def)
            ttype_str := enum_to_str(ttype_def)

            if ttype_str.eq("TTypeDef.TEnumDef") {
                // Extract enum definition from inner_e
                mut inner_node_type := inner_e.node_type
                mut enum_def := SEnumDef()
                enum_extract_payload(inner_node_type, enum_def)

                // Register in symbols and enum_defs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // TODO: Store enum_def properly (currently storing as string)
                mut enum_defs_map := context.enum_defs
                enum_defs_map.insert(decl.name, "enum_def_placeholder")
                context.enum_defs = enum_defs_map
                return
            }

            if ttype_str.eq("TTypeDef.TStructDef") {
                // Extract struct definition from inner_e
                mut inner_node_type := inner_e.node_type
                mut struct_def := SStructDef()
                enum_extract_payload(inner_node_type, struct_def)

                // Register in symbols and struct_defs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // TODO: Store struct_def properly (currently storing as string)
                mut struct_defs_map := context.struct_defs
                struct_defs_map.insert(decl.name, "struct_def_placeholder")
                context.struct_defs = struct_defs_map

                // TODO: Register associated functions and constants
                return
            }
        }

        // Handle custom types and multi types
        if value_type_str.eq("ValueType.TCustom") {
            symbols_map.insert(decl.name, value_type_str)
            context.symbols = symbols_map
            return
        }

        if value_type_str.eq("ValueType.TMulti") {
            symbols_map.insert(decl.name, value_type_str)
            context.symbols = symbols_map
            return
        }

        // Unknown type - register anyway
        symbols_map.insert(decl.name, value_type_str)
        context.symbols = symbols_map
        return
    }

    // For other node types, no declaration processing needed
}

// Process import declarations during init phase
init_import_declarations := proc(mut context: Context, e: Expr, import_path: Str) throws Str, AllocError, IndexOutOfBoundsError {
    // TODO: Read import file, parse it, copy declarations to parent context
    // TODO: Track in imports_declarations_done and imports_wip for cycle detection
    // For now, just throw TODO
    throw format(loc(), " TODO: init_import_declarations not fully implemented for path '", import_path, "'")
}

// Initialize context (corresponds to Context::new in init.rs)
// Creates and sets up a new Context for a given mode and file
init_context := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
    mut ctx := Context.new(mode_def, path)
    // TODO: Register core types, functions, imports
    // For now, just return the basic context
    return ctx
}
