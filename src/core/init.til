mode lib

import("src/core/parser")

// Init phase: Context creation and symbol table management
// Corresponds to src/rs/init.rs in the Rust implementation

// Tracks information about a declared symbol (variable, constant, etc.)
SymbolInfo := struct {
    mut value_type: Str = ""     // Type of the symbol (e.g., "I64", "Str", "Bool")
    mut is_mut: Bool = false     // Whether the symbol is mutable
}

// Represents an enum value with its type, variant name, and optional payload
EnumVal := struct {
    mut enum_type: Str = ""      // The enum type name
    mut enum_name: Str = ""      // The variant name
    mut has_payload: Bool = false // Whether payload exists
    mut payload: Str = ""         // Payload data (simplified as string for now)
}

// Context for type checking and evaluation
// Mimics Context struct in rstil.rs
Context := struct {
    mut mode_def: ModeDef = ModeDef()          // Mode definition
    mut path: Str = ""                         // File path for error reporting
    mut symbols: StrMap = StrMap()             // symbol_name -> SymbolInfo (as JSON for now)
    mut funcs: StrMap = StrMap()               // func_name -> SFuncDef (as JSON for now)
    mut enum_defs: StrMap = StrMap()           // enum_name -> SEnumDef (as JSON for now)
    mut struct_defs: StrMap = StrMap()         // struct_name -> SStructDef (as JSON for now)
    mut arena_index: StrMap = StrMap()         // var_name -> arena_offset (as str)
    mut arena: Arena = Arena()                 // Memory storage
    mut temp_enum_payload_exists: Bool = false // Whether temp enum payload exists
    mut temp_enum_payload: Str = ""            // Temp storage for enum payload during construction
    mut imports_declarations_done: StrMap = StrMap()  // Tracks imports with declarations copied
    mut imports_values_done: StrMap = StrMap() // Tracks imports with values initialized
    mut imports_wip: StrMap = StrMap()         // Work-in-progress imports for cycle detection

    // Create new context
    new := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
        mut ctx := Context()
        ctx.mode_def = mode_def
        ctx.path = path
        ctx.symbols = StrMap.new()
        ctx.funcs = StrMap.new()
        ctx.enum_defs = StrMap.new()
        ctx.struct_defs = StrMap.new()
        ctx.arena_index = StrMap.new()
        ctx.arena = Arena.new()
        ctx.temp_enum_payload_exists = false
        ctx.temp_enum_payload = ""
        ctx.imports_declarations_done = StrMap.new()
        ctx.imports_values_done = StrMap.new()
        ctx.imports_wip = StrMap.new()
        return ctx
    }

    // Get I64 value from arena by variable name
    get_i64 := func(self: Context, var_name: Str) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: I64 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read 8 bytes from arena memory at offset
        // For now, simplified: convert back from string representation
        // TODO: Implement proper byte-level storage when needed
        mut value_bytes := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_bytes)

        // Parse back to I64
        mut value_str := value_bytes
        return value_str.to_i64()
    }

    // Insert I64 value into arena
    insert_i64 := proc(mut self: Context, var_name: Str, value: I64) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // For Phase 1: simplified storage - store as string representation
        // Later: store as actual bytes like rstil.rs does

        // Check if variable already exists (update vs insert)
        mut offset_str := self.arena_index.get(var_name)
        mut value_str := value.to_str()

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory (as string for now)
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read string from arena memory at offset
        mut value := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value)
        return value
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read bool from arena memory (stored as "true"/"false" string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Convert string to bool
        return value_str.eq("true")
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert bool to string
        mut value_str := "false"
        if value {
            value_str = "true"
        }

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get U8 value from arena by variable name
    get_u8 := func(self: Context, var_name: Str) returns U8 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: U8 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read U8 from arena memory at offset
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to U8 (stored as string for now, like other types)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return u8(i64_val)
    }

    // Insert U8 value into arena
    insert_u8 := proc(mut self: Context, var_name: Str, value: U8) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert U8 to I64 then to string for storage
        i64_val := i64(value)
        mut value_str := i64_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read Bool from arena memory at offset (stored as U8: 0 or 1)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to I64 then check if 1 (true) or 0 (false)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return eq(i64_val, 1)
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert Bool to I64 (1 for true, 0 for false) then to string for storage
        mut stored_val := 0
        if value {
            stored_val = 1
        }
        mut value_str := stored_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get size in bytes of a type
    // Corresponds to get_type_size in init.rs
    get_type_size := func(self: Context, type_name: Str) returns I64 throws Str {
        // Handle primitive types
        mut tn_copy := type_name
        if tn_copy.eq("U8") {
            return 1
        }
        if tn_copy.eq("I64") {
            return 8
        }
        if tn_copy.eq("Bool") {
            return 1
        }
        if tn_copy.eq("Str") {
            return 24  // c_string (8 bytes ptr) + cap (8 bytes) + len (8 bytes)
        }

        // Check if it's an enum (all enums are 8 bytes)
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(type_name)
        if not(enum_def_str.eq("")) {
            return 8
        }

        // Check if it's a struct - need to calculate total size
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(type_name)
        if not(struct_def_str.eq("")) {
            // TODO: Parse SStructDef and calculate total size of all members
            // For now, just return a placeholder
            return 8
        }

        // Unknown type
        throw format(loc(), " ERROR: Unknown type '", type_name, "' in get_type_size")
    }

    // Get payload size for an enum type at a given offset
    // Corresponds to get_payload_size_for_type in init.rs
    get_payload_size_for_type := func(self: Context, vtype: ValueType, offset: I64) returns I64 throws Str {
        // TODO: Implement payload size calculation for enums
        // For now, just return a default size
        return 8
    }

    // Get enum value from arena by variable name
    get_enum := func(self: Context, var_name: Str) returns EnumVal throws Str, IndexOutOfBoundsError {
        // Look up symbol to verify it exists
        mut symbols_map := self.symbols
        mut symbol_str := symbols_map.get(var_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: get_enum: Symbol '", var_name, "' not found")
        }

        // TODO: Get enum type from symbol, read from arena, parse variant
        // For now, just throw TODO
        throw format(loc(), " TODO: get_enum not fully implemented for '", var_name, "'")
    }

    // Insert enum value into arena
    insert_enum := proc(mut self: Context, var_name: Str, enum_type: Str, enum_variant: Str) returns EnumVal throws Str, AllocError, IndexOutOfBoundsError {
        // TODO: Look up enum definition, calculate variant position, write to arena
        // For now, just throw TODO
        throw format(loc(), " TODO: insert_enum not fully implemented for '", var_name, "' type '", enum_type, "' variant '", enum_variant, "'")
    }
}

// Get enum variant position by name
// Corresponds to get_variant_pos in init.rs
get_variant_pos := proc(enum_def: SEnumDef, variant_name: Str) returns I64 throws Str {
    // TODO: Search enum_map for variant_name and return its position
    // For now, just throw an error
    throw format(loc(), " TODO: get_variant_pos not fully implemented for variant '", variant_name, "'")
}

// Get enum variant name by position
// Corresponds to variant_pos_to_str in init.rs
variant_pos_to_str := proc(enum_def: SEnumDef, position: I64) returns Str throws Str {
    // TODO: Get variant name at position from enum_map keys
    // For now, just throw an error
    mut pos_str := position.to_str()
    throw format(loc(), " TODO: variant_pos_to_str not fully implemented for position ", pos_str)
}

// Check function/proc return type
// Corresponds to value_type_func_proc in init.rs
value_type_func_proc := proc(e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str {
    // Check that function returns exactly one value
    mut returns_len := func_def.returns.len

    if eq(returns_len, 0) {
        throw format(loc(), " ERROR: func '", name, "' does not return anything")
    }

    if gt(returns_len, 1) {
        throw format(loc(), " TODO: func '", name, "' returns multiple values (not yet supported)")
    }

    // Get the return type (should be at index 0)
    mut returns_arr := func_def.returns
    mut return_type := ValueType.TCustom("")
    returns_arr.get(0, return_type)

    return return_type
}

// Get value type for an expression (core type inference)
// Corresponds to get_value_type in init.rs
get_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle literals
    if node_type_str.eq("NodeType.Literal") {
        // TODO: Extract literal type and return appropriate ValueType
        throw format(loc(), " TODO: get_value_type for literals not fully implemented")
    }

    // Handle function calls
    if node_type_str.eq("NodeType.FCall") {
        return get_fcall_value_type(context, e)
    }

    // Handle identifiers
    if node_type_str.eq("NodeType.Identifier") {
        // Extract identifier name
        mut id_name := ""
        mut node_type := e.node_type
        enum_extract_payload(node_type, id_name)

        // Look up symbol
        mut symbols_map := context.symbols
        mut symbol_str := symbols_map.get(id_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: Undefined symbol '", id_name, "'")
        }

        // TODO: Parse SymbolInfo and return its value_type
        // For now, just return a placeholder
        return ValueType.TCustom(symbol_str)
    }

    // Not implemented for other node types
    throw format(loc(), " TODO: get_value_type not fully implemented for node type: ", node_type_str)
}

// Get value type for function call expressions
// Corresponds to get_fcall_value_type in init.rs
get_fcall_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Get function name
    f_name := get_func_name_in_call(e)

    // Check if it's a standalone function
    mut funcs_map := context.funcs
    mut func_def_str := funcs_map.get(f_name)
    if not(func_def_str.eq("")) {
        // TODO: Parse SFuncDef from JSON string
        // For now, just return a placeholder type
        throw format(loc(), " TODO: get_fcall_value_type not fully implemented for function '", f_name, "'")
    }

    // Check if it's a struct or enum constructor
    mut symbols_map := context.symbols
    mut symbol_str := symbols_map.get(f_name)
    if not(symbol_str.eq("")) {
        // TODO: Handle struct/enum constructors
        throw format(loc(), " TODO: get_fcall_value_type not fully implemented for constructor '", f_name, "'")
    }

    // Function not found
    throw format(loc(), " ERROR: Unknown function or constructor '", f_name, "'")
}

// Get value type for UFCS (Uniform Function Call Syntax) calls
// Corresponds to get_ufcs_fcall_value_type in init.rs
get_ufcs_fcall_value_type := proc(context: Context, e: Expr, f_name: Str, id_expr: Expr, symbol: SymbolInfo) returns ValueType throws Str, IndexOutOfBoundsError {
    // Check if id_expr has params (for method calls like obj.method())
    if lt(id_expr.params.len, 1) {
        throw format(loc(), " ERROR: Cannot call '", f_name, "', it is not a function or struct, it is a '", symbol.value_type, "'")
    }

    // TODO: Full UFCS implementation
    // For now, just throw an error indicating it's not yet supported
    throw format(loc(), " TODO: UFCS method calls not yet fully implemented for '", f_name, "'")
}

// Get function name from function call expression
// Corresponds to get_func_name_in_call in init.rs
get_func_name_in_call := proc(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    // Check that this is an FCall node
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected FCall node, got ", node_type_str)
    }

    // Check that we have at least one parameter
    if lt(e.params.len, 1) {
        throw format(loc(), " ERROR: get_func_name_in_call(): FCall nodes must have at least 1 parameter")
    }

    // Get first parameter (function name)
    mut params := e.params
    mut func_name_expr := Expr()
    params.get(0, func_name_expr)

    // Extract identifier from node_type
    mut func_node_type := func_name_expr.node_type
    mut func_node_type_str := enum_to_str(func_node_type)
    if not(func_node_type_str.eq("NodeType.Identifier")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected Identifier in params[0], got ", func_node_type_str)
    }

    // Extract the function name string from the Identifier payload
    mut func_name := ""
    enum_extract_payload(func_node_type, func_name)
    return func_name
}

// Process declarations in AST and register them in context
// Corresponds to init_context in init.rs (the declaration processing part)
process_declarations := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle Body - recursively process all statements
    if node_type_str.eq("NodeType.Body") {
        mut i := 0
        mut params := e.params
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            process_declarations(context, stmt)
            i = add(i, 1)
        }
        return
    }

    // Handle FCall - check for import()
    if node_type_str.eq("NodeType.FCall") {
        f_name := get_func_name_in_call(e)
        mut f_name_copy := f_name
        if f_name_copy.eq("import") {
            // TODO: Process import declarations
            return
        }
    }

    // Handle Declaration nodes
    if node_type_str.eq("NodeType.Declaration") {
        // TODO: Extract declaration info and register in context
        // For now, just skip
        return
    }

    // For other node types, no declaration processing needed
}

// Initialize context (corresponds to init_context in init.rs)
// Creates and sets up a new Context for a given mode and file
init_context := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
    mut ctx := Context.new(mode_def, path)
    // TODO: Register core types, functions, imports
    // For now, just return the basic context
    return ctx
}
