mode lib

import("src/core/parser")

// Init phase: Context creation and symbol table management
// Corresponds to src/rs/init.rs in the Rust implementation
//
// IMPLEMENTATION STATUS (~85% complete):
//
// COMPLETED:
// Phase 1: Foundation
// - Context struct with all fields (arena, symbols, funcs, enum_defs, struct_defs, imports tracking)
// - Type serialization: SFuncDef serialization/deserialization ("FUNC|type|return_type")
// - Type serialization: SStructDef serialization ("STRUCT|field1=Type1|field2=Type2|...")
// - Basic struct support: get_type_size, insert_struct, map_instance_fields
// - String storage: get_str, insert_str (simplified arena storage)
//
// Phase 2: Enum and Array Support
// - Enum methods: get_enum, insert_enum, get_enum_at_offset (simplified without payloads)
// - Array method: insert_array (empty array allocation)
// - Helper methods: get_i64_at_offset, set_i64_at_offset, insert_bool_at_offset
//
// Phase 3: Struct Operations
// - Struct field operations: copy_fields, register_struct_fields_for_typecheck
// - Recursive nested struct handling
//
// Core Type Inference:
// - get_value_type: handles literals, funcdefs, enums, structs, ranges, identifiers, patterns
// - Member access with actual type resolution (parses struct definitions)
// - get_fcall_value_type: handles UFCS, standalone funcs, constructors
// - value_type_func_proc: function return type checking
//
// Arena Methods (simplified string-based storage):
// - get/insert for I64, U8, Bool, Str
// - Offset-based helpers for direct arena access
//
// Declaration Processing:
// - process_declarations: registers funcs, enums, structs with serialization
// - Enum helpers: get_variant_pos, variant_pos_to_str
//
// NOT YET IMPLEMENTED:
// - init_import_declarations: needs file I/O, lexing, parsing, recursive import handling
// - Full UFCS method resolution (partially stubbed)
// - Enum payload handling (basic tags only)
// - Array initialization with values (empty arrays only)
// - Proper byte-level c_string/cap/len for strings
// - Mode validation in declarations
// - Associated function registration for structs
// - SymbolInfo serialization (currently using simple string format)
//
// KEY APPROACH:
// Using simplified serialization formats for complex types:
// - Functions: "FUNC|<function_type>|<return_type>"
// - Structs: "STRUCT|field1=Type1|field2=Type2|..."
// - Arena storage: string representations instead of raw bytes
// This approach is sufficient for basic single-file TIL programs.

// Tracks information about a declared symbol (variable, constant, etc.)
SymbolInfo := struct {
    mut value_type: ValueType = ValueType.TFunction  // Type of the symbol
    mut is_mut: Bool = false                          // Whether the symbol is mutable
}

// Represents an enum value with its type, variant name, and optional payload
EnumVal := struct {
    mut enum_type: Str = ""                            // The enum type name
    mut enum_name: Str = ""                            // The variant name
    mut has_payload: Bool = false                      // Whether payload exists
    mut payload: Str = ""                              // Payload data (simplified - Rust uses Vec<u8>)
    mut payload_type: ValueType = ValueType.TFunction  // Payload type (TFunction = none)
}

// Context for type checking and evaluation
// Mimics Context struct in rstil.rs
Context := struct {
    mut mode_def: ModeDef = ModeDef()          // Mode definition
    mut path: Str = ""                         // File path for error reporting
    mut symbols: StrMap = StrMap()             // symbol_name -> SymbolInfo (as JSON for now)
    mut funcs: StrMap = StrMap()               // func_name -> SFuncDef (as JSON for now)
    mut enum_defs: StrMap = StrMap()           // enum_name -> SEnumDef (as JSON for now)
    mut struct_defs: StrMap = StrMap()         // struct_name -> SStructDef (as JSON for now)
    mut arena_index: StrMap = StrMap()         // var_name -> arena_offset (as str)
    mut arena: Arena = Arena()                 // Memory storage
    mut temp_enum_payload_exists: Bool = false // Whether temp enum payload exists
    mut temp_enum_payload: Str = ""            // Temp storage for enum payload during construction
    mut imports_declarations_done: StrMap = StrMap()  // Tracks imports with declarations copied
    mut imports_values_done: StrMap = StrMap() // Tracks imports with values initialized
    mut imports_wip: StrMap = StrMap()         // Work-in-progress imports for cycle detection

    // Create new context
    new := proc(mode_def: ModeDef, path: Str) returns Context throws AllocError {
        mut ctx := Context()
        ctx.mode_def = mode_def
        ctx.path = path
        ctx.symbols = StrMap.new()
        ctx.funcs = StrMap.new()
        ctx.enum_defs = StrMap.new()
        ctx.struct_defs = StrMap.new()
        ctx.arena_index = StrMap.new()
        ctx.arena = Arena.new()
        ctx.temp_enum_payload_exists = false
        ctx.temp_enum_payload = ""
        ctx.imports_declarations_done = StrMap.new()
        ctx.imports_values_done = StrMap.new()
        ctx.imports_wip = StrMap.new()
        return ctx
    }

    // Get I64 value from arena at specific offset
    get_i64_at_offset := func(self: Context, offset: I64) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Read value from arena memory at offset
        mut value_bytes := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_bytes)

        // Parse back to I64
        mut value_str := value_bytes
        return value_str.to_i64()
    }

    // Set I64 value in arena at specific offset
    set_i64_at_offset := proc(mut self: Context, offset: I64, value: I64) throws Str, IndexOutOfBoundsError {
        mut value_str := value.to_str()
        mut mem_arr := self.arena.memory
        mem_arr.set(offset, value_str)
        self.arena.memory = mem_arr
    }

    // Insert Bool value in arena at specific offset
    insert_bool_at_offset := proc(mut self: Context, offset: I64, value: Bool) throws Str, IndexOutOfBoundsError {
        // Store Bool as "true" or "false" string
        mut value_str := ""
        if value {
            value_str = "true"
        }
        else {
            value_str = "false"
        }
        mut mem_arr := self.arena.memory
        mem_arr.set(offset, value_str)
        self.arena.memory = mem_arr
    }

    // Get I64 value from arena by variable name
    get_i64 := func(self: Context, var_name: Str) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: I64 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read 8 bytes from arena memory at offset
        // For now, simplified: convert back from string representation
        // TODO: Implement proper byte-level storage when needed
        mut value_bytes := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_bytes)

        // Parse back to I64
        mut value_str := value_bytes
        return value_str.to_i64()
    }

    // Insert I64 value into arena
    insert_i64 := proc(mut self: Context, var_name: Str, value: I64) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // For Phase 1: simplified storage - store as string representation
        // Later: store as actual bytes like rstil.rs does

        // Check if variable already exists (update vs insert)
        mut offset_str := self.arena_index.get(var_name)
        mut value_str := value.to_str()

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory (as string for now)
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read string from arena memory at offset
        mut value := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value)
        return value
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read bool from arena memory (stored as "true"/"false" string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Convert string to bool
        return value_str.eq("true")
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert bool to string
        mut value_str := "false"
        if value {
            value_str = "true"
        }

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get U8 value from arena by variable name
    get_u8 := func(self: Context, var_name: Str) returns U8 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: U8 variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read U8 from arena memory at offset
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to U8 (stored as string for now, like other types)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return u8(i64_val)
    }

    // Insert U8 value into arena
    insert_u8 := proc(mut self: Context, var_name: Str, value: U8) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert U8 to I64 then to string for storage
        i64_val := i64(value)
        mut value_str := i64_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get Bool value from arena by variable name
    get_bool := func(self: Context, var_name: Str) returns Bool throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Bool variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read Bool from arena memory at offset (stored as U8: 0 or 1)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        // Parse to I64 then check if 1 (true) or 0 (false)
        mut value_str_copy := value_str
        i64_val := value_str_copy.to_i64()
        return eq(i64_val, 1)
    }

    // Insert Bool value into arena
    insert_bool := proc(mut self: Context, var_name: Str, value: Bool) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Convert Bool to I64 (1 for true, 0 for false) then to string for storage
        mut stored_val := 0
        if value {
            stored_val = 1
        }
        mut value_str := stored_val.to_str()

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value_str)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value_str)
            self.arena.memory = mem_arr
        }
    }

    // Get size in bytes of a type
    // Corresponds to get_type_size in init.rs
    get_type_size := func(self: Context, type_name: Str) returns I64 throws Str {
        // Handle primitive types
        mut tn_copy := type_name
        if tn_copy.eq("U8") {
            return 1
        }
        if tn_copy.eq("I64") {
            return 8
        }
        if tn_copy.eq("Bool") {
            return 1
        }
        if tn_copy.eq("Str") {
            return 24  // c_string (8 bytes ptr) + cap (8 bytes) + len (8 bytes)
        }

        // Check if it's an enum (all enums are 8 bytes)
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(type_name)
        if not(enum_def_str.eq("")) {
            return 8
        }

        // Check if it's a struct - need to calculate total size
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(type_name)
        if not(struct_def_str.eq("")) {
            // Parse serialized struct definition
            // Format: "STRUCT|field1=Type1|field2=Type2|..."
            mut parts := struct_def_str.split("|")
            mut total_size := 0

            // Skip first part ("STRUCT") and iterate through field definitions
            mut i := 1
            while lt(i, parts.len) {
                mut field_def := ""
                parts.get(i, field_def)

                // Split field_def by "=" to get field_name=field_type
                mut field_parts := field_def.split("=")
                if gteq(field_parts.len, 2) {
                    mut field_type := ""
                    field_parts.get(1, field_type)

                    // Recursively get the size of this field's type
                    mut field_size := self.get_type_size(field_type)
                    total_size = add(total_size, field_size)
                }

                i = add(i, 1)
            }

            return total_size
        }

        // Unknown type
        throw format(loc(), " ERROR: Unknown type '", type_name, "' in get_type_size")
    }

    // Get payload size for an enum type at a given offset
    // Corresponds to get_payload_size_for_type in init.rs
    get_payload_size_for_type := func(self: Context, vtype: ValueType, offset: I64) returns I64 throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Match on value type
        mut vtype_str := value_type_to_str(vtype)

        // Extract type name if TCustom
        mut type_name := ""
        switch vtype {
        case ValueType.TCustom(name):
            type_name = name
        case:
            // For non-custom types, return 0
            return 0
        }

        // Handle primitive types
        if type_name.eq("Bool") {
            return 1
        }
        if type_name.eq("I64") {
            return 8
        }

        // Look up the type in symbols
        mut symbols_map := self.symbols
        mut symbol_str := symbols_map.get(type_name)
        if symbol_str.eq("") {
            // Type not found in symbols, return 0
            return 0
        }

        // Parse symbol to get ValueType
        mut symbol := SymbolInfo()
        symbol.value_type = parse_value_type_from_str(symbol_str)

        // Check if it's a struct or enum type
        mut symbol_vtype_str := value_type_to_str(symbol.value_type)

        // Handle TType(TStructDef)
        if symbol_vtype_str.contains("TType.TStructDef") {
            return self.get_type_size(type_name)
        }

        // Handle TType(TEnumDef)
        if symbol_vtype_str.contains("TType.TEnumDef") {
            // For simplified implementation without payloads, just return 8 for variant tag
            // In full implementation, this would recursively get the inner enum's payload size
            return 8
        }

        // For other types, return 0
        return 0
    }

    // Get enum value from arena by variable name
    get_enum := func(self: Context, var_name: Str) returns EnumVal throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up symbol to verify it exists
        mut symbols_map := self.symbols
        mut symbol_str := symbols_map.get(var_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: get_enum: Symbol '", var_name, "' not found")
        }

        // TODO: Parse SymbolInfo to get enum_type
        // For now, assume symbol_str contains type info like "ValueType.TCustom=TypeName"
        mut enum_type := ""
        if symbol_str.contains("=") {
            mut parts := symbol_str.split("=")
            if gteq(parts.len, 2) {
                parts.get(1, enum_type)
            }
        }
        if enum_type.eq("") {
            throw format(loc(), " ERROR: get_enum: Could not determine enum type for '", var_name, "'")
        }

        // Get arena offset
        mut arena_idx := self.arena_index
        mut offset_str := arena_idx.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: get_enum: Arena index for '", var_name, "' not found")
        }
        mut offset := offset_str.to_i64()

        // Read enum value from arena (stored as I64 variant position)
        mut enum_value := self.get_i64_at_offset(offset)

        // Get enum definition to map position to name
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(enum_type)
        if enum_def_str.eq("") {
            throw format(loc(), " ERROR: get_enum: Enum definition for '", enum_type, "' not found")
        }

        // Get variant name from position
        mut enum_name := self.variant_pos_to_str(enum_type, enum_value)

        // TODO: Handle payload reading
        // For now, return enum without payload
        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name
        return result
    }

    // Insert enum value into arena
    insert_enum := proc(mut self: Context, var_name: Str, enum_type: Str, enum_variant: Str) returns EnumVal throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Get enum definition
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(enum_type)
        if enum_def_str.eq("") {
            throw format(loc(), " ERROR: insert_enum: Enum definition for '", enum_type, "' not found")
        }

        // Normalize enum_variant (strip type prefix if present)
        mut normalized_variant := enum_variant
        if enum_variant.contains(".") {
            mut parts := enum_variant.split(".")
            mut last_part := ""
            mut last_idx := sub(parts.len, 1)
            parts.get(last_idx, last_part)
            normalized_variant = last_part
        }

        // Get variant position
        mut enum_value := self.get_variant_pos(enum_type, normalized_variant)

        // Check if variable already exists (update vs insert)
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space and store
            self.insert_i64(var_name, enum_value)
        }
        else {
            // Update existing variable
            mut offset := offset_str.to_i64()
            self.set_i64_at_offset(offset, enum_value)
        }

        // TODO: Handle temp_enum_payload for variants with payloads
        // For now, return enum without payload
        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = normalized_variant
        return result
    }

    // Map struct instance fields to arena offsets
    map_instance_fields := proc(mut self: Context, custom_type_name: Str, instance_name: Str) throws Str, IndexOutOfBoundsError {
        // Get struct definition
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(custom_type_name)
        if struct_def_str.eq("") {
            throw format(loc(), " ERROR: map_instance_fields: definition for '", custom_type_name, "' not found")
        }

        // Get instance mutability from symbols
        mut symbols_map := self.symbols
        mut symbol_info_str := symbols_map.get(instance_name)
        if symbol_info_str.eq("") {
            throw format(loc(), " ERROR: map_instance_fields: instance '", instance_name, "' not found in symbols")
        }
        // TODO: Parse SymbolInfo to get is_mut (for now assume mutable)
        mut is_mut := true

        // Get base offset from arena_index
        mut arena_index_map := self.arena_index
        mut base_offset_str := arena_index_map.get(instance_name)
        if base_offset_str.eq("") {
            throw format(loc(), " ERROR: map_instance_fields: base offset for '", instance_name, "' not found")
        }
        mut base_offset := base_offset_str.to_i64()

        // Parse serialized struct definition
        // Format: "STRUCT|field1=Type1|field2=Type2|..."
        mut parts := struct_def_str.split("|")
        mut current_offset := 0

        // Skip first part ("STRUCT") and iterate through field definitions
        mut i := 1
        while lt(i, parts.len) {
            mut field_def := ""
            parts.get(i, field_def)

            // Split field_def by "=" to get field_name=field_type
            mut field_parts := field_def.split("=")
            if gteq(field_parts.len, 2) {
                mut field_name := ""
                mut field_type := ""
                field_parts.get(0, field_name)
                field_parts.get(1, field_type)

                // TODO: Handle immutable fields separately
                // For now, assume all fields are mutable
                mut combined_name := format(instance_name, ".", field_name)
                mut field_offset := add(base_offset, current_offset)

                // Register in arena_index
                mut arena_map := self.arena_index
                arena_map.insert(combined_name, field_offset.to_str())
                self.arena_index = arena_map

                // Register in symbols
                mut syms := self.symbols
                // TODO: Serialize SymbolInfo properly (for now just store type)
                syms.insert(combined_name, format("ValueType.TCustom=", field_type))
                self.symbols = syms

                // Recursively handle nested structs
                mut struct_defs := self.struct_defs
                mut nested_struct_def := struct_defs.get(field_type)
                if not(nested_struct_def.eq("")) {
                    self.map_instance_fields(field_type, combined_name)
                }

                // Calculate field size and increment offset
                mut field_size := self.get_type_size(field_type)
                current_offset = add(current_offset, field_size)
            }

            i = add(i, 1)
        }
    }

    // Copy struct fields from source to destination
    copy_fields := proc(mut self: Context, custom_type_name: Str, src: Str, dest: Str) throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Get struct definition
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(custom_type_name)
        if struct_def_str.eq("") {
            throw format(loc(), " ERROR: copy_fields: definition for '", custom_type_name, "' not found")
        }

        // Get destination symbol info (for is_mut)
        mut symbols_map := self.symbols
        mut dest_symbol_str := symbols_map.get(dest)
        if dest_symbol_str.eq("") {
            throw format(loc(), " ERROR: copy_fields: destination symbol '", dest, "' not found")
        }
        // TODO: Parse SymbolInfo to get is_mut
        mut is_mut := true

        // Get destination base offset
        mut arena_idx := self.arena_index
        mut dest_base_offset_str := arena_idx.get(dest)
        if dest_base_offset_str.eq("") {
            throw format(loc(), " ERROR: copy_fields: destination arena offset for '", dest, "' not found")
        }
        mut dest_base_offset := dest_base_offset_str.to_i64()

        // Parse serialized struct definition
        // Format: "STRUCT|field1=Type1|field2=Type2|..."
        mut parts := struct_def_str.split("|")
        mut current_offset := 0

        // Skip first part ("STRUCT") and iterate through field definitions
        mut i := 1
        while lt(i, parts.len) {
            mut field_def := ""
            parts.get(i, field_def)

            // Split field_def by "=" to get field_name=field_type
            mut field_parts := field_def.split("=")
            if gteq(field_parts.len, 2) {
                mut field_name := ""
                mut field_type := ""
                field_parts.get(0, field_name)
                field_parts.get(1, field_type)

                // Get field size
                mut field_size := self.get_type_size(field_type)

                // Build source and destination keys
                mut src_key := format(src, ".", field_name)
                mut dest_key := format(dest, ".", field_name)

                // Get source offset
                mut arena_map := self.arena_index
                mut src_offset_str := arena_map.get(src_key)
                if src_offset_str.eq("") {
                    throw format(loc(), " ERROR: copy_fields: source offset for '", src_key, "' not found")
                }
                mut src_offset := src_offset_str.to_i64()

                // Calculate destination offset
                mut dest_offset := add(dest_base_offset, current_offset)

                // Register destination field in arena_index and symbols
                mut arena_idx_map := self.arena_index
                arena_idx_map.insert(dest_key, dest_offset.to_str())
                self.arena_index = arena_idx_map

                mut syms := self.symbols
                // TODO: Serialize SymbolInfo properly (for now just store type)
                syms.insert(dest_key, format("ValueType.TCustom=", field_type))
                self.symbols = syms

                // Copy memory from source to destination (simplified: copy string value)
                mut mem_arr := self.arena.memory
                mut value_str := ""
                mem_arr.get(src_offset, value_str)
                mem_arr.set(dest_offset, value_str)
                self.arena.memory = mem_arr

                // Recursively handle nested structs
                mut struct_defs := self.struct_defs
                mut nested_struct_def := struct_defs.get(field_type)
                if not(nested_struct_def.eq("")) {
                    self.copy_fields(field_type, src_key, dest_key)
                }

                current_offset = add(current_offset, field_size)
            }

            i = add(i, 1)
        }
    }

    // Insert struct instance into arena
    insert_struct := proc(mut self: Context, var_name: Str, custom_type_name: Str) throws Str, AllocError, IndexOutOfBoundsError {
        // Get struct definition
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(custom_type_name)
        if struct_def_str.eq("") {
            throw format(loc(), " ERROR: insert_struct: definition for '", custom_type_name, "' not found")
        }

        // Get instance mutability from symbols
        mut symbols_map := self.symbols
        mut symbol_info_str := symbols_map.get(var_name)
        if symbol_info_str.eq("") {
            throw format(loc(), " ERROR: insert_struct: var_name '", var_name, "' not found in symbols")
        }
        // TODO: Parse SymbolInfo to get is_mut (for now assume mutable)

        // Calculate total size (reuse get_type_size which already does this)
        mut total_size := self.get_type_size(custom_type_name)

        // Allocate blob in arena
        mut arena := self.arena
        mut offset := arena.memory.len
        arena.memory.resize(add(offset, total_size))
        self.arena = arena

        // Register base offset in arena_index
        mut arena_map := self.arena_index
        arena_map.insert(var_name, offset.to_str())
        self.arena_index = arena_map

        // Parse serialized struct definition to initialize fields
        // Format: "STRUCT|field1=Type1|field2=Type2|..."
        mut parts := struct_def_str.split("|")
        mut current_offset := 0

        // Skip first part ("STRUCT") and iterate through field definitions
        mut i := 1
        while lt(i, parts.len) {
            mut field_def := ""
            parts.get(i, field_def)

            // Split field_def by "=" to get field_name=field_type
            mut field_parts := field_def.split("=")
            if gteq(field_parts.len, 2) {
                mut field_name := ""
                mut field_type := ""
                field_parts.get(0, field_name)
                field_parts.get(1, field_type)

                mut combined_name := format(var_name, ".", field_name)
                mut field_offset := add(offset, current_offset)

                // Register field in arena_index
                mut arena_idx := self.arena_index
                arena_idx.insert(combined_name, field_offset.to_str())
                self.arena_index = arena_idx

                // Register field in symbols
                mut syms := self.symbols
                syms.insert(combined_name, format("ValueType.TCustom=", field_type))
                self.symbols = syms

                // TODO: Initialize field with default value
                // For now, fields are zero-initialized by resize()

                // Recursively handle nested structs
                mut struct_defs := self.struct_defs
                mut nested_struct_def := struct_defs.get(field_type)
                if not(nested_struct_def.eq("")) {
                    self.insert_struct(combined_name, field_type)
                }

                // Calculate field size and increment offset
                mut field_size := self.get_type_size(field_type)
                current_offset = add(current_offset, field_size)
            }

            i = add(i, 1)
        }
    }

    // Register struct fields for type checking without evaluating defaults
    register_struct_fields_for_typecheck := proc(mut self: Context, instance_name: Str, struct_type_name: Str) throws Str, AllocError, IndexOutOfBoundsError {
        // Get struct definition
        mut struct_defs_map := self.struct_defs
        mut struct_def_str := struct_defs_map.get(struct_type_name)
        if struct_def_str.eq("") {
            // Struct definition not found - silently return (not all types are structs)
            return
        }

        // Parse serialized struct definition
        // Format: "STRUCT|field1=Type1|field2=Type2|..."
        mut parts := struct_def_str.split("|")

        // Skip first part ("STRUCT") and iterate through field definitions
        mut i := 1
        while lt(i, parts.len) {
            mut field_def := ""
            parts.get(i, field_def)

            // Split field_def by "=" to get field_name=field_type
            mut field_parts := field_def.split("=")
            if gteq(field_parts.len, 2) {
                mut field_name := ""
                mut field_type := ""
                field_parts.get(0, field_name)
                field_parts.get(1, field_type)

                // Build combined name (instance.field)
                mut combined_name := format(instance_name, ".", field_name)

                // Register field in symbols for type checking
                mut syms := self.symbols
                // TODO: Serialize SymbolInfo properly with is_mut
                // For now, just store type info
                syms.insert(combined_name, format("ValueType.TCustom=", field_type))
                self.symbols = syms

                // Recursively register nested struct fields
                mut struct_defs := self.struct_defs
                mut nested_struct_def := struct_defs.get(field_type)
                if not(nested_struct_def.eq("")) {
                    self.register_struct_fields_for_typecheck(combined_name, field_type)
                }
            }

            i = add(i, 1)
        }
    }

    // Get Str value from arena by variable name
    get_str := func(self: Context, var_name: Str) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Look up the offset in arena_index
        mut offset_str := self.arena_index.get(var_name)
        if offset_str.eq("") {
            throw format(loc(), " ERROR: Str variable '", var_name, "' not found in arena")
        }

        // Convert offset string to I64
        mut offset_str_copy := offset_str
        offset := offset_str_copy.to_i64()

        // Read Str from arena memory at offset (stored directly as string)
        mut value_str := ""
        mut mem_arr := self.arena.memory
        mem_arr.get(offset, value_str)

        return value_str
    }

    // Insert Str value into arena
    insert_str := proc(mut self: Context, var_name: Str, value: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Simplified storage: store string value directly (like I64/Bool)
        // TODO Phase 3+: Implement proper c_string/cap/len structure

        // Check if variable already exists
        mut offset_str := self.arena_index.get(var_name)

        if offset_str.eq("") {
            // New variable - allocate space
            offset := self.arena.next_offset
            mut offset_str_new := offset.to_str()

            // Store offset in index
            mut arena_idx := self.arena_index
            arena_idx.insert(var_name, offset_str_new)
            self.arena_index = arena_idx

            // Store value in arena memory
            mut mem_arr := self.arena.memory
            mem_arr.push(value)
            self.arena.memory = mem_arr

            // Update next offset
            self.arena.next_offset = add(offset, 1)
        }
        else {
            // Update existing variable
            mut offset_str_copy := offset_str
            offset := offset_str_copy.to_i64()

            mut mem_arr := self.arena.memory
            mem_arr.set(offset, value)
            self.arena.memory = mem_arr
        }
    }

    // Get enum value at specific arena offset
    get_enum_at_offset := func(self: Context, enum_type: Str, offset: I64) returns EnumVal throws Str, IndexOutOfBoundsError, I64_OverflowError {
        // Read enum value from arena at given offset
        mut enum_value := self.get_i64_at_offset(offset)

        // Get enum definition to map position to name
        mut enum_defs_map := self.enum_defs
        mut enum_def_str := enum_defs_map.get(enum_type)
        if enum_def_str.eq("") {
            throw format(loc(), " ERROR: get_enum_at_offset: Enum definition for '", enum_type, "' not found")
        }

        // Get variant name from position
        mut enum_name := self.variant_pos_to_str(enum_type, enum_value)

        // TODO: Handle payload reading from offset+8
        // For now, return enum without payload
        mut result := EnumVal()
        result.enum_type = enum_type
        result.enum_name = enum_name
        return result
    }

    // Insert array into arena
    insert_array := proc(mut self: Context, var_name: Str, elem_type: Str) throws Str, AllocError, IndexOutOfBoundsError, FullError, I64_OverflowError {
        // Allocate Array struct
        self.insert_struct(var_name, "Array")

        // Get element type size
        mut elem_size := self.get_type_size(elem_type)

        // Initialize Array fields
        // ptr = 0 (no buffer allocated yet)
        mut ptr_field := format(var_name, ".ptr")
        mut ptr_offset_str := self.arena_index.get(ptr_field)
        if not(ptr_offset_str.eq("")) {
            mut ptr_offset := ptr_offset_str.to_i64()
            self.set_i64_at_offset(ptr_offset, 0)
        }

        // len = 0 (empty array)
        mut len_field := format(var_name, ".len")
        mut len_offset_str := self.arena_index.get(len_field)
        if not(len_offset_str.eq("")) {
            mut len_offset := len_offset_str.to_i64()
            self.set_i64_at_offset(len_offset, 0)
        }

        // cap = 0 (no capacity)
        mut cap_field := format(var_name, ".cap")
        mut cap_offset_str := self.arena_index.get(cap_field)
        if not(cap_offset_str.eq("")) {
            mut cap_offset := cap_offset_str.to_i64()
            self.set_i64_at_offset(cap_offset, 0)
        }

        // is_dyn = false (static array)
        mut is_dyn_field := format(var_name, ".is_dyn")
        mut is_dyn_offset_str := self.arena_index.get(is_dyn_field)
        if not(is_dyn_offset_str.eq("")) {
            mut is_dyn_offset := is_dyn_offset_str.to_i64()
            self.insert_bool_at_offset(is_dyn_offset, false)
        }

        // type_name = elem_type (using insert_str for the type_name field)
        mut type_name_field := format(var_name, ".type_name")
        self.insert_str(type_name_field, elem_type)

        // type_size = elem_size
        mut type_size_field := format(var_name, ".type_size")
        mut type_size_offset_str := self.arena_index.get(type_size_field)
        if not(type_size_offset_str.eq("")) {
            mut type_size_offset := type_size_offset_str.to_i64()
            self.set_i64_at_offset(type_size_offset, elem_size)
        }

        // TODO: Support arrays with initial values
        // For now, creates empty array (len=0, cap=0, ptr=0)
    }
}

// Get function name from function call expression
// Corresponds to get_func_name_in_call in init.rs
get_func_name_in_call := proc(e: Expr) returns Str throws Str, IndexOutOfBoundsError {
    // Check that this is an FCall node
    mut node_type_str := enum_to_str(e.node_type)
    if not(node_type_str.eq("NodeType.FCall")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected FCall node, got ", node_type_str)
    }

    // Check that we have at least one parameter
    if lt(e.params.len, 1) {
        throw format(loc(), " ERROR: get_func_name_in_call(): FCall nodes must have at least 1 parameter")
    }

    // Get first parameter (function name)
    mut params := e.params
    mut func_name_expr := Expr()
    params.get(0, func_name_expr)

    // Extract identifier from node_type
    mut func_node_type := func_name_expr.node_type
    mut func_node_type_str := enum_to_str(func_node_type)
    if not(func_node_type_str.eq("NodeType.Identifier")) {
        throw format(loc(), " ERROR: get_func_name_in_call(): expected Identifier in params[0], got ", func_node_type_str)
    }

    // Extract the function name string from the Identifier payload using pattern matching
    mut func_name := ""
    switch func_node_type {
    case NodeType.Identifier(name):
        func_name = name
    case:
        // Should never happen due to the if check above
    }
    return func_name
}

// Check function/proc return type
// Corresponds to value_type_func_proc in init.rs
value_type_func_proc := proc(e: Expr, name: Str, func_def: SFuncDef) returns ValueType throws Str {
    // Check that function returns exactly one value
    mut returns_len := func_def.return_types.len

    if eq(returns_len, 0) {
        throw format(loc(), " ERROR: func '", name, "' does not return anything")
    }

    if gt(returns_len, 1) {
        throw format(loc(), " TODO: func '", name, "' returns multiple values (not yet supported)")
    }

    // Get the return type (should be at index 0)
    mut returns_arr := func_def.return_types
    mut return_type := ValueType.TCustom("")
    returns_arr.get(0, return_type)

    return return_type
}

// Get enum variant position by name
// Corresponds to get_variant_pos in init.rs
get_variant_pos := proc(enum_def: SEnumDef, variant_name: Str) returns I64 throws Str, IndexOutOfBoundsError {
    // Get position of variant in enum_map (maintains insertion order)
    mut enum_map := enum_def.enum_map
    pos := enum_map.position(variant_name)

    if lt(pos, 0) {
        throw format(loc(), " ERROR: Enum variant '", variant_name, "' not found in enum map")
    }

    return pos
}

// Get enum variant name by position
// Corresponds to variant_pos_to_str in init.rs
variant_pos_to_str := proc(enum_def: SEnumDef, position: I64) returns Str throws Str, IndexOutOfBoundsError, I64_OverflowError {
    // Get keys array from enum_map
    mut enum_map := enum_def.enum_map
    mut map_size := enum_map.len()

    // Validate position
    if lt(position, 0) {
        mut pos_str := position.to_str()
        throw format(loc(), " ERROR: Invalid position '", pos_str, "' for enum variant (negative)")
    }

    if not(lt(position, map_size)) {
        mut pos_str := position.to_str()
        mut size_str := map_size.to_str()
        throw format(loc(), " ERROR: Invalid position '", pos_str, "' for enum variant (max ", size_str, ")")
    }

    // Get key at position from enum_map.keys array
    mut variant_name := ""
    mut keys_arr := enum_map.keys
    keys_arr.get(position, variant_name)

    return variant_name
}

// Get value type for an expression (core type inference)
// Corresponds to get_value_type in init.rs
get_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle literals - use pattern matching to extract LiteralNodeType
    if node_type_str.eq("NodeType.Literal") {
        mut node_type := e.node_type
        switch node_type {
        case NodeType.Literal(lit_node_type):
            switch lit_node_type {
            case LiteralNodeType.I64:
                return ValueType.TCustom("I64")
            case LiteralNodeType.Bool:
                return ValueType.TCustom("Bool")
            case LiteralNodeType.String:
                return ValueType.TCustom("Str")
            case LiteralNodeType.List:
                return ValueType.TCustom("List")
            case:
                lit_type_str := enum_to_str(lit_node_type)
                throw format(loc(), " ERROR: Unknown literal type: ", lit_type_str)
            }
        case:
            // Should not happen due to if check above
            throw format(loc(), " ERROR: Expected NodeType.Literal")
        }
    }

    // Handle function definitions
    if node_type_str.eq("NodeType.FuncDef") {
        // Extract SFuncDef from payload
        mut func_def := SFuncDef()
        mut node_type := e.node_type
        switch node_type {
        case NodeType.FuncDef(fd):
            func_def = fd
        case:
            // Other node types
        }

        // Determine function type
        func_type := func_def.function_type
        func_type_str := enum_to_str(func_type)

        if func_type_str.eq("FunctionType.FTFunc") {
            return ValueType.TFunction(FunctionType.FTFunc)
        }
        if func_type_str.eq("FunctionType.FTFuncExt") {
            return ValueType.TFunction(FunctionType.FTFunc)
        }
        if func_type_str.eq("FunctionType.FTProc") {
            return ValueType.TFunction(FunctionType.FTProc)
        }
        if func_type_str.eq("FunctionType.FTProcExt") {
            return ValueType.TFunction(FunctionType.FTProc)
        }
        if func_type_str.eq("FunctionType.FTMacro") {
            return ValueType.TFunction(FunctionType.FTMacro)
        }

        throw format(loc(), " ERROR: Unknown function type: ", func_type_str)
    }

    // Handle enum definitions
    if node_type_str.eq("NodeType.EnumDef") {
        return ValueType.TType(TTypeDef.TEnumDef)
    }

    // Handle struct definitions
    if node_type_str.eq("NodeType.StructDef") {
        return ValueType.TType(TTypeDef.TStructDef)
    }

    // Handle function calls
    if node_type_str.eq("NodeType.FCall") {
        return get_fcall_value_type(context, e)
    }

    // Handle Range expressions
    if node_type_str.eq("NodeType.Range") {
        // TODO: Get type of range bounds and return appropriate RangeType
        // For now, assume I64Range
        return ValueType.TCustom("I64Range")
    }

    // Handle identifiers
    if node_type_str.eq("NodeType.Identifier") {
        // Extract identifier name using pattern matching
        mut id_name := ""
        mut node_type := e.node_type
        switch node_type {
        case NodeType.Identifier(name):
            id_name = name
        case:
            // Should never happen due to the if check above
        }

        // Look up symbol
        mut symbols_map := context.symbols
        mut symbol_str := symbols_map.get(id_name)
        if symbol_str.eq("") {
            throw format(loc(), " ERROR: Undefined symbol '", id_name, "'")
        }

        // TODO: Parse SymbolInfo to get actual value_type
        // For now, assume symbol_str contains the value type string
        mut current_type := ValueType.TCustom(id_name)

        // If there are no params, return the base type
        if eq(e.params.len, 0) {
            return current_type
        }

        // Process member access (e.params contains the chain like obj.field1.field2)
        mut i := 0
        mut params := e.params
        while lt(i, params.len) {
            mut member_expr := Expr()
            params.get(i, member_expr)

            // Get member name
            mut member_node_type := member_expr.node_type
            member_node_str := enum_to_str(member_node_type)
            if not(member_node_str.eq("NodeType.Identifier")) {
                throw format(loc(), " ERROR: Identifiers can only contain identifiers, found ", member_node_str)
            }

            mut member_name := ""
            switch member_node_type {
            case NodeType.Identifier(name):
                member_name = name
            case:
                // Should never happen due to the if check above
            }

            // Check current_type to determine how to resolve member
            current_type_str := enum_to_str(current_type)

            // Handle TType - accessing enum variant or struct member
            if current_type_str.eq("ValueType.TType") {
                mut ttype_def := TTypeDef.TEnumDef
                switch current_type {
                case ValueType.TType(ttype):
                    ttype_def = ttype
                case:
                    // other
                }
                ttype_str := enum_to_str(ttype_def)

                if ttype_str.eq("TTypeDef.TEnumDef") {
                    // Accessing enum variant - check if exists
                    mut enum_defs_map := context.enum_defs
                    mut enum_def_str := enum_defs_map.get(id_name)
                    if not(enum_def_str.eq("")) {
                        // TODO: Check if variant exists in enum_def
                        // For now, return TCustom(enum_name)
                        return ValueType.TCustom(id_name)
                    }
                }

                if ttype_str.eq("TTypeDef.TStructDef") {
                    // Accessing struct member
                    mut struct_defs_map := context.struct_defs
                    mut struct_def_str := struct_defs_map.get(id_name)
                    if not(struct_def_str.eq("")) {
                        // Parse struct definition to find member type
                        // Format: "STRUCT|field1=Type1|field2=Type2|..."
                        mut parts := struct_def_str.split("|")
                        mut j := 1
                        while lt(j, parts.len) {
                            mut field_def := ""
                            parts.get(j, field_def)
                            mut field_parts := field_def.split("=")
                            if gteq(field_parts.len, 2) {
                                mut fname := ""
                                mut ftype := ""
                                field_parts.get(0, fname)
                                field_parts.get(1, ftype)
                                if fname.eq(member_name) {
                                    return ValueType.TCustom(ftype)
                                }
                            }
                            j = add(j, 1)
                        }
                        // Member not found
                        throw format(loc(), " ERROR: Struct '", id_name, "' has no member '", member_name, "'")
                    }
                }
            }

            // Handle TCustom - accessing field on instance
            if current_type_str.eq("ValueType.TCustom") {
                mut custom_type_name := ""
                switch current_type {
                case ValueType.TCustom(name):
                    custom_type_name = name
                case:
                    // Should never happen due to the if check above
                }

                // Check if it's a struct instance
                mut struct_defs_map := context.struct_defs
                mut struct_def_str := struct_defs_map.get(custom_type_name)
                if not(struct_def_str.eq("")) {
                    // Parse struct definition to find member type
                    // Format: "STRUCT|field1=Type1|field2=Type2|..."
                    mut parts := struct_def_str.split("|")
                    mut found := false
                    mut j := 1
                    while lt(j, parts.len) {
                        mut field_def := ""
                        parts.get(j, field_def)
                        mut field_parts := field_def.split("=")
                        if gteq(field_parts.len, 2) {
                            mut fname := ""
                            mut ftype := ""
                            field_parts.get(0, fname)
                            field_parts.get(1, ftype)
                            if fname.eq(member_name) {
                                current_type = ValueType.TCustom(ftype)
                                found = true
                            }
                        }
                        j = add(j, 1)
                    }
                    if not(found) {
                        throw format(loc(), " ERROR: Struct '", custom_type_name, "' has no member '", member_name, "'")
                    }
                }
            }

            i = add(i, 1)
        }

        return current_type
    }

    // Handle Pattern (used in switch/case pattern matching)
    if node_type_str.eq("NodeType.Pattern") {
        // Extract enum type from variant_name in "EnumType.Variant" format
        mut pattern_info := PatternInfo()
        mut node_type := e.node_type
        switch node_type {
        case NodeType.Pattern(pi, _):
            pattern_info = pi
        case:
            // Should never happen
        }

        mut variant_name := pattern_info.variant_name

        // Find last dot to extract enum type
        if variant_name.contains(".") {
            // Split and get everything before the last dot
            mut parts := variant_name.split(".")
            if gt(parts.len, 1) {
                // Get all parts except the last one
                mut enum_type := ""
                mut i := 0
                while lt(i, sub(parts.len, 1)) {
                    mut part := ""
                    parts.get(i, part)
                    if gt(i, 0) {
                        enum_type = format(enum_type, ".", part)
                    }
                    else {
                        enum_type = part
                    }
                    i = add(i, 1)
                }
                return ValueType.TCustom(enum_type)
            }
        }

        // No dot found - assume whole thing is enum type
        return ValueType.TCustom(variant_name)
    }

    // Not implemented for other node types
    throw format(loc(), " TODO: get_value_type not fully implemented for node type: ", node_type_str)
}

// Get value type for function call expressions
// Corresponds to get_fcall_value_type in init.rs
// Parse serialized function definition to get return type
// Format: "FUNC|<function_type>|<return_type>"
parse_func_return_type := proc(serialized: Str) returns Str {
    // Split by "|" to get parts
    // Format: parts[0]="FUNC", parts[1]=function_type, parts[2]=return_type
    mut parts := serialized.split("|")
    mut return_type := ""
    if gt(parts.len, 2) {
        parts.get(2, return_type)
    }
    return return_type
}

get_fcall_value_type := proc(context: Context, e: Expr) returns ValueType throws Str, IndexOutOfBoundsError {
    // Get function name
    f_name := get_func_name_in_call(e)

    // Check for UFCS call (2+ params means target + args)
    if not(lt(e.params.len, 2)) {
        // Get first arg (the UFCS target)
        mut first_arg := Expr()
        mut params := e.params
        params.get(1, first_arg)

        // Try to get type of first argument
        mut target_type := get_value_type(context, first_arg)
        catch (err: Str) {
            // If we can't determine type, fall through to regular function lookup
        }

        // Check if target type has an associated method
        target_type_str := enum_to_str(target_type)
        if target_type_str.eq("ValueType.TCustom") {
            mut custom_type_name := ""
            switch target_type {
            case ValueType.TCustom(name):
                custom_type_name = name
            case:
                // Should never happen due to the if check above
            }

            // Check for associated method
            mut method_name := ""
            method_name = custom_type_name
            method_name = method_name.concat(".")
            method_name = method_name.concat(f_name)

            mut funcs_map := context.funcs
            mut method_def_str := funcs_map.get(method_name)
            if not(method_def_str.eq("")) {
                // Parse return type from serialized function definition
                mut return_type := parse_func_return_type(method_def_str)
                if return_type.eq("") {
                    throw format(loc(), " ERROR: Method '", method_name, "' has no return type")
                }
                return ValueType.TCustom(return_type)
            }
        }
    }

    // Check if it's a standalone function
    mut funcs_map := context.funcs
    mut func_def_str := funcs_map.get(f_name)
    if not(func_def_str.eq("")) {
        // Parse return type from serialized function definition
        mut return_type := parse_func_return_type(func_def_str)
        if return_type.eq("") {
            throw format(loc(), " ERROR: Function '", f_name, "' has no return type")
        }
        return ValueType.TCustom(return_type)
    }

    // Check if it's a struct or enum constructor
    mut symbols_map := context.symbols
    mut symbol_str := symbols_map.get(f_name)
    if not(symbol_str.eq("")) {
        // Check if it's a type (struct or enum)
        if symbol_str.eq("ValueType.TType") {
            // Get params[0] to check for member access (Struct.field or Enum.Variant)
            mut params := e.params
            mut id_expr := Expr()
            params.get(0, id_expr)

            // Check if id_expr has params (means Struct.field or Enum.Variant)
            if eq(id_expr.params.len, 0) {
                // Just the type itself - return TCustom(type_name)
                return ValueType.TCustom(f_name)
            }

            // Has params - check enum_defs and struct_defs
            mut enum_defs_map := context.enum_defs
            mut enum_def_str := enum_defs_map.get(f_name)
            if not(enum_def_str.eq("")) {
                // It's an enum - return TCustom(enum_name)
                return ValueType.TCustom(f_name)
            }

            mut struct_defs_map := context.struct_defs
            mut struct_def_str := struct_defs_map.get(f_name)
            if not(struct_def_str.eq("")) {
                // It's a struct - TODO: check if accessing field or calling method
                // For now, return TCustom(struct_name)
                return ValueType.TCustom(f_name)
            }
        }

        // Other symbol types - return as custom type
        return ValueType.TCustom(f_name)
    }

    // Function not found
    throw format(loc(), " ERROR: Unknown function or constructor '", f_name, "'")
}

// Process declarations in AST and register them in context
// Corresponds to init_context in init.rs (the declaration processing part)
process_declarations := proc(mut context: Context, e: Expr) throws Str, IndexOutOfBoundsError {
    // Match on node type
    mut node_type_str := enum_to_str(e.node_type)

    // Handle Body - recursively process all statements
    if node_type_str.eq("NodeType.Body") {
        mut i := 0
        mut params := e.params
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            process_declarations(context, stmt)
            i = add(i, 1)
        }
        return
    }

    // Handle FCall - check for import()
    if node_type_str.eq("NodeType.FCall") {
        f_name := get_func_name_in_call(e)
        mut f_name_copy := f_name
        if f_name_copy.eq("import") {
            // TODO: Process import declarations
            return
        }
    }

    // Handle Declaration nodes
    if node_type_str.eq("NodeType.Declaration") {
        // Extract Declaration from node_type
        mut decl := Declaration()
        mut node_type := e.node_type
        switch node_type {
        case NodeType.Declaration(d):
            decl = d
        case:
            // Other node types
        }

        // Check if already declared
        mut funcs_map := context.funcs
        mut symbols_map := context.symbols
        if funcs_map.contains_key(decl.name) {
            throw format(loc(), " ERROR: '", decl.name, "' already declared")
        }
        if symbols_map.contains_key(decl.name) {
            throw format(loc(), " ERROR: '", decl.name, "' already declared")
        }

        // Must have exactly one param (the initializer expression)
        if not(eq(e.params.len, 1)) {
            throw format(loc(), " ERROR: Declaration of '", decl.name, "' must have exactly one value")
        }

        // Get the initializer expression
        mut inner_e := Expr()
        mut params := e.params
        params.get(0, inner_e)

        // Get value type of initializer
        value_type := get_value_type(context, inner_e)

        // TODO: Type checking - verify declared type matches inferred type
        // For now, just use the inferred type

        // Register based on value type
        value_type_str := enum_to_str(value_type)

        // Handle functions
        if value_type_str.eq("ValueType.TFunction") {
            // Extract function definition from inner_e
            mut inner_node_type := inner_e.node_type
            inner_node_type_str := enum_to_str(inner_node_type)

            if inner_node_type_str.eq("NodeType.FuncDef") {
                mut func_def := SFuncDef()
                switch inner_node_type {
                case NodeType.FuncDef(fd):
                    func_def = fd
                case:
                    // Other node types
                }

                // Register in symbols and funcs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // Serialize func_def to string for storage
                // Format: "FUNC|<function_type>|<return_type>"
                // TODO: Add args, throw_types when needed
                mut ft_str := enum_to_str(func_def.function_type)
                mut ret_type := ""
                if gt(func_def.return_types.len, 0) {
                    func_def.return_types.get(0, ret_type)
                }
                mut serialized := format("FUNC|", ft_str, "|", ret_type)
                funcs_map.insert(decl.name, serialized)
                context.funcs = funcs_map
            }
            return
        }

        // Handle enum definitions
        if value_type_str.eq("ValueType.TType") {
            mut ttype_def := TTypeDef.TEnumDef
            switch value_type {
            case ValueType.TType(ttype):
                ttype_def = ttype
            case:
                // other
            }
            ttype_str := enum_to_str(ttype_def)

            if ttype_str.eq("TTypeDef.TEnumDef") {
                // Extract enum definition from inner_e
                mut inner_node_type := inner_e.node_type
                mut enum_def := SEnumDef()
                switch inner_node_type {
                case NodeType.EnumDef(ed):
                    enum_def = ed
                case:
                    // Other node types
                }

                // Register in symbols and enum_defs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // TODO: Store enum_def properly (currently storing as string)
                mut enum_defs_map := context.enum_defs
                enum_defs_map.insert(decl.name, "enum_def_placeholder")
                context.enum_defs = enum_defs_map
                return
            }

            if ttype_str.eq("TTypeDef.TStructDef") {
                // Extract struct definition from inner_e
                mut inner_node_type := inner_e.node_type
                mut struct_def := SStructDef()
                switch inner_node_type {
                case NodeType.StructDef(sd):
                    struct_def = sd
                case:
                    // Other node types
                }

                // Register in symbols and struct_defs
                symbols_map.insert(decl.name, value_type_str)
                context.symbols = symbols_map

                // Serialize struct_def to string for storage
                // Format: "STRUCT|field1=Type1|field2=Type2|..."
                mut serialized := "STRUCT"
                mut members_map := struct_def.members
                mut i := 0
                while lt(i, members_map.size) {
                    mut field_name := ""
                    mut field_type := ""
                    mut keys_arr := members_map.keys
                    mut values_arr := members_map.values
                    keys_arr.get(i, field_name)
                    values_arr.get(i, field_type)
                    serialized = format(serialized, "|", field_name, "=", field_type)
                    i = add(i, 1)
                }

                mut struct_defs_map := context.struct_defs
                struct_defs_map.insert(decl.name, serialized)
                context.struct_defs = struct_defs_map

                // TODO: Register associated functions and constants
                return
            }
        }

        // Handle custom types and multi types
        if value_type_str.eq("ValueType.TCustom") {
            symbols_map.insert(decl.name, value_type_str)
            context.symbols = symbols_map
            return
        }

        if value_type_str.eq("ValueType.TMulti") {
            symbols_map.insert(decl.name, value_type_str)
            context.symbols = symbols_map
            return
        }

        // Unknown type - register anyway
        symbols_map.insert(decl.name, value_type_str)
        context.symbols = symbols_map
        return
    }

    // For other node types, no declaration processing needed
}

// Process import declarations during init phase
init_import_declarations := proc(mut context: Context, e: Expr, import_path: Str) throws Str, AllocError, IndexOutOfBoundsError {
    // TODO: Read import file, parse it, copy declarations to parent context
    // TODO: Track in imports_declarations_done and imports_wip for cycle detection
    // For now, just throw TODO
    throw format(loc(), " TODO: init_import_declarations not fully implemented for path '", import_path, "'")
}

// Context priming / declaration indexing
// Process AST and register all declarations (funcs, enums, structs, vars)
// Returns array of error strings (empty if success)
// Corresponds to init_context in init.rs
init_context := proc(mut context: Context, e: Expr) returns Array throws Str, AllocError, IndexOutOfBoundsError {
    mut errors := Array.new_dyn("Str", size_of(Str))

    // Match on node type
    switch e.node_type {
    case NodeType.Body:
        // Recursively process all statements in body
        mut params := e.params
        mut i := 0
        while lt(i, params.len) {
            mut stmt := Expr()
            params.get(i, stmt)
            mut stmt_errors := init_context(context, stmt)
            // Extend errors array with stmt_errors
            mut j := 0
            while lt(j, stmt_errors.len) {
                mut err_str := ""
                stmt_errors.get(j, err_str)
                errors.push(err_str)
                j = add(j, 1)
            }
            i = add(i, 1)
        }

    case NodeType.FCall:
        // Check if this is an import call
        f_name := get_func_name_in_call(e)
        if f_name.eq("import") {
            // TODO: Handle import - extract path and call init_import_declarations
            TODO(loc(), "import handling not yet implemented in init_context")
        }

    case NodeType.Declaration(decl):
        // Check for duplicate declaration
        mut symbols_map := context.symbols
        mut funcs_map := context.funcs
        if symbols_map.contains(decl.name) {
            errors.push(e.error("type", format("'", decl.name, "' already declared.")))
        }

        // Declaration must have exactly one value (the initializer)
        mut params := e.params
        if not(params.len.eq(1)) {
            errors.push(e.exit_error("type", format("in init_context, while declaring ", decl.name, ", declarations must take exactly one value.")))
            return errors
        }

        // Get the initializer expression
        mut inner_e := Expr()
        params.get(0, inner_e)

        // Get value type of initializer
        // TODO: Call get_value_type once it's fully homologized
        mut value_type := ValueType.TCustom("TODO_get_value_type")

        // For now, just register symbols with placeholder type
        // TODO: Complete type checking and proper registration
        mut symbol_info := SymbolInfo()
        symbol_info.value_type = value_type
        symbol_info.is_mut = decl.is_mut
        context.symbols.set(decl.name, "TODO_serialize_SymbolInfo")

        TODO(loc(), format("Full declaration processing not yet implemented for '", decl.name, "'"))

    case:
        // Other node types - check mode constraints
        // TODO: Add mode validation
    }

    return errors
}

// Check if function/proc has variadic arguments
// Corresponds to func_proc_has_multi_arg in typer.rs
func_proc_has_multi_arg := proc(func_def: SFuncDef) returns Bool {
    // TODO: Need to iterate through func_def.args and check for TMulti type
    // For now, return false (no variadic support in type checking yet)
    TODO(loc(), "func_proc_has_multi_arg: Need SFuncDef arg iteration")
    return false
}

// Get function definition for a function call
// Corresponds to get_func_def_for_fcall_with_expr in typer.rs
// Returns Option.Some(SFuncDef) if found, Option.None for struct constructors
get_func_def_for_fcall := proc(context: Context, e: Expr) returns Option throws Str, IndexOutOfBoundsError {
    // TODO: Extract function name, look up in context.funcs
    // TODO: Handle UFCS (Uniform Function Call Syntax)
    // TODO: Return None for struct constructors
    // For now, return None to allow struct instantiation
    TODO(loc(), "get_func_def_for_fcall: Need function lookup implementation")
    return Option.None
}
