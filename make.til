#!/usr/bin/env -S ./bin/rstil run
// make.til - TIL build system (Issue #82)

mode make

import("std.io")
import("std.sys")
import("core.vec")

// Global flag: set to true when compiler (bin/rstil) changed
// Used to pass --force-rebuild to tests
mut g_compiler_changed := false

// Run command with streaming output (prints as it goes)
run_stream_cmd := proc(cmd: Str) returns I64 {
    println(cmd)
    pid := spawn_cmd(cmd)?
    status := wait_cmd(pid)

    catch (err: SpawnError) {
        println("ERROR: ", err.msg)
        exit(1)
    }

    return status
}

run_clean := proc() {
    _ := run_stream_cmd("rm -rf bin/* gen/*")
}

// REPL = Read-Eval-Print-Loop
run_repl := proc() {
    _ := run_stream_cmd("rlwrap ./bin/rstil repl")
}

/**
 * Checks if target needs to be rebuilt based on dependency modification times.
 * Returns true if target doesn't exist or any dependency is newer than target.
 * Used only for non-.til dependencies (Rust files, etc.)
 */
needs_rebuild := proc(target: Str, deps: Vec) returns Bool {
    target_mtime := file_mtime(target)
    neg_one := sub(0, 1)
    if target_mtime.eq(neg_one) {
        return true  // target doesn't exist
    }
    for dep: Str in deps {
        dep_mtime := file_mtime(dep)
        if dep_mtime.gt(target_mtime) {
            return true  // dependency is newer
        }
    }
    return false
}

build_rstil := proc() {
    // Check if rstil needs rebuilding (Rust files - not tracked by til build)
    mut deps := Vec.new(Str)
    deps.push("src/rstil.rs")
    rs_files := glob_files("src/rs/*.rs")?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    for f: Str in rs_files { deps.push(f) }

    if needs_rebuild("bin/rstil", deps).not() {
        return
    }

    mut status := 0
    status = run_stream_cmd("mkdir -p bin")
    status = run_stream_cmd("rustc -D warnings src/rstil.rs -o bin/rstil")
    if status.eq(0).not() {
        exit(1)
    }
}

build_rstil_til := proc() {
    // .til dependency tracking is automatic via `rstil build`
    // But automatic tracking only knows about .til files, not the compiler itself.
    // If bin/rstil changed, we must force rebuild even if .til files are unchanged.
    mut deps := Vec.new(Str)
    deps.push("bin/rstil")
    mut status := 0
    status = run_stream_cmd("mkdir -p bin")
    if needs_rebuild("bin/til", deps) {
        // Compiler changed - force rebuild (automatic tracking wouldn't catch this)
        // Also set global flag so tests know to force rebuild
        g_compiler_changed = true
        status = run_stream_cmd("./bin/rstil build src/til.til --force-rebuild")
    } else {
        // Compiler unchanged - let automatic .til dep tracking decide
        status = run_stream_cmd("./bin/rstil build src/til.til")
    }
    if status.eq(0).not() {
        exit(1)
    }
    _ := run_stream_cmd("cp gen/c/til.c bootstrap/til.c")
    _ := run_stream_cmd("cp bin/til bin/rstil_til")
}

// WARNING: This target currently hangs!
// ./bin/til translate src/til.til takes >2min and doesn't complete
build_til_til := proc() {
    mut status := 0
    status = run_stream_cmd("mkdir -p tmp")
    status = run_stream_cmd("./bin/til build src/til.til")
    status = run_stream_cmd("cp gen/c/til.c tmp/til_by_til.c")
    status = run_stream_cmd("cp bin/til bin/til_til")
    if status.eq(0).not() {
        exit(1)
    }
}

build_test_runner := proc() {
    build_rstil_til()
    // .til dependency tracking is automatic via `rstil build`
    mut status := 0
    status = run_stream_cmd("./bin/rstil build src/test_runner.til")
    if status.eq(0).not() {
        exit(1)
    }
}

build_tests := proc() {
    build_test_runner()  // tests.til spawns test_runner for each test
    // .til dependency tracking is automatic via `rstil build`
    mut status := 0
    status = run_stream_cmd("./bin/rstil build src/tests.til")
    if status.eq(0).not() {
        exit(1)
    }
}

run_tests := proc() {
    build_tests()
    mut status := 0
    // Pass --force-rebuild to tests if compiler changed
    // This ensures tests rebuild when rstil changed, even if test .til files didn't
    if g_compiler_changed {
        status = run_stream_cmd("./bin/tests --force-rebuild")
    } else {
        status = run_stream_cmd("./bin/tests")
    }
    tests_status := status
    status = run_stream_cmd("cp gen/c/test/constfold.c src/test/constfold.c")
    println("Remember to add generated files to commit: bootstrap/til.c, src/test/constfold.c")
    if tests_status.eq(0).not() {
        exit(1)
    }
}

run_regen := proc() {
    build_tests()
    mut status := 0
    // Pass --force-rebuild to regen if compiler changed
    if g_compiler_changed {
        status = run_stream_cmd("./bin/tests --force-rebuild regen")
    } else {
        status = run_stream_cmd("./bin/tests regen")
    }
    println("Regenerated all test outputs")
    if status.eq(0).not() {
        exit(1)
    }
}

run_benchmark := proc() {
    run_tests()
    _ := run_stream_cmd("cp gen/benchmark.org doc/benchmark.org")
    println("Benchmark saved to doc/benchmark.org, can be committed")
}

run_test_cross := proc() {
    mut status := 0
    println("=== Cross-compilation tests ===")
    println("linux-arm64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-arm64")
    status = run_stream_cmd("qemu-aarch64 -L /usr/aarch64-linux-gnu ./bin/examples/hello_script")
    println("linux-riscv64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-riscv64")
    status = run_stream_cmd("qemu-riscv64 -L /usr/riscv64-linux-gnu ./bin/examples/hello_script")
    println("windows-x64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=windows-x64")
    status = run_stream_cmd("wine ./bin/examples/hello_script.exe")
    // TODO: macos-x64, macos-arm64 (no emulator available)
    // TODO: wasm32 (needs libc/wasi support)
    println("=== All cross-compilation tests passed ===")
}

// Build til with debug symbols and run gdb
build_til_debug := proc() {
    build_rstil_til()
    mut status := 0
    status = run_stream_cmd("gcc -g -O0 -o bin/til_debug gen/c/til.c -lm -I src")
    if status.eq(0).not() {
        exit(1)
    }
    _ := run_stream_cmd("gdb ./bin/til_debug")
}

// WARNING: This target depends on til_til which hangs
diff_til := proc() {
    // Compare C output from rstil vs til
    mut status := 0
    status = run_stream_cmd("diff bootstrap/til.c tmp/til_by_til.c")
    if status.eq(0).not() {
        exit(1)
    }
}

main := proc(args: ..Str) {
    if not(args.len().eq(1)) {
        println("Usage: make.til <target>")
        println("Available targets: clean, rstil, repl, rstil_til, til_til, til_debug, tests, regen, benchmark, test-cross, diff_til")
        exit(1)
    }
    mut target := ""
    args.get(0, target)?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    switch target {
    case "clean":
        run_clean()
    case "rstil":
        build_rstil()
    case "repl":
        run_repl()
    case "rstil_til":
        build_rstil_til()
    case "til_til":
        build_til_til()
    case "til_debug":
        build_til_debug()
    case "tests":
        run_tests()
    case "regen":
        run_regen()
    case "benchmark":
        run_benchmark()
    case "test-cross":
        run_test_cross()
    case "diff_til":
        diff_til()
    case:
        println("Unknown target: ", target)
        println("Available targets: clean, rstil, repl, rstil_til, til_til, til_debug, tests, regen, benchmark, test-cross, diff_til")
        exit(1)
    }
}
