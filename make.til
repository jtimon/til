#!/usr/bin/env -S ./bin/rstil interpret
// make.til - TIL build system (Issue #82)

mode make

import("std.io")
import("std.sys")
import("core.vec")

// Run command with streaming output (prints as it goes)
run_stream_cmd := proc(cmd: Str) returns I64 {
    println(cmd)
    pid := spawn_cmd(cmd)
    status := wait_cmd(pid)

    catch (err: SpawnError) {
        println("ERROR: ", err.msg)
        exit(1)
    }
    catch (err: SleepError) {
        println("ERROR: ", err.msg)
        exit(1)
    }

    return status
}

run_clean := proc() {
    _ := run_stream_cmd("rm -rf bin/* gen/*")
}

// REPL = Read-Eval-Print-Loop
run_repl := proc() {
    _ := run_stream_cmd("rlwrap ./bin/rstil repl")
}

build_rstil := proc() {
    // Check if rstil needs rebuilding
    mut deps := Vec.new(Str)
    deps.push("src/rstil.rs")
    rs_files := glob_files("src/rs/*.rs")
    for f: Str in rs_files { deps.push(f) }

    if needs_rebuild("bin/rstil", deps).not() {
        return
    }

    mut status := 0
    status = run_stream_cmd("mkdir -p bin")
    status = run_stream_cmd("rustc src/rstil.rs -o bin/rstil")
    if status.eq(0).not() {
        exit(1)
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: AllocError) { panic(loc(), err.msg) }
}

/**
 * Checks if target needs to be rebuilt based on dependency modification times.
 * Returns true if target doesn't exist or any dependency is newer than target.
 */
needs_rebuild := proc(target: Str, deps: Vec) returns Bool {
    target_mtime := file_mtime(target)
    neg_one := sub(0, 1)
    if target_mtime.eq(neg_one) {
        return true  // target doesn't exist
    }
    for dep: Str in deps {
        dep_mtime := file_mtime(dep)
        if dep_mtime.gt(target_mtime) {
            return true  // dependency is newer
        }
    }
    return false
}

build_rstil_til := proc() {
    // Collect dependencies
    mut deps := Vec.new(Str)
    deps.push("bin/rstil")
    deps.push("src/til.til")
    self_files := glob_files("src/self/*.til")
    for f: Str in self_files { deps.push(f) }
    core_files := glob_files("src/core/*.til")
    for f: Str in core_files { deps.push(f) }
    std_files := glob_files("src/std/*.til")
    for f: Str in std_files { deps.push(f) }
    mode_files := glob_files("src/modes/*.til")
    for f: Str in mode_files { deps.push(f) }

    if needs_rebuild("bin/rstil_til", deps).not() {
        return
    }

    mut status := 0
    status = run_stream_cmd("mkdir -p bin")
    status = run_stream_cmd("./bin/rstil build src/til.til")
    status = run_stream_cmd("cp gen/c/til.c bootstrap/til.c")
    status = run_stream_cmd("cp bin/til bin/rstil_til")
    if status.eq(0).not() {
        exit(1)
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: AllocError) { panic(loc(), err.msg) }
}

// WARNING: This target currently hangs!
// ./bin/til translate src/til.til takes >2min and doesn't complete
build_til_til := proc() {
    mut status := 0
    status = run_stream_cmd("mkdir -p tmp")
    status = run_stream_cmd("./bin/til build src/til.til")
    status = run_stream_cmd("cp gen/c/til.c tmp/til_by_til.c")
    status = run_stream_cmd("cp bin/til bin/til_til")
    if status.eq(0).not() {
        exit(1)
    }
}

build_tests := proc() {
    build_rstil_til()

    // Collect dependencies - same as rstil_til plus tests.til
    mut deps := Vec.new(Str)
    deps.push("bin/rstil")
    deps.push("src/tests.til")
    self_files := glob_files("src/self/*.til")
    for f: Str in self_files { deps.push(f) }
    core_files := glob_files("src/core/*.til")
    for f: Str in core_files { deps.push(f) }
    std_files := glob_files("src/std/*.til")
    for f: Str in std_files { deps.push(f) }
    mode_files := glob_files("src/modes/*.til")
    for f: Str in mode_files { deps.push(f) }

    if needs_rebuild("bin/tests", deps).not() {
        return
    }

    mut status := 0
    status = run_stream_cmd("./bin/rstil build src/tests.til")
    if status.eq(0).not() {
        exit(1)
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: AllocError) { panic(loc(), err.msg) }
}

run_tests := proc() {
    build_tests()
    mut status := 0
    status = run_stream_cmd("./bin/tests")
    status = run_stream_cmd("cp gen/c/test/constfold.c src/test/constfold.c")
    println("Remember to add generated files to commit: bootstrap/til.c, src/test/constfold.c")
    if status.eq(0).not() {
        exit(1)
    }
}

run_regen := proc() {
    build_tests()
    mut status := 0
    status = run_stream_cmd("./bin/tests regen")
    println("Regenerated all test outputs")
    if status.eq(0).not() {
        exit(1)
    }
}

run_benchmark := proc() {
    run_tests()
    _ := run_stream_cmd("cp gen/benchmark.org doc/benchmark.org")
    println("Benchmark saved to doc/benchmark.org, can be committed")
}

run_test_cross := proc() {
    mut status := 0
    println("=== Cross-compilation tests ===")
    println("linux-arm64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-arm64")
    status = run_stream_cmd("qemu-aarch64 -L /usr/aarch64-linux-gnu ./bin/examples/hello_script")
    println("linux-riscv64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-riscv64")
    status = run_stream_cmd("qemu-riscv64 -L /usr/riscv64-linux-gnu ./bin/examples/hello_script")
    println("windows-x64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=windows-x64")
    status = run_stream_cmd("wine ./bin/examples/hello_script.exe")
    // TODO: macos-x64, macos-arm64 (no emulator available)
    // TODO: wasm32 (needs libc/wasi support)
    println("=== All cross-compilation tests passed ===")
}

// WARNING: This target depends on til_til which hangs
diff_til := proc() {
    // Compare C output from rstil vs til
    mut status := 0
    status = run_stream_cmd("diff bootstrap/til.c tmp/til_by_til.c")
    if status.eq(0).not() {
        exit(1)
    }
}

main := proc(args: ..Str) {
    if not(args.len().eq(1)) {
        println("Usage: make.til <target>")
        println("Available targets: clean, rstil, repl, rstil_til, til_til, tests, regen, benchmark, test-cross, diff_til")
        exit(1)
    }
    mut target := ""
    args.get(0, target)
    switch target {
    case "clean":
        run_clean()
    case "rstil":
        build_rstil()
    case "repl":
        run_repl()
    case "rstil_til":
        build_rstil_til()
    case "til_til":
        build_til_til()
    case "tests":
        run_tests()
    case "regen":
        run_regen()
    case "benchmark":
        run_benchmark()
    case "test-cross":
        run_test_cross()
    case "diff_til":
        diff_til()
    case:
        println("Unknown target: ", target)
        println("Available targets: clean, rstil, repl, rstil_til, til_til, tests, regen, benchmark, test-cross, diff_til")
        exit(1)
    }

    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
}
