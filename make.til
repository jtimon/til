#!/usr/bin/env -S ./bin/rstil run
// make.til - TIL build system (Issue #82)

mode make

import("std.io")
import("std.sys")
import("core.vec")

// Global flag: --cc=COMPILER override (Issue #131)
// Empty string means use default
mut g_cc := ""

// Get --cc flag string for commands (returns "" if not set, " --cc=X" if set)
get_cc_flag := func() returns Str {
    if g_cc.is_empty() {
        return ""
    }
    return concat(" --cc=", g_cc)
}

// Run command with streaming output (prints as it goes)
run_stream_cmd := proc(cmd: Str) returns I64 {
    println(cmd)
    pid := spawn_cmd(cmd)?
    status := wait_cmd(pid)

    catch (err: SpawnError) {
        println("ERROR: ", err.msg)
        exit(1)
    }

    return status
}

run_clean := proc() {
    _ := run_stream_cmd("rm -rf bin/* gen/*")
}

// REPL = Read-Eval-Print-Loop
run_repl := proc() {
    _ := run_stream_cmd("rlwrap ./bin/rstil repl")
}

/**
 * Checks if target needs to be rebuilt based on dependency modification times.
 * Returns true if target doesn't exist or any dependency is newer than target.
 * Used only for non-.til dependencies (Rust files, etc.)
 */
needs_rebuild := proc(target: Str, deps: Vec) returns Bool {
    target_mtime := file_mtime(target)
    if target_mtime.eq(I64_MINUS1) {
        return true  // target doesn't exist
    }
    for dep: Str in deps {
        dep_mtime := file_mtime(dep)
        if dep_mtime.gt(target_mtime) {
            return true  // dependency is newer
        }
    }
    return false
}

build_rstil := proc() {
    // Check if rstil needs rebuilding (Rust files - not tracked by til build)
    mut deps := Vec.new(Str)
    deps.push("src/rstil.rs")
    rs_files := glob_files("src/rs/*.rs")?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    catch (err: IOError) { panic(loc(), err.msg) }
    for f: Str in rs_files { deps.push(f) }

    if needs_rebuild("bin/rstil", deps).not() {
        return
    }

    mut status := 0
    status = run_stream_cmd("mkdir -p bin")
    status = run_stream_cmd("rustc -D warnings src/rstil.rs -o bin/rstil")
    if status.eq(0).not() {
        exit(1)
    }
}

build_rstil_til := proc() {
    // .til dependency tracking is automatic via `rstil build`
    // But automatic tracking only knows about .til files, not the compiler itself.
    // If bin/rstil changed, we must force rebuild even if .til files are unchanged.
    // Bug #141: rstil outputs to bin/rs/ and gen/rs/c/
    mut deps := Vec.new(Str)
    deps.push("bin/rstil")
    mut status := 0
    status = run_stream_cmd("mkdir -p bin/rs")
    cc_flag := get_cc_flag()
    if needs_rebuild("bin/rs/til", deps) {
        // Compiler changed - force rebuild (automatic tracking wouldn't catch this)
        status = run_stream_cmd(concat("./bin/rstil build src/til.til --force-rebuild", cc_flag))
    } else {
        // Compiler unchanged - let automatic .til dep tracking decide
        status = run_stream_cmd(concat("./bin/rstil build src/til.til", cc_flag))
    }
    if status.eq(0).not() {
        exit(1)
    }
    _ := run_stream_cmd("cp gen/rs/c/til.c bootstrap/til.c")
    println("rstil_til binary: bin/rs/til")
}

// WARNING: This target currently hangs!
// ./bin/rs/til translate src/til.til takes >2min and doesn't complete
// Bug #141: til outputs to bin/til/ and gen/til/c/
build_til_til := proc() {
    mut status := 0
    status = run_stream_cmd("./bin/rs/til build src/til.til")
    if status.eq(0).not() {
        exit(1)
    }
    println("til_til binary: bin/til/til")
    println("til_til C output: gen/til/c/til.c")
}

build_test_runner := proc() {
    build_rstil_til()
    // .til dependency tracking is automatic via `rstil build`
    // Bug #141: rstil outputs to bin/rs/
    mut status := 0
    status = run_stream_cmd(concat("./bin/rstil build src/test_runner.til", get_cc_flag()))
    if status.eq(0).not() {
        exit(1)
    }
}

build_tests := proc() {
    build_test_runner()  // tests.til spawns test_runner for each test
    // .til dependency tracking is automatic via `rstil build`
    mut status := 0
    status = run_stream_cmd(concat("./bin/rstil build src/tests.til", get_cc_flag()))
    if status.eq(0).not() {
        exit(1)
    }
}

run_tests := proc() {
    build_tests()
    mut status := 0
    // Issue #131: Pass --cc flag to tests
    // test_runner.til calls rstil/til build per test, which has needs_rebuild logic
    cc_flag := get_cc_flag()
    status = run_stream_cmd(concat("./bin/rs/tests", cc_flag))
    tests_status := status
    status = run_stream_cmd("cp gen/rs/c/test/constfold.c src/test/constfold.c")
    println("Remember to add generated files to commit: bootstrap/til.c, src/test/constfold.c")
    if tests_status.eq(0).not() {
        exit(1)
    }
}

run_regen := proc() {
    build_tests()
    mut status := 0
    // Issue #131: Pass --cc flag to tests
    cc_flag := get_cc_flag()
    status = run_stream_cmd(concat("./bin/rs/tests", cc_flag).concat(" regen"))
    println("Regenerated all test outputs")
    if status.eq(0).not() {
        exit(1)
    }
}

run_benchmark := proc() {
    run_tests()
    _ := run_stream_cmd("cp gen/totals.org doc/totals.org")
    println("Benchmark saved to doc/totals.org, can be committed")
}

run_mem_report := proc() {
    build_tests()
    cc_flag := get_cc_flag()
    // Write flag file so compiled tests/test_runner can detect --mem-report
    // Don't pass --mem-report on command line - it would enable HeapState in
    // tests/test_runner themselves (C runtime strips it). Flag file is sufficient.
    writefile("tmp/.mem_report_flag", "1")?
    status := run_stream_cmd(format("./bin/rs/tests", cc_flag))
    // Clean up flag file
    mut rm_out := ""
    _ := rm_out.run_cmd("rm", "-f", "tmp/.mem_report_flag")
    if status.eq(0).not() {
        exit(1)
    }
    _ := run_stream_cmd("cp gen/totals.org doc/totals.org")
    _ := run_stream_cmd("cp gen/totals_mem.org doc/totals_mem.org")
    println("Memory report saved to doc/totals_mem.org")

    catch (err: WriteError) { panic(loc(), err.msg) }
}

run_test_cross := proc() {
    mut status := 0
    println("=== Cross-compilation tests ===")
    // Bug #141: rstil outputs to bin/rs/
    println("linux-arm64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-arm64")
    status = run_stream_cmd("qemu-aarch64 -L /usr/aarch64-linux-gnu ./bin/rs/examples/hello_script")
    println("linux-riscv64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=linux-riscv64")
    status = run_stream_cmd("qemu-riscv64 -L /usr/riscv64-linux-gnu ./bin/rs/examples/hello_script")
    println("windows-x64...")
    status = run_stream_cmd("./bin/rstil build src/examples/hello_script.til --target=windows-x64")
    status = run_stream_cmd("wine ./bin/rs/examples/hello_script.exe")
    // TODO: macos-x64, macos-arm64 (no emulator available)
    // TODO: wasm32 (needs libc/wasi support)
    println("=== All cross-compilation tests passed ===")
}

// Build til with debug symbols and run gdb
// Bug #141: rstil outputs to gen/rs/c/
build_til_debug := proc() {
    build_rstil_til()
    mut status := 0
    status = run_stream_cmd("gcc -g -O0 -o bin/til_debug gen/rs/c/til.c -lm -I src")
    if status.eq(0).not() {
        exit(1)
    }
    _ := run_stream_cmd("gdb ./bin/til_debug")
}

// Compare C output from rstil vs til for a given file
run_diff := proc(file_path: Str) {
    build_rstil_til()
    mut status := 0
    status = run_stream_cmd(concat("./bin/rstil interpret src/til_diff.til ", file_path))
    if status.eq(0).not() {
        exit(1)
    }
}

main := proc(args: ..Str) {
    if args.len().eq(0) {
        println("Usage: make.til <target> [options]")
        println("Available targets: clean, rstil, repl, rstil_til, til_til, til_debug, tests, regen, benchmark, mem-report, test-cross, diff <file>")
        println("Options: --cc=COMPILER (e.g., --cc=clang)")
        exit(1)
    }
    // Parse --cc= option (Issue #131)
    mut remaining_args := Vec.new(Str)
    for arg: Str in args {
        if arg.starts_with("--cc=") {
            g_cc = arg.get_substr(5, arg.len())?
        } else {
            remaining_args.push(arg)
        }
    }
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    if remaining_args.len().eq(0) {
        println("Usage: make.til <target> [options]")
        exit(1)
    }
    mut target := ""
    remaining_args.get(0, target)?
    catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
    switch target {
    case "clean":
        run_clean()
    case "rstil":
        build_rstil()
    case "repl":
        run_repl()
    case "rstil_til":
        build_rstil_til()
    case "til_til":
        build_til_til()
    case "til_debug":
        build_til_debug()
    case "tests":
        run_tests()
    case "regen":
        run_regen()
    case "benchmark":
        run_benchmark()
    case "mem-report":
        run_mem_report()
    case "test-cross":
        run_test_cross()
    case "diff":
        if args.len().lt(2) {
            println("Usage: make diff <file.til>")
            exit(1)
        }
        mut file_path := ""
        args.get(1, file_path)?
        catch (err: IndexOutOfBoundsError) { panic(loc(), err.msg) }
        run_diff(file_path)
    case:
        println("Unknown target: ", target)
        println("Available targets: clean, rstil, repl, rstil_til, til_til, til_debug, tests, regen, benchmark, mem-report, test-cross, diff <file>")
        exit(1)
    }
}
