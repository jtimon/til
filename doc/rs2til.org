
Translation patterns for converting Rust code to TIL, primarily for self-hosting the compiler/interpreter.

See also: [[file:rs.org][Rust Rules]] - things NOT to do in Rust code.

* Overview

TIL and Rust have different idioms, but the translation is mechanical. This guide documents the patterns discovered when analyzing lexer.rs, parser.rs, and init.rs against their TIL counterparts.

** panic vs throw/catch

| Rust | TIL | Notes |
|------|-----|-------|
| ~panic!()~ | ~panic()~ | Avoid both - nothing to translate |
| ~Result/Option~ + ~?~ | ~throw/catch~ | This is the translation |
| ~match~ on Option/Result | ~switch~ | Explicit case handling |

~unwrap()~ is hidden ~panic!()~ - avoid it, use ~?~ or ~match~ instead.

* Lexer Patterns (lexer.rs -> lexer.til)

** Match on Option<byte> -> switch on string

Rust:
#+begin_src rust
match source.as_bytes().get(pos).copied() {
    Some(b'0'..=b'9') => ...,
    Some(b'a'..=b'z') | Some(b'A'..=b'Z') => ...,
    _ => ...
}
#+end_src

TIL:
#+begin_src til
c := source.get_substr(pos, pos.add(1))
switch c {
    case "0".."9": ...
    case "a".."z": ...
    case "A".."Z": ...
    case: ...
}
#+end_src

** String slicing

Rust: ~&source[start..end]~
TIL: ~source.get_substr(start, end)~

** OR patterns in match

Rust uses ~|~ to combine patterns. TIL uses separate case arms:

Rust:
#+begin_src rust
Some(b'a'..=b'z') | Some(b'A'..=b'Z') | Some(b'_') => is_ident()
#+end_src

TIL:
#+begin_src til
case "a".."z": is_ident()
case "A".."Z": is_ident()
case "_": is_ident()
#+end_src

* Parser Patterns (parser.rs -> parser.til)

** OR patterns in match

Rust:
#+begin_src rust
match func_type {
    FunctionType::FTProc | FunctionType::FTProcExt => true,
    _ => false
}
#+end_src

TIL:
#+begin_src til
switch func_type {
    case FTProc: return true
    case FTProcExt: return true
    case: return false
}
#+end_src

** Vec literals

Rust: ~vec![a, b, c]~

TIL:
#+begin_src til
mut v := Vec.new(T)
v.push(a)
v.push(b)
v.push(c)
#+end_src

** Struct literals

Rust:
#+begin_src rust
let info = SymbolInfo {
    value_type: some_type,
    is_mut: true,
    is_copy: false,
    is_own: false,
};
#+end_src

TIL uses constructor-style syntax with named arguments. Only specify fields that differ from defaults:
#+begin_src til
// Only set fields that differ from struct defaults
info := SymbolInfo(value_type=some_type, is_mut=true)

// All fields use defaults
info := SymbolInfo()

// Order doesn't matter
p := Vec2(y=20, x=10)
#+end_src

* Init Patterns (init.rs -> init.til)

** Not-equal comparisons (ne -> not(eq()))

TIL does not have a ~ne~ function. Use ~not(eq())~ instead:

Rust:
#+begin_src rust
if a != b { ... }
if x.len() != 0 { ... }
#+end_src

TIL:
#+begin_src til
if not(a.eq(b)) { ... }
if not(x.len().eq(0)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.ne()~ - it doesn't exist in TIL. Always use ~not(eq())~ or ~not(...eq(...))~.

** Enum comparisons (use switch, not eq)

Enums do NOT have an ~.eq()~ method. Use ~switch~ to compare enum values:

Rust:
#+begin_src rust
if value_type == ValueType::TInfer { ... }
if my_enum != SomeEnum::Variant { ... }
#+end_src

TIL:
#+begin_src til
// For equality check, use switch with a boolean flag
mut is_infer := false
switch value_type {
case ValueType.TInfer:
    is_infer = true
case:
    // Other variants
}
if is_infer { ... }

// For inequality, negate the flag
if not(is_infer) { ... }
#+end_src

For enum comparisons where you need to compare two enum values, prefer ~switch~ or use
a type-specific ~_to_str~ function if one exists (e.g., ~value_type_to_str~ for ValueType):
#+begin_src til
// Preferred: use switch
mut types_match := false
switch type_a {
case ValueType.TCustom(name_a):
    switch type_b {
    case ValueType.TCustom(name_b):
        types_match = name_a.eq(name_b)
    case:
    }
case:
    // handle other cases
}

// Alternative: use type-specific _to_str function if available
if value_type_to_str(type_a).eq(value_type_to_str(type_b)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.eq()~ on enums - it doesn't exist. Do NOT use ~enum_to_str()~ for
comparisons - it only returns the variant name without payloads. Use ~switch~ or type-specific
~_to_str~ functions that include payload information.

** Pattern variable scoping in switch/case

CRITICAL: Pattern variables in ~switch/case~ are scoped to the case block only, just like
Rust's ~match~ arms. This means you CANNOT use a flag pattern when extracting payloads.

Rust:
#+begin_src rust
for p in body.params {
    match p.node_type {
        NodeType::Declaration(decl) => {
            members.push(decl.clone());
            default_values.insert(decl.name.clone(), val.clone());
        },
        _ => return Err("expected declaration"),
    }
}
#+end_src

TIL (CORRECT):
#+begin_src til
for p: Expr in body.params {
    switch p.node_type {
    case NodeType.Declaration(decl):
        members.push(decl)
        default_values.insert(decl.name, val)
    case:
        throw "expected declaration"
    }
}
#+end_src

TIL (WRONG - DO NOT DO THIS):
#+begin_src til
for p: Expr in body.params {
    // BUG: This does NOT work!
    mut is_declaration := false
    mut decl := Declaration()  // outer empty decl
    switch p.node_type {
    case NodeType.Declaration(decl):  // shadows outer, gets payload
        is_declaration = true
    case:
    }
    if is_declaration {
        members.push(decl)  // BUG: uses outer empty decl, NOT the pattern variable!
    }
}
#+end_src

The pattern variable ~decl~ only exists inside the case block. All logic using it must be there.

** if let Some(x) = ...

Rust uses ~if let~ for Option destructuring. TIL uses catch blocks with the out-parameter pattern:

Rust:
#+begin_src rust
if let Some(val) = map.get(key) {
    // use val
}
#+end_src

TIL (catch block with out-parameter):
#+begin_src til
mut val := DefaultType()
map.get(key, val)
catch (err: KeyNotFoundError) {
    // key not found - handle or ignore
}
// use val (has value if key was found)
#+end_src

TIL (check existence first):
#+begin_src til
if map.contains_key(key) {
    mut val := DefaultType()
    map.get(key, val)
    // use val
}
#+end_src

** Reverse iteration

Rust: ~items.iter().rev()~

TIL (reverse range loop):
#+begin_src til
// Iterate len-1 down to 0 (inclusive) - use sub(0, 1) as end
for i in items.len().sub(1)..sub(0, 1) {
    mut item := T()
    items.get(i, item)
    // use item
}
#+end_src

Note: Reverse ranges exclude the end value, just like forward ranges. ~5..0~ iterates 5, 4, 3, 2, 1.
To include index 0, use ~..sub(0, 1)~ (equivalent to ~..-1~).
For literal ranges, direction is detected at parse time; for variable ranges, at runtime.

** break and continue

TIL supports ~break~ and ~continue~ statements for loop control.

*** break

Works in both ~while~ and ~for~ loops. Only breaks the innermost loop.

#+begin_src til
while condition {
    if should_exit {
        break
    }
}

for i in 0..10 {
    if i.eq(5) {
        break  // exits loop when i is 5
    }
}
#+end_src

*** continue

Works in ~while~ loops only. Does NOT work correctly in ~for~ loops.

#+begin_src til
// CORRECT: continue in while loop
mut i := 0
while lt(i, 10) {
    i.inc()
    if i.eq(5) {
        continue  // skip rest of body, go to next iteration
    }
    // ... rest of body
}
#+end_src

WARNING: ~continue~ in ~for~ loops causes infinite loops because ~for~ desugars to
~while~ with the increment at the end of the body. ~continue~ skips the increment.

#+begin_src til
// WRONG: causes infinite loop!
for i in 0..10 {
    if i.eq(5) {
        continue  // BUG: skips the implicit i.inc(), loops forever at i=5
    }
}

// CORRECT: use while with manual increment before continue
mut i := 0
while lt(i, 10) {
    i.inc()  // increment BEFORE any continue
    if i.eq(5) {
        continue
    }
    // ...
}
#+end_src

** For-in loops

Rust:
#+begin_src rust
for item in &items {
    // use item
}

for (i, item) in items.iter().enumerate() {
    // use i and item
}
#+end_src

TIL:
#+begin_src til
for item: T in items {
    // use item
}

for i in 0..items.len() {
    mut item := T()
    items.get(i, item)
    // use i and item
}
#+end_src

Note: TIL's ~for item: T in vec~ iterates by value. For indexed access, use range loop with ~get~.

** Return type and error translation patterns

This is the canonical mapping from Rust return types to TIL throws:

| Rust                        | TIL                                  |
|-----------------------------+--------------------------------------|
| ~Result<T, String>~         | ~returns T throws Str~               |
| ~Option<T>~                 | ~returns T throws KeyNotFoundError~  |
| ~Result<Option<T>, String>~ | ~returns T throws Str, KeyNotFoundError~ |

Examples:

Rust:
#+begin_src rust
fn lookup_symbol(&self, name: &str) -> Option<&SymbolInfo> { ... }
fn parse_expr(&mut self) -> Result<Expr, String> { ... }
fn try_lookup(&self, name: &str) -> Result<Option<&Value>, String> { ... }
#+end_src

TIL:
#+begin_src til
lookup_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws KeyNotFoundError { ... }
parse_expr := func(mut self: Parser) returns Expr throws Str { ... }
try_lookup := func(self: Context, name: Str) returns Value throws Str, KeyNotFoundError { ... }
#+end_src

IMPORTANT: Internal errors (like ~IndexOutOfBoundsError~ from ~Vec.get()~) should be caught
internally and NOT exposed in the throws signature. Only expose the semantic error types
that correspond to the Rust return type.

** Option handling patterns

Rust uses ~Option<T>~ with ~.ok_or_else()~, ~.is_some()~, ~.is_none()~.

TIL uses throw/catch instead:
- Function throws ~KeyNotFoundError~ instead of returning None
- Caller uses catch block to handle the not-found case
- ~map.contains_key(k)~ to check existence without fetching

** The ? operator is implicit in TIL

Rust uses ~?~ to propagate errors up the call stack:
#+begin_src rust
let x = foo()?;  // propagates error if foo() returns Err
let y = bar()?.baz()?;  // chains propagation
#+end_src

TIL has NO ~?~ operator. Error propagation is automatic:
#+begin_src til
x := foo()  // automatically propagates if foo() throws
y := bar().baz()  // chains automatically
#+end_src

When porting Rust to TIL:
- Remove all ~?~ operators - they're implicit
- Change ~Result<T, String>~ to ~returns T throws Str~
- Change ~panic!("msg")~ to ~throw "msg"~
- Errors propagate automatically unless caught

Example - converting panic! to Result/throw:

Rust (before):
#+begin_src rust
pub fn reserve(&mut self, size: usize) -> usize {
    if new_len > ARENA_SIZE { panic!("arena overflow"); }
    // ...
}
#+end_src

Rust (after):
#+begin_src rust
pub fn reserve(&mut self, size: usize) -> Result<usize, String> {
    if new_len > ARENA_SIZE { return Err("arena overflow".to_string()); }
    // ...
}
// Call sites use: arena.reserve(size)?
#+end_src

TIL:
#+begin_src til
reserve := proc(mut self: Arena, size: I64) returns I64 throws Str {
    if gt(new_len, ARENA_SIZE) { throw "arena overflow" }
    // ...
}
// Call sites: arena.reserve(size)  -- ? is implicit
#+end_src

** Default switch case syntax

Rust uses ~_~ for catch-all. TIL uses empty ~case:~

Rust:
#+begin_src rust
match x {
    Foo::A => ...,
    _ => ...  // catch-all
}
#+end_src

TIL:
#+begin_src til
switch x {
    case Foo.A: ...
    case: ...  // catch-all (NOT "case _:")
}
#+end_src

** NULL pointer comparison

Rust: ~ptr.is_some()~ or ~ptr != NULL~

TIL: Use ~not(NULL.eq(ptr.data))~ - TIL doesn't have ~.ne()~ method:

#+begin_src til
if not(NULL.eq(func_ptr.data)) {
    // pointer is valid
}
#+end_src

** Option<T> struct fields -> Ptr

Rust uses ~Option<T>~ for optional struct fields. TIL uses ~Ptr~ where ~NULL~ represents ~None~:

Rust:
#+begin_src rust
struct EnumVal {
    pub payload: Option<Vec<u8>>,
    pub payload_type: Option<ValueType>,
}

// Usage
if let Some(payload_type) = &enum_val.payload_type {
    // use payload_type
}
#+end_src

TIL:
#+begin_src til
EnumVal := struct {
    mut payload: Ptr = Ptr()  // Ptr to Vec<U8>, NULL = None
    mut payload_type: Ptr = Ptr()  // Ptr to ValueType, NULL = None
}

// Usage - check for NULL to see if present
if not(NULL.eq(enum_val.payload_type.data)) {
    // pointer is valid, use it
}
#+end_src

Comment pattern: ~# Ptr to T, NULL = None~ or ~// Ptr for Option pattern, NULL = None~

** Vec/Map.get() out-parameter pattern

Rust returns the value directly. TIL uses out-parameter pattern:

Rust:
#+begin_src rust
let item = vec.get(i)?;
let val = map.get(&key)?;
#+end_src

TIL:
#+begin_src til
mut item := T()  // default init
vec.get(i, item)  // out-parameter, throws IndexOutOfBoundsError

mut val := V()
map.get(key, val)  // out-parameter, throws KeyNotFoundError
#+end_src

** HashMap.insert vs Map.insert/set

IMPORTANT: Rust's ~HashMap.insert()~ OVERWRITES existing keys. TIL's ~Map.insert()~ THROWS ~DuplicatedKeyError~ on existing keys!

Rust:
#+begin_src rust
map.insert(key, value);  // Overwrites if key exists, no error
#+end_src

TIL:
#+begin_src til
// WRONG - throws DuplicatedKeyError if key exists
map.insert(key, value)

// CORRECT - use set() to match Rust's overwrite behavior
map.set(key, value)  // Overwrites if key exists, like Rust
#+end_src

Use ~Map.insert()~ only when you want to enforce unique keys (throws on duplicate).
Use ~Map.set()~ when you want Rust's HashMap.insert behavior (overwrites).

** Catch blocks placement

Catch blocks CANNOT be placed in unreachable code (after the final return/throw of a function).
Placement depends on the error type:

*** KeyNotFoundError (like Rust's Option::None)

Place catch immediately after the throwing call, before using the result:

#+begin_src til
lookup_func := func(self: ScopeStack, name: Str) returns SFuncDef throws KeyNotFoundError {
    for i in self.frames.len().sub(1)..sub(0, 1) {
        mut frame := ScopeFrame()
        self.frames.get(i, frame)

        if frame.funcs.contains_key(name) {
            mut func_def := SFuncDef()
            frame.funcs.get(name, func_def)
            catch (err: KeyNotFoundError) {
                // Function not found, continue searching
            }
            return func_def
        }
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in lookup_func: ", err.msg)
    }
    throw KeyNotFoundError(msg="lookup_func: Function not found in Context")
}
#+end_src

*** Panic-like errors (IndexOutOfBoundsError, AllocError, etc.)

Can be grouped at the end of the function to avoid repetition:

#+begin_src til
my_func := func() returns T throws Str {
    // ... code that may throw various errors ...

    result := compute_result()

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}
#+end_src

*** panic for impossible errors

Use ~panic(loc(), "message")~ for errors that should never happen (e.g., index errors when iterating within known bounds):

#+begin_src til
for i in vec.len().sub(1)..sub(0, 1) {
    mut item := T()
    vec.get(i, item)
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "vec.get can't fail: i is always within bounds: ", err.msg)
    }
    // use item
}
#+end_src

*** lang_error for better error messages (TIL improvement over Rust)

When a function has an ~Expr~ parameter, use ~e.lang_error()~ instead of ~panic()~ for
internal errors. This provides source location from the expression being processed,
giving better error messages than Rust's implicit panics:

#+begin_src til
// When you have an Expr available, use lang_error for better diagnostics
process_expr := func(context: Context, e: Expr) returns T throws Str {
    mut items := get_items()
    for item: Item in items {
        // ... processing that might fail ...
    }

    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "phase_name", format("Internal error: ", err.msg))
    }
    // ...
}
#+end_src

This is better than Rust because:
- Rust would silently panic on index out of bounds
- TIL can catch and rethrow with source location info from the Expr

*** loc().concat() for functions without Expr

When a function does NOT have an ~Expr~ parameter but still needs to report errors
with location info, use ~loc().concat()~ to include the source location:

#+begin_src til
// When you don't have an Expr, use loc().concat() for error messages
all_structs := func(self: ScopeStack) returns Vec throws Str {
    mut result := Vec.new(SStructDef)
    // ... iteration logic ...

    catch (err: IndexOutOfBoundsError) {
        throw loc().concat("IndexOutOfBoundsError in all_structs: ").concat(err.msg)
    }
    catch (err: AllocError) {
        throw loc().concat("AllocError in all_structs: ").concat(err.msg)
    }
    return result
}
#+end_src

This provides the location where the error was thrown (the catch block), which is
helpful for debugging internal errors.

* Clone Methods (derive(Clone) -> manual implementation)

Rust uses ~#[derive(Clone)]~ to auto-generate clone methods. TIL has no derive macros,
so clone methods must be written manually for each struct/enum that needs them.

Rust:
#+begin_src rust
#[derive(Clone)]
struct MyStruct {
    field1: String,
    field2: i64,
}
#+end_src

TIL:
#+begin_src til
MyStruct := struct {
    mut field1: Str = ""
    mut field2: I64 = 0

    clone := func(self: MyStruct) returns MyStruct {
        mut result := MyStruct()
        result.field1 = self.field1.clone()
        result.field2 = self.field2
        return result
    }
}
#+end_src

Clone behavior by type:
- Primitives (I64, Bool, U8): direct copy, no clone needed
- Simple enums (no heap data): direct copy, no clone needed
- Enums with Str/Vec payloads: NEED deep clone functions (see below)
- Str: use ~.clone()~
- Vec: use ~.clone()~ (deep copy)
- Map: use ~.clone()~ (deep copy)
- Structs: create clone method, copy each field appropriately

** Simple enums (no heap data)

Enums without Str/Vec payloads are value types and copy automatically:

#+begin_src til
// Simple enum - just assign, copies by value
MyEnum := enum { A, B, C }
copy := my_enum
#+end_src

** Enums with heap data (Str/Vec payloads)

Enums containing Str or Vec fields need deep clone functions to copy the heap data.
Otherwise you get shallow copies where multiple values point to the same heap memory.

Example from parser.til:
#+begin_src til
// Literal enum has Str payloads - needs deep clone
literal_clone := func(lit: Literal) returns Literal throws AllocError {
    switch lit {
    case Literal.Str(s):
        return Literal.Str(s.clone())
    case Literal.I64(n):
        return Literal.I64(n)  // primitive, no clone needed
    case Literal.Bool(b):
        return Literal.Bool(b)
    // ... other variants
    }
}

// NodeType, ValueType, Token also need clone functions
node_type_clone := func(nt: NodeType) returns NodeType throws AllocError { ... }
value_type_clone := func(vt: ValueType) returns ValueType throws AllocError { ... }
Token.clone := func(self: Token) returns Token throws AllocError { ... }
#+end_src

IMPORTANT: When a struct contains other structs that need cloning, call their
clone methods recursively.

* func vs proc

~func~ and ~proc~ indicate function purity, NOT whether a function can throw:

- ~func~ = pure function (no side effects, deterministic output based only on inputs)
- ~proc~ = procedure (may have side effects like I/O, mutation of external state, etc.)

The ~throws~ section is completely independent of func/proc. Both can throw:

#+begin_src til
// Pure function that can throw
get_value := func(map: Map, key: Str) returns Str throws KeyNotFoundError {
    mut result := ""
    map.get(key, result)
    return result
}

// Procedure that can throw
read_file := proc(path: Str) returns Str throws Str {
    // Has side effects (I/O), so it's a proc
    return file_read(path)
}

// Pure function that doesn't throw
add := func(a: I64, b: I64) returns I64 {
    return a.add(b)
}
#+end_src

IMPORTANT: Do NOT assume ~func~ means "cannot throw". The distinction is purely about purity/side effects.

* Porting Workflow

When porting changes from Rust to TIL:

1. First make and test all changes in the Rust files
2. Run ~git diff 'src/**/*.rs'~ to see exactly what changed
3. For each changed file (e.g. ~ccodegen.rs~), apply the same changes to the TIL equivalent (~ccodegen.til~)
4. Run ~make tests~ to verify the port is correct

The git diff shows exactly what lines changed, making the translation mechanical - just convert the Rust syntax to TIL syntax for each change.

* Summary

The translation is mechanical:
1. OR patterns (~|~) -> separate case arms
2. ~if let~ -> check default value or catch block
3. Iterator methods -> explicit loops
4. Return type translation:
   - ~Result<T, String>~ -> ~returns T throws Str~
   - ~Option<T>~ -> ~returns T throws KeyNotFoundError~
   - ~Result<Option<T>, String>~ -> ~returns T throws Str, KeyNotFoundError~
5. Internal errors (IndexOutOfBoundsError, AllocError, etc.) should be caught internally, not exposed
6. String slicing -> ~get_substr~
7. UFCS works similarly: ~a.method(b)~ in both languages
8. Default case: ~_~ -> empty ~case:~
9. NULL check: ~!= NULL~ -> ~not(NULL.eq(x))~
10. ~vec.get(i)~ -> out-parameter: ~vec.get(i, out_val)~
11. Catch blocks come before final return/throw
12. Not-equal: ~!=~ or ~.ne()~ -> ~not(eq())~ or ~not(x.eq(y))~ (TIL has no ~ne~ function)
13. Enum comparison: ~==~ on enums -> use ~switch~ or type-specific ~_to_str~ functions (enums have no ~eq~ method, ~enum_to_str~ ignores payloads)
14. Pattern variables in switch/case are scoped to the case block - do ALL work with payloads inside the case
15. ~break~ works in while and for loops; ~continue~ works in while loops only (NOT for loops - causes infinite loop)
16. Enums with Str/Vec payloads need deep clone functions (~literal_clone~, ~node_type_clone~, etc.); simple enums copy by value
17. ~HashMap.insert()~ -> ~Map.set()~ (Rust overwrites, TIL's ~insert~ throws on duplicate; use ~set~ to match Rust behavior)
18. ~vec.extend(std::iter::repeat(v).take(n))~ -> ~vec.extend_with(v, n)~
