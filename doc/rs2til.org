
Translation patterns for converting Rust code to TIL, primarily for self-hosting the compiler/interpreter.

See also: [[file:rs.org][Rust Rules]] - things NOT to do in Rust code.

* IMPORTANT: These Are RULES, Not Recommendations

This document contains RULES to follow, not suggestions or recommendations. When porting Rust code to TIL:

1. Follow these patterns EXACTLY as documented
2. NEVER use shortcuts or workarounds without stopping to ask and getting explicit consent first
3. If something is unclear or seems difficult, ASK instead of inventing alternatives

Before translating complex Rust patterns, ask: "Is this complexity necessary in Rust itself?"
Often the simplest TIL translation comes from simplifying the source (e.g., parser enforcement
can eliminate runtime Option checks, intermediate structs may be avoidable by iterating directly).

* Overview

TIL and Rust have different idioms, but the translation is mechanical. This guide documents the patterns discovered when analyzing lexer.rs, parser.rs, and init.rs against their TIL counterparts.

** panic vs throw/catch

| Rust | TIL | Notes |
|------|-----|-------|
| ~panic!()~ | ~panic()~ | Avoid both - nothing to translate |
| ~Result/Option~ + ~?~ | ~throw/catch~ | This is the translation |
| ~match~ on Option/Result | ~switch~ | Explicit case handling |

~unwrap()~ is hidden ~panic!()~ - avoid it, use ~?~ or ~match~ instead.

* Lexer Patterns (lexer.rs -> lexer.til)

** Match on Option<byte> -> switch on string

Rust:
#+begin_src rust
match source.as_bytes().get(pos).copied() {
    Some(b'0'..=b'9') => ...,
    Some(b'a'..=b'z') | Some(b'A'..=b'Z') => ...,
    _ => ...
}
#+end_src

TIL:
#+begin_src til
c := source.get_substr(pos, pos.add(1))
switch c {
    case "0".."9": ...
    case "a".."z": ...
    case "A".."Z": ...
    case: ...
}
#+end_src

** String slicing

Rust: ~&source[start..end]~
TIL: ~source.get_substr(start, end)~

** OR patterns in match

Rust uses ~|~ to combine patterns. TIL uses separate case arms:

Rust:
#+begin_src rust
Some(b'a'..=b'z') | Some(b'A'..=b'Z') | Some(b'_') => is_ident()
#+end_src

TIL:
#+begin_src til
case "a".."z": is_ident()
case "A".."Z": is_ident()
case "_": is_ident()
#+end_src

* Parser Patterns (parser.rs -> parser.til)

** OR patterns in match

Rust:
#+begin_src rust
match func_type {
    FunctionType::FTProc | FunctionType::FTProcExt => true,
    _ => false
}
#+end_src

TIL:
#+begin_src til
switch func_type {
    case FTProc: return true
    case FTProcExt: return true
    case: return false
}
#+end_src

** Vec literals

Rust: ~vec![a, b, c]~

TIL:
#+begin_src til
mut v := Vec.new(T)
v.push(a)
v.push(b)
v.push(c)
#+end_src

** Array concatenation (no literal syntax)

Rust uses inline array concatenation with ~[arr1, arr2].concat()~:

#+begin_src rust
let common: &[&str] = &["-Wall", "-Wextra"];
let extra: &[&str] = &["-Wno-unused"];
// Return concatenated arrays
[&["-target", "arm64"], common, extra].concat()
#+end_src

TIL has no array literal syntax. Use helper procs that push to a Vec:

#+begin_src til
// Helper procs that mutate Vec
push_common := proc(mut result: Vec) {
    result.push("-Wall")
    result.push("-Wextra")
}

push_extra := proc(mut result: Vec) {
    result.push("-Wno-unused")
}

get_flags := func() returns Vec {
    mut result := Vec.new(Str)
    result.push("-target")
    result.push("arm64")
    push_common(result)
    push_extra(result)
    return result
}
#+end_src

Note: Functions returning Vec types (Vec<I64>, Vec<U8>, Vec<Str>, Vec<Vec<T>>) can use ~func~ normally.
For List and Map, use ~proc~ to prevent precomputation (Bug #133 partial fix - List/Map not yet supported).

** Struct literals

Rust:
#+begin_src rust
let info = SymbolInfo {
    value_type: some_type,
    is_mut: true,
    is_copy: false,
    is_own: false,
};
#+end_src

TIL uses constructor-style syntax with named arguments. Only specify fields that differ from defaults:
#+begin_src til
// Only set fields that differ from struct defaults
info := SymbolInfo(value_type=some_type, is_mut=true)

// All fields use defaults
info := SymbolInfo()

// Order doesn't matter
p := Vec2(y=20, x=10)
#+end_src

* Init Patterns (init.rs -> init.til)

** Not-equal comparisons (ne -> not(eq()))

TIL does not have a ~ne~ function. Use ~not(eq())~ instead:

Rust:
#+begin_src rust
if a != b { ... }
if x.len() != 0 { ... }
#+end_src

TIL:
#+begin_src til
if not(a.eq(b)) { ... }
if not(x.len().eq(0)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.ne()~ - it doesn't exist in TIL. Always use ~not(eq())~ or ~not(...eq(...))~.

** Enum comparisons (use switch, not eq)

Enums do NOT have an ~.eq()~ method. Use ~switch~ to compare enum values:

Rust:
#+begin_src rust
if value_type == ValueType::TInfer { ... }
if my_enum != SomeEnum::Variant { ... }
#+end_src

TIL:
#+begin_src til
// For equality check, use switch with a boolean flag
mut is_infer := false
switch value_type {
case ValueType.TInfer:
    is_infer = true
case:
    // Other variants
}
if is_infer { ... }

// For inequality, negate the flag
if not(is_infer) { ... }
#+end_src

For enum comparisons where you need to compare two enum values, prefer ~switch~ or use
a type-specific ~_to_str~ function if one exists (e.g., ~value_type_to_str~ for ValueType):
#+begin_src til
// Preferred: use switch
mut types_match := false
switch type_a {
case ValueType.TCustom(name_a):
    switch type_b {
    case ValueType.TCustom(name_b):
        types_match = name_a.eq(name_b)
    case:
    }
case:
    // handle other cases
}

// Alternative: use type-specific _to_str function if available
if value_type_to_str(type_a).eq(value_type_to_str(type_b)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.eq()~ on enums - it doesn't exist. Do NOT use ~enum_to_str()~ for
comparisons - it only returns the variant name without payloads. Use ~switch~ or type-specific
~_to_str~ functions that include payload information.

** Pattern variable scoping in switch/case

CRITICAL: Pattern variables in ~switch/case~ are scoped to the case block only, just like
Rust's ~match~ arms. This means you CANNOT use a flag pattern when extracting payloads.

Rust:
#+begin_src rust
for p in body.params {
    match p.node_type {
        NodeType::Declaration(decl) => {
            members.push(decl.clone());
            default_values.insert(decl.name.clone(), val.clone());
        },
        _ => return Err("expected declaration"),
    }
}
#+end_src

TIL (CORRECT):
#+begin_src til
for p: Expr in body.params {
    switch p.node_type {
    case NodeType.Declaration(decl):
        members.push(decl)
        default_values.insert(decl.name, val)
    case:
        throw "expected declaration"
    }
}
#+end_src

TIL (WRONG - DO NOT DO THIS):
#+begin_src til
for p: Expr in body.params {
    // BUG: This does NOT work!
    mut is_declaration := false
    mut decl := Declaration()  // outer empty decl
    switch p.node_type {
    case NodeType.Declaration(decl):  // shadows outer, gets payload
        is_declaration = true
    case:
    }
    if is_declaration {
        members.push(decl)  // BUG: uses outer empty decl, NOT the pattern variable!
    }
}
#+end_src

The pattern variable ~decl~ only exists inside the case block. All logic using it must be there.

** if let Some(x) = ...

Rust uses ~if let~ for Option destructuring. TIL uses catch blocks with the out-parameter pattern:

Rust:
#+begin_src rust
if let Some(val) = map.get(key) {
    // use val
}
#+end_src

TIL (catch block with out-parameter):
#+begin_src til
mut val := DefaultType()
map.get(key, val)?
catch (err: KeyNotFoundError) {
    // key not found - handle or ignore
}
// use val (has value if key was found)
#+end_src

TIL (check existence first):
#+begin_src til
if map.contains_key(key) {
    mut val := DefaultType()
    map.get(key, val)?
    // use val
}
#+end_src

** if let Some with early return

When Rust uses ~if let Some~ to check-and-return-early:

Rust:
#+begin_src rust
if let Some(temp_var) = ctx.hoisted_exprs.get(&expr_addr) {
    output.push_str(temp_var);
    return Ok(());
}
// continue with normal processing...
#+end_src

TIL:
#+begin_src til
ctx.hoisted_exprs.get(expr_addr, temp_var)?
output.push_str(temp_var)
return
catch (err: KeyNotFoundError) {
    // Not found, continue with normal processing
}
#+end_src

Catch blocks are reachable via the throw path, so ~return~ before ~catch~ works correctly.

** Multiple if let Some in sequence (catch ordering)

When Rust has multiple ~if let Some~ checks that can each fail independently, TIL must
place the catch IMMEDIATELY after each throwing call. This is because TIL catches handle
errors from ALL code above them, not just the most recent call.

Rust:
#+begin_src rust
// Nested if-let where None cases are ignored (no else branches)
if let NodeType::FCall(_) = &expr.node_type {
    if let Some(func_name) = get_func_name_string(&expr.params[0]) {
        // func_name is valid here
        if let Some(struct_def) = context.scope_stack.lookup_struct(&func_name) {
            // struct_def is valid here, use both func_name and struct_def
            process_struct_literal(func_name, struct_def);
        }
        // If lookup_struct returns None, we just skip this block
    }
    // If get_func_name_string returns None, we skip the whole thing
}
#+end_src

TIL (CORRECT - catch immediately after each throwing call):
#+begin_src til
switch expr.node_type {
case NodeType.FCall(_):
    mut func_name := get_func_name_string(first_param)?
    catch (err: KeyNotFoundError) {
        // REM: Equivalent to Rust's None case - just skip
    }
    // func_name is valid here

    mut struct_def := lookup_struct(func_name)?
    catch (err: KeyNotFoundError) {
        // REM: Equivalent to Rust's None case - just skip
    }
    // struct_def is valid here
    process_struct_literal(func_name, struct_def)
case:
}
#+end_src

TIL (WRONG - catches at end will fail):
#+begin_src til
// BUG: This does NOT work!
switch expr.node_type {
case NodeType.FCall(_):
    mut func_name := get_func_name_string(first_param)?  // throws KeyNotFoundError
    mut struct_def := lookup_struct(func_name)?          // also throws KeyNotFoundError

    // These catches are WRONG because:
    // 1. First catch handles errors from BOTH calls above
    // 2. Second catch has nothing left to catch (type error!)
    catch (err: KeyNotFoundError) { }  // catches from get_func_name_string AND lookup_struct
    catch (err: KeyNotFoundError) { }  // ERROR: nothing throws this anymore!
case:
}
#+end_src

Key insight: In TIL, ~catch~ blocks catch errors from ALL code that came before them,
not from a specific call. So when multiple calls throw the same error type, you MUST
place catches immediately after each call to handle them separately.

However, when all catches would do the same thing (e.g., panic, or rethrow as Str),
you can consolidate them into ONE catch at the end. This can make TIL code SIMPLER
than Rust:

#+begin_src til
// When all error handling is the same, ONE catch at the end suffices
mut func_name := get_func_name_string(first_param)?  // throws KeyNotFoundError
mut struct_def := lookup_struct(func_name)?          // throws KeyNotFoundError
process(func_name, struct_def)

catch (err: KeyNotFoundError) {
    panic(loc(), "unexpected None: ", err.msg)  // handles BOTH calls
}
#+end_src

Only place catches immediately after each call when you need DIFFERENT behavior for
each None case (e.g., skip vs error, or different fallback values).

When Rust's None case does nothing (no else branch), TIL uses an empty catch.
IMPORTANT: Never leave catch blocks completely empty - always add a "// REM:" comment
explaining why the catch is empty:
#+begin_src til
mut result := some_function_that_returns_option()?
catch (err: KeyNotFoundError) {
    // REM: Rust's None case did nothing, so we do nothing here
}
// Continue with result if it was found
#+end_src

** Reverse iteration

Rust: ~items.iter().rev()~

TIL (reverse range loop):
#+begin_src til
// Iterate len-1 down to 0 (inclusive) - use sub(0, 1) as end
for i in items.len().sub(1)..sub(0, 1) {
    mut item := T()
    items.get(i, item)?
    // use item
}
#+end_src

Note: Reverse ranges exclude the end value, just like forward ranges. ~5..0~ iterates 5, 4, 3, 2, 1.
To include index 0, use ~..sub(0, 1)~ (equivalent to ~..-1~).
For literal ranges, direction is detected at parse time; for variable ranges, at runtime.

** break and continue

TIL supports ~break~ and ~continue~ statements for loop control.

*** break

Works in both ~while~ and ~for~ loops. Only breaks the innermost loop.

#+begin_src til
while condition {
    if should_exit {
        break
    }
}

for i in 0..10 {
    if i.eq(5) {
        break  // exits loop when i is 5
    }
}
#+end_src

*** continue

Works in both ~while~ and ~for~ loops.

#+begin_src til
// continue in while loop
mut i := 0
while lt(i, 10) {
    i.inc()
    if i.eq(5) {
        continue  // skip rest of body, go to next iteration
    }
    // ... rest of body
}

// continue in for loop (works correctly)
for i in 0..10 {
    if i.eq(5) {
        continue  // skip adding 5 to sum
    }
    sum = sum.add(i)
}
// sum = 0+1+2+3+4+6+7+8+9 = 40
#+end_src

** For-in loops

Rust:
#+begin_src rust
for item in &items {
    // use item
}

for (i, item) in items.iter().enumerate() {
    // use i and item
}
#+end_src

TIL:
#+begin_src til
for item: T in items {
    // use item
}

for i in 0..items.len() {
    mut item := T()
    items.get(i, item)?
    // use i and item
}
#+end_src

Note: TIL's ~for item: T in vec~ iterates by value. For indexed access, use range loop with ~get~.

** Return type and error translation patterns

This is the canonical mapping from Rust return types to TIL throws:

| Rust                        | TIL                                  |
|-----------------------------+--------------------------------------|
| ~Result<T, String>~         | ~returns T throws Str~               |
| ~Option<T>~                 | ~returns T throws KeyNotFoundError~  |
| ~Result<Option<T>, String>~ | ~returns T throws Str, KeyNotFoundError~ |

Examples:

Rust:
#+begin_src rust
fn lookup_symbol(&self, name: &str) -> Option<&SymbolInfo> { ... }
fn parse_expr(&mut self) -> Result<Expr, String> { ... }
fn try_lookup(&self, name: &str) -> Result<Option<&Value>, String> { ... }
#+end_src

TIL:
#+begin_src til
lookup_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws KeyNotFoundError { ... }
parse_expr := func(mut self: Parser) returns Expr throws Str { ... }
try_lookup := func(self: Context, name: Str) returns Value throws Str, KeyNotFoundError { ... }
#+end_src

IMPORTANT: Internal errors (like ~IndexOutOfBoundsError~ from ~Vec.get()~) should be caught
internally and NOT exposed in the throws signature. Only expose the semantic error types
that correspond to the Rust return type.

** Option handling patterns

Rust uses ~Option<T>~ with ~.ok_or_else()~, ~.is_some()~, ~.is_none()~.

TIL uses throw/catch instead:
- Function throws ~KeyNotFoundError~ instead of returning None
- Caller uses catch block to handle the not-found case
- ~map.contains_key(k)~ to check existence without fetching

** The ? operator is mandatory in TIL (Issue #132)

Both Rust and TIL use ~?~ to mark calls to throwing functions:
#+begin_src rust
let x = foo()?;  // Rust: propagates error if foo() returns Err
let y = bar()?.baz()?;  // chains propagation
#+end_src

#+begin_src til
x := foo()?  // TIL: marks that foo() may throw
y := bar()?.baz()?  // chains work the same way
#+end_src

Key difference: In Rust, ~?~ is optional (you can match on Result instead). In TIL, ~?~ is MANDATORY:
- Calls to throwing functions MUST use ~?~
- Calls to non-throwing functions MUST NOT use ~?~
- The type checker enforces both rules

When porting Rust to TIL:
- KEEP all ~?~ operators - they're required in TIL
- Change ~Result<T, String>~ to ~returns T throws Str~
- Change ~panic!("msg")~ to ~throw "msg"~
- Errors propagate automatically unless caught

Example - converting panic! to Result/throw:

Rust (before):
#+begin_src rust
pub fn reserve(&mut self, size: usize) -> usize {
    if new_len > ARENA_SIZE { panic!("arena overflow"); }
    // ...
}
#+end_src

Rust (after):
#+begin_src rust
pub fn reserve(&mut self, size: usize) -> Result<usize, String> {
    if new_len > ARENA_SIZE { return Err("arena overflow".to_string()); }
    // ...
}
// Call sites use: arena.reserve(size)?
#+end_src

TIL:
#+begin_src til
reserve := proc(mut self: Arena, size: I64) returns I64 throws Str {
    if gt(new_len, ARENA_SIZE) { throw "arena overflow" }
    // ...
}
// Call sites: arena.reserve(size)?  -- ? is mandatory
#+end_src

** Nested if-let detection patterns

Rust uses nested ~if let~ for checking type hierarchies (common in AST traversal).
TIL uses nested ~switch/case~ with ~get()+catch~ for array access.

Rust:
#+begin_src rust
fn is_struct_declaration(expr: &Expr) -> bool {
    if let NodeType::Declaration(_) = &expr.node_type {
        if !expr.params.is_empty() {
            if let NodeType::StructDef(_) = &expr.params[0].node_type {
                return true;
            }
        }
    }
    false
}
#+end_src

TIL:
#+begin_src til
is_struct_declaration := func(expr: Expr) returns Bool {
    switch expr.node_type {
    case NodeType.Declaration(_):
        if not(expr.params.is_empty()) {
            mut first := Expr()
            expr.params.get(0, first)?
            catch (err: IndexOutOfBoundsError) { return false }
            switch first.node_type {
            case NodeType.StructDef(_):
                return true
            case:
            }
        }
    case:
    }
    return false
}
#+end_src

Translation rules for this pattern:
| Rust | TIL | Notes |
|------|-----|-------|
| ~if let Pattern = expr { ... }~ | ~switch expr { case Pattern: ... case: }~ | Empty default case required |
| ~!expr.is_empty()~ | ~not(expr.is_empty())~ | Use ~not()~ for negation |
| ~expr.params[0]~ | ~mut first := T(); expr.params.get(0, first); catch...~ | get()+catch pattern |
| Single ~false~ at end | Single ~return false~ at end | Empty default cases fall through |

Note on ~is_empty()~: We added ~is_empty()~ methods to Vec, Map, and Str specifically to make
LLM-assisted Rust-to-TIL translation easier. The original TIL idiom was ~len().gt(0)~ for
non-empty checks and ~len().eq(0)~ for empty checks - these are semantically equivalent and
still work fine. Using ~is_empty()~ just makes the translation more mechanical since it
matches Rust's method name directly.

Key insight: Empty ~case:~ blocks don't need ~return false~ - they fall through to the
single ~return false~ at the end. This matches Rust's structure where the final ~false~
is only reached when no early ~return true~ happened.

** Default switch case syntax

Rust uses ~_~ for catch-all. TIL uses empty ~case:~

Rust:
#+begin_src rust
match x {
    Foo::A => ...,
    _ => ...  // catch-all
}
#+end_src

TIL:
#+begin_src til
switch x {
    case Foo.A: ...
    case: ...  // catch-all (NOT "case _:")
}
#+end_src

** Option<String> -> Avoid in Rust, use String with "" as None

For ~Option<String>~ struct fields, avoid using ~Option~ in Rust. Use ~String~ directly
where empty string ~""~ represents ~None~. This is simpler than ~Ptr~ and natural for strings.

Rust:
#+begin_src rust
struct CodegenContext {
    // Empty string means None/no current function
    current_function_name: String,
}

// Usage
if !ctx.current_function_name.is_empty() {
    // has a function name
}
#+end_src

TIL:
#+begin_src til
CodegenContext := struct {
    // Empty string means None/no current function
    mut current_function_name: Str = ""
}

// Usage
if ctx.current_function_name.len().gt(0) {
    // has a function name
}
#+end_src

** Option<T> -> Ptr (for non-String types)

Rust uses ~Option<T>~ for optional values. TIL uses ~Ptr~ where ~NULL~ represents ~None~.
This applies to struct fields AND function parameters.

*** Struct fields

Rust:
#+begin_src rust
struct EnumVal {
    pub payload: Option<Vec<u8>>,
    pub payload_type: Option<ValueType>,
}
#+end_src

TIL:
#+begin_src til
EnumVal := struct {
    mut payload: Ptr = Ptr()  // Ptr to Vec<U8>, NULL = None
    mut payload_type: Ptr = Ptr()  // Ptr to ValueType, NULL = None
}
#+end_src

*** Function parameters

Rust:
#+begin_src rust
fn process_type(param_type: Option<&ValueType>) {
    if let Some(vt) = param_type {
        // use vt
    }
}
#+end_src

TIL:
#+begin_src til
process_type := proc(param_type: Ptr) {  // Ptr to ValueType, NULL = None
    if not(param_type.is_null()) {
        // Read the value using copy_to_dynamic
        mut vt := ValueType.TCustom("")
        param_type.copy_to_dynamic(vt, size_of(ValueType))
        // use vt
    }
}
#+end_src

*** Checking for Some vs None

#+begin_src til
// Check if Some (not NULL):
if not(ptr.is_null()) {
    // ptr has a value
}

// Check if None (NULL):
if ptr.is_null() {
    // ptr is None
}
#+end_src

*** Reading the value from Ptr

Use ~copy_to_dynamic~ to copy from the pointer into a local variable:

#+begin_src til
// 1. Create a default-initialized local variable
mut local_val := ValueType.TCustom("")

// 2. Copy from pointer to local variable using Ptr method
ptr.copy_to_dynamic(local_val, size_of(ValueType))

// 3. Now use local_val (e.g., switch on it)
switch local_val {
case ValueType.TCustom(name):
    // use name
case:
}
#+end_src

*** Setting a Ptr to Some

Use ~to_ptr~ to get the address of a value:

#+begin_src til
mut value := ValueType.TCustom("Dynamic")
mut ptr := Ptr()
ptr.data = to_ptr(value)  // Now ptr points to value (Some)
#+end_src

IMPORTANT: The pointed-to value must remain in scope while the Ptr is used.

*** Comment pattern

Use comments to document what the Ptr points to:
- ~// Ptr to T, NULL = None~
- ~// Ptr for Option pattern, NULL = None~

** Ptr type for memory operations

Core types (Vec, Str, List) use the ~Ptr~ type for internal pointer fields instead of ~I64~.
When working with raw memory, use ~Ptr~ methods instead of arithmetic and ~memcpy~.

*** Ptr struct fields in core types

#+begin_src til
Vec := struct {
    mut ptr : Ptr = Ptr()  // NOT I64
    // ...
}

Str := struct {
    mut c_string : Ptr = Ptr()  // NOT I64
    // ...
}

List := struct {
    mut data : Ptr = Ptr()  // NOT I64
    // ...
}
#+end_src

*** Allocation and deallocation

OLD pattern (don't use):
#+begin_src til
ptr := malloc(size)?
catch (err: BadAlloc) { panic(loc(), "malloc failed") }
// ...
free(ptr)
#+end_src

NEW pattern:
#+begin_src til
ptr := Ptr.new_by_size(size)  // No catch needed, panics on failure
// ...
if not(ptr.is_null()) {
    ptr.delete()
}
ptr = Ptr()  // Reset to null
#+end_src

*** Offset calculations

OLD pattern (don't use):
#+begin_src til
dest := add(self.ptr, mul(index, elem_size))
memcpy(dest, to_ptr(value), elem_size)
#+end_src

NEW pattern:
#+begin_src til
mut dest := self.ptr.offset(index.mul(elem_size))
dest.copy_from_dynamic(value, elem_size)
#+end_src

*** Ptr methods for copying

~Ptr~ provides methods for common copy operations:

#+begin_src til
// Copy from another Ptr
dest_ptr.copy_from(src_ptr, num_bytes)

// Copy from a Dynamic value into this Ptr
dest_ptr.copy_from_dynamic(value, size_of(T))

// Copy from this Ptr into a Dynamic destination
src_ptr.copy_to_dynamic(dest_var, size_of(T))
#+end_src

When you need the raw I64 address (e.g., for ~memcmp~), use ~.data~:
#+begin_src til
result := memcmp(to_ptr(value), ptr.offset(i).data, elem_size)
#+end_src

*** NULL checks

OLD pattern (don't use):
#+begin_src til
if gt(self.ptr, 0) { ... }
if self.ptr.eq(0) { ... }
#+end_src

NEW pattern:
#+begin_src til
if not(self.ptr.is_null()) { ... }
if self.ptr.is_null() { ... }
#+end_src

** Vec/Map.get() out-parameter pattern

Rust returns the value directly. TIL uses out-parameter pattern:

Rust:
#+begin_src rust
let item = vec.get(i)?;
let val = map.get(&key)?;
#+end_src

TIL:
#+begin_src til
mut item := T()  // default init
vec.get(i, item)?  // out-parameter, throws IndexOutOfBoundsError

mut val := V()
map.get(key, val)?  // out-parameter, throws KeyNotFoundError
#+end_src

** HashMap.insert vs Map.insert/set

IMPORTANT: Rust's ~HashMap.insert()~ OVERWRITES existing keys. TIL's ~Map.insert()~ THROWS ~DuplicatedKeyError~ on existing keys!

Rust:
#+begin_src rust
map.insert(key, value);  // Overwrites if key exists, no error
#+end_src

TIL:
#+begin_src til
// WRONG - throws DuplicatedKeyError if key exists
map.insert(key, value)

// CORRECT - use set() to match Rust's overwrite behavior
map.set(key, value)  // Overwrites if key exists, like Rust
#+end_src

Use ~Map.insert()~ only when you want to enforce unique keys (throws on duplicate).
Use ~Map.set()~ when you want Rust's HashMap.insert behavior (overwrites).

** Map.keys is a field, not a method

In Rust, ~.keys()~ is a method that returns an iterator. In TIL, ~.keys~ is a field (Vec) that you access directly:

Rust:
#+begin_src rust
for key in map.keys() {
    // use key
}
#+end_src

TIL:
#+begin_src til
// WRONG - keys is not a method
for key: Str in map.keys() { ... }

// CORRECT - keys is a field (Vec)
for key: Str in map.keys { ... }
#+end_src

** HashMap iteration (key-value pairs)

Rust iterates directly over ~(key, value)~ pairs. TIL must iterate over keys and do a separate ~get()~ for each value:

Rust:
#+begin_src rust
for (member_name, default_expr) in &struct_def.default_values {
    if let NodeType::FuncDef(func_def) = &default_expr.node_type {
        let mangled_name = format!("{}_{}", struct_name, member_name);
        // ...
    }
}
#+end_src

TIL:
#+begin_src til
for member_name: Str in struct_def.default_values.keys {
    mut default_expr := Expr()
    struct_def.default_values.get(member_name, default_expr)?
    switch default_expr.node_type {
    case NodeType.FuncDef(func_def):
        mangled_name := format(struct_name, "_", member_name)
        // ...
    case:
    }
    catch (err: KeyNotFoundError) { /* skip */ }
}
#+end_src

Key differences:
- Rust: ~for (key, value) in &map~ - direct iteration over pairs
- TIL: ~for key: KeyType in map.keys~ + ~map.get(key, value)~ - iterate keys, get values separately
- TIL requires a catch block for ~KeyNotFoundError~ from ~get()~

** Catch blocks placement

Catch blocks CANNOT be placed in unreachable code (after the final return/throw of a function).
Placement depends on the error type:

*** KeyNotFoundError (like Rust's Option::None)

Place catch immediately after the throwing call, before using the result:

#+begin_src til
lookup_func := func(self: ScopeStack, name: Str) returns SFuncDef throws KeyNotFoundError {
    for i in self.frames.len().sub(1)..sub(0, 1) {
        mut frame := ScopeFrame()
        self.frames.get(i, frame)?

        if frame.funcs.contains_key(name) {
            mut func_def := SFuncDef()
            frame.funcs.get(name, func_def)?
            catch (err: KeyNotFoundError) {
                // Function not found, continue searching
            }
            return func_def
        }
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in lookup_func: ", err.msg)
    }
    throw KeyNotFoundError(msg="lookup_func: Function not found in Context")
}
#+end_src

*** Panic-like errors (IndexOutOfBoundsError, AllocError, etc.)

Can be grouped at the end of the function to avoid repetition:

#+begin_src til
my_func := func() returns T throws Str {
    // ... code that may throw various errors ...

    result := compute_result()

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}
#+end_src

*** panic for impossible errors

Use ~panic(loc(), "message")~ for errors that should never happen (e.g., index errors when iterating within known bounds):

#+begin_src til
for i in vec.len().sub(1)..sub(0, 1) {
    mut item := T()
    vec.get(i, item)?
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "vec.get can't fail: i is always within bounds: ", err.msg)
    }
    // use item
}
#+end_src

*** Implicit panics become throws Str

When Rust code would implicitly panic (e.g., array out-of-bounds, unwrap on None), TIL should
throw a Str error. The function signature must include ~throws Str~.

Rust (implicit panic on out-of-bounds):
#+begin_src rust
fn process(items: &[Item]) -> Result {
    for i in 0..items.len() {
        let item = items[i];  // Would panic if somehow out of bounds
        // ...
    }
}
#+end_src

TIL (catch and throw Str):
#+begin_src til
process := func(items: Vec) returns Result throws Str {
    for i in 0..items.len() {
        mut item := Item()
        items.get(i, item)?
        // ...
    }
    catch (err: IndexOutOfBoundsError) { throw err.msg }
}
#+end_src

This pattern applies to:
- Array/Vec indexing that would panic in Rust -> catch IndexOutOfBoundsError, throw err.msg
- Map access that would panic in Rust -> catch KeyNotFoundError, throw err.msg
- Any operation that would call ~unwrap()~ or ~expect()~ in Rust

*** lang_error for better error messages (TIL improvement over Rust)

When a function has an ~Expr~ parameter, use ~e.lang_error()~ instead of ~panic()~ for
internal errors. This provides source location from the expression being processed,
giving better error messages than Rust's implicit panics:

#+begin_src til
// When you have an Expr available, use lang_error for better diagnostics
process_expr := func(context: Context, e: Expr) returns T throws Str {
    mut items := get_items()
    for item: Item in items {
        // ... processing that might fail ...
    }

    catch (err: IndexOutOfBoundsError) {
        throw e.lang_error(context.path, "phase_name", format("Internal error: ", err.msg))
    }
    // ...
}
#+end_src

This is better than Rust because:
- Rust would silently panic on index out of bounds
- TIL can catch and rethrow with source location info from the Expr

*** loc().concat() for functions without Expr

When a function does NOT have an ~Expr~ parameter but still needs to report errors
with location info, use ~loc().concat()~ to include the source location:

#+begin_src til
// When you don't have an Expr, use loc().concat() for error messages
all_structs := func(self: ScopeStack) returns Vec throws Str {
    mut result := Vec.new(SStructDef)
    // ... iteration logic ...

    catch (err: IndexOutOfBoundsError) {
        throw loc().concat("IndexOutOfBoundsError in all_structs: ").concat(err.msg)
    }
    catch (err: AllocError) {
        throw loc().concat("AllocError in all_structs: ").concat(err.msg)
    }
    return result
}
#+end_src

This provides the location where the error was thrown (the catch block), which is
helpful for debugging internal errors.

* Variable Shadowing (not allowed in TIL)

TIL does not allow variable shadowing within a function. When Rust code reuses variable
names in different blocks (which Rust allows), you must rename them to be unique.

*CRITICAL*: When renaming variables in TIL to avoid shadowing, port the renames BACK to
Rust so both versions use the same names. The goal is to minimize divergences.

Rust (before - uses shadowing):
#+begin_src rust
fn process() {
    let prefix = format!("{}.", source_var);  // first use
    for key in keys { ... }

    // Later in same function, different block:
    let prefix = format!("{}.", id_);  // shadows first prefix
    for key in other_keys { ... }  // shadows first key
}
#+end_src

Rust (after - no shadowing, unique names):
#+begin_src rust
fn process() {
    let own_prefix = format!("{}.", source_var);
    for own_key in keys { ... }

    // Later in same function:
    let ref_prefix = format!("{}.", id_);
    for ref_key in other_keys { ... }
}
#+end_src

TIL (matches Rust after):
#+begin_src til
process := proc() {
    own_prefix := format(source_var, ".")
    for own_key: Str in keys { ... }

    // Later in same function:
    ref_prefix := format(id_, ".")
    for ref_key: Str in other_keys { ... }
}
#+end_src

*Workflow*:
1. Port Rust to TIL using the same variable names
2. If TIL compiler complains about shadowing, rename to unique names in TIL
3. Port the renames BACK to Rust immediately
4. Both versions should have identical variable names

See also: doc/rs.org rule "Don't use variable shadowing"

* Clone Methods (derive(Clone) -> manual implementation)

Rust uses ~#[derive(Clone)]~ to auto-generate clone methods. TIL has no derive macros,
so clone methods must be written manually for each struct/enum that needs them.

Rust:
#+begin_src rust
#[derive(Clone)]
struct MyStruct {
    field1: String,
    field2: i64,
}
#+end_src

TIL:
#+begin_src til
MyStruct := struct {
    mut field1: Str = ""
    mut field2: I64 = 0

    clone := func(self: MyStruct) returns MyStruct throws AllocError {
        mut result := MyStruct()
        result.field1 = self.field1.clone()?
        result.field2 = self.field2
        return result
    }
}
#+end_src

Clone behavior by type:
- Primitives (I64, Bool, U8): direct copy, no clone needed
- Simple enums (no heap data): direct copy, no clone needed
- Enums with Str/Vec payloads: NEED deep clone functions (see below)
- Str: use ~.clone()~
- Vec: use ~.clone()~ (deep copy)
- Map: use ~.clone()~ (deep copy)
- Structs: create clone method, copy each field appropriately

** Simple enums (no heap data)

Enums without Str/Vec payloads are value types and copy automatically:

#+begin_src til
// Simple enum - just assign, copies by value
MyEnum := enum { A, B, C }
copy := my_enum
#+end_src

** Enums with heap data (Str/Vec payloads)

Enums containing Str or Vec fields need deep clone functions to copy the heap data.
Otherwise you get shallow copies where multiple values point to the same heap memory.

Example from parser.til:
#+begin_src til
// Literal enum has Str payloads - needs deep clone
literal_clone := func(lit: Literal) returns Literal throws AllocError {
    switch lit {
    case Literal.Str(s):
        return Literal.Str(s.clone()?)
    case Literal.I64(n):
        return Literal.I64(n)  // primitive, no clone needed
    case Literal.Bool(b):
        return Literal.Bool(b)
    // ... other variants
    }
}

// NodeType, ValueType, Token also need clone functions
node_type_clone := func(nt: NodeType) returns NodeType throws AllocError { ... }
value_type_clone := func(vt: ValueType) returns ValueType throws AllocError { ... }
Token.clone := func(self: Token) returns Token throws AllocError { ... }
#+end_src

IMPORTANT: When a struct contains other structs that need cloning, call their
clone methods recursively.

* func vs proc

~func~ and ~proc~ indicate function purity, NOT whether a function can throw:

- ~func~ = pure function (no side effects, deterministic output based only on inputs)
- ~proc~ = procedure (may have side effects like I/O, mutation of external state, etc.)

The ~throws~ section is completely independent of func/proc. Both can throw:

#+begin_src til
// Pure function that can throw
get_value := func(map: Map, key: Str) returns Str throws KeyNotFoundError {
    mut result := ""
    map.get(key, result)?
    return result
}

// Procedure that can throw
read_file := proc(path: Str) returns Str throws Str {
    // Has side effects (I/O), so it's a proc
    return file_read(path)?
}

// Pure function that doesn't throw
add := func(a: I64, b: I64) returns I64 {
    return a.add(b)
}
#+end_src

IMPORTANT: Do NOT assume ~func~ means "cannot throw". The distinction is purely about purity/side effects.

* Porting Workflow

*CRITICAL*: ~make tests~ uses the self-hosted til interpreter (~til_interpreted~) for some
tests. You CANNOT test Rust changes incrementally without also porting to TIL first.
Testing just the Rust version with ~rstil interpret~ is NOT sufficient validation.
If Rust changes aren't ported to TIL, tests will segfault or fail mysteriously.

When porting changes from Rust to TIL:

1. Make changes to BOTH Rust and TIL files together
2. Run ~git diff 'src/**/*.rs'~ to see exactly what changed in Rust
3. For each changed file (e.g. ~ccodegen.rs~), apply the same changes to the TIL equivalent (~ccodegen.til~)
4. Run ~make tests~ to verify both versions work correctly

The git diff shows exactly what lines changed, making the translation mechanical - just convert the Rust syntax to TIL syntax for each change.

*DO NOT* test Rust changes first and port later - the self-hosted til tests will fail.

* Style: Method Chaining vs Function Calls

For readability, prefer method chaining style over function call style for comparison
and boolean operations:

** Comparisons

#+begin_src til
// PREFERRED: method chaining
if func_def.return_types.len().gt(0) { ... }
if x.lt(y) { ... }
if name.eq("foo") { ... }

// AVOID: function call style
if gt(func_def.return_types.len(), 0) { ... }
if lt(x, y) { ... }
if eq(name, "foo") { ... }
#+end_src

** Boolean operations

#+begin_src til
// PREFERRED: method chaining
if found.and(has_return_type) { ... }
if is_empty.or(is_null) { ... }
if value.not() { ... }

// AVOID: function call style
if and(found, has_return_type) { ... }
if or(is_empty, is_null) { ... }
if not(value) { ... }
#+end_src

The method chaining style reads more naturally left-to-right and matches how Rust
code is typically written.

** Exception: Literals

Numerical and string literals cannot use UFCS syntax - use function call style instead:

#+begin_src til
// Literals require function call style
add(34, 35)      // can't write 34.add(35)
concat("a", "b") // can't write "a".concat("b")
gt(0, x)         // can't write 0.gt(x)

// But struct literals CAN use UFCS
MyStruct().method()  // works fine
Vec.new(I64).push(x) // works fine
#+end_src

* Summary

The translation is mechanical:
1. OR patterns (~|~) -> separate case arms
2. ~if let~ -> check default value or catch block
3. Iterator methods -> explicit loops
4. Return type translation:
   - ~Result<T, String>~ -> ~returns T throws Str~
   - ~Option<T>~ -> ~returns T throws KeyNotFoundError~
   - ~Result<Option<T>, String>~ -> ~returns T throws Str, KeyNotFoundError~
5. Internal errors (IndexOutOfBoundsError, AllocError, etc.) should be caught internally, not exposed
6. String slicing -> ~get_substr~
7. UFCS works similarly: ~a.method(b)~ in both languages
8. Default case: ~_~ -> empty ~case:~
9. NULL check: ~!= NULL~ -> ~not(ptr.is_null())~ or ~not(NULL.eq(ptr.data))~
10. ~vec.get(i)~ -> out-parameter: ~vec.get(i, out_val)~
11. Catch blocks come before final return/throw
12. Not-equal: ~!=~ or ~.ne()~ -> ~not(eq())~ or ~not(x.eq(y))~ (TIL has no ~ne~ function)
13. Enum comparison: ~==~ on enums -> use ~switch~ or type-specific ~_to_str~ functions (enums have no ~eq~ method, ~enum_to_str~ ignores payloads)
14. Pattern variables in switch/case are scoped to the case block - do ALL work with payloads inside the case
15. ~break~ works in while and for loops; ~continue~ works in while loops only (NOT for loops - causes infinite loop)
16. Enums with Str/Vec payloads need deep clone functions (~literal_clone~, ~node_type_clone~, etc.); simple enums copy by value
17. ~HashMap.insert()~ -> ~Map.set()~ (Rust overwrites, TIL's ~insert~ throws on duplicate; use ~set~ to match Rust behavior)
18. ~vec.extend(std::iter::repeat(v).take(n))~ -> ~vec.extend_with(v, n)~
19. Prefer method chaining: ~x.gt(0)~ over ~gt(x, 0)~, ~a.and(b)~ over ~and(a, b)~
20. HashMap iteration: ~for (k, v) in &map~ -> ~for k: T in map.keys { map.get(k, v) }~
21. ~Option<T>~ struct fields/params -> ~Ptr~ (NULL = None); read with ~ptr.copy_to_dynamic(local, size_of(T))~
22. Variable shadowing: TIL doesn't allow it. Rename in BOTH Rust and TIL to use unique names (see dedicated section)
23. Tuples: TIL doesn't have tuples. Use structs instead in BOTH Rust and TIL with the same struct name and fields (e.g., ~HashSet<(String, usize, usize)>~ -> ~HashSet<FunctionLocal>~ with ~FunctionLocal~ struct)
24. The ~?~ operator: KEEP all ~?~ from Rust - TIL requires ~?~ on calls to throwing functions (Issue #132)
25. Memory operations use ~Ptr~ type: ~Ptr.new_by_size(n)~ for allocation, ~ptr.delete()~ for deallocation, ~ptr.offset(n)~ for pointer arithmetic, ~ptr.is_null()~ for NULL checks
26. Copying with ~Ptr~: ~dest.copy_from(src_ptr, size)~, ~dest.copy_from_dynamic(value, size)~, ~src.copy_to_dynamic(dest, size)~
