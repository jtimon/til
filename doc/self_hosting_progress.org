#+TITLE: TIL Self-Hosting Progress
#+AUTHOR: Self-Hosting Homologization Plan
#+DATE: 2025-01-08

* Overview

Goal: Systematically homologize TIL implementations with Rust counterparts, working bottom-to-top through the compiler stack.

* Current Status Summary

| Component   | TIL Lines | Rust Lines | Completion | Status                       |
|-------------+-----------+------------+------------+------------------------------|
| lexer       |       712 |        517 | 100%       | ‚úÖ HOMOLOGIZATION COMPLETE  |
| parser      |     1,471 |      1,389 | ~60%       | ‚ö†Ô∏è DIVERGED (INTENTIONAL)   |
| init        |     1,220 |      1,761 | 70%        | ‚è≥ TOP-DOWN IN PROGRESS     |
| typer       |       408 |      1,285 | 30%        | ‚è≥ TOP-DOWN IN PROGRESS     |
| interpreter |       585 |      2,485 | 24%        | ‚è≥ TOP-DOWN IN PROGRESS     |
|-------------+-----------+------------+------------+------------------------------|
| *TOTAL*     |     4,396 |      7,437 | *52%*      | Lexer Complete ‚úÖ            |

* Architecture & Call Hierarchy

#+BEGIN_EXAMPLE
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   COMPILATION PHASES                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                       ‚îÇ
‚îÇ  1. LEXER: scan_tokens(source) ‚Üí Array<Token>       ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  2. PARSER: parse_tokens(tokens) ‚Üí Expr (AST)       ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  3. INIT: process_declarations(ctx, ast)            ‚îÇ
‚îÇ     - Register funcs, enums, structs in context     ‚îÇ
‚îÇ     - Process imports (copy declarations only)       ‚îÇ
‚îÇ     - Build symbol table (no eval yet)              ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  4. TYPER: check_types(ctx, ast)                    ‚îÇ
‚îÇ     - Validate all types match                       ‚îÇ
‚îÇ     - Check return/throw statements                  ‚îÇ
‚îÇ     - Verify mode constraints                        ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  5. INTERPRETER: eval_expr(ctx, ast)                ‚îÇ
‚îÇ     - Execute with arena memory management           ‚îÇ
‚îÇ     - Handle imports (eval imported code)            ‚îÇ
‚îÇ     - Runtime value computation                      ‚îÇ
‚îÇ                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#+END_EXAMPLE

* Critical Blockers

** BLOCKER #1: Enum Payload Extraction Bug ‚ö†Ô∏è
- *File*: =interpreter.til= line 292-299
- *Impact*: Cannot dispatch function calls properly
- *Priority*: HIGHEST
- *Fix*: Complete switch pattern matching migration
- *Timeline*: 1-2 weeks
- *Current workaround*: All functions treated as println

** BLOCKER #2: Complex Type Serialization ‚ö†Ô∏è
- *File*: =init.til= line 39
- *Impact*: Cannot store SFuncDef, SEnumDef, SStructDef in maps
- *Priority*: CRITICAL
- *Fix*: Implement struct/enum serialization
- *Timeline*: 3-4 weeks
- *Blocks*: typer.til and interpreter.til progress

** BLOCKER #3: Tagged Union Support ‚úÖ RESOLVED
- *File*: =parser.til= lines 507, 754
- *Status*: FIXED - Tagged unions work, just needed to uncomment
- *Fix*: Enum payload extraction via switch already working in rstil
- *Changes*: Enabled NodeType.Declaration(decl) payloads in parser
- *Result*: Declaration info now properly stored in AST

* Component Details

** Lexer (lexer.til vs src/rs/lexer.rs)
*** Status: FUNCTIONAL PARITY ‚úÖ - HOMOLOGIZATION COMPLETE ‚úÖ

*TIL Implementation (712 lines):*
- Full token scanning with nested comments
- String escape sequences (including =\0=)
- Reserved word scanning
- Dotted number support (fractional parts)
- Error handling for unterminated strings/comments
- Comprehensive lexical error reporting
- Helpful error messages for forbidden keywords (fn, const, var, try)

*Functional Equivalence (2025-01-08):*
- Both lexers produce identical tokens
- Both handle all keyword types correctly
- Both provide helpful error messages for forbidden keywords
- Enum organization aligned (Case in flow control, Try in errors)
- No functional differences remain

*Remaining Differences (Non-Functional):*
- *Size*: TIL 712 lines vs Rust 517 lines (38% larger)
  - 67% of difference is verbosity (explicit if/switch vs pattern matching)
  - 33% of difference is TIL having more error message detail in some places
- *Style*: TIL uses explicit if/switch, Rust uses match expressions
- *Optimization opportunity*: TIL could be reduced to ~650 lines using better switch patterns

*Recommendation:*
- Direction: COMPLETE (functional parity achieved)
- Optional improvement: Reduce TIL verbosity using switch pattern matching
- Optional improvement: Backport remaining detailed error messages to Rust

*** Homologization Tasks - 46 Differences Found

*Phase 1: Functional Parity (COMPLETE)*
- [X] Fix enum organization (Case to flow control, Try to errors)
- [X] Add error message for 'try' keyword
- [X] Validate functional equivalence

*Phase 2: Critical Bugs (COMPLETE ‚úÖ)*
- [X] Fix line numbering (0-based vs 1-based) - Both now start at line 1
- [X] Fix column calculation +1 inconsistencies - Optimized: start_line_pos = sub(0,1), no +1 needed
- [X] Fix number token column (use start not pos) - TIL line 229
- [X] Fix TIL comment scanning bug (2 chars vs 1) - TIL line 336
- [X] Fix string token column (use start not pos) - TIL line 427
- [X] Fix identifier token column calculation - TIL line 450

Both lexers now use identical algorithms and produce byte-for-byte identical output.

*Phase 3: Code Quality (SHOULD FIX)*
- [X] Add path field to Rust Lexer struct
- [X] Add new_from_file constructor to Rust (matches TIL's new/new_from_src)
- [X] Standardize field name: `current` (was current_token in TIL)
- [X] Add print_lex_errors helper to Rust - TIL lines 677-685
- [X] Standardize error message ordering (NotEqual after EqualEqual)
- [X] Fix grammar: "have" ‚Üí "has" in ext_func comment
- [X] Add token_type_to_str helper to both (better error messages)
- [X] Standardize whitespace handling comments
- [ ] Resolve todo_error method (comment #5)
- [ ] Investigate string escape TODO comment (TIL line 446)

*Phase 4: Optimization (OPTIONAL)*
- [ ] Reduce TIL verbosity using switch pattern matching
- [ ] Consider string escape switch in Rust (TIL lines 394-415)

** Parser (parser.til vs src/rs/parser.rs)
*** Status: ‚ö†Ô∏è DIVERGED - NEEDS HOMOGENIZATION (Next Priority)

*IMPORTANT:* parser.rs is the **source of truth**. parser.til must be updated to match it.

*Current State (2025-11-09):*
The parsers have **unintentionally diverged** during recent StrMap‚ÜíMap refactoring work.
parser.til was updated to use generic Map structures, but should have maintained
the same structure as parser.rs. Both currently produce valid ASTs and tests pass,
but the data structures no longer match.

*Detailed Homogenization Plan:* See =doc/parser_homogenization_plan.org=

*Current TIL Implementation (1,471 lines) - NEEDS FIXES:*
- ‚ùå Uses generic =Map= (string‚Üístring) for type storage (WRONG)
- ‚ùå Uses =Array= for collections with string-based types (WRONG)
- ‚ùå Simplified data structures don't match Rust (WRONG)
- ‚ö†Ô∏è Recent change broke homogenization: Replaced StrMap with Map

*Rust Implementation (1,389 lines) - CORRECT/TARGET:*
- ‚úÖ Uses strongly-typed =HashMap<String, Option<ValueType>>=
- ‚úÖ Uses =Vec<Declaration>=, =Vec<ValueType>= for proper type safety
- ‚úÖ Full type-correct representation with enum payloads
- ‚úÖ This is what parser.til needs to match

*Critical Divergences That Must Be Fixed:*

1. **SStructDef struct** - MUST REVERT TIL
   - TIL (WRONG): =Map= (string‚Üístring) + parallel =Arrays=
   - Rust (CORRECT): =Vec<(String, Declaration)>= + =HashMap<String, Expr>=
   - Fix: Revert TIL to use arrays/maps that mirror Rust's Vec/HashMap

2. **SFuncDef struct** - MUST REVERT TIL
   - TIL (WRONG): =Map= for args (string‚Üístring), generic =Array=
   - Rust (CORRECT): =Vec<Declaration>=, =Vec<ValueType>=
   - Fix: Store full Declaration/ValueType info in TIL

3. **SEnumDef struct** - MUST FIX TIL
   - TIL (WRONG): Stores payload types as strings
   - Rust (CORRECT): =HashMap<String, Option<ValueType>>=
   - Fix: TIL needs to store ValueType enums, not strings

4. **parse_func_proc_args** - MUST IMPLEMENT IN TIL
   - TIL (INCOMPLETE): Only validates, doesn't return data
   - Rust (CORRECT): Returns =Vec<Declaration>=
   - Fix: TIL must build and return Declaration array

5. **parse_func_proc_definition** - MUST COMPLETE IN TIL
   - TIL (INCOMPLETE): Creates stub =SFuncDef= with empty data
   - Rust (CORRECT): Fully populates =SFuncDef= with args/returns/throws
   - Fix: TIL must populate all SFuncDef fields

6. **ValueType enum** - MUST ADD PAYLOADS IN TIL
   - TIL (INCOMPLETE): Simple variants, missing payloads
   - Rust (CORRECT): =TFunction(FunctionType)=, =TType(TTypeDef)=
   - Fix: TIL enum variants must carry same payload data

*What Currently Works (Despite Divergence):*
- ‚úÖ Both produce valid ASTs for all test cases
- ‚úÖ All test suite passes (src/tests.til)
- ‚úÖ Pattern matching, switch statements work
- ‚úÖ External function/procedure parsing works
- ‚úÖ Tests pass because later stages compensate for incomplete parsing

*Root Cause:*
During recent Map implementation work, parser.til was updated to use the new
generic Map class (replacing StrMap), but the structure wasn't kept aligned
with parser.rs. The Map changes went beyond simple StrMap replacement and
simplified the data structures in a way that broke homogenization.

*Next Steps (PRIORITY):*
1. Review =doc/parser_homogenization_plan.org= for detailed task breakdown
2. Revert parser.til data structures to match parser.rs exactly
3. Update parse functions to populate all required metadata
4. Test that structures are byte-for-byte equivalent
5. Verify all tests still pass after homogenization

*** Homogenization Status
- [X] Divergence discovered during analysis (2025-11-09)
- [X] Documented divergence and created homogenization plan (2025-11-09)
- [ ] NEXT: Execute parser_homogenization_plan.org (Rust‚ÜíTIL direction)
- [ ] Revert TIL data structures to match Rust
- [ ] Complete TIL parse functions to match Rust behavior
- [ ] Validate homogenization with structural comparison
- [ ] Mark parser homogenization complete

** Init (init.til vs src/rs/init.rs)
*** Status: 70% COMPLETE - TOP-DOWN IN PROGRESS ‚è≥ (2025-01-09)

*TIL Implementation (1,220 lines):*

*‚úÖ COMPLETED (2025-01-09):*
- Struct alignment: SymbolInfo.value_type now uses ValueType enum
- Struct alignment: EnumVal.payload_type added (matches Rust)
- Function ordering: First 3 functions match Rust order
  1. =get_func_name_in_call= ‚úÖ
  2. =value_type_func_proc= ‚úÖ
  3. =get_ufcs_fcall_value_type= ‚úÖ
- =init_context= skeleton with TODO() placeholders (top-down approach)
- Declaration processing skeleton in =init_context=
- Context struct with all fields (arena, symbols, funcs, enum_defs, struct_defs, imports)
- Arena methods: =get_i64=, =get_str=, =get_bool=, =get_u8=, =insert_*= (simplified)
- Enum helpers: =get_variant_pos=, =variant_pos_to_str=
- Type helpers: =get_type_size=, =get_func_name_in_call=
- Type inference: =get_value_type= (literals, funcdefs, enums, structs, ranges, identifiers)
- Type inference: =get_fcall_value_type= (UFCS, standalone funcs, constructors)

*‚ö†Ô∏è PARTIALLY IMPLEMENTED:*
- =get_fcall_value_type=: needs SFuncDef parsing from storage
- =get_value_type= identifier handling: needs SymbolInfo parsing
- Struct methods: =map_instance_fields=, =copy_fields=, =insert_struct=
- Enum methods: =get_enum=, =insert_enum=, =get_enum_at_offset=

*‚ùå NOT IMPLEMENTED:*
- =init_import_declarations=: needs file I/O, lexing, parsing, recursive imports
- Complex type serialization: SFuncDef, SEnumDef, SStructDef storage
- Full struct size calculation with nested structs
- Proper string storage (c_string/cap/len structure)
- Mode validation
- Associated function registration for structs

*KEY LIMITATION (from line 39):*
#+BEGIN_QUOTE
Currently storing complex types (SFuncDef, SEnumDef, SStructDef) as placeholder strings
in maps. Full equivalence requires either JSON serialization or direct object storage.
#+END_QUOTE

*Recommendation:*
- Direction: Rust ‚Üí TIL (most work needed here)
- *Critical blocker*: Struct serialization to StrMap (BLOCKER #2)
- *Priority*: Implement proper struct storage before proceeding
- *Dependencies*: This blocks interpreter and typer progress

*** Homologization Tasks (Top-Down Approach)

*Phase 1: Struct Alignment (COMPLETE)*
- [X] Align SymbolInfo struct to use ValueType
- [X] Align EnumVal struct (add payload_type field)

*Phase 2: Function Reordering (IN PROGRESS)*
- [X] Move get_func_name_in_call to line 560
- [X] Move value_type_func_proc to line 597
- [X] Move get_ufcs_fcall_value_type to line 619
- [ ] Continue reordering remaining functions to match Rust

*Phase 3: Top-Down Implementation with TODO() (IN PROGRESS)*
- [X] Create init_context skeleton with TODO() placeholders
- [X] Add Declaration processing skeleton
- [ ] Fill in Declaration: function registration
- [ ] Fill in Declaration: enum registration
- [ ] Fill in Declaration: struct registration
- [ ] Fill in Declaration: type checking
- [ ] Add import handling
- [ ] Add mode validation
- [ ] Complete remaining helper functions

*Phase 4: Serialization (BLOCKED)*
- [ ] Design serialization format for SFuncDef, SEnumDef, SStructDef
- [ ] Implement to_string/from_string for complex types
- [ ] Update maps to store actual type info (not placeholders)

** Typer (typer.til vs src/rs/typer.rs)
*** Status: 30% COMPLETE - TOP-DOWN IN PROGRESS ‚è≥ (2025-01-09)

*TIL Implementation (408 lines):*

*‚úÖ COMPLETED (2025-01-09):*
- =check_types= skeleton with TODO() placeholders (matches Rust signature)
- Returns Array of error strings (not throws)
- NodeType.Body: Recursively processes all statements
- NodeType.Return/Throw: Recursively checks values
- NodeType.Literal/DefaultCase/Pattern: No-op (already validated)
- Uses pattern matching on NodeType enum (benefits from parser homologization)

*‚è≥ TODO PLACEHOLDERS (incremental implementation):*
- =check_enum_def= (enum payload validation)
- =check_struct_def= (struct field validation)
- =check_if_statement= (condition must be Bool)
- =check_while_statement= (condition must be Bool)
- =check_switch_statement= (switch value + case type matching)
- =check_range= (start/end types must match)
- =check_fcall= (function call validation)
- =check_func_proc_types= (function body validation)
- =check_declaration= (declaration type checking)
- =check_assignment= (assignment type checking)
- =check_catch_statement= (catch type validation)

*Old Implementation (being replaced):*
- Basic =check_types= dispatcher
- =check_if_statement= (condition must be Bool)
- =check_while_statement= (condition must be Bool)
- =check_range= (both sides must match)
- =check_identifier= (symbol exists)
- =check_declaration= (type inference, symbol registration)
- =check_assignment= (mutability checking)
- Stub functions for: =check_fcall=, =check_func_def=

*‚ùå Missing (compared to Rust's 1,285 lines):*
- Actual function call type checking implementation
- Function definition validation
- Switch statement type checking
- Struct definition type checking
- Enum definition validation
- Mode constraint checking (lib/pure/script/etc)
- Catch statement validation
- Variadic argument handling

*Recommendation:*
- Direction: Rust ‚Üí TIL (massive gap)
- *Status*: This is the WEAKEST component
- *Priority*: HIGH - implement from Rust after init.til is complete
- *Dependencies*: Requires working init.til with proper type storage

*** Homologization Tasks
- [ ] Wait for init.til completion (DEPENDENCY)
- [ ] Port check_fcall implementation from typer.rs
- [ ] Port check_func_def validation
- [ ] Implement check_declaration fully (not just stub)
- [ ] Implement check_assignment fully (not just stub)
- [ ] Port check_switch_statement
- [ ] Port check_catch_statement
- [ ] Port check_struct_def
- [ ] Port check_enum_def
- [ ] Port mode constraint checking
- [ ] Port variadic argument handling
- [ ] Test against Rust typer output
- [ ] Mark complete

** Interpreter (interpreter.til vs src/rs/interpreter.rs)
*** Status: TOP-DOWN IN PROGRESS ‚è≥ (24% complete)

*TIL Implementation (585 lines):*

*Approach:* Top-down skeleton with TODO() placeholders (safe incremental implementation)

*‚úÖ Implemented:*
- =EvalResult= struct (lines 24-59)
  - Corresponds to =EvalResult= in interpreter.rs
  - Handles normal values, returns, and throws
  - Constructor methods: =new()=, =new_return()=, =new_throw()=
- =eval_expr= cornerstone function (lines 64-171)
  - Pattern matching on =NodeType= using switch
  - Literal evaluation fully implemented (Bool, I64, String, List)
  - All other cases have TODO() placeholders
- =Arena= struct for memory management (lines 9-20)

*üî® TODO Placeholders (to be filled incrementally):*
- Body evaluation
- Function calls (eval_func_proc_call)
- Declarations
- Assignments
- Identifiers
- Control flow (if, while, switch)
- Pattern matching
- Binary/comparison operations
- Struct instantiation and field access
- Enum construction
- Array operations
- Return/throw handling
- Catch blocks
- Import evaluation
- External function calls

*Key Insight:*
Using =TODO(loc(), "message")= from std.til allows tests to keep passing while building out functionality incrementally. This is much safer than trying to implement everything at once.

*Next Steps:*
1. Fill in eval_body (most frequently used)
2. Fill in eval_func_proc_call (critical for any code)
3. Continue with other cases based on test coverage needs

*** Homologization Tasks
- [X] Add EvalResult struct matching Rust
- [X] Create eval_expr skeleton with pattern matching
- [X] Implement literal evaluation
- [ ] Implement eval_body
- [ ] Implement eval_func_proc_call
- [ ] Implement eval_declaration
- [ ] Implement eval_assignment
- [ ] Implement eval_identifier
- [ ] Implement binary operations (add, sub, mul, div, mod)
- [ ] Implement comparison operations (lt, gt, eq, ne, le, ge)
- [ ] Implement control flow (if, while, switch)
- [ ] Implement struct instantiation and field access
- [ ] Implement enum construction and pattern matching
- [ ] Implement array operations
- [ ] Implement return/throw handling
- [ ] Implement catch blocks
- [ ] Implement import evaluation
- [ ] Implement external function calls
- [ ] Test exhaustively
- [ ] Mark complete

* Overall Timeline (21 weeks)

** Week 1: Lexer Homologization - IN PROGRESS ‚ö†Ô∏è
- [X] Create tracking document (this file)
- [X] Fixed enum organization (Case, Try)
- [X] Added error message for 'try' keyword
- [X] Validated functional equivalence
- [X] Deep comparison analysis (46 differences found)
- [ ] Fix 6 critical bugs (line/column calculations)
- [ ] Fix 7 code quality issues
- [ ] Complete homologization (implementations nearly identical)

** Weeks 2-4: Fix Critical Blockers
- [ ] BLOCKER #1: Fix enum payload extraction bug
- [ ] BLOCKER #3: Fix tagged union support in parser
- [ ] Test fixes thoroughly

** Week 5: Parser Homogenization - NEXT PRIORITY üî•
- [X] Parser divergence discovered during analysis (2025-11-09)
- [X] Documented divergence and created detailed plan (2025-11-09)
- [ ] NEXT UP: Execute parser_homogenization_plan.org (~3 days, 22 hours)
- [ ] Direction: Rust ‚Üí TIL (parser.rs is source of truth)
- [ ] Revert TIL data structures to match Rust exactly
- [ ] Complete parse functions to populate full metadata
- [ ] Validate structural equivalence

** Weeks 6-10: Init Homologization (MAJOR WORK)
- [ ] Design struct serialization format
- [ ] Implement serialization functions
- [ ] Port init_import_declarations
- [ ] Complete struct methods
- [ ] Complete enum methods
- [ ] Implement string storage
- [ ] Test with complex types
- [ ] Mark init complete

** Weeks 11-13: Typer Homologization
- [ ] Port check_fcall implementation
- [ ] Port check_func_def validation
- [ ] Port full check_declaration/check_assignment
- [ ] Port check_switch/check_catch
- [ ] Port struct/enum checking
- [ ] Port mode constraints
- [ ] Test against Rust typer
- [ ] Mark typer complete

** Weeks 14-20: Interpreter Homologization (MASSIVE)
- [ ] Fix function dispatch
- [ ] Port eval_fcall
- [ ] Port binary operations
- [ ] Port comparisons
- [ ] Port struct operations
- [ ] Port enum operations
- [ ] Port control flow
- [ ] Port throw/catch
- [ ] Port imports
- [ ] Port arrays
- [ ] Test exhaustively
- [ ] Mark interpreter complete

** Week 21: Final Validation
- [ ] Run comprehensive test suite
- [ ] Bootstrap test (compile TIL with TIL)
- [ ] Compare with Rust compiler output
- [ ] Fix discrepancies
- [ ] Update documentation
- [ ] *DONE: Self-hosting achieved!*

* Success Criteria

- [ ] All components at 100% parity with Rust
- [ ] TIL compiler can compile itself (bootstrap)
- [ ] Identical output to Rust compiler on test suite
- [ ] All tests pass in both implementations
- [ ] This document shows 100% complete

* Improvements to Backport

** TIL ‚Üí Rust (Better in TIL)

1. *Better Error Messages* (lexer.til lines 605-670)
   - Helpful suggestions for common mistakes
   - "use 'func' instead of 'fn'"
   - "use 'mut' instead of 'var'"
   - More user-friendly than Rust version

2. *For Loop Desugaring* (parser.til lines 697-805)
   - TIL desugars =for i in 0..10 {}= to while loop in parser
   - Simpler for later phases to handle
   - Consider adopting in Rust

** Rust ‚Üí TIL (Missing in TIL)

1. *Complex Type Storage*
   - Rust stores SFuncDef, SEnumDef, SStructDef directly in HashMaps
   - TIL uses placeholder strings (init.til line 39 limitation)
   - *CRITICAL for progress*

2. *Complete Type Checking*
   - Rust has full typer.rs (1,285 lines)
   - TIL has minimal typer.til (336 lines)
   - Missing: fcall checking, struct validation, mode constraints

3. *Full Interpreter*
   - Rust has complete interpreter.rs (2,485 lines)
   - TIL has basic Phase 2 only (475 lines)
   - Missing: All complex operations, struct/enum support

* Notes

- Created: 2025-01-08
- Last Updated: 2025-01-08
- Status: Planning phase
- Next: Begin lexer homologization (Week 1)
