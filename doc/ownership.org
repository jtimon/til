#+TITLE: TIL vs Mojo: Ownership and Memory Safety Design Comparison
#+DATE: 2025-11-12
#+UPDATED: 2025-11-12
#+AUTHOR: TIL Development

* Overview

Comparison of TIL's ownership model with Mojo's ownership system, showing remarkable convergence in design philosophy.

* Mojo's Design

** Argument Conventions (Function Parameters)

Mojo has three main argument conventions:

1. **read** (default): Immutable reference, no copy
   - Efficient for large values
   - Cannot modify the argument

2. **mut**: Mutable reference (inout parameter)
   - Modifications visible to caller
   - Enforces exclusivity (no aliasing)

3. **var**: Ownership transfer
   - Function takes ownership
   - Either copy (if copyable) or move with ^ sigil

** Local Variables (Updated 2025)

Mojo REMOVED the `let` keyword for immutable variables because:
- Immutability only applied to the binding, not the referenced value
- This was confusing with reference types
- Not needed for Python programmers
- Immutability better handled through function parameters

Current design:
- **var**: Mutable variables (only kind of local variable)
- **ref**: Explicit reference binding (for aliasing)

** Philosophy

- Value semantics by default
- References for performance
- Automatic lifetime checking by compiler
- Simplicity over completeness (removed `let`)
- Ownership rules: "Every value has only one owner at a time"

* TIL's Current Design (Post Bug #25 Fix)

** Function Parameters

1. **Default (no keyword)**: Immutable parameter
   - Currently COPIES (inefficient)
   - Phase 3 goal: Make it a reference
   - Type checker prevents modification

2. **mut**: Mutable reference
   - Modifications visible to caller
   - Works for primitives and structs

3. **copy**: Explicit copy
   - Local modifications don't affect caller
   - Added in Phase 2

4. **own** (future): Ownership transfer
   - Caller can pass with `own` at call site
   - Invalidates variable in caller's context
   - Example: `func(own my_string)` transfers ownership
   - Works even if function declared with `mut` (opt-in at call site)

** Local Variable Declarations (Bug #25 Fix)

After Bug #25 fix, TIL has clean semantics:

1. **mut x := original**: Creates INDEPENDENT COPY
   - Modifications to x don't affect original
   - Safe, prevents aliasing
   - Equivalent to Mojo's `var x = original`

2. **x := original** (no keyword): Immutable reference binding
   - Shares arena offset (no copy)
   - Type checker prevents modification
   - Efficient, safe
   - **Equivalent to Mojo's `ref x = original`**

** Design Insight

TIL's default (no keyword) ‚âà Mojo's `ref`
- Both are reference bindings
- Both are immutable (enforced by type checker/compiler)
- User doesn't need to care if it's a "const copy" or "const reference" - same behavior!

The key realization: **const copy vs const reference is an implementation detail**.
From the user's perspective, if you can't modify it, it doesn't matter whether
it's copied or referenced. TIL chooses reference (efficient), Mojo makes it explicit
with `ref` keyword. TIL's approach is arguably simpler.

* Comparison Table (Updated)

| Feature                 | Mojo (2025)    | TIL (Current)       | Notes                               |
|-------------------------+----------------+---------------------+-------------------------------------|
| Default param           | read (ref)     | Copy                | Phase 3: will become ref            |
| Mutable param           | mut (ref)      | mut (ref)           | ‚úÖ Same                             |
| Copy param              | var (copy)     | copy                | ‚úÖ Same concept                     |
| Ownership transfer      | var with ^     | own (sig + call)    | Both require call-site marker       |
| Mut local               | var x = y      | mut x := y          | ‚úÖ Equivalent (both copy)           |
| Immut local             | (REMOVED)      | x := y (ref)        | TIL simpler: default is ref         |
| Explicit ref            | ref x = y      | x := y              | TIL: no keyword needed (is default) |
| Move at call site       | foo(x^)        | foo(own x)          | ‚úÖ Both explicit (TIL more readable)|

* Key Differences

** Where TIL is Simpler

1. **No explicit ref keyword needed**: Default is reference
   - Mojo: `ref x = y` (explicit)
   - TIL: `x := y` (implicit, cleaner)

2. **Readable ownership keyword**: Uses `own` (both sig and call site)
   - Mojo: `^` sigil at call site (punctuation)
   - TIL: `own` keyword at call site (readable: `foo(own x)`)

3. **Simpler local variables**: Only two cases
   - `mut x := y` = mutable copy
   - `x := y` = immutable reference
   - No need to learn separate `ref` keyword

** Where Mojo is More Explicit

1. **Explicit ref binding**: `ref` keyword makes aliasing visible
2. **Default params are refs**: Already efficient (TIL needs Phase 3)
3. **Mature lifetime system**: Compiler-enforced lifetimes

** Implementation Status

TIL is currently missing:
1. **Phase 3**: Default params should be references (blocked by arena issues)
2. **Bug #49**: Typer doesn't track use-after-move (interpreter does at eval)
3. **Lifetime tracking**: Would need for move-only types

* TIL's Design Philosophy (Refined Understanding)

** Core Insight: Const Copy vs Const Reference Doesn't Matter

From user discussion:
> "why does it matter to the user if it's a const copy or a const reference?
> you can't modify it either way."

This is **exactly right** and a key design principle. If a binding is immutable:
- Whether it's a copy or reference is an **implementation detail**
- User sees identical behavior either way
- Implementation can choose most efficient approach

This is why Mojo removed `let` - the distinction was confusing and unnecessary.

** Current Semantics (Post Bug #25)

Local variables:
```til
x := original        // Immutable reference (shares offset, can't modify)
mut x := original    // Mutable copy (independent, can modify)
```

Function parameters:
```til
func(x: T)           // Immutable (currently copies, should be ref in Phase 3)
func(mut x: T)       // Mutable reference
func(copy x: T)      // Explicit copy
```

** Ownership Transfer Design (Current)

Use `own` in **both signature and call site**:
```til
consume := proc(own n: I64) returns I64 { return mul(n, 2) }
// ...
mut x := 42
result := consume(own x)    // own REQUIRED at call site
// x is now undefined - use-after-move error
```

The `own` keyword is required in both places:

1. **Signature** (`own n: T`): Declares the function takes ownership
   - Function can modify, consume, or transfer the value
   - Caller's variable is invalidated after the call
   - Works even if function also has `mut` (opt-in at call site)

2. **Call site** (`foo(own x)`): Makes ownership transfer visible to readers
   - You see the transfer without looking up the signature
   - Compiler errors if you forget: "argument to `own` parameter must use `own`"
   - If you still try to use the variable later: "undefined symbol" error

This follows TIL's "explicit at call sites" principle - you shouldn't need to
look up a function signature to know a variable is being consumed.

** Comparison with Mojo's Equivalents

| TIL                | Mojo Equivalent     | Notes                              |
|--------------------+---------------------+------------------------------------|
| x := y             | ref x = y           | **TIL's default ‚â° Mojo's ref**     |
| mut x := y         | var x = y           | Both copy                          |
| f(own x)           | f(x^)               | Both require call-site marker      |
| func(mut x: T)     | func(mut x: T)      | Same (mutable reference)           |

**Key Equivalence**: TIL's default (no keyword) is equivalent to Mojo's `ref`.
Both create immutable reference bindings. TIL doesn't need explicit `ref` keyword
because the default behavior IS reference binding.

* Implementation Roadmap

** ‚úÖ Phase 1: Immutability Enforcement (COMPLETE)
- Type checker prevents modification of non-mut parameters
- Prevents field modification
- Foundation for safe reference semantics

** ‚úÖ Phase 2: Copy Keyword (COMPLETE)
- Added `copy` keyword for explicit copying
- Mutually exclusive with `mut`
- Enables fine-grained control

** ‚úÖ Bug #25 Fix: Declaration Semantics (COMPLETE)
- `mut x := y` creates independent copy
- `x := y` creates immutable reference binding
- Aligns with Mojo's philosophy

** ‚è∏ Phase 3: Default Params as References (DEFERRED)
- Goal: Make `func(x: T)` pass by reference instead of copy
- Blocked: Arena singleton + context cloning causes corruption
- Can revisit post self-hosting with better debugging tools

** ‚ö†Ô∏è In Progress: Ownership Transfer (Partial Implementation)
Status: Basic implementation done, use-after-move check needs typer fix

Completed (2025-12-18 update):
- ‚úÖ Lexer: Added `own` token
- ‚úÖ Parser: Accepts `own` in parameter declarations (mutually exclusive with mut/copy)
- ‚úÖ Type checker: Allows modification of `own` parameters
- ‚úÖ Interpreter: Invalidates caller's variable after passing to own param
- ‚úÖ All own tests in src/test/args.til passing (lines 494-621)

Still missing:
- ‚ùå Use-after-move at typer phase: Interpreter catches at eval, compiler doesn't catch at all
  - Fix: Mirror interpreter - remove symbol from scope when passed to own param (Bug #49)
- ‚ö™ Call-site `own` syntax: `func(own x)` not parsed (optional - for code clarity only)

Current behavior:
```til
consume := proc(own n: I64) returns I64 { return mul(n, 2) }
mut x := 42
result := consume(x)
// Interpreter: x is now undefined (use-after-move works at eval)
// Compiler: x still accessible (bug - should be caught by typer)
```

Tests in src/test/args.til (lines 494-621) - all passing

** üîÆ Future: Move-Only Types (Maybe)
Needs more research and real-world examples to determine necessity.

** üîÆ Future: Owned Struct Fields (Issue #115)
Struct fields should declare ownership semantics.

*** Problem
Currently struct fields are just ~mut~ or not, but we can't express whether a
struct OWNS its fields (should delete them) vs BORROWS them (someone else deletes).

*** Example: Neural Network Layer
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally a pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Interaction with ASAP Destruction (Issue #117)
When parent struct is deleted (automatically or explicitly):
- Owned fields: Cascade delete
- Borrowed fields: Leave alone

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- ~delete()~: Calls delete() on all owned fields
- ~size()~: Sums size of all fields
- ~clone()~: Deep clones owned fields, shallow copies borrowed

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives be "owned"? (Probably no - always copy)
- How is a borrowed field assigned? (Must point to something that outlives struct)
- Syntax: ~own field: T~ vs ~field: own T~ vs attribute

* Complete Vision: TIL's Ownership Model

This section integrates all the pieces into a coherent final design.

** What's Already Solved

*** Function Parameters (Complete)
#+BEGIN_SRC til
func(x: T)           // Immutable reference (like C++ const T&)
func(mut x: T)       // Mutable reference (like C++ T&)
func(copy x: T)      // Explicit copy (like C++ T by value)
func(own x: T)       // Ownership transfer (like C++ T&& move)
#+END_SRC

No pointer/reference syntax needed here - the keywords handle it.

*** Local Variable Bindings (Complete)
#+BEGIN_SRC til
x := original        // Immutable reference (shares memory, can't modify)
mut x := original    // Mutable copy (independent, can modify)
#+END_SRC

** What's Missing: Explicit Reference Types (Issue #151)

*** The Problem
TIL has ~Ptr~ but it's untyped. We can't express "pointer to Vec2" in the type
system. And ~Ptr.dereference()~ always copies - there's no way to access data
through a pointer without copying.

*** Where We Need Reference Types

1. **Struct fields that borrow** (not own):
   #+BEGIN_SRC til
   Layer := struct {
       mut weights: Vec       // Owned - Layer.delete() frees this
       input: &Vec            // Borrowed - don't free, just a reference
   }
   #+END_SRC

2. **Collections returning references**:
   #+BEGIN_SRC til
   vec.get_ptr(i)             // Returns &T, not copies T
   #+END_SRC

3. **Iteration by reference** (Bug #144):
   #+BEGIN_SRC til
   for elem: &Expr in exprs { // elem is reference, no copy
       println(elem.line)
   }
   #+END_SRC

4. **Storing references in variables**:
   #+BEGIN_SRC til
   p: &Vec2 = &my_vec         // p is a typed reference
   #+END_SRC

*** Syntax Decision (To Be Made)

**** Option A: Ampersand (Recommended - Rust/C++ familiar)
#+BEGIN_SRC til
// Type annotation
field: &Vec2                   // Reference to Vec2
field: &mut Vec2               // Mutable reference to Vec2

// Taking a reference
p := &my_vec                   // p is &Vec2

// Access (auto-deref for fields)
p.x                            // Reads field through reference
p.x = 10                       // Writes through mutable reference (if &mut)

// Explicit deref (when needed)
v := *p                        // Copy the value out
#+END_SRC

**** Option B: Caret (Unambiguous, Pascal-style)
#+BEGIN_SRC til
field: ^Vec2                   // Pointer to Vec2
p := @my_vec                   // Take address
p^.x                           // Explicit dereference
#+END_SRC

**** Option C: Keyword (Most readable)
#+BEGIN_SRC til
field: ref Vec2                // Reference to Vec2
field: ref mut Vec2            // Mutable reference
p := ref my_vec                // Take reference
#+END_SRC

*** Implementation: Desugars to Ptr

Whatever syntax we choose, it desugars to existing ~Ptr~ operations:
- ~&x~ ‚Üí ~Ptr~ with type info (typed wrapper around ~to_ptr(x)~)
- ~p.field~ ‚Üí offset calculation + direct memory access (no full struct copy)
- ~*p~ or binding to non-ref ‚Üí actual copy happens here

The key insight: **copy only happens at binding points**, not at dereference.
Dereferencing gives access to a location; what you do with it determines copy.

** Owned vs Borrowed Fields (Issue #115)

*** Syntax Options
#+BEGIN_SRC til
// Option 1: own keyword (matches parameter syntax)
Layer := struct {
    own weights: Vec           // Owned
    input: Vec                 // Borrowed (default? or requires &?)
}

// Option 2: Reference syntax for borrowed
Layer := struct {
    weights: Vec               // Owned (default)
    input: &Vec                // Borrowed (explicit reference)
}
#+END_SRC

*** Semantics
- **Owned field**: Actual data stored inline; ~delete()~ cascades
- **Borrowed field**: Stores a pointer; ~delete()~ skips it

*** Default: Owned (like Rust)
Fields own their data by default. Borrowing requires explicit ~&~ or ~ref~.
This is safer - you must consciously decide to borrow.

** ASAP Destruction (Issue #117)

Automatic ~delete()~ insertion on last use:
#+BEGIN_SRC til
process := proc() {
    data := Vec.new(I64)
    data.push(1)
    data.push(2)
    result := sum(data)
    // Compiler inserts: data.delete() here (last use was previous line)
    return result
}
#+END_SRC

*** Interaction with References
- Owned values: ASAP destruction applies
- References (~&T~): Don't delete - someone else owns the data
- Borrowed fields: Parent's ~delete()~ skips them

** For-In Loops with References (Bug #144)

With reference syntax, for-in could iterate without copying:

*** Current (copies each element)
#+BEGIN_SRC til
for expr: Expr in exprs {
    // expr is a COPY - modifications don't affect exprs
    // Performance cost for large structs
}
#+END_SRC

*** With References
#+BEGIN_SRC til
for expr: &Expr in exprs {
    // expr is a REFERENCE - no copy
    println(expr.line)         // Reads through reference
}

for expr: &mut Expr in exprs {
    // Mutable reference - can modify in place
    expr.line = 0
}
#+END_SRC

*** Desugaring
#+BEGIN_SRC til
// for elem: &T in collection { body }
// becomes:
for i in 0..collection.len() {
    elem: &T = collection.get_ref(i)   // Returns &T, no copy
    body
}
#+END_SRC

Collections implement ~get_ref(i) returns &T~ for this to work.

** Complete Parameter/Variable Reference

| Context | Syntax | Semantics | Copy? |
|---------+--------+-----------+-------|
| **Parameters** | | | |
| Default | ~f(x: T)~ | Immutable reference | No |
| Mutable | ~f(mut x: T)~ | Mutable reference | No |
| Copy | ~f(copy x: T)~ | Explicit copy | Yes |
| Own | ~f(own x: T)~ | Ownership transfer | No (move) |
| **Local Variables** | | | |
| Default | ~x := y~ | Immutable reference | No |
| Mutable | ~mut x := y~ | Mutable copy | Yes |
| **Explicit References** | | | |
| Take ref | ~p := &x~ | Create typed pointer | No |
| Deref read | ~p.field~ | Access through pointer | No |
| Deref copy | ~v := *p~ | Copy value out | Yes |
| **Struct Fields** | | | |
| Owned | ~field: T~ | Owns data, delete cascades | N/A |
| Borrowed | ~field: &T~ | Reference, no delete | N/A |

** Summary of Remaining Work

1. **Issue #151**: Decide on reference syntax (~&~, ~^~, or ~ref~)
2. **Issue #115**: Implement owned/borrowed field semantics
3. **Issue #117**: Implement ASAP destruction
4. **Bug #144**: Update for-in desugaring to use references
5. **Bug #49**: Typer use-after-move tracking for ~own~ parameters

* Design Principle: Explicit at Call Sites

TIL follows a consistent principle: **important control flow must be visible
at the call site**, not hidden in function signatures.

** The Principle

When reading code, you shouldn't need to look up every function signature to
understand what's happening. Two key cases:

1. **Ownership transfer**: Is this variable consumed?
2. **Potential errors**: Can this call fail?

Both are made explicit at the point of use.

** Ownership: ~own~ at Call Sites

#+BEGIN_SRC til
// Without call-site own (bad - have to look up process() signature):
result := process(data)
use(data)  // Is this valid? Who knows without checking process()

// With call-site own (good - self-documenting):
result := process(own data)
use(data)  // Obviously wrong - we just moved data
#+END_SRC

The ~own~ keyword is required both in the function signature AND at the call
site. This makes ownership transfer visible when reading code.

** Errors: ~?~ at Call Sites

#+BEGIN_SRC til
// Without ? (bad - have to look up signatures):
value := map.get("key")
other := parse(input)
// Which of these can throw? Have to check each signature.

// With ? (good - self-documenting):
value := map.get("key")?
other := parse(input)?
// Immediately see: both can throw
#+END_SRC

The ~?~ is required on ALL throwing calls, even when catching immediately
after. It marks "this can throw" - what happens to the error (caught or
propagated) is determined by catch blocks and throws declarations.

** TIL vs Rust

| Feature   | Rust                       | TIL                          |
|-----------+----------------------------+------------------------------|
| Move      | Implicit (default)         | Explicit: ~own~ at call site |
| Error     | ~?~ means "propagate"      | ~?~ means "can throw"        |

TIL is more explicit in both cases. The trade-off is slightly more typing
for significantly more readable code.

** Complete Example

#+BEGIN_SRC til
process := proc(own data: Data) throws ProcessError {
    // Caller wrote: process(own data)?
    // They see: data consumed, call can throw

    result := transform(own data)?   // data moved, can throw
    save(result)?                    // can throw

    catch (e: TransformError) {
        throw ProcessError(e.msg)    // convert and rethrow
    }
}

main := proc() {
    data := load()?
    process(own data)?

    catch (e: LoadError) { println("Load failed") }
    catch (e: ProcessError) { println("Process failed") }
}
#+END_SRC

See also: doc/errors.org for full error handling design.

* Conclusion

TIL's ownership model has **remarkable convergence with Mojo**:

**Similarities:**
- Default locals are references (TIL implicit, Mojo explicit with `ref`)
- Mutable locals copy (both use different keywords: TIL `mut`, Mojo `var`)
- Mutable parameters are references (both use `mut`)
- Ownership transfer supported (TIL `own`, Mojo `^`)

**Where TIL is simpler:**
- No explicit `ref` keyword needed (default behavior)
- Readable `own` keyword (both in signature AND at call site) instead of `^` sigil

**Where TIL needs work:**
- Phase 3: Default params should be refs (currently copy)
- Bug #49: Typer use-after-move tracking
- Lifetime tracking for move-only types (if needed)

The key insight: **const copy vs const reference is an implementation detail**.
Users don't need to care, type checker ensures safety either way.
