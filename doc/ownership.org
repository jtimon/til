#+TITLE: TIL vs Mojo: Ownership and Memory Safety Design Comparison
#+DATE: 2025-11-12
#+UPDATED: 2025-11-12
#+AUTHOR: TIL Development

* Overview

Comparison of TIL's ownership model with Mojo's ownership system, showing remarkable convergence in design philosophy.

* Mojo's Design

** Argument Conventions (Function Parameters)

Mojo has three main argument conventions:

1. **read** (default): Immutable reference, no copy
   - Efficient for large values
   - Cannot modify the argument

2. **mut**: Mutable reference (inout parameter)
   - Modifications visible to caller
   - Enforces exclusivity (no aliasing)

3. **var**: Ownership transfer
   - Function takes ownership
   - Either copy (if copyable) or move with ^ sigil

** Local Variables (Updated 2025)

Mojo REMOVED the `let` keyword for immutable variables because:
- Immutability only applied to the binding, not the referenced value
- This was confusing with reference types
- Not needed for Python programmers
- Immutability better handled through function parameters

Current design:
- **var**: Mutable variables (only kind of local variable)
- **ref**: Explicit reference binding (for aliasing)

** Philosophy

- Value semantics by default
- References for performance
- Automatic lifetime checking by compiler
- Simplicity over completeness (removed `let`)
- Ownership rules: "Every value has only one owner at a time"

* TIL's Current Design (Post Bug #25 Fix)

** Function Parameters

1. **Default (no keyword)**: Immutable parameter
   - Currently COPIES (inefficient)
   - Phase 3 goal: Make it a reference
   - Type checker prevents modification

2. **mut**: Mutable reference
   - Modifications visible to caller
   - Works for primitives and structs

3. **copy**: Explicit copy
   - Local modifications don't affect caller
   - Added in Phase 2

4. **own** (future): Ownership transfer
   - Caller can pass with `own` at call site
   - Invalidates variable in caller's context
   - Example: `func(own my_string)` transfers ownership
   - Works even if function declared with `mut` (opt-in at call site)

** Local Variable Declarations (Bug #25 Fix)

After Bug #25 fix, TIL has clean semantics:

1. **mut x := original**: Creates INDEPENDENT COPY
   - Modifications to x don't affect original
   - Safe, prevents aliasing
   - Equivalent to Mojo's `var x = original`

2. **x := original** (no keyword): Immutable reference binding
   - Shares arena offset (no copy)
   - Type checker prevents modification
   - Efficient, safe
   - **Equivalent to Mojo's `ref x = original`**

** Design Insight

TIL's default (no keyword) ‚âà Mojo's `ref`
- Both are reference bindings
- Both are immutable (enforced by type checker/compiler)
- User doesn't need to care if it's a "const copy" or "const reference" - same behavior!

The key realization: **const copy vs const reference is an implementation detail**.
From the user's perspective, if you can't modify it, it doesn't matter whether
it's copied or referenced. TIL chooses reference (efficient), Mojo makes it explicit
with `ref` keyword. TIL's approach is arguably simpler.

* Comparison Table (Updated)

| Feature                 | Mojo (2025)    | TIL (Current)       | Notes                               |
|-------------------------+----------------+---------------------+-------------------------------------|
| Default param           | read (ref)     | Copy                | Phase 3: will become ref            |
| Mutable param           | mut (ref)      | mut (ref)           | ‚úÖ Same                             |
| Copy param              | var (copy)     | copy                | ‚úÖ Same concept                     |
| Ownership transfer      | var with ^     | own (in signature)  | TIL: in sig, Mojo: at call site     |
| Mut local               | var x = y      | mut x := y          | ‚úÖ Equivalent (both copy)           |
| Immut local             | (REMOVED)      | x := y (ref)        | TIL simpler: default is ref         |
| Explicit ref            | ref x = y      | x := y              | TIL: no keyword needed (is default) |
| Move at call site       | foo(x^)        | foo(x) to own param | TIL: implicit, Mojo: explicit ^     |

* Key Differences

** Where TIL is Simpler

1. **No explicit ref keyword needed**: Default is reference
   - Mojo: `ref x = y` (explicit)
   - TIL: `x := y` (implicit, cleaner)

2. **Readable ownership keyword**: Uses `own` in signature
   - Mojo: `^` sigil at call site (punctuation)
   - TIL: `own n: T` in function signature (readable)

3. **Simpler local variables**: Only two cases
   - `mut x := y` = mutable copy
   - `x := y` = immutable reference
   - No need to learn separate `ref` keyword

** Where Mojo is More Explicit

1. **Explicit ref binding**: `ref` keyword makes aliasing visible
2. **Default params are refs**: Already efficient (TIL needs Phase 3)
3. **Mature lifetime system**: Compiler-enforced lifetimes

** Implementation Status

TIL is currently missing:
1. **Phase 3**: Default params should be references (blocked by arena issues)
2. **Bug #49**: Typer doesn't track use-after-move (interpreter does at eval)
3. **Lifetime tracking**: Would need for move-only types

* TIL's Design Philosophy (Refined Understanding)

** Core Insight: Const Copy vs Const Reference Doesn't Matter

From user discussion:
> "why does it matter to the user if it's a const copy or a const reference?
> you can't modify it either way."

This is **exactly right** and a key design principle. If a binding is immutable:
- Whether it's a copy or reference is an **implementation detail**
- User sees identical behavior either way
- Implementation can choose most efficient approach

This is why Mojo removed `let` - the distinction was confusing and unnecessary.

** Current Semantics (Post Bug #25)

Local variables:
```til
x := original        // Immutable reference (shares offset, can't modify)
mut x := original    // Mutable copy (independent, can modify)
```

Function parameters:
```til
func(x: T)           // Immutable (currently copies, should be ref in Phase 3)
func(mut x: T)       // Mutable reference
func(copy x: T)      // Explicit copy
```

** Ownership Transfer Design (Current)

Use `own` in **signature** (declaration):
```til
consume := proc(own n: I64) returns I64 { return mul(n, 2) }
// ...
mut x := 42
result := consume(x)    // x is invalidated after this call
// x is now undefined - use-after-move error
```

The function signature declares it takes ownership. Caller doesn't need special syntax.
Variable is automatically invalidated after being passed to an `own` parameter.

** Call-site own syntax (Optional/Future)

Call-site syntax like `func(own x)` could be added for code clarity:
```til
result := consume(own x)    // Explicit: reader sees ownership transfer
```

This would be purely aesthetic - making the transfer visible at the call site.
The mechanism works without it since the signature already declares `own`.

** Comparison with Mojo's Equivalents

| TIL                | Mojo Equivalent     | Notes                              |
|--------------------+---------------------+------------------------------------|
| x := y             | ref x = y           | **TIL's default ‚â° Mojo's ref**     |
| mut x := y         | var x = y           | Both copy                          |
| own n: T (in sig)  | var with ^          | TIL: in signature, Mojo: at call   |
| func(mut x: T)     | func(mut x: T)      | Same (mutable reference)           |

**Key Equivalence**: TIL's default (no keyword) is equivalent to Mojo's `ref`.
Both create immutable reference bindings. TIL doesn't need explicit `ref` keyword
because the default behavior IS reference binding.

* Implementation Roadmap

** ‚úÖ Phase 1: Immutability Enforcement (COMPLETE)
- Type checker prevents modification of non-mut parameters
- Prevents field modification
- Foundation for safe reference semantics

** ‚úÖ Phase 2: Copy Keyword (COMPLETE)
- Added `copy` keyword for explicit copying
- Mutually exclusive with `mut`
- Enables fine-grained control

** ‚úÖ Bug #25 Fix: Declaration Semantics (COMPLETE)
- `mut x := y` creates independent copy
- `x := y` creates immutable reference binding
- Aligns with Mojo's philosophy

** ‚è∏ Phase 3: Default Params as References (DEFERRED)
- Goal: Make `func(x: T)` pass by reference instead of copy
- Blocked: Arena singleton + context cloning causes corruption
- Can revisit post self-hosting with better debugging tools

** ‚ö†Ô∏è In Progress: Ownership Transfer (Partial Implementation)
Status: Basic implementation done, use-after-move check needs typer fix

Completed (2025-12-18 update):
- ‚úÖ Lexer: Added `own` token
- ‚úÖ Parser: Accepts `own` in parameter declarations (mutually exclusive with mut/copy)
- ‚úÖ Type checker: Allows modification of `own` parameters
- ‚úÖ Interpreter: Invalidates caller's variable after passing to own param
- ‚úÖ All own tests in src/test/args.til passing (lines 494-621)

Still missing:
- ‚ùå Use-after-move at typer phase: Interpreter catches at eval, compiler doesn't catch at all
  - Fix: Mirror interpreter - remove symbol from scope when passed to own param (Bug #49)
- ‚ö™ Call-site `own` syntax: `func(own x)` not parsed (optional - for code clarity only)

Current behavior:
```til
consume := proc(own n: I64) returns I64 { return mul(n, 2) }
mut x := 42
result := consume(x)
// Interpreter: x is now undefined (use-after-move works at eval)
// Compiler: x still accessible (bug - should be caught by typer)
```

Tests in src/test/args.til (lines 494-621) - all passing

** üîÆ Future: Move-Only Types (Maybe)
Needs more research and real-world examples to determine necessity.

* Conclusion

TIL's ownership model has **remarkable convergence with Mojo**:

**Similarities:**
- Default locals are references (TIL implicit, Mojo explicit with `ref`)
- Mutable locals copy (both use different keywords: TIL `mut`, Mojo `var`)
- Mutable parameters are references (both use `mut`)
- Ownership transfer supported (TIL `own`, Mojo `^`)

**Where TIL is simpler:**
- No explicit `ref` keyword needed (default behavior)
- Readable `own` keyword in signature instead of `^` sigil at call site

**Where TIL needs work:**
- Phase 3: Default params should be refs (currently copy)
- Bug #49: Typer use-after-move tracking
- Lifetime tracking for move-only types (if needed)

The key insight: **const copy vs const reference is an implementation detail**.
Users don't need to care, type checker ensures safety either way.
