#+TITLE: Pass-by-Reference Refactoring Plan (Phase 3)
#+DATE: 2025-11-12
#+AUTHOR: TIL Development
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it

* Overview

Plan to refactor TIL's default parameter passing from copy-by-default to reference-by-default (immutable reference).

Current status: **DEFERRED** until self-hosting or after field offset refactoring.

* Current Implementation: Copy-by-Default

** How It Works Today

Location: src/rs/interpreter.rs:1450-1800

When calling a function with default (non-mut, non-copy, non-own) parameters:

#+BEGIN_SRC rust
// 1. Clone the context (line 1464)
let mut function_context = context.clone();  // Clones arena_index HashMap, NOT arena memory

// 2. Evaluate argument in caller's context (line 1559)
let result = eval_expr(context, &current_arg)?;

// 3. Allocate NEW memory for parameter (lines 1654-1788)
function_context.insert_struct(&arg.name, &type_name, e)?;
function_context.copy_fields(&source_var, &arg.name, e)?;  // Copies bytes in Arena
#+END_SRC

Key point: Even when passing a variable, it allocates fresh memory and copies bytes from source offset to destination offset.

** The Two Cases

*** Passing a Variable

Example: ~func(my_var)~

- ~my_var~ exists at offset 100 in caller's arena_index
- New memory allocated at offset 200 for parameter
- ~copy_fields()~ copies bytes from offset 100 → 200
- Function uses offset 200

*** Passing an Expression

Example: ~func(Vec2.new(1, 2))~ or ~func(x + y)~

- Expression evaluated, allocates at offset 300
- New memory allocated at offset 400 for parameter
- Bytes copied from offset 300 → 400
- Function uses offset 400

Note: For struct expressions, this currently errors - only identifiers allowed for non-own parameters.

** Performance Cost

Every function call copies all parameter data:
- Primitives: 8 bytes (I64, pointers)
- Structs: Entire struct contents (recursive)
- Strings: 16 bytes (ptr + cap)

* Desired Implementation: Reference-by-Default

** Goal

Default parameters (no keyword) should be **immutable references**:
- Zero-copy for variables
- Type checker enforces immutability
- Aligns with Mojo's ~read~ convention

** The Core Distinction

*** Variables (Already Have Arena Offset)

Variables should share their existing offset:

#+BEGIN_SRC rust
// NEW BEHAVIOR - no copying!
match &current_arg.node_type {
    NodeType::Identifier(id_) => {
        // Just share the offset instead of copying
        if let Some(offset) = context.arena_index.get(id_) {
            function_context.arena_index.insert(arg.name.clone(), *offset);
            // For structs: map field offsets too
            function_context.map_instance_fields(&type_name, &arg.name, e)?;
        }
        // NO insert_struct(), NO copy_fields()
    }
}
#+END_SRC

Result: Both contexts point to same arena offset - zero copy!

*** Expressions (Don't Have Offset Yet)

Expressions must still allocate fresh memory:

#+BEGIN_SRC rust
_ => {
    // Must evaluate and allocate fresh
    let result = eval_expr(context, &current_arg)?;
    // Use the offset from evaluation result
    function_context.insert_struct(&arg.name, &type_name, e)?;
}
#+END_SRC

Result: Expression produces owned value in function context.

** What Gets Simpler

*** 1. copy_fields() Becomes Mostly Unnecessary

Location: init.rs:1091

#+BEGIN_SRC rust
// TODO all args should be passed as pointers/references and we wouldn't need this
pub fn copy_fields(&mut self, custom_type_name: &str, src: &str, dest: &str, ...) -> Result<(), String>
#+END_SRC

After refactoring:
- Only needed for explicit ~copy~ keyword parameters
- Default parameters: share offset (no copy)
- Expression parameters: already allocated (no copy needed)

*** 2. mut Parameter Return Logic Becomes Simpler

Location: interpreter.rs:1868

#+BEGIN_SRC rust
// TODO this can be simplified once we pass all args by reference
if let Some(offset) = function_context.arena_index.get(&arg_name) {
    context.arena_index.insert(source_name.to_string(), *offset);
    context.map_instance_fields(type_name, &source_name, e)?;
}
#+END_SRC

Current flow: Copy going in, copy coming back out
After refactoring: Share offset going in, share offset coming out

*** 3. Aligns with own Parameter Mechanism

Location: interpreter.rs:1607-1650

The ~own~ parameter implementation ALREADY shares offsets:

#+BEGIN_SRC rust
if arg.is_own {
    if let NodeType::Identifier(source_var) = &current_arg.node_type {
        if let Some(offset) = context.arena_index.get(source_var).copied() {
            function_context.arena_index.insert(arg.name.clone(), offset);
            // ... transfer field offsets too ...

            // Remove from caller's context (ownership transferred)
            context.arena_index.remove(source_var);
        }
    }
}
#+END_SRC

Default parameters would use the SAME mechanism, just without the "remove from caller" part.

* Implementation Plan

** Code Changes Needed

Location: src/rs/interpreter.rs, lines ~1650-1788

*** Step 1: Detect if argument is a variable or expression

#+BEGIN_SRC rust
// Around line 1650
match &current_arg.node_type {
    NodeType::Identifier(id_) => {
        // Variable case - share offset
    }
    _ => {
        // Expression case - allocate fresh
    }
}
#+END_SRC

*** Step 2: For variables, share arena offset

#+BEGIN_SRC rust
NodeType::Identifier(id_) => {
    if let Some(offset) = context.arena_index.get(id_) {
        // Share the offset (reference semantics)
        function_context.arena_index.insert(arg.name.clone(), *offset);

        // For structs, also share field offsets
        if matches!(arg.value_type, ValueType::TCustom(_)) {
            function_context.map_instance_fields(&type_name, &arg.name, e)?;
        }

        // Skip allocation logic
        param_index += 1;
        continue;
    } else {
        return Err(e.lang_error("eval", &format!("Variable '{}' not found", id_)));
    }
}
#+END_SRC

*** Step 3: For expressions, allocate as usual

#+BEGIN_SRC rust
_ => {
    // Expression case - evaluate and allocate
    // This is the current behavior, keep it
    function_context.insert_struct(&arg.name, &type_name, e)?;
    // ... rest of allocation logic
}
#+END_SRC

*** Step 4: Update copy keyword to use old behavior

The ~copy~ keyword should continue to allocate fresh and copy:

#+BEGIN_SRC rust
if arg.is_copy {
    // Use old copy-by-default behavior
    function_context.insert_struct(&arg.name, &type_name, e)?;
    function_context.copy_fields(&source_var, &arg.name, e)?;
} else {
    // Use new reference-by-default behavior
    // ... sharing logic from Step 2
}
#+END_SRC

** Estimated LOC Changes

- ~50 lines modified in interpreter.rs
- Logic reorganization, no new algorithms needed
- Existing ~own~ parameter code serves as template

* Arena Architecture Concerns

** The Arena Singleton

Location: interpreter.rs:16-37

#+BEGIN_SRC rust
pub struct Arena {
    pub memory: Vec<u8>,
    pub temp_id_counter: usize,
}

impl Arena {
    pub fn g() -> &'static mut Arena {
        unsafe {
            static mut INSTANCE: Option<Arena> = None;
            INSTANCE.get_or_insert_with(|| Arena {
                memory: vec![0],
                temp_id_counter: 0,
            })
        }
    }
}
#+END_SRC

The Arena is a **global singleton** shared by all contexts.

** Potential Aliasing Issues

When reference-passing is enabled, both caller and function contexts point to same arena offsets:

#+BEGIN_SRC til
x := Vec2.new(5, 10)  // caller: arena_index["x"] = 100

func(x: Vec2)         // function: arena_index["x"] = 100 (SAME!)
#+END_SRC

Potential problems if not handled correctly:

*** Problem 1: Modification of immutable reference

#+BEGIN_SRC til
x := Vec2.new(5, 10)  // Immutable binding
func(x: Vec2) {       // Should be read-only
    x.x = 99          // Should this modify caller's x?
}
#+END_SRC

Expected: Type checker should reject assignment to ~x~ (const parameter)

*** Problem 2: Arena reallocation during function execution

#+BEGIN_SRC til
func(x: BigStruct) {
    y := AllocateLotsOfMemory()  // Might reallocate arena.memory Vec
    println(x)                   // x's offset now points to invalid memory!
}
#+END_SRC

Expected: Arena reallocation must preserve all existing offsets (Vec growth does this automatically)

*** Problem 3: Passing const to mut parameter

#+BEGIN_SRC til
x := Vec2.new(5, 10)       // Immutable binding
modify(mut y: Vec2) {
    y.x = 99
}
modify(x)                  // Should this be allowed?
#+END_SRC

Expected: Type checker should reject passing const to mut parameter

** Why mut and own Parameters Work

*** mut parameters work because:

1. Function gets a COPY initially (safe during execution)
2. After function returns, offset is shared back
3. Function context is destroyed, so no aliasing remains

Current implementation (lines 1867-1874):
#+BEGIN_SRC rust
// After function returns
if let Some(offset) = function_context.arena_index.get(&arg_name) {
    context.arena_index.insert(source_name.to_string(), *offset);
}
#+END_SRC

*** own parameters work because:

1. Offset is TRANSFERRED, not shared
2. Caller loses access (removed from arena_index)
3. Only one context has the offset at any time

Current implementation (lines 1607-1650):
#+BEGIN_SRC rust
// Transfer ownership
function_context.arena_index.insert(arg.name.clone(), offset);
// Remove from caller
context.arena_index.remove(source_var);
#+END_SRC

** Are These Real Blockers?

*CLARIFICATION*: Most of these are NOT actual blockers! The type checker already prevents the problematic scenarios.

*** Type Checker Already Enforces Safety

1. **Cannot modify const parameters**: Type checker already enforces immutability (typer.rs:933)
   - Attempting ~x.field = value~ on const parameter → type error
   - Attempting ~x = value~ on const parameter → type error
   - *This is already working correctly*

2. **Cannot pass const to mut parameter**: Type checker should already enforce this
   - Passing const variable to ~mut~ parameter → type error
   - *Need to verify this is enforced, may need enhancement*

3. **Arena reallocation**: Vec growth preserves existing data, offsets remain valid
   - Rust's Vec::push reallocates but copies existing data
   - All existing offsets remain valid after reallocation
   - *This is not a blocker*

4. **Mut parameters SHOULD modify caller**: That's the feature!
   - When passing to ~mut~ parameter, modifications apply to caller's data
   - Both contexts point to same arena location
   - Type checker ensures only mutable variables can be passed to ~mut~ parameters
   - *This is the intended behavior, not a bug*

*** What Are the Actual Concerns?

The "arena singleton aliasing" concerns appear to be mostly theoretical. The real issues are:

1. **Debugging complexity**: When both contexts share offsets, bugs are harder to trace
   - Current copy-based approach: Each context has independent data
   - Reference-based approach: Contexts share data, mutations harder to track
   - *This is a tooling/debugging issue, not a correctness issue*

2. **Field registration complexity**: Current system pre-registers all fields
   - Complicates sharing offsets (see Field Registration Technical Debt below)
   - Need to re-register fields with new parameter name
   - *This IS a real blocker - but solvable with field offset refactoring*

3. **Self-hosting benefits**: Easier to implement and debug in TIL itself
   - Better debugging tools in native TIL
   - Can implement lifetime tracking in TIL's type system
   - *This is a practical choice, not a technical requirement*

* Field Registration Technical Debt (Actual Blocker)

** Current System: Eager Field Pre-Registration

The REAL complexity blocking pass-by-reference is the current field registration system.

*** How It Works

Location: init.rs:1009-1089 (~map_instance_fields()~)

When a struct instance is created, ALL fields are eagerly registered in ~arena_index~:

#+BEGIN_SRC rust
// For instance "person" of type "Person" with fields {name: Str, age: I64}
arena_index["person"] = 1000                // Base offset
arena_index["person.name"] = 1000           // Field at offset 0
arena_index["person.name.c_string"] = 1000  // Str sub-field
arena_index["person.name.cap"] = 1008       // Str sub-field
arena_index["person.age"] = 1016            // Field at offset 16
#+END_SRC

Each struct instance creates O(n) entries in ~arena_index~, where n = number of fields (including nested).

*** The Problem for Pass-by-Reference

When passing by reference, we want to share the base offset:

#+BEGIN_SRC til
person := Person { name: "Alice", age: 30 }
// Caller has: arena_index["person"] = 1000, arena_index["person.name"] = 1000, etc.

func(p: Person) {
    println(p.name)  // Should access same memory as person.name
}
#+END_SRC

But the current system expects fields to be registered with the parameter name:

#+BEGIN_SRC rust
// Function context needs:
arena_index["p"] = 1000              // Shared base offset ✓
arena_index["p.name"] = 1000         // Must re-register with "p" prefix
arena_index["p.name.c_string"] = 1000
arena_index["p.name.cap"] = 1008
arena_index["p.age"] = 1016
#+END_SRC

This requires calling ~map_instance_fields()~ to re-register all fields with the new name.

*** Why This Is Complex

1. **Redundant storage**: Same offset stored multiple times under different keys
2. **Re-registration overhead**: Must traverse all fields and create new entries
3. **Name dependency**: Field access depends on full dotted path as HashMap key
4. **Special cases**: Str fields require manual sub-field copying (init.rs:1060-1086)

** Alternative: Dynamic Offset Calculation

*** The Better Approach

Instead of pre-registering all fields, calculate offsets dynamically:

#+BEGIN_SRC rust
// Only store base offset
arena_index["person"] = 1000

// Calculate field offset on access
fn get_field_offset(base: usize, type_name: &str, field_path: &[&str]) -> usize {
    let mut offset = base;
    let mut current_type = type_name;

    for field_name in field_path {
        let struct_def = self.struct_defs.get(current_type)?;

        // Iterate through fields until we find the target
        let mut field_offset = 0;
        for (member_name, decl) in &struct_def.members {
            if !decl.is_mut { continue; }

            if member_name == field_name {
                offset += field_offset;
                current_type = extract_type(&decl.value_type);
                break;
            }

            field_offset += get_type_size(&decl.value_type)?;
        }
    }

    return offset;
}

// Usage: person.name.c_string
let offset = get_field_offset(1000, "Person", &["name", "c_string"]);
#+END_SRC

*** Infrastructure Already Exists

The system ALREADY calculates offsets dynamically in ~get_type_size()~ (init.rs:1189-1214):

#+BEGIN_SRC rust
pub fn get_type_size(&self, type_name: &str) -> Result<usize, String> {
    if let Some(struct_def) = self.struct_defs.get(type_name) {
        let mut total_size = 0;

        for (field_name, decl) in &struct_def.members {
            if !decl.is_mut { continue; }
            let field_size = /* recursive calculation */;
            total_size += field_size;
        }
        Ok(total_size)
    }
}
#+END_SRC

The same traversal logic can calculate field offsets!

** Benefits of Dynamic Offset Calculation

1. **Sparse arena_index**: Only O(1) entry per struct (just base offset)
2. **No re-registration**: Sharing base offset is enough for pass-by-reference
3. **Uniform handling**: All structs (including Str) use same logic
4. **Cleaner code**: Field layout in StructDef, access logic in one place
5. **Memory savings**: Fewer HashMap entries

** Pass-by-Reference Becomes Trivial

With dynamic offsets, sharing is just:

#+BEGIN_SRC rust
// Variable case - share base offset only
NodeType::Identifier(id_) => {
    if let Some(base_offset) = context.arena_index.get(id_) {
        function_context.arena_index.insert(arg.name.clone(), *base_offset);
        // Done! No field re-registration needed
    }
}
#+END_SRC

Field access inside function:
- Looks up ~arena_index["p"]~ → gets 1000
- Calculates ~p.name.cap~ → 1000 + offset_of("name") + offset_of("cap") = 1008
- Accesses arena memory at offset 1008

** Str Special Case Handling

*** Current Special Case

Location: init.rs:1060-1086

Immutable Str fields require special handling to copy sub-field (~.c_string~, ~.cap~) arena_index entries from type definition to instance.

This is because:
1. Str is a struct with mutable fields
2. But when used as immutable field of another struct, its sub-fields need registration
3. Done by copying arena_index entries from struct type to instance

*** With Dynamic Offsets

Str becomes a regular struct - no special case needed:

#+BEGIN_SRC til
Person := struct {
    name: Str,  // Immutable Str field
    age: I64
}

person := Person { name: "Alice", age: 30 }
// Only stores: arena_index["person"] = 1000

// Access person.name.cap
// Calculate: base=1000 + offset_of("name" in Person) + offset_of("cap" in Str)
//          = 1000 + 0 + 8 = 1008
#+END_SRC

No special Str handling required!

** Other Technical Debt Removed

*** 1. copy_fields() Mostly Unnecessary

Current: init.rs:1091
#+BEGIN_SRC rust
// TODO all args should be passed as pointers/references and we wouldn't need this
pub fn copy_fields(&mut self, custom_type_name: &str, src: &str, dest: &str, ...)
#+END_SRC

With dynamic offsets + pass-by-reference:
- Default params: Share base offset (no copy)
- ~copy~ keyword: Allocate and copy bytes (no field registration)
- Only needed for explicit ~copy~ parameters

*** 2. mut Parameter Writeback Simplified

Current: interpreter.rs:1867-1875
#+BEGIN_SRC rust
// TODO this can be simplified once we pass all args by reference
if let Some(offset) = function_context.arena_index.get(&arg_name) {
    context.arena_index.insert(source_name.to_string(), *offset);
    context.map_instance_fields(type_name, &source_name, e)?;  // Re-register fields
}
#+END_SRC

With dynamic offsets:
#+BEGIN_SRC rust
// Just share the base offset back
if let Some(offset) = function_context.arena_index.get(&arg_name) {
    context.arena_index.insert(source_name.to_string(), *offset);
    // Done! No field re-registration
}
#+END_SRC

*** 3. own Parameter Simplified

Current: interpreter.rs:1621-1630
#+BEGIN_SRC rust
// Transfer all field entries
let prefix = format!("{}.", source_var);
let keys_to_transfer: Vec<String> = context.arena_index.keys()
    .filter(|k| k.starts_with(&prefix))
    .cloned()
    .collect();

for key in &keys_to_transfer {
    // Transfer each field entry...
}
#+END_SRC

With dynamic offsets:
#+BEGIN_SRC rust
// Just transfer base offset
if let Some(offset) = context.arena_index.get(source_var).copied() {
    function_context.arena_index.insert(arg.name.clone(), offset);
    context.arena_index.remove(source_var);
    // Done! No field transfer loop
}
#+END_SRC

** Implementation Complexity

*** For Dynamic Offset Calculation

Estimated effort: ~100-150 LOC

1. Implement ~get_field_offset()~ helper (similar to ~get_type_size()~)
2. Update field access in ~eval_custom_expr()~ to use dynamic calculation
3. Remove ~map_instance_fields()~ calls (except for backward compat?)
4. Remove Str special-case handling
5. Test thoroughly with nested structs

*** For Pass-by-Reference (After Dynamic Offsets)

Estimated effort: ~50 LOC

1. Detect variable vs expression in parameter passing
2. Share base offset for variables
3. Allocate fresh for expressions
4. Update ~mut~ writeback (simpler now)
5. Test thoroughly

** Prerequisite: Verify Str Handling

Before removing Str special case, verify:

1. Is Str's memory layout stable? (c_string at offset 0, cap at offset 8)
2. Do all Str operations assume this layout?
3. Are there other types with similar special handling?

If Str has other special cases (insert_string(), get_string(), etc.), those might need updates.

** Recommendation: Tackle Field Offset Refactoring First

*** Rationale

1. **Simplifies byref implementation**: Reduces complexity significantly
2. **Independent value**: Dynamic offsets improve code quality regardless of byref
3. **Memory savings**: Fewer arena_index entries
4. **Removes technical debt**: Eliminates Str special case, simplifies many functions

*** Sequence

1. **Phase 3a**: Implement dynamic field offset calculation
   - Keep eager registration for backward compat initially
   - Add dynamic calculation path
   - Test both paths give same results
   - Gradually migrate field access to dynamic path
   - Remove eager registration

2. **Phase 3b**: Implement pass-by-reference
   - Now trivial with dynamic offsets
   - Just share base offsets
   - Update ~copy~, ~mut~, ~own~ to use simpler logic

* Why Deferred Until Self-Hosting (Updated)

From doc/ownership.org:218-221:

#+BEGIN_QUOTE
** ⏸ Phase 3: Default Params as References (DEFERRED)
- Goal: Make ~func(x: T)~ pass by reference instead of copy
- Blocked: Arena singleton + context cloning causes corruption
- Can revisit post self-hosting with better debugging tools
#+END_QUOTE

** Updated Understanding

The original reasoning about "arena singleton corruption" was based on a misunderstanding. The real situation:

*** NOT Actually Blockers
1. **"Cannot modify const parameters"**: Type checker already prevents this ✓
2. **"Arena reallocation breaks offsets"**: Vec growth preserves existing data ✓
3. **"Aliasing causes corruption"**: Only if type checker fails (it doesn't) ✓

*** ACTUAL Blocker
- **Field registration complexity**: Current eager pre-registration system complicates offset sharing
- Must re-register all fields when parameter name changes
- Requires calling ~map_instance_fields()~ which has bugs (see own parameter infinite loop)

*** Actual Reason for Deferring

**Choice 1**: Implement dynamic field offset calculation first (Phase 3a)
- Removes the real blocker (field registration complexity)
- Independent value (memory savings, code simplification)
- Makes pass-by-reference trivial to implement afterward
- Estimated ~100-150 LOC

**Choice 2**: Defer until self-hosting
- Better debugging tools
- Can implement in TIL itself with lifetime tracking
- Lower risk of introducing subtle bugs

** Rationale for Current Deferral

1. **Current system works correctly**: All tests pass, copy semantics are safe
2. **Field offset refactoring is significant**: Touches many parts of codebase
3. **Self-hosting is near**: Better to wait for improved tooling
4. **Explicit copy keyword exists**: Performance optimization available if needed

** Recommended Sequence (Future)

1. **Option A**: Do Phase 3a (dynamic offsets) before self-hosting
   - Simplifies codebase regardless of byref
   - Fixes ~own~ parameter bugs (infinite loop, field access)
   - Makes Phase 3b (byref) trivial

2. **Option B**: Defer both to self-hosting
   - Implement dynamic offsets in TIL itself
   - Implement byref in TIL itself
   - Lower risk, better debugging

** Post Self-Hosting Advantages

1. **Better debugging**: TIL-based interpreter with TIL debugging tools
2. **Lifetime tracking**: Can implement borrow-checker-like lifetime analysis
3. **Reference visualization**: Can inspect reference graph in native TIL
4. **Incremental approach**: Can test reference semantics in TIL codebase first
5. **Fix own parameter bugs**: Dynamic offsets will resolve current infinite loop issue

* Comparison with Mojo

From doc/ownership.org:

| Feature                 | Mojo (2025)    | TIL (Current)       | TIL (After Phase 3) |
|-------------------------+----------------+---------------------+---------------------|
| Default param           | read (ref)     | Copy                | Immutable ref       |
| Mutable param           | mut (ref)      | mut (ref)           | mut (ref)           |
| Copy param              | var (copy)     | copy                | copy                |
| Ownership transfer      | var with ^     | own (at call site)  | own (at call site)  |

After Phase 3, TIL's default parameters will match Mojo's ~read~ convention.

* Testing Plan

** Minimal Test Cases

*** Test 1: Variable reference (zero-copy)

#+BEGIN_SRC til
print_vec := proc(v: Vec2) {
    println(v.x)
    println(v.y)
}

main := proc() {
    v := Vec2.new(5, 10)
    print_vec(v)              // Should NOT copy
    println(v.x)              // v still accessible
}
#+END_SRC

Expected: v is NOT copied, function reads caller's memory.

*** Test 2: Expression allocation

#+BEGIN_SRC til
print_vec := proc(v: Vec2) {
    println(v.x)
}

main := proc() {
    print_vec(Vec2.new(5, 10))  // Expression must allocate
}
#+END_SRC

Expected: Expression allocates fresh memory for parameter.

*** Test 3: Immutability enforcement

#+BEGIN_SRC til
modify := proc(v: Vec2) {
    v.x = 99                  // Should be type error
}
#+END_SRC

Expected: Type checker rejects modification of const parameter.

*** Test 4: Copy keyword preserves old behavior

#+BEGIN_SRC til
modify := proc(copy v: Vec2) {
    v.x = 99                  // Should be allowed (local copy)
}

main := proc() {
    v := Vec2.new(5, 10)
    modify(v)
    println(v.x)              // Should still be 5
}
#+END_SRC

Expected: copy keyword creates independent copy, modifications don't affect caller.

*** Test 5: Nested structs

#+BEGIN_SRC til
Line := struct { mut start: Vec2, mut end: Vec2 }

print_line := proc(line: Line) {
    println(line.start.x)
    println(line.end.y)
}

main := proc() {
    line := Line { start: Vec2.new(0, 0), end: Vec2.new(10, 10) }
    print_line(line)          // Should share offset, include nested fields
}
#+END_SRC

Expected: Nested struct fields accessible via shared offsets.

** Performance Benchmarks

Compare execution time before/after refactoring:
- Function calls with large structs (>100 bytes)
- Recursive functions passing structs
- Hot loops with function calls

* Related TODOs

** init.rs:1091

#+BEGIN_SRC rust
// TODO all args should be passed as pointers/references and we wouldn't need this
pub fn copy_fields(&mut self, custom_type_name: &str, src: &str, dest: &str, e: &Expr) -> Result<(), String>
#+END_SRC

After Phase 3: ~copy_fields()~ only needed for ~copy~ keyword parameters.

** interpreter.rs:1868

#+BEGIN_SRC rust
// TODO this can be simplified once we pass all args by reference
if let Some(offset) = function_context.arena_index.get(&arg_name) {
    context.arena_index.insert(source_name.to_string(), *offset);
    context.map_instance_fields(type_name, &source_name, e)?;
}
#+END_SRC

After Phase 3: ~mut~ return logic becomes offset sharing, no copying needed.

* References

- Mojo ownership model: doc/ownership.org
- Parameter handling: src/rs/interpreter.rs:1450-1800
- Type checking: src/rs/typer.rs:278-375
- Arena implementation: src/rs/interpreter.rs:16-37
- Field copying: src/rs/init.rs:1091-1159
