#+TITLE: Future Performance, Architecture, and Cleanup
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks performance improvements, architecture decisions, and
internal cleanup work. For language features (new syntax, operators, etc.),
see features.org. For bugs, see bugs.org.

* Open Issues

** Issue #186: Symbol tracking performance -- is_consumed flag, is_used on SymbolInfo
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Performance, correctness, and better error messages
:STATUS: Open
:RELATED: Issue #185 (own at call sites), Bug #101 (unused variable warnings), Issue #117 (ASAP destruction)
:END:

*** Current state (Rust analysis)

**** Unused variable tracking (Bug #101)

~used_symbols~ is a ~HashSet<String>~ on ~ScopeStack~ (function-level, not
per-symbol). Every identifier reference calls ~mark_symbol_used(name)~ which
does ~self.used_symbols.insert(name.to_string())~ -- a string allocation + hash
+ insert for every single identifier use in the program.

At function exit, ~get_unused_symbols()~ iterates ~function_locals~ Vec and
checks each name against the HashSet. The ~function_locals~ Vec itself uses
linear search for deduplication (~is_already_processed~ scans the whole Vec).

Location: ~src/rs/init.rs:101~ (~used_symbols~), ~src/rs/init.rs:160~
(~mark_symbol_used~), ~src/rs/init.rs:166~ (~get_unused_symbols~),
~src/rs/typer.rs:270~ (call site), ~src/rs/typer.rs:1094~ (unused check).

**** Own-consumed variable tracking (Issue #117)

When a variable is passed to an ~own~ parameter, the typer calls
~remove_symbol(var_name)~ (~src/rs/typer.rs:880~) which physically removes
the symbol from the scope frame's HashMap. If ~removal_tracking_depth > 0~,
it also logs the removal in ~removed_log: Vec<RemovedSymbol>~.

The removal tracking exists because Bug #162 found that ~check_body_returns_throws~
re-walks the AST for UFCS resolution and needs the consumed symbols back.
So the typer saves/drains/restores consumed symbols around the two walks
(~src/rs/typer.rs:1047-1054~).

This means every own-consumption triggers:
1. HashMap remove
2. Vec push (if tracking)
3. Vec split_off (drain)
4. Vec iteration + HashMap re-insert (restore)

All for what could be a single boolean flag on the symbol.

*** Proposed improvement: flags on SymbolInfo

Instead of removing symbols and tracking them separately, add flags directly
to ~SymbolInfo~:

#+BEGIN_SRC rust
pub struct SymbolInfo {
    pub value_type: ValueType,
    pub is_mut: bool,
    pub is_copy: bool,
    pub is_own: bool,
    pub is_comptime_const: bool,
    // NEW:
    pub is_consumed: bool,       // ownership was transferred
    pub consumed_by: String,     // which function consumed it (for error msg)
    pub consumed_line: i64,      // where (for error msg)
    pub consumed_col: i64,       // where (for error msg)
    pub is_used: bool,           // variable was referenced at least once
}
#+END_SRC

Benefits:
- ~is_consumed~: No HashMap remove/re-insert cycle. Just set a flag. The
  "Undefined symbol" check becomes: "is symbol absent? -> undefined. is symbol
  consumed? -> ownership transferred error. otherwise -> valid."
- ~is_used~: No separate HashSet. Just set a flag on lookup. ~get_unused_symbols~
  iterates symbols in scope and checks the flag. Saves all the string allocations
  from ~mark_symbol_used~.
- Eliminates ~removed_log~, ~removal_tracking_depth~, ~begin/end_removal_tracking~,
  ~drain_removals_since~, ~restore_removed~ -- all replaced by a single flag that
  can be set/unset.
- The save/restore dance in ~check_func_proc_types~ becomes: save consumed state,
  clear flags, walk, restore flags.

*** Performance impact

Every identifier use currently does: ~used_symbols.insert(name.to_string())~
= 1 heap allocation + hash computation + HashSet insert. With ~is_used~ on
SymbolInfo: ~lookup_symbol(name)~ already happens, just set a bool on the
result. Zero extra allocations.

Every own-transfer currently does: HashMap remove + conditional Vec push +
later Vec split_off + HashMap re-inserts. With ~is_consumed~ on SymbolInfo:
set 4 fields on the already-looked-up symbol. Zero extra allocations.

For TIL (compiled C), the difference is even larger because Map/Set operations
involve dynamic dispatch through the eval heap.

*** Implementation notes

- ~has_symbol~ must return false for consumed symbols (or add ~has_live_symbol~)
  so existing "Undefined symbol" paths still trigger
- ~lookup_symbol~ should still find consumed symbols so the error path can
  read ~consumed_by~ / ~consumed_line~
- Need ~lookup_symbol_any~ (finds consumed too) vs ~lookup_symbol~ (skips consumed)
  OR keep one ~lookup_symbol~ and check ~is_consumed~ at each call site
- The typer's save/restore for Bug #162 becomes: snapshot consumed flags before
  first walk, restore after (instead of the remove/log/drain/restore cycle)
- ~is_used~ replaces the entire ~used_symbols: HashSet<String>~ field on ScopeStack
- ~function_locals~ Vec is still needed for shadowing detection (it tracks
  declaration locations, not just names)


** Issue #142: Code Simplification - Context Error Helpers
:PROPERTIES:
:DISCOVERED: 2026-01-26
:IMPACT: Reduces boilerplate, improves readability
:STATUS: Open
:END:

*** Description
Add helper methods to Context struct to reduce repetitive error creation boilerplate.
Currently there are 301 calls to error methods that redundantly pass ~context.path~.

*** Current Pattern
#+BEGIN_SRC til
errors.push(e.error(context.path, "type", format("...", foo, "...")))
errors.push(e.lang_error(context.path, "type", "..."))
errors.push(e.todo_error(context.path, "type", "..."))
#+END_SRC

Every call redundantly passes ~context.path~. The error methods are defined on Expr (parser.til:443).

*** Proposed Simplification
Add Context helper methods in init.til:
#+BEGIN_SRC til
// In init.til, add to Context struct:
type_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.error(self.path, "type", msg)
}
type_lang_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.lang_error(self.path, "type", msg)
}
type_todo_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.todo_error(self.path, "type", msg)
}
#+END_SRC

*** Usage After Change
#+BEGIN_SRC til
// Before (65 chars):
errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
// After (52 chars):
errors.push(context.type_error(e, format("Undefined symbol '", name, "'")))
#+END_SRC

*** Impact Analysis
| File | Approximate calls |
|------|-------------------|
| typer.til | 89 |
| interpreter.til | 98 |
| init.til | 63 |
| others | ~50 |
| Total | ~301 |

Estimated savings: ~13 chars per call x 301 calls = ~3900 chars saved

*** Files to Modify
| File | Changes |
|------|---------|
| src/self/init.til | Add Context helper methods |
| src/rs/init.rs | Port Context helpers |
| src/self/typer.til | Use new Context helpers (~89 calls) |
| src/rs/typer.rs | Port helper usage |
| src/self/interpreter.til | Use new Context helpers (~98 calls) |
| src/rs/interpreter.rs | Port helper usage |

*** Verification
1. ~make benchmark~ - all tests pass before and after
2. Line count comparison: ~wc -l src/self/typer.til~ before/after
3. No functional changes - pure refactoring

*** Additional Opportunities (Lower Priority)

**** ccodegen push_str Chains (1438 calls)
Many consecutive ~output.push_str()~ calls could be combined with ~format()~:
#+BEGIN_SRC til
// Current:
output.push_str(indent_str)
output.push_str(c_type)
output.push_str(" ")
output.push_str(temp_var)
output.push_str(";\n")

// Potential:
output.push_str(format(indent_str, c_type, " ", temp_var, ";\n"))
#+END_SRC
This is tedious but safe - consider as follow-up work.

**** I64Range.get() Dynamic Pattern
Uses Dynamic for interface compatibility with for-in loops. By design - cannot simplify without language-level template support.

** Issue #138: Use Bool for Ptr.is_borrowed or separate BorrowedPtr type
:PROPERTIES:
:DISCOVERED: 2026-01-25
:IMPACT: Cleaner ownership semantics
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction)
:END:

*** Description
Currently ~Ptr.is_borrowed~ is ~I64~ instead of ~Bool~ because Bool causes size
alignment issues between interpreter and compiled code:
- Interpreter: Bool = 1 byte, so Ptr = 9 bytes, Str = 25 bytes
- Compiled: Bool = 1 byte + 7 padding, so Ptr = 16 bytes, Str = 32 bytes

*** Options
1. Fix interpreter's ~size_of~ to account for alignment padding
2. Use separate types: ~Ptr~ (owned) vs ~BorrowedPtr~ (borrowed)
   - Smaller size: Ptr = 8 bytes (just data) instead of 16 bytes (data + is_borrowed)
   - Type system enforces ownership at compile time
   - No runtime check needed in delete()

*** Benefits of Bool
Would allow cleaner syntax in Ptr.delete():
#+BEGIN_SRC til
if self.is_borrowed {  // instead of if self.is_borrowed.eq(1)
    self.data = NULL
    return
}
#+END_SRC

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:RESOLVED: 2026-01-30
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open - shadowing check is too strict, needs scope-awareness (2026-02-23)
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (fix via name mangling), Bug #173 (Rust typer missing shadowing check)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Problem: shadowing check is too strict (2026-02-23)

The current check in ~typer.rs:check_declaration~ (Bug #97) uses ~function_locals~
which is function-wide -- it tracks ALL declarations across the entire function body,
regardless of scope. This means variables in separate scopes can't reuse names:

#+begin_src til
// FAILS: "Variable 'i' already declared in this function (shadowing not allowed)"
test := func() returns I64 = {
    mut sum := 0
    for i in 0..3 { sum = sum.add(i) }
    for i in 10..13 { sum = sum.add(i) }   // ERROR: 'i' already declared
    return sum
}
#+end_src

Range-for loops desugar to ~Body { mut i := start; while ... }~ (parser.rs:1504).
Both Body blocks are at function scope level from the typer's perspective since
~function_locals~ ignores scope nesting.

For-in loops DON'T have this problem because the user's variable is declared via
~cast()~ inside the while body, and ~cast~ declarations are created with the ForIn
node's line/col. The internal variables (~_for_i_funcname_N~, ~_ref_forin_N~) use
unique generated names.

*Minimum fix*: the shadowing check should respect scope boundaries (Body blocks).
Re-declaration in a sibling or nested scope is fine -- C itself handles this with
block scoping (~{}~), so no codegen issues. The ~is_shadowing_in_function~ check
needs scope tracking, or alternatively, the typer should push/pop the ~function_locals~
set when entering/leaving Body nodes.

Further relaxation (same-scope shadowing, type-change shadowing) can be decided later.

*** Action Items
- [ ] Make shadowing check scope-aware (at minimum, separate Body blocks)
- [ ] Decide on further relaxation (same-scope shadowing, type-change shadowing)
- [ ] Document final policy

*** References
- Bug #65: Specific instance where shadowing caused divergence
- Bug #97: Introduced the function-wide shadowing check
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #178: Eliminate TTypeDef, unify type representation
:PROPERTIES:
:DISCOVERED: 2026-02-22
:IMPACT: Internal cleanup, type system simplification
:STATUS: Open
:RELATED: Issue #105 (First-Class Structs), doc/first_class.org
:END:

*** Description
Replace ~TType(TTypeDef::TStructDef)~ / ~TType(TTypeDef::TEnumDef)~ /
~TType(TTypeDef::TFuncSig)~ with ~TCustom("StructDef")~ / ~TCustom("EnumDef")~ /
~TCustom("FuncSig")~ throughout the compiler. This would eliminate the ~TTypeDef~
enum and ~ValueType::TType~ variant entirely, unifying the type representation.

*** Background
This was originally Issue #105 Step 4b. It was attempted but deferred because
TIL's switch/case desugarer does not support string literal payloads in enum case
patterns (~case ValueType.TCustom("StructDef"):~ only matches the outer TCustom
variant, ignoring the string). Every case pattern had to be converted to
~case ValueType.TCustom(name): if name.eq("StructDef") { ... }~, which is fragile.
The attempt also hit OOM issues during benchmark.

Issue #105 Step 4d's ~metatype_matches()~ provides the user-facing benefits
(explicit metatype annotations) without the internal refactor.

*** Scope
~122 Rust refs to TTypeDef, ~126 TIL refs. Mechanical replacement but requires
careful handling of TIL's switch/case limitation.


