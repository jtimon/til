#+TITLE: Future Language Design Decisions
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.

* Overview

This document tracks long-term language design decisions that are not bugs
but need consideration. Unlike bugs.org (specific problems to fix), these
are open questions about language direction.

* Open Issues

** Issue #181: Standalone body blocks and first-class bodies
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Ergonomics -- eliminates ~if true {}~ hack, enables closures/lambdas later
:STATUS: Open
:RELATED: Issue #91 (first-class functions), Issue #105 (first-class types), Issue #106 (first-class enums), doc/first_class.org
:END:

*** Problem

Rust has standalone blocks ~{ ... }~ that create a new scope. TIL currently
requires ~if true { ... }~ as a workaround:

#+BEGIN_SRC rust
// Rust: standalone block
{
    let temp = compute();
    use_temp(temp);
}
// temp is out of scope
#+END_SRC

#+BEGIN_SRC til
// TIL: sad workaround
if true {
    temp := compute()
    use_temp(temp)
}
#+END_SRC

*** Step 1: Standalone body blocks

Allow bare ~{ ... }~ blocks as statements, creating a new scope:

#+BEGIN_SRC til
{
    temp := compute()
    use_temp(temp)
}
// temp is out of scope
#+END_SRC

Parser recognizes a ~{~ at statement level as a Body node (already exists in
the AST). Interpreter and ccodegen already handle Body nodes, so this may
mostly be a parser change.

*** Step 2: First-class bodies (future)

Bodies as values that can be stored, passed, and returned:

#+BEGIN_SRC til
my_block : Body = {
    println("hello")
    some_call()
}

// Pass as argument
run_block(my_block)

// Return from function
make_block : func() returns Body = {
    return { println("deferred") }
}
#+END_SRC

This is closely related to first-class functions (#91) and could share
infrastructure. A Body is essentially a zero-argument closure. Step 2 should
be designed alongside #91 to avoid duplicated effort.

** Issue #180: Bang operator ~!~ for panic-on-throw (Rust ~.unwrap()~ equivalent)
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Ergonomics -- cleaner translation of Rust .unwrap(), less boilerplate catch blocks
:STATUS: Open
:RELATED: rs2til.org (? operator semantics)
:END:

*** Description

Currently ~?~ marks that a call may throw. There is no concise way to say
"call this, and if it throws, panic." You must write a full catch block:

#+BEGIN_SRC til
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Propose ~!~ as an alternative to ~?~ meaning "panic on throw":

#+BEGIN_SRC til
result := might_fail(x)!   // panics if might_fail throws
#+END_SRC

This maps directly to Rust's ~.unwrap()~:

#+BEGIN_SRC rust
// Rust
let result = might_fail(x).unwrap();

// TIL equivalent
result := might_fail(x)!
#+END_SRC

*** Implementation

Desugarer transforms ~func()!~ by inserting a catch block with panic for
every throwable type immediately after the call:

#+BEGIN_SRC til
// Before desugaring:
result := might_fail(x)!

// After desugaring:
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Steps:
1. Lexer: recognize ~!~ after fcall (new token or reuse existing)
2. Parser: parse ~!~ like ~?~ but store a flag (e.g. ~FCall(does_throw=true, is_bang=true)~)
3. Desugarer: for bang calls, look up the function's throw types and generate
   a catch block with ~panic(loc(), err.msg)~ for each thrown type

*** Notes

- The desugarer needs access to function signatures to know which error types
  to catch. This is already available via ~context.scope_stack.lookup_func~.
- ~!~ should NOT be allowed on calls that don't throw (typer error).
- Multiple throw types generate multiple catch blocks, all panicking.

** Issue #167: Benchmark HashMap vs Map (OrderedMap) in Rust and TIL
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Performance - understand when HashMap is actually faster
:STATUS: Open
:RELATED: Issue #112 (HashMap implementation), Bug #166 (container dedup)
:END:

*** Summary
Systematically benchmark HashMap vs Map to understand when each wins.

In Rust, the codebase used ~HashMap~ (std) everywhere until ~OrderedMap~ was
introduced. In TIL, everything uses ~Map~ (sorted, O(log n) binary search).
TIL has a ~HashMap~ implementation (Issue #112) but it was slower than Map in
the two cases tested (small maps, ScopeFrame maps).

The question: is HashMap ever faster, and if so, does that advantage translate
to TIL?

*** Plan
1. In Rust: identify use cases where HashMap should win (large N, frequent
   lookup, no ordering needed). Benchmark HashMap vs OrderedMap for each.
2. For cases where HashMap wins in Rust, try the same in TIL. See if TIL's
   HashMap also wins, or if TIL's overhead negates the algorithmic advantage.
3. Document results:
   - If HashMap wins for some cases in both Rust and TIL: use HashMap there
   - If HashMap wins in Rust but not TIL: document the gap, investigate why
   - If Map/OrderedMap wins everywhere: validates TIL's design choice of Map
     as the shorter/default name. Document this.

*** Context
- Rust: ~HashMap~ (std, highly optimized SwissTable) vs ~OrderedMap~ (custom, sorted)
- TIL: ~Map~ (sorted, binary search) vs ~HashMap~ (first attempt, separate chaining)
- Only Map (TIL) and OrderedMap (Rust) are maintained equivalents by design.
  TIL's HashMap is a first attempt and likely far less optimized than Rust's
  std HashMap (which uses SwissTable/hashbrown). If HashMap wins in Rust but
  loses in TIL, the fault may be in TIL's naive HashMap implementation, not
  in the concept of hashing itself.
- Issue #112 showed TIL HashMap 81% slower for ScopeFrame maps (til interpreted)
  and 5-6% slower for small maps. But those were specific cases -- larger
  collections with pure lookup workloads may differ.
- For cases with few elements, the simpler sorted approach may win due to
  cache locality and lower overhead. This is expected and would reinforce
  TIL's choice of ~Map~ as the primary/shorter name.

** Issue #112: Add HashMap type with O(1) lookup
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Performance - self-hosted interpreter 2.7x slower than Rust
:STATUS: Blocked - TIL HashMap implementation too slow
:END:

*** Summary
Created HashMap type with O(1) average lookup, but it's actually slower than
the existing Map in TIL due to implementation overhead.

*** What Was Done
- Created ~HashMap~ type in ~src/std/hashmap.til~
- Uses ~Str.hash()~ (FNV-1a) for string keys, FNV-1a on raw bytes for others
- Separate chaining collision handling, power-of-2 buckets, 0.75 load factor
- Same API as Map (get, set, insert, contains_key, remove, etc.)
- Added 15 HashMap tests to ~src/test/maps.til~

*** Attempts to Use HashMap - Both Failed

**** Attempt 1: default_values and named_values
Result: 5-6% slower (small maps, overhead exceeds benefit)

**** Attempt 2: ScopeFrame maps (arena_index, symbols, funcs, enums, structs)
Result: 81% slower (TIL HashMap implementation has too much overhead)

| Metric          | Before   | After    | Change       |
|-----------------+----------+----------+--------------|
| til interpreted | 354.153s | 641.957s | +81% slower  |
| til compiled    | 14.441s  | 16.423s  | +14% slower  |

*** Root Cause
TIL HashMap overhead is too high:
- Hash computation via memcpy for non-Str keys
- Bucket indirection and chain traversal
- Key comparison via memcpy
- These costs exceed O(n) linear scan benefit even for larger maps

*** Possible Future Approaches
- Consider using OrderedMap instead of HashMap in Rust itself
- Optimize TIL HashMap (inline hash functions, avoid memcpy)
- Profile to identify actual bottleneck
- Accept interpreted TIL is slower, focus on compiled performance

** Issue #89: Constant folding only works at global scope
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Performance, macro implementation
:STATUS: Open
:END:

*** Description
Pure function calls with all compile-time known arguments are only constant
folded at global scope. Inside function bodies, they are not folded even when
all arguments are literals.

*** Example
#+BEGIN_SRC til
double := func(x: I64) returns I64 { return x.mul(2) }

// Global scope - folded to literal 10
global_result := double(5)

test := proc() {
    // Inside function - NOT folded, calls double() at runtime
    inner_result := double(10)
}
#+END_SRC

Generated C shows:
- ~til_global_result = 10~ (folded)
- ~til_inner_result = til_double(...)~ (not folded)

*** Location
~precomp_expr()~ in src/rs/precomp.rs / src/self/precomp.til has:
#+BEGIN_SRC til
at_global_scope := context.scope_stack.frames.len().eq(1)
if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
    const_folded = eval_comptime(context, const_folded)
}
#+END_SRC

The ~at_global_scope~ check should be removed.

*** Impact on Issue #88 (Macros)
This issue blocks proper macro implementation. Macros should be evaluated at
compile time regardless of where they are called.

*** Why the Fix is Safe

The ~at_global_scope~ check was added for Bug #41 to prevent double output from
functions with side effects. However, this is overly conservative because:

1. *~is_proc()~ correctly identifies side effects*: The type system guarantees
   that ~func~ cannot call ~proc~ (enforced by typer). Only ~proc~ can call
   ~ext_proc~, which is where actual side effects (I/O, memory allocation) live.

2. *Trust the type system*: If ~is_proc()~ returns false, the function is pure.
   The ~is_comptime_evaluable()~ check already calls ~is_proc()~ and rejects
   procs from folding.

3. *liba/pura exception is a debugging hack*: These modes allow ~func~ to call
   ~println~ as a convenience for debugging pure/lib code. If such funcs get
   evaluated twice (once at compile-time, once at runtime), that's an acceptable
   consequence of using the debugging modes.

4. *User responsibility*: If someone declares an ~ext_func~ that actually has
   side effects (instead of ~ext_proc~), that's the user's or mode designer's
   fault. The type system is correct; misuse is not our problem.

*** Future Enhancement
Add warnings when ~proc~ is used but ~func~ would suffice. Using ~proc~
unnecessarily causes a cascade effect - anything calling it must also be ~proc~
or in a special mode. This means users miss constant folding optimizations for
entire call chains.

*** Implementation Attempt (2026-01-07)

Tried removing ~at_global_scope~ checks from three locations. Result: build fails.

**** Three Locations with at_global_scope Check

1. *FCall folding* in ~precomp_expr()~ (precomp.rs line 229-235, precomp.til line 301-307):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // Only fold at global scope - inside function definitions, values from other
   // modules may not be available yet (import ordering). Interpreter doesn't
   // evaluate function bodies during import either.
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope && is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects
   // via the type system (func cannot call proc, only proc can call ext_proc).
   if is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

2. *Primitive storage* (I64/U8/Str) in ~precomp_declaration()~ (precomp.rs line 958-973, precomp.til line 1174-1191):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // Only do this at global scope - inside function bodies, evaluating could cause side effects
   // to run at compile time AND runtime (e.g., print_debug func in mode liba).
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope {
       if let ValueType::TCustom(ref custom_type_name) = &value_type {
           match custom_type_name.as_str() {
               "I64" | "U8" | "Str" => {
                   if is_comptime_evaluable(context, &new_params[0]) {
                       let inner_e = &new_params[0];
                       let result = eval_expr(context, inner_e)?;
                       if !result.is_throw {
                           EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                       }
                   }
               },
               _ => {},
           }
       }
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects.
   if let ValueType::TCustom(ref custom_type_name) = &value_type {
       match custom_type_name.as_str() {
           "I64" | "U8" | "Str" => {
               if is_comptime_evaluable(context, &new_params[0]) {
                   let inner_e = &new_params[0];
                   let result = eval_expr(context, inner_e)?;
                   if !result.is_throw {
                       EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                   }
               }
           },
           _ => {},
       }
   }
   #+END_SRC

3. *Struct instance storage* in ~precomp_declaration()~ (precomp.rs line 975-991, precomp.til line 1193-1206):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
   if at_global_scope && !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   if !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

**** Error When Removing All Three Checks

#+BEGIN_SRC
./bin/rstil build make.til
ERROR: src/core/array.til:41:45: rstil insert_string_into_frame ERROR:
  Str template not found - ensure str.til is imported
#+END_SRC

**** Root Cause Analysis

The issue is NOT about side effects (the "Why Fix is Safe" analysis is correct for that).
The issue is about *infrastructure availability during precompilation*:

1. *Precomp vs Eval timing*: ~precomp_expr~ runs before ~eval~. During precomp of
   function bodies, we're still in the syntactic transformation phase.

2. *Templates created during eval*: The ~EvalArena.default_instances["Str"]~ template
   is created when global Str declarations are evaluated, not during precomp.

3. *Order problem*: When precompiling ~src/core/array.til~'s function bodies (which
   contain format() calls that create Str), the Str template doesn't exist yet
   because we haven't finished evaluating global scope.

4. *Why global scope works*: At global scope, declarations are both precompiled AND
   evaluated in sequence. The Str template gets created by earlier declarations
   before later ones need it.

5. *Why function bodies fail*: Function bodies are precompiled during the module
   import phase, but not evaluated. The template infrastructure isn't available.

**** What Needs to Change

Simply removing ~at_global_scope~ doesn't work. The fix requires understanding
the precomp/eval interaction:

- *FCall folding (Location 1)*: Might work alone if ~eval_comptime~ doesn't try
  to store values that need templates. Needs investigation.

- *Primitive/Struct storage (Locations 2 & 3)*: Cannot work without templates.
  Options:
  1. Make template lookup fail gracefully (skip storage, don't error)
  2. Defer non-global storage to evaluation phase
  3. Initialize templates earlier (during precomp init?)
  4. Only fold to literals, don't store in arena for non-global

**** Files to Investigate Further

- ~src/rs/eval_arena.rs~: ~insert_string_into_frame()~, ~default_instances~ map
- ~src/rs/precomp.rs~: ~eval_comptime()~, understand what it stores vs returns
- ~src/rs/interpreter.rs~: When/how templates get initialized
- The interaction between ~precomp_expr~ -> ~eval_comptime~ -> ~EvalArena~

**** TIL Equivalents

The same changes were ported to ~src/self/precomp.til~:
- Location 1: lines 301-307 (FCall folding)
- Location 2: lines 1174-1191 (primitive storage)
- Location 3: lines 1193-1206 (struct instance storage)

The TIL syntax differs slightly (e.g., ~at_global_scope.and(...)~ instead of
~at_global_scope && ...~) but the logic is identical.

*** Tests
- tmp/test_constfold_scope.til - demonstrates the issue

** Issue #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Open
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Issue #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [-] Issue #82: make.til - Replace Makefile with TIL (partial: make.til works, go_build_yourself added, Makefile reduced to bootstrap only)
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [-] Issue #91: First-Class Functions (FunctionSig + function pointers done, closures/collections next)
- [X] Bug #92: Range loops should allow explicit iterator type annotation (Fixed 2026-01-29)
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Fixed. Variable shadowing now works via name mangling in C codegen.

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #142: Code Simplification - Context Error Helpers
:PROPERTIES:
:DISCOVERED: 2026-01-26
:IMPACT: Reduces boilerplate, improves readability
:STATUS: Open
:END:

*** Description
Add helper methods to Context struct to reduce repetitive error creation boilerplate.
Currently there are 301 calls to error methods that redundantly pass ~context.path~.

*** Current Pattern
#+BEGIN_SRC til
errors.push(e.error(context.path, "type", format("...", foo, "...")))
errors.push(e.lang_error(context.path, "type", "..."))
errors.push(e.todo_error(context.path, "type", "..."))
#+END_SRC

Every call redundantly passes ~context.path~. The error methods are defined on Expr (parser.til:443).

*** Proposed Simplification
Add Context helper methods in init.til:
#+BEGIN_SRC til
// In init.til, add to Context struct:
type_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.error(self.path, "type", msg)
}
type_lang_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.lang_error(self.path, "type", msg)
}
type_todo_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.todo_error(self.path, "type", msg)
}
#+END_SRC

*** Usage After Change
#+BEGIN_SRC til
// Before (65 chars):
errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
// After (52 chars):
errors.push(context.type_error(e, format("Undefined symbol '", name, "'")))
#+END_SRC

*** Impact Analysis
| File | Approximate calls |
|------|-------------------|
| typer.til | 89 |
| interpreter.til | 98 |
| init.til | 63 |
| others | ~50 |
| Total | ~301 |

Estimated savings: ~13 chars per call x 301 calls = ~3900 chars saved

*** Files to Modify
| File | Changes |
|------|---------|
| src/self/init.til | Add Context helper methods |
| src/rs/init.rs | Port Context helpers |
| src/self/typer.til | Use new Context helpers (~89 calls) |
| src/rs/typer.rs | Port helper usage |
| src/self/interpreter.til | Use new Context helpers (~98 calls) |
| src/rs/interpreter.rs | Port helper usage |

*** Verification
1. ~make benchmark~ - all tests pass before and after
2. Line count comparison: ~wc -l src/self/typer.til~ before/after
3. No functional changes - pure refactoring

*** Additional Opportunities (Lower Priority)

**** ccodegen push_str Chains (1438 calls)
Many consecutive ~output.push_str()~ calls could be combined with ~format()~:
#+BEGIN_SRC til
// Current:
output.push_str(indent_str)
output.push_str(c_type)
output.push_str(" ")
output.push_str(temp_var)
output.push_str(";\n")

// Potential:
output.push_str(format(indent_str, c_type, " ", temp_var, ";\n"))
#+END_SRC
This is tedious but safe - consider as follow-up work.

**** I64Range.get() Dynamic Pattern
Uses Dynamic for interface compatibility with for-in loops. By design - cannot simplify without language-level template support.

** Issue #138: Use Bool for Ptr.is_borrowed or separate BorrowedPtr type
:PROPERTIES:
:DISCOVERED: 2026-01-25
:IMPACT: Cleaner ownership semantics
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction)
:END:

*** Description
Currently ~Ptr.is_borrowed~ is ~I64~ instead of ~Bool~ because Bool causes size
alignment issues between interpreter and compiled code:
- Interpreter: Bool = 1 byte, so Ptr = 9 bytes, Str = 25 bytes
- Compiled: Bool = 1 byte + 7 padding, so Ptr = 16 bytes, Str = 32 bytes

*** Options
1. Fix interpreter's ~size_of~ to account for alignment padding
2. Use separate types: ~Ptr~ (owned) vs ~BorrowedPtr~ (borrowed)
   - Smaller size: Ptr = 8 bytes (just data) instead of 16 bytes (data + is_borrowed)
   - Type system enforces ownership at compile time
   - No runtime check needed in delete()

*** Benefits of Bool
Would allow cleaner syntax in Ptr.delete():
#+BEGIN_SRC til
if self.is_borrowed {  // instead of if self.is_borrowed.eq(1)
    self.data = NULL
    return
}
#+END_SRC

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:RESOLVED: 2026-01-30
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Resolved - Bug #97 implemented option 1 (allow full shadowing)
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (fix via name mangling), Bug #173 (Rust typer missing shadowing check)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Action Items
- [ ] Fix nested-scope shadowing bug (high priority)
- [ ] Evaluate shadowing usage in self-hosted codebase
- [ ] Choose consistent shadowing policy
- [ ] Implement in type checker
- [ ] Document decision

*** References
- Bug #65: Specific instance where shadowing caused divergence
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured → splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded → same behavior, splice
_ := declare_const(a, I64, 42)

// Captured → get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: In progress - FunctionSig type + function pointers done (2026-02-21), next: closures/collections
:RELATED: Bug #90 (semicolon/body syntax), Bug #159 (needs func ptrs for deep clone/delete), Issue #105 (First-Class Structs), Issue #106 (First-Class Enums), src/test/function_pointers.til, doc/first_class.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

TIL is now self-hosting, so the earlier concern about "post-self-hosting timing"
is resolved. Additionally, Bug #159 (shallow copy elimination) is blocked on
function pointer support for deep Vec.clone/delete -- making this a priority.

*** Core Semantics

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type declarations*: A function type is a function with no body.
   #+BEGIN_SRC til
   // Function type declaration (no body):
   BinaryOp := func(a: I64, b: I64) returns I64
   // With throws:
   Parser := func(s: Str) returns Ast throws ParseError
   #+END_SRC

3. *Throws are part of the signature*.

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures*: Functions can only reference their own parameters and globals.
   Capturing enclosing scope variables is deferred (likely harder).

6. *Return functions and store in struct fields*: Include if not too much extra
   work over the basic "pass as arguments" support.

*** Example
#+BEGIN_SRC til
// Define a function type (no body = type declaration)
BinaryOp := func(a: I64, b: I64) returns I64

// Function that takes a function as argument
apply : func(op: BinaryOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}

// Define functions matching the type
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }
mul : func(a: I64, b: I64) returns I64 = { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** Syntax Decision

**** Current approach: context-aware lookahead (no semicolons)
After parsing ~func(args) returns T throws E~, if the next token is NOT ~{~,
it is a bodyless declaration (function type or ext_func/ext_proc). If ~{~ follows,
it is a function definition with a body.

This resolves Bug #90 cleanly: ext_func/ext_proc no longer need the ugly ~{}~
empty body, and function type declarations don't need semicolons.

Examples:
#+BEGIN_SRC til
// Function type (no body, no braces needed):
BinaryOp := func(a: I64, b: I64) returns I64

// ext_func (no body, no braces needed):
single_print : ext_proc(s: Str) = {}

// Regular function (has body):
add : func(a: I64, b: I64) returns I64 = {
    return a.add(b)
}
#+END_SRC

Only "ambiguity": ~func() {}~ is always parsed as a function with empty body,
never as a type. This is the natural interpretation and harmless.

**** New unified syntax (DONE - f9af099f, fb40690b, b0badfdd, 2026-02-21)
Parser uses the unified ~name : Type = value~ syntax for functions,
as designed in doc/first_class.org. Two equivalent forms:
#+BEGIN_SRC til
// Sugar form (names in signature):
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }

// Normal form (type-only params + binding tuple):
add : func(I64, I64) returns I64 = (a, b) { return a.add(b) }
#+END_SRC
Sugar desugars to normal form in the parser; rest of pipeline only sees
normal form. Both produce the same AST (Declaration + FuncDef).

Old ~:= func(...)~ syntax is rejected with a clear error message pointing
to the new syntax. All 150+ files in the codebase converted (1650+ definitions).

**** FunctionSig type definitions (DONE - 65fd0227, 2026-02-21)
Added TFuncSig variant to TTypeDef. Function signature types use empty body
as delimiter (like ext_func):
#+BEGIN_SRC til
// Define signature type (inferred FunctionSig)
BinaryOp := func(I64, I64) returns I64 {}

// Explicit type annotation
BinaryOp : FunctionSig = func(I64, I64) returns I64 {}

// Declare function using signature + binding tuple
my_add : BinaryOp = (a, b) { return a.add(b) }
#+END_SRC
Parser detects binding-tuple-body pattern. Init, typer, and precomp resolve
arg types from signatures into declarations. Tests in src/test/function_pointers.til.

**** Function pointers (DONE - 2026-02-21)
Pass functions as arguments, call through variable, signature compatibility checking.
- Typer: accepts FuncSig as parameter type, resolves calls through function-typed parameters
- Interpreter: binds function arguments in callee frame under parameter name
- Ccodegen: emits C typedefs for FuncSig types, function pointer parameters passed by value,
  indirect calls through function pointers, function names as arguments
- Scavenger: tracks function references through FuncSig-typed arguments
- Type checking: structural signature compatibility (arg types, return types, throw types, func/proc kind)
- Tests: direct calls, cross-type compatibility, multiple function-typed params, nested higher-order,
  runtime dispatch (proc wrapper)

Next: closures, storing function pointers in collections, lambdas.

*** Existing Infrastructure (as of 2026-02-21)

What already exists:
- ~ValueType::TFunction(FunctionType)~ -- stores func/proc/macro kind
- ~SFuncDef~ struct -- full function definition (type, args, returns, throws, body)
- ~ScopeFrame.funcs~ -- HashMap<String, SFuncDef> for function lookup by name
- Parser: ~parse_func_proc_definition~ parses func/proc with body
- Typer: recognizes ~TFunction~ declarations, calls ~declare_func~
- Test file: ~src/test/function_pointers.til~

**** Reusable patterns from #105 (First-Class Structs) and #106 (First-Class Enums)

Issues #105 and #106 established patterns that directly apply to #91:

1. *Anonymous registration with temp names*: ~__anon_struct_N~ / ~__anon_enum_N~
   pattern in interpreter eval_expr. For functions, the same pattern gives
   anonymous function values: ~__anon_func_N~.

2. *Global frame registration*: Structs/enums declared inside macros are
   registered on the global frame so they survive scope pops. Function type
   declarations need the same treatment.

3. *~returns func~ in parser*: Parser already supports ~returns struct~ and
   ~returns enum~ for macros. Adding ~returns func~ follows the same pattern
   (TokenType::Func case in return type parsing).

4. *Precomp type substitution*: ~substitute_type_params_in_struct~ and
   ~substitute_type_params_in_enum~ show the pattern for substituting type
   parameters. Function signatures need the same (substitute param/return types).

5. *~value_type_func_proc~*: init.rs already handles TStructDef and TEnumDef
   as macro return types. Adding TFunction follows the same pattern.

6. *Macro-returned types with namespace*: The full pipeline (eval_comptime ->
   expand_struct_macros -> register type -> generate methods) is proven. If
   function types need associated behavior, the pattern exists.

**** What #91 adds beyond #105/#106

The key difference: structs and enums are *type definitions* (they define new
types). Functions are *values* (instances of a function signature type). This
means #91 needs:

- *Function pointer semantics in C*: Structs/enums compile to C structs. Function
  values compile to C function pointers (~typedef ret (*name)(args)~). Different
  codegen path.

- *Call-through-variable*: ~op(3, 5)~ where ~op~ is a parameter holding a function.
  Interpreter needs to resolve the function name from the variable value.
  Codegen needs to emit indirect call through pointer.

- *Signature matching*: When passing ~add~ where ~BinaryOp~ is expected, verify
  signatures match (arg types, return type, throws, func/proc kind).

What is done:
- Doc: updated first_class.org with type definition vs instantiation (b264b558)
- Parser: sugar form ~name : func(a: I64) = { body }~ (f9af099f)
- Parser: normal form ~name : func(I64) = (a) { body }~ with binding tuples (fb40690b)
- Parser: old ~:= func()~ syntax rejected, all code converted (b0badfdd)
- FunctionSig type definitions (65fd0227)
- Typer: accept FuncSig as parameter type, resolve calls through params
- Interpreter: bind function arguments in callee frame
- Ccodegen: function pointer typedefs, pointer params, indirect calls, pass functions as args
- Scavenger: track function references through FuncSig args
- Type checking: structural signature compatibility verification
- Reusable patterns from #105 (structs) and #106 (enums) documented above

What is missing:
- Closures (capturing local variables)
- Storing function pointers in collections (Vec/Map of function pointers)
- Lambda syntax
- Returning functions from functions

*** C Calling Convention (critical for codegen)

TIL's generated C calling convention is non-trivial:

| TIL Signature                     | C Signature                                          |
|-----------------------------------+------------------------------------------------------|
| func() returns I64                | til_I64 f(void)                                      |
| func(a: I64) returns I64          | til_I64 f(const til_I64* a)                          |
| func(mut a: I64) returns I64      | til_I64 f(til_I64* a)                                |
| func(copy a: I64) returns I64     | til_I64 f(til_I64 a)                                 |
| proc()                            | void f(void)                                         |
| func(a: I64) returns I64 throws E | int f(til_I64* _ret, til_E* _err1, const til_I64* a) |

Function pointer typedefs must match exactly:
#+BEGIN_SRC c
// For: BinaryOp := func(a: I64, b: I64) returns I64
typedef til_I64 (*til_BinaryOp)(const til_I64*, const til_I64*);

// For: ThrowingParser := func(s: Str) returns Ast throws ParseError
typedef int (*til_ThrowingParser)(til_Ast*, til_ParseError*, const til_Str*);
#+END_SRC

*** Implementation Plan (incremental)

**** Step 1: Parser -- bodyless function declarations
Modify ~parse_func_proc_definition~ in parser.rs/parser.til:
After parsing ~func(args) returns T throws E~, check if next token is ~{~.
If not, return a FuncDef with empty body (marks it as a type declaration).
Also apply to ext_func/ext_proc (remove the ~{}~ requirement).

Test: ~BinaryOp := func(a: I64, b: I64) returns I64~ parses without error.
Files: src/rs/parser.rs, src/self/parser.til

**** Step 2: Type system -- function types carry full signature
Option A (simpler): Function types use ~TCustom("BinaryOp")~ and the actual
SFuncDef is looked up from ~scope_stack.lookup_func("BinaryOp")~ when needed.
This piggybacks on existing infrastructure -- a function type declaration stores
an SFuncDef (with empty body) in the funcs map, and referring to "BinaryOp"
as a type just works through ~TCustom~.

Option B (proper): Extend ~ValueType::TFunction~ to carry full signature info.
More work but cleaner long-term.

Recommendation: Start with Option A. If it works for the initial feature,
defer Option B. A function type IS stored as a FuncDef -- it just happens
to have an empty body.

Files: src/rs/typer.rs, src/self/typer.til, src/rs/init.rs, src/self/init.til

**** Step 3: Interpreter -- pass functions as arguments, call through parameters
When a function-typed parameter receives an argument:
- The argument is a function name (identifier)
- Store the function name as the parameter's value (just like any string variable)
- When calling through the parameter: read the name, ~lookup_func~ by that name

The key change is in ~eval_func_proc_call~ (interpreter.rs line ~396, init.rs
line ~616): if ~lookup_func(name)~ fails AND the name is a variable holding a
function name, do ~lookup_func(variable_value)~ instead.

Test: interpreter can run ~apply(add, 3, 5)~ and get 8.
Files: src/rs/interpreter.rs, src/self/interpreter.til,
       src/rs/init.rs, src/self/init.til

**** Step 4: Ccodegen -- function pointer typedefs and calls
4a. Emit ~typedef~ for function type declarations:
    ~typedef til_I64 (*til_BinaryOp)(const til_I64*, const til_I64*);~
    Must match the exact C calling convention (see table above).

4b. Function-typed parameters emit as function pointer parameters:
    ~void til_apply(const til_I64* til_I64__ret, til_BinaryOp til_BinaryOp_op, ...)~

4c. Calls through function pointers: ~*_ret = til_BinaryOp_op(...)~ instead
    of the normal direct call.

4d. Passing a function as argument: emit as ~&til_add~ (address of the function).

Test: compiled mode can run ~apply(add, 3, 5)~ and get 8.
Files: src/rs/ccodegen.rs, src/self/ccodegen.til

**** Step 5: Type checking -- signature compatibility
Verify that when a function is passed where a type is expected, signatures match:
- Same number of args
- Compatible arg types
- Compatible return types
- Compatible throw types
- func/proc distinction respected

Files: src/rs/typer.rs, src/self/typer.til

**** Step 6: Tests
Uncomment and update ~src/test/function_pointers.til~:
- Basic: pass named function, call it
- Multiple function types
- Throwing functions as arguments
- proc vs func distinction
- Type mismatch errors (negative tests)

*** Deferred Features

- *Closures*: Capturing enclosing scope variables (likely harder)
- *Anonymous inline functions*: ~numbers.map(func(x: I64) returns I64 { return x.mul(2) })~
  Syntax already works via ~parse_func_proc_definition~ -- just needs the passing
  infrastructure from this issue. May work for free after Step 3/4.
- *Optional parameter names in types*: ~func(I64) returns I64~ (extra parser work)
- *Storing in collections*: Vec/Map of function pointers
- *Future syntax*: Move signature to type position (see Syntax Decision section)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/rs/init.rs / src/self/init.til (SFuncDef, ScopeFrame, ValueType, dispatch)
- src/test/function_pointers.til (test cases)

** Issue #178: Eliminate TTypeDef, unify type representation
:PROPERTIES:
:DISCOVERED: 2026-02-22
:IMPACT: Internal cleanup, type system simplification
:STATUS: Open
:RELATED: Issue #105 (First-Class Structs), doc/first_class.org
:END:

*** Description
Replace ~TType(TTypeDef::TStructDef)~ / ~TType(TTypeDef::TEnumDef)~ /
~TType(TTypeDef::TFuncSig)~ with ~TCustom("StructDef")~ / ~TCustom("EnumDef")~ /
~TCustom("FuncSig")~ throughout the compiler. This would eliminate the ~TTypeDef~
enum and ~ValueType::TType~ variant entirely, unifying the type representation.

*** Background
This was originally Issue #105 Step 4b. It was attempted but deferred because
TIL's switch/case desugarer does not support string literal payloads in enum case
patterns (~case ValueType.TCustom("StructDef"):~ only matches the outer TCustom
variant, ignoring the string). Every case pattern had to be converted to
~case ValueType.TCustom(name): if name.eq("StructDef") { ... }~, which is fragile.
The attempt also hit OOM issues during benchmark.

Issue #105 Step 4d's ~metatype_matches()~ provides the user-facing benefits
(explicit metatype annotations) without the internal refactor.

*** Scope
~122 Rust refs to TTypeDef, ~126 TIL refs. Mechanical replacement but requires
careful handling of TIL's switch/case limitation.

** Issue #106: First-Class Enums
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Partial
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs)
:END:

*** Description
Allow anonymous enum type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(enum {A, B})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for enums.

*** Progress (2026-02-20): Macro-returned enums with namespace support

Implemented the same macro infrastructure that Issue #105 provides for structs,
but for enums. Macro-returned enums now work with =namespace:= blocks and type
parameter substitution in variant payload types.

**** What works
- =macro(T: Type) returns enum { ... }= syntax
- Named enum pattern inside macro body (=TemplatedOption := enum { ... }=)
- Internal-to-external name substitution (=TemplatedOption= -> =I64Option=)
- Type substitution in variant payload types (=Some: T= -> =Some: I64=)
- Pattern substitution in switch-case (=case TemplatedOption.Some(val):= -> =case I64Option.Some(val):=)
- =namespace:= methods on macro-returned enums
- Auto-generated delete/clone methods
- Anonymous enum registration with =__anon_enum_N= temp names
- Global frame enum registration (survives macro function scope pops)
- =returns enum= in parser for macro return types

**** Test case: typed_option.til
Generic Option type (like Rust's =Option<T>=):
#+BEGIN_SRC til
import("std.typed_option")
I64Option := make_option(I64)
opt := I64Option.Some(42)
test(loc(), opt.is_some(), "is_some")
#+END_SRC

**** Files changed
- src/rs/interpreter.rs, src/rs/init.rs, src/rs/parser.rs, src/rs/precomp.rs, src/rs/preinit.rs
- src/self/interpreter.til, src/self/init.til, src/self/parser.til, src/self/precomp.til, src/self/preinit.til
- src/std/typed_option.til (new), src/test/macros.til

**** Completed (2026-02-21) -- enum_def_of: runtime enum introspection
- [X] 4 ext functions: ~__enum_variant_count~, ~__enum_variant_name~,
  ~__enum_variant_has_payload~, ~__enum_variant_payload_type~
- [X] Implemented in src/rs/ext.rs and ported to src/self/ext.til
- [X] Dispatch in src/rs/interpreter.rs and src/self/interpreter.til
- [X] Ext function declarations in src/std/meta.til
- [X] ~enum_def_of(type_name)~ proc in src/std/meta.til: builds SEnumDef
  on eval heap by calling ext functions
- [X] Tests in src/test/macros.til: ~count_variants~ and ~first_variant_name~
  macros that inspect enum definitions at compile time
- [X] Fix: enum declarations now marked ~is_comptime_const: true~ in precomp
  (was false, preventing enum type names from being passed to macros)
- [X] All changes ported to both Rust and TIL, all 93 tests pass

**** What remains
- Anonymous enum as inline arguments: =some_function(enum {A, B})=
- Multiple type parameters in enum macros
- Enum macros with complex payload types (structs, nested enums)


