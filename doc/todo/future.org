#+TITLE: Future Language Design Decisions
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues here use same numbering as bugs.org (from doc/todo/next_issue_num.txt)
# BOT: add them at the top of open issues, when implemented, move them to the top of implemented issues

* Overview

This document tracks long-term language design decisions that are not bugs
but need consideration. Unlike bugs.org (specific problems to fix), these
are open questions about language direction.

* Open Issues

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #110: Desugar switch to if/else in precomp
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Simplify interpreter and ccodegen, reduce internal complexity
:STATUS: Open
:RELATED: ccodegen payload hoisting, Issue #111 (enum_payload nicer with returns Dynamic)
:END:

*** Description
Remove switch as an internal construct. In precomp, desugar switch/case to
if/else chains with hoisted payload bindings (like ccodegen already does).

*** Benefits
- Interpreter doesn't need switch handling (uses precomp output)
- Ccodegen doesn't need switch handling (uses precomp output)
- One construct post-precomp (if/else), not two (if/else + switch)
- Payload hoisting logic moves from ccodegen to precomp (single place)

*** Example
Before precomp:
#+BEGIN_SRC til
switch my_enum {
    case Foo(x) { use(x) }
    case Bar(y) { use(y) }
    default { fallback() }
}
#+END_SRC

After precomp:
#+BEGIN_SRC til
if enum_to_str(my_enum).eq("MyEnum.Foo") {
    x := /* hoisted payload extraction */
    use(x)
} else if enum_to_str(my_enum).eq("MyEnum.Bar") {
    y := /* hoisted payload extraction */
    use(y)
} else {
    fallback()
}
#+END_SRC

*** Required ext_func
Need to add for payload extraction (like Vec.new takes Type):
#+BEGIN_SRC til
// With inout (works now):
enum_payload := ext_func(e: Dynamic, payload_type: Type, mut p: Dynamic) {}

// With returns Dynamic (nicer, needs Issue #111):
enum_payload := ext_func(e: Dynamic, payload_type: Type) returns Dynamic {}
#+END_SRC

*** Notes
- Gleam went the opposite direction (if/else to switch)
- We prefer switch->if/else since payload hoisting is already in ccodegen
- Just move that logic earlier (to precomp)

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open
:RELATED: Bug #65 (specific shadowing divergence)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Action Items
- [ ] Fix nested-scope shadowing bug (high priority)
- [ ] Evaluate shadowing usage in self-hosted codebase
- [ ] Choose consistent shadowing policy
- [ ] Implement in type checker
- [ ] Document decision

*** References
- Bug #65: Specific instance where shadowing caused divergence
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Open
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type, but macros
are currently executed identically to funcs at runtime. This issue tracks
implementing true compile-time macro evaluation.

*** Core Semantics

1. *Forced compile-time evaluation*: Macros are always evaluated during precomp,
   never deferred to runtime (unlike funcs which fall back to runtime if args
   aren't comptime-known)

2. *All arguments must be compile-time known*: If any argument cannot be resolved
   at compile-time, emit an error. No runtime fallback.

3. *Can call procs*: Macros have proc permissions (side effects allowed during
   compile-time evaluation). The existing typer check that prevents funcs from
   calling procs already doesn't apply to macros.

4. *Return types*: Initially limited to what's currently supported (primitives,
   struct instances). Types can be passed as arguments but not returned yet.

*** Current Constant Folding (for reference)

The existing constant folding for funcs in ~precomp_expr()~ (precomp.til:299-308):
- Only folds at global scope
- Silently skips if not comptime-evaluable (defers to runtime)
- Rejects proc calls via ~is_comptime_evaluable()~ check

Macros need different behavior:
| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

*** Implementation Steps

1. *Add ~is_macro()~ helper to SFuncDef*
   - File: src/rs/parser.rs, src/self/parser.til
   - Pattern: like ~is_proc()~ but checks ~FunctionType::FTMacro~

2. *Add macro handling in ~precomp_expr()~ FCall case*
   - File: src/rs/precomp.rs, src/self/precomp.til
   - Location: After ~precomp_fcall()~ call, before existing constant folding
   - Logic: Detect macro call, error if args not comptime, force evaluation

3. *Port to TIL*
   - Mirror all changes in src/self/*.til

4. *Add tests*
   - Basic macro returning I64/Str
   - Macro calling proc (allowed)
   - Macro with non-const arg (should error)
   - Macro inside function body (should work)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (add is_macro helper)
- src/rs/precomp.rs / src/self/precomp.til (main changes)

*** Future Extensions

Once core mechanism works, expand capabilities:
- Return Types (StructDef) for generic type generation
- Return/pass FuncDefs for function generation
- Quote/unquote syntax (~quote { $var }~) for AST building
- Full metaprogramming per doc/metaprogramming.org

*** References
- doc/metaprogramming.org: Full macro/generics design vision

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: Open
:RELATED: Bug #90 (semicolon syntax), src/test/function_pointers.til (early draft), doc/lamda.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

*** Core Semantics (Initial Implementation)

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type syntax*: Parameter names are optional in type signatures.
   #+BEGIN_SRC til
   // Both are valid:
   BinaryOp := func(a: I64, b: I64) returns I64 {};
   BinaryOp := func(I64, I64) returns I64 {};
   #+END_SRC

3. *Throws are part of the signature*:
   #+BEGIN_SRC til
   Parser := func(Str) returns Ast throws ParseError, IOError {};
   #+END_SRC

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures initially*: Functions can only reference their own parameters
   and globals. Capturing enclosing scope variables is post-self-hosting.

*** Example
#+BEGIN_SRC til
// Define a function type (needs {} until Bug #90 Step 2 is done)
BinaryOp := func(I64, I64) returns I64 {};

// Function that takes a function as argument
apply := func(op: BinaryOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}

// Define functions matching the type
add := func(a: I64, b: I64) returns I64 { return a.add(b) }
mul := func(a: I64, b: I64) returns I64 { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** What This Avoids (for now)

- *Returning functions*: Not needed initially (structs/enums can't be returned either yet)
- *Storing in collections*: Vec/Map of functions - deferred
- *Closures*: Capturing enclosing scope variables - post-self-hosting

*** Implementation Considerations

*C codegen*: Function types become C function pointer types.
#+BEGIN_SRC c
typedef til_I64 (*BinaryOp)(til_I64, til_I64);
#+END_SRC

*Interpreter*: Need to resolve function parameters to actual function
definitions and call them. Currently looks up by name - would need to handle
"this parameter holds a function reference".

*Type checking*: Verify passed function's signature matches expected type
(args, return types, throw types).

*** Timing

Consider implementing post-self-hosting:
- FuncDef size/representation is simpler when TIL can use its own structs
- Avoids rstil/til divergence
- Related: til's ccodegen needs fixes ported from Rust first

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/test/function_pointers.til (existing draft, commented out)

*** Future Extensions (post-self-hosting)

- Return functions from functions
- Store functions in collections (Vec, Map)
- Multiple return values (~x, y := some_func()~)
- Closures (capturing enclosing scope variables)

** Issue #103: Mode GUI
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, graphical applications
:STATUS: Open
:RELATED: Issue #104 (TempleOS support), src/examples/hello_gui.til (untested draft)
:END:

*** Description
Add ~mode gui~ for graphical user interface applications.

*** Backend Strategy
- *Standard platforms*: Use raylib as the graphics backend
- *TempleOS*: Native HolyC graphics (see Issue #104)
- *Web*: Options to explore:
  - raylib + wasm compilation from C
  - Separate jscodegen.til with ~mode webgui~ importing mode html files
  - Decision deferred

*** Notes
- Draft exists in src/examples/hello_gui.til (untested, won't work yet)
- Keep API simple to maintain portability across backends
- TempleOS and raylib may have more features than needed; focus on common subset

** Issue #104: TempleOS Support
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Platform support, tiny containers
:STATUS: Open
:RELATED: Issue #103 (mode gui), Bug #80, Bug #100
:END:

*** Description
Add TempleOS as a compilation target, producing HolyC instead of C.

*** Dependencies
- Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- Bug #100: Get rid of rstil (full self-hosting)

*** Implementation Options
1. *Preferred*: Add flag/option to ccodegen for HolyC output
   - HolyC is very similar to C, differences are minor
   - Avoids code duplication
2. *Alternative*: Separate holyccodegen.til
   - More work, harder to maintain

*** Motivation
- Partly for fun/flexing and, why not? Also to honor Terry's ideal language: HolyC
- Practical use: TempleOS is tiny, useful for minimal docker containers
- Integration with mode gui (Issue #103) for native TempleOS graphics

** Issue #105: First-Class Structs
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #106 (First-Class Enums)
:END:

*** Description
Allow anonymous struct type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(struct {x := 0, y := 0})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for structs.

** Issue #106: First-Class Enums
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs)
:END:

*** Description
Allow anonymous enum type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(enum {A, B})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for enums.

** Issue #107: First-Class Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous namespaces
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #108 (Implement Namespaces)
:END:

*** Description
Allow anonymous namespace definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(namespace {
    INC_VAL := 32
    f := func(a: I64) returns I64 { return a.add(INC_VAL) }
})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for namespaces.
Depends on Issue #108 (proper namespace syntax).

** Issue #108: Implement Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, code organization
:STATUS: Open
:RELATED: Issue #107 (First-Class Namespaces)
:END:

*** Current State
Structs are used as namespaces by declaring only constants (no mut).
See src/test/namespaces.til:

#+BEGIN_SRC til
MyNamespace := struct {
    field_static_str : Str = "hello MyNamespace.field_static_str"
    field_static_bool : Bool = true
    field_static_int : I64 = 42

    proc_static := proc() {
        assert_eq(loc(), 42, MyNamespace.field_static_int)
    }

    func_static_str := func() returns Str {
        return "func called"
    }
}
#+END_SRC

*** What Works
- Access static fields: ~MyNamespace.field_static_str~
- Call static functions: ~MyNamespace.func_static_str()~
- Call static procs: ~MyNamespace.proc_static()~

*** What's Missing

A. *Namespace for enums*
   Enums can't have associated functions/constants. Structs can, enums cannot.

   Example: ~clone~. Structs can define a ~clone~ method, but enums cannot:
   #+BEGIN_SRC til
   Tile := enum {
       Object: struct { name := "", pos: struct { x := 0, y := 0 } }
       Monster: SomeStructThatImplementsClone
   }
   // Currently no way to define Tile.clone(), but with namespaces:
   namespace Tile {
       clone := func(self: Tile) returns Tile { TODO("Tile.clone") }
   }
   #+END_SRC

B. *Namespace for structs*
   Currently methods are mixed inside struct definitions. A separate
   namespace keyword would clarify intent and fit better with UFCS.

   #+BEGIN_SRC til
   Str := struct { ... }
   namespace Str {
       len := func(self: Str) returns I64 { ... }
       concat := func(self: Str, other: Str) returns Str { ... }
   }
   #+END_SRC
   Internally treated the same as current struct-embedded methods.

   Can implement step A or step B first - they're independent.

C. *One namespace per type per context*
   Only one ~namespace Foo~ block allowed per type in the same context.
   Could allow spreading across multiple blocks, but no clear gain -
   only potential confusion. Keep it simple: one place for all methods.

*** Keyword Choice
Two options being considered:
- ~namespace~ - matches UFCS concept better, more descriptive
- ~impl~ - shorter, familiar to Rust developers

Example with ~namespace~:
#+BEGIN_SRC til
MyEnum := enum { A, B, C }

namespace MyEnum {
    default := func() returns MyEnum { return MyEnum.A }
    describe := func(self: MyEnum) returns Str { return "an enum" }
}

MyStruct := struct { x: I64 }

namespace MyStruct {
    new := func() returns MyStruct { return MyStruct(x=0) }
    increment := func(self: MyStruct) returns MyStruct { return MyStruct(x=self.x.add(1)) }
}
#+END_SRC

** Issue #109: Proper Imports
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Language feature, code organization, namespace control
:STATUS: Open
:RELATED: Issue #108 (Implement Namespaces)
:END:

*** Python Reference
#+BEGIN_SRC python
import os                            # import module as namespace
import os as operating_system        # import module with alias

from os import path, getcwd          # import specific items
from os import path as p             # import specific item with alias

from os import *                     # import all (discouraged)

from . import sibling                # relative imports
from .. import parent
from ..package import module
#+END_SRC

*** Current State
~import("module")~ imports everything into current namespace (like Python's ~from os import *~).

*** Priorities

A. *Namespaced imports*
   #+BEGIN_SRC til
   import("os")              // from os import *
   getcwd()                  // getcwd() - directly available
   #+END_SRC

   #+BEGIN_SRC til
   os := import("os")        // import os
   os.getcwd()               // os.getcwd()
   #+END_SRC

B. *Selective imports*
   Could save significant precomp/scavenger time by not loading everything.
   #+BEGIN_SRC til
   import("numpy", "array", "zeros")  // from numpy import array, zeros
   array()                            // array()
   zeros()                            // zeros()
   #+END_SRC
   Uses variadic arguments. Syntax may change as we cover more Python cases.

C. *Namespaced + selective (TIL-specific, no Python equivalent)*
   #+BEGIN_SRC til
   np := import("numpy", "array", "zeros")
   np.array()
   np.zeros()
   #+END_SRC
   Combines A and B: namespaced access but only selected items and their own internal dependencies, recursively, are loaded.

*** Future (lower priority)

These Python cases still need TIL equivalents:
- ~import os as operating_system~ - module alias
- ~from os import getcwd as cwd~ - item alias
- ~from . import sibling~ - relative imports (collides with current dot syntax for multiplatform, needs thought)

*** Notes
This is a multi-step issue. Priorities A and B are sufficient for now.
Final syntax may evolve as we address all Python import patterns.

* Implemented Issues

** Issue #69: Test Organization - all_common category
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Test infrastructure, rstil/til output validation
:STATUS: Implemented
:RELATED: bug50 (rstil vs til prefix mismatch)
:END:

*** Background
Tests that pass with BOTH rstil and til (with identical output) need a category
that runs all modes. Previously tests were either in ~rs_common~ (rstil only)
or ~til_interpreted~ (til only), with no way to verify identical behavior.

*** Solution Implemented
Added ~all_common~ category in tests.til that runs 4 modes:
- rs_interpreted (rstil interpret)
- rs_compiled (rstil run)
- til_interpreted (til interpret)
- til_compiled (til run)

Currently empty - ~til run~ segfaults on all tests (self-hosted compiler broken).
When ~til run~ starts working, tests can be promoted from ~rs_common~.

*** Test Categorization Strategy
- ~all_common~: Tests producing identical output across all 4 modes (currently empty)
- ~rs_common~: Tests that pass with rstil (67 tests)
- ~til_interpreted~: Tests that pass with til interpret (47 tests)
  - 46 tests are in BOTH rs_common and til_interpreted (duplicated for validation)
  - 1 test (empty.til) is til-only
- ~rs_interpreted~, ~rs_compiled~: Mode-specific tests
- Empty categories are skipped in benchmark output

*** Example: bug50
bug50.til produces ~rstil type ERROR~ vs ~til type ERROR~ (binary name in output).
It stays in ~rs_common~ until either:
1. Binary name removed from error messages, OR
2. Output normalization added to test comparison

*** Benchmark Annotations
4-phase all_common tests will show timing comparisons:
- ~(rstil: faster interpreted)~ or ~(rstil: faster compiled)~ - comparing rstil modes
- ~(interpreted: faster rstil)~ or ~(interpreted: faster til)~ - comparing interpreters
- ~(compiled: faster rstil)~ or ~(compiled: faster til)~ - comparing compilers

*** Files Modified
- src/tests.til: Added all_common Vec, processing in run_all_tests(), updated usage()
