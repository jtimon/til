#+TITLE: Future Language Design Decisions
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues here use same numbering as bugs.org (from doc/todo/next_issue_num.txt)

* Overview

This document tracks long-term language design decisions that are not bugs
but need consideration. Unlike bugs.org (specific problems to fix), these
are open questions about language direction.

* Open Issues

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open
:RELATED: Bug #65 (specific shadowing divergence)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Action Items
- [ ] Fix nested-scope shadowing bug (high priority)
- [ ] Evaluate shadowing usage in self-hosted codebase
- [ ] Choose consistent shadowing policy
- [ ] Implement in type checker
- [ ] Document decision

*** References
- Bug #65: Specific instance where shadowing caused divergence
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #69: Test Organization - all_common category
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Test infrastructure, rstil/til output validation
:STATUS: Implemented
:RELATED: bug50 (rstil vs til prefix mismatch)
:END:

*** Background
Tests that pass with BOTH rstil and til (with identical output) need a category
that runs all modes. Previously tests were either in ~rs_common~ (rstil only)
or ~til_interpreted~ (til only), with no way to verify identical behavior.

*** Solution Implemented
Added ~all_common~ category in tests.til that runs 4 modes:
- rs_interpreted (rstil interpret)
- rs_compiled (rstil run)
- til_interpreted (til interpret)
- til_compiled (til run)

Currently empty - ~til run~ segfaults on all tests (self-hosted compiler broken).
When ~til run~ starts working, tests can be promoted from ~rs_common~.

*** Test Categorization Strategy
- ~all_common~: Tests producing identical output across all 4 modes (currently empty)
- ~rs_common~: Tests that pass with rstil (67 tests)
- ~til_interpreted~: Tests that pass with til interpret (47 tests)
  - 46 tests are in BOTH rs_common and til_interpreted (duplicated for validation)
  - 1 test (empty.til) is til-only
- ~rs_interpreted~, ~rs_compiled~: Mode-specific tests
- Empty categories are skipped in benchmark output

*** Example: bug50
bug50.til produces ~rstil type ERROR~ vs ~til type ERROR~ (binary name in output).
It stays in ~rs_common~ until either:
1. Binary name removed from error messages, OR
2. Output normalization added to test comparison

*** Benchmark Annotations
4-phase all_common tests will show timing comparisons:
- ~(rstil: faster interpreted)~ or ~(rstil: faster compiled)~ - comparing rstil modes
- ~(interpreted: faster rstil)~ or ~(interpreted: faster til)~ - comparing interpreters
- ~(compiled: faster rstil)~ or ~(compiled: faster til)~ - comparing compilers

*** Files Modified
- src/tests.til: Added all_common Vec, processing in run_all_tests(), updated usage()

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Open
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type, but macros
are currently executed identically to funcs at runtime. This issue tracks
implementing true compile-time macro evaluation.

*** Core Semantics

1. *Forced compile-time evaluation*: Macros are always evaluated during precomp,
   never deferred to runtime (unlike funcs which fall back to runtime if args
   aren't comptime-known)

2. *All arguments must be compile-time known*: If any argument cannot be resolved
   at compile-time, emit an error. No runtime fallback.

3. *Can call procs*: Macros have proc permissions (side effects allowed during
   compile-time evaluation). The existing typer check that prevents funcs from
   calling procs already doesn't apply to macros.

4. *Return types*: Initially limited to what's currently supported (primitives,
   struct instances). Types can be passed as arguments but not returned yet.

*** Current Constant Folding (for reference)

The existing constant folding for funcs in ~precomp_expr()~ (precomp.til:299-308):
- Only folds at global scope
- Silently skips if not comptime-evaluable (defers to runtime)
- Rejects proc calls via ~is_comptime_evaluable()~ check

Macros need different behavior:
| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

*** Implementation Steps

1. *Add ~is_macro()~ helper to SFuncDef*
   - File: src/rs/parser.rs, src/self/parser.til
   - Pattern: like ~is_proc()~ but checks ~FunctionType::FTMacro~

2. *Add macro handling in ~precomp_expr()~ FCall case*
   - File: src/rs/precomp.rs, src/self/precomp.til
   - Location: After ~precomp_fcall()~ call, before existing constant folding
   - Logic: Detect macro call, error if args not comptime, force evaluation

3. *Port to TIL*
   - Mirror all changes in src/self/*.til

4. *Add tests*
   - Basic macro returning I64/Str
   - Macro calling proc (allowed)
   - Macro with non-const arg (should error)
   - Macro inside function body (should work)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (add is_macro helper)
- src/rs/precomp.rs / src/self/precomp.til (main changes)

*** Future Extensions

Once core mechanism works, expand capabilities:
- Return Types (StructDef) for generic type generation
- Return/pass FuncDefs for function generation
- Quote/unquote syntax (~quote { $var }~) for AST building
- Full metaprogramming per doc/metaprogramming.org

*** References
- doc/metaprogramming.org: Full macro/generics design vision

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: Open
:RELATED: Bug #90 (semicolon syntax), src/test/function_pointers.til (early draft)
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

*** Core Semantics (Initial Implementation)

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type syntax*: Parameter names are optional in type signatures.
   #+BEGIN_SRC til
   // Both are valid:
   BinaryOp := func(a: I64, b: I64) returns I64 {};
   BinaryOp := func(I64, I64) returns I64 {};
   #+END_SRC

3. *Throws are part of the signature*:
   #+BEGIN_SRC til
   Parser := func(Str) returns Ast throws ParseError, IOError {};
   #+END_SRC

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures initially*: Functions can only reference their own parameters
   and globals. Capturing enclosing scope variables is post-self-hosting.

*** Example
#+BEGIN_SRC til
// Define a function type (needs {} until Bug #90 Step 2 is done)
BinaryOp := func(I64, I64) returns I64 {};

// Function that takes a function as argument
apply := func(op: BinaryOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}

// Define functions matching the type
add := func(a: I64, b: I64) returns I64 { return a.add(b) }
mul := func(a: I64, b: I64) returns I64 { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** What This Avoids (for now)

- *Returning functions*: Not needed initially (structs/enums can't be returned either yet)
- *Storing in collections*: Vec/Map of functions - deferred
- *Closures*: Capturing enclosing scope variables - post-self-hosting

*** Implementation Considerations

*C codegen*: Function types become C function pointer types.
#+BEGIN_SRC c
typedef til_I64 (*BinaryOp)(til_I64, til_I64);
#+END_SRC

*Interpreter*: Need to resolve function parameters to actual function
definitions and call them. Currently looks up by name - would need to handle
"this parameter holds a function reference".

*Type checking*: Verify passed function's signature matches expected type
(args, return types, throw types).

*** Timing

Consider implementing post-self-hosting:
- FuncDef size/representation is simpler when TIL can use its own structs
- Avoids rstil/til divergence
- Related: til's ccodegen needs fixes ported from Rust first

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/test/function_pointers.til (existing draft, commented out)

*** Future Extensions (post-self-hosting)

- Return functions from functions
- Store functions in collections (Vec, Map)
- Multiple return values (~x, y := some_func()~)
- Closures (capturing enclosing scope variables)
