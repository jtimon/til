#+TITLE: Future Performance, Architecture, and Cleanup
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks performance improvements, architecture decisions, and
internal cleanup work. For language features (new syntax, operators, etc.),
see features.org. For bugs, see bugs.org.

* Open Issues

** Issue #201: Bang operator catch deduplication -- one catch per function, not per call
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Code size / performance -- reduces generated catch block count
:STATUS: Open
:RELATED: Issue #180 (bang operator), Issue #199 (codebase cleanup with !)
:END:

*** Description

Currently the desugarer generates a catch block for each ~!~ call:

#+BEGIN_SRC til
// Two ! calls generate two catch blocks each:
a := foo()!
b := bar()!

// Desugars to:
a := foo()?
catch (_bang_err_0: FooError) { panic(loc(), _bang_err_0.msg) }
b := bar()?
catch (_bang_err_1: BarError) { panic(loc(), _bang_err_1.msg) }
#+END_SRC

Since all bang catches do the same thing (panic), they could be deduplicated
into a single catch per error type at the end of the function:

#+BEGIN_SRC til
a := foo()?
b := bar()?
// One combined catch block at function end:
catch (_bang_err: FooError) { panic(loc(), _bang_err.msg) }
catch (_bang_err: BarError) { panic(loc(), _bang_err.msg) }
#+END_SRC

This reduces generated code size, especially in functions with many ~!~ calls.

** Issue #194: make.til flag forwarding to tests
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Usability -- enable ./bin/rs/make benchmark --rust-only
:STATUS: Open -- reverted, needs investigation
:RELATED: b0730483 (reverted in c6e18eac)
:END:

*** Description

Forward extra CLI flags (--rust-only, -jN, --mem-report) from make.til
to the tests binary. Commit b0730483 implemented this by collecting
non-target, non---cc= args into a ~g_extra_flags~ global string and
appending it to the ~./bin/rs/tests~ command.

*** Problem

The commit caused OOM during ~./bin/rstil build src/tests.til~ under the
70G systemd memory limit. The build step itself only uses ~10MB standalone,
but under the systemd scope with the flag-forwarding code present, it
consistently failed with ~Ptr.new_by_size: malloc failed~. Reverting the
flag-forwarding changes fixed the OOM. Root cause is unknown -- the
flag-forwarding code only affects how tests are *run*, not how they are
*built*. The compiled make.til binary itself may be larger or trigger
different memory behavior in the cgroup.

*** TODO

- Investigate why the flag-forwarding code causes OOM during build
- Re-implement with minimal changes once root cause is understood
- Makefile can't forward flags easily ($(MAKECMDGOALS) only passes targets)
- Workaround: use ~./bin/rs/make benchmark --rust-only~ once fixed

** Issue #189: Replace Assignment NodeType with ext_func call
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Uniformity -- fewer NodeTypes in the AST
:STATUS: Open -- idea stage, likely not worth it
:RELATED: Issue #190 (Declaration as ext_func)
:END:

*** Description

Instead of ~NodeType.Assignment(name)~, assignment could be modeled as
~ext_func(Type, mut dest, src)~ -- a regular FCall with an external function.
This would remove a special NodeType and treat assignment like any other operation.

*** Potential disadvantages

1. *Assignment is fundamental* -- it's one of the most frequent operations.
   Having its own NodeType lets every compiler phase pattern-match directly
   (~case NodeType.Assignment(name):~). As an FCall, every phase would need to
   inspect the FCall, check if it's the special "assignment" ext_func, extract
   dest/src -- more code and more fragile.

2. *Assignment has special semantics* -- the dest is not evaluated the same way
   as a normal argument. ~x = 5~ means "write to x's location", not "pass x's
   value". An ext_func call would naturally evaluate both args, but assignment
   needs lvalue semantics on the left side. Special-casing would still be needed.

3. *The garbager and typer already understand Assignment* -- they pattern-match
   on it for clone insertion, type checking, etc. Refactoring to use a generic
   FCall dispatch would be a large change for no functional gain.

4. *Readability* -- ~NodeType.Assignment("x")~ is self-documenting.
   ~NodeType.FCall~ with a magic "assignment" identifier is not.

** Issue #190: Replace Declaration NodeType with ext_func call
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Uniformity -- fewer NodeTypes in the AST
:STATUS: Open -- idea stage, likely not worth it
:RELATED: Issue #189 (Assignment as ext_func)
:END:

*** Description

Same idea as #189 but for declarations. Instead of ~NodeType.Declaration(decl)~,
declaration could be modeled as an ~ext_func~ or ~ext_proc~ call that binds a
name to a value in the current scope.

*** Potential disadvantages

1. *Declarations carry rich metadata* -- the ~Declaration~ struct has name,
   value_type, is_mut, is_copy, is_own, default_value. Encoding all of this
   in an FCall's parameters would be awkward and lose type safety.

2. *Declarations are structural, not operational* -- they define what exists in
   a scope, not what to execute. The parser, typer, interpreter, and ccodegen
   all treat declarations as scope-building constructs. Modeling them as function
   calls conflates definition with execution.

3. *Scope registration happens at declaration time* -- the typer and interpreter
   register symbols when they see a Declaration. An FCall would need to be
   recognized as "actually a declaration" before the same registration can happen,
   adding indirection for no benefit.

4. *Every compiler phase pattern-matches on Declaration* -- parser builds them,
   typer validates them, interpreter evaluates them, ccodegen emits them. All
   would need refactoring to extract declaration info from FCall parameters.

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Issue #152: Migrate doc/todo files to numbered issue system
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Documentation cleanup, better tracking
:STATUS: Open
:END:

*** Description
Several doc/todo files use older TODO/checklist systems instead of the numbered
issue tracking system. These should be reviewed and migrated.

*** Files Using Numbered System (done)
- bugs.org - Bug #N format
- future.org - Issue #N format
- post.org - Issue #N format
- os.org - Issue #N format
- optimizations.org - Optimization #N format

*** Files to Migrate

**** post_old.org (31KB) - partial extraction done
Remaining items to extract or delete:
- List/Tuple support
- Negative number literals
- Guards for pattern matching
- Default keyword for switch
- Struct literals
- Cast operations
- Operator overloading
- Type checking edge cases
- safe_script mode
- pure mode
- Performance optimizations
- Memory management
- Better error messages
- Code quality improvements
- Memory error handling
- More test cases
- Improve documentation
- Other number types
- Unset default values in structs
- Better import caching

Likely duplicates to verify:
- Closures -> Issue #91 (First-Class Functions)
- Macros -> Issue #88 (Macro Support)
- Error handling -> Bug #98 (ext_proc error types) - FIXED
- Code quality -> Issue #142 (Context Error Helpers)

**** wish.org (1.6KB) - wishlist/checklist
- Forbidden keywords with helpful error messages
- Dynamic error messages with user identifiers

**** clone.org (6.3KB) - task tracker
- 368 missing .clone() calls to port from Rust to TIL
- 6/14 files done

**** introspection.org (6.4KB) - design doc
- Runtime introspection system design
- has_const/has_field implemented, more TODO

**** special.org (8.6KB) - technical debt catalog
- Catalog of Rust special cases for primitive types
- Reference doc, may not need issues

**** mandatory.org (7.8KB) - completed feature
- clone/len/size requirements - all phases complete
- Could be moved to doc/ as reference

**** pre.org - DONE (migrated to fixed.org as #pre, file deleted)

**** pass_by_ref.org - DONE (content already in doc/ownership.org, file deleted)

**** 108.org (11.8KB) - deep dive doc
- Detailed design for Issue #108 (Namespaces)
- Supplement to future.org entry

**** Obsolete files (can delete)
- shadow.org (3KB) - obsolete plan, Bug #65 already fixed
- byref_plan.org, byref-params-plan.md - likely obsolete
- attempt_const.org - likely obsolete attempt
- wip_offsets.org - likely obsolete WIP
- scope.org, scope_refactor_prep.md - likely obsolete
- precomp_overhaul.org - likely obsolete

**** Unchecked files
- dry.org (21KB)
- techdebt.org (22.8KB)
- self_hosting.org (24KB)
- self.md (15KB)

*** After Migration
Delete or archive files once content is properly tracked in numbered issues.

** Bug #169: Get rid of memcmp
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic correctness -- memcmp compares raw bytes (pointers, padding) not logical values
:STATUS: Step 1 done (pure TIL memcmp). Steps 2-4 blocked by Dynamic having no type dispatch.
:RELATED: Bug #166 (container type info duplication, memcmp elem_size=0 breakage)
:END:

*** Problem
Containers (Vec, Set, Map, HashMap) use ~memcmp~ to compare elements. This
compares raw struct bytes -- meaning pointer values, padding bytes, and all.
Two structs with identical logical content but different pointer addresses
(e.g. two Str with same text but different allocations) will compare as
NOT equal. Creates interpreted/compiled divergence.

*** Current usage (as of 2026-02-20)
7 call sites in production code, all in containers:
- set.til (3): insert, remove, contains -- element comparison
- vec.til (2): _is_str_type (type tag check) + contains (element comparison)
- map.til (1): key comparison for non-Str keys
- hashmap.til (1): key comparison for non-Str keys
All containers already special-case Str (using Str.eq()). memcmp is the
fallback for all other types. Works correctly for value types (I64, U8, Bool)
since their raw bytes ARE the value. Broken for any struct with heap pointers.

*** Blocker
Containers hold ~Dynamic~ parameters and use ~elem_type~ (a string) to know
the type. They already special-case Str. Could extend the pattern to dispatch
.eq() for other types, but that's a lot of per-type boilerplate. In practice
memcmp works for value types (I64, U8, Bool) which are the common case.
The real problem is only for struct types with heap pointers as container
elements, which is rare.

*** Plan
- Step 1: Replace ext_func memcmp with pure TIL implementation (DONE)
  Removed C/Rust/TIL-interpreter implementations. memcmp is now a regular
  TIL function in mem.til using byte-by-byte comparison via memcpy+to_ptr.
- Step 2: Extend elem_type dispatch to cover more types if needed
- Step 3: Remove memcmp entirely (or keep for low-level use only)

** Issue #186: Symbol tracking performance -- is_consumed flag, is_used on SymbolInfo
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Performance, correctness, and better error messages
:STATUS: Open
:RELATED: Issue #185 (own at call sites), Bug #101 (unused variable warnings), Issue #117 (ASAP destruction)
:END:

*** Current state (Rust analysis)

**** Unused variable tracking (Bug #101)

~used_symbols~ is a ~HashSet<String>~ on ~ScopeStack~ (function-level, not
per-symbol). Every identifier reference calls ~mark_symbol_used(name)~ which
does ~self.used_symbols.insert(name.to_string())~ -- a string allocation + hash
+ insert for every single identifier use in the program.

At function exit, ~get_unused_symbols()~ iterates ~function_locals~ Vec and
checks each name against the HashSet. The ~function_locals~ Vec itself uses
linear search for deduplication (~is_already_processed~ scans the whole Vec).

Location: ~src/rs/init.rs:101~ (~used_symbols~), ~src/rs/init.rs:160~
(~mark_symbol_used~), ~src/rs/init.rs:166~ (~get_unused_symbols~),
~src/rs/typer.rs:270~ (call site), ~src/rs/typer.rs:1094~ (unused check).

**** Own-consumed variable tracking (Issue #117)

When a variable is passed to an ~own~ parameter, the typer calls
~remove_symbol(var_name)~ (~src/rs/typer.rs:880~) which physically removes
the symbol from the scope frame's HashMap. If ~removal_tracking_depth > 0~,
it also logs the removal in ~removed_log: Vec<RemovedSymbol>~.

The removal tracking exists because Bug #162 found that ~check_body_returns_throws~
re-walks the AST for UFCS resolution and needs the consumed symbols back.
So the typer saves/drains/restores consumed symbols around the two walks
(~src/rs/typer.rs:1047-1054~).

This means every own-consumption triggers:
1. HashMap remove
2. Vec push (if tracking)
3. Vec split_off (drain)
4. Vec iteration + HashMap re-insert (restore)

All for what could be a single boolean flag on the symbol.

*** Proposed improvement: flags on SymbolInfo

Instead of removing symbols and tracking them separately, add flags directly
to ~SymbolInfo~:

#+BEGIN_SRC rust
pub struct SymbolInfo {
    pub value_type: ValueType,
    pub is_mut: bool,
    pub is_copy: bool,
    pub is_own: bool,
    pub is_comptime_const: bool,
    // NEW:
    pub is_consumed: bool,       // ownership was transferred
    pub consumed_by: String,     // which function consumed it (for error msg)
    pub consumed_line: i64,      // where (for error msg)
    pub consumed_col: i64,       // where (for error msg)
    pub is_used: bool,           // variable was referenced at least once
}
#+END_SRC

Benefits:
- ~is_consumed~: No HashMap remove/re-insert cycle. Just set a flag. The
  "Undefined symbol" check becomes: "is symbol absent? -> undefined. is symbol
  consumed? -> ownership transferred error. otherwise -> valid."
- ~is_used~: No separate HashSet. Just set a flag on lookup. ~get_unused_symbols~
  iterates symbols in scope and checks the flag. Saves all the string allocations
  from ~mark_symbol_used~.
- Eliminates ~removed_log~, ~removal_tracking_depth~, ~begin/end_removal_tracking~,
  ~drain_removals_since~, ~restore_removed~ -- all replaced by a single flag that
  can be set/unset.
- The save/restore dance in ~check_func_proc_types~ becomes: save consumed state,
  clear flags, walk, restore flags.

*** Performance impact

Every identifier use currently does: ~used_symbols.insert(name.to_string())~
= 1 heap allocation + hash computation + HashSet insert. With ~is_used~ on
SymbolInfo: ~lookup_symbol(name)~ already happens, just set a bool on the
result. Zero extra allocations.

Every own-transfer currently does: HashMap remove + conditional Vec push +
later Vec split_off + HashMap re-inserts. With ~is_consumed~ on SymbolInfo:
set 4 fields on the already-looked-up symbol. Zero extra allocations.

For TIL (compiled C), the difference is even larger because Map/Set operations
involve dynamic dispatch through the eval heap.

*** Implementation notes

- ~has_symbol~ must return false for consumed symbols (or add ~has_live_symbol~)
  so existing "Undefined symbol" paths still trigger
- ~lookup_symbol~ should still find consumed symbols so the error path can
  read ~consumed_by~ / ~consumed_line~
- Need ~lookup_symbol_any~ (finds consumed too) vs ~lookup_symbol~ (skips consumed)
  OR keep one ~lookup_symbol~ and check ~is_consumed~ at each call site
- The typer's save/restore for Bug #162 becomes: snapshot consumed flags before
  first walk, restore after (instead of the remove/log/drain/restore cycle)
- ~is_used~ replaces the entire ~used_symbols: HashSet<String>~ field on ScopeStack
- ~function_locals~ Vec is still needed for shadowing detection (it tracks
  declaration locations, not just names)


** Issue #142: Code Simplification - Context Error Helpers
:PROPERTIES:
:DISCOVERED: 2026-01-26
:IMPACT: Reduces boilerplate, improves readability
:STATUS: Open
:END:

*** Description
Add helper methods to Context struct to reduce repetitive error creation boilerplate.
Currently there are 301 calls to error methods that redundantly pass ~context.path~.

*** Current Pattern
#+BEGIN_SRC til
errors.push(e.error(context.path, "type", format("...", foo, "...")))
errors.push(e.lang_error(context.path, "type", "..."))
errors.push(e.todo_error(context.path, "type", "..."))
#+END_SRC

Every call redundantly passes ~context.path~. The error methods are defined on Expr (parser.til:443).

*** Proposed Simplification
Add Context helper methods in init.til:
#+BEGIN_SRC til
// In init.til, add to Context struct:
type_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.error(self.path, "type", msg)
}
type_lang_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.lang_error(self.path, "type", msg)
}
type_todo_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.todo_error(self.path, "type", msg)
}
#+END_SRC

*** Usage After Change
#+BEGIN_SRC til
// Before (65 chars):
errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
// After (52 chars):
errors.push(context.type_error(e, format("Undefined symbol '", name, "'")))
#+END_SRC

*** Impact Analysis
| File | Approximate calls |
|------|-------------------|
| typer.til | 89 |
| interpreter.til | 98 |
| init.til | 63 |
| others | ~50 |
| Total | ~301 |

Estimated savings: ~13 chars per call x 301 calls = ~3900 chars saved

*** Files to Modify
| File | Changes |
|------|---------|
| src/self/init.til | Add Context helper methods |
| src/rs/init.rs | Port Context helpers |
| src/self/typer.til | Use new Context helpers (~89 calls) |
| src/rs/typer.rs | Port helper usage |
| src/self/interpreter.til | Use new Context helpers (~98 calls) |
| src/rs/interpreter.rs | Port helper usage |

*** Verification
1. ~make benchmark~ - all tests pass before and after
2. Line count comparison: ~wc -l src/self/typer.til~ before/after
3. No functional changes - pure refactoring

*** Additional Opportunities (Lower Priority)

**** ccodegen push_str Chains (1438 calls)
Many consecutive ~output.push_str()~ calls could be combined with ~format()~:
#+BEGIN_SRC til
// Current:
output.push_str(indent_str)
output.push_str(c_type)
output.push_str(" ")
output.push_str(temp_var)
output.push_str(";\n")

// Potential:
output.push_str(format(indent_str, c_type, " ", temp_var, ";\n"))
#+END_SRC
This is tedious but safe - consider as follow-up work.

**** I64Range.get() Dynamic Pattern
Uses Dynamic for interface compatibility with for-in loops. By design - cannot simplify without language-level template support.

** Issue #138: Use Bool for Ptr.is_borrowed or separate BorrowedPtr type
:PROPERTIES:
:DISCOVERED: 2026-01-25
:IMPACT: Cleaner ownership semantics
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction)
:END:

*** Description
Currently ~Ptr.is_borrowed~ is ~I64~ instead of ~Bool~ because Bool causes size
alignment issues between interpreter and compiled code:
- Interpreter: Bool = 1 byte, so Ptr = 9 bytes, Str = 25 bytes
- Compiled: Bool = 1 byte + 7 padding, so Ptr = 16 bytes, Str = 32 bytes

*** Options
1. Fix interpreter's ~size_of~ to account for alignment padding
2. Use separate types: ~Ptr~ (owned) vs ~BorrowedPtr~ (borrowed)
   - Smaller size: Ptr = 8 bytes (just data) instead of 16 bytes (data + is_borrowed)
   - Type system enforces ownership at compile time
   - No runtime check needed in delete()

*** Benefits of Bool
Would allow cleaner syntax in Ptr.delete():
#+BEGIN_SRC til
if self.is_borrowed {  // instead of if self.is_borrowed.eq(1)
    self.data = NULL
    return
}
#+END_SRC

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:RESOLVED: 2026-01-30
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open - shadowing check is too strict, needs scope-awareness (2026-02-23)
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (fix via name mangling), Bug #173 (Rust typer missing shadowing check)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Problem: shadowing check is too strict (2026-02-23)

The current check in ~typer.rs:check_declaration~ (Bug #97) uses ~function_locals~
which is function-wide -- it tracks ALL declarations across the entire function body,
regardless of scope. This means variables in separate scopes can't reuse names:

#+begin_src til
// FAILS: "Variable 'i' already declared in this function (shadowing not allowed)"
test := func() returns I64 = {
    mut sum := 0
    for i in 0..3 { sum = sum.add(i) }
    for i in 10..13 { sum = sum.add(i) }   // ERROR: 'i' already declared
    return sum
}
#+end_src

Range-for loops desugar to ~Body { mut i := start; while ... }~ (parser.rs:1504).
Both Body blocks are at function scope level from the typer's perspective since
~function_locals~ ignores scope nesting.

For-in loops DON'T have this problem because the user's variable is declared via
~cast()~ inside the while body, and ~cast~ declarations are created with the ForIn
node's line/col. The internal variables (~_for_i_funcname_N~, ~_ref_forin_N~) use
unique generated names.

*Minimum fix*: the shadowing check should respect scope boundaries (Body blocks).
Re-declaration in a sibling or nested scope is fine -- C itself handles this with
block scoping (~{}~), so no codegen issues. The ~is_shadowing_in_function~ check
needs scope tracking, or alternatively, the typer should push/pop the ~function_locals~
set when entering/leaving Body nodes.

Further relaxation (same-scope shadowing, type-change shadowing) can be decided later.

*** Action Items
- [ ] Make shadowing check scope-aware (at minimum, separate Body blocks)
- [ ] Decide on further relaxation (same-scope shadowing, type-change shadowing)
- [ ] Document final policy

*** References
- Bug #65: Specific instance where shadowing caused divergence
- Bug #97: Introduced the function-wide shadowing check
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #178: Eliminate TTypeDef, unify type representation
:PROPERTIES:
:DISCOVERED: 2026-02-22
:IMPACT: Internal cleanup, type system simplification
:STATUS: Open
:RELATED: Issue #105 (First-Class Structs), doc/first_class.org
:END:

*** Description
Replace ~TType(TTypeDef::TStructDef)~ / ~TType(TTypeDef::TEnumDef)~ /
~TType(TTypeDef::TFuncSig)~ with ~TCustom("StructDef")~ / ~TCustom("EnumDef")~ /
~TCustom("FuncSig")~ throughout the compiler. This would eliminate the ~TTypeDef~
enum and ~ValueType::TType~ variant entirely, unifying the type representation.

*** Background
This was originally Issue #105 Step 4b. It was attempted but deferred because
TIL's switch/case desugarer does not support string literal payloads in enum case
patterns (~case ValueType.TCustom("StructDef"):~ only matches the outer TCustom
variant, ignoring the string). Every case pattern had to be converted to
~case ValueType.TCustom(name): if name.eq("StructDef") { ... }~, which is fragile.
The attempt also hit OOM issues during benchmark.

Issue #105 Step 4d's ~metatype_matches()~ provides the user-facing benefits
(explicit metatype annotations) without the internal refactor.

*** Scope
~122 Rust refs to TTypeDef, ~126 TIL refs. Mechanical replacement but requires
careful handling of TIL's switch/case limitation.


