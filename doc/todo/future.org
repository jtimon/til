#+TITLE: Future Performance, Architecture, and Cleanup
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks performance improvements, architecture decisions, and
internal cleanup work. For language features (new syntax, operators, etc.),
see features.org. For bugs, see bugs.org.

* Open Issues

** Issue #186: Symbol tracking performance -- is_consumed flag, is_used on SymbolInfo
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Performance, correctness, and better error messages
:STATUS: Open
:RELATED: Issue #185 (own at call sites), Bug #101 (unused variable warnings), Issue #117 (ASAP destruction)
:END:

*** Current state (Rust analysis)

**** Unused variable tracking (Bug #101)

~used_symbols~ is a ~HashSet<String>~ on ~ScopeStack~ (function-level, not
per-symbol). Every identifier reference calls ~mark_symbol_used(name)~ which
does ~self.used_symbols.insert(name.to_string())~ -- a string allocation + hash
+ insert for every single identifier use in the program.

At function exit, ~get_unused_symbols()~ iterates ~function_locals~ Vec and
checks each name against the HashSet. The ~function_locals~ Vec itself uses
linear search for deduplication (~is_already_processed~ scans the whole Vec).

Location: ~src/rs/init.rs:101~ (~used_symbols~), ~src/rs/init.rs:160~
(~mark_symbol_used~), ~src/rs/init.rs:166~ (~get_unused_symbols~),
~src/rs/typer.rs:270~ (call site), ~src/rs/typer.rs:1094~ (unused check).

**** Own-consumed variable tracking (Issue #117)

When a variable is passed to an ~own~ parameter, the typer calls
~remove_symbol(var_name)~ (~src/rs/typer.rs:880~) which physically removes
the symbol from the scope frame's HashMap. If ~removal_tracking_depth > 0~,
it also logs the removal in ~removed_log: Vec<RemovedSymbol>~.

The removal tracking exists because Bug #162 found that ~check_body_returns_throws~
re-walks the AST for UFCS resolution and needs the consumed symbols back.
So the typer saves/drains/restores consumed symbols around the two walks
(~src/rs/typer.rs:1047-1054~).

This means every own-consumption triggers:
1. HashMap remove
2. Vec push (if tracking)
3. Vec split_off (drain)
4. Vec iteration + HashMap re-insert (restore)

All for what could be a single boolean flag on the symbol.

*** Proposed improvement: flags on SymbolInfo

Instead of removing symbols and tracking them separately, add flags directly
to ~SymbolInfo~:

#+BEGIN_SRC rust
pub struct SymbolInfo {
    pub value_type: ValueType,
    pub is_mut: bool,
    pub is_copy: bool,
    pub is_own: bool,
    pub is_comptime_const: bool,
    // NEW:
    pub is_consumed: bool,       // ownership was transferred
    pub consumed_by: String,     // which function consumed it (for error msg)
    pub consumed_line: i64,      // where (for error msg)
    pub consumed_col: i64,       // where (for error msg)
    pub is_used: bool,           // variable was referenced at least once
}
#+END_SRC

Benefits:
- ~is_consumed~: No HashMap remove/re-insert cycle. Just set a flag. The
  "Undefined symbol" check becomes: "is symbol absent? -> undefined. is symbol
  consumed? -> ownership transferred error. otherwise -> valid."
- ~is_used~: No separate HashSet. Just set a flag on lookup. ~get_unused_symbols~
  iterates symbols in scope and checks the flag. Saves all the string allocations
  from ~mark_symbol_used~.
- Eliminates ~removed_log~, ~removal_tracking_depth~, ~begin/end_removal_tracking~,
  ~drain_removals_since~, ~restore_removed~ -- all replaced by a single flag that
  can be set/unset.
- The save/restore dance in ~check_func_proc_types~ becomes: save consumed state,
  clear flags, walk, restore flags.

*** Performance impact

Every identifier use currently does: ~used_symbols.insert(name.to_string())~
= 1 heap allocation + hash computation + HashSet insert. With ~is_used~ on
SymbolInfo: ~lookup_symbol(name)~ already happens, just set a bool on the
result. Zero extra allocations.

Every own-transfer currently does: HashMap remove + conditional Vec push +
later Vec split_off + HashMap re-inserts. With ~is_consumed~ on SymbolInfo:
set 4 fields on the already-looked-up symbol. Zero extra allocations.

For TIL (compiled C), the difference is even larger because Map/Set operations
involve dynamic dispatch through the eval heap.

*** Implementation notes

- ~has_symbol~ must return false for consumed symbols (or add ~has_live_symbol~)
  so existing "Undefined symbol" paths still trigger
- ~lookup_symbol~ should still find consumed symbols so the error path can
  read ~consumed_by~ / ~consumed_line~
- Need ~lookup_symbol_any~ (finds consumed too) vs ~lookup_symbol~ (skips consumed)
  OR keep one ~lookup_symbol~ and check ~is_consumed~ at each call site
- The typer's save/restore for Bug #162 becomes: snapshot consumed flags before
  first walk, restore after (instead of the remove/log/drain/restore cycle)
- ~is_used~ replaces the entire ~used_symbols: HashSet<String>~ field on ScopeStack
- ~function_locals~ Vec is still needed for shadowing detection (it tracks
  declaration locations, not just names)

** Issue #167: Benchmark HashMap vs Map (OrderedMap) in Rust and TIL
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Performance - understand when HashMap is actually faster
:STATUS: Open
:RELATED: Issue #112 (HashMap implementation), Bug #166 (container dedup)
:END:

*** Summary
Systematically benchmark HashMap vs Map to understand when each wins.

In Rust, the codebase used ~HashMap~ (std) everywhere until ~OrderedMap~ was
introduced. In TIL, everything uses ~Map~ (sorted, O(log n) binary search).
TIL has a ~HashMap~ implementation (Issue #112) but it was slower than Map in
the two cases tested (small maps, ScopeFrame maps).

The question: is HashMap ever faster, and if so, does that advantage translate
to TIL?

*** Plan
1. In Rust: identify use cases where HashMap should win (large N, frequent
   lookup, no ordering needed). Benchmark HashMap vs OrderedMap for each.
2. For cases where HashMap wins in Rust, try the same in TIL. See if TIL's
   HashMap also wins, or if TIL's overhead negates the algorithmic advantage.
3. Document results:
   - If HashMap wins for some cases in both Rust and TIL: use HashMap there
   - If HashMap wins in Rust but not TIL: document the gap, investigate why
   - If Map/OrderedMap wins everywhere: validates TIL's design choice of Map
     as the shorter/default name. Document this.

*** Context
- Rust: ~HashMap~ (std, highly optimized SwissTable) vs ~OrderedMap~ (custom, sorted)
- TIL: ~Map~ (sorted, binary search) vs ~HashMap~ (first attempt, separate chaining)
- Only Map (TIL) and OrderedMap (Rust) are maintained equivalents by design.
  TIL's HashMap is a first attempt and likely far less optimized than Rust's
  std HashMap (which uses SwissTable/hashbrown). If HashMap wins in Rust but
  loses in TIL, the fault may be in TIL's naive HashMap implementation, not
  in the concept of hashing itself.
- Issue #112 showed TIL HashMap 81% slower for ScopeFrame maps (til interpreted)
  and 5-6% slower for small maps. But those were specific cases -- larger
  collections with pure lookup workloads may differ.
- For cases with few elements, the simpler sorted approach may win due to
  cache locality and lower overhead. This is expected and would reinforce
  TIL's choice of ~Map~ as the primary/shorter name.

** Issue #112: Add HashMap type with O(1) lookup
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Performance - self-hosted interpreter 2.7x slower than Rust
:STATUS: Blocked - TIL HashMap implementation too slow
:END:

*** Summary
Created HashMap type with O(1) average lookup, but it's actually slower than
the existing Map in TIL due to implementation overhead.

*** What Was Done
- Created ~HashMap~ type in ~src/std/hashmap.til~
- Uses ~Str.hash()~ (FNV-1a) for string keys, FNV-1a on raw bytes for others
- Separate chaining collision handling, power-of-2 buckets, 0.75 load factor
- Same API as Map (get, set, insert, contains_key, remove, etc.)
- Added 15 HashMap tests to ~src/test/maps.til~

*** Attempts to Use HashMap - Both Failed

**** Attempt 1: default_values and named_values
Result: 5-6% slower (small maps, overhead exceeds benefit)

**** Attempt 2: ScopeFrame maps (arena_index, symbols, funcs, enums, structs)
Result: 81% slower (TIL HashMap implementation has too much overhead)

| Metric          | Before   | After    | Change       |
|-----------------+----------+----------+--------------|
| til interpreted | 354.153s | 641.957s | +81% slower  |
| til compiled    | 14.441s  | 16.423s  | +14% slower  |

*** Root Cause
TIL HashMap overhead is too high:
- Hash computation via memcpy for non-Str keys
- Bucket indirection and chain traversal
- Key comparison via memcpy
- These costs exceed O(n) linear scan benefit even for larger maps

*** Possible Future Approaches
- Consider using OrderedMap instead of HashMap in Rust itself
- Optimize TIL HashMap (inline hash functions, avoid memcpy)
- Profile to identify actual bottleneck
- Accept interpreted TIL is slower, focus on compiled performance

** Issue #89: Constant folding only works at global scope
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Performance, macro implementation
:STATUS: Open
:END:

*** Description
Pure function calls with all compile-time known arguments are only constant
folded at global scope. Inside function bodies, they are not folded even when
all arguments are literals.

*** Example
#+BEGIN_SRC til
double := func(x: I64) returns I64 { return x.mul(2) }

// Global scope - folded to literal 10
global_result := double(5)

test := proc() {
    // Inside function - NOT folded, calls double() at runtime
    inner_result := double(10)
}
#+END_SRC

Generated C shows:
- ~til_global_result = 10~ (folded)
- ~til_inner_result = til_double(...)~ (not folded)

*** Location
~precomp_expr()~ in src/rs/precomp.rs / src/self/precomp.til has:
#+BEGIN_SRC til
at_global_scope := context.scope_stack.frames.len().eq(1)
if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
    const_folded = eval_comptime(context, const_folded)
}
#+END_SRC

The ~at_global_scope~ check should be removed.

*** Impact on Issue #88 (Macros)
This issue blocks proper macro implementation. Macros should be evaluated at
compile time regardless of where they are called.

*** Why the Fix is Safe

The ~at_global_scope~ check was added for Bug #41 to prevent double output from
functions with side effects. However, this is overly conservative because:

1. *~is_proc()~ correctly identifies side effects*: The type system guarantees
   that ~func~ cannot call ~proc~ (enforced by typer). Only ~proc~ can call
   ~ext_proc~, which is where actual side effects (I/O, memory allocation) live.

2. *Trust the type system*: If ~is_proc()~ returns false, the function is pure.
   The ~is_comptime_evaluable()~ check already calls ~is_proc()~ and rejects
   procs from folding.

3. *liba/pura exception is a debugging hack*: These modes allow ~func~ to call
   ~println~ as a convenience for debugging pure/lib code. If such funcs get
   evaluated twice (once at compile-time, once at runtime), that's an acceptable
   consequence of using the debugging modes.

4. *User responsibility*: If someone declares an ~ext_func~ that actually has
   side effects (instead of ~ext_proc~), that's the user's or mode designer's
   fault. The type system is correct; misuse is not our problem.

*** Future Enhancement
Add warnings when ~proc~ is used but ~func~ would suffice. Using ~proc~
unnecessarily causes a cascade effect - anything calling it must also be ~proc~
or in a special mode. This means users miss constant folding optimizations for
entire call chains.

*** Implementation Attempt (2026-01-07)

Tried removing ~at_global_scope~ checks from three locations. Result: build fails.

**** Three Locations with at_global_scope Check

1. *FCall folding* in ~precomp_expr()~ (precomp.rs line 229-235, precomp.til line 301-307):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // Only fold at global scope - inside function definitions, values from other
   // modules may not be available yet (import ordering). Interpreter doesn't
   // evaluate function bodies during import either.
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope && is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects
   // via the type system (func cannot call proc, only proc can call ext_proc).
   if is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

2. *Primitive storage* (I64/U8/Str) in ~precomp_declaration()~ (precomp.rs line 958-973, precomp.til line 1174-1191):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // Only do this at global scope - inside function bodies, evaluating could cause side effects
   // to run at compile time AND runtime (e.g., print_debug func in mode liba).
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope {
       if let ValueType::TCustom(ref custom_type_name) = &value_type {
           match custom_type_name.as_str() {
               "I64" | "U8" | "Str" => {
                   if is_comptime_evaluable(context, &new_params[0]) {
                       let inner_e = &new_params[0];
                       let result = eval_expr(context, inner_e)?;
                       if !result.is_throw {
                           EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                       }
                   }
               },
               _ => {},
           }
       }
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects.
   if let ValueType::TCustom(ref custom_type_name) = &value_type {
       match custom_type_name.as_str() {
           "I64" | "U8" | "Str" => {
               if is_comptime_evaluable(context, &new_params[0]) {
                   let inner_e = &new_params[0];
                   let result = eval_expr(context, inner_e)?;
                   if !result.is_throw {
                       EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                   }
               }
           },
           _ => {},
       }
   }
   #+END_SRC

3. *Struct instance storage* in ~precomp_declaration()~ (precomp.rs line 975-991, precomp.til line 1193-1206):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
   if at_global_scope && !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   if !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

**** Error When Removing All Three Checks

#+BEGIN_SRC
./bin/rstil build make.til
ERROR: src/core/array.til:41:45: rstil insert_string_into_frame ERROR:
  Str template not found - ensure str.til is imported
#+END_SRC

**** Root Cause Analysis

The issue is NOT about side effects (the "Why Fix is Safe" analysis is correct for that).
The issue is about *infrastructure availability during precompilation*:

1. *Precomp vs Eval timing*: ~precomp_expr~ runs before ~eval~. During precomp of
   function bodies, we're still in the syntactic transformation phase.

2. *Templates created during eval*: The ~EvalArena.default_instances["Str"]~ template
   is created when global Str declarations are evaluated, not during precomp.

3. *Order problem*: When precompiling ~src/core/array.til~'s function bodies (which
   contain format() calls that create Str), the Str template doesn't exist yet
   because we haven't finished evaluating global scope.

4. *Why global scope works*: At global scope, declarations are both precompiled AND
   evaluated in sequence. The Str template gets created by earlier declarations
   before later ones need it.

5. *Why function bodies fail*: Function bodies are precompiled during the module
   import phase, but not evaluated. The template infrastructure isn't available.

**** What Needs to Change

Simply removing ~at_global_scope~ doesn't work. The fix requires understanding
the precomp/eval interaction:

- *FCall folding (Location 1)*: Might work alone if ~eval_comptime~ doesn't try
  to store values that need templates. Needs investigation.

- *Primitive/Struct storage (Locations 2 & 3)*: Cannot work without templates.
  Options:
  1. Make template lookup fail gracefully (skip storage, don't error)
  2. Defer non-global storage to evaluation phase
  3. Initialize templates earlier (during precomp init?)
  4. Only fold to literals, don't store in arena for non-global

**** Files to Investigate Further

- ~src/rs/eval_arena.rs~: ~insert_string_into_frame()~, ~default_instances~ map
- ~src/rs/precomp.rs~: ~eval_comptime()~, understand what it stores vs returns
- ~src/rs/interpreter.rs~: When/how templates get initialized
- The interaction between ~precomp_expr~ -> ~eval_comptime~ -> ~EvalArena~

**** TIL Equivalents

The same changes were ported to ~src/self/precomp.til~:
- Location 1: lines 301-307 (FCall folding)
- Location 2: lines 1174-1191 (primitive storage)
- Location 3: lines 1193-1206 (struct instance storage)

The TIL syntax differs slightly (e.g., ~at_global_scope.and(...)~ instead of
~at_global_scope && ...~) but the logic is identical.

*** Tests
- tmp/test_constfold_scope.til - demonstrates the issue

** Issue #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [-] Issue #82: make.til - Replace Makefile with TIL (partial: make.til works, go_build_yourself added, Makefile reduced to bootstrap only)
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [-] Issue #91: First-Class Functions (FunctionSig + function pointers done, closures/collections next)
- [X] Bug #92: Range loops should allow explicit iterator type annotation (Fixed 2026-01-29)
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Fixed. Variable shadowing now works via name mangling in C codegen.

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #142: Code Simplification - Context Error Helpers
:PROPERTIES:
:DISCOVERED: 2026-01-26
:IMPACT: Reduces boilerplate, improves readability
:STATUS: Open
:END:

*** Description
Add helper methods to Context struct to reduce repetitive error creation boilerplate.
Currently there are 301 calls to error methods that redundantly pass ~context.path~.

*** Current Pattern
#+BEGIN_SRC til
errors.push(e.error(context.path, "type", format("...", foo, "...")))
errors.push(e.lang_error(context.path, "type", "..."))
errors.push(e.todo_error(context.path, "type", "..."))
#+END_SRC

Every call redundantly passes ~context.path~. The error methods are defined on Expr (parser.til:443).

*** Proposed Simplification
Add Context helper methods in init.til:
#+BEGIN_SRC til
// In init.til, add to Context struct:
type_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.error(self.path, "type", msg)
}
type_lang_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.lang_error(self.path, "type", msg)
}
type_todo_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.todo_error(self.path, "type", msg)
}
#+END_SRC

*** Usage After Change
#+BEGIN_SRC til
// Before (65 chars):
errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
// After (52 chars):
errors.push(context.type_error(e, format("Undefined symbol '", name, "'")))
#+END_SRC

*** Impact Analysis
| File | Approximate calls |
|------|-------------------|
| typer.til | 89 |
| interpreter.til | 98 |
| init.til | 63 |
| others | ~50 |
| Total | ~301 |

Estimated savings: ~13 chars per call x 301 calls = ~3900 chars saved

*** Files to Modify
| File | Changes |
|------|---------|
| src/self/init.til | Add Context helper methods |
| src/rs/init.rs | Port Context helpers |
| src/self/typer.til | Use new Context helpers (~89 calls) |
| src/rs/typer.rs | Port helper usage |
| src/self/interpreter.til | Use new Context helpers (~98 calls) |
| src/rs/interpreter.rs | Port helper usage |

*** Verification
1. ~make benchmark~ - all tests pass before and after
2. Line count comparison: ~wc -l src/self/typer.til~ before/after
3. No functional changes - pure refactoring

*** Additional Opportunities (Lower Priority)

**** ccodegen push_str Chains (1438 calls)
Many consecutive ~output.push_str()~ calls could be combined with ~format()~:
#+BEGIN_SRC til
// Current:
output.push_str(indent_str)
output.push_str(c_type)
output.push_str(" ")
output.push_str(temp_var)
output.push_str(";\n")

// Potential:
output.push_str(format(indent_str, c_type, " ", temp_var, ";\n"))
#+END_SRC
This is tedious but safe - consider as follow-up work.

**** I64Range.get() Dynamic Pattern
Uses Dynamic for interface compatibility with for-in loops. By design - cannot simplify without language-level template support.

** Issue #138: Use Bool for Ptr.is_borrowed or separate BorrowedPtr type
:PROPERTIES:
:DISCOVERED: 2026-01-25
:IMPACT: Cleaner ownership semantics
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction)
:END:

*** Description
Currently ~Ptr.is_borrowed~ is ~I64~ instead of ~Bool~ because Bool causes size
alignment issues between interpreter and compiled code:
- Interpreter: Bool = 1 byte, so Ptr = 9 bytes, Str = 25 bytes
- Compiled: Bool = 1 byte + 7 padding, so Ptr = 16 bytes, Str = 32 bytes

*** Options
1. Fix interpreter's ~size_of~ to account for alignment padding
2. Use separate types: ~Ptr~ (owned) vs ~BorrowedPtr~ (borrowed)
   - Smaller size: Ptr = 8 bytes (just data) instead of 16 bytes (data + is_borrowed)
   - Type system enforces ownership at compile time
   - No runtime check needed in delete()

*** Benefits of Bool
Would allow cleaner syntax in Ptr.delete():
#+BEGIN_SRC til
if self.is_borrowed {  // instead of if self.is_borrowed.eq(1)
    self.data = NULL
    return
}
#+END_SRC

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:RESOLVED: 2026-01-30
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open - shadowing check is too strict, needs scope-awareness (2026-02-23)
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (fix via name mangling), Bug #173 (Rust typer missing shadowing check)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Problem: shadowing check is too strict (2026-02-23)

The current check in ~typer.rs:check_declaration~ (Bug #97) uses ~function_locals~
which is function-wide -- it tracks ALL declarations across the entire function body,
regardless of scope. This means variables in separate scopes can't reuse names:

#+begin_src til
// FAILS: "Variable 'i' already declared in this function (shadowing not allowed)"
test := func() returns I64 = {
    mut sum := 0
    for i in 0..3 { sum = sum.add(i) }
    for i in 10..13 { sum = sum.add(i) }   // ERROR: 'i' already declared
    return sum
}
#+end_src

Range-for loops desugar to ~Body { mut i := start; while ... }~ (parser.rs:1504).
Both Body blocks are at function scope level from the typer's perspective since
~function_locals~ ignores scope nesting.

For-in loops DON'T have this problem because the user's variable is declared via
~cast()~ inside the while body, and ~cast~ declarations are created with the ForIn
node's line/col. The internal variables (~_for_i_funcname_N~, ~_ref_forin_N~) use
unique generated names.

*Minimum fix*: the shadowing check should respect scope boundaries (Body blocks).
Re-declaration in a sibling or nested scope is fine -- C itself handles this with
block scoping (~{}~), so no codegen issues. The ~is_shadowing_in_function~ check
needs scope tracking, or alternatively, the typer should push/pop the ~function_locals~
set when entering/leaving Body nodes.

Further relaxation (same-scope shadowing, type-change shadowing) can be decided later.

*** Action Items
- [ ] Make shadowing check scope-aware (at minimum, separate Body blocks)
- [ ] Decide on further relaxation (same-scope shadowing, type-change shadowing)
- [ ] Document final policy

*** References
- Bug #65: Specific instance where shadowing caused divergence
- Bug #97: Introduced the function-wide shadowing check
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured → splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded → same behavior, splice
_ := declare_const(a, I64, 42)

// Captured → get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #178: Eliminate TTypeDef, unify type representation
:PROPERTIES:
:DISCOVERED: 2026-02-22
:IMPACT: Internal cleanup, type system simplification
:STATUS: Open
:RELATED: Issue #105 (First-Class Structs), doc/first_class.org
:END:

*** Description
Replace ~TType(TTypeDef::TStructDef)~ / ~TType(TTypeDef::TEnumDef)~ /
~TType(TTypeDef::TFuncSig)~ with ~TCustom("StructDef")~ / ~TCustom("EnumDef")~ /
~TCustom("FuncSig")~ throughout the compiler. This would eliminate the ~TTypeDef~
enum and ~ValueType::TType~ variant entirely, unifying the type representation.

*** Background
This was originally Issue #105 Step 4b. It was attempted but deferred because
TIL's switch/case desugarer does not support string literal payloads in enum case
patterns (~case ValueType.TCustom("StructDef"):~ only matches the outer TCustom
variant, ignoring the string). Every case pattern had to be converted to
~case ValueType.TCustom(name): if name.eq("StructDef") { ... }~, which is fragile.
The attempt also hit OOM issues during benchmark.

Issue #105 Step 4d's ~metatype_matches()~ provides the user-facing benefits
(explicit metatype annotations) without the internal refactor.

*** Scope
~122 Rust refs to TTypeDef, ~126 TIL refs. Mechanical replacement but requires
careful handling of TIL's switch/case limitation.


