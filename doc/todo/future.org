#+TITLE: Future Language Design Decisions
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues here use same numbering as bugs.org (from doc/todo/next_issue_num.txt)
# BOT: add them at the top of open issues, when implemented, move them to the top of implemented issues

* Overview

This document tracks long-term language design decisions that are not bugs
but need consideration. Unlike bugs.org (specific problems to fix), these
are open questions about language direction.

* Open Issues

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux→macOS, Windows→Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #134: Ptr type refactor - distinguish pointer fields from I64
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables proper serialization of heap data, fixes Bug #133
:STATUS: Open
:RELATED: Bug #133 (precomputed heap values), Issue #115 (owned struct fields)
:END:

*** Description
Currently, pointer fields in structs (Vec.ptr, Str.c_string, List node pointers)
are typed as I64. This makes it impossible to distinguish a pointer from a regular
integer during code generation.

For Bug #133's proper fix (serializing heap data to static arrays), we need to
identify which fields contain heap pointers so ccodegen can:
1. Extract the pointed-to data from the interpreter's arena
2. Emit that data as static C arrays
3. Patch the pointer to reference the static array instead

*** Current State
#+BEGIN_SRC til
Vec := struct {
    type_name: Str
    mut type_size: I64
    mut ptr: I64       // Actually a pointer, but typed as I64
    mut _len: I64
    mut cap: I64
}
#+END_SRC

*** Proposed Solutions

**** Option A: Add Ptr type
Introduce a ~Ptr~ type that indicates a heap pointer:
#+BEGIN_SRC til
Vec := struct {
    type_name: Str
    mut type_size: I64
    mut ptr: Ptr       // Explicitly a pointer
    mut _len: I64
    mut cap: I64
}
#+END_SRC

ccodegen can then detect Ptr fields and handle them specially.

**** Option B: Metadata/annotation approach
Keep I64 but add annotations:
#+BEGIN_SRC til
mut ptr: I64 @heap_pointer
#+END_SRC

**** Option C: Pattern-based detection in ccodegen
Hardcode knowledge of which fields are pointers (Vec.ptr, Str.c_string, etc.).
Simplest but least extensible.

*** Recommendation
Option A (Ptr type) is cleanest for long-term language design. Option C is
acceptable as a short-term solution if Ptr type is too invasive.

*** Implementation Notes
- Ptr would be similar to I64 in most operations (size=8, arithmetic)
- ccodegen emits Ptr as ~til_I64~ (same as I64)
- The difference is semantic: precomp/ccodegen knows to serialize pointed-to data
- Consider whether Ptr should have generic type: ~Ptr<Str>~ vs just ~Ptr~

** Issue #131: Clang support (gcc/clang interchangeable)
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Broader platform support, developer choice
:STATUS: Open
:END:

*** Description
Make gcc and clang interchangeable as C compilers. Currently gcc is required,
but clang should work as an alternative. Update README to reflect that either
compiler satisfies the dependency.

*** Goals
- gcc remains the default compiler
- If clang is available but gcc isn't, use clang
- README should list "gcc OR clang" as dependency
- Both compilers should produce working binaries
- Handle any compiler-specific flags or warnings

*** Implementation notes
- Check for gcc first, fall back to clang
- May need separate warning flag handling (some -W flags differ)
- Test on both compilers in CI if possible

** Issue #122: Add regex support to standard library
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Essential for text processing, refactoring tools, code generators
:STATUS: Open
:END:

*** Failed attempt: branch wip_122 (2026-01-21)
Commit b6d31a6a was merged to master but has a subtle bug:
- After ~make clean && make benchmark~: FAILS
- Without clean (incremental build): PASSES

This indicates a build dependency issue - something isn't being rebuilt that
should be, or the generated code depends on stale artifacts.

Branch ~wip_122~ preserved for investigation. Will need to:
1. Identify what artifact is stale/missing after clean
2. Fix the build dependency or code generation
3. Cherry-pick fix to master once resolved

*** Description
Add regular expression support to TIL's standard library. The exact interface
is to be decided, but should be general enough to handle common use cases
while remaining simple to use.

*** Prior art

**** grep (POSIX Basic/Extended Regular Expressions)
#+BEGIN_SRC bash
# Basic usage - match pattern in file
grep "pattern" file.txt

# Extended regex (-E)
grep -E "foo|bar" file.txt

# Replace with sed
sed 's/old/new/g' file.txt
#+END_SRC

Key features:
- BRE (Basic) and ERE (Extended) syntax
- Line-oriented matching
- Simple substitution with backreferences

**** Emacs Lisp
#+BEGIN_SRC elisp
;; Search forward for regex
(re-search-forward "pattern" nil t)

;; Replace regex
(replace-regexp-in-string "old" "new" string)

;; Match and capture groups
(string-match "\\(foo\\)\\(bar\\)" str)
(match-string 1 str)  ; => "foo"
#+END_SRC

Key features:
- Integrated with buffer/string operations
- Capture groups via match-string
- Backslash-heavy escaping (elisp quirk)

**** Python re module
#+BEGIN_SRC python
import re

# Search for pattern
match = re.search(r"pattern", string)

# Find all matches
matches = re.findall(r"\d+", string)

# Substitution
result = re.sub(r"old", "new", string)

# Compiled patterns for performance
pattern = re.compile(r"complex_pattern")
pattern.match(string)

# Named groups
m = re.match(r"(?P<name>\w+)", string)
m.group("name")
#+END_SRC

Key features:
- Raw strings (r"...") avoid escaping issues
- re.compile() for repeated use
- Named capture groups
- MULTILINE, DOTALL flags

**** Rust regex crate
#+BEGIN_SRC rust
use regex::Regex;

let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
assert!(re.is_match("2024-01-15"));

// Capture groups
let caps = re.captures("...");
caps.get(1).map(|m| m.as_str());

// Replace
re.replace_all(text, "replacement");
#+END_SRC

Key features:
- Compiled regex (Regex::new)
- No backtracking (guarantees linear time)
- Capture groups with .captures()

*** Proposed API (TBD)
Interface decisions to make:
1. Compiled vs interpreted patterns?
2. PCRE vs POSIX vs custom syntax?
3. How to handle capture groups?
4. Multiline/dotall mode handling?

#+BEGIN_SRC til
// Option 1: Simple function-based API
regex_match := ext_func(pattern: Str, text: Str) returns Bool {}
regex_find := ext_func(pattern: Str, text: Str) returns I64 {}  // -1 if not found
regex_sub := ext_func(pattern: Str, replacement: Str, text: Str) returns Str {}

// Option 2: Compiled pattern object
Regex := struct {
    // ... internal state ...

    new := proc(pattern: Str) returns Regex throws RegexError {}
    is_match := func(self: Regex, text: Str) returns Bool {}
    find := func(self: Regex, text: Str) returns I64 {}
    replace := func(self: Regex, text: Str, replacement: Str) returns Str {}
    replace_all := func(self: Regex, text: Str, replacement: Str) returns Str {}
}

// Option 3: Match result with captures
RegexMatch := struct {
    mut matched: Bool = false
    mut start: I64 = 0
    mut end: I64 = 0
    mut groups: Vec = Vec.new(Str)  // Capture groups
}
#+END_SRC

*** Implementation options
1. Link against system regex (POSIX regex.h)
2. Link against PCRE/PCRE2 library
3. Use Rust regex crate (for rstil)
4. Implement simple regex engine in TIL (educational but limited)

*** Use cases
- Text search and replace in files
- Parsing structured text (logs, config files)
- Input validation
- Code refactoring tools
- Extracting data from strings

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open
:DEPENDS: Issue #116 (Str len/cap), Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Issue #116: Str needs len/cap refactor for ownership tracking
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()
Already implemented: Vec, Array, Set, Map, List, Ptr
After Issue #116: Str

*** Implementation Steps

**** Step 1: Type System - Track has_delete
- Check if type has ~delete~ method
- Track in SStructDef or compute on demand
- Files: typer.rs, typer.til

**** Step 2: Liveness Analysis Infrastructure
Track last use of variables - core algorithm.

Data structure:
#+BEGIN_SRC rust
struct VarLifetime {
    name: String,
    value_type: ValueType,
    has_delete: bool,
    last_use_stmt_idx: Option<usize>,
    is_deleted: bool,
}
#+END_SRC

Algorithm:
1. Analysis pass: Scan statements, track last use index per variable
2. Emission pass: After emitting stmt at last_use_index, emit ~var.delete()~

Files: ccodegen.rs, ccodegen.til

**** Step 3: Handle Early Exits (return/throw)
Before any exit point, delete all still-live variables with delete().
Files: ccodegen.rs, ccodegen.til

**** Step 4: Handle Branches (if/else/switch)
Conservative: Only delete if ALL paths agree variable is dead.
Otherwise, postpone delete to after branch.
Files: ccodegen.rs, ccodegen.til

**** Step 5: Handle Loops
Most conservative: Variables used in loop body deleted after loop ends.
Special case: for-in loop variable deleted at end of each iteration.
Files: ccodegen.rs, ccodegen.til

**** Step 6: Scope Exit Safety Net
Delete any remaining live variables at function end.
Files: ccodegen.rs, ccodegen.til

**** Step 7: Interpreter Support
Mirror same logic in interpreter for consistency.
Files: interpreter.rs, interpreter.til

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- Scope: Both compiler and interpreter for consistency

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Issue #116: Refactor Str to use len/cap pattern
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables Str.delete() and ownership tracking
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction depends on this)
:END:

*** Description
Str currently uses ~cap~ field as length. Refactor to proper len/cap like Vec,
enabling ownership tracking (cap=0 means literal/unowned, cap>0 means heap/owned).

*** Problem
String literals in generated C point to static .rodata memory:
#+BEGIN_SRC c
til_Str s = ((til_Str){(til_I64)"hello", 5});  // can't free this!
#+END_SRC

Dynamic strings (clone, concat) point to heap memory - CAN free.
We need a way to distinguish them.

*** Solution
Use capacity field for ownership (like Vec):

Current:
#+BEGIN_SRC til
Str := struct {
    mut c_string: I64 = 0
    mut cap: I64 = 0      // misleading - actually length
}
#+END_SRC

New:
#+BEGIN_SRC til
Str := struct {
    mut c_string: I64 = 0
    mut len: I64 = 0      // length of string
    mut cap: I64 = 0      // allocated capacity (0 = literal/unowned)
}
#+END_SRC

*** Ownership Semantics
- ~cap = 0~: Literal/unowned - DO NOT free (points to .rodata)
- ~cap > 0~: Owned - CAN free (heap allocated, cap bytes)

*** Benefits
- Not a hack flag - actual useful capacity info
- Enables future push_str optimization (append in-place if len < cap)
- Consistent with Vec semantics (ptr, len, cap)
- Ownership derived from meaningful data

*** Implementation Steps

**** Step 1: Update Str struct
- Rename current ~cap~ to ~len~
- Add new ~cap~ field (allocated capacity, 0 = literal)

**** Step 2: Update Str methods
All allocating methods must set cap:
- clone(): cap = allocated size
- concat(): cap = allocated size
- replace(): cap = allocated size
- get_substr(): cap = allocated size (when it allocates)
- etc.

**** Step 3: Add Str.delete()
#+BEGIN_SRC til
delete := proc(mut self: Str) {
    if self.cap.gt(0) {  // Only free if owned
        free(self.c_string)
    }
    self.c_string = 0
    self.len = 0
    self.cap = 0
}
#+END_SRC

**** Step 4: Update ccodegen literal emission
Emit ~{c_string, len, 0}~ for literals (cap=0 = unowned).

*** ABI Change
This changes til_Str struct size - requires:
- Regenerate all C code
- Update bootstrap/til.c
- Full rebuild

*** Files
- src/core/str.til (struct + all methods)
- src/rs/ccodegen.rs (literal emission)
- src/self/ccodegen.til (literal emission)
- bootstrap/til.c (regenerate)

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #110: Desugar switch to if/else in desugarer
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Simplify interpreter and ccodegen, reduce internal complexity
:STATUS: Open
:RELATED: ccodegen payload hoisting, Issue #111 (enum_payload nicer with returns Dynamic)
:END:

*** Description
Remove switch as an internal construct. In desugarer phase, desugar switch/case to
if/else chains with hoisted payload bindings (like ccodegen already does).

*** Benefits
After desugaring switch to if/else in desugarer, these phases can be simplified:
- ~interpreter.rs~ (24 switch refs) - remove switch handling entirely
- ~ccodegen.rs~ (57 switch refs) - remove switch handling and payload hoisting
- ~precomp.rs~ (12 switch refs) - remove switch handling
- ~scavenger.rs~ (1 switch ref) - remove switch handling
- ~typer.rs~ (45 switch refs) - KEEP for validation before desugaring

Result: one construct post-desugarer (if/else), payload hoisting in single place

*** Example
Before precomp:
#+BEGIN_SRC til
switch my_enum {
    case Foo(x) { use(x) }
    case Bar(y) { use(y) }
    default { fallback() }
}
#+END_SRC

After precomp:
#+BEGIN_SRC til
if enum_to_str(my_enum).eq("MyEnum.Foo") {
    x := /* hoisted payload extraction */
    use(x)
} else if enum_to_str(my_enum).eq("MyEnum.Bar") {
    y := /* hoisted payload extraction */
    use(y)
} else {
    fallback()
}
#+END_SRC

*** Required ext_func
Need to add for payload extraction (like Vec.new takes Type):
#+BEGIN_SRC til
// With inout (works now):
enum_payload := ext_func(e: Dynamic, payload_type: Type, mut p: Dynamic) {}

// With returns Dynamic (nicer, needs Issue #111):
enum_payload := ext_func(e: Dynamic, payload_type: Type) returns Dynamic {}
#+END_SRC

*** Notes
- Gleam went the opposite direction (if/else to switch)
- We prefer switch->if/else since payload hoisting is already in ccodegen
- Move that logic to desugarer (runs after typer, before precomp/interpreter/ccodegen)

*** Prerequisite [DONE]
Merged commit ~08865594~ (enum_get_payload branch) providing:
- ~enum_get_payload(e: Dynamic, payload_type: Type, mut out: Dynamic)~ ext_func
- ~test_color_match_if~ in enums.til - working reference implementation

*** enum_get_payload fix for nested enums [DONE]
The original ~enum_get_payload~ implementation only worked for primitives (Bool, I64, Str)
and structs. For nested enum payloads (e.g., ~Result.Ok(Option.None)~), it failed because:
- The check ~payload_bytes.len() >= type_size~ used max enum size
- But actual payload bytes only contain the specific variant's data
- For ~Option.None~, payload is just 8 bytes (tag), not max size (tag + Some payload)

Fix: For enum payload types, copy all available bytes (must have >= 8 for tag) instead
of comparing against max type size.

Also added RGB struct (with U8 r,g,b fields) test case to verify struct payloads work.

*** Implementation Plan

Incremental approach: Rust first, test, TIL port, test. One file per commit.

Pipeline reminder: Typer -> Desugarer -> UFCS -> Precomp -> ...
The desugared ~val.eq(other)~ calls will be handled by UFCS (transforms to ~Type.eq(val, other)~).

**** Step 1: Add switch desugaring to desugarer (2 commits)

***** Commit 1a: Rust desugarer
- ~src/rs/desugarer.rs~ - add desugar_switch, handle Switch case
- Run ~make benchmark~ - must pass

***** Commit 1b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/desugarer.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 2: Remove switch handling from ufcs (2 commits)

UFCS has 12 switch refs and runs right after desugarer.

***** Commit 2a: Rust ufcs
- ~src/rs/ufcs.rs~ - remove switch handling, add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 2b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/ufcs.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 3: Remove switch handling from precomp (2 commits)

***** Commit 3a: Rust precomp
- ~src/rs/precomp.rs~ - remove switch handling, add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 3b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/precomp.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 4: Remove switch handling from scavenger (2 commits)

***** Commit 4a: Rust scavenger
- ~src/rs/scavenger.rs~ - remove switch handling
- Run ~make benchmark~ - must pass

***** Commit 4b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/scavenger.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 5: Remove switch handling from interpreter (2 commits)

***** Commit 5a: Rust interpreter
- ~src/rs/interpreter.rs~ - remove switch handling, add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 5b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/interpreter.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 6: Remove switch handling from ccodegen (2 commits)

***** Commit 6a: Rust ccodegen
- ~src/rs/ccodegen.rs~ - remove switch handling and payload hoisting
- Run ~make benchmark~ - must pass

***** Commit 6b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/ccodegen.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

*** Desugaring Details

**** Files to modify in Step 1
- ~src/rs/desugarer.rs~ - add desugar_switch, handle Switch case
- ~src/self/desugarer.til~ - port same changes (follow ~doc/rs2til.org~ translation rules)

***** Desugaring pattern (from test_color_match_if)
Input:
#+BEGIN_SRC til
switch to_switch {
case Color.Unknown: return "unknown color"
case Color.Green(is_olive):
    if is_olive { return "olive green" }
    return "dark green"
case Color.Number(code):
    if code.gt(0) { return "positive" }
    return "negative"
case:
    return "default"
}
#+END_SRC

Output:
#+BEGIN_SRC til
{
    _switch_variant_funcname_N := enum_to_str(to_switch)
    if Str.eq(_switch_variant_funcname_N, "Color.Unknown") {
        return "unknown color"
    } else if Str.eq(_switch_variant_funcname_N, "Color.Green") {
        mut is_olive := false
        enum_get_payload(to_switch, Bool, is_olive)
        if is_olive { return "olive green" }
        return "dark green"
    } else if Str.eq(_switch_variant_funcname_N, "Color.Number") {
        mut code := 0
        enum_get_payload(to_switch, I64, code)
        if code.gt(0) { return "positive" }
        return "negative"
    } else {
        return "default"
    }
}
#+END_SRC

***** Non-enum switch example (Str)
Input:
#+BEGIN_SRC til
switch name {
case "alice": return "found alice"
case "bob": return "found bob"
case: return "unknown"
}
#+END_SRC

Output:
#+BEGIN_SRC til
if name.eq("alice") {
    return "found alice"
} else if name.eq("bob") {
    return "found bob"
} else {
    return "unknown"
}
#+END_SRC

***** Non-enum switch with range example (I64)
Input:
#+BEGIN_SRC til
switch score {
case 90..100: return "A"
case 80..89: return "B"
case 0..79: return "C"
case: return "invalid"
}
#+END_SRC

Output:
#+BEGIN_SRC til
if score.gteq(90) && score.lteq(100) {
    return "A"
} else if score.gteq(80) && score.lteq(89) {
    return "B"
} else if score.gteq(0) && score.lteq(79) {
    return "C"
} else {
    return "invalid"
}
#+END_SRC

***** Switch AST structure
- ~params[0]~ = switch expression
- ~params[1..n]~ = pairs of (case_expr, body_expr)
- Trailing odd element = default case body

***** Switch types: Enum vs Non-enum
The desugaring differs based on switch expression type:

****** Enum switch
- Uses ~enum_to_str(val)~ to get tag as string (e.g., "Color.Green")
- Compares with ~Str.eq(variant_str, "EnumName.Variant")~
- For payload patterns, uses ~enum_get_payload(val, Type, binding_var)~

****** Non-enum switch (Str, I64, U8, custom structs)
- Uses direct method calls on the value: ~val.eq(case_val)~
- No enum_to_str wrapper needed
- Typer validates that ~eq~ method exists for the type

***** Case expression types
- ~NodeType::Pattern(PatternInfo { variant_name, binding_var })~ - e.g., Color.Green(is_olive) [enum only]
- ~NodeType::Identifier(...)~ - e.g., Color.Unknown (enum variant) or literal value
- ~NodeType::Range~ - e.g., 1..10
- ~NodeType::DefaultCase~ - the ~case:~ default

***** Range case desugaring
Range cases use ~gteq~ and ~lteq~ methods:
#+BEGIN_SRC til
// Input:
switch val {
case 1..10: handle_range()
}

// Output:
if val.gteq(1) && val.lteq(10) {
    handle_range()
}
#+END_SRC

***** Method requirements (typer validates)
The desugaring relies on these methods existing for the switch expression type:
- Simple case: ~eq(other: T) returns Bool~
- Range case: ~gteq(other: T) returns Bool~ and ~lteq(other: T) returns Bool~

If a struct is used in switch without implementing required methods, typer emits
an error (same as forin loops requiring ~get~ method on iterables).

No hardcoding of I64/Str/U8 - just call the methods and let typer validate.

****** TODO: Typer validation (like forin)
The forin loop validates ~len~ and ~get~ methods in typer.rs (lines 415-458) with
clear error messages showing required signatures:
#+BEGIN_SRC
for-in loop: type 'Things' does not have a 'get()' method.
Required: Things.get(self, index: I64, mut item: Dynamic) throws IndexOutOfBoundsError
#+END_SRC

Switch desugaring should add similar validation in typer for context-specific errors:
#+BEGIN_SRC
switch case: type 'Point' does not have an 'eq()' method.
Required: Point.eq(self, other: Point) returns Bool

switch range case: type 'Point' does not have a 'gteq()' method.
Required: Point.gteq(self, other: Point) returns Bool
#+END_SRC

Without explicit typer validation, the desugared code will fail with generic
errors like ~Type 'Point' has no method 'eq'~ which lacks switch context.

******* Current behavior (no validation)
Tested: struct without eq/gteq/lteq used in switch currently WORKS because
the interpreter uses string comparison, not method calls:
#+BEGIN_SRC til
Point := struct { mut x: I64 = 0  mut y: I64 = 0 }

// Simple case - works now (string compare), will fail after desugaring
switch p1 { case Point(x=5, y=10): ... }

// Range case - works now (lexicographic), will fail after desugaring
switch p1 { case Point(x=0, y=0)..Point(x=10, y=20): ... }
#+END_SRC

******* Implementation steps
1. Add validation in typer.rs for Switch nodes (copy pattern from forin at lines 415-458)
2. For non-enum simple cases: check ~TypeName.eq(self, other: TypeName) returns Bool~
3. For range cases: check ~TypeName.gteq~ and ~TypeName.lteq~ with same pattern
4. Create ~src/test/sugar.til~ with expected failures (forin + switch method checks)
5. Add to ~all_common~ in tests.til with ~expected_status=1~

****** Tested behaviors
- Struct without ~eq~ method calling ~p1.eq(p2)~: ~Type 'Point' has no method 'eq'~ (generic error)
- Struct without ~gteq~ method calling ~p1.gteq(p2)~: ~Type 'Point' has no method 'gteq'~ (generic error)
- Struct with ~eq~ method: works correctly (~p1.eq(p2)~ returns Bool)
- forin on struct without ~len~/~get~: clear context-specific error with required signature
- switch on struct without ~eq~: currently works (string compare) - will break after desugaring

***** Key implementation details
1. Reuse ~context.precomp_forin_counter~ for unique temp var names
2. Use prefix form ~Str.eq(a, b)~ - precomp_expr handles UFCS
3. Use ~build_default_value()~ for payload defaults (Bool/I64/Str/enums)
4. Flatten Body nodes when adding original body statements
5. Build if chain from end to beginning (reverse iteration)

***** precomp.rs changes
Line 240: Change ~NodeType::Switch => precomp_switch(context, e)~ to:
#+BEGIN_SRC rust
NodeType::Switch => {
    let desugared = desugar_switch(context, e)?;
    precomp_expr(context, &desugared)
},
#+END_SRC

Add ~desugar_switch~ function (~line 770) with helpers:
- ~build_switch_if_chain~ - collect cases, build if chain
- ~build_case_condition~ - build condition based on case type:
  - Simple case: ~val.eq(case_val)~
  - Range case: ~val.gteq(start) && val.lteq(end)~
  - Enum variant: ~enum_to_str(val).eq("Type.Variant")~
- ~build_payload_extraction_body~ - for enum patterns: {mut var := default; enum_get_payload(...); ...body...}
- ~build_if_chain_from_cases~ - build If nodes from end to beginning

Delete old ~precomp_switch~ function (lines 776-852).

***** precomp.til changes
Line 310: Change to call desugar_switch and recurse.
Add equivalent functions using TIL idioms (~Vec.new(Expr)~, ~Expr.new_explicit~).
Delete old ~precomp_switch~ function (lines 576-679).
IMPORTANT: Follow ~doc/rs2til.org~ translation rules when porting.

**** Commit 2: Replace eval_Switch/emit_switch with panics

After desugaring works, Switch nodes never reach interpreter/ccodegen.

***** Files to modify
- ~src/rs/interpreter.rs~ - replace NodeType::Switch arm with panic
- ~src/rs/ccodegen.rs~ - replace NodeType::Switch arm with panic
- ~src/self/interpreter.til~ - replace with panic
- ~src/self/ccodegen.til~ - replace with panic

**** Verification
#+BEGIN_SRC bash
make benchmark
#+END_SRC

All tests should pass. ~src/test/enums.til~ tests both:
- ~test_color_match~ (switch - now desugared)
- ~test_color_match_if~ (manual if/else - reference)

Both should produce identical behavior.

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (implementation attempt)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Action Items
- [ ] Fix nested-scope shadowing bug (high priority)
- [ ] Evaluate shadowing usage in self-hosted codebase
- [ ] Choose consistent shadowing policy
- [ ] Implement in type checker
- [ ] Document decision

*** References
- Bug #65: Specific instance where shadowing caused divergence
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Open
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type, but macros
are currently executed identically to funcs at runtime. This issue tracks
implementing true compile-time macro evaluation.

*** Core Semantics

1. *Forced compile-time evaluation*: Macros are always evaluated during precomp,
   never deferred to runtime (unlike funcs which fall back to runtime if args
   aren't comptime-known)

2. *All arguments must be compile-time known*: If any argument cannot be resolved
   at compile-time, emit an error. No runtime fallback.

3. *Can call procs*: Macros have proc permissions (side effects allowed during
   compile-time evaluation). The existing typer check that prevents funcs from
   calling procs already doesn't apply to macros.

4. *Return types*: Initially limited to what's currently supported (primitives,
   struct instances). Types can be passed as arguments but not returned yet.

*** Current Constant Folding (for reference)

The existing constant folding for funcs in ~precomp_expr()~ (precomp.til:299-308):
- Only folds at global scope
- Silently skips if not comptime-evaluable (defers to runtime)
- Rejects proc calls via ~is_comptime_evaluable()~ check

Macros need different behavior:
| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

*** Implementation Steps

1. *Add ~is_macro()~ helper to SFuncDef*
   - File: src/rs/parser.rs, src/self/parser.til
   - Pattern: like ~is_proc()~ but checks ~FunctionType::FTMacro~

2. *Add macro handling in ~precomp_expr()~ FCall case*
   - File: src/rs/precomp.rs, src/self/precomp.til
   - Location: After ~precomp_fcall()~ call, before existing constant folding
   - Logic: Detect macro call, error if args not comptime, force evaluation

3. *Port to TIL*
   - Mirror all changes in src/self/*.til

4. *Add tests*
   - Basic macro returning I64/Str
   - Macro calling proc (allowed)
   - Macro with non-const arg (should error)
   - Macro inside function body (should work)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (add is_macro helper)
- src/rs/precomp.rs / src/self/precomp.til (main changes)

*** Future Extensions

Once core mechanism works, expand capabilities:
- Return Types (StructDef) for generic type generation
- Return/pass FuncDefs for function generation
- Quote/unquote syntax (~quote { $var }~) for AST building
- Full metaprogramming per doc/metaprogramming.org

*** References
- doc/metaprogramming.org: Full macro/generics design vision

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: Open
:RELATED: Bug #90 (semicolon syntax), src/test/function_pointers.til (early draft), doc/lamda.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

*** Core Semantics (Initial Implementation)

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type syntax*: Parameter names are optional in type signatures.
   #+BEGIN_SRC til
   // Both are valid:
   BinaryOp := func(a: I64, b: I64) returns I64 {};
   BinaryOp := func(I64, I64) returns I64 {};
   #+END_SRC

3. *Throws are part of the signature*:
   #+BEGIN_SRC til
   Parser := func(Str) returns Ast throws ParseError, IOError {};
   #+END_SRC

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures initially*: Functions can only reference their own parameters
   and globals. Capturing enclosing scope variables is post-self-hosting.

*** Example
#+BEGIN_SRC til
// Define a function type (needs {} until Bug #90 Step 2 is done)
BinaryOp := func(I64, I64) returns I64 {};

// Function that takes a function as argument
apply := func(op: BinaryOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}

// Define functions matching the type
add := func(a: I64, b: I64) returns I64 { return a.add(b) }
mul := func(a: I64, b: I64) returns I64 { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** What This Avoids (for now)

- *Returning functions*: Not needed initially (structs/enums can't be returned either yet)
- *Storing in collections*: Vec/Map of functions - deferred
- *Closures*: Capturing enclosing scope variables - post-self-hosting

*** Implementation Considerations

*C codegen*: Function types become C function pointer types.
#+BEGIN_SRC c
typedef til_I64 (*BinaryOp)(til_I64, til_I64);
#+END_SRC

*Interpreter*: Need to resolve function parameters to actual function
definitions and call them. Currently looks up by name - would need to handle
"this parameter holds a function reference".

*Type checking*: Verify passed function's signature matches expected type
(args, return types, throw types).

*** Timing

Consider implementing post-self-hosting:
- FuncDef size/representation is simpler when TIL can use its own structs
- Avoids rstil/til divergence
- Related: til's ccodegen needs fixes ported from Rust first

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/test/function_pointers.til (existing draft, commented out)

*** Future Extensions (post-self-hosting)

- Return functions from functions
- Store functions in collections (Vec, Map)
- Multiple return values (~x, y := some_func()~)
- Closures (capturing enclosing scope variables)

** Issue #103: Mode GUI
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, graphical applications
:STATUS: Open
:RELATED: Issue #104 (TempleOS support), src/examples/hello_gui.til (untested draft)
:END:

*** Description
Add ~mode gui~ for graphical user interface applications.

*** Backend Strategy
- *Standard platforms*: Use raylib as the graphics backend
- *TempleOS*: Native HolyC graphics (see Issue #104)
- *Web*: Options to explore:
  - raylib + wasm compilation from C
  - Separate jscodegen.til with ~mode webgui~ importing mode html files
  - Decision deferred

*** Notes
- Draft exists in src/examples/hello_gui.til (untested, won't work yet)
- Keep API simple to maintain portability across backends
- TempleOS and raylib may have more features than needed; focus on common subset

** Issue #104: TempleOS Support
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Platform support, tiny containers
:STATUS: Open
:RELATED: Issue #103 (mode gui), Bug #80, Bug #100
:END:

*** Description
Add TempleOS as a compilation target, producing HolyC instead of C.

*** Dependencies
- Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- Bug #100: Get rid of rstil (full self-hosting)

*** Implementation Options
1. *Preferred*: Add flag/option to ccodegen for HolyC output
   - HolyC is very similar to C, differences are minor
   - Avoids code duplication
2. *Alternative*: Separate holyccodegen.til
   - More work, harder to maintain

*** Motivation
- Partly for fun/flexing and, why not? Also to honor Terry's ideal language: HolyC
- Practical use: TempleOS is tiny, useful for minimal docker containers
- Integration with mode gui (Issue #103) for native TempleOS graphics

** Issue #105: First-Class Structs
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #106 (First-Class Enums)
:END:

*** Description
Allow anonymous struct type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(struct {x := 0, y := 0})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for structs.

** Issue #106: First-Class Enums
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs)
:END:

*** Description
Allow anonymous enum type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(enum {A, B})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for enums.

** Issue #107: First-Class Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous namespaces
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #108 (Implement Namespaces)
:END:

*** Description
Allow anonymous namespace definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(namespace {
    INC_VAL := 32
    f := func(a: I64) returns I64 { return a.add(INC_VAL) }
})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for namespaces.
Depends on Issue #108 (proper namespace syntax).

** Issue #108: Implement Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, code organization
:STATUS: Open
:RELATED: Issue #107 (First-Class Namespaces)
:END:

*** Current State
Structs are used as namespaces by declaring only constants (no mut).
See src/test/namespaces.til:

#+BEGIN_SRC til
MyNamespace := struct {
    field_static_str : Str = "hello MyNamespace.field_static_str"
    field_static_bool : Bool = true
    field_static_int : I64 = 42

    proc_static := proc() {
        assert_eq(loc(), 42, MyNamespace.field_static_int)
    }

    func_static_str := func() returns Str {
        return "func called"
    }
}
#+END_SRC

*** What Works
- Access static fields: ~MyNamespace.field_static_str~
- Call static functions: ~MyNamespace.func_static_str()~
- Call static procs: ~MyNamespace.proc_static()~

*** What's Missing

A. *Namespace for enums*
   Enums can't have associated functions/constants. Structs can, enums cannot.

   Example: ~clone~. Structs can define a ~clone~ method, but enums cannot:
   #+BEGIN_SRC til
   Tile := enum {
       Object: struct { name := "", pos: struct { x := 0, y := 0 } }
       Monster: SomeStructThatImplementsClone
   }
   // Currently no way to define Tile.clone(), but with namespaces:
   namespace Tile {
       clone := func(self: Tile) returns Tile { TODO("Tile.clone") }
   }
   #+END_SRC

B. *Namespace for structs*
   Currently methods are mixed inside struct definitions. A separate
   namespace keyword would clarify intent and fit better with UFCS.

   #+BEGIN_SRC til
   Str := struct { ... }
   namespace Str {
       len := func(self: Str) returns I64 { ... }
       concat := func(self: Str, other: Str) returns Str { ... }
   }
   #+END_SRC
   Internally treated the same as current struct-embedded methods.

   Can implement step A or step B first - they're independent.

C. *One namespace per type per context*
   Only one ~namespace Foo~ block allowed per type in the same context.
   Could allow spreading across multiple blocks, but no clear gain -
   only potential confusion. Keep it simple: one place for all methods.

*** Keyword Choice
Two options being considered:
- ~namespace~ - matches UFCS concept better, more descriptive
- ~impl~ - shorter, familiar to Rust developers

Example with ~namespace~:
#+BEGIN_SRC til
MyEnum := enum { A, B, C }

namespace MyEnum {
    default := func() returns MyEnum { return MyEnum.A }
    describe := func(self: MyEnum) returns Str { return "an enum" }
}

MyStruct := struct { x: I64 }

namespace MyStruct {
    new := func() returns MyStruct { return MyStruct(x=0) }
    increment := func(self: MyStruct) returns MyStruct { return MyStruct(x=self.x.add(1)) }
}
#+END_SRC

** Issue #109: Proper Imports
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Language feature, code organization, namespace control
:STATUS: Open
:RELATED: Issue #108 (Implement Namespaces)
:END:

*** Python Reference
#+BEGIN_SRC python
import os                            # import module as namespace
import os as operating_system        # import module with alias

from os import path, getcwd          # import specific items
from os import path as p             # import specific item with alias

from os import *                     # import all (discouraged)

from . import sibling                # relative imports
from .. import parent
from ..package import module
#+END_SRC

*** Current State
~import("module")~ imports everything into current namespace (like Python's ~from os import *~).

*** Priorities

A. *Namespaced imports*
   #+BEGIN_SRC til
   import("os")              // from os import *
   getcwd()                  // getcwd() - directly available
   #+END_SRC

   #+BEGIN_SRC til
   os := import("os")        // import os
   os.getcwd()               // os.getcwd()
   #+END_SRC

B. *Selective imports*
   Could save significant precomp/scavenger time by not loading everything.
   #+BEGIN_SRC til
   import("numpy", "array", "zeros")  // from numpy import array, zeros
   array()                            // array()
   zeros()                            // zeros()
   #+END_SRC
   Uses variadic arguments. Syntax may change as we cover more Python cases.

C. *Namespaced + selective (TIL-specific, no Python equivalent)*
   #+BEGIN_SRC til
   np := import("numpy", "array", "zeros")
   np.array()
   np.zeros()
   #+END_SRC
   Combines A and B: namespaced access but only selected items and their own internal dependencies, recursively, are loaded.

*** Future (lower priority)

These Python cases still need TIL equivalents:
- ~import os as operating_system~ - module alias
- ~from os import getcwd as cwd~ - item alias
- ~from . import sibling~ - relative imports (collides with current dot syntax for multiplatform, needs thought)

*** Notes
This is a multi-step issue. Priorities A and B are sufficient for now.
Final syntax may evolve as we address all Python import patterns.

* Implemented Issues

** Issue #132: Mandatory ? for calls to throwing functions [DONE]
:PROPERTIES:
:DISCOVERED: 2026-01-22
:COMPLETED: 2026-01-23
:IMPACT: Explicit error propagation, catches sneaky throws at compile time
:STATUS: Fixed
:RELATED: Bug #54 (precomp_throw divergence)
:END:

*** Description
Make ~?~ mandatory at call sites for functions that throw.
- ~myvec.get(i)?~ instead of ~myvec.get(i)~
- Typer enforces: call to throwing function without ~?~ = type error

*** Syntax
- ~foo()?~ - foo throws
- ~foo().bar()?~ - only bar throws
- ~foo()?.bar()~ - only foo throws
- ~foo()?.bar()?~ - both throw

*** Implementation
- Lexer: Added ~QuestionMark~ token for ~?~
- Parser: Added ~does_throw: bool~ field to FCall, consumed ~?~ after ~)~
- Typer: Check ~does_throw~ matches function's throws clause
- All phases updated to handle ~FCall(bool)~ pattern
- All .til files updated with ~?~ on throwing calls (~4000+ changes)

** Issue #127: Pipeline refactoring - Add Desugarer and UFCS phases [DONE]
:PROPERTIES:
:DISCOVERED: 2026-01-19
:COMPLETED: 2026-01-20
:IMPACT: Cleaner architecture, single-pass type inference, easier maintenance
:STATUS: Fixed
:END:

*** Description
Refactor the compilation pipeline to separate concerns. See doc/pipeline.org
for full details including current vs target state and migration TODOs.

*** Current Problems
- Precomp is overloaded: UFCS + forin + switch + const-folding + macros
- Typer only validates, doesn't annotate AST with resolved types
- Later phases re-infer types repeatedly
- Parser desugars range for directly (should just build AST)

*** Target Pipeline
Lexer -> Parser -> Mode -> Init -> Typer -> Desugarer -> UFCS -> Precomp -> Scavenger -> Build/Interpret

Where:
- Typer: validates AND annotates AST with resolved types (no later phase infers)
- Desugarer: desugar forin, switch, range for (needs type info)
- UFCS: desugar x.method(y) -> Type.method(x, y)
- Precomp: const-folding, macros only

*** Related Issues
- Issue #110: Switch desugaring (will move to Desugarer phase)

*** Commit 1: Separate Desugarer phase from Precomp [DONE]

**** Overview
Create new desugarer phase that handles ForIn desugaring. Currently precomp
does desugaring inline during its recursive pass. The new design runs desugarer
as a separate pass before precomp.

**** Completion Notes
- Key fix: Do NOT declare loop variable in scope_stack during desugaring.
  The desugarer just transforms AST; declaring variables was leaking type
  information across files during batch compilation (caused custom_type_name
  in interpreter.til to be incorrectly typed as SymbolEntry from eval_arena.til's
  for-in loop over SymbolEntry).

**** Post-completion fix: Counter reset for determinism (2026-01-21)
When ForIn desugaring was moved from precomp to desugarer, the per-function
counter reset logic was NOT moved along with it. This caused non-deterministic
temp variable names (~_for_i_N~) in generated C code.

precomp.rs had this pattern for FuncDef processing:
#+BEGIN_SRC rust
let saved_counter = context.precomp_forin_counter;
context.precomp_forin_counter = 0;
// ... process function body ...
context.precomp_forin_counter = saved_counter;
#+END_SRC

But desugarer.rs was missing it. Fix: Added the same save/reset/restore pattern
to ~desugar_expr~ FuncDef handling in both desugarer.rs and desugarer.til.

**** Files to create
- src/rs/desugarer.rs - Rust implementation
- src/self/desugarer.til - TIL implementation (port from Rust)

**** Code to move from precomp.rs to desugarer.rs
1. transform_continue_with_step() - Bug #57 fix for continue in for-in loops
2. build_default_value() - Creates default values for enum payloads
3. precomp_forin() -> desugar_forin() - The actual ForIn desugaring logic

**** New entry point: desugar_expr()
Recursive function that:
- Handles NodeType::ForIn by calling desugar_forin()
- Recurses into FuncDef bodies (methods need desugaring too)
- Recurses into StructDef default values (may contain function defs)
- For all other nodes, recurses into params

**** Changes to precomp.rs
- Remove transform_continue_with_step, build_default_value, precomp_forin
- Replace ForIn case with panic:
  NodeType::ForIn(_) => panic!("ForIn should have been desugared")

**** Changes to interpreter.rs
- Add: use crate::rs::desugarer::desugar_expr;
- Before each precomp_expr call, add: e = desugar_expr(context, &e)?;

**** Changes to builder.rs
- Before each precomp_expr call, add desugar_expr call

**** Changes to rstil.rs
- Add: pub mod desugarer; (between typer and precomp)

**** TIL port (desugarer.til)
- Port all functions following doc/rs2til.org translation rules
- Import: import("self.init")
- Entry: desugar_expr proc

**** Changes to precomp.til
- Remove desugar-related functions
- Replace ForIn case with panic

**** Changes to interpreter.til, builder.til
- Add: import("self.desugarer")
- Call desugar_expr before precomp_expr

**** Verification
Run: make benchmark
All tests must pass.

*** Commit 2: Separate UFCS phase from Precomp [DONE]

**** Overview
Create new ufcs phase that handles UFCS desugaring. Currently precomp does
UFCS resolution inline in precomp_fcall. The new design runs ufcs as a
separate pass after desugarer, before precomp.

**** Completion Notes
- Key fix: U8 type annotation handling must be in ufcs_declaration, not just
  precomp_declaration. When `mut val : U8 = 41`, the literal 41 infers as I64
  but must be registered as U8 so UFCS transforms `val.inc()` to `U8.inc(val)`.
- TIL port required renaming `ufcs_func_def` variable in typer.til to `ufcs_fn_def`
  to avoid collision with the new ufcs_func_def function (TIL has global scope).

**** Files to create
- src/rs/ufcs.rs - Rust implementation
- src/self/ufcs.til - TIL implementation (port from Rust)

**** Code to move from precomp.rs to ufcs.rs
From precomp_fcall():
1. UFCS for chained calls (lines ~1176-1200): func(result, args) -> Type.func(result, args)
2. UFCS with dot notation (lines ~1202-1250): a.method(b) -> Type.method(a, b)
3. Named argument reordering (reorder_named_args function)

**** New entry point: ufcs_expr()
Recursive function that:
- Handles NodeType::FCall by resolving UFCS and reordering named args
- Recurses into FuncDef bodies
- Recurses into StructDef default values
- For all other nodes, recurses into params

**** Changes to precomp.rs
- Remove UFCS resolution code from precomp_fcall
- Remove reorder_named_args function
- precomp_fcall only handles: comptime intrinsics, struct/enum constructors, import()

**** Changes to interpreter.rs
- Add: use crate::rs::ufcs::ufcs_expr;
- Pipeline becomes: typer -> desugarer -> ufcs -> precomp

**** Changes to builder.rs
- Pipeline becomes: typer -> desugarer -> ufcs -> precomp

**** Changes to rstil.rs
- Add: pub mod ufcs; (between desugarer and precomp)

**** TIL port (ufcs.til)
- Port all functions following doc/rs2til.org translation rules

**** Verification
Run: make benchmark
All tests must pass.

** Issue #69: Test Organization - all_common category
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Test infrastructure, rstil/til output validation
:STATUS: In Progress
:RELATED: Bug #126 (error message divergence), Bug #100 (get rid of rstil)
:END:

*** Background
Tests that pass with BOTH rstil and til (with identical output) need a category
that runs all modes. Previously tests were either in ~rs_common~ (rstil only)
or ~til_interpreted~ (til only), with no way to verify identical behavior.

*** Solution Implemented
Added ~all_common~ category in tests.til that runs 4 modes:
- rs_interpreted (rstil interpret)
- rs_compiled (rstil run)
- til_interpreted (til interpret)
- til_compiled (til run)

*** Test Categorization Strategy
- ~all_common~: Tests producing identical output across all 4 modes (67 tests)
- ~rs_common~: Tests that pass with rstil but have different output from til
- ~til_common~: Tests that pass with til but have different output from rstil
- ~rs_interpreted~, ~rs_compiled~: Mode-specific tests
- Empty categories are skipped in benchmark output

*** Error Message Divergence (Bug #126)
Tests with expected failures (expected_status != 0) often can't go in all_common
because rstil and til produce different error messages. Common divergences:
- Debug markers (" b", " c", " d") in Rust not ported to TIL
- Different code paths triggered between implementations
- Different error collection/reporting order

Such tests must go in BOTH rs_common AND til_common with separate expected
output files. See sugar.til for an example.

*** Example: bug50 (RESOLVED)
bug50.til produced ~rstil type ERROR~ vs ~til type ERROR~ (binary name in output).
Fixed by unifying LANG_NAME to "til" in both src/rs/lexer.rs and src/self/lexer.til.
bug50.til now in all_common (2026-01-22).

*** Progress
Tests moved to all_common:
- panic.til (2026-01-22): Error messages now identical after Bug #126 fixes
- bug50.til (2026-01-22): LANG_NAME unified to "til" in both implementations

Remaining in rs_common + til_common separately:
- sugar.til: Error output still differs between rstil and til

*** Benchmark Annotations
4-phase all_common tests will show timing comparisons:
- ~(rstil: faster interpreted)~ or ~(rstil: faster compiled)~ - comparing rstil modes
- ~(interpreted: faster rstil)~ or ~(interpreted: faster til)~ - comparing interpreters
- ~(compiled: faster rstil)~ or ~(compiled: faster til)~ - comparing compilers

*** Files Modified
- src/tests.til: Added all_common Vec, processing in run_all_tests(), updated usage()
