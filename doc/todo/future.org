#+TITLE: Future Language Design Decisions
#+AUTHOR: TIL Development
#+DATE: 2025-12-31
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.

* Overview

This document tracks long-term language design decisions that are not bugs
but need consideration. Unlike bugs.org (specific problems to fix), these
are open questions about language direction.

* Open Issues

** Issue #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [ ] Issue #82: make.til - Replace Makefile with TIL
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [ ] Issue #91: First-Class Functions
- [X] Bug #92: Range loops should allow explicit iterator type annotation (Fixed 2026-01-29)
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Partial fix is sufficient. Shadowing detection is in both Rust and TIL
  typers, all existing code renamed. Final design decision (allow vs disallow)
  can wait until after #100.

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #142: Code Simplification - Context Error Helpers
:PROPERTIES:
:DISCOVERED: 2026-01-26
:IMPACT: Reduces boilerplate, improves readability
:STATUS: Open
:END:

*** Description
Add helper methods to Context struct to reduce repetitive error creation boilerplate.
Currently there are 301 calls to error methods that redundantly pass ~context.path~.

*** Current Pattern
#+BEGIN_SRC til
errors.push(e.error(context.path, "type", format("...", foo, "...")))
errors.push(e.lang_error(context.path, "type", "..."))
errors.push(e.todo_error(context.path, "type", "..."))
#+END_SRC

Every call redundantly passes ~context.path~. The error methods are defined on Expr (parser.til:443).

*** Proposed Simplification
Add Context helper methods in init.til:
#+BEGIN_SRC til
// In init.til, add to Context struct:
type_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.error(self.path, "type", msg)
}
type_lang_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.lang_error(self.path, "type", msg)
}
type_todo_error := func(self: Context, e: Expr, msg: Str) returns Str {
    return e.todo_error(self.path, "type", msg)
}
#+END_SRC

*** Usage After Change
#+BEGIN_SRC til
// Before (65 chars):
errors.push(e.error(context.path, "type", format("Undefined symbol '", name, "'")))
// After (52 chars):
errors.push(context.type_error(e, format("Undefined symbol '", name, "'")))
#+END_SRC

*** Impact Analysis
| File | Approximate calls |
|------|-------------------|
| typer.til | 89 |
| interpreter.til | 98 |
| init.til | 63 |
| others | ~50 |
| Total | ~301 |

Estimated savings: ~13 chars per call x 301 calls = ~3900 chars saved

*** Files to Modify
| File | Changes |
|------|---------|
| src/self/init.til | Add Context helper methods |
| src/rs/init.rs | Port Context helpers |
| src/self/typer.til | Use new Context helpers (~89 calls) |
| src/rs/typer.rs | Port helper usage |
| src/self/interpreter.til | Use new Context helpers (~98 calls) |
| src/rs/interpreter.rs | Port helper usage |

*** Verification
1. ~make benchmark~ - all tests pass before and after
2. Line count comparison: ~wc -l src/self/typer.til~ before/after
3. No functional changes - pure refactoring

*** Additional Opportunities (Lower Priority)

**** ccodegen push_str Chains (1438 calls)
Many consecutive ~output.push_str()~ calls could be combined with ~format()~:
#+BEGIN_SRC til
// Current:
output.push_str(indent_str)
output.push_str(c_type)
output.push_str(" ")
output.push_str(temp_var)
output.push_str(";\n")

// Potential:
output.push_str(format(indent_str, c_type, " ", temp_var, ";\n"))
#+END_SRC
This is tedious but safe - consider as follow-up work.

**** I64Range.get() Dynamic Pattern
Uses Dynamic for interface compatibility with for-in loops. By design - cannot simplify without language-level template support.

** Issue #138: Use Bool for Ptr.is_borrowed or separate BorrowedPtr type
:PROPERTIES:
:DISCOVERED: 2026-01-25
:IMPACT: Cleaner ownership semantics
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction)
:END:

*** Description
Currently ~Ptr.is_borrowed~ is ~I64~ instead of ~Bool~ because Bool causes size
alignment issues between interpreter and compiled code:
- Interpreter: Bool = 1 byte, so Ptr = 9 bytes, Str = 25 bytes
- Compiled: Bool = 1 byte + 7 padding, so Ptr = 16 bytes, Str = 32 bytes

*** Options
1. Fix interpreter's ~size_of~ to account for alignment padding
2. Use separate types: ~Ptr~ (owned) vs ~BorrowedPtr~ (borrowed)
   - Smaller size: Ptr = 8 bytes (just data) instead of 16 bytes (data + is_borrowed)
   - Type system enforces ownership at compile time
   - No runtime check needed in delete()

*** Benefits of Bool
Would allow cleaner syntax in Ptr.delete():
#+BEGIN_SRC til
if self.is_borrowed {  // instead of if self.is_borrowed.eq(1)
    self.data = NULL
    return
}
#+END_SRC

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #66: Variable Shadowing Policy
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Language design, Rust/TIL parity, developer experience
:STATUS: Open
:RELATED: Bug #65 (specific shadowing divergence), Bug #97 (implementation attempt)
:END:

*** Background
Bug #65 was caused by Rust code using variable shadowing (~let custom_type_name = ...~
to shadow an existing variable), but TIL doesn't support shadowing, so the TIL
translation used a different variable name (~resolved_type_name~) and then
inconsistently used the old name later.

*** Current Behavior (Tested 2025-11-10)

1. *~_~ reuse in same scope*: ALLOWED
   - ~_ := 5~ followed by ~_ := 10~ works
   - Universal in all languages - ~_~ is special

2. *Regular variable same-scope shadowing*: ALLOWED
   - ~x := 5~ followed by ~x := 10~ works
   - Creates new binding, not reassignment

3. *Type-change shadowing*: NOT ALLOWED
   - ~y := 5~ followed by ~y := "hello"~ fails type checking
   - Treated as reassignment to existing variable

4. *Nested-scope shadowing*: PARTIALLY WORKS (buggy)
   - Inner ~z := 10~ is allowed after outer ~z := 5~
   - BUT: Inner declaration MUTATES outer variable
   - This is likely a bug - should create new binding

*** Decision Needed

Options:
1. *Allow full shadowing like Rust* (including type changes)
   - Pro: 1:1 translation from Rust to TIL
   - Pro: Familiar to Rust developers
   - Con: Can hide bugs (accidentally reusing variable name)

2. *Prohibit same-scope shadowing like Go/Haskell* (except for ~_~)
   - Pro: Clearer code, no hidden rebinding
   - Con: Rust code needs different variable names when porting

3. *Current inconsistent behavior* (not recommended)
   - Pro: None
   - Con: Confusing, leads to bugs like Bug #65

*** Interim Rule (Until Decided)

To avoid Rust/TIL divergence like Bug #65:
- *Avoid shadowing in Rust code* - use different variable names
- *Use ~resolved_X~ pattern* - when transforming a variable, use a new name
- *-Wshadow enabled* - gcc warns about shadowing in generated C code

This rule is documented in CLAUDE.md.

*** Action Items
- [ ] Fix nested-scope shadowing bug (high priority)
- [ ] Evaluate shadowing usage in self-hosted codebase
- [ ] Choose consistent shadowing policy
- [ ] Implement in type checker
- [ ] Document decision

*** References
- Bug #65: Specific instance where shadowing caused divergence
- doc/todo/post.org: Original shadowing discussion (moved here)

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured → splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded → same behavior, splice
_ := declare_const(a, I64, 42)

// Captured → get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: Open
:RELATED: Bug #90 (semicolon syntax), src/test/function_pointers.til (early draft), doc/lamda.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

*** Core Semantics (Initial Implementation)

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type syntax*: Parameter names are optional in type signatures.
   #+BEGIN_SRC til
   // Both are valid:
   BinaryOp := func(a: I64, b: I64) returns I64 {};
   BinaryOp := func(I64, I64) returns I64 {};
   #+END_SRC

3. *Throws are part of the signature*:
   #+BEGIN_SRC til
   Parser := func(Str) returns Ast throws ParseError, IOError {};
   #+END_SRC

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures initially*: Functions can only reference their own parameters
   and globals. Capturing enclosing scope variables is post-self-hosting.

*** Example
#+BEGIN_SRC til
// Define a function type (needs {} until Bug #90 Step 2 is done)
BinaryOp := func(I64, I64) returns I64 {};

// Function that takes a function as argument
apply := func(op: BinaryOp, a: I64, b: I64) returns I64 {
    return op(a, b)
}

// Define functions matching the type
add := func(a: I64, b: I64) returns I64 { return a.add(b) }
mul := func(a: I64, b: I64) returns I64 { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** What This Avoids (for now)

- *Returning functions*: Not needed initially (structs/enums can't be returned either yet)
- *Storing in collections*: Vec/Map of functions - deferred
- *Closures*: Capturing enclosing scope variables - post-self-hosting

*** Implementation Considerations

*C codegen*: Function types become C function pointer types.
#+BEGIN_SRC c
typedef til_I64 (*BinaryOp)(til_I64, til_I64);
#+END_SRC

*Interpreter*: Need to resolve function parameters to actual function
definitions and call them. Currently looks up by name - would need to handle
"this parameter holds a function reference".

*Type checking*: Verify passed function's signature matches expected type
(args, return types, throw types).

*** Timing

Consider implementing post-self-hosting:
- FuncDef size/representation is simpler when TIL can use its own structs
- Avoids rstil/til divergence
- Related: til's ccodegen needs fixes ported from Rust first

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/test/function_pointers.til (existing draft, commented out)

*** Future Extensions (post-self-hosting)

- Return functions from functions
- Store functions in collections (Vec, Map)
- Multiple return values (~x, y := some_func()~)
- Closures (capturing enclosing scope variables)

** Issue #105: First-Class Structs
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #106 (First-Class Enums)
:END:

*** Description
Allow anonymous struct type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(struct {x := 0, y := 0})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for structs.

** Issue #106: First-Class Enums
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs)
:END:

*** Description
Allow anonymous enum type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(enum {A, B})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for enums.

** Issue #107: First-Class Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous namespaces
:STATUS: Open
:RELATED: Issue #91 (First-Class Functions), Issue #108 (Implement Namespaces)
:END:

*** Description
Allow anonymous namespace definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(namespace {
    INC_VAL := 32
    f := func(a: I64) returns I64 { return a.add(INC_VAL) }
})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for namespaces.
Depends on Issue #108 (proper namespace syntax).

