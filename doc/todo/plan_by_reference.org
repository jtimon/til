#+TITLE: Plan: Pass-by-Reference with Three Parameter Modes
#+AUTHOR: TIL Development Team
#+DATE: 2025-11-12

* Goal

Implement efficient pass-by-reference semantics with three explicit parameter modes:
1. **Default (const)**: Immutable reference - cannot be modified
2. **mut**: Mutable reference - modifications affect caller
3. **copy**: Explicit copy - can be modified without affecting caller

* Three Parameter Modes

** Default (No Keyword) - Immutable Reference
- Syntax: ~func(x: I64)~
- Semantics: Pass by reference, read-only
- Implementation: Share arena offset, no copying
- Type checker: Prevents assignment to parameter

** Mut Keyword - Mutable Reference
- Syntax: ~func(mut x: I64)~
- Semantics: Pass by reference, read-write
- Implementation: Share arena offset, write-back to caller
- Type checker: Allows assignment, enforces caller passes mut variable

** Copy Keyword - Explicit Copy
- Syntax: ~func(copy x: I64)~
- Semantics: Create independent copy, modifications are local
- Implementation: Deep copy via copy_fields() for structs
- Type checker: Allows assignment (local copy only)
- Mutually exclusive with mut (parser validation)

* Implementation Status

** Phase 1: Type Checker Immutability Enforcement ✅ COMPLETE
- Prevents assignment to immutable parameters (typer.rs:930, 937)
- Prevents field modification of immutable parameters
- Prevents passing immutable to mut parameter (typer.rs:322-344)
- Tests in src/test/tmp/test_immutability*.til verify all cases

** Phase 2: Copy Keyword ✅ COMPLETE
- Added Copy token to lexer (lexer.rs:25, 208, 262)
- Added is_copy field to Declaration and SymbolInfo (parser.rs:19, init.rs:22)
- Parser validates mut and copy are mutually exclusive (parser.rs:536-546)
- Type checker allows modification of copy parameters (typer.rs:930, 937)
- Interpreter allows assignment to copy parameters (interpreter.rs:946, 953)
- Comprehensive tests in src/test/args.til (lines 344-467)
- All existing tests pass

** Phase 3: Use References for All Non-Copy Parameters ⏳ TODO

Goal: Both const (default) and mut parameters use references. Only copy creates actual copies.

*** Change Default Parameter Passing (Const)
Currently: Uses copy_fields() to deep copy structs
Target: Share arena offset like mut parameters do

File: src/rs/interpreter.rs (lines 1615-1700)
- Replace insert_struct() + copy_fields() logic
- New: Share arena offset from caller context
- Get source offset from caller's arena_index
- Insert same offset into function_context.arena_index
- Call map_instance_fields() to register field offsets

*** Include Primitives in Reference Passing
Currently: Primitives are copied for both const and mut
Target: Share arena offset for primitives too (semantic consistency)

File: src/rs/interpreter.rs (lines 1593-1604)
- Replace insert_i64(), insert_bool(), etc. allocations
- New: Share arena offset from caller context
- For literals: Still allocate (caller evaluates these)

*** Keep Copy Parameter Behavior
File: src/rs/interpreter.rs
- Copy parameters continue to use copy_fields()
- Check is_copy field to determine copy vs. reference
- Deep copy for copy parameters only

*** Update Mut Parameter Implementation
File: src/rs/interpreter.rs (lines 1733-1781)
- Mut parameters already use reference sharing
- No changes needed (already correct)
- Continue write-back behavior for consistency

** Phase 4: Update Core Library ⏳ TODO

Goal: Remove Bug #24 workarounds once references work correctly.

File: src/core/list.til, vec.til, map.til
- Remove copy-modify-reassign patterns
- Simplify List.push(), List.set(), List.pop()
- Test that direct field mutation works
- Mark Bug #24 as FIXED in bugs.org

* Key Implementation Details

** Current State

***  Function Call Entry Point
File: src/rs/interpreter.rs:452-705
- eval_func_proc_call() is the main dispatcher
- Routes to eval_user_func_proc_call() for user-defined functions (line 704)

*** Core Parameter Handling
File: src/rs/interpreter.rs:1466-1725

For CONST parameters (lines 1509-1714):
1. Argument is evaluated in the caller's context (line 1545)
2. A NEW function_context is created (cloned from caller, line 1468)
3. For structs (lines 1615-1700):
   - insert_struct() allocates NEW space in arena (line 1670)
   - copy_fields() COPIES all field values from source to dest (line 1699)
   - This is a DEEP COPY of all mutable fields

For MUT parameters (lines 1563-1590, 1733-1781):
1. Stores tuple: (arg_name, source_name, type) in mut_args vector
2. STILL does the copy into function context initially (same as const)
3. After function execution (lines 1733-1781):
   - For primitive types: Reads value and re-inserts to caller context
   - For structs (lines 1759-1767): Uses arena offset sharing
   - This POINTS the caller's variable to the SAME arena location

For COPY parameters:
1. Same as const (deep copy behavior)
2. Check is_copy flag to identify copy parameters
3. Type checker allows modification (unlike const)

*** Critical TODOs Found
- Line 1096 in init.rs: "TODO all args should be passed as pointers/references and we wouldn't need this"
- Line 1760 in interpreter.rs: "TODO this can be simplified once we pass all args by reference"

** Arena/Memory Management

*** Arena Structure
File: src/rs/interpreter.rs:16-37
- Global singleton accessed via Arena::g() (unsafe static)
- Memory starts at offset 1 (offset 0 reserved as "null")
- All values stored as raw bytes in single Vec<u8>

*** Context Structure
File: src/rs/init.rs:832-862
- arena_index: HashMap<String, usize> maps var names to arena offsets
- symbols: HashMap<String, SymbolInfo> maps var names to type info

*** How Values Are Stored
Storing a value (e.g., insert_i64() line 913-935):
1. Allocate space: offset = Arena::g().memory.len()
2. Append bytes: Arena::g().memory.extend_from_slice(&bytes)
3. Record offset: self.arena_index.insert(id.to_string(), offset)

Storing a reference (used for mut struct returns, line 1762):
1. Just update arena_index: context.arena_index.insert(source_name, *offset)
2. No new arena allocation, points to existing data

*** The copy_fields() Function
File: src/rs/init.rs:1097-1159
- Gets source field offset from arena_index
- Calculates dest offset
- Performs memory copy: Arena::g().memory.copy_within(...)
- Recursively copies nested structs
- Used for copy parameters only (after Phase 3)

** Type System

File: src/rs/typer.rs:360-410
- Type checker validates that types match
- is_mut and is_copy flags preserved in SymbolInfo
- Type checker enforces immutability of const parameters
- Mut arguments must be identifiers or field access
- Copy parameters can be modified (local changes only)

* Benefits After Phase 3

- **Performance**: No more copy_fields() overhead for const params
- **Consistency**: All non-copy params passed by reference
- **Semantics**: Clear distinction between reference and copy
- **Bug Fixes**: Resolves Bug #24 (struct field mutation)
- **Removes TODOs**: init.rs:1096 and interpreter.rs:1760

* Risks and Mitigations

** Risk: Breaking existing code that relies on const param isolation
Mitigation: Type checker already prevents modifications to const params (Phase 1)

** Risk: Arena lifetime/sharing issues
Mitigation: Arena never deletes, so references always valid

** Risk: Nested function calls with shared references
Mitigation: Read-only semantics mean sharing is safe for const params

** Risk: Copy parameters might not deep copy correctly
Mitigation: Continue using existing copy_fields() implementation for copy params

* Files to Modify in Phase 3

** src/rs/interpreter.rs (lines 1615-1700, 1593-1604)
Replace copy logic with reference sharing for const params
Check is_copy flag to determine copy vs. reference behavior

** src/test/tmp/test_reference_passing.til (new file)
Add tests for reference passing semantics
Verify const params share memory (read-only)
Verify mut params share memory (read-write)
Verify copy params don't share memory (independent)

* Next Steps

1. Implement Phase 3: Modify interpreter.rs parameter passing
2. Add comprehensive tests for reference semantics
3. Verify all existing tests still pass
4. Implement Phase 4: Clean up core library
5. Mark Bug #24 as FIXED
