#+TITLE: Post-Self-Hosting Features and Improvements
#+AUTHOR: TIL Development
#+DATE: 2026-01-29
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section at the bottom.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features, improvements, and optimizations that can be
deferred until after self-hosting is achieved. These are not blocking the
self-hosted TIL interpreter but are planned for future development.

For bugs, see bugs.org. For language design decisions, see future.org.

* Open Issues

** Issue #104: TempleOS Support
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Platform support, tiny containers
:STATUS: Open
:RELATED: Issue #103 (mode gui), Bug #80, Bug #100
:END:

*** Description
Add TempleOS as a compilation target, producing HolyC instead of C.

*** Dependencies
- Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- Bug #100: Get rid of rstil (full self-hosting)

*** Implementation Options
1. *Preferred*: Add flag/option to ccodegen for HolyC output
   - HolyC is very similar to C, differences are minor
   - Avoids code duplication
2. *Alternative*: Separate holyccodegen.til
   - More work, harder to maintain

*** Motivation
- Partly for fun/flexing and, why not? Also to honor Terry's ideal language: HolyC
- Practical use: TempleOS is tiny, useful for minimal docker containers
- Integration with mode gui (Issue #103) for native TempleOS graphics

*** Why Post-Self-Hosting
Requires full self-hosting (Bug #100) and ccodegen parity (Bug #80).

** Issue #103: Mode GUI
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, graphical applications
:STATUS: Open
:RELATED: Issue #104 (TempleOS support), src/examples/hello_gui.til (untested draft)
:END:

*** Description
Add ~mode gui~ for graphical user interface applications.

*** Backend Strategy
- *Standard platforms*: Use raylib as the graphics backend
- *TempleOS*: Native HolyC graphics (see Issue #104)
- *Web*: Options to explore:
  - raylib + wasm compilation from C
  - Separate jscodegen.til with ~mode webgui~ importing mode html files
  - Decision deferred

*** Notes
- Draft exists in src/examples/hello_gui.til (untested, won't work yet)
- Keep API simple to maintain portability across backends
- TempleOS and raylib may have more features than needed; focus on common subset

*** Why Post-Self-Hosting
GUI is a nice-to-have feature that requires significant platform abstraction work.

** Issue #156: Implement match keyword (expression-based switch)
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Language ergonomics, expression-based control flow
:STATUS: Open - token recognized, not implemented
:FILE: src/rs/lexer.rs, src/core/lexer.til
:END:

*** Description
~match~ is like ~switch~ but returns a value (expression vs statement).

*** Example
#+BEGIN_SRC til
// switch - statement
switch x {
    case 1: do_something()
    case 2: do_other()
}

// match - expression, returns value
result := match x {
    case 1: "one"
    case 2: "two"
    case: "other"
}
#+END_SRC

Like Rust's ~let result = match x { ... }~.

*** Current State
- Token recognized by lexer
- Not implemented in parser/interpreter/typer

*** What's Needed
- [ ] Design match semantics (expression that returns value)
- [ ] Implement in parser
- [ ] Add type checking (all branches must return same type)
- [ ] Add evaluation support
- [ ] Add test cases

*** Why Post-Self-Hosting
Switch statements work fine. Match is syntactic convenience for when you
want the result of a case-based decision.

** Issue #155: Add Unicode support to TIL
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Internationalization, modern text handling
:STATUS: Open
:FILE: src/rs/lexer.rs
:END:

*** Problem
TIL currently does not support Unicode characters in source code. The lexer
panics when encountering multi-byte UTF-8 characters like checkmarks, emoji,
or non-ASCII text.

Example error:
: byte index 368 is not a char boundary; it is inside '...' (bytes 367..370)

*** Current Limitation
Until Unicode is supported:
- NO Unicode characters should be used anywhere in the project
- This includes: source code, documentation files, comments, test files
- Use ASCII-only characters (e.g., [PASS] instead of checkmark)

*** What Needs to be Fixed
- Update lexer.rs to handle UTF-8 character boundaries correctly
- Use Rust's ~chars()~ iterator instead of byte indexing where appropriate
- Add comprehensive Unicode tests
- Update documentation about supported character sets

*** Implementation Notes
- Implement proper UTF-8 handling in lexer
- Add Unicode test suite
- Consider which Unicode features to support (identifiers, strings, etc.)
- Update lexer.til to match lexer.rs changes

*** Why Post-Self-Hosting
ASCII-only is sufficient for self-hosting. Unicode is a nice-to-have for
internationalization and modern text handling.

** Issue #154: Template vs Dynamic compilation mode
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Binary size vs performance trade-off, embedded device support
:STATUS: Open
:RELATED: Issue #153 (Dynamic field/method access), Issue #111 (returns Dynamic)
:END:

*** Description
Currently TIL uses Dynamic internally for generic collections (Vec, Map, etc.) -
type erasure approach with one implementation that works for all types, checked
at runtime.

The vision: offer BOTH approaches via compiler flag, transparently to the user:
- ~--dynamic~ (or similar): Current behavior, type erasure, smaller binary
- ~--template~ (or similar): Rust-style monomorphization, specialized code per type

*** The Trade-off

| Mode     | Type checking | Binary size       | Performance |
|----------+---------------+-------------------+-------------|
| Dynamic  | Runtime       | Smaller (1 copy)  | Slower      |
| Template | Compile-time  | Larger (N copies) | Fast        |

*** User Experience
Same source code works either way:
#+BEGIN_SRC til
v := Vec.new(I64)
v.push(42)
#+END_SRC

With ~--dynamic~: One Vec implementation, runtime type info
With ~--template~: Specialized Vec_I64 generated, compile-time checks

The user doesn't change their code - the compiler flag decides.

*** Use Cases
- **Embedded devices**: Use ~--dynamic~ for limited flash, accept slower runtime
- **Performance-critical**: Use ~--template~ for speed, accept larger binary
- **Development**: Use ~--dynamic~ for fast compilation
- **Release**: Use ~--template~ for production performance

*** Why Post-Self-Hosting
This is a major compiler feature requiring:
- Template instantiation system
- Monomorphization pass
- Significant ccodegen changes
- Testing infrastructure for both modes

Current Dynamic-only approach works for self-hosting.

** Issue #109: Proper Imports
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Language feature, code organization, namespace control
:STATUS: Open
:RELATED: Issue #108 (Implement Namespaces)
:END:

*** Python Reference
#+BEGIN_SRC python
import os                            # import module as namespace
import os as operating_system        # import module with alias

from os import path, getcwd          # import specific items
from os import path as p             # import specific item with alias

from os import *                     # import all (discouraged)

from . import sibling                # relative imports
from .. import parent
from ..package import module
#+END_SRC

*** Current State
~import("module")~ imports everything into current namespace (like Python's ~from os import *~).

*** Priorities

A. *Namespaced imports*
   #+BEGIN_SRC til
   import("os")              // from os import *
   getcwd()                  // getcwd() - directly available
   #+END_SRC

   #+BEGIN_SRC til
   os := import("os")        // import os
   os.getcwd()               // os.getcwd()
   #+END_SRC

B. *Selective imports*
   Could save significant precomp/scavenger time by not loading everything.
   #+BEGIN_SRC til
   import("numpy", "array", "zeros")  // from numpy import array, zeros
   array()                            // array()
   zeros()                            // zeros()
   #+END_SRC
   Uses variadic arguments. Syntax may change as we cover more Python cases.

C. *Namespaced + selective (TIL-specific, no Python equivalent)*
   #+BEGIN_SRC til
   np := import("numpy", "array", "zeros")
   np.array()
   np.zeros()
   #+END_SRC
   Combines A and B: namespaced access but only selected items and their own internal dependencies, recursively, are loaded.

D. *Direct member access*
   #+BEGIN_SRC til
   Lexer := import("src/core/lexer").Lexer
   my_lexer := Lexer.new("file.til")
   #+END_SRC
   Access single member from import result without loading entire namespace.

E. *Destructuring syntax (alternative to B)*
   #+BEGIN_SRC til
   {Lexer, Token} := import("src/core/lexer")
   #+END_SRC
   Similar to Python's ~from lexer import Lexer, Token~ but with destructuring.
   Alternative to variadic syntax in B - needs decision on preferred approach.

*** Future (lower priority)

These Python cases still need TIL equivalents:
- ~import os as operating_system~ - module alias
- ~from os import getcwd as cwd~ - item alias
- ~from . import sibling~ - relative imports (collides with current dot syntax for multiplatform, needs thought)

*** Implementation Notes
- Import result is struct-like: declarations accessed like struct fields
- Requires Issue #108 (namespaces) to be partially complete - import returns namespace object
- Type checker needs to handle namespace types for dot access
- Scavenger benefits from selective imports (less to scan)

*** Why Post-Self-Hosting
Current ~import("module")~ works for self-hosting. Advanced import features are
syntactic conveniences that can wait.

* Implemented Issues

(None yet - move issues here when implemented)
