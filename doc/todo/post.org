#+TITLE: Post-Self-Hosting TODO List
#+AUTHOR: rstil Development
#+DATE: 2025-11-10
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it

* Overview

This document tracks TODOs that can be deferred until *after* self-hosting is achieved.

These are features, improvements, and optimizations that would be nice to have but are not blocking the ability to run the self-hosted til interpreter.

* Language Features

** TODO Enable Field and Method Access on Dynamic Parameters          :MEDIUM:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, code flexibility
:PRIORITY: Medium (would enable true dynamic typing, but workarounds exist)
:END:

*** Problem
Currently, `Dynamic` parameters skip type checking when **passed** to functions, but once inside the function, any field access or method call on the Dynamic value is still type-checked and fails.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

The type checker treats `Dynamic` as a concrete struct type and validates member/method access, which fails because `Dynamic` itself has no members or methods.

*** What Works Now
1. **Skipped type checking when passing arguments** - you can pass any type to a `Dynamic` parameter
2. **Type introspection functions** - `size_of(T)` and `type_as_str(T)` work when used with type identifiers

*** What Doesn't Work
- Accessing fields on `Dynamic` values (e.g., `obj.x`)
- Calling methods on `Dynamic` values (e.g., `obj.sum()`)
- Any operations on the Dynamic value itself

*** Desired Behavior
For true Python-like dynamic typing, the type checker should skip validation for operations on `Dynamic` values, allowing:
- Field access to be checked at runtime
- Method calls to be resolved at runtime
- Duck typing patterns

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a `Dynamic` type
2. Skip member/method existence validation for Dynamic expressions
3. Defer these checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a `.x` field, use it)
- Temporary workaround until proper generics are implemented
- Python-style flexible code

*** Priority
Medium - This would enable more flexible code patterns and is part of the vision for `Dynamic` as a Python-like feature. However, it's not critical for self-hosting since we can use concrete types or work around the limitation.

** TODO Consider Implementing Enum Tag Comparison Feature               :LOW:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Code quality, parser implementation
:PRIORITY: Low (workaround exists, not needed for self-hosting)
:END:

*** Problem
Rust has an enum `.tag()` method that returns the discriminant (variant identifier), allowing comparison of enum variants without caring about payloads. TIL doesn't have this feature.

*** Investigation Results (2025-11-10)
Attempted to implement an `enum_tag()` helper function but discovered a `Dynamic` type limitation:
- When an enum is passed through a `Dynamic` parameter to a TIL function, `enum_to_str()` returns the parameter name instead of evaluating the enum value
- This makes it impossible to create a reusable `enum_tag()` helper function
- Core functions in Rust (like `rsonly_enum_extract_payload`) can handle `Dynamic`, but user-defined TIL functions cannot

*** Current Workaround
Use switch statements to check enum variants. This works and is actually quite clean:

#+BEGIN_SRC til
// Instead of Rust's: if nt.tag().eq(NodeType.Identifier("").tag())
switch nt {
    case NodeType.Identifier:
        // Handle Identifier case directly
}
#+END_SRC

*** Potential Future Solutions
1. Implement `.tag()` as a core function in Rust (like `enum_to_str`)
2. Fix `Dynamic` type handling so user-defined functions can properly receive enums
3. Implement direct enum variant comparison with `==` operator
4. Keep using switch statements (current approach - works well)

*** Documentation
Added note in `src/core/pure_std.til` explaining the Dynamic limitation and recommending switch statements for enum pattern matching.

*** Impact on Self-Hosting
None - The switch statement workaround is sufficient and readable. This would be a nice-to-have for slightly cleaner code, but is not essential.

** DONE Bug #8 Fixed with Compile-Time Enforcement                      :HIGH:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-10
:IMPACT: Affects language ergonomics and error handling
:RELATED: Bug #8, Return value handling
:END:

*** Implemented Approach
Bug #8 (uncaptured return values propagate up call stack) has been **fixed with compile-time enforcement**. The type checker now requires all return values to be explicitly captured with `_ := func()` or used in expressions.

*** Why This Approach
We chose compile-time enforcement rather than fixing the runtime propagation behavior because:

1. **Catches errors at compile time** - Better than runtime surprises
2. **Makes intent explicit** - Clear whether return values are used or discarded
3. **Follows best practices** - Aligns with Rust (#[must_use]), Swift (@discardableResult)
4. **Safer default** - Prevents accidental loss of important return values

*** Implementation Details
- Added =ExprContext= enum to track ValueUsed vs ValueDiscarded contexts
- Modified type checker to propagate context through all expressions
- Function calls with return values must be in ValueUsed context
- Helpful error messages guide users to fix the issue

*** Valid Code Patterns
```til
result := my_add(1, 2)        // ✅ Capture return value
double(my_add(3, 4))          // ✅ Use as argument
_ := get_value()              // ✅ Explicitly discard
print_hello()                 // ✅ Procs don't return
my_add(1, 2)                  // ❌ ERROR: Return value not used
```

*** Reconsideration After Self-Hosting
After gaining more experience with the self-hosted codebase, we may consider:
- Whether certain built-in functions should allow discarded returns
- If @discardableResult-style annotations would be useful
- Whether the explicitness helps or hinders in practice

For now, requiring explicit handling is the safer and clearer default.

** TODO Reconsider Variable Shadowing Policy After Self-Hosting        :MEDIUM:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Language design, developer experience
:END:

*** Current Behavior (Tested 2025-11-10)

Based on tests in src/test/temporary_tests.til:

1. **`_` reuse in same scope**: ✅ ALLOWED
   - `_ := 5` followed by `_ := 10` works
   - Universal in all languages - `_` is special

2. **Regular variable same-scope shadowing**: ✅ ALLOWED
   - `x := 5` followed by `x := 10` works
   - Creates new binding, not reassignment (tested with `let` keyword behavior)

3. **Type-change shadowing**: ❌ NOT ALLOWED
   - `y := 5` followed by `y := "hello"` fails type checking
   - Treated as reassignment to existing variable, not new binding

4. **Nested-scope shadowing**: ⚠️ PARTIALLY WORKS
   - Inner `z := 10` is allowed after outer `z := 5`
   - BUT: Inner declaration MUTATES outer variable (z=10 after inner scope!)
   - This is likely a bug - should create new binding in inner scope

*** Issues with Current Behavior

- Inconsistent: Allows same-scope shadowing but not type changes
- Nested scope behavior is buggy (mutates instead of shadowing)
- Different from most languages (Rust allows type changes, Go/Haskell prohibit same-scope)

*** Decision Needed After Self-Hosting

Should we:
1. Allow full shadowing like Rust (including type changes)?
2. Prohibit same-scope shadowing like Go/Haskell (except for `_`)?
3. Fix nested-scope shadowing to create new bindings (not mutate)?

*** Action Required
- Fix nested-scope shadowing bug (high priority)
- Evaluate shadowing usage in self-hosted codebase
- Choose consistent shadowing policy
- Implement in type checker

** TODO Add Unicode Support to TIL                                    :MEDIUM:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FILE: src/rs/lexer.rs
:IMPACT: Internationalization, modern text handling
:END:

*** Problem
TIL currently does not support Unicode characters in source code. The lexer panics when encountering multi-byte UTF-8 characters like checkmarks, emoji, or non-ASCII text.

Example error:
: byte index 368 is not a char boundary; it is inside '✓' (bytes 367..370)

*** Current Limitation
Until Unicode is supported:
- **NO Unicode characters** should be used anywhere in the project
- This includes: source code, documentation files, comments, test files
- Use ASCII-only characters (e.g., [PASS] instead of ✓, [FAIL] instead of ✗)

*** What Needs to be Fixed
- Update lexer.rs to handle UTF-8 character boundaries correctly
- Use Rust's `chars()` iterator instead of byte indexing where appropriate
- Add comprehensive Unicode tests
- Update documentation about supported character sets

*** Action Required After Self-Hosting
- Implement proper UTF-8 handling in lexer
- Add Unicode test suite
- Update all documentation to reflect Unicode support
- Consider which Unicode features to support (identifiers, strings, etc.)

** TODO Support Namespace-Style Imports                              :MEDIUM:
:PROPERTIES:
:FILE: src/rs/init.rs
:IMPACT: Better code organization and namespace management
:END:

*** Description
Allow imports to return module namespaces instead of just executing code.

*** Current State
- Imports execute the imported file and make its definitions available
- No way to namespace imported definitions
- Example: =import("src/core/lexer")= executes lexer.til but can't assign to variable

*** Desired Behavior

*1. Namespace-style imports (assign import to variable):*
#+BEGIN_SRC til
// Import entire module as namespace (like Python's "import parser as parser")
parser := import("src/core/parser")
ast := parser.parse(tokens)

lexer := import("src/core/lexer")
tokens := lexer.scan_tokens(source)
#+END_SRC

*2. Direct member access (single item):*
#+BEGIN_SRC til
// Access single member from import result
Lexer := import("src/core/lexer").Lexer
my_lexer := Lexer.new("file.til")
#+END_SRC

*3. Selective imports (multiple items):*
#+BEGIN_SRC til
// Similar to Python's "from lexer import Lexer, Token"
// Syntax TBD - possible options:
// Option A: Destructuring syntax
{Lexer, Token} := import("src/core/lexer")

// Option B: Multiple member access
Lexer := import("src/core/lexer").Lexer
Token := import("src/core/lexer").Token

// Option C: Special import syntax (like Python)
import("src/core/lexer", "Lexer", "Token")  // Makes Lexer and Token available directly
#+END_SRC

*Key Design Points:*
- Import result is struct-like: declarations inside are accessed like struct fields
- Enables namespacing: =parser.parse()= vs global =parse()=
- Current global imports remain: =import("file")= executes and adds to global context
- New assignment form: =name := import("file")= creates namespace without polluting globals

*** What's Needed
- [ ] Design module/namespace type system
- [ ] Decide on selective import syntax (destructuring vs multiple access vs special form)
- [ ] Modify import to return struct-like namespace object
- [ ] Allow dot notation access to module members
- [ ] Update type checker to handle namespace types
- [ ] Add test cases for namespace imports (all three forms)
- [ ] Document namespace import syntax

*** Why It's Post-Self-Hosting
Current import system works for self-hosting. Namespacing is a quality-of-life improvement for larger codebases.

** TODO Implement List/Tuple Support                                   :LOW:
:PROPERTIES:
:FILE: src/rs/parser.rs:75, src/core/parser.til:78-80
:IMPACT: Nicer syntax, not functionally necessary
:END:

*** Current State
- Parser recognizes syntax but doesn't fully implement it
- =src/rs/parser.rs:75= - "TODO: Could call it tuple, not tested yet"
- Struct workarounds work fine (PatternInfo uses struct instead of tuple)
- Arrays work fine instead of lists

*** Why It's Not Blocking
The only real use case found:
- =src/core/parser.til:78-80= - PatternInfo struct is a workaround for =(Str, Str)= tuple
- This works perfectly fine as a struct with two fields
- No other significant usage of tuples/lists in self-hosting code

*** Workarounds That Work Fine
- PatternInfo struct instead of tuple
- Arrays instead of lists
- Function parameters already work with comma-separated syntax

*** What Would Be Needed (Post-Self-Hosting)
- [ ] Implement proper list literal parsing in parser.rs
- [ ] Implement tuple types in type system
- [ ] Add list/tuple evaluation in interpreter.rs
- [ ] Test with pattern matching scenarios
- [ ] Replace PatternInfo struct with tuple syntax

*** Priority Note
This is pure syntax sugar. Structs and Arrays cover all functionality needed.

** TODO Support Negative Number Literals                               :LOW:
:PROPERTIES:
:FILE: src/core/core.til:26
:IMPACT: Quality of life, not blocking
:END:

*** Current State
- Negative literals not supported
- All negative numbers use =sub(0, n)= workaround
- Examples: =cNeg2 := sub(0, 2)=, =cNeg42 := sub(0, 42)=

*** What's Needed
- [ ] Extend lexer to recognize negative number tokens
- [ ] Update parser to handle negative literals
- [ ] Add test cases for negative number operations
- [ ] Update core.til to use native negative literals

*** Why It's Not Blocking
The workaround is functional and self-hosting code can use =sub(0, n)= just fine.

** TODO Implement Match Keyword                                      :MEDIUM:
:PROPERTIES:
:FILE: src/core/lexer.til:155, src/rs/lexer.rs:288
:STATUS: Token recognized, not implemented
:END:

*** Description
Like switch but for declarations/assignments.

*** Current State
- Token is recognized by lexer
- Not implemented in parser/interpreter/typer

*** What's Needed
- [ ] Design match semantics (switch for expressions vs statements)
- [ ] Implement in parser
- [ ] Add type checking
- [ ] Add evaluation support
- [ ] Add test cases

*** Why It's Post-Self-Hosting
Switch statements work fine for now. This is a nice language feature but not essential.

** TODO Add Guards to Pattern Matching                                  :LOW:
:PROPERTIES:
:FILE: N/A
:STATUS: Not implemented, workaround exists
:END:

*** Description
Guards are boolean conditions attached to pattern match cases, allowing additional constraints beyond structural matching.

*** Current State - Workaround Works Fine
TIL uses if-statements inside case blocks, which provides equivalent functionality:

#+BEGIN_SRC til
describeNumber := func(n: I64) returns Str {
    switch n {
    case n:
        if lt(n, 0) { return "negative" }
        if eq(n, 0) { return "zero" }
        if lt(n, 10) { return "small positive" }
        return "large positive"
    }
}

// With enum pattern matching
describeColor := func(c: Color) returns Str {
    switch c {
    case Color.RGB(r, g, b):
        if and(eq(r, g), eq(g, b)) { return "grayscale" }
        if gt(r, 200) { return "reddish" }
        return format("RGB ", r.to_str(), " ", g.to_str(), " ", b.to_str())
    case Color.Named(name):
        return format("named ", name)
    }
}
#+END_SRC

*** Hypothetical Guard Syntax
If guards were added, they might look like:

#+BEGIN_SRC til
// Haskell-style with |
switch n {
case n | lt(n, 0): return "negative"
case n | eq(n, 0): return "zero"
case n | lt(n, 10): return "small positive"
case n: return "large positive"
}

// Or Rust-style with if
switch c {
case Color.RGB(r, g, b) if and(eq(r, g), eq(g, b)):
    return "grayscale"
case Color.RGB(r, g, b) if gt(r, 200):
    return "reddish"
}
#+END_SRC

*** Pros and Cons

*Pros of adding guards:*
- More concise for simple conditions
- Familiar to functional programmers
- Slightly more "pattern-matching-y"

*Cons / Why current approach is fine:*
- If-statements are more explicit and readable for imperative programmers
- No new syntax needed
- More flexible (can have multiple statements, not just boolean conditions)
- Doesn't enforce exhaustiveness checking on guards anyway

*** Priority
Very low. The if-statement workaround is actually clearer and more flexible than special guard syntax.

** TODO Implement Own Keyword for Function Arguments               :MEDIUM:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:IMPACT: Memory semantics, function ownership, borrow checking
:RELATED: Bug #24, pass-by-reference implementation, mode safe
:END:

*** Problem
After implementing pass-by-reference semantics (see pre.org), TIL has three argument modes:
- Default (immutable): Pass by reference, read-only
- mut: Pass by reference, mutable
- copy: Explicit copy, can modify without affecting caller ✅ IMPLEMENTED (Phase 2)

However, this still lacks move semantics for transferring ownership. The `own` keyword would enable:
1. Explicit ownership transfer (like Rust's move)
2. Zero-copy patterns for large structs
3. Foundation for future borrow checker (mode safe)

*** Proposed Solution
Add an `own` keyword for function arguments to indicate ownership transfer/move semantics:

#+BEGIN_SRC til
// Default (immutable reference - Phases 1-3 implementation)
read_struct := proc(s: MyStruct) {
    println(s.field.to_str())  // Can read, cannot modify
}

// Mutable reference (Phases 1-3 implementation)
modify_struct := proc(mut s: MyStruct) {
    s.field = 42  // Modifies caller's struct
}

// Copy (Phase 2 IMPLEMENTED ✅)
local_modify := proc(copy s: MyStruct) {
    s.field = 99  // Modifies local copy, caller unchanged
}

// Own keyword (POST self-hosting - REQUIRED for mode safe)
take_ownership := proc(own s: MyStruct) {
    // s is MOVED into this function
    // Caller can no longer use s after this call
    // Function can do anything with s (modify, consume, transfer)
    s.field = 42
    // No need to write back - we own it
}

// Own with mut (can modify the owned value)
consume_and_modify := proc(own mut s: MyStruct) {
    s.field = 42
    s.items.push(10)
    return s  // Can return owned value
}
#+END_SRC

*** Use Cases

*1. Consuming values:*
#+BEGIN_SRC til
delete_resource := proc(own r: Resource) {
    // Resource is moved in, caller can't use it anymore
    r.cleanup()
    r.delete()
}
#+END_SRC

*2. Builder patterns:*
#+BEGIN_SRC til
Builder := struct {
    with_field := func(own mut self: Builder, val: I64) returns Builder {
        self.field = val
        return self  // Move ownership back to caller
    }
}

// Usage: b := Builder().with_field(10).with_field(20)
#+END_SRC

*3. Transfer to other owners:*
#+BEGIN_SRC til
transfer_to_list := proc(own item: Item, mut list: List) {
    list.push(item)  // Ownership transferred to list
    // Caller's item is now invalid
}
#+END_SRC

*** Relationship to Mode Safe

The `own` keyword is **REQUIRED** for implementing "mode safe" with a borrow checker:

#+BEGIN_SRC til
mode safe  // Opt-in mode with compile-time borrow checking

dangerous_fn := proc(own data: Data) {
    spawn_thread(data)  // OK - we own it, can move to thread
}

safe_fn := proc(data: Data) {
    spawn_thread(data)  // ERROR: Cannot move borrowed value
}

mut_fn := proc(mut data: Data) {
    spawn_thread(data)  // ERROR: Cannot move mutable borrow
}
#+END_SRC

Without `own`, the borrow checker cannot distinguish between:
- Borrowed references (must return to caller)
- Owned values (can be consumed/moved)

*** Benefits
- Explicit ownership transfer like Rust's move semantics
- Enables zero-copy patterns for large structs
- Makes value lifecycle explicit and compiler-verifiable
- Foundation for mode safe borrow checking
- Prevents use-after-move bugs at compile time

*** What's Needed
- [ ] Design own keyword semantics (move vs borrow)
- [ ] Update parser to recognize own in parameter lists
- [ ] Add is_owned field to Declaration
- [ ] Validate: own and copy mutually exclusive
- [ ] Implement ownership tracking in type checker
- [ ] Modify interpreter to handle moved values
- [ ] Add compiler errors for use-after-move
- [ ] Test with struct field modifications
- [ ] Document ownership model
- [ ] Design mode safe borrow checker (future)

*** Why It's Post-Self-Hosting
1. The three-mode system (immutable/mut/copy) from pre.org is sufficient for self-hosting
2. Own keyword requires sophisticated lifetime tracking
3. Mode safe borrow checker is a major undertaking
4. Self-hosting should work without move semantics initially

The `own` keyword would be a significant language enhancement that requires careful design and implementation, but it's essential for the long-term vision of safe concurrent programming.

** TODO Add Optional Error Handling Enhancements                    :MEDIUM:
:PROPERTIES:
:FILE: src/rs/typer.rs:1212, src/test/errors.til
:STATUS: Core system working, optional features could be added
:END:

*** Current State - Core System Working
Error handling is FULLY FUNCTIONAL:
- =throw= keyword works
- =throws= declarations work and are type-checked
- =catch= blocks work with multiple catch types
- Type checker enforces throws propagation
- All tests in =src/test/errors.til= pass

*** What Works Today
#+BEGIN_SRC til
// Throw and catch
MyError := struct { msg: Str = "error" }

risky := func() throws MyError {
    throw MyError()
}

safe := proc() {
    risky()
    catch (e: MyError) {
        println("Caught: ", e.msg)
    }
}
#+END_SRC

Working features:
- Throwing custom error types (any struct)
- Multiple catch blocks for different error types
- Throws propagation checking (must declare or catch)
- Error structs with fields

*** Optional Enhancements
See =src/test/errors.til= for detailed TODO examples with code.

**** 1. PanicError - Implicit Error Type
Currently =panic()= is special-cased but doesn't actually throw a catchable error.

Related: =exit()= is currently an ext_func (not ext_proc) because funcs need a way to
exit/panic without returning. This is a temporary solution until PanicError is implemented.
With PanicError, funcs could throw it implicitly, and exit() might become a proc.

#+BEGIN_SRC til
// Proposed: PanicError that doesn't need declaration
test_implicit_panic := proc() {
    panic(loc(), "Something went wrong")
    catch (err: PanicError) {
        // Can catch panics without declaring throws
        println("Caught panic: ", err.msg)
    }
}
#+END_SRC

**** 2. Result<T, E> Type (Rust-style)
Alternative to throws - explicit error handling in return type.

#+BEGIN_SRC til
Result := enum {
    Ok: T,
    Err: E,
}

safe_divide := func(a: I64, b: I64) returns Result<I64, DivideByZero> {
    if eq(b, 0) {
        return Result.Err(DivideByZero())
    }
    return Result.Ok(div(a, b))
}

// Use with pattern matching
result := safe_divide(10, 2)
switch result {
case Result.Ok(value):
    println("Result: ", value.to_str())
case Result.Err(err):
    println("Error dividing by zero")
}
#+END_SRC

**** 3. Rethrow Keyword
Currently must manually throw again.

#+BEGIN_SRC til
test_rethrow := proc() throws SomeError {
    risky_operation()
    catch (err: SomeError) {
        println("Logging error before rethrow")
        rethrow  // or: throw err
    }
}
#+END_SRC

**** 4. Try Operator (? in Rust)
Automatically propagate errors without explicit catch.

#+BEGIN_SRC til
parse_and_compute := func(s: Str) returns I64 throws ParseError, ComputeError {
    n := parse_number(s)?  // Auto-propagates ParseError
    result := compute(n)?  // Auto-propagates ComputeError
    return result
}
#+END_SRC

**** 5. Finally Blocks
Cleanup code that runs whether error is thrown or not.

#+BEGIN_SRC til
test_finally := proc() {
    resource := acquire_resource()
    try {
        use_resource(resource)
    }
    catch (err: ResourceError) {
        println("Error using resource")
    }
    finally {
        release_resource(resource)  // Always runs
    }
}
#+END_SRC

*** Why It's Post-Self-Hosting
The current throw/throws/catch system is complete and sufficient. These enhancements are nice-to-haves:
- PanicError would reduce boilerplate
- Result<T, E> provides explicit error handling (alternative style)
- Rethrow, try operator (?), and finally are convenience features
- Better backtraces improve debugging experience

All can be added after self-hosting without breaking existing code.

** TODO Implement Closures (Nested Function Capture)                 :MEDIUM:
:PROPERTIES:
:DISCOVERED: 2025-12-27
:IMPACT: Nested functions can capture variables from enclosing scope
:RELATED: Bug #50
:END:

*** Description
Allow nested functions to capture variables from their enclosing scope (closures).
Currently, nested functions must explicitly take all needed values as parameters.

*** Current State
The typer emits a todo_error when a nested function references outer scope variables:
"Closures are not supported yet. Pass 'varname' as a parameter instead."

*** Example
#+BEGIN_SRC til
// This currently fails with todo_error:
outer := func(x: I64) returns I64 {
    inner := func() returns I64 {
        return x  // ERROR: x is from outer scope
    }
    return inner()
}

// Workaround - pass as parameter:
outer := func(x: I64) returns I64 {
    inner := func(x: I64) returns I64 {
        return x  // OK: x is a parameter
    }
    return inner(x)
}
#+END_SRC

*** What's Needed
- [ ] Lambda lifting (add captured vars as hidden params) - simplest approach
- [ ] Or closure struct approach (pass struct with captured vars)
- [ ] Update ccodegen to handle captured variables
- [ ] Remove the todo_error from typer

*** Why It's Post-Self-Hosting
The workaround (explicit parameters) is functional and makes data flow explicit.
Closures are syntactic sugar that can be added after self-hosting.

** TODO Implement Macro System                                         :LOW:
:PROPERTIES:
:FILE: src/core/lexer.til:144, src/rs/lexer.rs:277
:STATUS: Token recognized, not implemented
:END:

*** Current State
- =macro= keyword recognized
- Comment says "Implement macro for real once we compile"
- No macro expansion implemented

*** What's Needed
- [ ] Design macro syntax and semantics
- [ ] Implement macro expansion in parser
- [ ] Add hygiene rules
- [ ] Test macro edge cases
- [ ] Document macro system

*** Why It's Post-Self-Hosting
Macros are a power feature but not needed for basic self-hosting.

** TODO Implement Default Keyword for Switch                           :LOW:
:PROPERTIES:
:FILE: src/core/lexer.til:157, src/rs/lexer.rs:290
:STATUS: Syntax preference
:END:

*** Current State
Using =case:= for default case, could use =default:= instead for more traditional syntax.

*** Action
- [ ] Decide on preferred syntax
- [ ] Update parser if changing
- [ ] Update all test cases
- [ ] Document in language guide

** TODO Support Struct Literals and Struct Instantiation with Arguments :LOW:
:PROPERTIES:
:FILE: src/rs/interpreter.rs:464, doc/literal_syntax.org
:END:

*** Current vs Desired

*Struct instantiation with arguments:*
- Current: =Vec2()= initializes with defaults, must set fields afterward
- Desired: =Vec2(10, 20)= initializes x and y directly

*Struct literals:*
- Current: Not supported
- Desired: =Vec2{x: 10, y: 20}= creates struct with named fields

*** Example Current Workaround
#+BEGIN_SRC til
Point := struct {
    mut x: I64 = 0
    mut y: I64 = 0
}

// Current approach
mut p := Point()
p.x = 10
p.y = 20

// Or with constructor function
Point := struct {
    // ...
    new := func(x: I64, y: I64) returns Point {
        mut self := Point()
        self.x = x
        self.y = y
        return self
    }
}
p := Point.new(10, 20)
#+END_SRC

*** What's Needed
- [ ] Design struct literal syntax (see doc/literal_syntax.org)
- [ ] Parse constructor call arguments: =Vec2(10, 20)=
- [ ] Parse struct literals: =Vec2{x: 10, y: 20}=
- [ ] Map arguments to struct fields
- [ ] Type check field types
- [ ] Handle default values for missing arguments
- [ ] Add test cases

*** Natural Follow-up: Struct Pattern Matching
Once struct literals exist, pattern matching on structs becomes a natural extension:

#+BEGIN_SRC til
switch point {
case Point{x: 0, y: 0}:
    return "origin"
case Point{x: _, y: 0}:
    return "on x-axis"  // _ for wildcard
case Point{x: 0, y: _}:
    return "on y-axis"
case Point{x: x, y: y}:
    return format("point (", x.to_str(), ", ", y.to_str(), ")")
}
#+END_SRC

This would complement the already-working enum pattern matching:
- [ ] Implement struct destructuring in patterns
- [ ] Add wildcard =_= for ignored fields
- [ ] Test with nested structs

*** Why It's Post-Self-Hosting
Current workaround (constructor functions, manual initialization) works fine. This is syntactic convenience.

* Type System Enhancements

** TODO Implement Cast Operations                                      :LOW:
:PROPERTIES:
:FILE: src/core/core.til:319
:END:

*** What's Needed
- [ ] Implement cast syntax
- [ ] Start with U8 to I64
- [ ] Expand to other type conversions
- [ ] Add type checking for valid casts
- [ ] Test cast operations

*** Current Workaround
Manual conversion functions work fine.

** TODO Add More Operators & Overloading                             :MEDIUM:
:PROPERTIES:
:FILE: src/core/core.til:324-326, src/core/core.til:385
:END:

*** What's Needed
- [ ] Rename add to i64_add or I64.add for consistency
- [ ] Implement remaining arithmetic operations
- [ ] Design operator overloading semantics (likely Python-style __add__ associated functions)
- [ ] Allow custom types to define operators
- [ ] Test operator precedence with overloads

*** Current State
Basic operators work. UFCS provides method-like syntax already.

*** Implementation Approach
Likely Python-style with special associated function names:
- =__add__= for +
- =__sub__= for -
- =__mul__= for *
- =__eq__= for ==
- etc.

** TODO Improve Type Checking Edge Cases                               :LOW:
:PROPERTIES:
:FILE: src/rs/typer.rs
:END:

*** TODOs in Rust Type System
- =src/rs/typer.rs:309= - "TODO: Check more type stuff"
- =src/rs/typer.rs:984= - "Check types for members inside structs too"
- =src/rs/typer.rs:1149= - "Default values could try to call procs"
- =src/rs/typer.rs:1168= - "Arguments of function call can also call procedures"
- =src/rs/init.rs:251= - "TODO: Handle enums too for TCustom"

*** Priority
These are edge cases that rarely come up. Can be addressed after self-hosting.

* Mode System Enhancements

** TODO Implement safe_script Mode                                   :MEDIUM:
:PROPERTIES:
:FILE: README.org:183-193, src/tests.til:20
:STATUS: Not implemented
:END:

*** Description
Like script mode but unsafe actions (non-whitelisted commands, file I/O) require user confirmation. Idea from Roc.

*** What's Needed
- [X] Design safe_script mode semantics
- [ ] Implement user confirmation prompts
- [X] Add whitelist for safe commands
- [X] Create hello_safe_script.til test case
- [X] Document safe_script mode in README
- [ ] Fix: current implementation can probably be bypassed with import

*** Why It's Post-Self-Hosting
This is a safety feature for running untrusted scripts. Not needed for self-hosting the compiler itself.

** TODO Implement pure Mode                                            :LOW:
:PROPERTIES:
:FILE: README.org:210-220
:STATUS: Not implemented
:END:

*** Description
Like lib but no proc declarations, calls, or imports. Ensures truly pure functional subset.

*** What's Needed
- [ ] Add mode validation for pure mode
- [ ] Reject proc declarations
- [ ] Reject proc calls
- [ ] Reject imports
- [ ] Add test cases
- [ ] Document pure mode

*** Why It's Post-Self-Hosting
This is for ensuring functional purity. Nice to have but not essential for self-hosting.

* Performance & Optimization

** TODO Performance Optimizations                                       :LOW:
:PROPERTIES:
:FILE: src/core/core.til:95
:END:

*** Current State
"Temporary optimization - many Array implementations slow"

*** What's Needed
- [ ] Profile array operations
- [ ] Optimize hot paths
- [ ] Consider better data structures
- [ ] Benchmark improvements

*** Why It's Post-Self-Hosting
Self-hosting doesn't need to be fast initially. Correctness first, speed later.

** TODO Optimize Memory Management                                      :LOW:
:PROPERTIES:
:FILE: src/rs/init.rs, src/rs/interpreter.rs
:END:

*** TODOs
- =src/rs/init.rs:1021= - "All args should be passed as pointers/references"
- =src/rs/interpreter.rs:1709= - "Simplify once we pass all args by reference"

*** What's Needed
- [ ] Analyze memory usage patterns
- [ ] Implement reference passing where appropriate
- [ ] Reduce unnecessary copies
- [ ] Test for correctness

*** Why It's Post-Self-Hosting
Current memory management works. Optimization can come later.

* Code Quality & Developer Experience

** TODO Better Error Messages                                        :MEDIUM:
:PROPERTIES:
:FILE: Multiple locations
:END:

*** Improvements Needed
- =src/rs/interpreter.rs:2545= - More detailed messages with backtraces for circular dependencies
- =src/rs/lexer.rs:451= - Print warning with unknown escaped characters
- =src/rs/typer.rs:1219= - Err(lang_error) here instead (better error propagation)

*** What's Needed
- [ ] Add source location tracking to more errors
- [ ] Implement stack traces for runtime errors
- [ ] Improve error message formatting
- [ ] Add suggestions for common mistakes

*** Why It's Post-Self-Hosting
Errors work. Better errors are quality-of-life improvements.

** TODO Code Quality Improvements                                       :LOW:
:PROPERTIES:
:FILE: Various
:END:

*** Refactoring TODOs
- =src/rs/init.rs:60= - Find better way than type_str.to_string()
- =src/rs/typer.rs:730, 747= - Move to init_context() - inner contexts not persisted
- =src/rs/init.rs:759= - Use Context.path for eval errors (don't refactor whole eval phase)

*** What's Needed
- [ ] Clean up code duplication
- [ ] Improve naming consistency
- [ ] Refactor complex functions
- [ ] Add more documentation

*** Why It's Post-Self-Hosting
Code works. Cleanliness is important but not blocking.

** TODO Improve Memory Error Handling                                   :LOW:
:PROPERTIES:
:FILE: src/core/core.til:110
:END:

*** Current State
Malloc returns 0 on failure instead of throwing error.

*** What's Needed
Use =throws= for memory operations instead of returning 0 from malloc.

*** Why It's Post-Self-Hosting
Current behavior is safe (null pointer detection). Better error handling can come later.

* Documentation & Testing

** TODO Add More Test Cases                                          :MEDIUM:
:PROPERTIES:
:FILE: Various test files
:END:

*** Areas Needing Tests
- Edge cases in type checking
- Complex pattern matching scenarios
- Error recovery behavior
- Memory edge cases

*** What's Needed
- [ ] Audit test coverage
- [ ] Add missing test cases
- [ ] Test error paths thoroughly
- [ ] Add fuzzing tests

** TODO Improve Documentation                                           :LOW:
:PROPERTIES:
:FILE: README.org, design_notes.org
:END:

*** What's Needed
- [ ] Complete language reference
- [ ] Add more examples
- [ ] Document all modes
- [ ] Explain design decisions
- [ ] Add contributor guide

* Feature Requests from TODO Comments

** TODO Support Other Number Types                                      :LOW:
:PROPERTIES:
:FILE: src/rs/parser.rs:72
:END:

"TODO: Support more kinds of numbers"

Currently only I64 supported. Could add:
- [ ] F64 (floating point)
- [ ] I32, I16, I8
- [ ] U64, U32, U16, U8
- [ ] BigInt for arbitrary precision

** TODO Allow Unset Default Values in Structs                           :LOW:
:PROPERTIES:
:FILE: src/rs/parser.rs:731
:END:

"TODO: Allow not setting default values in struct members"

Currently all fields need defaults. Could make them optional.

** TODO Better Import Caching                                         :MEDIUM:
:PROPERTIES:
:FILE: src/rs/init.rs:786
:END:

"TODO: Cached type should support import returning struct_def"

Type caching could be more sophisticated.

* Notes

** Why Defer These?
All items in this document are either:
1. Nice syntax improvements (tuples, negative literals)
2. Performance optimizations (not needed for correctness)
3. Advanced features (macros, additional modes)
4. Code quality improvements (better errors, cleaner code)
5. Documentation and testing enhancements

None of these block the ability to bootstrap the self-hosted interpreter.

** When to Tackle These?
After self-hosting is working:
1. First priority: Fix bugs found during self-hosted development
2. Second priority: Performance issues that make development slow
3. Third priority: Language features that improve code quality
4. Fourth priority: Nice-to-haves and polish

** Philosophy
Get self-hosting working first with the minimal feature set. Then iterate and improve from a position of having a working self-hosted compiler.

The self-hosted version can implement these features in til itself, which is part of the point of self-hosting!
