#+TITLE: Post-Self-Hosting Features and Improvements
#+AUTHOR: TIL Development
#+DATE: 2026-01-29
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section at the bottom.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features, improvements, and optimizations that can be
deferred until after self-hosting is achieved. These are not blocking the
self-hosted TIL interpreter but are planned for future development.

For bugs, see bugs.org. For language design decisions, see future.org.

* Open Issues

** Bug #90: Parser requires semicolon for bodyless func/proc definitions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Syntax ergonomics
:STATUS: Partially Fixed - final enhancement deferred
:END:

*** Description
The parser cannot determine where a function/proc definition ends when there
is no body. Previously required a semicolon as a terminator.

*** Initial Fix (2026-01-07)
Semicolons are now completely optional - skipped by the lexer as whitespace.
~ext_func~ and ~ext_proc~ require an empty body ~{}~ instead of a semicolon.

*** Step 2: Context-aware lookahead (planned for Issue #91)
Context-aware lookahead: after parsing ~func(args) returns T throws E~,
if the next token is NOT ~{~, treat as bodyless declaration. This removes
the ~{}~ requirement for ext_func/ext_proc AND enables function type
declarations for Issue #91 (first-class functions).
#+BEGIN_SRC til
single_print := ext_proc(s: Str)           // Just works without {}
BinaryOp := func(a: I64, b: I64) returns I64  // Function type declaration
#+END_SRC

*** Future syntax direction (longer-term)
Move the full function signature into the type position of declarations:
#+BEGIN_SRC til
my_func : func(a: I64) returns I64 = { return a.mul(2) }
my_type : func(a: I64) returns I64        // no initializer = type only
#+END_SRC
This unifies function declarations with the general ~name : Type = value~
pattern. See Issue #91 for details.

** Issue #104: TempleOS Support
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Platform support, tiny containers
:STATUS: Open
:RELATED: Issue #103 (mode gui), Bug #80, Bug #100
:END:

*** Description
Add TempleOS as a compilation target, producing HolyC instead of C.

*** Dependencies
- Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- Bug #100: Get rid of rstil (full self-hosting)

*** Implementation Options
1. *Preferred*: Add flag/option to ccodegen for HolyC output
   - HolyC is very similar to C, differences are minor
   - Avoids code duplication
2. *Alternative*: Separate holyccodegen.til
   - More work, harder to maintain

*** Motivation
- Partly for fun/flexing and, why not? Also to honor Terry's ideal language: HolyC
- Practical use: TempleOS is tiny, useful for minimal docker containers
- Integration with mode gui (Issue #103) for native TempleOS graphics

*** Why Post-Self-Hosting
Requires full self-hosting (Bug #100) and ccodegen parity (Bug #80).

** Issue #103: Mode GUI
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, graphical applications
:STATUS: Open
:RELATED: Issue #104 (TempleOS support), src/examples/hello_gui.til (untested draft)
:END:

*** Description
Add ~mode gui~ for graphical user interface applications.

*** Backend Strategy
- *Standard platforms*: Use raylib as the graphics backend
- *TempleOS*: Native HolyC graphics (see Issue #104)
- *Web*: Options to explore:
  - raylib + wasm compilation from C
  - Separate jscodegen.til with ~mode webgui~ importing mode html files
  - Decision deferred

*** Notes
- Draft exists in src/examples/hello_gui.til (untested, won't work yet)
- Keep API simple to maintain portability across backends
- TempleOS and raylib may have more features than needed; focus on common subset

*** Why Post-Self-Hosting
GUI is a nice-to-have feature that requires significant platform abstraction work.

** Issue #156: Implement match keyword (expression-based switch)
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Language ergonomics, expression-based control flow
:STATUS: Open - token recognized, not implemented
:FILE: src/rs/lexer.rs, src/core/lexer.til
:END:

*** Description
~match~ is like ~switch~ but returns a value (expression vs statement).

*** Example
#+BEGIN_SRC til
// switch - statement
switch x {
    case 1: do_something()
    case 2: do_other()
}

// match - expression, returns value
result := match x {
    case 1: "one"
    case 2: "two"
    case: "other"
}
#+END_SRC

Like Rust's ~let result = match x { ... }~.

*** Current State
- Token recognized by lexer
- Not implemented in parser/interpreter/typer

*** What's Needed
- [ ] Design match semantics (expression that returns value)
- [ ] Implement in parser
- [ ] Add type checking (all branches must return same type)
- [ ] Add evaluation support
- [ ] Add test cases

*** Why Post-Self-Hosting
Switch statements work fine. Match is syntactic convenience for when you
want the result of a case-based decision.

** Issue #155: Add Unicode support to TIL
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Internationalization, modern text handling
:STATUS: Open
:FILE: src/rs/lexer.rs
:END:

*** Problem
TIL currently does not support Unicode characters in source code. The lexer
panics when encountering multi-byte UTF-8 characters like checkmarks, emoji,
or non-ASCII text.

Example error:
: byte index 368 is not a char boundary; it is inside '...' (bytes 367..370)

*** Current Limitation
Until Unicode is supported:
- NO Unicode characters should be used anywhere in the project
- This includes: source code, documentation files, comments, test files
- Use ASCII-only characters (e.g., [PASS] instead of checkmark)

*** What Needs to be Fixed
- Update lexer.rs to handle UTF-8 character boundaries correctly
- Use Rust's ~chars()~ iterator instead of byte indexing where appropriate
- Add comprehensive Unicode tests
- Update documentation about supported character sets

*** Implementation Notes
- Implement proper UTF-8 handling in lexer
- Add Unicode test suite
- Consider which Unicode features to support (identifiers, strings, etc.)
- Update lexer.til to match lexer.rs changes

*** Why Post-Self-Hosting
ASCII-only is sufficient for self-hosting. Unicode is a nice-to-have for
internationalization and modern text handling.

** Issue #154: Template vs Dynamic compilation mode
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Binary size vs performance trade-off, embedded device support
:STATUS: Open
:RELATED: Issue #153 (Dynamic field/method access), Issue #111 (returns Dynamic)
:END:

*** Description
Currently TIL uses Dynamic internally for generic collections (Vec, Map, etc.) -
type erasure approach with one implementation that works for all types, checked
at runtime.

The vision: offer BOTH approaches via compiler flag, transparently to the user:
- ~--dynamic~ (or similar): Current behavior, type erasure, smaller binary
- ~--template~ (or similar): Rust-style monomorphization, specialized code per type

*** The Trade-off

| Mode     | Type checking | Binary size       | Performance |
|----------+---------------+-------------------+-------------|
| Dynamic  | Runtime       | Smaller (1 copy)  | Slower      |
| Template | Compile-time  | Larger (N copies) | Fast        |

*** User Experience
Same source code works either way:
#+BEGIN_SRC til
v := Vec.new(I64)
v.push(42)
#+END_SRC

With ~--dynamic~: One Vec implementation, runtime type info
With ~--template~: Specialized Vec_I64 generated, compile-time checks

The user doesn't change their code - the compiler flag decides.

*** Use Cases
- **Embedded devices**: Use ~--dynamic~ for limited flash, accept slower runtime
- **Performance-critical**: Use ~--template~ for speed, accept larger binary
- **Development**: Use ~--dynamic~ for fast compilation
- **Release**: Use ~--template~ for production performance

*** Why Post-Self-Hosting
This is a major compiler feature requiring:
- Template instantiation system
- Monomorphization pass
- Significant ccodegen changes
- Testing infrastructure for both modes

Current Dynamic-only approach works for self-hosting.

** Issue #122: Add regex support to standard library
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Essential for text processing, refactoring tools, code generators
:STATUS: Open
:END:

*** Description
Add regular expression support to TIL's standard library. The exact interface
is to be decided, but should be general enough to handle common use cases
while remaining simple to use.

*** Failed attempt: branch wip_122 (2026-01-21)
Commit b6d31a6a was merged to master but has a subtle bug:
- After ~make clean && make benchmark~: FAILS
- Without clean (incremental build): PASSES

Branch ~wip_122~ preserved for investigation.

*** Why Post-Self-Hosting
Regex is a library feature, not needed for self-hosting. Current string methods
(contains, starts_with, split) are sufficient.

** Issue #121: Directory traversal (readdir / walk)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Essential for file processing tools, build systems, code generators
:STATUS: Open
:END:

*** Description
Add functions to list directory contents and recursively traverse directory trees.
This is essential for writing tools that process multiple files.

*** Prior art

**** POSIX C (opendir/readdir/closedir)
#+BEGIN_SRC c
DIR *dir = opendir("src/");
struct dirent *entry;
while ((entry = readdir(dir)) != NULL) {
    printf("%s\n", entry->d_name);
}
closedir(dir);
#+END_SRC

**** Python os.walk
#+BEGIN_SRC python
for root, dirs, files in os.walk("src/"):
    for file in files:
        print(os.path.join(root, file))
#+END_SRC

**** Tsoding's C implementation
Reference: Tsoding's recent video on implementing directory traversal in C
using the POSIX API. Shows practical patterns for recursive traversal with
proper error handling.

*** Proposed API (TBD)
#+BEGIN_SRC til
// Option 1: Low-level POSIX-style
DirEntry := struct {
    mut name: Str = ""
    mut is_dir: Bool = false
}

readdir := ext_proc(path: Str) returns Vec throws IOError {
    // Returns Vec of DirEntry
}

// Option 2: Higher-level walk function
walk := proc(path: Str, callback: proc(Str)) throws IOError {
    // Recursively visits all files, calls callback with each path
}

// Option 3: Iterator-based (if TIL gets iterators)
walk_iter := proc(path: Str) returns DirIterator throws IOError {
    // Returns iterator over all files
}
#+END_SRC

*** Implementation notes
- Need ext_proc wrapping POSIX opendir/readdir/closedir
- Must handle . and .. entries (skip them)
- Need is_dir check (stat or d_type)
- Consider symlink handling
- Error handling for permission denied, not found, etc.

*** Use cases
- Build systems processing source files
- Code generators finding all .til files
- Test runners discovering test files
- Refactoring tools updating multiple files

*** Why Post-Self-Hosting
Directory traversal is a library feature, not needed for self-hosting.

** Optimization #51: Precomp doesn't propagate constants through function parameters
:PROPERTIES:
:DISCOVERED: 2025-12-19
:IMPACT: Missed compile-time optimizations, larger generated code
:STATUS: Open
:END:

*** Description
When a function is called with literal arguments, the parameters inside the
function body are not treated as compile-time constants, preventing constfolding.

*** Example
#+BEGIN_SRC til
test_equal := proc(s1: Str, s2: Str) {
    preffix := "\nPara "
    for_whom := preffix.concat(s1).concat(s2)  // NOT folded
    ...
}
test_equal("lo", "la")  // Called with literals
#+END_SRC

Even though ~test_equal("lo", "la")~ passes literals, inside the function:
- ~preffix~ is a literal -> comptime
- ~s1~, ~s2~ are parameters -> NOT comptime
- ~preffix.concat(s1)~ cannot fold because ~s1~ isn't comptime

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/examples/lolalalo.til
# Inspect gen/c/examples/lolalalo.c line 771:
# til_for_whom = til_concat(til_concat(til_preffix, til_s1), til_s2);
# Should be: til_for_whom = ((til_Str){(til_I64)"\nPara lola", 10});
#+END_SRC

*** Root Cause
In ~precomp_func_def~ (src/rs/precomp.rs:749):
#+BEGIN_SRC rust
is_comptime_const: false,  // Function args are not comptime constants
#+END_SRC

Function parameters are unconditionally marked as non-comptime, even when
the function is called exclusively with literal arguments.

*** Deeper Analysis (2025-12-26)

The core insight: *comptime-ness of parameters should be per-call, not per-function*.

#+BEGIN_SRC til
test_equal("lo", "la")      // s1, s2 SHOULD be comptime here
test_equal(get_input(), "la")  // s1 NOT comptime, s2 IS comptime
#+END_SRC

**** Why current design can't support this

1. *Original body discarded*: ~precomp_func_def~ transforms the body once at
   definition time. After transformation, the original untransformed body is gone.

2. *Parameters marked once*: At definition time, we don't know what arguments
   will be passed. So parameters are marked as non-comptime unconditionally.

3. *No per-call mechanism*: When a call like ~test_equal("lo", "la")~ is seen,
   we know the args are comptime, but the body was already transformed without
   that knowledge.

**** The architectural gap

#+BEGIN_EXAMPLE
Definition time:                    Call time:
  precomp_func_def                    precomp_fcall
    -> params: is_comptime=false        -> args are literals (comptime!)
    -> transform body                   -> but body already transformed
    -> discard original                 -> can't re-transform with comptime params
#+END_EXAMPLE

*** Potential Solution: Store Original Body + Per-Call Transformation

**** Step 1: Modify SFuncDef to preserve original body

#+BEGIN_SRC rust
pub struct SFuncDef {
    // ... existing fields ...
    pub body: Vec<Expr>,
    pub original_body: Option<Vec<Expr>>,  // NEW: preserved for per-call transform
}
#+END_SRC

**** Step 2: Per-call body transformation

When processing a function call, if any argument is comptime:
1. Look up the ~original_body~ (untransformed)
2. Create a scope where each param's comptime-ness matches the call arg's comptime-ness
3. Transform the original body in this new scope
4. Use/cache this specialized version for codegen

#+BEGIN_SRC rust
fn precomp_body_with_comptime_params(
    context: &mut Context,
    original_body: &[Expr],
    args: &[Declaration],
    call_args: &[Expr],
) -> Result<Vec<Expr>, String> {
    context.scope_stack.push(ScopeType::Function);
    for (i, arg) in args.iter().enumerate() {
        let is_comptime = is_comptime_evaluable(context, &call_args[i]);
        context.scope_stack.declare_symbol(arg.name.clone(), SymbolInfo {
            is_comptime_const: is_comptime,  // Per-call!
            // ...
        });
    }
    // Transform body with this call's parameter context
    // ...
}
#+END_SRC

**** Challenges

- *Multiple versions*: Different call sites may need different specialized bodies
- *Caching*: Need to cache by comptime pattern to avoid redundant transformation
- *Codegen*: Need to generate unique function names for each specialized version
- *Recursion*: Recursive functions need careful handling to avoid infinite loops

*** Workaround
None - this is an optimization issue, not a correctness bug. Code runs correctly
but with larger generated code and more runtime computation than necessary.

*** Related
- Bug #50 (Fixed): Similar pattern - both require per-call analysis instead of once-at-definition
- #51 is about per-call comptime-ness (precomp phase)
- #50 was about per-call variable capture (codegen phase) - now fixed by forbidding closures

*** Why Post-Self-Hosting
This is an optimization, not a correctness bug. Code works correctly but with
larger generated code and more runtime computation than necessary.

** Issue #109: Proper Imports
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Language feature, code organization, namespace control
:STATUS: Open
:RELATED: Issue #108 (Implement Namespaces)
:END:

*** Python Reference
#+BEGIN_SRC python
import os                            # import module as namespace
import os as operating_system        # import module with alias

from os import path, getcwd          # import specific items
from os import path as p             # import specific item with alias

from os import *                     # import all (discouraged)

from . import sibling                # relative imports
from .. import parent
from ..package import module
#+END_SRC

*** Current State
~import("module")~ imports everything into current namespace (like Python's ~from os import *~).

*** Priorities

A. *Namespaced imports*
   #+BEGIN_SRC til
   import("os")              // from os import *
   getcwd()                  // getcwd() - directly available
   #+END_SRC

   #+BEGIN_SRC til
   os := import("os")        // import os
   os.getcwd()               // os.getcwd()
   #+END_SRC

B. *Selective imports*
   Could save significant precomp/scavenger time by not loading everything.
   #+BEGIN_SRC til
   import("numpy", "array", "zeros")  // from numpy import array, zeros
   array()                            // array()
   zeros()                            // zeros()
   #+END_SRC
   Uses variadic arguments. Syntax may change as we cover more Python cases.

C. *Namespaced + selective (TIL-specific, no Python equivalent)*
   #+BEGIN_SRC til
   np := import("numpy", "array", "zeros")
   np.array()
   np.zeros()
   #+END_SRC
   Combines A and B: namespaced access but only selected items and their own internal dependencies, recursively, are loaded.

D. *Direct member access*
   #+BEGIN_SRC til
   Lexer := import("src/core/lexer").Lexer
   my_lexer := Lexer.new("file.til")
   #+END_SRC
   Access single member from import result without loading entire namespace.

E. *Destructuring syntax (alternative to B)*
   #+BEGIN_SRC til
   {Lexer, Token} := import("src/core/lexer")
   #+END_SRC
   Similar to Python's ~from lexer import Lexer, Token~ but with destructuring.
   Alternative to variadic syntax in B - needs decision on preferred approach.

*** Future (lower priority)

These Python cases still need TIL equivalents:
- ~import os as operating_system~ - module alias
- ~from os import getcwd as cwd~ - item alias
- ~from . import sibling~ - relative imports (collides with current dot syntax for multiplatform, needs thought)

*** Implementation Notes
- Import result is struct-like: declarations accessed like struct fields
- Requires Issue #108 (namespaces) to be partially complete - import returns namespace object
- Type checker needs to handle namespace types for dot access
- Scavenger benefits from selective imports (less to scan)

*** Why Post-Self-Hosting
Current ~import("module")~ works for self-hosting. Advanced import features are
syntactic conveniences that can wait.

* Implemented Issues

(None yet - move issues here when implemented)
