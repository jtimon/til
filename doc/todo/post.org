#+TITLE: Post-Self-Hosting Features and Improvements
#+AUTHOR: TIL Development
#+DATE: 2026-01-29
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section at the bottom.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features, improvements, and optimizations that can be
deferred until after self-hosting is achieved. These are not blocking the
self-hosted TIL interpreter but are planned for future development.

For bugs, see bugs.org. For language design decisions, see future.org.

* Open Issues

** Issue #104: TempleOS Support
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Platform support, tiny containers
:STATUS: Open
:RELATED: Issue #103 (mode gui), Bug #80, Bug #100
:END:

*** Description
Add TempleOS as a compilation target, producing HolyC instead of C.

*** Dependencies
- Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- Bug #100: Get rid of rstil (full self-hosting)

*** Implementation Options
1. *Preferred*: Add flag/option to ccodegen for HolyC output
   - HolyC is very similar to C, differences are minor
   - Avoids code duplication
2. *Alternative*: Separate holyccodegen.til
   - More work, harder to maintain

*** Motivation
- Partly for fun/flexing and, why not? Also to honor Terry's ideal language: HolyC
- Practical use: TempleOS is tiny, useful for minimal docker containers
- Integration with mode gui (Issue #103) for native TempleOS graphics

*** Why Post-Self-Hosting
Requires full self-hosting (Bug #100) and ccodegen parity (Bug #80).

** Issue #103: Mode GUI
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, graphical applications
:STATUS: Open
:RELATED: Issue #104 (TempleOS support), src/examples/hello_gui.til (untested draft)
:END:

*** Description
Add ~mode gui~ for graphical user interface applications.

*** Backend Strategy
- *Standard platforms*: Use raylib as the graphics backend
- *TempleOS*: Native HolyC graphics (see Issue #104)
- *Web*: Options to explore:
  - raylib + wasm compilation from C
  - Separate jscodegen.til with ~mode webgui~ importing mode html files
  - Decision deferred

*** Notes
- Draft exists in src/examples/hello_gui.til (untested, won't work yet)
- Keep API simple to maintain portability across backends
- TempleOS and raylib may have more features than needed; focus on common subset

*** Why Post-Self-Hosting
GUI is a nice-to-have feature that requires significant platform abstraction work.

** Issue #156: Implement match keyword (expression-based switch)
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Language ergonomics, expression-based control flow
:STATUS: Open - token recognized, not implemented
:FILE: src/rs/lexer.rs, src/core/lexer.til
:END:

*** Description
~match~ is like ~switch~ but returns a value (expression vs statement).

*** Example
#+BEGIN_SRC til
// switch - statement
switch x {
    case 1: do_something()
    case 2: do_other()
}

// match - expression, returns value
result := match x {
    case 1: "one"
    case 2: "two"
    case: "other"
}
#+END_SRC

Like Rust's ~let result = match x { ... }~.

*** Current State
- Token recognized by lexer
- Not implemented in parser/interpreter/typer

*** What's Needed
- [ ] Design match semantics (expression that returns value)
- [ ] Implement in parser
- [ ] Add type checking (all branches must return same type)
- [ ] Add evaluation support
- [ ] Add test cases

*** Why Post-Self-Hosting
Switch statements work fine. Match is syntactic convenience for when you
want the result of a case-based decision.

** Issue #155: Add Unicode support to TIL
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Internationalization, modern text handling
:STATUS: Open
:FILE: src/rs/lexer.rs
:END:

*** Problem
TIL currently does not support Unicode characters in source code. The lexer
panics when encountering multi-byte UTF-8 characters like checkmarks, emoji,
or non-ASCII text.

Example error:
: byte index 368 is not a char boundary; it is inside '...' (bytes 367..370)

*** Current Limitation
Until Unicode is supported:
- NO Unicode characters should be used anywhere in the project
- This includes: source code, documentation files, comments, test files
- Use ASCII-only characters (e.g., [PASS] instead of checkmark)

*** What Needs to be Fixed
- Update lexer.rs to handle UTF-8 character boundaries correctly
- Use Rust's ~chars()~ iterator instead of byte indexing where appropriate
- Add comprehensive Unicode tests
- Update documentation about supported character sets

*** Implementation Notes
- Implement proper UTF-8 handling in lexer
- Add Unicode test suite
- Consider which Unicode features to support (identifiers, strings, etc.)
- Update lexer.til to match lexer.rs changes

*** Why Post-Self-Hosting
ASCII-only is sufficient for self-hosting. Unicode is a nice-to-have for
internationalization and modern text handling.

** Issue #154: Template vs Dynamic compilation mode
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Binary size vs performance trade-off, embedded device support
:STATUS: Open
:RELATED: Issue #153 (Dynamic field/method access), Issue #111 (returns Dynamic)
:END:

*** Description
Currently TIL uses Dynamic internally for generic collections (Vec, Map, etc.) -
type erasure approach with one implementation that works for all types, checked
at runtime.

The vision: offer BOTH approaches via compiler flag, transparently to the user:
- ~--dynamic~ (or similar): Current behavior, type erasure, smaller binary
- ~--template~ (or similar): Rust-style monomorphization, specialized code per type

*** The Trade-off

| Mode     | Type checking | Binary size       | Performance |
|----------+---------------+-------------------+-------------|
| Dynamic  | Runtime       | Smaller (1 copy)  | Slower      |
| Template | Compile-time  | Larger (N copies) | Fast        |

*** User Experience
Same source code works either way:
#+BEGIN_SRC til
v := Vec.new(I64)
v.push(42)
#+END_SRC

With ~--dynamic~: One Vec implementation, runtime type info
With ~--template~: Specialized Vec_I64 generated, compile-time checks

The user doesn't change their code - the compiler flag decides.

*** Use Cases
- **Embedded devices**: Use ~--dynamic~ for limited flash, accept slower runtime
- **Performance-critical**: Use ~--template~ for speed, accept larger binary
- **Development**: Use ~--dynamic~ for fast compilation
- **Release**: Use ~--template~ for production performance

*** Why Post-Self-Hosting
This is a major compiler feature requiring:
- Template instantiation system
- Monomorphization pass
- Significant ccodegen changes
- Testing infrastructure for both modes

Current Dynamic-only approach works for self-hosting.

* Implemented Issues

(None yet - move issues here when implemented)
