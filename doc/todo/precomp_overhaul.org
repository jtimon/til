* Precomp Overhaul Plan

*Design document:* See [[file:../precomp.org][doc/precomp.org]] for how precomp SHOULD work.

This file tracks the implementation work to make the code match the design.

* Bug #54 Fix Plan

** Bug #54 Summary (from doc/todo/bugs.org)

*Problem:* Pure functions with ~throws~ are not evaluated at compile time, even when called with literal arguments.

*Test file:* ~src/test/precomp_throw.til~ - expects precomp error when ~always_throws(5)~ is called (func throws ~Str~)

*Documented solution:* Remove the throw_types check that blocks all throwing functions. The existing ~eval_comptime~ already handles thrown exceptions and reports them as compile-time errors.

** Original Diff Summary

1. *~src/rs/precomp.rs~*:
   - Modified ~is_comptime_evaluable~: Instead of blocking ALL throwing functions, now only blocks those throwing ~AllocError~, ~IndexOutOfBoundsError~, or ~KeyNotFoundError~ (runtime-dependent errors)
   - Added U8 support in ~eval_comptime~

2. *~src/self/precomp.til~*:
   - Same change but only excludes ~AllocError~ (needs sync with Rust)
   - Already has U8 support

3. *~src/test/errors.til~*: Changed throwing funcs to procs to avoid precomp folding

4. *~src/test/u8.til~*: Changed literal to mut var to avoid precomp catching overflow

** Step 1: Restructure ~precomp_fcall~ into clean phases

*** Change A: Fix ~eval_comptime~ error handling [DONE]

Changed soft Err to ~lang_error~ for internal compiler bugs.

*** Change B: Restructure ~precomp_fcall~ into three phases [DONE]

Structure now follows interpreter more closely:
1. loc()/_file()/_line()/_col() intrinsics handled via ~try_replace_comptime_intrinsic~
2. import() handling
3. Struct/enum constructor handling (with template creation)
4. Recursive transform of args
5. Named arg reordering
6. UFCS transformation
7. Folding at global scope only

** Completed Changes So Far

*** precomp_declaration differences (from earlier work)
- Difference 1 & 2: Added ~let mut value_type~ and type validation block (U8/I64 coercion)
- Difference 3: Added TEnumDef handling before TStructDef
- Difference 4: Removed shadowed value_type re-computation
- Difference 5: Changed empty check to ~e.params.len() != 1~
- Import: Added ~value_type_to_str~ to imports
- Import: Changed to call ~proc_import~ directly instead of ~precomp_import_declarations~
- Removed unused ~precomp_import_declarations~ function and ~import_path_to_file_path~ import
- Temporarily removed ~til~ from ~tests~ dependencies in Makefile

*** precomp_fcall differences addressed
- *Difference B*: Added ~insert_struct_instance~ call for struct constructors in precomp_fcall
- *Difference A*: Reordered precomp_fcall to check struct/enum constructors BEFORE function lookup (matching eval_func_proc_call order)
- Added import of ~insert_struct_instance~ from interpreter module

*** Cleanup
- Removed all debug prints from builder.rs, interpreter.rs, precomp.rs

** NEW FINDING: ~is_comptime_evaluable~ is incomplete

The function ~is_comptime_evaluable~ (precomp.rs:180-260) is missing cases!

Current match:
#+begin_src rust
match &e.node_type {
    NodeType::LLiteral(_) => true,
    NodeType::Identifier(name) => { ... }
    NodeType::FCall => { ... }
    _ => false,  // <-- StructDef, EnumDef fall here!
}
#+end_src

*Missing cases that should return true:*
- ~NodeType::StructDef(_)~ - struct definitions are always comptime
- ~NodeType::EnumDef(_)~ - enum definitions are always comptime
- Struct literals like ~AllocError(msg="str")~ should also be comptime if args are comptime

*Debug output confirmed this:*
#+begin_example
DEBUG precomp_declaration: name=AllocError is_comptime_const=false value_type=TType(TStructDef)
#+end_example

AllocError is a struct definition - it SHOULD be comptime, but ~is_comptime_evaluable~ returns false because StructDef falls through to ~_ => false~.

This is a key difference between interpreter and precomp behavior that we weren't considering because we wrongly assumed ~is_comptime_evaluable~ was correctly implemented.

** Previous Problem: MAX_U8 value not in arena [FIXED]

Error was: ~i64 not found for id 'MAX_U8'~ at u8.til:52

*Root cause:* Import order - array.til imported before u8.til, so MAX_U8 wasn't stored yet.

*Fix:* Only fold at global scope. Inside function definitions, don't try to fold because
values from other modules may not be available yet. This matches interpreter behavior
(doesn't evaluate function bodies during import).

** Differences Between eval_func_proc_call and precomp_fcall

*** Difference A: Order - Struct constructors vs Import [DONE]
- *EVAL*: Checks struct constructor FIRST (line 840), before anything else
- *PRECOMP*: Now also checks struct/enum constructors first

*** Difference B: Struct constructor handling [DONE]
- *EVAL*: Calls ~insert_struct_instance~ (lines 866, 929) - actually creates instance in arena
- *PRECOMP*: Now calls ~insert_struct_instance~ for struct constructors

*** Difference C: Enum constructor handling [DONE]

*Bug found in ~is_comptime_evaluable~ (precomp.rs:215-233):*
- Struct constructors ARE handled - returns true if all args comptime
- Enum constructors were NOT handled - fell through to ~return false~

*Fix applied:* Added enum constructor handling after struct handling.

Error progressed from "MAX_U8 not found" to "template for 'Str' not found".

*** Difference D: Argument evaluation/transformation [TO DISCUSS]
- *EVAL*: Evaluates arguments AS NEEDED during struct/enum construction
- *PRECOMP*: Transforms arguments after struct/enum check but before function lookup

*** Difference E: loc() handling [DONE]

Created ~precomp_ext.rs~ with ~try_replace_comptime_intrinsic()~ that handles:
- ~loc()~ - returns "file:line:col:"
- ~_file()~ - returns file path
- ~_line()~ - returns line number
- ~_col()~ - returns column number

Changes made:
- NEW: src/rs/precomp_ext.rs - compile-time intrinsic replacements
- MODIFIED: src/rstil.rs - added ~pub mod precomp_ext~
- MODIFIED: src/rs/precomp.rs - uses ~try_replace_comptime_intrinsic~
- MODIFIED: src/rs/interpreter.rs - removed loc/_file/_line/_col dispatch (dead code)
- MODIFIED: src/rs/ext.rs - removed func_loc/func_file/func_line/func_col (dead code)

*** Difference F: Function dispatch for import [TO DISCUSS]
- *EVAL*: Looks up func_def, checks is_ext(), dispatches to eval_core_func_proc_call
- *PRECOMP*: Direct string comparison for "import", then proc_import

*** Difference G: Return type [EXPECTED]
- *EVAL*: Returns ~EvalResult~ (runtime value)
- *PRECOMP*: Returns ~Expr~ (transformed AST)
- This is inherent to precomp vs eval

*** Difference H: Template creation [DONE]

*Problem:* "template for 'Str' not found" at array.til:91

- *EVAL*: Creates templates via ~create_default_instance~ in ~eval_declaration~ when struct defs are processed
- *PRECOMP*: Did NOT create templates, so ~insert_struct_instance~ failed

*Fix applied:* Added ~create_default_instance~ call before ~insert_struct_instance~ in precomp_fcall.

** Investigation Approach
- Always feel free to add debug prints during investigation
- Remove debug prints before committing

** When Fixed - Don't Forget
- Restore ~til~ dependency in Makefile: ~tests: rstil til~

** Core Insight: What Makes Something Comptime?

(See [[file:../precomp.org][doc/precomp.org]] for full design. Summary below for reference.)

*The TYPE of a value does NOT determine if it's comptime. The VALUE and how it's computed does.*

What makes something NOT comptime-evaluable:
1. Depends on runtime values (function parameters, mut variables)
2. Has side effects (malloc, I/O, network)
3. Depends on runtime state (current time, random)

What does NOT matter:
- The type itself (I64, U8, Str, struct, enum - all can be comptime)
- The ~copy~ keyword (ownership semantics, not mutability)
- The ~own~ keyword (ownership semantics, not mutability)

Only ~mut~ affects whether a declaration is a constant (can be reassigned).
~copy~ and ~own~ are about ownership/transfer semantics, orthogonal to comptime-ness.

Examples:
- ~"hello"~ - comptime (string literal)
- ~Bool(value=1)~ - comptime if all fields are comptime
- ~copy x := 5~ - comptime (copy is about ownership, not mutability)
- ~own x := SomeStruct()~ - comptime if SomeStruct() args are comptime
- ~some_func(own SomeStruct(a=1))~ - comptime if func is pure
- ~AllocError := struct { ... }~ - comptime (type definition, static metadata)
- ~Color := enum { Red, Green, Blue }~ - comptime (type definition, static metadata)
- ~malloc(100)~ - NOT comptime (side effect, runtime state)
- ~mut x := 5~ - NOT comptime constant (can be reassigned)
- Function parameter ~x~ - NOT comptime (runtime value)

** Proposed Fix

*The ~is_supported_type~ restriction is artificial and should be REMOVED.*

Current broken logic:
#+begin_src rust
// WRONG: artificially restricts to I64/U8
let is_supported_type = matches!(&value_type,
    ValueType::TCustom(ref t) if t == "I64" || t == "U8"
);
let is_comptime_const = is_supported_type && ...
#+end_src

Correct logic:
#+begin_src rust
// RIGHT: only mut matters for constantness, copy/own are about ownership
let is_comptime_const = !decl.is_mut
    && is_comptime_evaluable(context, &new_params[0]);
#+end_src

*Also fix ~is_comptime_evaluable~ to handle all node types:*

#+begin_src rust
match &e.node_type {
    NodeType::LLiteral(_) => true,
    NodeType::StructDef(_) => true,   // ADD: type definitions are static metadata
    NodeType::EnumDef(_) => true,     // ADD: type definitions are static metadata
    NodeType::FuncDef(_) => true,     // ADD: func defs are static metadata
    NodeType::Identifier(name) => { ... }
    NodeType::FCall => { ... }        // Already handles struct constructors
    _ => false,
}
#+end_src

*Simplify declaration handling:*

Current precomp has 3 separate special cases that all call ~eval_declaration~:
- Lines 772-778: type definitions (structs)
- Lines 844-859: I64/U8 primitives (uses insert_primitive)
- Lines 862-879: struct instances

Interpreter just calls ~eval_declaration~ for everything. Precomp should do the same - for any comptime-evaluable declaration, just call ~eval_declaration~.

** Completed Code Changes

*** 1. Fix ~is_comptime_evaluable~ [DONE]
- Added ~NodeType::StructDef(_) => true~
- Added ~NodeType::EnumDef(_) => true~
- Added ~NodeType::FuncDef(_) => true~
- Added enum constructor handling (FieldAccess check for EnumType.Variant)

*** 2. Remove artificial type restrictions [DONE]
- Deleted ~is_supported_type~ variable
- Removed ~is_copy~ and ~is_own~ restrictions
- Changed to: ~let is_comptime_const = !decl.is_mut && is_comptime_evaluable(...)~

*** 3. Fix template creation (Difference H) [DONE]
- Added ~create_default_instance~ call before ~insert_struct_instance~ in precomp_fcall
- Added import of ~create_default_instance~ from interpreter module

*** 4. Fix global scope folding [DONE]
- Only fold at global scope (~scope_stack.frames.len() == 1~)
- Inside function definitions, values from other modules may not be available yet
- Matches interpreter behavior (doesn't evaluate function bodies during import)

*** 5. Store ALL comptime-evaluable declarations [DONE]
- Changed precomp_declaration to store I64/U8/Str when ~is_comptime_evaluable~ is true
- Removed dependency on ~is_comptime_const~ for storing (that's only for folding identifiers)
- Matches interpreter behavior which stores all primitive declarations

*** 6. Fix for-in loop variable declaration [DONE]
- Added code to declare loop variable in scope BEFORE processing body
- Loop body references the variable, so it must be declared first

*** 7. Fix eval_comptime for unsupported types [DONE]
- For enums and complex structs: eval_expr is called (catching errors)
- But if we can't convert result back to AST literal, return original expression
- This way errors are caught at compile time, but we don't fail on unconvertible types

** Current Test Status

ALL 68 TESTS PASS.

*** Previously Fixed Issues

**** test_parser.til and til.til - "Lexer.advance does not return anything" [FIXED]
- Error at parser.til:482
- Root cause: Old translation bug in parser.til - ~_ := lexer.advance(1)~ where ~advance~ doesn't return anything
- ~Lexer.advance~ is defined as ~func(mut self: Lexer, count: I64) throws Str~ (no return)
- Fix: Changed ~_ := lexer.advance(1)~ to just ~lexer.advance(1)~
- This pre-existing bug was exposed by the new Rust precomp changes (return type check in ~is_comptime_evaluable~)

**** interpreter.til - Similar ~_ :=~ bugs with EvalArena.insert_* [FIXED]
- ~EvalArena.insert_i64/u8/string~ are procs with no return - ~_ := ...~ was WRONG
- ~EvalArena.insert_enum~ returns ~EnumVal~ - ~_ := ...~ is CORRECT (kept as-is)
- Fixed: Removed ~_ :=~ from insert_i64/u8/string calls at lines 3005, 3007, 3009

**** introspections.til - moved to interpreted-only [FIXED]
- Was failing in compiled mode: linker error for ~til_Introspection_has_field~
- Root cause: ext_func in TIL but no C implementation in src/ext.c
- Rust implementation exists in src/rs/ext.rs (works interpreted)
- Fix: Moved from rs_common to rs_interpreted with TODO comment
- Updated doc/todo/introspection.org with correct file location and TODO status

**** bug41_test.til - Double output [FIXED]
- "DEBUG:hello from bug41 test" appeared twice
- Root cause: ~precomp_declaration~ was calling ~eval_expr~ for I64/U8/Str declarations
  even inside function bodies (no ~at_global_scope~ check)
- When processing ~result := print_debug("hello")~ in ~test_bug41()~ body:
  1. ~print_debug~ is a func that returns I64 and calls println (allowed in mode liba)
  2. ~is_comptime_evaluable~ returned true (pure func, literal arg)
  3. ~eval_expr~ was called to get value -> this ran ~print_debug~ at compile time!
  4. At runtime, ~print_debug~ ran again -> double output
- Fix: Added ~at_global_scope~ check before ~eval_expr~ calls in ~precomp_declaration~
  (same check as in ~precomp_expr~ for FCall folding)
- Also updated doc/precomp.org with design principle: if precomp evaluates a func,
  it MUST fold it, otherwise side effects run twice

** Next Steps

1. Port precomp.rs changes to precomp.til
2. Restore Makefile (~tests: rstil til~)
3. Update bugs.org, commit
