#+TITLE: TIL Self-Hosting Progress
#+AUTHOR: Self-Hosting Homologization Plan
#+DATE: 2025-01-10
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it

* Overview

Goal: Systematically homologize TIL implementations with Rust counterparts, working bottom-to-top through the compiler stack.

* Current Status Summary

| Component   | TIL Lines | Rust Lines | Completion | Status                       |
|-------------+-----------+------------+------------+------------------------------|
| lexer       |       712 |        517 | 100%       | ‚úÖ HOMOLOGIZATION COMPLETE  |
| parser      |     1,479 |      1,408 | 100%       | ‚úÖ TRANSLATION COMPLETE     |
| init        |     1,220 |      1,761 | 70%        | ‚è≥ TOP-DOWN IN PROGRESS     |
| typer       |       408 |      1,285 | 30%        | ‚è≥ TOP-DOWN IN PROGRESS     |
| interpreter |       585 |      2,485 | 24%        | ‚è≥ TOP-DOWN IN PROGRESS     |
|-------------+-----------+------------+------------+------------------------------|
| *TOTAL*     |     4,404 |      7,456 | *59%*      | Lexer & Parser Complete ‚úÖ  |

* Architecture & Call Hierarchy

#+BEGIN_EXAMPLE
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   COMPILATION PHASES                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                       ‚îÇ
‚îÇ  1. LEXER: scan_tokens(source) ‚Üí Array<Token>       ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  2. PARSER: parse_tokens(tokens) ‚Üí Expr (AST)       ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  3. INIT: process_declarations(ctx, ast)            ‚îÇ
‚îÇ     - Register funcs, enums, structs in context     ‚îÇ
‚îÇ     - Process imports (copy declarations only)       ‚îÇ
‚îÇ     - Build symbol table (no eval yet)              ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  4. TYPER: check_types(ctx, ast)                    ‚îÇ
‚îÇ     - Validate all types match                       ‚îÇ
‚îÇ     - Check return/throw statements                  ‚îÇ
‚îÇ     - Verify mode constraints                        ‚îÇ
‚îÇ     ‚Üì                                                 ‚îÇ
‚îÇ  5. INTERPRETER: eval_expr(ctx, ast)                ‚îÇ
‚îÇ     - Execute with arena memory management           ‚îÇ
‚îÇ     - Handle imports (eval imported code)            ‚îÇ
‚îÇ     - Runtime value computation                      ‚îÇ
‚îÇ                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#+END_EXAMPLE

** External Function Architecture (ext.rs ‚Üí ext.c)

*Current Implementation (Rust):*
- =src/rs/ext.rs=: Contains implementations of all built-in primitives
  - Functions like =func_malloc=, =func_add=, =func_lt=, =proc_print=
  - All functions prefixed with =func_= (pure) or =proc_= (side effects)
  - Functions are =pub= (not =pub(crate)=) for simplicity
- =src/rs/interpreter.rs=: Contains the dispatcher
  - =eval_core_func_proc_call=: Routes by name to ext.rs implementations
  - Uses Rust's =match= statement for dispatching

*TIL Mirror (for self-hosting):*
- =src/core/interpreter.til=: Contains TIL dispatcher (lines 595-652)
  - =eval_core_func_proc_call=: Mirrors Rust dispatcher using =switch=
  - Same case ordering and structure as Rust implementation
  - Currently has TODOs for extracting arguments from expr
  - Not yet wired up (ext functions called directly for now)

*Future Architecture (when self-hosted):*
- TIL code will call ext functions through the TIL dispatcher
- Compiled TIL will link to =ext.c= (C translation of ext.rs)
- No =ext.til= file will exist - these are built-in primitives, not TIL code
- The dispatcher in interpreter.til will become the active routing mechanism

*Key Design Decisions:*
1. *Dispatcher location*: Interpreter (routing logic) not ext (implementations)
2. *No ext.til*: These are primitives, not library code to be imported
3. *Naming convention*: All ext functions must start with =func_= or =proc_=
4. *Simplicity over Rust idioms*: Use =pub= not =pub(crate)=, avoid =crate::= prefix

* Critical Blockers

** All Enum-Related Blockers: ‚úÖ RESOLVED (2025-01-10)

All blockers related to enum payloads, enum returns, and pattern matching have been resolved:

*** BLOCKER #1: Enum Payload Extraction Bug ‚úÖ RESOLVED
- *Status*: FIXED - Pattern matching with enum payloads works correctly
- *Fix*: Switch pattern matching already worked, just needed proper testing

*** BLOCKER #2: Enum Return Value Handling ‚úÖ RESOLVED (Bug #7)
- *Status*: FIXED - Functions can now return enums with payloads correctly
- *Symptom*: "range end index out of bounds" when returning enums from functions
- *Fix*: interpreter.rs:1761-1786 - Transfer temp_enum_payload from function to caller context
- *Commit*: 05dd5c9
- *Impact*: Parser homogenization can now proceed

*** BLOCKER #3: Tagged Union Support ‚úÖ RESOLVED
- *Status*: FIXED - Tagged unions work, just needed to uncomment
- *Fix*: Enum payload extraction via switch already working in rstil

** Remaining Blocker: Complex Type Serialization ‚ö†Ô∏è
- *File*: =init.til= line 39
- *Impact*: Cannot store SFuncDef, SEnumDef, SStructDef in maps
- *Priority*: MEDIUM (not blocking parser homogenization)
- *Fix*: Implement struct/enum serialization
- *Note*: Can work around with string serialization for now

* Component Details

** Lexer (lexer.til vs src/rs/lexer.rs)
*** Status: FUNCTIONAL PARITY ‚úÖ - HOMOLOGIZATION COMPLETE ‚úÖ

*TIL Implementation (712 lines):*
- Full token scanning with nested comments
- String escape sequences (including =\0=)
- Reserved word scanning
- Dotted number support (fractional parts)
- Error handling for unterminated strings/comments
- Comprehensive lexical error reporting
- Helpful error messages for forbidden keywords (fn, const, var, try)

*Functional Equivalence (2025-01-08):*
- Both lexers produce identical tokens
- Both handle all keyword types correctly
- Both provide helpful error messages for forbidden keywords
- Enum organization aligned (Case in flow control, Try in errors)
- No functional differences remain

*Remaining Differences (Non-Functional):*
- *Size*: TIL 712 lines vs Rust 517 lines (38% larger)
  - 67% of difference is verbosity (explicit if/switch vs pattern matching)
  - 33% of difference is TIL having more error message detail in some places
- *Style*: TIL uses explicit if/switch, Rust uses match expressions
- *Optimization opportunity*: TIL could be reduced to ~650 lines using better switch patterns

*Recommendation:*
- Direction: COMPLETE (functional parity achieved)
- Optional improvement: Reduce TIL verbosity using switch pattern matching
- Optional improvement: Backport remaining detailed error messages to Rust

*** Homologization Tasks - 46 Differences Found

*Phase 1: Functional Parity (COMPLETE)*
- [X] Fix enum organization (Case to flow control, Try to errors)
- [X] Add error message for 'try' keyword
- [X] Validate functional equivalence

*Phase 2: Critical Bugs (COMPLETE ‚úÖ)*
- [X] Fix line numbering (0-based vs 1-based) - Both now start at line 1
- [X] Fix column calculation +1 inconsistencies - Optimized: start_line_pos = sub(0,1), no +1 needed
- [X] Fix number token column (use start not pos) - TIL line 229
- [X] Fix TIL comment scanning bug (2 chars vs 1) - TIL line 336
- [X] Fix string token column (use start not pos) - TIL line 427
- [X] Fix identifier token column calculation - TIL line 450

Both lexers now use identical algorithms and produce byte-for-byte identical output.

*Phase 3: Code Quality (SHOULD FIX)*
- [X] Add path field to Rust Lexer struct
- [X] Add new_from_file constructor to Rust (matches TIL's new/new_from_src)
- [X] Standardize field name: `current` (was current_token in TIL)
- [X] Add print_lex_errors helper to Rust - TIL lines 677-685
- [X] Standardize error message ordering (NotEqual after EqualEqual)
- [X] Fix grammar: "have" ‚Üí "has" in ext_func comment
- [X] Add token_type_to_str helper to both (better error messages)
- [X] Standardize whitespace handling comments
- [ ] Resolve todo_error method (comment #5)
- [ ] Investigate string escape TODO comment (TIL line 446)

*Phase 4: Optimization (OPTIONAL)*
- [ ] Reduce TIL verbosity using switch pattern matching
- [ ] Consider string escape switch in Rust (TIL lines 394-415)

** Parser (parser.til vs src/rs/parser.rs)
*** Status: ‚úÖ TRANSLATION COMPLETE (2025-01-10)
*** Runtime Status: ‚è≥ TESTING IN PROGRESS (2025-01-10)

*Translation Completed:* 100% of parser.rs (1,408 lines) translated to parser.til (1,527 lines)

*TIL Implementation (1,527 lines):*
- ‚úÖ All data structures (ValueType, Declaration, NodeType, Expr, etc.)
- ‚úÖ All parse functions (parse_primary, parse_statement, parse_body, etc.)
- ‚úÖ Mode system (ModeDef, parse_mode, can_be_imported)
- ‚úÖ Function/proc/macro parsing with full type annotations
- ‚úÖ Enum and struct definition parsing
- ‚úÖ Control flow parsing (if/while/for/switch/catch)
- ‚úÖ Pattern matching and case expressions
- ‚úÖ Full expression parsing with method chaining
- ‚úÖ Public API: parse_tokens() entry point
- ‚úÖ All TODOs resolved
- ‚úÖ All type errors fixed (194 type errors ‚Üí 0)
- ‚úÖ Helper functions added (empty_expr_array, token_type_eq)
- ‚úÖ Fixed Array/Map/struct constructors to use proper dynamic initialization

*Key Translation Patterns:*
- Used `catch (err: Type)` syntax instead of Rust's try/catch
- Converted nested loops with manual continue flags
- Used `.to_str()` for I64 conversions
- Used `not()` function instead of `!` operator
- Renamed "returns"/"throws" variables to "return_types"/"throw_types" (keyword conflicts)
- Fixed TIL limitation: can't pass function return values (structs) directly as args
- All Expr.new_parse() calls now assign to variable first, then pass variable

*Runtime Testing Status (2025-01-10):*
- ‚úÖ 11 parser tests passing (10 lower-level + test_declarations)
- ‚ùå test_simple_expressions: memcpy error on 2nd test
- ‚ùå test_functions: Parse error "Expected statement, found returns"
- ‚ùå test_control_flow: memcpy error
- ‚ùå test_enums: Parse error "Expected statement, found }"
- ‚ùå test_structs: Parse error "Expected statement, found :"
- ‚ùå test_switch: Type error "Could not find function defintion"
- ‚ùå test_parse_file: Hangs (infinite loop)

*Critical Fixes Needed:*
1. Debug memcpy errors (likely in complex expression handling)
2. Fix parsing of function definitions, enums, structs
3. Fix infinite loop in parse_tokens for real files
4. Investigate type error in switch statement parsing

*Translation Timeline (2025-01-10):*
- Lines 1-747: Data structures, mode system, and basic parsing functions
- Lines 749-1408: Control flow, statements, and parse_tokens entry point
- All TODOs resolved (value_type_to_str payloads, struct Declaration extraction)
- Array/Map/struct constructor fixes
- Documentation cleaned up


** Init (init.til vs src/rs/init.rs)
*** Status: 70% COMPLETE - TOP-DOWN IN PROGRESS ‚è≥ (2025-01-09)

*TIL Implementation (1,220 lines):*

*‚úÖ COMPLETED (2025-01-09):*
- Struct alignment: SymbolInfo.value_type now uses ValueType enum
- Struct alignment: EnumVal.payload_type added (matches Rust)
- Function ordering: First 3 functions match Rust order
  1. =get_func_name_in_call= ‚úÖ
  2. =value_type_func_proc= ‚úÖ
  3. =get_ufcs_fcall_value_type= ‚úÖ
- =init_context= skeleton with TODO() placeholders (top-down approach)
- Declaration processing skeleton in =init_context=
- Context struct with all fields (arena, symbols, funcs, enum_defs, struct_defs, imports)
- Arena methods: =get_i64=, =get_str=, =get_bool=, =get_u8=, =insert_*= (simplified)
- Enum helpers: =get_variant_pos=, =variant_pos_to_str=
- Type helpers: =get_type_size=, =get_func_name_in_call=
- Type inference: =get_value_type= (literals, funcdefs, enums, structs, ranges, identifiers)
- Type inference: =get_fcall_value_type= (UFCS, standalone funcs, constructors)

*‚ö†Ô∏è PARTIALLY IMPLEMENTED:*
- =get_fcall_value_type=: needs SFuncDef parsing from storage
- =get_value_type= identifier handling: needs SymbolInfo parsing
- Struct methods: =map_instance_fields=, =copy_fields=, =insert_struct=
- Enum methods: =get_enum=, =insert_enum=, =get_enum_at_offset=

*‚ùå NOT IMPLEMENTED:*
- =init_import_declarations=: needs file I/O, lexing, parsing, recursive imports
- Complex type serialization: SFuncDef, SEnumDef, SStructDef storage
- Full struct size calculation with nested structs
- Proper string storage (c_string/cap/len structure)
- Mode validation
- Associated function registration for structs

*KEY LIMITATION (from line 39):*
#+BEGIN_QUOTE
Currently storing complex types (SFuncDef, SEnumDef, SStructDef) as placeholder strings
in maps. Full equivalence requires either JSON serialization or direct object storage.
#+END_QUOTE

*Recommendation:*
- Direction: Rust ‚Üí TIL (most work needed here)
- *Critical blocker*: Struct serialization to StrMap (BLOCKER #2)
- *Priority*: Implement proper struct storage before proceeding
- *Dependencies*: This blocks interpreter and typer progress

*** Homologization Tasks (Top-Down Approach)

*Phase 1: Struct Alignment (COMPLETE)*
- [X] Align SymbolInfo struct to use ValueType
- [X] Align EnumVal struct (add payload_type field)

*Phase 2: Function Reordering (IN PROGRESS)*
- [X] Move get_func_name_in_call to line 560
- [X] Move value_type_func_proc to line 597
- [X] Move get_ufcs_fcall_value_type to line 619
- [ ] Continue reordering remaining functions to match Rust

*Phase 3: Top-Down Implementation with TODO() (IN PROGRESS)*
- [X] Create init_context skeleton with TODO() placeholders
- [X] Add Declaration processing skeleton
- [ ] Fill in Declaration: function registration
- [ ] Fill in Declaration: enum registration
- [ ] Fill in Declaration: struct registration
- [ ] Fill in Declaration: type checking
- [ ] Add import handling
- [ ] Add mode validation
- [ ] Complete remaining helper functions

*Phase 4: Serialization (BLOCKED)*
- [ ] Design serialization format for SFuncDef, SEnumDef, SStructDef
- [ ] Implement to_string/from_string for complex types
- [ ] Update maps to store actual type info (not placeholders)

** Typer (typer.til vs src/rs/typer.rs)
*** Status: 30% COMPLETE - TOP-DOWN IN PROGRESS ‚è≥ (2025-01-09)

*TIL Implementation (408 lines):*

*‚úÖ COMPLETED (2025-01-09):*
- =check_types= skeleton with TODO() placeholders (matches Rust signature)
- Returns Array of error strings (not throws)
- NodeType.Body: Recursively processes all statements
- NodeType.Return/Throw: Recursively checks values
- NodeType.Literal/DefaultCase/Pattern: No-op (already validated)
- Uses pattern matching on NodeType enum (benefits from parser homologization)

*‚è≥ TODO PLACEHOLDERS (incremental implementation):*
- =check_enum_def= (enum payload validation)
- =check_struct_def= (struct field validation)
- =check_if_statement= (condition must be Bool)
- =check_while_statement= (condition must be Bool)
- =check_switch_statement= (switch value + case type matching)
- =check_range= (start/end types must match)
- =check_fcall= (function call validation)
- =check_func_proc_types= (function body validation)
- =check_declaration= (declaration type checking)
- =check_assignment= (assignment type checking)
- =check_catch_statement= (catch type validation)

*Old Implementation (being replaced):*
- Basic =check_types= dispatcher
- =check_if_statement= (condition must be Bool)
- =check_while_statement= (condition must be Bool)
- =check_range= (both sides must match)
- =check_identifier= (symbol exists)
- =check_declaration= (type inference, symbol registration)
- =check_assignment= (mutability checking)
- Stub functions for: =check_fcall=, =check_func_def=

*‚ùå Missing (compared to Rust's 1,285 lines):*
- Actual function call type checking implementation
- Function definition validation
- Switch statement type checking
- Struct definition type checking
- Enum definition validation
- Mode constraint checking (lib/pure/script/etc)
- Catch statement validation
- Variadic argument handling

*Recommendation:*
- Direction: Rust ‚Üí TIL (massive gap)
- *Status*: This is the WEAKEST component
- *Priority*: HIGH - implement from Rust after init.til is complete
- *Dependencies*: Requires working init.til with proper type storage

*** Homologization Tasks
- [ ] Wait for init.til completion (DEPENDENCY)
- [ ] Port check_fcall implementation from typer.rs
- [ ] Port check_func_def validation
- [ ] Implement check_declaration fully (not just stub)
- [ ] Implement check_assignment fully (not just stub)
- [ ] Port check_switch_statement
- [ ] Port check_catch_statement
- [ ] Port check_struct_def
- [ ] Port check_enum_def
- [ ] Port mode constraint checking
- [ ] Port variadic argument handling
- [ ] Test against Rust typer output
- [ ] Mark complete

** Interpreter (interpreter.til vs src/rs/interpreter.rs)
*** Status: TOP-DOWN IN PROGRESS ‚è≥ (24% complete)

*TIL Implementation (585 lines):*

*Approach:* Top-down skeleton with TODO() placeholders (safe incremental implementation)

*‚úÖ Implemented:*
- =EvalResult= struct (lines 24-59)
  - Corresponds to =EvalResult= in interpreter.rs
  - Handles normal values, returns, and throws
  - Constructor methods: =new()=, =new_return()=, =new_throw()=
- =eval_expr= cornerstone function (lines 64-171)
  - Pattern matching on =NodeType= using switch
  - Literal evaluation fully implemented (Bool, I64, String, List)
  - All other cases have TODO() placeholders
- =Arena= struct for memory management (lines 9-20)

*üî® TODO Placeholders (to be filled incrementally):*
- Body evaluation
- Function calls (eval_func_proc_call)
- Declarations
- Assignments
- Identifiers
- Control flow (if, while, switch)
- Pattern matching
- Binary/comparison operations
- Struct instantiation and field access
- Enum construction
- Array operations
- Return/throw handling
- Catch blocks
- Import evaluation
- External function calls

*Key Insight:*
Using =TODO(loc(), "message")= from std.til allows tests to keep passing while building out functionality incrementally. This is much safer than trying to implement everything at once.

*Next Steps:*
1. Fill in eval_body (most frequently used)
2. Fill in eval_func_proc_call (critical for any code)
3. Continue with other cases based on test coverage needs

*** Homologization Tasks
- [X] Add EvalResult struct matching Rust
- [X] Create eval_expr skeleton with pattern matching
- [X] Implement literal evaluation
- [ ] Implement eval_body
- [ ] Implement eval_func_proc_call
- [ ] Implement eval_declaration
- [ ] Implement eval_assignment
- [ ] Implement eval_identifier
- [ ] Implement binary operations (add, sub, mul, div, mod)
- [ ] Implement comparison operations (lt, gt, eq, ne, le, ge)
- [ ] Implement control flow (if, while, switch)
- [ ] Implement struct instantiation and field access
- [ ] Implement enum construction and pattern matching
- [ ] Implement array operations
- [ ] Implement return/throw handling
- [ ] Implement catch blocks
- [ ] Implement import evaluation
- [ ] Implement external function calls
- [ ] Test exhaustively
- [ ] Mark complete

* Overall Timeline (21 weeks)

** Week 1: Lexer Homologization - IN PROGRESS ‚ö†Ô∏è
- [X] Create tracking document (this file)
- [X] Fixed enum organization (Case, Try)
- [X] Added error message for 'try' keyword
- [X] Validated functional equivalence
- [X] Deep comparison analysis (46 differences found)
- [ ] Fix 6 critical bugs (line/column calculations)
- [ ] Fix 7 code quality issues
- [ ] Complete homologization (implementations nearly identical)

** Weeks 2-4: Fix Critical Blockers
- [ ] BLOCKER #1: Fix enum payload extraction bug
- [ ] BLOCKER #3: Fix tagged union support in parser
- [ ] Test fixes thoroughly

** Week 5: Parser Homogenization - NEXT PRIORITY üî•
- [X] Parser divergence discovered during analysis (2025-11-09)
- [X] Bug #6 FIXED: Enum payloads now reserve max variant size (2025-01-09)
- [X] test_parser.til re-enabled: 13/18 tests passing (2025-01-09)
- [X] Comprehensive analysis completed - found missing infrastructure (2025-01-09)
- [X] Updated plan with Phase 0 and new time estimate (2025-01-09)
- [ ] NEXT UP: Execute updated homogenization plan (~5 days, 37 hours)
- [ ] Direction: Rust ‚Üí TIL (parser.rs is source of truth)
- [ ] Phase 0: Add Mode system, parse_tokens(), func_proc_returns/throws (~6h)
- [ ] Phases 1-3: Fix data structures and parse functions (~19h)
- [ ] Phases 4-5: Cleanup and validation (~12h)
- [ ] Validate structural equivalence

** Weeks 6-10: Init Homologization (MAJOR WORK)
- [ ] Design struct serialization format
- [ ] Implement serialization functions
- [ ] Port init_import_declarations
- [ ] Complete struct methods
- [ ] Complete enum methods
- [ ] Implement string storage
- [ ] Test with complex types
- [ ] Mark init complete

** Weeks 11-13: Typer Homologization
- [ ] Port check_fcall implementation
- [ ] Port check_func_def validation
- [ ] Port full check_declaration/check_assignment
- [ ] Port check_switch/check_catch
- [ ] Port struct/enum checking
- [ ] Port mode constraints
- [ ] Test against Rust typer
- [ ] Mark typer complete

** Weeks 14-20: Interpreter Homologization (MASSIVE)
- [ ] Fix function dispatch
- [ ] Port eval_fcall
- [ ] Port binary operations
- [ ] Port comparisons
- [ ] Port struct operations
- [ ] Port enum operations
- [ ] Port control flow
- [ ] Port throw/catch
- [ ] Port imports
- [ ] Port arrays
- [ ] Test exhaustively
- [ ] Mark interpreter complete

** Week 21: Final Validation
- [ ] Re-enable tests_self_hosted.til (src/tests.til:9)
  - Fix type errors in lexer.til and parser.til
  - Ensure all self-hosted tests pass
- [ ] Re-enable test_lexer.til and test_parser.til (src/tests.til:44-46)
  - Fix lib mode import issues
  - Test lexer/parser as library imports
- [ ] Run comprehensive test suite
- [ ] Bootstrap test (compile TIL with TIL)
- [ ] Compare with Rust compiler output
- [ ] Fix discrepancies
- [ ] Update documentation
- [ ] *DONE: Self-hosting achieved!*

* Success Criteria

- [ ] All components at 100% parity with Rust
- [ ] TIL compiler can compile itself (bootstrap)
- [ ] tests_self_hosted.til passes completely
- [ ] All tests enabled and passing (currently 3 disabled)
- [ ] Identical output to Rust compiler on test suite
- [ ] All tests pass in both implementations
- [ ] This document shows 100% complete

* Improvements to Backport

** TIL ‚Üí Rust (Better in TIL)

1. *Better Error Messages* (lexer.til lines 605-670)
   - Helpful suggestions for common mistakes
   - "use 'func' instead of 'fn'"
   - "use 'mut' instead of 'var'"
   - More user-friendly than Rust version

2. *For Loop Desugaring* (parser.til lines 697-805)
   - TIL desugars =for i in 0..10 {}= to while loop in parser
   - Simpler for later phases to handle
   - Consider adopting in Rust

** Rust ‚Üí TIL (Missing in TIL)

1. *Complex Type Storage*
   - Rust stores SFuncDef, SEnumDef, SStructDef directly in HashMaps
   - TIL uses placeholder strings (init.til line 39 limitation)
   - *CRITICAL for progress*

2. *Complete Type Checking*
   - Rust has full typer.rs (1,285 lines)
   - TIL has minimal typer.til (336 lines)
   - Missing: fcall checking, struct validation, mode constraints

3. *Full Interpreter*
   - Rust has complete interpreter.rs (2,485 lines)
   - TIL has basic Phase 2 only (475 lines)
   - Missing: All complex operations, struct/enum support

* Notes

- Created: 2025-01-08
- Last Updated: 2025-01-08
- Status: Planning phase
- Next: Begin lexer homologization (Week 1)
