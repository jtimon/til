#+TITLE: Mandatory Method Requirements
#+AUTHOR: til Development
#+DATE: 2025-01-13

* Overview

Certain types in TIL must implement specific methods to ensure safety and consistency. This document tracks which methods are mandatory and when they're enforced.

* Mandatory Methods

** clone() - Required for Copy Parameters

*** When Required
Types passed to parameters declared with the 'copy' keyword must implement clone().

*** Implementation Location
- Type checker: src/rs/typer.rs (lines 346-383)
- Check happens during function call argument validation

*** Exemptions
- Primitive types: I64, U8, Bool, Str (trivially copyable)
- Types not in struct_defs (built-in types without struct definitions)

*** Error Message Format
"Cannot pass struct 'TypeName' to copy parameter 'param' of function 'func'.
 Reason: struct 'TypeName' does not implement clone() method.
 Suggestion: add 'clone := func(self: TypeName) returns TypeName { ... }' to struct 'TypeName'."

*** Signature
#+BEGIN_SRC til
clone := func(self: TypeName) returns TypeName
#+END_SRC

*** Example Implementation
#+BEGIN_SRC til
Vec := struct {
    mut ptr : I64 = 0
    mut _len : I64 = 0
    mut cap : I64 = 0

    clone := func(self: Vec) returns Vec throws AllocError {
        mut cloned := Vec()
        cloned.cap = self.cap
        cloned._len = self._len
        mut total_bytes := mul(self.cap, self.type_size)
        cloned.ptr = malloc(total_bytes)
        if NULL.eq(cloned.ptr) {
            throw AllocError.new("Vec.clone: malloc failed")
        }
        mut used_bytes := mul(self._len, self.type_size)
        memcpy(cloned.ptr, self.ptr, used_bytes)
        return cloned
    }
}
#+END_SRC

** len() - Required for Collection Types

*** When Required
Types that implement collection-like methods (push/get/set/insert/delete) must implement len().

*** Implementation Location
- Type checker: src/rs/typer.rs (in check_struct_def function)
- Check happens during struct definition validation

*** Detection Heuristic
A struct is considered "collection-like" if it has any of:
- push() method
- get() method
- set() method
- insert() method

Note: delete() is excluded as it's a cleanup method, not a collection operation.

*** Error Message Format
"Collection-like struct 'TypeName' has push()/get()/set() methods but no len() method.
 Reason: Collection types must provide a way to query their size.
 Suggestion: add 'len := func(self: TypeName) returns I64 { ... }' to struct 'TypeName'."

*** Signature
#+BEGIN_SRC til
len := func(self: TypeName) returns I64
#+END_SRC

*** Example Implementations
#+BEGIN_SRC til
Vec := struct {
    mut _len : I64 = 0
    mut cap : I64 = 0

    len := func(self: Vec) returns I64 {
        return self._len
    }
}

Map := struct {
    mut size : I64 = 0

    len := func(self: Map) returns I64 {
        return self.size
    }
}
#+END_SRC

*** Types That Already Comply
- ✅ Vec (src/core/core.til:626)
- ✅ Array (src/core/core.til:548)
- ✅ List (src/core/core.til:1068)
- ✅ Map (src/core/core.til:1031)
- ✅ Str (src/core/core.til:438)
- ✅ Bool (src/core/core.til:286)
- ✅ U8 (src/core/core.til:351)

** size() - Required for Collection Types

*** When Required
Types that implement collection-like methods (push/get/set/insert) must implement size().

*** Implementation Location
- Type checker: src/rs/typer.rs (lines 1321-1351, in check_struct_def function)
- Check happens during struct definition validation

*** Detection Heuristic
Same as len() - a struct is considered "collection-like" if it has any of:
- push() method
- get() method
- set() method
- insert() method

Note: delete() is excluded as it's a cleanup method, not a collection operation.

*** Error Message Format
"Collection-like struct 'TypeName' has push()/get() methods but no size() method.
 Reason: Collection types must provide their size in bytes.
 Suggestion: add 'size := func(self: TypeName) returns I64 { ... }' to struct 'TypeName'.
 Note: size() should return the total size in bytes, not element count (use len() for that)."

*** Signature
#+BEGIN_SRC til
size := func(self: TypeName) returns I64
#+END_SRC

Note: size() returns the total size in **bytes**, not element count. For element count, use len().

*** Example Implementations
#+BEGIN_SRC til
Vec := struct {
    mut _len : I64 = 0
    mut type_size : I64 = 0

    size := func(self: Vec) returns I64 {
        return mul(self._len, self.type_size)
    }
}

Map := struct {
    mut _size : I64 = 0
    mut key_type_size : I64 = 0
    mut value_type_size : I64 = 0

    size := func(self: Map) returns I64 {
        mut keys_size := mul(self._size, self.key_type_size)
        mut values_size := mul(self._size, self.value_type_size)
        return add(keys_size, values_size)
    }
}
#+END_SRC

*** Types That Already Comply
- ✅ Vec (src/core/core.til:630)
- ✅ Array (src/core/core.til:552)
- ✅ List (src/core/core.til:1072)
- ✅ Map (src/core/core.til:1036) - added in Phase 3

*** Notable Changes
- Map.size field renamed to Map._size to avoid conflict with size() method
- Documented field naming inconsistency in doc/todo/pre.org

* Implementation Status

** Phase 1: clone() for copy parameters ✅
- [X] Implemented introspection system (has_const, has_field)
- [X] Added check in typer.rs for copy parameters
- [X] All existing collection types have clone()
- [X] Tests pass
- [X] Committed: b427e02, 8cbcc77

** Phase 2: len() for collection types ✅
- [X] Add check in typer.rs check_struct_def function (lines 1281-1321)
- [X] Create test for missing len() error (src/test/tmp/test_len_mandatory.til)
- [X] Verify all existing types pass
- [X] Update this documentation
- [X] Commit changes (09cace7)

** Phase 3: size() for collection types ✅
- [X] Add check in typer.rs check_struct_def function (lines 1321-1351)
- [X] Add size() method to Map (renamed Map.size field to Map._size)
- [X] Create test for missing size() error (src/test/tmp/test_size_mandatory.til)
- [X] Verify all existing types pass
- [X] Update this documentation
- [X] Document field naming inconsistency in doc/todo/pre.org
- [X] Commit changes

** Future: Additional mandatory methods
- [ ] Consider other methods that should be mandatory
- [ ] Evaluate need for size() enforcement beyond collections

* Moving Functionality from Rust to TIL

** Semantic Difference: sizeof vs instance.size()

There are two different concepts of "size" in the system:

*** Struct Size (sizeof / get_type_size)
- **What**: Size of the struct's fields in memory
- **Where**: Rust's get_type_size() in src/rs/init.rs
- **Used for**: Field offset calculation, memory layout
- **Example**: Vec struct has 5 I64 fields = 40 bytes total
- **Constant**: Same for all instances of the type

*** Data Size (instance.size())
- **What**: Size of data the instance currently holds
- **Where**: TIL's size() method (mandatory for collections)
- **Used for**: Knowing how much data is stored
- **Example**: Vec with 10 I64 elements has size = 80 bytes
- **Variable**: Differs per instance based on contents

*** Current Status
- Added check in get_type_size() to detect if type has size() method (lines 1236-1248)
- TODO comment explains we can't directly use TIL's size() for struct size calculation
- Kept Rust fallback for calculating struct field sizes
- For now, these remain separate concepts with different purposes

* Notes

- Enforcement uses introspection (has_const) to check for method existence
- Methods must be consts (immutable fields of type FuncDef)
- Primitive types get special exemptions where appropriate
- Error messages include helpful suggestions with correct syntax
- All checks happen at type-check time, not runtime
