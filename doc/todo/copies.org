* Copy Analysis - All .get() sites in the TIL codebase
  Date: 2026-02-14

** Summary

| Metric              | Count |
|---------------------+-------|
| Total .get() calls  |  1225 |
| params.get() calls  |   290 |
| Total for-in loops  |   392 |
| Forward range loops |    45 |
| Reverse range loops |    14 |

Every .get() call performs a shallow memcpy copy. The for-in loops
(392 total) are already zero-copy after Bug #144.

** Categories of .get() calls

*** Category A: params.get(i, expr) -- 290 calls -- DONE (2026-02-14)

*CONVERTED to zero-copy*: Replaced with ~e.get(i)~ + ~dont_delete(var)~
across all 11 TIL self-hosted files. Uses get_by_ref + create_alias
(zero-copy pointer into collection storage, no memcpy).

These access child nodes of an Expr AST node. The copied type is
usually Expr (a large struct with heap pointers). Every compiler
phase uses these extensively.

| File                       | Count |
|----------------------------+-------|
| src/self/ccodegen.til      |   128 |
| src/self/typer.til         |    42 |
| src/self/desugarer.til     |    27 |
| src/self/parser.til        |    18 |
| src/self/garbager.til      |    16 |
| src/self/interpreter.til   |    12 |
| src/self/ufcs.til          |    11 |
| src/self/precomp.til       |    11 |
| src/self/init.til          |    10 |
| src/self/preinit.til       |     7 |
| src/self/builder.til       |     5 |
| src/test/ufcs.til          |     2 |
| src/test/test_parser.til   |     1 |

*** Category B: e.get(N)? shorthand -- ~200 calls -- DONE (2026-02-14)

*CONVERTED to zero-copy*: Same as Category A. ~e.get(N)~ now uses
get_by_ref + create_alias internally. All call sites have
~dont_delete(var)~ to prevent the garbager from freeing the alias.

These use the Expr helper method e.get(N) which returns an Expr
by value. Found extensively in:

| File                       | Approx |
|----------------------------+--------|
| src/self/ext.til           |    ~80 |
| src/self/typer.til         |    ~40 |
| src/self/interpreter.til   |    ~30 |
| src/self/init.til          |    ~20 |
| src/self/desugarer.til     |    ~15 |
| src/self/scavenger.til     |    ~15 |

*** Category C: self.frames.get(i, frame) -- ScopeStack lookups -- MOSTLY DONE (2026-02-16)

*CONVERTED to zero-copy*: 24 of 25 .get() calls + all 10 .set() calls converted
to get_by_ref + create_alias. Commits 40d2a579, 0cd9e119.

14 reverse loops: get_by_ref + create_alias (zero-copy pointer into Vec storage).
10 mutating last-frame operations: get_by_ref + create_alias, removed .set() copy-back.
1 forward loop (update_func): get_by_ref + create_alias, removed .set() copy-back.

**** last_frame (line 153) -- NOT YET CONVERTED

last_frame returns a ScopeFrame by value. The old generated C is very wasteful:
1. 5x Map_new() for default ScopeFrame constructor (all thrown away by Vec.get)
2. Vec_get memcpy into out
3. ScopeFrame_clone() deep clone (garbager-inserted)
4. *_ret = out shallow copy to caller

Converting to get_by_ref + create_alias should eliminate all of that, but is
blocked by the Bug #168 ret_var_alias optimization. The optimization maps the
return variable to _ret, but create_alias declares a separate pointer variable.
Result: _ret is never written (verified in gen/rs/c/til.c).

Why Expr.get (parser.til:459) works with the same pattern: self: Expr matches
return type Expr, disabling ret_var_alias via the "no parameter with same type
as return" check. For last_frame, self: ScopeStack != ScopeFrame, so ret_var_alias
activates. In the old code, the garbager's clone insertion was a reassignment that
disabled ret_var_alias; create_alias suppresses the clone (dont_delete_vars), so
nothing blocks the optimization.

Callers (all 7 in interpreter.til) only read heap_index.len() or iterate
heap_index.keys -- they never modify the frame. A borrowed view would suffice.

Possible fixes:
1. Add has_create_alias_of check to find_ret_var_for_placement (disables ret_var_alias
   when return var is a create_alias target). Still does a shallow copy via *_ret.
2. Change callers to use get_by_ref + create_alias directly on
   context.scope_stack.frames, bypassing last_frame entirely (true zero-copy).
3. Change ccodegen to generate pointer-typed caller variables when the returned
   value comes from create_alias + dont_delete (avoids even the shallow copy).

*** Category D: Map.get(key, val) -- ~100 calls

Map lookups that copy the value. Found in:

**** ScopeFrame map lookups -- NOT YET CONVERTED (same problem as last_frame)

- frame.symbols.get(name, symbol) -- copies SymbolInfo (lookup_symbol, lookup_symbol_in_enclosing_scope, remove_symbol)
- frame.funcs.get(name, func_def) -- copies SFuncDef (lookup_func)
- frame.enums.get(name, enum_def) -- copies SEnumDef (lookup_enum)
- frame.structs.get(name, struct_def) -- copies SStructDef (lookup_struct)
- frame.heap_index.get(name, offset) -- copies I64 (cheap, not worth converting)

These are inside lookup_symbol/lookup_func/lookup_enum/lookup_struct which all
RETURN the struct. Same ret_var_alias problem as last_frame: converting the
internal Map.get to get_by_ref + create_alias and returning the alias still
generates *_ret = (*alias_ptr) in C -- a full struct copy. The copy moves from
Map.get to the return statement, net savings zero.

Attempted 2026-02-16: converted all 6, added has_create_alias_of to
find_ret_var_for_placement (fix 1). Compiled and passed all 92 tests, but no
performance improvement. Reverted.

Same three fixes apply as for last_frame:
1. has_create_alias_of (fix 1) -- compiles but still copies via *_ret.
2. Inline: callers use frame.symbols.get_by_ref directly instead of calling
   lookup_symbol -- true zero-copy but duplicates lookup logic at every call site.
3. Codegen: generate pointer-typed caller variables when the returned value
   comes from create_alias (avoids even the *_ret copy).

Additional detail discovered during the attempt:
- Init phase (init.rs) can't resolve create_alias variables in declaration RHS.
  val_ref := frame.symbols.get_by_ref(name)? fails with "Undefined symbol 'frame'"
  because get_value_type (called for declarations) does lookup_symbol which doesn't
  find create_alias variables. Workaround: pre-declare mut val_ref := Ptr() then
  assign val_ref = frame.symbols.get_by_ref(name)? as a statement (not declaration).
  Statements don't go through get_value_type so the alias is found normally.

**** Struct/enum default value lookups -- IN PROGRESS (2026-02-16)

- struct_def.default_values.get(name, expr) -- copies Expr
- ns_def.default_values.get(name, expr) -- copies Expr

These are used IN-PLACE (not returned), so get_by_ref + create_alias genuinely
eliminates the copy. No ret_var_alias problem.

Converted: garbager.til (2 calls, commit ae117ca2)
Remaining: typer.til (5), ccodegen.til (7), interpreter.til (2),
  desugarer.til (2), scavenger.til (4), precomp.til (2), ufcs.til (2),
  preinit.til (1)
Not converting: init.til (~5 calls in register methods need ownership for switch)

Other map lookups:
- ctx.nested_func_names.get() -- copies Str (ccodegen.til)
- ctx.func_variadic_args.get() -- copies VariadicFCallInfo (ccodegen.til)
- ctx.local_catch_labels.get() -- copies CatchLabelInfo (ccodegen.til)
- context.imported_asts.get() -- copies Expr (init.til, typer.til, builder.til)
- g_heap.default_instances.get() -- copies I64 (cheap, eval_heap.til)
- local_types.get() -- copies Str (garbager.til)

*** Category E: Vec.get(i, val) on non-params Vecs -- ~200 calls

These copy elements from various Vec collections:

Struct/enum member iteration (MOSTLY CONVERTED to for-in, 2026-02-16):
- enum_def.variants.get(i, ev) -- copies EnumVariant
  Converted in: typer.til. Remaining: parser.til, eval_heap.til, desugarer.til
- struct_def.members.get(i, member) -- copies Declaration
  Converted in: garbager.til, preinit.til, eval_heap.til. None remaining.
- func_def.args.get(i, arg) -- copies Declaration
  Converted in: typer.til (validate_func_arg_count). Remaining: garbager.til, ufcs.til, precomp.til (use index)
- func_def.return_types.get(0, rt) -- copies ValueType
  Not converted (single element access, not a loop pattern).
  Found in: ccodegen.til, interpreter.til, init.til, scavenger.til, parser.til
- func_def.throw_types.get(i, tt) -- copies ValueType
  Converted in: scavenger.til. Remaining: ccodegen.til (uses index for numbering)
- func_def.body.get(i, stmt) -- copies Expr
  Converted in: preinit.til, desugarer.til, typer.til. None remaining.

Data structure internals:
- self.tokens.get(i, t) -- copies Token (lexer.til)
- parts.get(i, part) -- copies Str
- self._heap_bases.get(i, base) -- copies I64 (cheap, eval_heap.til)

Ccodegen-specific:
- nested_arg_strings.get(i, s) -- copies Str
- arg_strings.get(i, s) -- copies Str
- arg_temps.get(i, s) -- copies Str
- already_hoisted.get(i, s) -- copies Str
- field_values.get(name, s) -- copies Str

Test runner / tests.til:
- Various .get() on Vec of I64/Str for test results (~64 calls)
  Mostly copying I64 and Str (phase times, maxrss, paths)

*** Category F: g_heap.get(offset, size) -- raw heap reads -- ~25 calls

All in src/self/eval_heap.til and src/self/interpreter.til.
These are raw byte reads from the heap, not struct copies.
They return raw pointer data via memcpy. Different from the
struct-level .get() -- these are low-level memory operations
and cannot be converted to get_by_ref.

*** Category G: Collection internals -- ~10 calls

- hashmap.til: self.buckets.get(), self.nexts.get() -- copies I64 (cheap)
- list.til: self.type_sizes.get(), self.type_names.get() -- copies I64/Str
- vec.til: self.get(), v.get() -- copies element
- str.til: copies U8 (cheap)

These are inside the collection implementations themselves.

** Forward range loops (45 total, could convert to for-in)

Many of these use .get() inside the loop body and could potentially
be converted to for-in to avoid the copy.

*** Already convertible (forward, iterate full collection):

src/self/parser.til (8 loops):
- variants iteration (lines 65, 86, 97) -- over Vec of EnumVariant
- members iteration (line 260) -- over Vec of Declaration
- params iteration (lines 474, 522, 1173, 1256, 1349, 1522, 1859) -- over Vec of Expr

src/self/typer.til (9 loops):
- enum_def.variants (line 99) -- over Vec of EnumVariant
- e.params (lines 161, 482, 551, 1410, 3129) -- over Vec of Expr
- func_def.args (lines 410, 1230) -- over Vec of Declaration
- get_func.throw_types (line 684) -- over Vec of ValueType

src/self/desugarer.til (5 loops):
- e.params (lines 215, 239, 273, 290) -- over Vec of Expr
- transformed_body.params (line 1535) -- over Vec of Expr

src/self/garbager.til (3 loops):
- cand_vars (line 132) -- over Vec of Str
- func_def.args (lines 775, 1005) -- over Vec of Declaration

src/self/ccodegen.til (1 loop):
- func_def.throw_types (line 4339) -- over Vec of ValueType

src/self/interpreter.til (2 loops):
- statements (line 1623) -- over Vec of Expr
- e.params (line 3049) -- over Vec of Expr

src/self/init.til (2 loops):
- self.frames (line 391) -- over Vec of ScopeFrame (debug only)
- parts (line 2324) -- over Vec of Str

src/self/eval_heap.til (1 loop):
- self._heap_bases (line 110) -- over Vec of I64

src/self/ext.til (1 loop):
- e.params (line 879) -- over Vec of Expr

src/tests.til (1 loop):
- remaining_args (line 1456) -- over Vec of Str

src/test_runner.til (2 loops):
- file_path chars (line 179) -- over Str chars
- args (line 398) -- over Vec of Str

src/std/sys.til (1 loop):
- pattern chars (line 199) -- over Str chars

src/til_diff.til (1 loop):
- base_name chars (line 18) -- over Str chars

src/core/heap_state.til (2 loops):
- g_entries (lines 36, 58) -- over Vec of HeapEntry

src/core/str.til (3 loops):
- from chars (line 260) -- char-level iteration
- delimiter chars (line 468) -- char-level iteration
- args (line 687) -- over Vec of Str

*** Need index for non-iteration purpose:

Some forward loops use `i` for more than just indexing -- they use
it for position-dependent logic (e.g., skip first element, compare
adjacent elements). These need the index and can't trivially convert.

src/self/typer.til:482 -- `for i in 1..e.params.len()` (starts at 1)
src/self/typer.til:3129 -- `for i in 1..e.params.len()` (starts at 1)
src/self/desugarer.til:273 -- `for i in 1..e.params.len()` (starts at 1)
src/self/ext.til:879 -- `for i in 3..e.params.len()` (starts at 3)
src/tests.til:1456 -- `for i in 3..remaining_args.len()` (starts at 3)
src/test_runner.til:398 -- `for i in 5..args.len()` (starts at 5)

These would need either a .skip(N) method or manual handling.

** Reverse range loops (14 total, all in src/self/init.til)

All use pattern: `for i in self.frames.len().sub(1)..sub(0, 1)`
All copy ScopeFrame via `self.frames.get(i, frame)`

These CANNOT be converted to for-in without reverse iteration support.
Options:
1. Add get_by_ref to Vec (return Ptr, no copy)
2. Add reversed for-in (.rev() or similar)
3. Cache lookups to avoid repeated frame iteration

** Priority for optimization

1. *DONE* **params.get() / e.get()** -- 490 calls copying Expr
   Converted to zero-copy via get_by_ref + create_alias (2026-02-14).

2. *MOSTLY DONE* **ScopeStack frame iteration** -- 35 calls copying ScopeFrame
   24/25 .get() + 10 .set() converted to get_by_ref + create_alias (2026-02-16).
   1 remaining: last_frame blocked by Bug #168 ret_var_alias.

3. *IN PROGRESS* **Map.get() for default_values** -- ~27 calls copying Expr (in-place)
   Converted 2/27 in garbager.til (2026-02-16). Uses get_by_ref + create_alias.
   ScopeFrame map lookups (~6 calls) BLOCKED by ret_var_alias (same as last_frame).

4. *DONE* **Struct member/variant iteration** -- 15 loops converted (2026-02-16)
   Converted to for-in (zero-copy) in typer, preinit, garbager, eval_heap,
   scavenger, desugarer. Commit c47c3ea0.
   ~15 remaining loops use index for non-.get() purposes (skipped).

5. **Everything else** -- copies of Str, I64, ValueType
   Low priority, small types, cheap copies.
