#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [-] Issue #82: make.til - Replace Makefile with TIL (partial: make.til works, go_build_yourself added, Makefile reduced to bootstrap only)
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [-] Issue #91: First-Class Functions (FunctionSig + function pointers done, closures/collections next)
- [X] Bug #92: Range loops should allow explicit iterator type annotation (Fixed 2026-01-29)
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Fixed. Variable shadowing now works via name mangling in C codegen.

** Issue #187: Integrated profiling for self-hosted compiler
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Developer experience, performance debugging
:STATUS: Open
:RELATED: Issue #183 (memory reduction), Bug #165 (memory leak)
:END:

*** Problem

The self-hosted TIL compiler uses 5-8 GB of memory per test in interpreted mode
and build times are measured in minutes. There is no way to know where the time
or memory is going without external tools and guesswork. Every optimization
attempt (Issue #183, Bug #165) involves blind changes and full rebuild cycles
to measure impact.

*** Proposed Solution

Add built-in profiling to the interpreter and/or compiled output:
- Memory: track allocations per phase (parser, init, typer, desugarer, etc.)
- Time: measure wall-clock time per phase
- Optionally: per-function call counts and cumulative time

Output a summary at the end of a run (opt-in via flag or mode), e.g.:
#+begin_example
Phase          Time     Allocs   Memory
parser         1.2s     12,340   45 MB
init           3.4s     98,200   512 MB
typer          2.1s     45,600   230 MB
...
#+end_example

This would make memory/performance work targeted instead of blind.

** Issue #185: Require ~own~ keyword at call sites, improve consumed-variable errors
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Usability, readability, better error messages
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned struct fields)
:END:

*** Problem

When a function takes an ~own~ parameter, the caller just passes the variable
normally. After the call, the variable is consumed (removed from scope by the
garbager's ~collect_own_transfers~). If the caller tries to use it afterwards,
they get "undefined symbol" -- a confusing error that doesn't explain WHY the
symbol disappeared.

#+begin_src til
// Current: caller doesn't mark ownership transfer
tokens.push(expr)   // 'expr' silently consumed if push takes 'own'
println(expr.name)  // ERROR: "Undefined symbol 'expr'" -- confusing!
#+end_src

*** Proposed solution

*Part 1: Require ~own~ at call sites*

The caller must explicitly write ~own~ when passing to an ~own~ parameter:

#+begin_src til
tokens.push(own expr)   // explicit: caller acknowledges transfer
println(expr.name)      // ERROR: better message (see Part 2)
#+end_src

Without ~own~ at the call site, the type checker should error:
"Parameter 'value' of 'Vec.push' requires ownership transfer. Use 'own expr'."

*Part 2: Better error for consumed variables*

When a variable has been consumed by an ~own~ transfer, the error should say:
"Variable 'expr' is no longer available -- ownership was transferred to
'Vec.push' at line 42."

This requires tracking which function consumed which variable (the garbager's
~collect_own_transfers~ already knows this, but the information isn't propagated
to error messages).

** Issue #184: Integer-based enum comparison (replace string comparison)
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Performance -- enum switch/eq currently allocates and compares strings
:STATUS: Open
:RELATED: Bug #165 (memory leak), Bug #169 (get rid of memcmp), Issue #106 (first-class enums)
:END:

*** Problem

Enum variant comparison in the interpreter uses string comparison. The
desugarer transforms ~switch~ on enums to:

#+BEGIN_SRC til
// Desugared: eq(var, enum_to_str(CasePattern))
eq(switch_var, enum_to_str(ValueType.TCustom))
#+END_SRC

Every case in every switch allocates a temporary Str via ~enum_to_str~.
With 722 format() calls and thousands of switch evaluations during
compilation, this leaks significant memory and wastes cycles on strcmp.

In compiled C, enums are already integers (~typedef enum { ... }~) or
tagged unions (~.tag~ field). Comparison is fast integer ~==~. The
interpreter should match.

*** Proposed solution

1. Assign I64 constants to each variant during preinit/init (like C does):
   ~ValueType.TCustom = 0, ValueType.TFunction = 1, ...~ etc.

2. Auto-generate ~eq~ method on all enums in preinit (like delete/clone):
   #+BEGIN_SRC til
   eq : func(a: MyEnum, b: MyEnum) returns Bool = {
       return a.tag.eq(b.tag)  // integer comparison
   }
   #+END_SRC

3. Update desugarer to use ~EnumType.eq(var, pattern)~ instead of
   ~eq(var, enum_to_str(pattern))~ for switch cases.

4. The ~value_type_to_str(x).eq(value_type_to_str(y))~ pattern used in
   17+ sites across interpreter/typer/ufcs/precomp becomes
   ~ValueType.eq(x, y)~ -- no string allocation, just integer compare.

*** Why not desugar enums to structs in TIL?

Recurring thought: "should enums desugar to structs directly in TIL
instead of being a special case through to ccodegen?"

The blocker is unions. TIL only has tagged unions (enums), not raw unions.
We don't want raw unions -- Rust doesn't have them outside ~unsafe~, and
we agree with Rust on this. Enums ARE the tagged union type.

But the tag itself can be an I64 constant instead of a string. This gets
most of the performance benefit without needing to desugar the enum type
away.

*** Scope

- preinit: auto-generate ~eq~ method for all enums
- desugarer: use enum eq instead of enum_to_str + string eq
- interpreter: enum values store integer tag alongside string (or replace)
- Replace ~value_type_to_str(x).eq(value_type_to_str(y))~ with ~ValueType.eq(x, y)~
  across 17+ sites in interpreter.til, typer.til, ufcs.til, precomp.til

** Issue #183: Add manual .delete() calls to reduce memory
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Memory leak reduction until #117 automates destruction
:STATUS: In Progress
:RELATED: Issue #117 (ASAP Destruction), Bug #165 (200-800x memory leak), Bug #159 (shallow copies)
:END:

*** Description

Add manual ~.delete()~ calls in TIL source code where values are allocated
and never freed -- the same way you would in C. Work through files in
pipeline order (lexer, parser, init, typer, desugarer, ufcs, precomp,
scavenger, ccodegen, interpreter, eval_heap, garbager), one commit per file.

TIL-only changes. Rust returns references (no copies to delete).

*** Constraints

- Lookup results (~lookup_struct~, ~lookup_enum~, ~lookup_func~) are aliases
  in interpreted mode (pointer into scope stack map). Deleting them crashes.
  Only cloned or newly-allocated values are safe to delete.
- Double-frees are harmless (eval heap catches them), so being aggressive
  with deletes is safe.
- This is a manual version of what #117 will automate. When #117 handles a
  pattern, we remove the corresponding manual delete.

*** Memory trend

| Commit    | Change                             | til_interpreted | til_built |
|-----------+------------------------------------+-----------------+-----------|
| Pre-#105  | Baseline before NamespaceDef embed | 4406 MB         |           |
| 96361e5d  | #105 Step 4a: embed NamespaceDef   | 8253 MB (+3847) |           |
| Attempt 1 | scope_stack.pop()?.delete()        | 8253 MB (+0)    |           |
| Attempt 2 | StructDef.delete() for clones      | 8160 MB (-93)   | 21757 MB  |
| 9489210f  | has_* for discarded lookups         | 8162 MB (~0)    | 21773 MB  |
|           | lexer.til: 12 delete calls          | 8158 MB (-4)    | 21765 MB  |

*** Done so far

- ~scope_stack.pop()?.delete()~ on 28 sites. No improvement.
- ~.delete()~ on 2 cloned StructDef locals (-93 MB).
- ~has_struct/enum/func~ for ~30 discarded lookups (9489210f). Code
  simplification (-514 lines), neutral on memory. Rust consistency
  pending (~lookup_X().is_some()~ -> ~has_X()~).

*** Remaining

Add ~.delete()~ calls per file in pipeline order. One commit per file.
Port to Rust for consistency once each file works.

Files:
- [X] lexer.til -- 12 deletes: current_char, next_two, esc, lit_string, suggestion
- [ ] parser.til -- skipped (needs second pass, most allocs go to AST)
- [ ] init.til
- [ ] typer.til
- [ ] desugarer.til
- [ ] ufcs.til
- [ ] precomp.til
- [ ] scavenger.til
- [ ] ccodegen.til
- [ ] interpreter.til
- [ ] eval_heap.til
- [ ] garbager.til

** Issue #179: ~cast()~ should work as function argument, not just declarations
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Better error messages now, more flexible cast usage later
:STATUS: Open
:RELATED:
:END:

*** Description

~cast(Type, expr)~ currently only works as a declaration directive:

#+BEGIN_SRC til
// WORKS -- cast in declaration
x := cast(I64, v.get(0)?)

// FAILS -- cast as function argument
result := add_one(cast(I64, v.get(0)?))
// Interpreter: "Core function 'cast' not implemented"
// Compiler: gcc error "implicit declaration of function 'til_cast'"

// FAILS -- cast with UFCS
x := cast(I64, v.get(0)?).add(1)
// Same errors as above
#+END_SRC

*** Phase 1: Reject invalid usage in typer

The typer should detect and reject ~cast()~ when used in unsupported positions:
1. As a function argument
2. As the receiver of a UFCS method call
3. Any position other than the RHS of a ~:=~ declaration

Currently these fail silently in the interpreter ("Core function 'cast' not
implemented") or at gcc level ("implicit declaration of function 'til_cast'").
A clear typer error is much better.

Workaround: extract to declaration:
#+BEGIN_SRC til
// Instead of: result := add_one(cast(I64, v.get(0)?))
e0 := cast(I64, v.get(0)?)
result := add_one(e0)
#+END_SRC

*** Phase 2: Support cast as function argument

Teach the interpreter and ccodegen to handle ~cast()~ in argument position
so that ~func(cast(Type, expr))~ works directly without needing a temporary
declaration. UFCS on cast results (~cast(...).method()~) would also work.

** Issue #175: Unify C calling convention -- all functions return through ~_ret~ pointer
:PROPERTIES:
:DISCOVERED: 2026-02-19
:IMPACT: Major ccodegen simplification, fewer special cases, enables future optimizations
:STATUS: Open - implementation plan ready
:RELATED: Bug #168 (ret_var_alias optimization), Bug #173 (missing *_ret assignment), doc/first_class.org (function pointer typedefs)
:END:

*** Background

Currently, ccodegen uses two different C calling conventions depending on
whether a function throws:

#+BEGIN_SRC c
// Non-throwing: returns value directly
til_I64 til_add(const til_I64* til_I64_a, const til_I64* til_I64_b);
result = til_add(&a, &b);

// Throwing: returns status code, value through _ret pointer
int til_parse(til_Ast* _ret, til_ParseError* _err1, const til_Str* til_Str_s);
status = til_parse(&result, &err, &s);
#+END_SRC

This bifurcation infects the entire ccodegen:
- ~emit_func_signature~: branches on ~is_throwing~ for return type and _ret param
- ~emit_fcall~: completely different code paths for calling throwing vs non-throwing
- ~emit_declaration~: different hoisting logic depending on whether RHS is throwing
- ~emit_return~: ~return value;~ vs ~*_ret = value; return 0;~
- ~find_ret_var_for_placement~ / ~ret_var_alias~: only applies to throwing functions
  (non-throwing return directly, so no ~_ret~ to alias)
- Function pointer typedefs (Issue #91): would need two typedef patterns

*** Solution: all functions return through ~_ret~ pointer

#+BEGIN_SRC c
// Non-throwing (NEW): void, returns through _ret
void til_add(til_I64* _ret, const til_I64* til_I64_a, const til_I64* til_I64_b);
til_add(&result, &a, &b);

// Throwing (UNCHANGED): int status, returns through _ret
int til_parse(til_Ast* _ret, til_ParseError* _err1, const til_Str* til_Str_s);
status = til_parse(&result, &err, &s);

// Proc (UNCHANGED): void, no _ret
void til_greet(const til_Str* til_Str_name);
til_greet(&name);
#+END_SRC

Now every function with a return type uses ~_ret~. The only difference
between throwing and non-throwing is whether there's an int return + error
pointers. Call sites all follow the same pattern.

*** What simplifies

| Area                      | Before (two paths)                      | After (one path)                    |
|---------------------------+-----------------------------------------+-------------------------------------|
| ~emit_func_signature~     | if throwing: int + _ret param,          | Always _ret param if returns.       |
|                           | else: return type directly              | void if non-throwing, int if throws |
| ~emit_fcall~ call site    | if throwing: pass &result as _ret,      | Always pass &result as _ret         |
|                           | else: result = func(...)                |                                     |
| ~emit_return~             | if throwing: *_ret = val; return 0;     | Always *_ret = val; return;         |
|                           | else: return val;                       | (or return 0 if throwing)           |
| ~find_ret_var_for_placement~ | Only for throwing functions           | All functions with return type      |
| ~ret_var_alias~           | Only for throwing functions              | All functions with return type      |
| ~emit_declaration~ (RHS)  | Different hoisting for throwing vs not   | Same hoisting for all               |
| Function pointer typedefs | Two patterns needed                     | One pattern                         |

*** Current Architecture (reference for implementation)

Functions involved and their locations:

| Function                       | Rust (ccodegen.rs) | TIL (ccodegen.til) |
|--------------------------------+--------------------+---------------------|
| ~emit_func_signature~          | line 3455          | line 4207           |
| ~emit_fcall~                   | line 6509          | line 7975           |
| ~emit_fcall_arg_string~        | line 1468          | line 1812           |
| ~emit_arg_string~              | line 794           | line 961            |
| ~emit_return~                  | line 5897          | line 7214           |
| ~emit_declaration~             | line 5284          | line 6419           |
| ~emit_throwing_call~           | line 4332          | line 5318           |
| ~emit_throwing_call_propagate~ | line 5178          | line 5746           |
| ~emit_throwing_call_with_goto~ | line (near 4113)   | line 6072           |
| ~find_ret_var_for_placement~   | line 186           | line 212            |
| ~resolve_var_name~             | line 125           | line 165            |
| ~emit_struct_func_body~        | line 3278          | line 4002           |
| ~emit_func_prototype~          | line 3567          | line 4338           |
| ~emit_func_declaration~        | line 3598          | line 4384           |

*** Key finding: expression-level calls are already broken

At ~emit_fcall~ lines 7140-7150 (Rust), there is a WORKAROUND comment:
non-throwing calls at expression level (indent==0) with arguments that need
hoisting (throwing/variadic/by-ref non-lvalues) CANNOT be hoisted because
the code is already mid-expression. The comment says "may cause compilation
errors" and "a proper fix would require restructuring emit_fcall".

Unifying the convention fixes this by forcing ALL function calls through
the statement-level hoisting path. No more inline ~f(g(x))~ in generated C;
everything gets hoisted to temp vars, which is what throwing calls already do.

*** Implementation Plan

This plan was implemented in failed branch oom175, but failed due to OOM and differences in til and rust generated C.

**** Step 1: ~emit_func_signature~ -- always emit ~_ret~ for functions with returns

Current branching (rs:3456-3500):
- ~is_throwing~ -> return type is ~int~, emit ~RetType* _ret~ + error params
- not throwing -> return type is the actual type, no ~_ret~

New logic:
#+BEGIN_SRC
if has_return_types:
    if is_throwing:
        return type = "int"
    else:
        return type = "void"
    always emit: RetType* _ret as first param
else (proc):
    return type = "void"
    no _ret
#+END_SRC

The ~_ret~ param is emitted whenever ~return_types~ is non-empty,
regardless of ~is_throwing~. Error params (~_err1~, etc.) still only
appear for throwing functions.

Files: ccodegen.rs:3455-3564, ccodegen.til:4207

**** Step 2: ~emit_return~ -- always use ~*_ret = value~

Current (rs:5897-5980):
- Throwing: ~*_ret = value; return 0;~ (with ret_var_alias optimization)
- Non-throwing: ~return value;~ directly

New logic: ALL functions with return types use ~*_ret~:
- Has returns + throws: ~*_ret = value; return 0;~ (unchanged)
- Has returns + no throws: ~*_ret = value; return;~ (new)
- No returns (proc): ~return;~ (unchanged)

The ~ret_var_alias~ optimization (skip copy if returning the alias var)
now applies to ALL functions with return types.

Files: ccodegen.rs:5897-5980, ccodegen.til:7214

**** Step 3: ~find_ret_var_for_placement~ -- remove ~is_throwing~ guard

Current (rs:188): ~if func_def.throw_types.is_empty() { return Ok(String::new()); }~
This early-returns for non-throwing functions, disabling the optimization.

Remove this guard. The optimization (alias return variable to ~*_ret~ pointer)
now applies to ALL functions with return types and struct/enum returns.

Also update ALL call sites that set ~ctx.ret_var_alias~:
- ~emit_struct_func_body~ (rs:3347-3349, rs:3677-3679)
- ~emit_declaration~ for nested functions (rs:5376-5377)

Files: ccodegen.rs:186-250, ccodegen.til:212

**** Step 4: ~emit_struct_func_body~ -- update implicit returns

Current (rs:3358-3365):
- Throwing: ~return 0;~ (success status)
- Non-throwing with return: ~return (Type){0};~ (zero-initialized default)

New:
- Throwing: ~return 0;~ (unchanged)
- Non-throwing with return: ~*_ret = (Type){0}; return;~
- No return (proc): no implicit return (unchanged)

Files: ccodegen.rs:3278-3380, ccodegen.til:4002

**** Step 5: ~emit_fcall~ statement-level -- non-throwing calls use ~_ret~ pattern

Current statement-level (indent>0) non-throwing call:
~til_func_name(arg1, arg2);~ -- call is a standalone statement, or
~result = til_func_name(arg1, arg2);~ -- result captured by assignment

New: ALL calls with return types use the same pattern as throwing calls:
1. Declare temp: ~RetType _tmp_N;~
2. Call: ~til_func_name(&_tmp_N, arg1, arg2);~
3. Use ~_tmp_N~ where the result is needed

For throwing calls, additionally: ~int _status_N = ...~ and error check.

The key change is in how ~emit_arg_string~ and ~emit_fcall_arg_string~
handle non-throwing FCalls. Currently ~emit_fcall_arg_string~ returns the
call as an inline string (~til_func(args)~). After the change, ALL FCalls
must be hoisted to temp vars, same as throwing calls.

Approach: in ~emit_arg_string~ (rs:810-816), currently only throwing FCalls
get special hoisting. Extend this to ALL FCalls with return types. The
~emit_throwing_call_propagate~ pattern (hoist to temp, pass ~_ret~ pointer)
becomes the universal pattern.

Files: ccodegen.rs:794-920, 1468-1750, 6509-7179, ccodegen.til:961, 1812, 7975

**** Step 6: ~emit_fcall~ expression-level -- force hoisting

Current expression-level (indent==0) non-throwing calls are emitted inline.
This is ALREADY BROKEN for nested throwing/variadic args (rs:7140-7150).

After unification, expression-level FCalls with return types cannot exist
inline (void functions can't be expressions). Two options:

*Option A*: Eliminate expression-level calls entirely. All FCalls get hoisted
at the ~emit_arg_string~ level before reaching ~emit_fcall~. The expression-
level path in ~emit_fcall~ becomes dead code for user-defined functions.

*Option B*: Keep expression-level for struct constructors (compound literals)
and builtins that emit inline C (like ~type_as_str~, ~enum_to_str~). Only
user-defined function calls get hoisted.

Recommendation: Option B. Struct constructors and inline builtins don't
actually call C functions, so they're unaffected by the convention change.

Files: ccodegen.rs:7115-7158, ccodegen.til equivalent

**** Step 7: ~emit_declaration~ -- unify RHS handling

Current (rs:5284-5450):
- Throwing RHS: handled by ~emit_throwing_call_propagate~
- Non-throwing RHS: handled by ~emit_arg_string~ -> inline call string

After: both paths use the same logic. The call writes to ~_ret~ pointer.
For declarations like ~x := func_call()~, the flow becomes:
1. Declare ~x~ (unless it's the ~ret_var_alias~)
2. Call ~func(&x, args)~ -- writes result directly into ~x~

This eliminates the ~result = func(args)~ pattern entirely for declarations.

Files: ccodegen.rs:5284-5450, ccodegen.til:6419

**** Step 8: Update builtins in ~emit_fcall~

Hardcoded builtins in ~emit_fcall~ (rs:6636-6900+) that generate inline
C code are NOT affected (they don't generate actual function calls):
- ~type_as_str~ -> emits Str compound literal
- ~enum_to_str~ -> emits ~EnumType_to_str(&arg)~ (already a call, needs update)
- ~enum_get_payload~ -> emits field access
- ~enum_get_payload_type~ -> emits ~to_str~ call (needs update)

Builtins that generate actual C function calls (like ~enum_to_str~ calling
the generated ~_to_str~ function) need to use the new convention IF those
generated C functions also change. Since ~enum_to_str~ calls auto-generated
~_to_str~ which returns ~Str~ directly, this needs updating too.

Files: ccodegen.rs:6636+, ccodegen.til equivalent

**** Step 9: ext_func/ext_proc declarations

External functions (~ext_func~, ~ext_proc~) are declarations with no body.
They map to C functions with the OLD convention. Since we don't control
the C implementation of ext_funcs, they must keep their current signatures.

Approach: in ~emit_fcall~, detect calls to ext_funcs and use the old
call-site pattern (~result = ext_func(args)~). Or, emit thin wrappers
that translate between conventions.

Alternatively: since most ext_funcs are builtins handled by inline codegen
in ~emit_fcall~, the actual ext_funcs that generate real C calls may be
very few. Audit needed.

Files: src/core/*.til, ccodegen.rs, ccodegen.til

**** Step 10: ~main~ function special case

The ~main~ function returns ~int~ to the OS. This is already a special case
and stays that way. Just ensure the main function prototype emission skips
the ~_ret~ treatment.

**** Step 11: Port all changes to TIL and test

Every change to ccodegen.rs must be ported to ccodegen.til. Run:
~make clean && systemd-run --user --scope -p MemoryMax=40G -p MemorySwapMax=0 make benchmark~

All 93+ tests must pass. The generated C changes significantly but behavior
must be identical.

*** Notes

- This change also simplifies future Issue #91 (function pointer typedefs):
  all function pointers follow the same ~void (*fp)(RetType* _ret, ...)~
  pattern, with ~int~ return only for throwing variants.
- The generated C loses ~x = add(&a, &b)~ style (slightly less idiomatic),
  but when reading generated C for debugging, one consistent pattern is
  easier to follow than two different patterns depending on throws.
- Fixes the broken expression-level hoisting at rs:7140-7150 as a side effect.
- The ~emit_throwing_call~ / ~emit_throwing_call_propagate~ functions serve
  as the template for the unified call pattern. The non-throwing version is
  the same minus the status check and error handling.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open - Steps 1-9 done, Step 10A done, Step 10B done (98/98 pass)
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation), Bug #144 (for-in by-ref), Bug #168 (ccodegen return copies)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Garbager clone prerequisites (DONE)

**[X] Add Str to garbager clone set** - e4788b62
Remove "Str" from primitives exclusion in garbager clone logic.

**[X] Eliminate Str double-copy via arena_offset** - 31a10477
EvalResult carries arena_offset (0 = None) through eval/return/call chains.

**** Step 5: Typer own-consumption analysis (DONE - Bug #162)

Control-flow-aware tracking of variables consumed by ~own~ params.
(Dependency: needed before Step 7 container own params can work.)

File: typer.rs, typer.til:
- Mut check: only ~mut~ params require mut variables, NOT ~own~ params
- Lazy removal tracking via ~RemovedSymbol~ struct + ScopeStack methods:
  ~begin_removal_tracking~, ~end_removal_tracking~, ~removal_mark~,
  ~drain_removals_since~, ~restore_removed~ (replaces full map snapshot/restore,
  cost proportional to actual removals instead of total symbol count)
- ~check_if_statement~: begin tracking, mark/drain/restore per branch.
  After all branches, remove symbols consumed in ALL branches (intersection).
  If-without-else: no definite consumption.
- ~check_switch_statement~: begin tracking, mark/drain/restore per case body
- ~check_func_proc_types~: snapshot before body type-check, restore before
  ~check_body_returns_throws~ (needs UFCS resolution, which needs all symbols)

File: init.rs, init.til:
- Added ~RemovedSymbol~ struct, tracking fields (~removed_log~, ~removal_tracking_depth~)
- Modified ~remove_symbol~ to log when tracking is active
- Added ~Vec.split_off~ to core/vec.til (used by ~drain_removals_since~)

**** Step 6: Ccodegen - remove ~const~ for struct/enum locals (DONE - Bug #162)

Garbager inserts ~Type.delete()~ calls on local variables. C ~const~ prevents
calling ~delete()~ (takes ~mut self~). Remove ~const~ for struct/enum locals.

File: ccodegen.rs, ccodegen.til (7 locations):
1. ~emit_precomputed_vec_assignment~: remove ~is_mut~ param, remove const logic
2. Struct empty init: remove ~if !is_mut { "const " }~
3. Struct zero init: same
4. Struct designated init: same
5. Struct fallback: same
6. Enum declaration: same
7. General const declaration: skip ~const~ for non-primitive TCustom types:
   ~matches!(&decl.value_type, ValueType::TCustom(s) if s != "I64" && ...)~

**** Step 7: Container ~own~ params + clone fixes (DONE)

(Depends on Step 5: typer must accept const vars for ~own~ params.)

~push~, ~set~, ~insert~, ~insert_at~ take ~own value: Dynamic~.
The type checker removes the variable from scope after consumption,
forcing call sites to use ~.clone()~ when they need the value afterwards.

Container files: vec.til, array.til, set.til, list.til, map.til, hashmap.til
- Vec: push, set, insert_at, extend_with (inlined - can't call push with own)
- Array: set
- Set: insert
- List: push, set (both cases: same-size and different-size)
- Map: insert, set
- HashMap: insert, set (compute bucket BEFORE push moves key)

Clone fixes (~own~ params consume variables, call sites need ~.clone()~):
- builder.til: ~insert(core_path.clone())~ x3
- eval_arena.til: ~push(frame.clone())~ x2, ~set(temp_id.clone(), ...)~ x2
- ccodegen.til: ~set(name, idx.clone())~, ~push(pop_idx.clone())~,
  ~set(next, next_degree.clone())~
- interpreter.til: ~set(struct_type, template_offset.clone())~,
  ~set(var_name.clone(), offset)~
- parser.til: ~push(result.clone())~ x2
- init.til: ~name.clone()~ inline (Bug #162 UFCS fix enabled this)
- tests.til: ~push(time_ms.clone())~
- hashmap.til: ~set(bucket_idx, i.clone())~ in resize/remove
- Test/example files: bug57.til, vecs.til, lists.til, maps.til,
  cross_file_forward.til, music.til - loop vars consumed by push/insert

***** Zeroing deferred — replaced by ~dont_delete~ in Step 9
Zeroing (~memset(to_ptr(value), zero, size)~ after copy) was attempted
but removed. TIL's shared-offset reference chain causes zeroing to
cascade: e.g. ~declare_struct(name: Str)~ calls ~Map.set(own key=name)~
which calls ~Vec.insert_at(own value=key)~. Zeroing ~value~ zeroes ~key~
zeroes ~name~ zeroes ~decl.name~ in the original caller. This broke the
entire self-hosted compiler (87/98 test failures).

Replaced by ~dont_delete(value)~ in Step 9: a garbager-phase directive
that tells the garbager to skip inserting ~Type.delete()~ for that
variable and removes the ~dont_delete~ call from the AST. Combined with
~own~ (caller's variable removed from scope), nobody deletes the value.
Heap data lives on in the container, freed when container is deleted.
Same memory behavior as zeroing but no cascading corruption.

***** Bug #162 UFCS + own params (FIXED)
Root cause: ~check_body_returns_throws~ re-walked the AST doing UFCS
resolution after the type-check pass removed own-consumed symbols.
Parameters were not re-declared (unlike locals). Fix: restore removed
symbols before ~check_body_returns_throws~ via removal tracking.
Workarounds in init.til removed.

**** Step 8: ~dont_delete~ directive (replaces zeroing) — DONE

Garbager-phase directive. When the garbager sees ~dont_delete(var)~ in
the AST: (1) add ~var~ to skip set, (2) don't insert ~Type.delete(var)~,
(3) remove the ~dont_delete~ call from AST. No runtime cost — purely
garbager-phase. Used inside container methods with ~own~ params:
#+begin_src til
push := proc(mut self: Vec, own value: Dynamic) {
    dont_delete(value)  // garbager strips this, skips delete for value
    // ... copy bytes into vec ...
}
#+end_src
Files: garbager.rs, garbager.til, mem.til + container files (vec, array, map, etc.)

Implementation: declared as ~ext_func~ in ~mem.til~ so the type checker
accepts it. Garbager strips the calls from FuncDef bodies. ~dont_delete~
placed at top of function body (before any ownership-consuming calls).

Container methods with ~dont_delete~: Vec.push, Vec.set, Vec.extend_with,
Vec.insert_at, Array.set, Set.insert, Map.insert, Map.set,
HashMap.insert, HashMap.set, List.push, List.set.

Prerequisite for Step 9 (Bug #144 fix) and Step 10 (auto-delete).

**** Step 9: Fix ~get~ shallow copy + ~get~ (zero-copy) + ~create_alias~ (Bug #144) — DONE

The old copying ~get(self, index, mut dest)~ did memcpy (shallow copy). The
caller's local aliased the container element's heap data. Auto-deleting the
local corrupted the container (double-free).

Agreed approach:
1. DONE — zero-copy ~get~ added to Vec, Map, HashMap (previously named
   ~get_by_ref~, renamed for simplicity). Returns borrowed Ptr (~offset~
   sets ~is_borrowed=1~). Tests in vecs.til and maps.til.
2. DONE — ~create_alias~ standalone ext_func added. Rebinds a local variable's
   arena offset to a Ptr's data address (interpreter) or emits memcpy (compiler).
   Not a Ptr method (wrapper can't rebind caller's variable). Declared in mem.til,
   implemented in ext.rs/ext.til, inline codegen in ccodegen.rs/ccodegen.til.
   Test in pointers.til.
3. DONE — Fix Bug #144 — 3-arg compound directive ~create_alias(item, MyStruct, addr)~.
   Declares variable + aliases to address + skips auto-delete, all in one FCall.
   No wasteful default construction, no separate ~dont_delete~. Every phase with
   scope tracking recognizes it: init, typer, ufcs, precomp, ccodegen, interpreter.
   Desugared for-in for non-primitives is now:
#+begin_src til
_ref := get(vec, _for_i_func_N)
catch (...) { panic(...) }
create_alias(item, MyStruct, _ref.data)   // declares + aliases + skips delete
// user's body
#+end_src
   Performance gain modest (~0.6%), see Bug #144 for details. But the real
   value is correctness: create_alias variables are properly excluded from
   auto-delete, which is what Step 10 needs. Without this, Step 10 would
   double-free for-in loop variables over containers.
4. DONE — Renamed ~get_by_ref~ to ~get~. The old copying ~get~ was removed,
   so the name is free for the zero-copy version.

Dependencies: Step 8 (~dont_delete~), ~get~, ~create_alias~ ext_func.
Files: desugarer.rs, desugarer.til, container files, ptr ext_funcs,
  ufcs.rs, ufcs.til, precomp.rs, precomp.til, init.rs, init.til,
  typer.rs, typer.til, ccodegen.rs, ccodegen.til, ext.rs, ext.til,
  garbager.rs, garbager.til, mem.til, pointers.til.

**** Step 10A: Auto-insert Type.delete() at function body end — DONE

Files: ~src/rs/garbager.rs~ and ~src/self/garbager.til~

Implementation complete. 98/98 tests pass. Two fixes needed after initial implementation:
- ~is_deletable_type~: check struct has mutable fields (not just is-a-struct).
  Empty structs (EmptyStruct, BadAlloc, DivideByZero) have no heap data.
- Catch guard: any catch block (not just non-final) means throws can skip
  declarations, making unconditional deletes at function end unsafe.

***** Edits (Rust)

****** 1. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC rust
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
fn is_deletable_type(type_name: &str, context: &Context) -> bool {
    let is_primitive = matches!(type_name, "I64" | "U8" | "Type" | "Dynamic" | "Ptr");
    !is_primitive && context.scope_stack.has_struct(type_name)
}
#+END_SRC

****** 2. Replace 4 inline is_primitive checks with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType::Declaration~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType::Assignment~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if is_primitive || !context.scope_stack.has_struct(type_name) {
:          continue;
:      }
: NEW: if !is_deletable_type(type_name, context) {
:          continue;
:      }

NOTE: Location D uses inverted logic (continue if NOT deletable).
NOTE: The new helper adds "Ptr" to the exclusion list. This is intentional
(per Step 10 design in pre.org Issue #117). Doesn't change existing behavior
since Ptr was never in has_struct().

****** 3. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC rust
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
fn build_delete_call_expr(type_name: &str, var_name: &str, line: usize, col: usize) -> Expr {
    let delete_ident = Expr::new_explicit(
        NodeType::Identifier("delete".to_string()), vec![], line, col);
    let type_delete_access = Expr::new_explicit(
        NodeType::Identifier(type_name.to_string()), vec![delete_ident], line, col);
    let var_expr = Expr::new_explicit(
        NodeType::Identifier(var_name.to_string()), vec![], line, col);
    Expr::new_explicit(NodeType::FCall(false), vec![type_delete_access, var_expr], line, col)
}
#+END_SRC

****** 4. Add ~get_create_alias_var~ helper (after ~get_dont_delete_var~)

#+BEGIN_SRC rust
/// Extract variable name from create_alias(var, type, addr) call.
fn get_create_alias_var(e: &Expr) -> Option<String> {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(name) = get_func_name(e) {
            if name == "create_alias" && e.params.len() >= 3 {
                if let NodeType::Identifier(var_name) = &e.params[1].node_type {
                    return Some(var_name.clone());
                }
            }
        }
    }
    None
}
#+END_SRC

****** 5. Add ~collect_own_transfers~ helpers (after ~get_create_alias_var~)

#+BEGIN_SRC rust
/// Scan statements for variables passed as `own` args to function calls.
fn collect_own_transfers(stmts: &[Expr], context: &Context) -> HashSet<String> {
    let mut result = HashSet::new();
    for stmt in stmts {
        collect_own_transfers_recursive(stmt, context, &mut result);
    }
    result
}

fn collect_own_transfers_recursive(e: &Expr, context: &Context, result: &mut HashSet<String>) {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(func_name) = get_func_name(e) {
            if !func_name.ends_with(".clone") && !func_name.ends_with(".delete") {
                if let Some(func_def) = context.scope_stack.lookup_func(&func_name) {
                    for (i, arg_def) in func_def.args.iter().enumerate() {
                        let param_idx = i + 1;
                        if param_idx < e.params.len() && arg_def.is_own {
                            if let NodeType::Identifier(var_name) = &e.params[param_idx].node_type {
                                if e.params[param_idx].params.is_empty() {
                                    result.insert(var_name.clone());
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    for param in &e.params {
        collect_own_transfers_recursive(param, context, result);
    }
    if let NodeType::FuncDef(func_def) = &e.node_type {
        for stmt in &func_def.body {
            collect_own_transfers_recursive(stmt, context, result);
        }
    }
}
#+END_SRC

****** 6. Replace FuncDef handler (the ~NodeType::FuncDef~ arm in ~garbager_recursive~)

Replace the entire ~NodeType::FuncDef(func_def) => { ... }~ arm:

#+BEGIN_SRC rust
        NodeType::FuncDef(func_def) => {
            // Step 1: Strip dont_delete calls, collect protected var names
            let mut new_body = Vec::new();
            let mut dont_delete_vars: HashSet<String> = HashSet::new();
            for stmt in &func_def.body {
                if is_dont_delete_call(stmt) {
                    if let Some(var_name) = get_dont_delete_var(stmt) {
                        dont_delete_vars.insert(var_name);
                    }
                    continue;
                }
                // Step 2: Collect create_alias var names
                if let Some(alias_var) = get_create_alias_var(stmt) {
                    dont_delete_vars.insert(alias_var);
                }
                new_body.push(garbager_recursive(context, stmt)?);
            }

            // Step 3: Collect delete candidates
            let mut candidates: Vec<(String, String)> = Vec::new();

            // 3a: copy/own params with deletable types
            for arg_def in &func_def.args {
                if arg_def.is_copy || arg_def.is_own {
                    if let ValueType::TCustom(type_name) = &arg_def.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((arg_def.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // 3b: Scan new_body for Declaration nodes with deletable types
            for stmt in &new_body {
                if let NodeType::Declaration(decl) = &stmt.node_type {
                    if let ValueType::TCustom(type_name) = &decl.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((decl.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // Step 4: Remove dont_delete_vars and own-transferred vars
            let own_transfers = collect_own_transfers(&new_body, context);
            candidates.retain(|(var_name, _)| {
                !dont_delete_vars.contains(var_name) && !own_transfers.contains(var_name)
            });

            // Step 5: Append Type.delete(var) calls in reverse declaration order
            let last_line = new_body.last().map_or(e.line, |s| s.line);
            let last_col = new_body.last().map_or(e.col, |s| s.col);
            candidates.reverse();
            for (var_name, type_name) in &candidates {
                new_body.push(build_delete_call_expr(type_name, var_name, last_line, last_col));
            }

            let new_func_def = SFuncDef {
                function_type: func_def.function_type.clone(),
                args: func_def.args.clone(),
                return_types: func_def.return_types.clone(),
                throw_types: func_def.throw_types.clone(),
                body: new_body,
                source_path: func_def.source_path.clone(),
            };
            let mut new_params = Vec::new();
            for param in &e.params {
                new_params.push(garbager_recursive(context, param)?);
            }
            Ok(Expr::new_explicit(NodeType::FuncDef(new_func_def), new_params, e.line, e.col))
        }
#+END_SRC

***** Edits (TIL)

****** 7. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC til
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    return not(is_primitive).and(context.scope_stack.has_struct(type_name))
}
#+END_SRC

****** 8. Replace 4 inline is_primitive checks in TIL with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType.Declaration~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType.Assignment~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

****** 9. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC til
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}
#+END_SRC

****** 10. Add ~get_dont_delete_var~ to TIL (after ~is_dont_delete_call~)

Currently missing from TIL. Rust version is ~get_dont_delete_var~ in garbager.rs.

#+BEGIN_SRC til
/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str {
    if e.params.len().lt(2) {
        return ""
    }
    mut param1 := Expr()
    e.params.get(1, param1)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}
#+END_SRC

****** 11. Add ~get_create_alias_var~ to TIL (after ~get_dont_delete_var~)

#+BEGIN_SRC til
/// Extract variable name from create_alias(var, type, addr) call.
get_create_alias_var := func(e: Expr) returns Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.eq("create_alias").and(e.params.len().gteq(3)) {
            mut param1 := Expr()
            e.params.get(1, param1)?
            catch (err: IndexOutOfBoundsError) {
                return ""
            }
            switch param1.node_type {
            case NodeType.Identifier(var_name):
                return var_name
            case:
            }
        }
    case:
    }
    return ""
}
#+END_SRC

****** 12. Add ~collect_own_transfers~ to TIL (after ~get_create_alias_var~)

Uses Vec<Str> instead of HashSet. Returns the Vec directly.

#+BEGIN_SRC til
/// Scan statements for variables passed as `own` args to function calls.
collect_own_transfers := proc(stmts: Vec, context: Context) returns Vec {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, result)
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, mut result: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.len().gt(0).and(not(func_name.ends_with(".clone"))).and(not(func_name.ends_with(".delete"))) {
            mut func_def := SFuncDef()
            mut found := false
            func_def = context.scope_stack.lookup_func(func_name)?
            found = true
            catch (err: KeyNotFoundError) { }
            if found {
                for i in 0..func_def.args.len() {
                    mut arg_def := Declaration()
                    func_def.args.get(i, arg_def)?
                    catch (err: IndexOutOfBoundsError) { }
                    param_idx := i.add(1)
                    if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                        mut param_expr := Expr()
                        e.params.get(param_idx, param_expr)?
                        catch (err: IndexOutOfBoundsError) { }
                        switch param_expr.node_type {
                        case NodeType.Identifier(var_name):
                            if param_expr.params.len().eq(0) {
                                result.push(var_name)
                            }
                        case:
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, result)
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, result)
        }
    case:
    }
}
#+END_SRC

****** 13. Replace FuncDef handler in TIL (the ~NodeType.FuncDef~ case in ~garbager_recursive~)

Replace from ~case NodeType.FuncDef(func_def):~ through ~return Expr.new_explicit(...)~:

#+BEGIN_SRC til
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        mut new_body := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                // Step 2: Collect create_alias var names
                alias_var := get_create_alias_var(stmt)
                if alias_var.len().gt(0) {
                    dont_delete_vars.push(alias_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types
        for stmt: Expr in new_body {
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(decl.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            case:
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        own_transfers := collect_own_transfers(new_body, context)
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            mut var_name := ""
            cand_vars.get(i, var_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut type_name := ""
            cand_types.get(i, type_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut excluded := false
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 5: Append Type.delete(var) calls in reverse declaration order
        mut last_line := e.line
        mut last_col := e.col
        if new_body.len().gt(0) {
            mut last_stmt := Expr()
            new_body.get(new_body.len().sub(1), last_stmt)?
            catch (err: IndexOutOfBoundsError) { }
            last_line = last_stmt.line
            last_col = last_stmt.col
        }
        mut ri := filtered_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            mut del_var := ""
            filtered_vars.get(ri, del_var)?
            catch (err: IndexOutOfBoundsError) { }
            mut del_type := ""
            filtered_types.get(ri, del_type)?
            catch (err: IndexOutOfBoundsError) { }
            new_body.push(build_delete_call_expr(del_type, del_var, last_line, last_col))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)
#+END_SRC

**** Step 10B: ASAP last-use deletion for copy/own params — DONE

Files: ~src/rs/garbager.rs~, ~src/self/garbager.til~, ~src/self/ccodegen.til~

Moves ~Type.delete(var)~ calls from function body END to right after the
variable's last use — but only for ~copy~/~own~ params (deep copies, no aliasing).
Locals stay at function end (shared offsets mean locals can alias through
field assignment).

***** New helpers (both Rust + TIL)

- ~expr_references_var(e, var_name) -> bool~: Recursively checks if any
  Identifier node in the expression tree matches var_name. Recurses into
  e.params but NOT into nested FuncDef bodies (separate scope).

- ~find_last_use_index(body, var_name) -> Option<usize>~ (Rust) /
  ~-> I64~ (TIL, -1 = not found): Scans body from end to start, returns
  index of last statement referencing the variable.

***** Modified Step 5 logic

Step 5 now separates candidates into two groups:
- ~asap_candidates~ (copy/own params): insert delete after last use via
  HashMap (Rust) / parallel Vecs (TIL) for insertion positions
- ~end_candidates~ (locals): append at function end in reverse declaration order

When multiple deletes land at the same position, they appear in reverse
declaration order (last declared -> first deleted).

***** Bug fix: dont_delete for field aliases in ccodegen.til

ASAN revealed a pre-existing double-free from Step 10A in
~emit_precomputed_vec_assignment~: ~elem_type := contents.element_type_name~
creates a shared-pointer alias. Both ~Str.delete(elem_type)~ and
~VecContents.delete(contents)~ freed the same Str. Fixed with
~dont_delete(elem_type)~. Rust version uses ~&contents.element_type_name~
(a reference), so no issue there.

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Ownership Model for Containers
- ~push~/~set~/~insert~ use ~own~ params: ownership transfers IN (zeroing deferred to Step 9)
- ~get~ returns borrowed Ptr: no copy, no ownership transfer OUT
- Caller reads through Ptr; to get owned copy, explicitly clone
- This makes the ownership flow clean: containers own their data, ~get~ borrows,
  ~push~/~own~ transfers in. No hidden aliasing from shallow copies.

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Bug #168: ccodegen return values create copies the interpreter doesn't
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic divergence between interpreter and compiled code; root cause of memory leak gap
:STATUS: Partial -- commits 1/1b/2 on master, commit 3 (non-throwing out-ptr) reverted
:RELATED: Bug #159 (shallow copies), Bug #165 (memory leak), Bug #80 (ccodegen divergence), Issue #117 (ASAP destruction)
:END:

*** Description
In the interpreter, function returns are shared offsets -- no copy happens.
In ccodegen, every struct return is a memcpy:
#+begin_src c
*_ret = value;          // callee: struct assignment = implicit memcpy
var = func_call();      // caller: receives shallow copy
#+end_src

This means ccodegen creates copies the interpreter never does. The original
value in the callee's scope is abandoned (heap pointers aliased, never freed).
This is the fundamental semantic gap between interpreter and compiled memory
behavior, and the reason compiled TIL leaks far more than interpreted.

In C, return values are effectively pointer-based anyway (NRVO, hidden
destination pointer). The memcpy is semantically unnecessary. Same applies
to throw values and out params.

*** Why this matters
- #117 (ASAP destruction) can't be completed for ccodegen while returns
  create aliases the interpreter doesn't have
- #80 (ccodegen match) can't be verified because compiled TIL eats too
  much memory to run =make diff til.til=
- #100 (self-hosting) is blocked by #80 which is blocked by this

*** Inventory -- all ccodegen shallow copies
- =*_ret = value;= -- callee struct return (696 remaining, was 976)
- =return value;= -- non-throwing by-value return (485), implicit memcpy at call site
- =create_alias= -- emits =memcpy(&var, (void*)addr, sizeof(type))= where
  interpreter does =insert_var(name, addr)= (pure offset binding, zero copy)
- =enum_get_payload= -- shallow memcpy of enum payload data

*** Implementation

**** Commit 1: Throwing calls -- eliminate intermediate =_ret_N= temp -- DONE

Throwing functions already use the out-pointer pattern. Eliminated the
unnecessary intermediate temp at call sites:

#+begin_src c
// BEFORE:
til_Str _ret_N;                              // temp
int _status_N = func(&_ret_N, &_err, args);  // write to temp
dest = _ret_N;                               // UNNECESSARY COPY

// AFTER:
int _status_N = func(&dest, &_err, args);    // write to dest directly
#+end_src

Added =build_dest_ptr_expr= helper. Modified =emit_throwing_call_propagate=
and =emit_throwing_call_with_goto= to skip temp, use dest ptr, skip copy.
Ported to ccodegen.til. On master at 639c1741.

**** Commit 1b: Catch-block variant of commit 1 -- DONE

Same call-site direct-write optimization for throwing calls with local catch
blocks (=emit_throwing_call_with_goto=). On master at 7c383c6f.

**** Commit 2: Callee-side placement via ret_var_alias -- DONE

=find_ret_var_for_placement= detects when all return paths use the same variable.
That variable is aliased to =(*_ret)= so construction writes directly to the
out-pointer, eliminating the callee-side =*_ret = local_var;= copy.

Safety checks: variable not reassigned, not a parameter, no parameter shares
the return type. =has_declaration_of= prevents global constants (true/false)
from being treated as ret_var_alias candidates.

On master at 7e698d7a.

**** Result

=*_ret == copies in bootstrap/til.c: 976 -> 696 (280 eliminated, 29% reduction).

**** What remains

- 696 =*_ret == copies in throwing functions where =find_ret_var_for_placement=
  can't optimize (multiple return variables, reassignment, etc.)
- 485 non-throwing =return til_*= statements (by-value return = implicit memcpy
  at call site)
- =create_alias= emits memcpy instead of pointer alias (see below)
- =enum_get_payload= shallow memcpy of payload

**** Next: create_alias should use pointer, not memcpy

The interpreter handles =create_alias= by binding the variable name to the source
address (=insert_var(name, addr)=). Zero copy. ccodegen emits =memcpy=, creating
a shallow copy. The C equivalent of offset binding is a pointer cast:

#+begin_src c
// CURRENT (shallow copy):
til_MyStruct elem;
memcpy(&elem, (void*)addr, sizeof(til_MyStruct));

// CORRECT (true alias, matches interpreter):
til_MyStruct* elem = (til_MyStruct*)addr;
#+end_src

This requires ccodegen to track that =elem= is a pointer-alias and emit =elem->field=
instead of =elem.field=. Similar to how by-ref parameters are already handled.

**** Failed attempt: non-throwing out-ptr (reverted)

Extended out-pointer convention to non-throwing struct-returning functions:
=void func(Type* _ret, ...)= instead of =Type func(args)=.

- Added 963 lines to ccodegen.til, 610 lines to ccodegen.rs
- bootstrap/til.c grew by ~27k lines
- Build slowed 30% (730s -> 949s), primarily til_interpreted (+35%)
- Expression-position calls required temp vars no better than by-value return
- Reverted: cost far exceeded benefit

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Bug #170: Scope-exit deletion for local variables
:PROPERTIES:
:DISCOVERED: 2026-02-11
:IMPACT: Memory leak -- locals only deleted at function end (or never if catch blocks exist)
:STATUS: Open -- two approaches failed 2026-02-11, see implementation notes
:RELATED: Bug #165 (memory leak), Bug #159 (shallow copies), Issue #117 (ASAP destruction)
:END:

*** Problem
The garbager deletes local mut variables at function end only (and skips them
entirely if the function has catch blocks). Locals declared in inner scopes
(if/while/for) leak until function end or forever. copy/own params get ASAP
deletion after last use, but locals don't.

*** Design: unified scope-exit deletion
One concept: *delete at scope exit*. Every deletable variable gets deleted when
its declaring scope ends. All current deletion triggers are specific cases of
scope exit:

| Trigger                  | What it is                                    |
|--------------------------+-----------------------------------------------|
| ~}~ of if/while/for      | Scope exit for variables declared inside       |
| ~return~                  | Scope exit for entire function                 |
| ~throw~                   | Scope exit for entire function                 |
| ~own~ arg call            | Early scope exit for that one variable         |

Reverse declaration order within a scope naturally handles the container-
outlives-alias problem: ~elem := vec.get(0)~ is declared after ~vec~, so
~elem~ is deleted first, then ~vec~.

*** What the garbager needs to do

**** For each scope boundary (~}~ of if/while/for/block):
Insert ~Type.delete(var)~ for each deletable mut variable declared in that
scope, in reverse declaration order. Respect ~dont_delete~ as today.

**** For ~return~ statements:
Insert deletes for ALL in-scope deletable mut variables before the return.
Reverse declaration order, innermost scope first.

**** For ~throw~ paths:
Same as return -- delete everything in scope before the throw. But only
variables guaranteed to have been initialized (declared before the throw
point, not conditionally).

**** For ~own~ transfers:
Already handled: variable is consumed, removed from deletion candidates.

*** Open questions

1. *Const locals:* Should const locals also get scope-exit deletion (relying
   on reverse declaration order for safety), or only mut locals for now?
   Const locals are more likely to be aliases (field extractions), but reverse
   declaration order may handle that. Need to verify with concrete examples.

2. *Catch blocks:* Keep current conservative approach (skip all deletion if
   any catch exists) or implement smarter analysis (only skip variables whose
   initialization could be skipped by a throw)? Smarter is more complex but
   covers more functions since many functions have catch blocks.

3. *Scope tracking in garbager:* Currently does a flat scan of function body.
   Needs to understand nesting (if/while/for bodies are nested Expr params).
   The garbager already recurses into bodies for other transforms -- need to
   check if scope info is available or needs threading through.

4. *ccodegen impact:* If garbager inserts scope-exit deletes into the AST,
   ccodegen just emits them -- probably no ccodegen changes needed. Verify.

5. *Reassignment:* ~mut x := Str.new("a"); x = Str.new("b")~ -- the old value
   leaks. Scope-exit deletion only frees the final value. The old value needs
   clone-on-assign + delete-old-value semantics (Bug #159 territory, not this
   bug).

*** Implementation attempt 2026-02-11 -- two approaches failed

**** Attempt 1: ASAP deletion for top-level locals
Changed end-of-function locals to use ~find_last_use_index()~ (same as
copy/own params). Result: 89/92 tests failed with ~free(): invalid pointer~.

Root cause: shallow-copy aliasing (Bug #159). Pattern:
#+begin_example
mut tokens := lex("mode safe_script")
mut first_token := Token()
tokens.get(0, first_token)   // shallow copy -- first_token aliases tokens[0]
// ... more code using first_token ...
// ASAP: Vec.delete(tokens) inserted here (last direct reference to "tokens")
// ... first_token.text is now dangling -- freed with tokens
#+end_example

~Vec.get()~, ~Array.get()~, field access -- all do shallow memcpy. The
extracted value aliases heap pointers in the container. Deleting the container
ASAP frees the shared heap data while the alias is still live.

The original code comment was correct:
: // locals: at function end (shared offsets mean locals can alias).

ASAP deletion is only safe for copy/own params because the garbager inserts
~Type.clone()~ for those, giving them independent heap data.

**** Attempt 2: Collect inner-scope locals, delete at function end
Added ~collect_declarations_recursive()~ to scan Body nodes inside
if/while/for and add their declarations to the function-end deletion list.
Result: 69/92 tests failed with signal 11 (SIGSEGV).

Root cause: conditional initialization. Pattern:
#+begin_example
func foo(x: I64) {
    if x > 0 {
        mut thing := SomeStruct()   // only initialized when x > 0
    }
    // garbager inserts: SomeStruct.delete(thing)  -- SIGSEGV when x <= 0
}
#+end_example

Inner-scope variables are only initialized when the scope executes. Inserting
unconditional ~delete()~ at function end crashes when the scope was skipped.

**** What would work: scope-exit deletion in the Body handler
The correct approach: insert ~Type.delete(var)~ at the end of the BODY node
where the variable was declared, not at function end. This guarantees the
variable is initialized (we're inside the scope that declared it).

Still has the shallow-copy aliasing risk (Bug #159), but no worse than
current function-end deletion for top-level locals. The aliasing risk is
mitigated by reverse declaration order: if ~elem := vec.get(0)~ is declared
after ~vec~, then ~elem~ is deleted first, then ~vec~.

Needs:
- Modify ~garbager_recursive~ Body handler to scan for declarations and
  append deletes at body end
- Per-scope ~dont_delete~ / ~own_transfer~ filtering (or inherit from parent)
- Per-scope ~has_any_catch~ check
- Name collision avoidance: TIL has flat namespace, helper functions must not
  collide with ~collect_declarations_recursive~ in ccodegen.til

Also learned: name ~collect_declarations_recursive~ already exists in
ccodegen.til. TIL's flat namespace causes collision. Any new helpers in
garbager.til need prefixed names (e.g., ~garbager_collect_decls~).

** Bug #159: Shallow copy semantics for structs with Ptr/Vec fields (REOPENED)
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Memory corruption, prevents ASAP deletion, root cause of memory leaks
:STATUS: Open -- interpreter copy_fields removed; ccodegen shallow copies remain; deep Vec.clone/delete blocked on Issue #91 (function pointers); Map.get eliminated, cast replaces create_alias
:RELATED: Bug #165 (memory leak blocked by this), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame leak), Bug #170 (scope-exit deletion blocked by this), Issue #91 (function pointers needed for deep clone/delete)
:END:

*** Description
When doing =mut cloned := original=, the interpreter used =copy_fields= which did
a byte-level copy. For structs containing Ptr or Vec fields, both the original and
clone shared the same underlying memory.

*** What was done (2026-02-07, originally declared fixed)
Removed =copy_fields= (shallow copy) from the interpreter. Replaced with:
1. Garbager inserts =Type.clone()= calls for struct-typed identifier args (4 sites)
2. Interpreter uses offset binding or memcpy instead of copy_fields

Steps completed:
- Step 1: preinit generates clone/delete methods
- Step 2: Dynamic type info added to Ptr
- Step 3: mut declarations (clone + offset binding)
- Step 4: Function copy params (clone + offset binding)
- Step 5: Struct literal fields (memcpy)
- Step 6: Assignment statements (memcpy)
- Step 7: Nested member assign + own params (memcpy), copy_fields deleted
- Step 8: Own params simplified to pure offset binding

Dead code removed: =copy_fields=, =SavedOffsets=, =insert_struct_instance_into_frame=,
=EvalArenaMapping= import.

Test: src/test/bug159.til (passes all 4 modes)

*** What remains -- shallow copies still present
The interpreter fix only addressed =copy_fields=. Shallow copies remain throughout
the codebase via memcpy in generated C code and core library operations.

**** 1. ccodegen -- Function return values (partially addressed by Bug #168)
- =*_ret = value;= -- 696 remaining (was 976, commits 1/1b/2 eliminated 280)
- Non-throwing by-value returns: 485 =return til_*= statements
- See Bug #168 in pre.org for full details and commit history

**** 2. src/core/ptr.til -- Raw memcpy operations
- =copy_to_dynamic= (line 108): =memcpy(to_ptr(dest), self.data, size)=
- =copy_from_dynamic= (line 103): =memcpy(self.data, to_ptr(src), size)=
- =copy_to= (line 93): =memcpy(dest.data, self.data, size)=
- =copy_from= (line 89): =memcpy(self.data, src.data, size)=
- =dereference= (line 113): =memcpy(to_ptr(dest), self.data, size)=
- =Ptr.clone= (line 72): copies struct bytes, shared heap pointer

**** 3. src/core/vec.til -- Collection operations using copy_to/from_dynamic
Handled by =dont_delete= in garbager: the shallow copies still happen, but the
aliased data is not double-freed. The copies still leak memory (root cause of #165).
- =get= REMOVED, =push=, =set=, =clone=, =extend=, =extend_with=, =contains=, =remove=,
  =insert_at=, =to_str=, =split_off=, =pop= -- all use copy_to/from_dynamic

**** 4. src/core/set.til -- Uses Vec internally, same dont_delete protection
- =insert=, =remove=, =contains=, =get= REMOVED -- copy_to_dynamic for comparison/retrieval

**** 5. src/core/array.til -- Direct memcpy, same dont_delete protection
- =get= REMOVED, =set=, =clone= -- copy_to/from_dynamic

**** 6. ccodegen -- enum_get_payload
- Shallow memcpy of enum payload data

**** 7. ccodegen -- create_alias directive (FIXED)
=create_alias= replaced by =cast(Type, Ptr)= which emits =Type* var = (Type*)ptr.data;=
-- true pointer aliasing, zero copy in both interpreter and ccodegen.

*** Step 9: Clone-after-get for container out-params (2026-02-11)
Container =get()= and =pop()= methods extract elements via =copy_to_dynamic=
(memcpy), creating shallow copies that alias the container's internal heap
pointers. The garbager now inserts =elem = ElemType.clone(elem)= after every
container get/pop call where the out-param is a local variable with a deletable
struct type.

Whitelist of affected methods:
- =Vec.pop= (Vec.get, Array.get, Set.get, Map.get all REMOVED)
- =HashMap.get=, =List.get=, =List.pop=

New garbager functions:
- =build_clone_assignment_expr= -- builds AST for =var = Type.clone(var)=
- =detect_shallow_copy_outparam= -- checks if stmt is a whitelisted get/pop call
- =insert_clone_after_get= / =process_stmt_for_clone_after_get= -- inserts clones
  after matching calls, recursing into nested Body/If/While/For/Switch nodes

Step 2.7 in FuncDef handler runs after local_types is built, before Step 3
(delete candidate collection). The =local_types= map was moved earlier (from
Step 4 to after Step 2.5) so it's available for both clone-after-get and
own-transfer detection.

All 92 tests pass in all 4 modes.

*** Parameter passing semantics (unchanged)
| Mode      | Semantics                                      |
|-----------+------------------------------------------------|
| (default) | By reference - share offset                    |
| =mut=     | By reference - share offset                    |
| =own=     | Ownership transfer - share offset, remove src  |
| =copy=    | Deep copy - garbager inserts clone, bind result |

*** Step 3b attempts -- local deletion (2026-02-17, FAILED)

Multiple attempts to enable ASAP deletion for local variables at function end.
All reverted. This is the key step needed to actually FREE the cloned data.

**** Attempt 1: ASAP deletion for locals (89/92 fail, free(): invalid pointer)
Shallow-copy aliasing via Vec.get(), field access etc. creates aliases to
local's heap data. Deleting local ASAP frees data still referenced through aliases.

**** Attempt 2: Inner-scope collection to function-end (69/92 fail, SIGSEGV)
Variables declared inside if/while/for may never be initialized. Unconditional
delete at function end crashes when scope was skipped.

**** Attempt 3: Garbager clone gaps + step 3b (88/92 SIGSEGV)
- Fix A: Clone ALL Identifier-init declarations (removed is_mut check)
- Fix B: Clone field-access assignments (removed params.is_empty check)
- Fix C: Remove has_any_catch restriction, zero-init hoisted locals

Fixes A+B alone pass 92/92 but are net-negative on memory (more clones, no deletes).
Step 3b crashes because cloned locals get embedded in returned data via by-ref
function calls. Root cause: functions like =Expr.new_explicit= take params by-ref
(not =own=), so =collect_own_transfers= doesn't detect that the caller's variable
was consumed. The variable becomes a deletion candidate, gets deleted at function
end, and corrupts the returned Expr that shares the same data buffer.

*** Issue #105 Step 4a regression (2026-02-22)

Commit 96361e5d (Move NamespaceDef into StructDef/EnumDef as =ns= field)
introduced a performance regression:
- til_interpreted: 794s/4406MB -> 1245s/8253MB (+56% time, +87% memory)
- til_built: 639s/9989MB -> 1086s/21863MB (+70% time, +119% memory)

Root cause: 3 phases (desugarer, garbager, ufcs) now recurse into
=ns.default_values= (namespace method bodies) inside the StructDef handler.
Before, NamespaceDef was a separate sibling node at Body level. These phases
hit the default case which just cloned it opaquely -- no recursion into
method body Expr trees. Only precomp had explicit NamespaceDef handling.

After embedding ns in StructDef, each phase's StructDef handler explicitly
iterates =ns.default_values= and calls =desugar_expr= / =garbager_recursive= /
=ufcs_expr= on each method body. This is more correct behavior -- namespace
method bodies should be fully processed by all phases -- but expensive.

Accepted as cost of correctness. Will be absorbed by Issue #117 optimizations.

*** Root cause analysis (2026-02-17)

The fundamental problem is that TIL/C has no ownership tracking. Every struct
assignment is a shallow memcpy. The garbager inserts clones for some patterns,
but many sources of shallow copies remain:

1. *ccodegen return values*: =*_ret = var= is a shallow copy. The returned local
   and =*_ret= share heap pointers. (Bug #168)
2. *Vec.clone*: byte-wise copy of buffer. Element heap pointers are shared.
3. *Vec.delete*: frees only the buffer, not element heap data.
4. *Consuming functions*: =Expr.new_explicit=, =build_clone_call_expr= etc. take
   struct params by-ref instead of =own=. The garbager can't detect ownership transfer.
5. *Collection .get()*: copy_to_dynamic memcpy creates aliases. Partially mitigated
   by clone-after-get (Step 9). Map.get eliminated (2026-02-20). Vec/Array/Set .get()
   remain -- should use get + cast (zero-copy pointer into collection storage).

*** Remediation plan

**** Phase 1: Eliminate copying .get() from all collections (no dependencies) -- DONE
All copying .get() methods removed from Vec, Map, Array, Set, List.
All callers converted to get + cast (zero-copy pointer into storage).
(~get~ was previously named ~get_by_ref~, renamed for simplicity.)

=.pop()= methods (Vec.pop, List.pop) are NOT part of Phase 1 -- pop removes the
element from the collection, so a zero-copy pointer into storage would dangle.
Pop needs ownership transfer (move semantics). Ideal API: pop returns a Ptr
(is_borrowed=false), caller uses cast. Internally, pop would get the last
element, clone it, decrement length, return Ptr to the clone. But cloning a
type-erased Dynamic element requires calling =Type.clone()= from =self.type_name=
at runtime -- blocked by Phase 2 (Issue #91, function pointers).

**** Phase 2: Function pointer builtins (Issue #91, minimal scope)
Deep Vec.clone/delete requires calling Type.clone()/Type.delete() on type-erased
Dynamic elements. TIL has no function pointer support (Issue #91). Minimal fix:
4 new builtins that work with raw I64 function pointer values:
- =delete_fn_of(T: Type) returns I64= -- returns address of =til_T_delete=
- =clone_fn_of(T: Type) returns I64= -- returns address of =til_T_clone=
- =call_delete_fn(fn_ptr: I64, elem: Ptr)= -- casts I64 to fn ptr and calls it
- =call_clone_fn(fn_ptr: I64, src: Ptr, dst: Ptr)= -- same for clone

Vec gets two new fields: =delete_fn: I64= and =clone_fn: I64=, set at Vec.new(T)
time when T is still concrete. Vec.delete iterates elements calling delete_fn.
Vec.clone iterates elements calling clone_fn. Map/Set/Array cascade through Vec.

**** Phase 3: =own= params on consuming functions
Functions that embed their parameter data (Expr.new_explicit, build_clone_call_expr,
etc.) must take =own= + =dont_delete= internally. This lets =collect_own_transfers=
exclude caller variables from deletion candidates. Vec.push/set/insert_at already
use this pattern correctly.

**** Phase 4: Garbager skips delete for returned locals
Part of Issue #117 (ASAP destruction). When a local variable is returned
(=return var=), the garbager should NOT insert a delete for it -- the caller
now owns the data via =*_ret=. The garbager already has =dont_delete_vars= --
returned locals should be added to that set.

**** Phase 5: Garbager clone gaps
- Clone ALL Identifier-init declarations (not just mut)
- Clone field-access assignments (remove params.is_empty check)

**** Phase 6: Enable step 3b (local deletion)
With Phases 2-5 complete, local deletion is safe:
- =own= params -> collect_own_transfers excludes consumed variables
- Deep Vec.clone/delete -> no shared element data
- Return move -> returned locals zeroed, deletion is no-op
- Clone gaps -> all declarations/assignments produce owned data

Changes: remove has_any_catch restriction, zero-init hoisted locals,
add delete-before-return (exclude returned var).

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:RELATED: Bug #168 (ccodegen return copies), Issue #117 (ASAP destruction), Issue #100 (get rid of rstil)
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** History

**** 2026-01-01 to 2026-01-08: Initial Approach (Abandoned)
Original approach was to incrementally fix divergences in the existing ccodegen.til
through line-by-line comparison with ccodegen.rs. This proved problematic because:
- ccodegen.til had many missing ports from Rust
- Contained unauthorized workarounds and non-matching comments
- AI assistants kept adding more divergences instead of fixing them
- The accumulation of issues made systematic comparison impossible

**** 2026-01-09: Fresh Rewrite
Decision made to delete all self-hosted compiler files and start fresh:
- Commit ~1f29279a~: "Remove self-hosted compiler files for fresh rewrite"
- Blind translation of ccodegen.til, builder.til, til.til from Rust
- ~150+ commits fixing syntax, types, missing methods, etc.

***** WARNING: Broken Commit Range
Commits from ~1f29279a~ (origin/master + 1) through ~fad411f8~ are ALL BROKEN.
The build fails throughout this range because:
1. Fresh translation introduced many syntax/type errors
2. Each commit fixed some errors but build still failed
3. Only at ~fad411f8~ "Fix uninitialized variables..." does build pass again

This matters for:
- ~git bisect~: Skip this entire range, it's all broken
- ~git rebase -i~: Could squash ~1f29279a..fad411f8~ into single commit
- Archaeology: Don't waste time investigating individual commits in this range

**** 2026-01-12: Progress - Fixed if-let-Ok pattern in init.til
Build passes. 80/80 tests pass (0 failures). Test breakdown:
- 65 tests in all_common (pass all 4 modes) - includes maps.til!
- 1 test in til_common (panic.til)
- 4 tests in rs_interpreted
- 3 tests in rs_compiled
- 7 tests in rs_common
- 0 tests in til_interpreted (empty!)

Recent fixes:
- Fixed gcc stderr handling in builder.til to match Rust (capture stderr, only show on failure)
- Fixed hoisted_exprs collision: clear per-function to avoid cross-file line/col key collisions
- Fixed many if-let-Some translation bugs in ccodegen.til per rs2til.org rules:
  - emit_switch: enum_has_payloads, collect_declarations, payload lookup patterns
  - collect_declarations_recursive: type inference pattern
  - emit_assignment, emit_if, emit_while: vt check patterns
  - Various enum/struct lookup patterns with flag variables
- KEY FIX: Fixed if-let-Ok translation bug in init.til get_fcall_value_type
  - target_type was used after get_value_type could throw, causing garbage data
  - Added flag pattern: ~mut have_target_type := true~ with catch setting to false
  - This fixed enums.til and other nested function + switch case failures
- KEY FIX: Fixed ext.c run_cmd returning wrong exit code when output exceeds 64KB buffer
  - Rust's Command::output() captures all output; ext.c had 64KB limit
  - When buffer filled, pclose() with unread data caused gcc to get SIGPIPE -> non-zero exit
  - Added drain loop to consume remaining output before pclose()
  - This fixed maps.til and allowed moving it to all_common (all 4 modes pass)

*** Root Cause Analysis

The recurring bug pattern was if-let-Some/if-let-Ok translations from Rust:

#+begin_src rust
// Rust: if get_value_type fails, body is skipped
if let Ok(target_type) = get_value_type(context, first_arg) {
    // use target_type
}
#+end_src

#+begin_src til
// WRONG TIL: target_type is garbage if get_value_type throws!
target_type := get_value_type(context, first_arg)
catch (err: Str) { }
switch target_type {  // Uses garbage!
#+end_src

#+begin_src til
// CORRECT TIL: flag pattern per rs2til.org
mut have_target_type := true
target_type := get_value_type(context, first_arg)
catch (err: Str) {
    have_target_type = false
}
if have_target_type {
    switch target_type {  // Safe to use
#+end_src

*** Remaining Work
- 7 tests in rs_common (pass with rstil but not with til)
- Final verification: ~./src/til_diff.til src/til.til~ must show no differences
  - Note: times out at 300s - likely infinite loop (til compiled total is only 80s)

*** Debugging Tools

- ~./src/til_diff.til src/test/foo.til~ - compare rstil vs til generated C code
- ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ - test single file
- ~./make.til til_debug~ - build til with debug symbols for gdb
- ~gdb ./bin/til_debug~ - step through with breakpoints, inspect variable values
- ~gdb -batch -ex "run ..." -ex "bt" ./bin/til~ - get crash backtrace
- Look at ~gen/c/test/*.c~ for generated code

TIL code must be an exact translation from Rust (comments and variable names included)
using rs2til.org translation rules. Any differences detected must be fixed immediately,
even if only cosmetic.

Current test: ~src/test/c_mem.til~

**** Iterative Fix Workflow
1. User picks a test from til_interpreted that they want working in til_compiled
2. Run ~./src/til_diff.til src/test/chosen_test.til~ to compare rstil vs til generated C code
3. Analyze the diff - identify what's different in the generated C
4. Identify root cause in ccodegen.til
5. Verify against Rust - check equivalent code in ccodegen.rs
6. Fix following rs2til.org - apply correct translation pattern
7. Test the fix: ~./bin/til run src/test/chosen_test.til~
8. Run ~timeout 300 make benchmark~ (always use timeout 300 for make benchmark)
9. Re-run all failing tests in parallel to update TODO comments:
   - Run ~timeout 10 ./bin/til run src/test/X.til 2>&1~ for each test in til_interpreted
   - Update inline TODO comments with current errors
   - If any tests now pass, move them from til_interpreted + rs_common to all_common
   - If tests were moved, run ~make benchmark~ again to verify
10. Commit the fix (tests.til now has up-to-date TODOs and test locations)
11. Wait for user to pick next test to fix

**** Test Tracking
Each test in til_interpreted (src/tests.til) has an inline TODO comment explaining
why it fails in til_compiled:
#+BEGIN_SRC til
til_interpreted.push(TestEntry(path="src/test/foo.til"))  // TODO: too few args to til_Array_get
#+END_SRC
When a test passes til_compiled, remove TODO and move to all_common.

**** Updating TODO Comments
- Run ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ for each test to get the error
- Use timeout to catch infinite loops (exit code 124 = timeout)
- Run tests in parallel (multiple Bash tool calls), no shell loops
- NO filtering (no head, tail, grep) - see full output
- Extract the key error from output and add as inline TODO comment

**** Critical Rules
- Source of truth is Rust + rs2til.org - TIL code must match Rust translated per rs2til.org rules
- Validate changes by comparing Rust to TIL - run ~git diff~ and check both sides match per rs2til.org
- Correctness per rs2til.org is primary - whether a change "fixes" a test is secondary
- If change follows rs2til.org but doesn't fix issue - there's a DIFFERENT bug elsewhere
- NEVER filter make benchmark output - see ALL errors
- Variable shadowing is now supported (Bug #97 fixed via name mangling)
- Port fixes to BOTH Rust and TIL when needed

**** Files Modified
- src/self/ccodegen.til
- src/self/builder.til
- src/til.til
- src/rs/ccodegen.rs (when porting fixes)
- src/rs/builder.rs (when porting fixes)
- src/tests.til (when moving tests back to all_common)

*** Progress

**** Fixed Issues (from fresh rewrite)
1. Variable shadowing in emit_declaration (fcall_arg, hoisted_arg, ref_arg)
2. Variable shadowing in builder (reuse errors vector, default_fd rename)
3. Uninitialized variables after throwing calls:
   - detect_variadic_fcall (8 locations)
   - get_type_arg_name
   - lookup_struct
   - get_fcall_func_def in emit_throw
   - get_fcall_func_def in hoist_throwing_expr

**** Issues Found in hello_script.til Diff (2026-01-11)
Current diff from ~./src/til_diff.til src/examples/hello_script.til~:

***** Issue 1: til_Array_get missing 3 arguments
rstil generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1, til_extra_msgs, &_for_i_panic_0, (til_Dynamic*)&til_extra_msg);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1);
#+END_SRC
Affects 5 locations in hello_script.til (lines 101, 132, 165, 185, 233)

****** 2026-01-11: Fixed - Multiple issues in emit_throwing_call* functions
Root cause: Several interrelated bugs in argument emission for throwing function calls.

1. Catch block placement: Catch blocks were placed AFTER emit_arg_with_param_type(),
   so when param_by_ref.get() or param_types.get() threw IndexOutOfBoundsError,
   emit_arg_with_param_type was skipped entirely, causing missing arguments.

2. param_types type mismatch: emit_throwing_call_propagate and emit_throwing_call_with_goto
   stored Vec<Ptr> but hoist_for_dynamic_params expected Vec<ValueType>. This caused
   incorrect Dynamic casts to be applied to all arguments.

3. regular_arg_count defaulting to 0: In emit_throwing_call_with_goto, for non-variadic
   functions, regular_arg_count came from variadic_info.regular_count which defaults to 0.
   The loop `if arg_i.sub(1).gteq(regular_arg_count)` would break immediately.
   Fixed by using 999999999 for non-variadic (matches Rust's usize::MAX pattern).

Fixed in emit_throwing_call, emit_throwing_call_propagate, emit_throwing_call_with_goto:
- Move catch blocks immediately after .get() calls, before emit_arg_with_param_type
- Change param_types from Vec<Ptr> to Vec<ValueType>
- Convert ValueType to Ptr when calling emit_arg_with_param_type
- Use large default for regular_arg_count in non-variadic case

After fix: til_Array_get arguments now match rstil output.
Remaining diffs are hoisting differences (temp var numbering) which are cosmetic.

***** Issue 2: til_malloc missing 1 argument
rstil generates:
#+BEGIN_SRC c
til_I64 _tmp_format_13 = til_add(&til_result.cap, &(til_I64){1});
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12, &_tmp_format_13);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12);
#+END_SRC

***** Issue 3: Hoisting differences
rstil hoists expressions to temp vars:
#+BEGIN_SRC c
til_I64 _tmp_format_14 = til_mul(til_index, &til_self->type_size);
const til_I64 til_src = til_add(&til_self->ptr, &_tmp_format_14);
#+END_SRC
til uses inline compound literals:
#+BEGIN_SRC c
const til_I64 til_src = til_add(&til_self->ptr, &(til_I64){til_mul(til_index, &til_self->type_size)});
#+END_SRC
Both are valid C but cause temp variable numbering drift.

***** Issue 4: .msg inline vs hoisted
rstil hoists format call:
#+BEGIN_SRC c
til_Str _tmp_til_Array_get_7 = til_format(...);
*_err1 = (til_IndexOutOfBoundsError){.msg = _tmp_til_Array_get_7};
#+END_SRC
til inlines:
#+BEGIN_SRC c
*_err1 = (til_IndexOutOfBoundsError){.msg = til_format(...)};
#+END_SRC

****** 2026-01-12: Fixed - is_struct_constructor catch placement in init.til
The is_struct_constructor function in init.til had a catch block placed outside
the if block where the throwing code was:

#+BEGIN_SRC til
// WRONG - catch was outside if block, never catches lookup_struct exceptions
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    return true
}
catch (err: KeyNotFoundError) {  // Never triggered!
    return false
}
#+END_SRC

Fixed by moving the catch inside the if block:

#+BEGIN_SRC til
// CORRECT - catch inside same scope as throwing code
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    catch (err: KeyNotFoundError) {
        return false
    }
    return true
}
#+END_SRC

This fix resolves the hoisting differences - til_diff.til now shows "OK: No differences found!"

****** 2026-01-12: Test re-categorization after is_struct_constructor fix
With the catch placement fix, many tests now pass til_compiled mode.
Updated test categories in src/tests.til:
- 17 tests in all_common (pass all 4 modes)
- 49 tests in til_interpreted (pass til interpret, fail til compile)
- 53 tests in rs_common (pass rstil, fail til compile)

****** 2026-01-12: Discovered til.til run_cmd_vec swallows output
Tests showing "empty output" in til_compiled mode are caused by til.til's
run_cmd_vec function capturing stdout into a variable but never printing it:

#+BEGIN_SRC til
run_cmd_vec := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args { full_cmd = full_cmd.concat(" ").concat(arg) }
    mut output := ""
    return output.run_cmd("bash", "-c", full_cmd)  // output captured but never printed!
}
#+END_SRC

In contrast, rstil.rs uses Command::new().status() which inherits stdout.
This is NOT a ccodegen bug - the C code is identical. Needs separate fix in til.til.

****** 2026-01-12: Fixed run_cmd_vec output swallowing
Added run_cmd_vec_print to sys.til that prints captured output after run_cmd:

#+BEGIN_SRC til
run_cmd_vec_print := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)
    if output.len().gt(0) {
        print(output)
    }
    return exit_code
}
#+END_SRC

Updated til.til's run_file_or_exit to use run_cmd_vec_print instead of run_cmd_vec.
This matches rstil.rs's Command::new().status() behavior of inheriting stdout.

****** 2026-01-12: Final test re-categorization after run_cmd_vec_print fix
Tests that were failing with "empty output" now work correctly.
Updated test categories in src/tests.til:
- 22 tests in all_common (pass all 4 modes)
- 1 test in til_common (panic.til - error msg format differs "til" vs "rstil")
- 43 tests in til_interpreted (pass til interpret, fail til compile)
- 48 tests in rs_common (pass rstil, fail til compile)
- Total: 121 tests, 0 failures

Tests moved to all_common:
- hello_cli.til, hello_script.til, lolalalo.til (examples)
- bug46.til, underscore.til (tests)

****** 2026-01-12: Fixed hello_test.til constant folding
Two fixes to make hello_test.til pass til_compiled:

1. emit_arg_with_param_type in ccodegen.til: Added fc_fd_found flag to prevent
   double-emission when catch block handles KeyNotFoundError. The catch block
   would emit the expression, then code continued to emit it again.

2. is_comptime_evaluable in precomp.til: Changed from lookup_func to
   get_func_def_for_fcall_with_expr for proper UFCS resolution. This allows
   constant folding of expressions like ~not(I64.eq(42, 43))~.

Tests moved to all_common (11 tests):
- hello_test.til, arithmetics.til, boolean.til
- branchless.til, bug41.til, circular_test.til, comparisons.til
- eval.til, intro.til, literals.til, namespaces.til, variadic.til

Tests moved back from all_common (failed til_compiled):
- arenas.til (gcc type mismatch)
- arrays.til (gcc type mismatch)
- bug52.til (gcc shadow warning)
- underscore.til (segfault)

**** Known Error Patterns in Generated C
- ~too few arguments to function~ - missing args in generated calls
- ~undeclared variable~ - variable not emitted

*** Files That Must Match
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Final Verification
~make benchmark~ - all tests pass

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Partial
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Completed (2026-02-17)

- [X] ~mode make~ implemented
- [X] ~file_mtime(path: Str) returns I64~ implemented in src/std/sys.til
- [X] ~glob_files(pattern: Str) returns Vec~ implemented in src/std/sys.til
- [X] ~needs_rebuild(target, deps)~ implemented in make.til
- [X] All build targets in make.til: clean, rstil, repl, rstil_til, til_til,
  til_debug, tests, regen, benchmark, mem-report, test-cross, diff
- [X] ~go_build_yourself()~ - make.til detects when its own source or deps
  change, rebuilds itself via ~./bin/rstil build make.til~, and re-execs
  with the same args. Makefile only bootstraps the first build after clean.

*** Remaining: eliminate the Makefile

The Makefile still does:
1. *Rust bootstrap* (~rustc src/rstil.rs -o bin/rstil~) - irreducible,
   need a compiler before TIL can run at all
2. *First-time make.til compilation* (~./bin/rstil build make.til~) -
   only after clean, then go_build_yourself handles subsequent rebuilds
3. *Entry point delegation* (~./bin/rs/make $(MAKECMDGOALS)~) - so users
   can type ~make benchmark~ instead of ~./bin/rs/make benchmark~
4. *Clean* (~rm -rf bin/* gen/*~) - could move to make.til
5. *Pattern guards* (~%.rs:~, ~%.til:~, ~Makefile:~) - prevent Make from
   treating source files as targets

To fully replace the Makefile, need to solve:
- Rust bootstrap: make.til can't compile rstil because rstil is needed
  to run make.til. Could use a checked-in bootstrap binary, or a tiny
  shell script, or keep a minimal Makefile just for ~bin/rstil~.
- Entry point: users type ~make X~ today. Alternative: ~./make.til X~
  (shebang already exists) or a shell alias.

*** Endgame: C bootstrap, no Makefile

~bootstrap/til.c~ is already checked in (snapshot of self-hosted compiler).
Once it's trustworthy as the primary bootstrap, the entire build becomes:

#+begin_src sh
gcc bootstrap/til.c -o bin/til -lm
./make.til benchmark
#+end_src

No Makefile, no Rust, no rustc. The shebang (~#!/usr/bin/env -S ./bin/til run~)
means ~./make.til benchmark~ works directly. ~go_build_yourself()~ handles
rebuilding make.til when its deps change. The C bootstrap replaces the Rust
bootstrap as the chicken-and-egg solution.

*** Open Questions
- How to handle parallel builds?
- When is bootstrap/til.c trustworthy enough to be the primary bootstrap? (see Issue #100)
