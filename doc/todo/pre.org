#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #161: Namespace constants, static mutables, and per-instance immutables
:PROPERTIES:
:DISCOVERED: 2026-02-04
:IMPACT: Unified syntax for type-level and instance-level data
:STATUS: Open - detailed plan ready
:RELATED: Issue #108 (namespace blocks - implemented)
:END:

*** Overview

Follow-up to Issue #108 (namespace blocks for associated functions). This issue
extends namespaces to support constants and mutable state, and adds per-instance
immutable fields to structs.

After this issue, four kinds of declarations exist:

| Location  | Syntax             | Meaning                          |
|-----------+--------------------+----------------------------------|
| namespace | ~Max := 100~       | Associated constant (static)     |
| namespace | ~mut counter := 0~ | Associated mutable (static)      |
| struct    | ~id := 0~          | Per-instance immutable (frozen)  |
| struct    | ~mut name := ""~   | Per-instance mutable             |

*** Step 1: Associated constants in namespace blocks

Move type-level constants from standalone globals into type namespaces.

**** Current state
Constants are standalone globals with naming conventions:
#+BEGIN_SRC til
MAX_I64 := 9223372036854775807
MIN_I64 := -9223372036854775808
I64_SIZE := 8
#+END_SRC

**** Target state
Constants live in type namespaces:
#+BEGIN_SRC til
namespace I64 {
    Max := 9223372036854775807
    Min := -9223372036854775808
    Size := 8
}
// Usage: I64.Max instead of MAX_I64
#+END_SRC

**** Implementation

***** Step 1.1: Verify namespace blocks support constants
Namespace blocks already support function definitions. Verify they also support
constant declarations (non-mut, non-function). This likely already works since
init.rs merges all namespace members into the type.

Test with:
#+BEGIN_SRC til
namespace I64 {
    TestConst := 42
}
assert_eq(loc(), 42, I64.TestConst)
#+END_SRC

Files to check: init.rs:1311-1400, init.til (NamespaceDef handling)

***** Step 1.2: Audit existing constants
Find all type-related constants in the codebase:
- I64: MAX_I64, MIN_I64, I64_SIZE
- U8: (check if any exist)
- Str: (check if any exist)
- Other types in src/core/

***** Step 1.3: Migrate constants to namespaces
For each type, move constants into namespace blocks:
#+BEGIN_SRC til
// Before (in i64.til)
MAX_I64 := 9223372036854775807

// After (in i64.til)
namespace I64 {
    Max := 9223372036854775807
}
#+END_SRC

***** Step 1.4: Update all usages
Find and replace all old constant names:
- ~MAX_I64~ -> ~I64.Max~
- ~MIN_I64~ -> ~I64.Min~
- etc.

***** Step 1.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 2: Associated mutable state in namespace blocks

Allow ~mut~ declarations in namespace blocks - these work like static variables.

**** Use case
#+BEGIN_SRC til
Soldier := struct {
    mut id := 0
    mut name := "unknown"
}

namespace Soldier {
    mut counter := 0  // Static counter shared by all instances

    new := func(name: Str = "unknown") returns Soldier {
        s := Soldier(id=counter, name=name)
        counter = counter + 1
        return s
    }
}

// Usage:
s1 := Soldier.new("Alice")  // id=0
s2 := Soldier.new("Bob")    // id=1
#+END_SRC

**** Implementation

***** Step 2.1: Parser - allow mut in namespace blocks
Check if parser already accepts ~mut~ declarations in namespace blocks.
If not, update parse_namespace_definition to accept them.

Files: parser.rs, parser.til

***** Step 2.2: Init - register namespace mutables
When init processes NamespaceDef, it currently registers functions.
Extend to also register mutable variables with their initial values.

The mutable needs to be:
- Registered as a symbol with is_mut=true
- Stored in the global scope (not per-instance)

Files: init.rs, init.til

***** Step 2.3: Interpreter - handle namespace mutable access
When evaluating ~TypeName.mutable_var~, look up and return/assign the value.
This is similar to how ~TypeName.constant~ works, but allows mutation.

Files: interpreter.rs, interpreter.til

***** Step 2.4: Ccodegen - emit namespace mutable as static
In C, namespace mutables become static variables:
#+BEGIN_SRC c
// For: namespace Soldier { mut counter := 0 }
static long long til_Soldier_counter = 0;
#+END_SRC

Files: ccodegen.rs, ccodegen.til, scavenger.rs, scavenger.til

***** Step 2.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 3: Per-instance immutable fields in structs

Allow non-mut fields in structs that are set at construction and frozen afterward.

**** Use case
#+BEGIN_SRC til
Entry := struct {
    id := 0              // Immutable after construction
    mut name := ""       // Mutable
    mut desc := ""       // Mutable
}

mut e := Entry(id=get_unique_id(), name="test", desc="description")
e.name = "new name"  // OK - name is mut
e.id = 999           // ERROR - id is not mut, frozen after construction
#+END_SRC

**** Current state
Non-mut fields in structs are currently used for associated constants/functions:
#+BEGIN_SRC til
MyStruct := struct {
    static_const := 42       // Associated constant (no mut)
    mut instance_data := 0   // Instance field (mut)
}
#+END_SRC

After Issue #108, functions are in namespace blocks. But constants in struct
still work as associated constants (e.g., Cell.CHAR_WIDTH in hello_gui.til).

**** Design decision
With namespace blocks, associated constants should move to namespaces (Step 1).
This frees up non-mut struct fields for a new meaning: per-instance immutables.

Migration path:
1. Step 1 moves associated constants to namespaces
2. Step 3 repurposes non-mut fields for instance immutables
3. Deprecation warning for old pattern during transition

**** Implementation

***** Step 3.1: Migrate existing struct constants to namespaces
Before changing semantics, move all existing struct constants to namespace blocks.
Example from hello_gui.til:
#+BEGIN_SRC til
// Before
Cell := struct {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}

// After
Cell := struct {}
namespace Cell {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}
#+END_SRC

***** Step 3.2: Typer - track field mutability
The typer needs to know which struct fields are mutable vs immutable.
Add check: if assigning to a non-mut field after construction, emit error.

Challenge: distinguishing construction from assignment.
- Construction: ~Entry(id=42)~ - allowed to set immutable fields
- Assignment: ~e.id = 42~ - not allowed for immutable fields

Files: typer.rs, typer.til

***** Step 3.3: Interpreter - enforce field immutability
After struct construction, track which fields are frozen.
Reject mutations to immutable fields.

Approach: In eval_set, before modifying a struct field, check if field is mut.
If not mut and struct already exists, error.

Files: interpreter.rs, interpreter.til

***** Step 3.4: Ccodegen - enforce field immutability (optional)
Could add runtime checks in generated C, or rely on typer catching it.
Typer-only enforcement is simpler and sufficient.

***** Step 3.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Testing

**** Step 1 tests
#+BEGIN_SRC til
// Test namespace constants
namespace I64 {
    TestMax := 9223372036854775807
}
assert_eq(loc(), 9223372036854775807, I64.TestMax)
#+END_SRC

**** Step 2 tests
#+BEGIN_SRC til
// Test namespace mutable (static)
Counter := struct {}
namespace Counter {
    mut value := 0
    increment := func() returns I64 {
        value = value + 1
        return value
    }
}
assert_eq(loc(), 1, Counter.increment())
assert_eq(loc(), 2, Counter.increment())
assert_eq(loc(), 2, Counter.value)
#+END_SRC

**** Step 3 tests
#+BEGIN_SRC til
// Test per-instance immutable
ImmutableTest := struct {
    id := 0        // Immutable
    mut name := "" // Mutable
}

mut t := ImmutableTest(id=42, name="test")
assert_eq(loc(), 42, t.id)
t.name = "changed"  // OK
// t.id = 99       // Should error: cannot assign to immutable field
#+END_SRC

*** Verification
1. Run ~make benchmark~ after each step - all tests must pass
2. Port each .rs change to .til immediately
3. Test both interpreter and compiler modes

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Garbager clone prerequisites (DONE)

**[X] Add Str to garbager clone set** - e4788b62
Remove "Str" from primitives exclusion in garbager clone logic.

**[X] Eliminate Str double-copy via arena_offset** - 31a10477
EvalResult carries arena_offset (0 = None) through eval/return/call chains.

**** Step 5: Typer own-consumption analysis (DONE - Bug #162)

Control-flow-aware tracking of variables consumed by ~own~ params.
(Dependency: needed before Step 7 container own params can work.)

File: typer.rs, typer.til:
- Mut check: only ~mut~ params require mut variables, NOT ~own~ params
- Lazy removal tracking via ~RemovedSymbol~ struct + ScopeStack methods:
  ~begin_removal_tracking~, ~end_removal_tracking~, ~removal_mark~,
  ~drain_removals_since~, ~restore_removed~ (replaces full map snapshot/restore,
  cost proportional to actual removals instead of total symbol count)
- ~check_if_statement~: begin tracking, mark/drain/restore per branch.
  After all branches, remove symbols consumed in ALL branches (intersection).
  If-without-else: no definite consumption.
- ~check_switch_statement~: begin tracking, mark/drain/restore per case body
- ~check_func_proc_types~: snapshot before body type-check, restore before
  ~check_body_returns_throws~ (needs UFCS resolution, which needs all symbols)

File: init.rs, init.til:
- Added ~RemovedSymbol~ struct, tracking fields (~removed_log~, ~removal_tracking_depth~)
- Modified ~remove_symbol~ to log when tracking is active
- Added ~Vec.split_off~ to core/vec.til (used by ~drain_removals_since~)

**** Step 6: Ccodegen - remove ~const~ for struct/enum locals (DONE - Bug #162)

Garbager inserts ~Type.delete()~ calls on local variables. C ~const~ prevents
calling ~delete()~ (takes ~mut self~). Remove ~const~ for struct/enum locals.

File: ccodegen.rs, ccodegen.til (7 locations):
1. ~emit_precomputed_vec_assignment~: remove ~is_mut~ param, remove const logic
2. Struct empty init: remove ~if !is_mut { "const " }~
3. Struct zero init: same
4. Struct designated init: same
5. Struct fallback: same
6. Enum declaration: same
7. General const declaration: skip ~const~ for non-primitive TCustom types:
   ~matches!(&decl.value_type, ValueType::TCustom(s) if s != "I64" && ...)~

**** Step 7: Container ~own~ params + clone fixes (DONE)

(Depends on Step 5: typer must accept const vars for ~own~ params.)

~push~, ~set~, ~insert~, ~insert_at~ take ~own value: Dynamic~.
The type checker removes the variable from scope after consumption,
forcing call sites to use ~.clone()~ when they need the value afterwards.

Container files: vec.til, array.til, set.til, list.til, map.til, hashmap.til
- Vec: push, set, insert_at, extend_with (inlined - can't call push with own)
- Array: set
- Set: insert
- List: push, set (both cases: same-size and different-size)
- Map: insert, set
- HashMap: insert, set (compute bucket BEFORE push moves key)

Clone fixes (~own~ params consume variables, call sites need ~.clone()~):
- builder.til: ~insert(core_path.clone())~ x3
- eval_arena.til: ~push(frame.clone())~ x2, ~set(temp_id.clone(), ...)~ x2
- ccodegen.til: ~set(name, idx.clone())~, ~push(pop_idx.clone())~,
  ~set(next, next_degree.clone())~
- interpreter.til: ~set(struct_type, template_offset.clone())~,
  ~set(var_name.clone(), offset)~
- parser.til: ~push(result.clone())~ x2
- init.til: ~name.clone()~ inline (Bug #162 UFCS fix enabled this)
- tests.til: ~push(time_ms.clone())~
- hashmap.til: ~set(bucket_idx, i.clone())~ in resize/remove
- Test/example files: bug57.til, vecs.til, lists.til, maps.til,
  cross_file_forward.til, music.til - loop vars consumed by push/insert

***** Zeroing deferred — replaced by ~dont_delete~ in Step 9
Zeroing (~memset(to_ptr(value), zero, size)~ after copy) was attempted
but removed. TIL's shared-offset reference chain causes zeroing to
cascade: e.g. ~declare_struct(name: Str)~ calls ~Map.set(own key=name)~
which calls ~Vec.insert_at(own value=key)~. Zeroing ~value~ zeroes ~key~
zeroes ~name~ zeroes ~decl.name~ in the original caller. This broke the
entire self-hosted compiler (87/98 test failures).

Replaced by ~dont_delete(value)~ in Step 9: a garbager-phase directive
that tells the garbager to skip inserting ~Type.delete()~ for that
variable and removes the ~dont_delete~ call from the AST. Combined with
~own~ (caller's variable removed from scope), nobody deletes the value.
Heap data lives on in the container, freed when container is deleted.
Same memory behavior as zeroing but no cascading corruption.

***** Bug #162 UFCS + own params (FIXED)
Root cause: ~check_body_returns_throws~ re-walked the AST doing UFCS
resolution after the type-check pass removed own-consumed symbols.
Parameters were not re-declared (unlike locals). Fix: restore removed
symbols before ~check_body_returns_throws~ via removal tracking.
Workarounds in init.til removed.

**** Step 8: ~dont_delete~ directive (replaces zeroing) — DONE

Garbager-phase directive. When the garbager sees ~dont_delete(var)~ in
the AST: (1) add ~var~ to skip set, (2) don't insert ~Type.delete(var)~,
(3) remove the ~dont_delete~ call from AST. No runtime cost — purely
garbager-phase. Used inside container methods with ~own~ params:
#+begin_src til
push := proc(mut self: Vec, own value: Dynamic) {
    dont_delete(value)  // garbager strips this, skips delete for value
    // ... copy bytes into vec ...
}
#+end_src
Files: garbager.rs, garbager.til, mem.til + container files (vec, array, map, etc.)

Implementation: declared as ~ext_func~ in ~mem.til~ so the type checker
accepts it. Garbager strips the calls from FuncDef bodies. ~dont_delete~
placed at top of function body (before any ownership-consuming calls).

Container methods with ~dont_delete~: Vec.push, Vec.set, Vec.extend_with,
Vec.insert_at, Array.set, Set.insert, Map.insert, Map.set,
HashMap.insert, HashMap.set, List.push, List.set.

Prerequisite for Step 9 (Bug #144 fix) and Step 10 (auto-delete).

**** Step 9: Fix ~get~ shallow copy + ~get_by_ref~ + ~create_alias~ (Bug #144)

Current ~get(self, index, mut dest)~ does memcpy (shallow copy). The caller's
local aliases the container element's heap data. Auto-deleting the local
corrupts the container (double-free).

Agreed approach:
1. DONE — ~get_by_ref~ added to Vec, Map, HashMap. Returns borrowed Ptr
   (~offset~ sets ~is_borrowed=1~). Tests in vecs.til and maps.til.
2. DONE — ~create_alias~ standalone ext_func added. Rebinds a local variable's
   arena offset to a Ptr's data address (interpreter) or emits memcpy (compiler).
   Not a Ptr method (wrapper can't rebind caller's variable). Declared in mem.til,
   implemented in ext.rs/ext.til, inline codegen in ccodegen.rs/ccodegen.til.
   Test in pointers.til.
3. Fix Bug #144 — desugarer rewrites ~for item: T in vec~ to use
   ~get_by_ref~ + ~create_alias~ + ~dont_delete~:
#+begin_src til
for _i in 0..vec.len() {
    _ref := vec.get_by_ref(_i)
    mut item := MyStruct()
    create_alias(item, _ref.data)       // zero-copy alias
    dont_delete(item)                   // garbager skips delete
    // user's body
}
#+end_src
4. Decide on ~get~ API — break it (make ~get~ return ref by default) or
   keep both ~get~ (copy) / ~get_by_ref~ (reference).

Dependencies: Step 8 (~dont_delete~), ~get_by_ref~, ~create_alias~ ext_func.
Files: desugarer.rs, desugarer.til, container files, ptr ext_funcs.

**** Step 10: Garbager auto-insert Type.delete() calls

Core implementation, depends on Step 8 (~dont_delete~) and Step 9 (~get_by_ref~ / ~create_alias~).

Refactor: extract inline ~is_primitive~ checks into ~is_deletable_type~ helper.
Replace inline checks in: Declaration handler, Assignment handler,
~transform_fcall_copy_params~, ~transform_struct_literal_fields~.

What gets deleted per function:
- ~copy~ params with struct types (function owns the clone)
- ~own~ params with struct types (function received ownership)
- Local variable declarations with struct types (including Str)

Primitives excluded: I64, U8, Type, Dynamic, Ptr (NOT Str)

Safety: own-transfer tracking. If a variable is passed as ~own~ to another
function anywhere in the body, remove from delete set. Conservative: if
own-transfer is conditional (inside if), still exclude.

Where delete calls are inserted:
1. Before Return: delete all in-scope candidates (minus returned variable)
2. Before Throw: delete all in-scope candidates
3. At function body end: delete function-level candidates (if no return/throw)
4. At nested block end (if/while bodies): delete block-local candidates only
5. Before struct var reassignment: ~x = expr~ -> insert ~Type.delete(x)~ before
6. Field assignment (~l.field = var~): remove var from candidates (ownership transfer)

Synthetic catch-and-rethrow: ~?~ propagation bypasses explicit ~return~/~throw~
where deletes are inserted. For each throw type, append a synthetic catch that
deletes all candidates and rethrows.

Algorithm in garbager_recursive, FuncDef handler:
1. Run existing clone transforms on body -> new_body
2. Collect param_candidates: copy/own params with deletable struct types
3. Scan new_body recursively for own-transfers -> own_transferred set
4. Remove own_transferred vars from param_candidates
5. Call ~insert_deletes_in_stmts(new_body, param_candidates, own_transferred)~ -> final_body

New helper functions:
- ~is_deletable_type(value_type, context)~
- ~build_delete_call_expr(type_name, var_name, line, col)~
- ~collect_own_transfers(stmts, context)~ - scan for own params in FCalls
- ~collect_referenced_vars(expr, result)~ - avoid deleting vars still referenced
- ~insert_deletes_in_stmts(stmts, inherited, own_transferred, context)~ - core

Files: garbager.rs, garbager.til (Rust first, then port to TIL)

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Ownership Model for Containers
- ~push~/~set~/~insert~ use ~own~ params: ownership transfers IN (zeroing deferred to Step 9)
- ~get~ returns borrowed Ptr: no copy, no ownership transfer OUT
- Caller reads through Ptr; to get owned copy, explicitly clone
- This makes the ownership flow clean: containers own their data, ~get~ borrows,
  ~push~/~own~ transfers in. No hidden aliasing from shallow copies.

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

