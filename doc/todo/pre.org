#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #159: copy keyword does shallow copies (byte copy, not clone)
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Affects ASAP destruction safety, copy semantics clarity
:STATUS: Open - implementation plan ready
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Analysis Summary

The ~copy~ keyword and ~mut x := y~ declarations use ~EvalArena::copy_fields()~
which performs a **shallow byte copy**, not a deep clone.

*** What copy_fields Does (eval_arena.rs:239-307)

1. Iterates through struct fields
2. For each mutable field:
   - Reads raw bytes from source offset
   - Writes raw bytes to destination offset
   - Recursively copies nested struct fields

*** The Problem: Shared Heap Pointers

For structs containing ~Ptr~ fields (Vec, Str, Map, etc.), copying creates two
structs pointing to the **same heap allocation**:

#+BEGIN_SRC til
original := Vec.new(I64)
original.push(42)
mut copy := original  // shallow copy - copy.ptr = original.ptr

copy.push(100)        // modifies shared heap data!
println(original.len())  // Also shows 2 - they share the same buffer
#+END_SRC

*** Implications for ASAP Destruction (Issue #117)

This is why Step 4 (liveness analysis) in the garbager was disabled:

#+BEGIN_SRC til
process := proc() {
    data := Vec.new(I64)
    mut backup := data    // shallow copy - both point to same heap
    use(data)             // "last use" of data
    // ASAP would insert: data.delete() here - WRONG!
    // backup.ptr is now dangling
    use(backup)           // CRASH or corruption
}
#+END_SRC

*** Current Behavior vs Expected

| Operation | Current | Expected | Notes |
|-----------+---------+----------+-------|
| ~x := y~ (const) | Reference (alias) | Reference | Safe - can't modify |
| ~mut x := y~ | Shallow byte copy | Deep copy? | Problematic for Ptr |
| ~copy param~ | Shallow byte copy | Deep copy? | Problematic for Ptr |

*** Why This Hasn't Broken Tests

1. **Const bindings are safe**: ~x := y~ creates an alias, no copy
2. **Tests don't share then modify**: Most tests don't copy-then-mutate-both
3. **No ASAP destruction yet**: We manually delete at scope end

*** What Doesn't Need Changing

1. **const bindings** (~x := y~): Already safe - just an alias
2. **Function params** (default): Already pass-by-reference
3. **Primitive copies** (I64, U8, Bool): No heap data, shallow = deep

*** Solution: Auto-generate clone() and use it for copies

Instead of shallow byte copies, we'll use ~clone()~ methods for all copies.
This ensures deep copies that don't share heap allocations.

*** Implementation Plan

**** Step 1: Auto-generate clone() methods

Add to garbager phase (which already auto-generates ~delete()~):

1. For any struct without a ~clone()~ method, generate one
2. Generated clone creates a new instance and clones each field:
   #+BEGIN_SRC til
   // Auto-generated for:
   // MyStruct := struct { mut name: Str, mut data: Vec, mut count: I64 }

   clone := func(self: MyStruct) returns MyStruct {
       return MyStruct(
           name = self.name.clone(),
           data = self.data.clone(),
           count = self.count.clone()  // I64.clone() returns self
       )
   }
   #+END_SRC

3. **Exception for borrowed Ptr fields**: If a field is a borrowed Ptr
   (is_borrowed = true or marked as borrowed in Issue #115), just copy the
   pointer value, don't clone the pointed-to data.

4. **Primitives**: I64, U8, Bool get trivial ~clone()~ that returns self.
   (May already exist or can be added.)

5. **Validation**: Remove manually-written clone() methods that would be
   identical to auto-generated ones. This tests that auto-generation works
   correctly and reduces code duplication.

Files: garbager.rs, garbager.til

**** Step 2: Replace copy_fields() with clone()

**Current copy_fields call sites (interpreter.rs):**

| Line | Context | Pattern |
|------|---------|---------|
| 602 | Struct literal field | ~MyStruct(field = nested_struct)~ |
| 952 | Struct member default | Nested struct in struct definition |
| 1056 | mut declaration | ~mut x := struct_expr~ (Bug #25 fix) |
| 1143 | Assignment | ~x = struct_expr~ |
| 2102 | copy param (saved offsets) | Complex case with name collision |
| 2132 | copy param (identifier) | ~func(copy p: T)~ with variable |
| 2157 | copy param (expression) | ~func(copy p: T)~ with expr |

**Current pattern (complex):**
#+BEGIN_SRC rust
// 1. Allocate destination space
insert_struct_instance(context, &dest, type_name, e)?;
// 2. [lots of temp key setup for arena lookups]
// 3. Copy bytes from source to destination
EvalArena::copy_fields(context, type_name, &src, &dest, e)?;
// 4. [lots of temp key cleanup]
#+END_SRC

**New pattern (simpler):**
#+BEGIN_SRC rust
// 1. Call clone which allocates + returns new instance
let result = call_clone_method(context, type_name, &src, e)?;
// 2. Bind dest name to the cloned instance's offset
context.scope_stack.insert_var(dest, result.offset);
#+END_SRC

**Implementation approach:**

Add helper function in interpreter.rs:
#+BEGIN_SRC rust
/// Call Type.clone(source) and return the cloned instance
fn call_clone_method(ctx: &mut Context, type_name: &str, src: &str, e: &Expr) -> Result<EvalResult, String> {
    // Build AST: Type.clone(src)
    let clone_call = make_ufcs_call(type_name, "clone", vec![make_id(src, e.line, e.col)], e.line, e.col);
    eval_expr(ctx, &clone_call)
}
#+END_SRC

This simplifies the function parameter binding code significantly - no more:
- Temporary frame pushing/popping
- Saved offset management for name collisions
- Temporary key registration and cleanup

When ~copy_fields()~ becomes dead code, Rust warnings will force removal.

Files: interpreter.rs, interpreter.til, eval_arena.rs, eval_arena.til

*** Interaction with Other Issues

- **Issue #117 (ASAP destruction)**: With proper deep copies, Step 4 (liveness
  analysis) becomes safe. No more shared heap pointers from copies.
- **Issue #115 (owned fields)**: Borrowed fields need special handling in
  clone() - copy pointer, don't clone pointed-to data.

*** Testing

1. Write test that copies a Vec, modifies copy, verifies original unchanged
2. Write test that copies nested struct with Vec fields
3. Remove manual clone() methods and verify auto-generated ones work
4. Run ~make benchmark~ - all tests must pass

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Liveness Analysis and Delete Insertion (IN PROGRESS)
Insert ~var.delete()~ call after last use of each owned variable.

**What to delete** (variables we own):
- Local variables (~mut x := ...~)
- ~own~ parameters (ownership transferred to us)
- ~copy~ parameters (we own the copy)

**What NOT to delete** (caller owns):
- Regular parameters (immutable reference)
- ~mut~ parameters (mutable reference, caller still owns)

**When to delete**: After last use, not at function end.

**Simplification**: Switch desugared to if/else before garbager - can ~lang_error~ on Switch.

**Prerequisites satisfied**:
- Bug #159: Deep copy semantics - passing to functions creates independent copies
- preinit: All types have ~delete()~ method auto-generated

Algorithm:
1. Collect owned variables (locals + own params + copy params) with their types
2. Scan statements to find last use index for each variable
3. Insert ~var.delete()~ after the statement containing last use (UFCS transforms to ~Type.delete(var)~)

Handle control flow:
- Linear code: Insert delete right after last use statement
- Early exits (return/throw): Insert deletes for live owned variables before exit (skip returned/thrown var)
- Branches (if/else): Conservative - delete after branch if used in any path
- Loops: Delete after loop (variable may be used across iterations)
- Switch: lang_error (should be desugared)
- Loops: Most conservative - variables used in loop body deleted after loop ends
- Scope exit: Safety net - insert deletes for any remaining live variables at function end

Files: garbager.rs, garbager.til

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

** Issue #108: Implement Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, code organization
:STATUS: In progress - lexer done, parser stub
:RELATED: Issue #107 (First-Class Namespaces)
:END:

*Detailed plan:* See [[file:108.org][doc/todo/108.org]]

*** Current State
Structs are used as namespaces by declaring only constants (no mut).
See src/test/namespaces.til:

#+BEGIN_SRC til
MyNamespace := struct {
    field_static_str : Str = "hello MyNamespace.field_static_str"
    field_static_bool : Bool = true
    field_static_int : I64 = 42

    proc_static := proc() {
        assert_eq(loc(), 42, MyNamespace.field_static_int)
    }

    func_static_str := func() returns Str {
        return "func called"
    }
}
#+END_SRC

*** What Works
- Access static fields: ~MyNamespace.field_static_str~
- Call static functions: ~MyNamespace.func_static_str()~
- Call static procs: ~MyNamespace.proc_static()~

*** What's Missing

A. *Namespace for enums*
   Enums can't have associated functions/constants. Structs can, enums cannot.

   Example: ~clone~. Structs can define a ~clone~ method, but enums cannot:
   #+BEGIN_SRC til
   Tile := enum {
       Object: struct { name := "", pos: struct { x := 0, y := 0 } }
       Monster: SomeStructThatImplementsClone
   }
   // Currently no way to define Tile.clone(), but with namespaces:
   namespace Tile {
       clone := func(self: Tile) returns Tile { TODO("Tile.clone") }
   }
   #+END_SRC

B. *Namespace for structs*
   Currently methods are mixed inside struct definitions. A separate
   namespace keyword would clarify intent and fit better with UFCS.

   #+BEGIN_SRC til
   Str := struct { ... }
   namespace Str {
       len := func(self: Str) returns I64 { ... }
       concat := func(self: Str, other: Str) returns Str { ... }
   }
   #+END_SRC
   Internally treated the same as current struct-embedded methods.

   Can implement step A or step B first - they're independent.

C. *One namespace per type per context*
   Only one ~namespace Foo~ block allowed per type in the same context.
   Could allow spreading across multiple blocks, but no clear gain -
   only potential confusion. Keep it simple: one place for all methods.

*** Keyword Choice
Two options being considered:
- ~namespace~ - matches UFCS concept better, more descriptive
- ~impl~ - shorter, familiar to Rust developers

Example with ~namespace~:
#+BEGIN_SRC til
MyEnum := enum { A, B, C }

namespace MyEnum {
    default := func() returns MyEnum { return MyEnum.A }
    describe := func(self: MyEnum) returns Str { return "an enum" }
}

MyStruct := struct { x: I64 }

namespace MyStruct {
    new := func() returns MyStruct { return MyStruct(x=0) }
    increment := func(self: MyStruct) returns MyStruct { return MyStruct(x=self.x.add(1)) }
}
#+END_SRC

