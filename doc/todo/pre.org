#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #187: Integrated profiling for self-hosted compiler
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Developer experience, performance debugging
:STATUS: Open
:RELATED: Issue #183 (memory reduction), Bug #165 (memory leak)
:END:

*** Problem

The self-hosted TIL compiler uses 5-8 GB of memory per test in interpreted mode
and build times are measured in minutes. There is no way to know where the time
or memory is going without external tools and guesswork. Every optimization
attempt (Issue #183, Bug #165) involves blind changes and full rebuild cycles
to measure impact.

*** Proposed Solution

Add built-in profiling to the interpreter and/or compiled output:
- Memory: track allocations per phase (parser, init, typer, desugarer, etc.)
- Time: measure wall-clock time per phase
- Optionally: per-function call counts and cumulative time

Output a summary at the end of a run (opt-in via flag or mode), e.g.:
#+begin_example
Phase          Time     Allocs   Memory
parser         1.2s     12,340   45 MB
init           3.4s     98,200   512 MB
typer          2.1s     45,600   230 MB
...
#+end_example

This would make memory/performance work targeted instead of blind.

** Issue #185: Require ~own~ keyword at call sites, improve consumed-variable errors
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Usability, readability, better error messages
:STATUS: Open
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned struct fields)
:END:

*** Problem

When a function takes an ~own~ parameter, the caller just passes the variable
normally. After the call, the variable is consumed (removed from scope by the
garbager's ~collect_own_transfers~). If the caller tries to use it afterwards,
they get "undefined symbol" -- a confusing error that doesn't explain WHY the
symbol disappeared.

#+begin_src til
// Current: caller doesn't mark ownership transfer
tokens.push(expr)   // 'expr' silently consumed if push takes 'own'
println(expr.name)  // ERROR: "Undefined symbol 'expr'" -- confusing!
#+end_src

*** Proposed solution

*Part 1: Require ~own~ at call sites*

The caller must explicitly write ~own~ when passing to an ~own~ parameter:

#+begin_src til
tokens.push(own expr)   // explicit: caller acknowledges transfer
println(expr.name)      // ERROR: better message (see Part 2)
#+end_src

Without ~own~ at the call site, the type checker should error:
"Parameter 'value' of 'Vec.push' requires ownership transfer. Use 'own expr'."

*Part 2: Better error for consumed variables*

When a variable has been consumed by an ~own~ transfer, the error should say:
"Variable 'expr' is no longer available -- ownership was transferred to
'Vec.push' at line 42."

This requires tracking which function consumed which variable (the garbager's
~collect_own_transfers~ already knows this, but the information isn't propagated
to error messages).

** Issue #184: Integer-based enum comparison (replace string comparison)
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Performance -- enum switch/eq currently allocates and compares strings
:STATUS: Open
:RELATED: Bug #165 (memory leak), Bug #169 (get rid of memcmp), Issue #106 (first-class enums)
:END:

*** Problem

Enum variant comparison in the interpreter uses string comparison. The
desugarer transforms ~switch~ on enums to:

#+BEGIN_SRC til
// Desugared: eq(var, enum_to_str(CasePattern))
eq(switch_var, enum_to_str(ValueType.TCustom))
#+END_SRC

Every case in every switch allocates a temporary Str via ~enum_to_str~.
With 722 format() calls and thousands of switch evaluations during
compilation, this leaks significant memory and wastes cycles on strcmp.

In compiled C, enums are already integers (~typedef enum { ... }~) or
tagged unions (~.tag~ field). Comparison is fast integer ~==~. The
interpreter should match.

*** Proposed solution

1. Assign I64 constants to each variant during preinit/init (like C does):
   ~ValueType.TCustom = 0, ValueType.TFunction = 1, ...~ etc.

2. Auto-generate ~eq~ method on all enums in preinit (like delete/clone):
   #+BEGIN_SRC til
   eq : func(a: MyEnum, b: MyEnum) returns Bool = {
       return a.tag.eq(b.tag)  // integer comparison
   }
   #+END_SRC

3. Update desugarer to use ~EnumType.eq(var, pattern)~ instead of
   ~eq(var, enum_to_str(pattern))~ for switch cases.

4. The ~value_type_to_str(x).eq(value_type_to_str(y))~ pattern used in
   17+ sites across interpreter/typer/ufcs/precomp becomes
   ~ValueType.eq(x, y)~ -- no string allocation, just integer compare.

*** Why not desugar enums to structs in TIL?

Recurring thought: "should enums desugar to structs directly in TIL
instead of being a special case through to ccodegen?"

The blocker is unions. TIL only has tagged unions (enums), not raw unions.
We don't want raw unions -- Rust doesn't have them outside ~unsafe~, and
we agree with Rust on this. Enums ARE the tagged union type.

But the tag itself can be an I64 constant instead of a string. This gets
most of the performance benefit without needing to desugar the enum type
away.

*** Scope

- preinit: auto-generate ~eq~ method for all enums
- desugarer: use enum eq instead of enum_to_str + string eq
- interpreter: enum values store integer tag alongside string (or replace)
- Replace ~value_type_to_str(x).eq(value_type_to_str(y))~ with ~ValueType.eq(x, y)~
  across 17+ sites in interpreter.til, typer.til, ufcs.til, precomp.til

** Issue #183: Manual delete calls as temporary memory management
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Memory leak reduction until #117 automates destruction
:STATUS: Open
:RELATED: Issue #117 (ASAP Destruction), Bug #165 (200-800x memory leak), Bug #159 (shallow copies)
:END:

*** Description

Until Issue #117 (ASAP Destruction) is fully implemented, manually insert
~.delete()~ calls in TIL source code where variables go out of scope or
are no longer needed -- the same way you would in C.

*** Why this is safe

- ~delete()~ implementations already handle double-frees safely. The eval
  heap tracks allocations, so deleting an already-freed pointer is a no-op
  (or logged), not undefined behavior.
- Redundant deletes are harmless -- they just waste a few cycles on the
  check.
- As #117 automates more deletion patterns, the manual deletes become
  redundant and can be removed incrementally.

*** Approach

1. Identify hot spots: functions that allocate heavily (format, concat,
   split, clone, to_str, Vec/Map operations) and don't free results
2. Add explicit ~result.delete()~ or ~temp.delete()~ calls after last use
3. Focus on the self-hosted compiler files first (biggest memory consumers)
4. Verify with benchmarks that memory usage drops without crashes

*** Why not dont_delete (the opposite approach)

~dont_delete~ was tried before -- assume everything gets deleted, whitelist
what should be skipped. It never worked because shallow-copy aliasing (#159)
makes it impossible to reliably know what is safe to skip. Too many hidden
aliases, too many false negatives.

This approach flips it: nothing gets deleted by default, you manually add
deletes only where you *know* the value is owned and no longer needed.
Double-frees are harmless (eval heap catches them), so being overly
aggressive with deletes is safe. Being overly aggressive with dont_delete
was not (missing one alias = use-after-free).

*** Attempt 1: scope_stack.pop()?.delete() -- no measurable improvement

Replaced all 28 ~_ := context.scope_stack.pop()?~ sites with
~context.scope_stack.pop()?.delete()~ across interpreter.til, typer.til,
ufcs.til, precomp.til, desugarer.til, init.til.

Result: 0 memory improvement. Garbager likely already inserts delete for
the popped ScopeFrame, or the Maps inside are already freed by Vec.pop
internals. The change is correct and harmless but not where the big leaks
are. All sites marked with ~// TODO remove this #183 workaround~.

*** Attempt 2: StructDef.delete() for cloned locals -- small improvement

Key finding: ~lookup_struct~ returns an alias in the interpreter (pointer
into scope stack's map), not an owned copy. Deleting lookup results causes
SIGSEGV (all 89 tests crash). Only *cloned* StructDef locals are safe to
delete.

Two sites added:
- typer.til ~check_struct_def~: ~merged_struct~ (cloned via ~lookup_result.clone()~)
- init.til ~register_struct_fields_for_typecheck~: ~struct_def~ (cloned via ~lookup_struct()?.clone()~)

Result: til_interpreted 8227MB -> 8160MB (-67MB), til_built 21834MB -> 21757MB (-77MB).
Small but real. Most StructDef locals come from ~lookup_struct~ (alias), so
few sites are safe without first cloning the lookup result.

*** Relationship to #117

This is a manual version of what #117 will automate. Each manual delete
we add now is a site where #117's auto-delete will eventually take over.
When #117 handles a pattern, we remove the corresponding manual delete.

** Issue #179: ~cast()~ should work as function argument, not just declarations
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Better error messages now, more flexible cast usage later
:STATUS: Open
:RELATED:
:END:

*** Description

~cast(Type, expr)~ currently only works as a declaration directive:

#+BEGIN_SRC til
// WORKS -- cast in declaration
x := cast(I64, v.get(0)?)

// FAILS -- cast as function argument
result := add_one(cast(I64, v.get(0)?))
// Interpreter: "Core function 'cast' not implemented"
// Compiler: gcc error "implicit declaration of function 'til_cast'"

// FAILS -- cast with UFCS
x := cast(I64, v.get(0)?).add(1)
// Same errors as above
#+END_SRC

*** Phase 1: Reject invalid usage in typer

The typer should detect and reject ~cast()~ when used in unsupported positions:
1. As a function argument
2. As the receiver of a UFCS method call
3. Any position other than the RHS of a ~:=~ declaration

Currently these fail silently in the interpreter ("Core function 'cast' not
implemented") or at gcc level ("implicit declaration of function 'til_cast'").
A clear typer error is much better.

Workaround: extract to declaration:
#+BEGIN_SRC til
// Instead of: result := add_one(cast(I64, v.get(0)?))
e0 := cast(I64, v.get(0)?)
result := add_one(e0)
#+END_SRC

*** Phase 2: Support cast as function argument

Teach the interpreter and ccodegen to handle ~cast()~ in argument position
so that ~func(cast(Type, expr))~ works directly without needing a temporary
declaration. UFCS on cast results (~cast(...).method()~) would also work.

** Issue #175: Unify C calling convention -- all functions return through ~_ret~ pointer
:PROPERTIES:
:DISCOVERED: 2026-02-19
:IMPACT: Major ccodegen simplification, fewer special cases, enables future optimizations
:STATUS: Open - implementation plan ready
:RELATED: Bug #168 (ret_var_alias optimization), Bug #173 (missing *_ret assignment), doc/first_class.org (function pointer typedefs)
:END:

*** Background

Currently, ccodegen uses two different C calling conventions depending on
whether a function throws:

#+BEGIN_SRC c
// Non-throwing: returns value directly
til_I64 til_add(const til_I64* til_I64_a, const til_I64* til_I64_b);
result = til_add(&a, &b);

// Throwing: returns status code, value through _ret pointer
int til_parse(til_Ast* _ret, til_ParseError* _err1, const til_Str* til_Str_s);
status = til_parse(&result, &err, &s);
#+END_SRC

This bifurcation infects the entire ccodegen:
- ~emit_func_signature~: branches on ~is_throwing~ for return type and _ret param
- ~emit_fcall~: completely different code paths for calling throwing vs non-throwing
- ~emit_declaration~: different hoisting logic depending on whether RHS is throwing
- ~emit_return~: ~return value;~ vs ~*_ret = value; return 0;~
- ~find_ret_var_for_placement~ / ~ret_var_alias~: only applies to throwing functions
  (non-throwing return directly, so no ~_ret~ to alias)
- Function pointer typedefs (Issue #91): would need two typedef patterns

*** Solution: all functions return through ~_ret~ pointer

#+BEGIN_SRC c
// Non-throwing (NEW): void, returns through _ret
void til_add(til_I64* _ret, const til_I64* til_I64_a, const til_I64* til_I64_b);
til_add(&result, &a, &b);

// Throwing (UNCHANGED): int status, returns through _ret
int til_parse(til_Ast* _ret, til_ParseError* _err1, const til_Str* til_Str_s);
status = til_parse(&result, &err, &s);

// Proc (UNCHANGED): void, no _ret
void til_greet(const til_Str* til_Str_name);
til_greet(&name);
#+END_SRC

Now every function with a return type uses ~_ret~. The only difference
between throwing and non-throwing is whether there's an int return + error
pointers. Call sites all follow the same pattern.

*** What simplifies

| Area                      | Before (two paths)                      | After (one path)                    |
|---------------------------+-----------------------------------------+-------------------------------------|
| ~emit_func_signature~     | if throwing: int + _ret param,          | Always _ret param if returns.       |
|                           | else: return type directly              | void if non-throwing, int if throws |
| ~emit_fcall~ call site    | if throwing: pass &result as _ret,      | Always pass &result as _ret         |
|                           | else: result = func(...)                |                                     |
| ~emit_return~             | if throwing: *_ret = val; return 0;     | Always *_ret = val; return;         |
|                           | else: return val;                       | (or return 0 if throwing)           |
| ~find_ret_var_for_placement~ | Only for throwing functions           | All functions with return type      |
| ~ret_var_alias~           | Only for throwing functions              | All functions with return type      |
| ~emit_declaration~ (RHS)  | Different hoisting for throwing vs not   | Same hoisting for all               |
| Function pointer typedefs | Two patterns needed                     | One pattern                         |

*** Current Architecture (reference for implementation)

Functions involved and their locations:

| Function                       | Rust (ccodegen.rs) | TIL (ccodegen.til) |
|--------------------------------+--------------------+---------------------|
| ~emit_func_signature~          | line 3455          | line 4207           |
| ~emit_fcall~                   | line 6509          | line 7975           |
| ~emit_fcall_arg_string~        | line 1468          | line 1812           |
| ~emit_arg_string~              | line 794           | line 961            |
| ~emit_return~                  | line 5897          | line 7214           |
| ~emit_declaration~             | line 5284          | line 6419           |
| ~emit_throwing_call~           | line 4332          | line 5318           |
| ~emit_throwing_call_propagate~ | line 5178          | line 5746           |
| ~emit_throwing_call_with_goto~ | line (near 4113)   | line 6072           |
| ~find_ret_var_for_placement~   | line 186           | line 212            |
| ~resolve_var_name~             | line 125           | line 165            |
| ~emit_struct_func_body~        | line 3278          | line 4002           |
| ~emit_func_prototype~          | line 3567          | line 4338           |
| ~emit_func_declaration~        | line 3598          | line 4384           |

*** Key finding: expression-level calls are already broken

At ~emit_fcall~ lines 7140-7150 (Rust), there is a WORKAROUND comment:
non-throwing calls at expression level (indent==0) with arguments that need
hoisting (throwing/variadic/by-ref non-lvalues) CANNOT be hoisted because
the code is already mid-expression. The comment says "may cause compilation
errors" and "a proper fix would require restructuring emit_fcall".

Unifying the convention fixes this by forcing ALL function calls through
the statement-level hoisting path. No more inline ~f(g(x))~ in generated C;
everything gets hoisted to temp vars, which is what throwing calls already do.

*** Implementation Plan

This plan was implemented in failed branch oom175, but failed due to OOM and differences in til and rust generated C.

**** Step 1: ~emit_func_signature~ -- always emit ~_ret~ for functions with returns

Current branching (rs:3456-3500):
- ~is_throwing~ -> return type is ~int~, emit ~RetType* _ret~ + error params
- not throwing -> return type is the actual type, no ~_ret~

New logic:
#+BEGIN_SRC
if has_return_types:
    if is_throwing:
        return type = "int"
    else:
        return type = "void"
    always emit: RetType* _ret as first param
else (proc):
    return type = "void"
    no _ret
#+END_SRC

The ~_ret~ param is emitted whenever ~return_types~ is non-empty,
regardless of ~is_throwing~. Error params (~_err1~, etc.) still only
appear for throwing functions.

Files: ccodegen.rs:3455-3564, ccodegen.til:4207

**** Step 2: ~emit_return~ -- always use ~*_ret = value~

Current (rs:5897-5980):
- Throwing: ~*_ret = value; return 0;~ (with ret_var_alias optimization)
- Non-throwing: ~return value;~ directly

New logic: ALL functions with return types use ~*_ret~:
- Has returns + throws: ~*_ret = value; return 0;~ (unchanged)
- Has returns + no throws: ~*_ret = value; return;~ (new)
- No returns (proc): ~return;~ (unchanged)

The ~ret_var_alias~ optimization (skip copy if returning the alias var)
now applies to ALL functions with return types.

Files: ccodegen.rs:5897-5980, ccodegen.til:7214

**** Step 3: ~find_ret_var_for_placement~ -- remove ~is_throwing~ guard

Current (rs:188): ~if func_def.throw_types.is_empty() { return Ok(String::new()); }~
This early-returns for non-throwing functions, disabling the optimization.

Remove this guard. The optimization (alias return variable to ~*_ret~ pointer)
now applies to ALL functions with return types and struct/enum returns.

Also update ALL call sites that set ~ctx.ret_var_alias~:
- ~emit_struct_func_body~ (rs:3347-3349, rs:3677-3679)
- ~emit_declaration~ for nested functions (rs:5376-5377)

Files: ccodegen.rs:186-250, ccodegen.til:212

**** Step 4: ~emit_struct_func_body~ -- update implicit returns

Current (rs:3358-3365):
- Throwing: ~return 0;~ (success status)
- Non-throwing with return: ~return (Type){0};~ (zero-initialized default)

New:
- Throwing: ~return 0;~ (unchanged)
- Non-throwing with return: ~*_ret = (Type){0}; return;~
- No return (proc): no implicit return (unchanged)

Files: ccodegen.rs:3278-3380, ccodegen.til:4002

**** Step 5: ~emit_fcall~ statement-level -- non-throwing calls use ~_ret~ pattern

Current statement-level (indent>0) non-throwing call:
~til_func_name(arg1, arg2);~ -- call is a standalone statement, or
~result = til_func_name(arg1, arg2);~ -- result captured by assignment

New: ALL calls with return types use the same pattern as throwing calls:
1. Declare temp: ~RetType _tmp_N;~
2. Call: ~til_func_name(&_tmp_N, arg1, arg2);~
3. Use ~_tmp_N~ where the result is needed

For throwing calls, additionally: ~int _status_N = ...~ and error check.

The key change is in how ~emit_arg_string~ and ~emit_fcall_arg_string~
handle non-throwing FCalls. Currently ~emit_fcall_arg_string~ returns the
call as an inline string (~til_func(args)~). After the change, ALL FCalls
must be hoisted to temp vars, same as throwing calls.

Approach: in ~emit_arg_string~ (rs:810-816), currently only throwing FCalls
get special hoisting. Extend this to ALL FCalls with return types. The
~emit_throwing_call_propagate~ pattern (hoist to temp, pass ~_ret~ pointer)
becomes the universal pattern.

Files: ccodegen.rs:794-920, 1468-1750, 6509-7179, ccodegen.til:961, 1812, 7975

**** Step 6: ~emit_fcall~ expression-level -- force hoisting

Current expression-level (indent==0) non-throwing calls are emitted inline.
This is ALREADY BROKEN for nested throwing/variadic args (rs:7140-7150).

After unification, expression-level FCalls with return types cannot exist
inline (void functions can't be expressions). Two options:

*Option A*: Eliminate expression-level calls entirely. All FCalls get hoisted
at the ~emit_arg_string~ level before reaching ~emit_fcall~. The expression-
level path in ~emit_fcall~ becomes dead code for user-defined functions.

*Option B*: Keep expression-level for struct constructors (compound literals)
and builtins that emit inline C (like ~type_as_str~, ~enum_to_str~). Only
user-defined function calls get hoisted.

Recommendation: Option B. Struct constructors and inline builtins don't
actually call C functions, so they're unaffected by the convention change.

Files: ccodegen.rs:7115-7158, ccodegen.til equivalent

**** Step 7: ~emit_declaration~ -- unify RHS handling

Current (rs:5284-5450):
- Throwing RHS: handled by ~emit_throwing_call_propagate~
- Non-throwing RHS: handled by ~emit_arg_string~ -> inline call string

After: both paths use the same logic. The call writes to ~_ret~ pointer.
For declarations like ~x := func_call()~, the flow becomes:
1. Declare ~x~ (unless it's the ~ret_var_alias~)
2. Call ~func(&x, args)~ -- writes result directly into ~x~

This eliminates the ~result = func(args)~ pattern entirely for declarations.

Files: ccodegen.rs:5284-5450, ccodegen.til:6419

**** Step 8: Update builtins in ~emit_fcall~

Hardcoded builtins in ~emit_fcall~ (rs:6636-6900+) that generate inline
C code are NOT affected (they don't generate actual function calls):
- ~type_as_str~ -> emits Str compound literal
- ~enum_to_str~ -> emits ~EnumType_to_str(&arg)~ (already a call, needs update)
- ~enum_get_payload~ -> emits field access
- ~enum_get_payload_type~ -> emits ~to_str~ call (needs update)

Builtins that generate actual C function calls (like ~enum_to_str~ calling
the generated ~_to_str~ function) need to use the new convention IF those
generated C functions also change. Since ~enum_to_str~ calls auto-generated
~_to_str~ which returns ~Str~ directly, this needs updating too.

Files: ccodegen.rs:6636+, ccodegen.til equivalent

**** Step 9: ext_func/ext_proc declarations

External functions (~ext_func~, ~ext_proc~) are declarations with no body.
They map to C functions with the OLD convention. Since we don't control
the C implementation of ext_funcs, they must keep their current signatures.

Approach: in ~emit_fcall~, detect calls to ext_funcs and use the old
call-site pattern (~result = ext_func(args)~). Or, emit thin wrappers
that translate between conventions.

Alternatively: since most ext_funcs are builtins handled by inline codegen
in ~emit_fcall~, the actual ext_funcs that generate real C calls may be
very few. Audit needed.

Files: src/core/*.til, ccodegen.rs, ccodegen.til

**** Step 10: ~main~ function special case

The ~main~ function returns ~int~ to the OS. This is already a special case
and stays that way. Just ensure the main function prototype emission skips
the ~_ret~ treatment.

**** Step 11: Port all changes to TIL and test

Every change to ccodegen.rs must be ported to ccodegen.til. Run:
~make clean && systemd-run --user --scope -p MemoryMax=40G -p MemorySwapMax=0 make benchmark~

All 93+ tests must pass. The generated C changes significantly but behavior
must be identical.

*** Notes

- This change also simplifies future Issue #91 (function pointer typedefs):
  all function pointers follow the same ~void (*fp)(RetType* _ret, ...)~
  pattern, with ~int~ return only for throwing variants.
- The generated C loses ~x = add(&a, &b)~ style (slightly less idiomatic),
  but when reading generated C for debugging, one consistent pattern is
  easier to follow than two different patterns depending on throws.
- Fixes the broken expression-level hoisting at rs:7140-7150 as a side effect.
- The ~emit_throwing_call~ / ~emit_throwing_call_propagate~ functions serve
  as the template for the unified call pattern. The non-throwing version is
  the same minus the status check and error handling.

** Issue #161: Namespace constants, static mutables, and per-instance immutables
:PROPERTIES:
:DISCOVERED: 2026-02-04
:IMPACT: Unified syntax for type-level and instance-level data
:STATUS: Open - detailed plan ready
:RELATED: Issue #108 (namespace blocks - implemented)
:END:

*** Overview

Follow-up to Issue #108 (namespace blocks for associated functions). This issue
extends namespaces to support constants and mutable state, and adds per-instance
immutable fields to structs.

After this issue, four kinds of declarations exist:

| Location  | Syntax             | Meaning                          |
|-----------+--------------------+----------------------------------|
| namespace | ~Max := 100~       | Associated constant (static)     |
| namespace | ~mut counter := 0~ | Associated mutable (static)      |
| struct    | ~id := 0~          | Per-instance immutable (frozen)  |
| struct    | ~mut name := ""~   | Per-instance mutable             |

*** Step 1: Associated constants in namespace blocks

Move type-level constants from standalone globals into type namespaces.

**** Current state
Constants are standalone globals with naming conventions:
#+BEGIN_SRC til
MAX_I64 := 9223372036854775807
MIN_I64 := -9223372036854775808
I64_SIZE := 8
#+END_SRC

**** Target state
Constants live in type namespaces:
#+BEGIN_SRC til
namespace I64 {
    Max := 9223372036854775807
    Min := -9223372036854775808
    Size := 8
}
// Usage: I64.Max instead of MAX_I64
#+END_SRC

**** Implementation

***** Step 1.1: Verify namespace blocks support constants
Namespace blocks already support function definitions. Verify they also support
constant declarations (non-mut, non-function). This likely already works since
init.rs merges all namespace members into the type.

Test with:
#+BEGIN_SRC til
namespace I64 {
    TestConst := 42
}
assert_eq(loc(), 42, I64.TestConst)
#+END_SRC

Files to check: init.rs:1311-1400, init.til (NamespaceDef handling)

***** Step 1.2: Audit existing constants
Find all type-related constants in the codebase:
- I64: MAX_I64, MIN_I64, I64_SIZE
- U8: (check if any exist)
- Str: (check if any exist)
- Other types in src/core/

***** Step 1.3: Migrate constants to namespaces
For each type, move constants into namespace blocks:
#+BEGIN_SRC til
// Before (in i64.til)
MAX_I64 := 9223372036854775807

// After (in i64.til)
namespace I64 {
    Max := 9223372036854775807
}
#+END_SRC

***** Step 1.4: Update all usages
Find and replace all old constant names:
- ~MAX_I64~ -> ~I64.Max~
- ~MIN_I64~ -> ~I64.Min~
- etc.

***** Step 1.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 2: Associated mutable state in namespace blocks

Allow ~mut~ declarations in namespace blocks - these work like static variables.

**** Use case
#+BEGIN_SRC til
Soldier := struct {
    mut id := 0
    mut name := "unknown"
}

namespace Soldier {
    mut counter := 0  // Static counter shared by all instances

    new := func(name: Str = "unknown") returns Soldier {
        s := Soldier(id=counter, name=name)
        counter = counter + 1
        return s
    }
}

// Usage:
s1 := Soldier.new("Alice")  // id=0
s2 := Soldier.new("Bob")    // id=1
#+END_SRC

**** Implementation

***** Step 2.1: Parser - allow mut in namespace blocks
Check if parser already accepts ~mut~ declarations in namespace blocks.
If not, update parse_namespace_definition to accept them.

Files: parser.rs, parser.til

***** Step 2.2: Init - register namespace mutables
When init processes NamespaceDef, it currently registers functions.
Extend to also register mutable variables with their initial values.

The mutable needs to be:
- Registered as a symbol with is_mut=true
- Stored in the global scope (not per-instance)

Files: init.rs, init.til

***** Step 2.3: Interpreter - handle namespace mutable access
When evaluating ~TypeName.mutable_var~, look up and return/assign the value.
This is similar to how ~TypeName.constant~ works, but allows mutation.

Files: interpreter.rs, interpreter.til

***** Step 2.4: Ccodegen - emit namespace mutable as static
In C, namespace mutables become static variables:
#+BEGIN_SRC c
// For: namespace Soldier { mut counter := 0 }
static long long til_Soldier_counter = 0;
#+END_SRC

Files: ccodegen.rs, ccodegen.til, scavenger.rs, scavenger.til

***** Step 2.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 3: Per-instance immutable fields in structs

Allow non-mut fields in structs that are set at construction and frozen afterward.

**** Use case
#+BEGIN_SRC til
Entry := struct {
    id := 0              // Immutable after construction
    mut name := ""       // Mutable
    mut desc := ""       // Mutable
}

mut e := Entry(id=get_unique_id(), name="test", desc="description")
e.name = "new name"  // OK - name is mut
e.id = 999           // ERROR - id is not mut, frozen after construction
#+END_SRC

**** Current state
Non-mut fields in structs are currently used for associated constants/functions:
#+BEGIN_SRC til
MyStruct := struct {
    static_const := 42       // Associated constant (no mut)
    mut instance_data := 0   // Instance field (mut)
}
#+END_SRC

After Issue #108, functions are in namespace blocks. But constants in struct
still work as associated constants (e.g., Cell.CHAR_WIDTH in hello_gui.til).

**** Design decision
With namespace blocks, associated constants should move to namespaces (Step 1).
This frees up non-mut struct fields for a new meaning: per-instance immutables.

Migration path:
1. Step 1 moves associated constants to namespaces
2. Step 3 repurposes non-mut fields for instance immutables
3. Deprecation warning for old pattern during transition

**** Implementation

***** Step 3.1: Migrate existing struct constants to namespaces
Before changing semantics, move all existing struct constants to namespace blocks.
Example from hello_gui.til:
#+BEGIN_SRC til
// Before
Cell := struct {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}

// After
Cell := struct {}
namespace Cell {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}
#+END_SRC

***** Step 3.2: Typer - track field mutability
The typer needs to know which struct fields are mutable vs immutable.
Add check: if assigning to a non-mut field after construction, emit error.

Challenge: distinguishing construction from assignment.
- Construction: ~Entry(id=42)~ - allowed to set immutable fields
- Assignment: ~e.id = 42~ - not allowed for immutable fields

Files: typer.rs, typer.til

***** Step 3.3: Interpreter - enforce field immutability
After struct construction, track which fields are frozen.
Reject mutations to immutable fields.

Approach: In eval_set, before modifying a struct field, check if field is mut.
If not mut and struct already exists, error.

Files: interpreter.rs, interpreter.til

***** Step 3.4: Ccodegen - enforce field immutability (optional)
Could add runtime checks in generated C, or rely on typer catching it.
Typer-only enforcement is simpler and sufficient.

***** Step 3.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Testing

**** Step 1 tests
#+BEGIN_SRC til
// Test namespace constants
namespace I64 {
    TestMax := 9223372036854775807
}
assert_eq(loc(), 9223372036854775807, I64.TestMax)
#+END_SRC

**** Step 2 tests
#+BEGIN_SRC til
// Test namespace mutable (static)
Counter := struct {}
namespace Counter {
    mut value := 0
    increment := func() returns I64 {
        value = value + 1
        return value
    }
}
assert_eq(loc(), 1, Counter.increment())
assert_eq(loc(), 2, Counter.increment())
assert_eq(loc(), 2, Counter.value)
#+END_SRC

**** Step 3 tests
#+BEGIN_SRC til
// Test per-instance immutable
ImmutableTest := struct {
    id := 0        // Immutable
    mut name := "" // Mutable
}

mut t := ImmutableTest(id=42, name="test")
assert_eq(loc(), 42, t.id)
t.name = "changed"  // OK
// t.id = 99       // Should error: cannot assign to immutable field
#+END_SRC

*** Verification
1. Run ~make benchmark~ after each step - all tests must pass
2. Port each .rs change to .til immediately
3. Test both interpreter and compiler modes

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open - Steps 1-9 done, Step 10A done, Step 10B done (98/98 pass)
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation), Bug #144 (for-in by-ref), Bug #168 (ccodegen return copies)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Garbager clone prerequisites (DONE)

**[X] Add Str to garbager clone set** - e4788b62
Remove "Str" from primitives exclusion in garbager clone logic.

**[X] Eliminate Str double-copy via arena_offset** - 31a10477
EvalResult carries arena_offset (0 = None) through eval/return/call chains.

**** Step 5: Typer own-consumption analysis (DONE - Bug #162)

Control-flow-aware tracking of variables consumed by ~own~ params.
(Dependency: needed before Step 7 container own params can work.)

File: typer.rs, typer.til:
- Mut check: only ~mut~ params require mut variables, NOT ~own~ params
- Lazy removal tracking via ~RemovedSymbol~ struct + ScopeStack methods:
  ~begin_removal_tracking~, ~end_removal_tracking~, ~removal_mark~,
  ~drain_removals_since~, ~restore_removed~ (replaces full map snapshot/restore,
  cost proportional to actual removals instead of total symbol count)
- ~check_if_statement~: begin tracking, mark/drain/restore per branch.
  After all branches, remove symbols consumed in ALL branches (intersection).
  If-without-else: no definite consumption.
- ~check_switch_statement~: begin tracking, mark/drain/restore per case body
- ~check_func_proc_types~: snapshot before body type-check, restore before
  ~check_body_returns_throws~ (needs UFCS resolution, which needs all symbols)

File: init.rs, init.til:
- Added ~RemovedSymbol~ struct, tracking fields (~removed_log~, ~removal_tracking_depth~)
- Modified ~remove_symbol~ to log when tracking is active
- Added ~Vec.split_off~ to core/vec.til (used by ~drain_removals_since~)

**** Step 6: Ccodegen - remove ~const~ for struct/enum locals (DONE - Bug #162)

Garbager inserts ~Type.delete()~ calls on local variables. C ~const~ prevents
calling ~delete()~ (takes ~mut self~). Remove ~const~ for struct/enum locals.

File: ccodegen.rs, ccodegen.til (7 locations):
1. ~emit_precomputed_vec_assignment~: remove ~is_mut~ param, remove const logic
2. Struct empty init: remove ~if !is_mut { "const " }~
3. Struct zero init: same
4. Struct designated init: same
5. Struct fallback: same
6. Enum declaration: same
7. General const declaration: skip ~const~ for non-primitive TCustom types:
   ~matches!(&decl.value_type, ValueType::TCustom(s) if s != "I64" && ...)~

**** Step 7: Container ~own~ params + clone fixes (DONE)

(Depends on Step 5: typer must accept const vars for ~own~ params.)

~push~, ~set~, ~insert~, ~insert_at~ take ~own value: Dynamic~.
The type checker removes the variable from scope after consumption,
forcing call sites to use ~.clone()~ when they need the value afterwards.

Container files: vec.til, array.til, set.til, list.til, map.til, hashmap.til
- Vec: push, set, insert_at, extend_with (inlined - can't call push with own)
- Array: set
- Set: insert
- List: push, set (both cases: same-size and different-size)
- Map: insert, set
- HashMap: insert, set (compute bucket BEFORE push moves key)

Clone fixes (~own~ params consume variables, call sites need ~.clone()~):
- builder.til: ~insert(core_path.clone())~ x3
- eval_arena.til: ~push(frame.clone())~ x2, ~set(temp_id.clone(), ...)~ x2
- ccodegen.til: ~set(name, idx.clone())~, ~push(pop_idx.clone())~,
  ~set(next, next_degree.clone())~
- interpreter.til: ~set(struct_type, template_offset.clone())~,
  ~set(var_name.clone(), offset)~
- parser.til: ~push(result.clone())~ x2
- init.til: ~name.clone()~ inline (Bug #162 UFCS fix enabled this)
- tests.til: ~push(time_ms.clone())~
- hashmap.til: ~set(bucket_idx, i.clone())~ in resize/remove
- Test/example files: bug57.til, vecs.til, lists.til, maps.til,
  cross_file_forward.til, music.til - loop vars consumed by push/insert

***** Zeroing deferred — replaced by ~dont_delete~ in Step 9
Zeroing (~memset(to_ptr(value), zero, size)~ after copy) was attempted
but removed. TIL's shared-offset reference chain causes zeroing to
cascade: e.g. ~declare_struct(name: Str)~ calls ~Map.set(own key=name)~
which calls ~Vec.insert_at(own value=key)~. Zeroing ~value~ zeroes ~key~
zeroes ~name~ zeroes ~decl.name~ in the original caller. This broke the
entire self-hosted compiler (87/98 test failures).

Replaced by ~dont_delete(value)~ in Step 9: a garbager-phase directive
that tells the garbager to skip inserting ~Type.delete()~ for that
variable and removes the ~dont_delete~ call from the AST. Combined with
~own~ (caller's variable removed from scope), nobody deletes the value.
Heap data lives on in the container, freed when container is deleted.
Same memory behavior as zeroing but no cascading corruption.

***** Bug #162 UFCS + own params (FIXED)
Root cause: ~check_body_returns_throws~ re-walked the AST doing UFCS
resolution after the type-check pass removed own-consumed symbols.
Parameters were not re-declared (unlike locals). Fix: restore removed
symbols before ~check_body_returns_throws~ via removal tracking.
Workarounds in init.til removed.

**** Step 8: ~dont_delete~ directive (replaces zeroing) — DONE

Garbager-phase directive. When the garbager sees ~dont_delete(var)~ in
the AST: (1) add ~var~ to skip set, (2) don't insert ~Type.delete(var)~,
(3) remove the ~dont_delete~ call from AST. No runtime cost — purely
garbager-phase. Used inside container methods with ~own~ params:
#+begin_src til
push := proc(mut self: Vec, own value: Dynamic) {
    dont_delete(value)  // garbager strips this, skips delete for value
    // ... copy bytes into vec ...
}
#+end_src
Files: garbager.rs, garbager.til, mem.til + container files (vec, array, map, etc.)

Implementation: declared as ~ext_func~ in ~mem.til~ so the type checker
accepts it. Garbager strips the calls from FuncDef bodies. ~dont_delete~
placed at top of function body (before any ownership-consuming calls).

Container methods with ~dont_delete~: Vec.push, Vec.set, Vec.extend_with,
Vec.insert_at, Array.set, Set.insert, Map.insert, Map.set,
HashMap.insert, HashMap.set, List.push, List.set.

Prerequisite for Step 9 (Bug #144 fix) and Step 10 (auto-delete).

**** Step 9: Fix ~get~ shallow copy + ~get~ (zero-copy) + ~create_alias~ (Bug #144) — DONE

The old copying ~get(self, index, mut dest)~ did memcpy (shallow copy). The
caller's local aliased the container element's heap data. Auto-deleting the
local corrupted the container (double-free).

Agreed approach:
1. DONE — zero-copy ~get~ added to Vec, Map, HashMap (previously named
   ~get_by_ref~, renamed for simplicity). Returns borrowed Ptr (~offset~
   sets ~is_borrowed=1~). Tests in vecs.til and maps.til.
2. DONE — ~create_alias~ standalone ext_func added. Rebinds a local variable's
   arena offset to a Ptr's data address (interpreter) or emits memcpy (compiler).
   Not a Ptr method (wrapper can't rebind caller's variable). Declared in mem.til,
   implemented in ext.rs/ext.til, inline codegen in ccodegen.rs/ccodegen.til.
   Test in pointers.til.
3. DONE — Fix Bug #144 — 3-arg compound directive ~create_alias(item, MyStruct, addr)~.
   Declares variable + aliases to address + skips auto-delete, all in one FCall.
   No wasteful default construction, no separate ~dont_delete~. Every phase with
   scope tracking recognizes it: init, typer, ufcs, precomp, ccodegen, interpreter.
   Desugared for-in for non-primitives is now:
#+begin_src til
_ref := get(vec, _for_i_func_N)
catch (...) { panic(...) }
create_alias(item, MyStruct, _ref.data)   // declares + aliases + skips delete
// user's body
#+end_src
   Performance gain modest (~0.6%), see Bug #144 for details. But the real
   value is correctness: create_alias variables are properly excluded from
   auto-delete, which is what Step 10 needs. Without this, Step 10 would
   double-free for-in loop variables over containers.
4. DONE — Renamed ~get_by_ref~ to ~get~. The old copying ~get~ was removed,
   so the name is free for the zero-copy version.

Dependencies: Step 8 (~dont_delete~), ~get~, ~create_alias~ ext_func.
Files: desugarer.rs, desugarer.til, container files, ptr ext_funcs,
  ufcs.rs, ufcs.til, precomp.rs, precomp.til, init.rs, init.til,
  typer.rs, typer.til, ccodegen.rs, ccodegen.til, ext.rs, ext.til,
  garbager.rs, garbager.til, mem.til, pointers.til.

**** Step 10A: Auto-insert Type.delete() at function body end — DONE

Files: ~src/rs/garbager.rs~ and ~src/self/garbager.til~

Implementation complete. 98/98 tests pass. Two fixes needed after initial implementation:
- ~is_deletable_type~: check struct has mutable fields (not just is-a-struct).
  Empty structs (EmptyStruct, BadAlloc, DivideByZero) have no heap data.
- Catch guard: any catch block (not just non-final) means throws can skip
  declarations, making unconditional deletes at function end unsafe.

***** Edits (Rust)

****** 1. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC rust
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
fn is_deletable_type(type_name: &str, context: &Context) -> bool {
    let is_primitive = matches!(type_name, "I64" | "U8" | "Type" | "Dynamic" | "Ptr");
    !is_primitive && context.scope_stack.has_struct(type_name)
}
#+END_SRC

****** 2. Replace 4 inline is_primitive checks with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType::Declaration~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType::Assignment~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if is_primitive || !context.scope_stack.has_struct(type_name) {
:          continue;
:      }
: NEW: if !is_deletable_type(type_name, context) {
:          continue;
:      }

NOTE: Location D uses inverted logic (continue if NOT deletable).
NOTE: The new helper adds "Ptr" to the exclusion list. This is intentional
(per Step 10 design in pre.org Issue #117). Doesn't change existing behavior
since Ptr was never in has_struct().

****** 3. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC rust
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
fn build_delete_call_expr(type_name: &str, var_name: &str, line: usize, col: usize) -> Expr {
    let delete_ident = Expr::new_explicit(
        NodeType::Identifier("delete".to_string()), vec![], line, col);
    let type_delete_access = Expr::new_explicit(
        NodeType::Identifier(type_name.to_string()), vec![delete_ident], line, col);
    let var_expr = Expr::new_explicit(
        NodeType::Identifier(var_name.to_string()), vec![], line, col);
    Expr::new_explicit(NodeType::FCall(false), vec![type_delete_access, var_expr], line, col)
}
#+END_SRC

****** 4. Add ~get_create_alias_var~ helper (after ~get_dont_delete_var~)

#+BEGIN_SRC rust
/// Extract variable name from create_alias(var, type, addr) call.
fn get_create_alias_var(e: &Expr) -> Option<String> {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(name) = get_func_name(e) {
            if name == "create_alias" && e.params.len() >= 3 {
                if let NodeType::Identifier(var_name) = &e.params[1].node_type {
                    return Some(var_name.clone());
                }
            }
        }
    }
    None
}
#+END_SRC

****** 5. Add ~collect_own_transfers~ helpers (after ~get_create_alias_var~)

#+BEGIN_SRC rust
/// Scan statements for variables passed as `own` args to function calls.
fn collect_own_transfers(stmts: &[Expr], context: &Context) -> HashSet<String> {
    let mut result = HashSet::new();
    for stmt in stmts {
        collect_own_transfers_recursive(stmt, context, &mut result);
    }
    result
}

fn collect_own_transfers_recursive(e: &Expr, context: &Context, result: &mut HashSet<String>) {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(func_name) = get_func_name(e) {
            if !func_name.ends_with(".clone") && !func_name.ends_with(".delete") {
                if let Some(func_def) = context.scope_stack.lookup_func(&func_name) {
                    for (i, arg_def) in func_def.args.iter().enumerate() {
                        let param_idx = i + 1;
                        if param_idx < e.params.len() && arg_def.is_own {
                            if let NodeType::Identifier(var_name) = &e.params[param_idx].node_type {
                                if e.params[param_idx].params.is_empty() {
                                    result.insert(var_name.clone());
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    for param in &e.params {
        collect_own_transfers_recursive(param, context, result);
    }
    if let NodeType::FuncDef(func_def) = &e.node_type {
        for stmt in &func_def.body {
            collect_own_transfers_recursive(stmt, context, result);
        }
    }
}
#+END_SRC

****** 6. Replace FuncDef handler (the ~NodeType::FuncDef~ arm in ~garbager_recursive~)

Replace the entire ~NodeType::FuncDef(func_def) => { ... }~ arm:

#+BEGIN_SRC rust
        NodeType::FuncDef(func_def) => {
            // Step 1: Strip dont_delete calls, collect protected var names
            let mut new_body = Vec::new();
            let mut dont_delete_vars: HashSet<String> = HashSet::new();
            for stmt in &func_def.body {
                if is_dont_delete_call(stmt) {
                    if let Some(var_name) = get_dont_delete_var(stmt) {
                        dont_delete_vars.insert(var_name);
                    }
                    continue;
                }
                // Step 2: Collect create_alias var names
                if let Some(alias_var) = get_create_alias_var(stmt) {
                    dont_delete_vars.insert(alias_var);
                }
                new_body.push(garbager_recursive(context, stmt)?);
            }

            // Step 3: Collect delete candidates
            let mut candidates: Vec<(String, String)> = Vec::new();

            // 3a: copy/own params with deletable types
            for arg_def in &func_def.args {
                if arg_def.is_copy || arg_def.is_own {
                    if let ValueType::TCustom(type_name) = &arg_def.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((arg_def.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // 3b: Scan new_body for Declaration nodes with deletable types
            for stmt in &new_body {
                if let NodeType::Declaration(decl) = &stmt.node_type {
                    if let ValueType::TCustom(type_name) = &decl.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((decl.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // Step 4: Remove dont_delete_vars and own-transferred vars
            let own_transfers = collect_own_transfers(&new_body, context);
            candidates.retain(|(var_name, _)| {
                !dont_delete_vars.contains(var_name) && !own_transfers.contains(var_name)
            });

            // Step 5: Append Type.delete(var) calls in reverse declaration order
            let last_line = new_body.last().map_or(e.line, |s| s.line);
            let last_col = new_body.last().map_or(e.col, |s| s.col);
            candidates.reverse();
            for (var_name, type_name) in &candidates {
                new_body.push(build_delete_call_expr(type_name, var_name, last_line, last_col));
            }

            let new_func_def = SFuncDef {
                function_type: func_def.function_type.clone(),
                args: func_def.args.clone(),
                return_types: func_def.return_types.clone(),
                throw_types: func_def.throw_types.clone(),
                body: new_body,
                source_path: func_def.source_path.clone(),
            };
            let mut new_params = Vec::new();
            for param in &e.params {
                new_params.push(garbager_recursive(context, param)?);
            }
            Ok(Expr::new_explicit(NodeType::FuncDef(new_func_def), new_params, e.line, e.col))
        }
#+END_SRC

***** Edits (TIL)

****** 7. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC til
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    return not(is_primitive).and(context.scope_stack.has_struct(type_name))
}
#+END_SRC

****** 8. Replace 4 inline is_primitive checks in TIL with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType.Declaration~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType.Assignment~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

****** 9. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC til
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}
#+END_SRC

****** 10. Add ~get_dont_delete_var~ to TIL (after ~is_dont_delete_call~)

Currently missing from TIL. Rust version is ~get_dont_delete_var~ in garbager.rs.

#+BEGIN_SRC til
/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str {
    if e.params.len().lt(2) {
        return ""
    }
    mut param1 := Expr()
    e.params.get(1, param1)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}
#+END_SRC

****** 11. Add ~get_create_alias_var~ to TIL (after ~get_dont_delete_var~)

#+BEGIN_SRC til
/// Extract variable name from create_alias(var, type, addr) call.
get_create_alias_var := func(e: Expr) returns Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.eq("create_alias").and(e.params.len().gteq(3)) {
            mut param1 := Expr()
            e.params.get(1, param1)?
            catch (err: IndexOutOfBoundsError) {
                return ""
            }
            switch param1.node_type {
            case NodeType.Identifier(var_name):
                return var_name
            case:
            }
        }
    case:
    }
    return ""
}
#+END_SRC

****** 12. Add ~collect_own_transfers~ to TIL (after ~get_create_alias_var~)

Uses Vec<Str> instead of HashSet. Returns the Vec directly.

#+BEGIN_SRC til
/// Scan statements for variables passed as `own` args to function calls.
collect_own_transfers := proc(stmts: Vec, context: Context) returns Vec {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, result)
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, mut result: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.len().gt(0).and(not(func_name.ends_with(".clone"))).and(not(func_name.ends_with(".delete"))) {
            mut func_def := SFuncDef()
            mut found := false
            func_def = context.scope_stack.lookup_func(func_name)?
            found = true
            catch (err: KeyNotFoundError) { }
            if found {
                for i in 0..func_def.args.len() {
                    mut arg_def := Declaration()
                    func_def.args.get(i, arg_def)?
                    catch (err: IndexOutOfBoundsError) { }
                    param_idx := i.add(1)
                    if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                        mut param_expr := Expr()
                        e.params.get(param_idx, param_expr)?
                        catch (err: IndexOutOfBoundsError) { }
                        switch param_expr.node_type {
                        case NodeType.Identifier(var_name):
                            if param_expr.params.len().eq(0) {
                                result.push(var_name)
                            }
                        case:
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, result)
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, result)
        }
    case:
    }
}
#+END_SRC

****** 13. Replace FuncDef handler in TIL (the ~NodeType.FuncDef~ case in ~garbager_recursive~)

Replace from ~case NodeType.FuncDef(func_def):~ through ~return Expr.new_explicit(...)~:

#+BEGIN_SRC til
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        mut new_body := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                // Step 2: Collect create_alias var names
                alias_var := get_create_alias_var(stmt)
                if alias_var.len().gt(0) {
                    dont_delete_vars.push(alias_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types
        for stmt: Expr in new_body {
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(decl.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            case:
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        own_transfers := collect_own_transfers(new_body, context)
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            mut var_name := ""
            cand_vars.get(i, var_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut type_name := ""
            cand_types.get(i, type_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut excluded := false
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 5: Append Type.delete(var) calls in reverse declaration order
        mut last_line := e.line
        mut last_col := e.col
        if new_body.len().gt(0) {
            mut last_stmt := Expr()
            new_body.get(new_body.len().sub(1), last_stmt)?
            catch (err: IndexOutOfBoundsError) { }
            last_line = last_stmt.line
            last_col = last_stmt.col
        }
        mut ri := filtered_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            mut del_var := ""
            filtered_vars.get(ri, del_var)?
            catch (err: IndexOutOfBoundsError) { }
            mut del_type := ""
            filtered_types.get(ri, del_type)?
            catch (err: IndexOutOfBoundsError) { }
            new_body.push(build_delete_call_expr(del_type, del_var, last_line, last_col))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)
#+END_SRC

**** Step 10B: ASAP last-use deletion for copy/own params — DONE

Files: ~src/rs/garbager.rs~, ~src/self/garbager.til~, ~src/self/ccodegen.til~

Moves ~Type.delete(var)~ calls from function body END to right after the
variable's last use — but only for ~copy~/~own~ params (deep copies, no aliasing).
Locals stay at function end (shared offsets mean locals can alias through
field assignment).

***** New helpers (both Rust + TIL)

- ~expr_references_var(e, var_name) -> bool~: Recursively checks if any
  Identifier node in the expression tree matches var_name. Recurses into
  e.params but NOT into nested FuncDef bodies (separate scope).

- ~find_last_use_index(body, var_name) -> Option<usize>~ (Rust) /
  ~-> I64~ (TIL, -1 = not found): Scans body from end to start, returns
  index of last statement referencing the variable.

***** Modified Step 5 logic

Step 5 now separates candidates into two groups:
- ~asap_candidates~ (copy/own params): insert delete after last use via
  HashMap (Rust) / parallel Vecs (TIL) for insertion positions
- ~end_candidates~ (locals): append at function end in reverse declaration order

When multiple deletes land at the same position, they appear in reverse
declaration order (last declared -> first deleted).

***** Bug fix: dont_delete for field aliases in ccodegen.til

ASAN revealed a pre-existing double-free from Step 10A in
~emit_precomputed_vec_assignment~: ~elem_type := contents.element_type_name~
creates a shared-pointer alias. Both ~Str.delete(elem_type)~ and
~VecContents.delete(contents)~ freed the same Str. Fixed with
~dont_delete(elem_type)~. Rust version uses ~&contents.element_type_name~
(a reference), so no issue there.

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Ownership Model for Containers
- ~push~/~set~/~insert~ use ~own~ params: ownership transfers IN (zeroing deferred to Step 9)
- ~get~ returns borrowed Ptr: no copy, no ownership transfer OUT
- Caller reads through Ptr; to get owned copy, explicitly clone
- This makes the ownership flow clean: containers own their data, ~get~ borrows,
  ~push~/~own~ transfers in. No hidden aliasing from shallow copies.

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Bug #168: ccodegen return values create copies the interpreter doesn't
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic divergence between interpreter and compiled code; root cause of memory leak gap
:STATUS: Partial -- commits 1/1b/2 on master, commit 3 (non-throwing out-ptr) reverted
:RELATED: Bug #159 (shallow copies), Bug #165 (memory leak), Bug #80 (ccodegen divergence), Issue #117 (ASAP destruction)
:END:

*** Description
In the interpreter, function returns are shared offsets -- no copy happens.
In ccodegen, every struct return is a memcpy:
#+begin_src c
*_ret = value;          // callee: struct assignment = implicit memcpy
var = func_call();      // caller: receives shallow copy
#+end_src

This means ccodegen creates copies the interpreter never does. The original
value in the callee's scope is abandoned (heap pointers aliased, never freed).
This is the fundamental semantic gap between interpreter and compiled memory
behavior, and the reason compiled TIL leaks far more than interpreted.

In C, return values are effectively pointer-based anyway (NRVO, hidden
destination pointer). The memcpy is semantically unnecessary. Same applies
to throw values and out params.

*** Why this matters
- #117 (ASAP destruction) can't be completed for ccodegen while returns
  create aliases the interpreter doesn't have
- #80 (ccodegen match) can't be verified because compiled TIL eats too
  much memory to run =make diff til.til=
- #100 (self-hosting) is blocked by #80 which is blocked by this

*** Inventory -- all ccodegen shallow copies
- =*_ret = value;= -- callee struct return (696 remaining, was 976)
- =return value;= -- non-throwing by-value return (485), implicit memcpy at call site
- =create_alias= -- emits =memcpy(&var, (void*)addr, sizeof(type))= where
  interpreter does =insert_var(name, addr)= (pure offset binding, zero copy)
- =enum_get_payload= -- shallow memcpy of enum payload data

*** Implementation

**** Commit 1: Throwing calls -- eliminate intermediate =_ret_N= temp -- DONE

Throwing functions already use the out-pointer pattern. Eliminated the
unnecessary intermediate temp at call sites:

#+begin_src c
// BEFORE:
til_Str _ret_N;                              // temp
int _status_N = func(&_ret_N, &_err, args);  // write to temp
dest = _ret_N;                               // UNNECESSARY COPY

// AFTER:
int _status_N = func(&dest, &_err, args);    // write to dest directly
#+end_src

Added =build_dest_ptr_expr= helper. Modified =emit_throwing_call_propagate=
and =emit_throwing_call_with_goto= to skip temp, use dest ptr, skip copy.
Ported to ccodegen.til. On master at 639c1741.

**** Commit 1b: Catch-block variant of commit 1 -- DONE

Same call-site direct-write optimization for throwing calls with local catch
blocks (=emit_throwing_call_with_goto=). On master at 7c383c6f.

**** Commit 2: Callee-side placement via ret_var_alias -- DONE

=find_ret_var_for_placement= detects when all return paths use the same variable.
That variable is aliased to =(*_ret)= so construction writes directly to the
out-pointer, eliminating the callee-side =*_ret = local_var;= copy.

Safety checks: variable not reassigned, not a parameter, no parameter shares
the return type. =has_declaration_of= prevents global constants (true/false)
from being treated as ret_var_alias candidates.

On master at 7e698d7a.

**** Result

=*_ret == copies in bootstrap/til.c: 976 -> 696 (280 eliminated, 29% reduction).

**** What remains

- 696 =*_ret == copies in throwing functions where =find_ret_var_for_placement=
  can't optimize (multiple return variables, reassignment, etc.)
- 485 non-throwing =return til_*= statements (by-value return = implicit memcpy
  at call site)
- =create_alias= emits memcpy instead of pointer alias (see below)
- =enum_get_payload= shallow memcpy of payload

**** Next: create_alias should use pointer, not memcpy

The interpreter handles =create_alias= by binding the variable name to the source
address (=insert_var(name, addr)=). Zero copy. ccodegen emits =memcpy=, creating
a shallow copy. The C equivalent of offset binding is a pointer cast:

#+begin_src c
// CURRENT (shallow copy):
til_MyStruct elem;
memcpy(&elem, (void*)addr, sizeof(til_MyStruct));

// CORRECT (true alias, matches interpreter):
til_MyStruct* elem = (til_MyStruct*)addr;
#+end_src

This requires ccodegen to track that =elem= is a pointer-alias and emit =elem->field=
instead of =elem.field=. Similar to how by-ref parameters are already handled.

**** Failed attempt: non-throwing out-ptr (reverted)

Extended out-pointer convention to non-throwing struct-returning functions:
=void func(Type* _ret, ...)= instead of =Type func(args)=.

- Added 963 lines to ccodegen.til, 610 lines to ccodegen.rs
- bootstrap/til.c grew by ~27k lines
- Build slowed 30% (730s -> 949s), primarily til_interpreted (+35%)
- Expression-position calls required temp vars no better than by-value return
- Reverted: cost far exceeded benefit

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Partial
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Completed (2026-02-17)

- [X] ~mode make~ implemented
- [X] ~file_mtime(path: Str) returns I64~ implemented in src/std/sys.til
- [X] ~glob_files(pattern: Str) returns Vec~ implemented in src/std/sys.til
- [X] ~needs_rebuild(target, deps)~ implemented in make.til
- [X] All build targets in make.til: clean, rstil, repl, rstil_til, til_til,
  til_debug, tests, regen, benchmark, mem-report, test-cross, diff
- [X] ~go_build_yourself()~ - make.til detects when its own source or deps
  change, rebuilds itself via ~./bin/rstil build make.til~, and re-execs
  with the same args. Makefile only bootstraps the first build after clean.

*** Remaining: eliminate the Makefile

The Makefile still does:
1. *Rust bootstrap* (~rustc src/rstil.rs -o bin/rstil~) - irreducible,
   need a compiler before TIL can run at all
2. *First-time make.til compilation* (~./bin/rstil build make.til~) -
   only after clean, then go_build_yourself handles subsequent rebuilds
3. *Entry point delegation* (~./bin/rs/make $(MAKECMDGOALS)~) - so users
   can type ~make benchmark~ instead of ~./bin/rs/make benchmark~
4. *Clean* (~rm -rf bin/* gen/*~) - could move to make.til
5. *Pattern guards* (~%.rs:~, ~%.til:~, ~Makefile:~) - prevent Make from
   treating source files as targets

To fully replace the Makefile, need to solve:
- Rust bootstrap: make.til can't compile rstil because rstil is needed
  to run make.til. Could use a checked-in bootstrap binary, or a tiny
  shell script, or keep a minimal Makefile just for ~bin/rstil~.
- Entry point: users type ~make X~ today. Alternative: ~./make.til X~
  (shebang already exists) or a shell alias.

*** Endgame: C bootstrap, no Makefile

~bootstrap/til.c~ is already checked in (snapshot of self-hosted compiler).
Once it's trustworthy as the primary bootstrap, the entire build becomes:

#+begin_src sh
gcc bootstrap/til.c -o bin/til -lm
./make.til benchmark
#+end_src

No Makefile, no Rust, no rustc. The shebang (~#!/usr/bin/env -S ./bin/til run~)
means ~./make.til benchmark~ works directly. ~go_build_yourself()~ handles
rebuilding make.til when its deps change. The C bootstrap replaces the Rust
bootstrap as the chicken-and-egg solution.

*** Open Questions
- How to handle parallel builds?
- When is bootstrap/til.c trustworthy enough to be the primary bootstrap? (see Issue #100)
