#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Liveness Analysis and Delete Insertion
Add liveness analysis to track when variables are last used, then insert ~var.delete()~ calls.

Data structure:
#+BEGIN_SRC rust
struct VarLifetime {
    name: String,
    value_type: ValueType,
    last_use_stmt_idx: Option<usize>,
    is_deleted: bool,
}
#+END_SRC

Note: No need for ~has_delete~ field - after Step 3, every struct has ~delete()~.

Algorithm:
1. Analysis pass: Scan statements, track last use index per variable
2. Transform pass: Insert ~var.delete()~ statement after last_use_stmt_idx

Handle control flow:
- Early exits (return/throw): Insert deletes for all still-live variables before exit
- Branches (if/else/switch): Conservative - only delete if ALL paths agree variable is dead, otherwise delete after branch
- Loops: Most conservative - variables used in loop body deleted after loop ends
- Scope exit: Safety net - insert deletes for any remaining live variables at function end

Files: garbager.rs, garbager.til

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

** Issue #108: Implement Namespaces
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, code organization
:STATUS: Open
:RELATED: Issue #107 (First-Class Namespaces)
:END:

*Detailed plan:* See [[file:108.org][doc/todo/108.org]]

*** Current State
Structs are used as namespaces by declaring only constants (no mut).
See src/test/namespaces.til:

#+BEGIN_SRC til
MyNamespace := struct {
    field_static_str : Str = "hello MyNamespace.field_static_str"
    field_static_bool : Bool = true
    field_static_int : I64 = 42

    proc_static := proc() {
        assert_eq(loc(), 42, MyNamespace.field_static_int)
    }

    func_static_str := func() returns Str {
        return "func called"
    }
}
#+END_SRC

*** What Works
- Access static fields: ~MyNamespace.field_static_str~
- Call static functions: ~MyNamespace.func_static_str()~
- Call static procs: ~MyNamespace.proc_static()~

*** What's Missing

A. *Namespace for enums*
   Enums can't have associated functions/constants. Structs can, enums cannot.

   Example: ~clone~. Structs can define a ~clone~ method, but enums cannot:
   #+BEGIN_SRC til
   Tile := enum {
       Object: struct { name := "", pos: struct { x := 0, y := 0 } }
       Monster: SomeStructThatImplementsClone
   }
   // Currently no way to define Tile.clone(), but with namespaces:
   namespace Tile {
       clone := func(self: Tile) returns Tile { TODO("Tile.clone") }
   }
   #+END_SRC

B. *Namespace for structs*
   Currently methods are mixed inside struct definitions. A separate
   namespace keyword would clarify intent and fit better with UFCS.

   #+BEGIN_SRC til
   Str := struct { ... }
   namespace Str {
       len := func(self: Str) returns I64 { ... }
       concat := func(self: Str, other: Str) returns Str { ... }
   }
   #+END_SRC
   Internally treated the same as current struct-embedded methods.

   Can implement step A or step B first - they're independent.

C. *One namespace per type per context*
   Only one ~namespace Foo~ block allowed per type in the same context.
   Could allow spreading across multiple blocks, but no clear gain -
   only potential confusion. Keep it simple: one place for all methods.

*** Keyword Choice
Two options being considered:
- ~namespace~ - matches UFCS concept better, more descriptive
- ~impl~ - shorter, familiar to Rust developers

Example with ~namespace~:
#+BEGIN_SRC til
MyEnum := enum { A, B, C }

namespace MyEnum {
    default := func() returns MyEnum { return MyEnum.A }
    describe := func(self: MyEnum) returns Str { return "an enum" }
}

MyStruct := struct { x: I64 }

namespace MyStruct {
    new := func() returns MyStruct { return MyStruct(x=0) }
    increment := func(self: MyStruct) returns MyStruct { return MyStruct(x=self.x.add(1)) }
}
#+END_SRC

** Issue #110: Desugar switch to if/else in desugarer
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Simplify interpreter and ccodegen, reduce internal complexity
:STATUS: Ready to resume - rebase wip110final onto master
:BRANCH: wip110final (59 commits behind master, needs rebase)
:RELATED: Bug #143 (FIXED), Bug #144, Issue #111 (enum_payload nicer with returns Dynamic)
:END:

*** Description
Remove switch as an internal construct. In desugarer phase, desugar switch/case to
if/else chains with hoisted payload bindings (like ccodegen already does).

*** Benefits
After desugaring switch to if/else in desugarer, these phases can be simplified:
- ~interpreter.rs~ (24 switch refs) - remove switch handling entirely
- ~ccodegen.rs~ (57 switch refs) - remove switch handling and payload hoisting
- ~precomp.rs~ (12 switch refs) - remove switch handling
- ~scavenger.rs~ (1 switch ref) - remove switch handling
- ~typer.rs~ (45 switch refs) - KEEP for validation before desugaring

Result: one construct post-desugarer (if/else), payload hoisting in single place

*** Example
Before precomp:
#+BEGIN_SRC til
switch my_enum {
    case Foo(x) { use(x) }
    case Bar(y) { use(y) }
    default { fallback() }
}
#+END_SRC

After precomp:
#+BEGIN_SRC til
if enum_to_str(my_enum).eq("MyEnum.Foo") {
    x := /* hoisted payload extraction */
    use(x)
} else if enum_to_str(my_enum).eq("MyEnum.Bar") {
    y := /* hoisted payload extraction */
    use(y)
} else {
    fallback()
}
#+END_SRC

*** Required ext_func
Need to add for payload extraction (like Vec.new takes Type):
#+BEGIN_SRC til
// With inout (works now):
enum_payload := ext_func(e: Dynamic, payload_type: Type, mut p: Dynamic) {}

// With returns Dynamic (nicer, needs Issue #111):
enum_payload := ext_func(e: Dynamic, payload_type: Type) returns Dynamic {}
#+END_SRC

*** Notes
- Gleam went the opposite direction (if/else to switch)
- We prefer switch->if/else since payload hoisting is already in ccodegen
- Move that logic to desugarer (runs after typer, before precomp/interpreter/ccodegen)
- Bug #136 (switch on structs compared instance names, not values) was fixed independently
  by adding eq() calls directly in interpreter switch handling. This issue is now purely
  about code simplification, not correctness.

*** Prerequisite [DONE]
Merged commit ~08865594~ (enum_get_payload branch) providing:
- ~enum_get_payload(e: Dynamic, payload_type: Type, mut out: Dynamic)~ ext_func
- ~test_color_match_if~ in enums.til - working reference implementation

*** enum_get_payload fix for nested enums [DONE]
The original ~enum_get_payload~ implementation only worked for primitives (Bool, I64, Str)
and structs. For nested enum payloads (e.g., ~Result.Ok(Option.None)~), it failed because:
- The check ~payload_bytes.len() >= type_size~ used max enum size
- But actual payload bytes only contain the specific variant's data
- For ~Option.None~, payload is just 8 bytes (tag), not max size (tag + Some payload)

Fix: For enum payload types, copy all available bytes (must have >= 8 for tag) instead
of comparing against max type size.

Also added RGB struct (with U8 r,g,b fields) test case to verify struct payloads work.

*** Switch desugaring implementation [IN PROGRESS]
Branch: ~wip110final~

**** Rust desugarer changes [DONE]
The Rust desugarer (~src/rs/desugarer.rs~) correctly implements switch-to-if/else:
- ~desugar_switch~: Entry point, handles enum vs non-enum cases
- ~build_non_enum_if_chain~: Builds if/else chain for non-enum switches
- ~build_non_enum_case_condition_and_body~: Handles Range, Pattern, default cases
- ~build_enum_if_chain~: Builds if/else chain for enum switches with payload extraction
- Range cases: ~gteq(x, start).and(lteq(x, end))~
- Enum cases: ~enum_to_str(x).eq("Type.Variant")~ with ~enum_get_payload~ for payloads

**** TIL desugarer port [UNBLOCKED - Bug #143 FIXED]
Bug #143 was fixed with single-pass hoist+emit approach that removed ~hoisted_exprs~
entirely. The line/col collision issue no longer exists since there's no identity
tracking map anymore.

The wip110final branch has a TIL port (commit d152a823) but it was made before
the Bug #143 fix. After rebasing onto master, the port may need adjustments to
match the new ccodegen architecture.

**** Tests (needs re-verification after rebase)
Before Bug #143 fix:
- 92/94 tests passed with Rust compiler
- 2/94 failed with TIL compiler (til_compiled mode) - segfaults

After rebase onto master (which has Bug #143 fix), these should pass.

*** Current State (2026-01-30)

- Bug #143 FIXED on master - single-pass hoist+emit removed hoisted_exprs entirely
- Branch wip110final has Rust desugarer done + switch removal from all phases
- Branch needs rebase onto master (59 commits behind)
- TIL port on branch was made before Bug #143 fix, may need adjustments
- After rebase: test each commit with ~make clean && make benchmark~ (twice)

On master currently:
- Desugarer phase handles ForIn only, NO switch desugaring yet
- Switch still handled by: ufcs, precomp, interpreter, ccodegen
- enum_to_str and enum_get_payload ext_funcs ready to use

*** Implementation Plan

Incremental approach: Rust first, test, TIL port, test. One file per commit.

Pipeline reminder: Typer -> Desugarer -> UFCS -> Precomp -> ...
The desugared ~val.eq(other)~ calls will be handled by UFCS (transforms to ~Type.eq(val, other)~).

**** Step 1: Add switch desugaring to desugarer (2 commits)

Reference: ccodegen's ~emit_switch()~ (lines ~6309-6400) already does this work.

***** Commit 1a: Rust desugarer
- ~src/rs/desugarer.rs~ - add ~desugar_switch()~, handle Switch case in ~desugar_expr()~
- Use ~context.precomp_forin_counter~ for unique temp var names
- For enum switches: use ~enum_to_str()~ + ~Str.eq()~
- For non-enum switches: use direct ~val.eq(case_val)~
- For range cases: use ~val.gteq(lo) && val.lteq(hi)~
- For payload patterns: generate ~enum_get_payload()~ with default-initialized bindings
- Run ~make benchmark~ - must pass

***** Commit 1b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/desugarer.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 2: Remove switch handling from ufcs (2 commits)

***** Commit 2a: Rust ufcs
- ~src/rs/ufcs.rs~ - remove ~ufcs_switch()~ (lines 248-326), add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 2b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/ufcs.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 3: Remove switch handling from precomp (2 commits)

***** Commit 3a: Rust precomp
- ~src/rs/precomp.rs~ - remove ~precomp_switch()~ (lines 233-311), add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 3b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/precomp.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 4: Remove switch handling from interpreter (2 commits)

***** Commit 4a: Rust interpreter
- ~src/rs/interpreter.rs~ - remove switch evaluation (lines 462-~600), add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 4b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/interpreter.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 5: Remove switch handling from ccodegen (2 commits)

***** Commit 5a: Rust ccodegen
- ~src/rs/ccodegen.rs~ - remove ~emit_switch()~ (lines 6309-6400), add panic for Switch node
- Run ~make benchmark~ - must pass

***** Commit 5b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/ccodegen.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

**** Step 6: Add typer validation for switch methods (2 commits)

This prevents confusing runtime errors after desugaring. Without this, a struct
without ~eq~ method used in switch will fail with generic "Type X has no method eq"
instead of helpful "switch case: type X does not have an eq() method".

***** Commit 6a: Rust typer
- ~src/rs/typer.rs~ - in ~check_switch_statement()~ (line ~1763)
- Copy pattern from forin validation (lines 444-485)
- For non-enum simple cases: check ~TypeName.eq(self, other: TypeName) returns Bool~
- For range cases: check ~TypeName.gteq~ and ~TypeName.lteq~
- Skip validation for enum types (they use enum_to_str + Str.eq)
- Run ~make benchmark~ - must pass

***** Commit 6b: TIL port
- Read ~doc/rs2til.org~ and the Rust diff before porting
- ~src/self/typer.til~ - port same changes following rs2til.org rules strictly
- Run ~make benchmark~ - must pass

*** Desugaring Details

**** Files to modify in Step 1
- ~src/rs/desugarer.rs~ - add desugar_switch, handle Switch case
- ~src/self/desugarer.til~ - port same changes (follow ~doc/rs2til.org~ translation rules)

***** Desugaring pattern (from test_color_match_if)
Input:
#+BEGIN_SRC til
switch to_switch {
case Color.Unknown: return "unknown color"
case Color.Green(is_olive):
    if is_olive { return "olive green" }
    return "dark green"
case Color.Number(code):
    if code.gt(0) { return "positive" }
    return "negative"
case:
    return "default"
}
#+END_SRC

Output:
#+BEGIN_SRC til
{
    _switch_variant_funcname_N := enum_to_str(to_switch)
    if Str.eq(_switch_variant_funcname_N, "Color.Unknown") {
        return "unknown color"
    } else if Str.eq(_switch_variant_funcname_N, "Color.Green") {
        mut is_olive := false
        enum_get_payload(to_switch, Bool, is_olive)
        if is_olive { return "olive green" }
        return "dark green"
    } else if Str.eq(_switch_variant_funcname_N, "Color.Number") {
        mut code := 0
        enum_get_payload(to_switch, I64, code)
        if code.gt(0) { return "positive" }
        return "negative"
    } else {
        return "default"
    }
}
#+END_SRC

***** Non-enum switch example (Str)
Input:
#+BEGIN_SRC til
switch name {
case "alice": return "found alice"
case "bob": return "found bob"
case: return "unknown"
}
#+END_SRC

Output:
#+BEGIN_SRC til
if name.eq("alice") {
    return "found alice"
} else if name.eq("bob") {
    return "found bob"
} else {
    return "unknown"
}
#+END_SRC

***** Non-enum switch with range example (I64)
Input:
#+BEGIN_SRC til
switch score {
case 90..100: return "A"
case 80..89: return "B"
case 0..79: return "C"
case: return "invalid"
}
#+END_SRC

Output:
#+BEGIN_SRC til
if score.gteq(90) && score.lteq(100) {
    return "A"
} else if score.gteq(80) && score.lteq(89) {
    return "B"
} else if score.gteq(0) && score.lteq(79) {
    return "C"
} else {
    return "invalid"
}
#+END_SRC

***** Switch AST structure
- ~params[0]~ = switch expression
- ~params[1..n]~ = pairs of (case_expr, body_expr)
- Trailing odd element = default case body

***** Switch types: Enum vs Non-enum
The desugaring differs based on switch expression type:

****** Enum switch
- Uses ~enum_to_str(val)~ to get tag as string (e.g., "Color.Green")
- Compares with ~Str.eq(variant_str, "EnumName.Variant")~
- For payload patterns, uses ~enum_get_payload(val, Type, binding_var)~

****** Non-enum switch (Str, I64, U8, custom structs)
- Uses direct method calls on the value: ~val.eq(case_val)~
- No enum_to_str wrapper needed
- Typer validates that ~eq~ method exists for the type

***** Case expression types
- ~NodeType::Pattern(PatternInfo { variant_name, binding_var })~ - e.g., Color.Green(is_olive) [enum only]
- ~NodeType::Identifier(...)~ - e.g., Color.Unknown (enum variant) or literal value
- ~NodeType::Range~ - e.g., 1..10
- ~NodeType::DefaultCase~ - the ~case:~ default

***** Range case desugaring
Range cases use ~gteq~ and ~lteq~ methods:
#+BEGIN_SRC til
// Input:
switch val {
case 1..10: handle_range()
}

// Output:
if val.gteq(1) && val.lteq(10) {
    handle_range()
}
#+END_SRC

***** Method requirements (typer validates)
The desugaring relies on these methods existing for the switch expression type:
- Simple case: ~eq(other: T) returns Bool~
- Range case: ~gteq(other: T) returns Bool~ and ~lteq(other: T) returns Bool~

If a struct is used in switch without implementing required methods, typer emits
an error (same as forin loops requiring ~get~ method on iterables).

No hardcoding of I64/Str/U8 - just call the methods and let typer validate.

*** Failed Attempts

**** Branch: again110 (2026-01-23)

Branch preserved for reference: ~git checkout again110~

***** What was attempted
Implemented ~desugar_switch()~ in ~src/rs/desugarer.rs~ with:
- Enum switches: generate ~enum_to_str()~ + ~Str.eq()~ comparisons
- Non-enum switches: generate ~val.eq(case_val)~ calls
- Range cases: generate ~val.gteq(lo)~ and ~val.lteq(hi)~ with ~and()~
- Payload patterns: generate ~enum_get_payload()~ calls with default-initialized bindings
- Nested enum patterns like ~case ValueType.TType(TTypeDef.TStructDef)~: detect and generate nested if checks

***** Bug #137 was fixed during this attempt
During this attempt, discovered and fixed Bug #137: ~enum_get_payload~ field offset was
incorrectly calculated for struct enum payloads. The fix (calculating byte offset from
struct field definitions) was merged to master separately.

***** Symptom of failure
Rust version (~rstil interpret~) works correctly on test files. But when building
~rstil_til~ (self-hosted TIL compiler), the resulting binary fails with:
#+BEGIN_SRC
src/core/bool.til:src/core/bool.til:63:10: init ERROR: Undefined symbol 'Bool'
#+END_SRC

Note the doubled path in the error - suggests AST corruption somewhere.

***** Hypotheses tested and refuted

1. **Nested enum patterns not detected**: Added debug output to ~get_fcall_nested_enum_pattern~.
   All nested patterns (TTypeDef.TStructDef, TTypeDef.TEnumDef, FunctionType.*) were
   successfully detected and returned ~Some(...)~. Hypothesis refuted.

2. **Block passed to and() function**: Earlier version tried to generate ~and(outer_cond, { body })~
   which is invalid TIL (can't pass blocks as function arguments). Fixed to use nested ifs instead.
   But error persisted after fix.

***** What remains unknown
- Why the doubled path ~src/core/bool.til:src/core/bool.til:63:10~ appears in errors
- Why ~rstil_til~ fails on basic symbol lookup for Bool/I64 structs
- The actual root cause of AST corruption (if that's what it is)

***** Key insight from user
"I would copy and paste emit_switch into desugarer and rename it desugar_switch, first of all,
then let the compiler lead me to all the stuff that's wrong."

Instead of reimplementing from scratch, should literally copy working ccodegen emit_switch
code and adapt it minimally. Let the compiler guide the changes.

***** Files modified (not merged)
- ~src/rs/desugarer.rs~ - added ~desugar_switch()~ and supporting functions (~1200 lines added)
- TIL port was never done (blocked by Rust version not working with self-hosted compiler)

****** TODO: Typer validation (like forin)
The forin loop validates ~len~ and ~get~ methods in typer.rs (lines 415-458) with
clear error messages showing required signatures:
#+BEGIN_SRC
for-in loop: type 'Things' does not have a 'get()' method.
Required: Things.get(self, index: I64, mut item: Dynamic) throws IndexOutOfBoundsError
#+END_SRC

Switch desugaring should add similar validation in typer for context-specific errors:
#+BEGIN_SRC
switch case: type 'Point' does not have an 'eq()' method.
Required: Point.eq(self, other: Point) returns Bool

switch range case: type 'Point' does not have a 'gteq()' method.
Required: Point.gteq(self, other: Point) returns Bool
#+END_SRC

Without explicit typer validation, the desugared code will fail with generic
errors like ~Type 'Point' has no method 'eq'~ which lacks switch context.

******* Current behavior (no validation)
Tested: struct without eq/gteq/lteq used in switch currently WORKS because
the interpreter uses string comparison, not method calls:
#+BEGIN_SRC til
Point := struct { mut x: I64 = 0  mut y: I64 = 0 }

// Simple case - works now (string compare), will fail after desugaring
switch p1 { case Point(x=5, y=10): ... }

// Range case - works now (lexicographic), will fail after desugaring
switch p1 { case Point(x=0, y=0)..Point(x=10, y=20): ... }
#+END_SRC

******* Implementation steps
1. Add validation in typer.rs for Switch nodes (copy pattern from forin at lines 415-458)
2. For non-enum simple cases: check ~TypeName.eq(self, other: TypeName) returns Bool~
3. For range cases: check ~TypeName.gteq~ and ~TypeName.lteq~ with same pattern
4. Create ~src/test/sugar.til~ with expected failures (forin + switch method checks)
5. Add to ~all_common~ in tests.til with ~expected_status=1~

****** Tested behaviors
- Struct without ~eq~ method calling ~p1.eq(p2)~: ~Type 'Point' has no method 'eq'~ (generic error)
- Struct without ~gteq~ method calling ~p1.gteq(p2)~: ~Type 'Point' has no method 'gteq'~ (generic error)
- Struct with ~eq~ method: works correctly (~p1.eq(p2)~ returns Bool)
- forin on struct without ~len~/~get~: clear context-specific error with required signature
- switch on struct without ~eq~: currently works (string compare) - will break after desugaring

***** Key implementation details
1. Reuse ~context.precomp_forin_counter~ for unique temp var names
2. Use prefix form ~Str.eq(a, b)~ - precomp_expr handles UFCS
3. Use ~build_default_value()~ for payload defaults (Bool/I64/Str/enums)
4. Flatten Body nodes when adding original body statements
5. Build if chain from end to beginning (reverse iteration)

***** desugarer.rs implementation

Add ~desugar_switch~ function with helpers:
- ~build_switch_if_chain~ - collect cases, build if chain
- ~build_case_condition~ - build condition based on case type:
  - Simple case: ~val.eq(case_val)~
  - Range case: ~val.gteq(start) && val.lteq(end)~
  - Enum variant: ~enum_to_str(val).eq("Type.Variant")~
- ~build_payload_extraction_body~ - for enum patterns: {mut var := default; enum_get_payload(...); ...body...}
- ~build_if_chain_from_cases~ - build If nodes from end to beginning

Reference implementation: ccodegen.rs ~emit_switch()~ lines ~6309-6400

***** desugarer.til implementation
Add equivalent functions using TIL idioms (~Vec.new(Expr)~, ~Expr.new_explicit~).
IMPORTANT: Follow ~doc/rs2til.org~ translation rules when porting.

**** Commit 2: Replace eval_Switch/emit_switch with panics

After desugaring works, Switch nodes never reach interpreter/ccodegen.

***** Files to modify
- ~src/rs/interpreter.rs~ - replace NodeType::Switch arm with panic
- ~src/rs/ccodegen.rs~ - replace NodeType::Switch arm with panic
- ~src/self/interpreter.til~ - replace with panic
- ~src/self/ccodegen.til~ - replace with panic

**** Verification
#+BEGIN_SRC bash
make benchmark
#+END_SRC

All tests should pass. ~src/test/enums.til~ tests both:
- ~test_color_match~ (switch - now desugared)
- ~test_color_match_if~ (manual if/else - reference)

Both should produce identical behavior.

* Implemented Issues

(None yet - move issues here when implemented)
