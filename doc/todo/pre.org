#+TITLE: Pre-Self-Hosting TODO List
#+AUTHOR: rstil Development
#+DATE: 2025-11-12

* Overview

This document tracks TODOs in the Rust implementation (rstil) that must be completed before the self-hosted til interpreter can run successfully.

Current Status: Core language features complete. Error handling standardized. One remaining API cleanup task.

Scope: This focuses on rstil (Rust) implementation issues, NOT on completing the til-based interpreter/typer/etc.

* TODO Active Items

- [ ] Implement pass-by-reference semantics with three argument modes
  - [X] Phase 1: Type checker immutability enforcement (COMPLETE)
    - Prevents assignment to immutable parameters (typer.rs:930, 937)
    - Prevents field modification of immutable parameters (check_assignment extracts root variable)
    - Prevents passing immutable to mut parameter (typer.rs:322-344)
    - Tests in src/test/tmp/test_immutability*.til verify all cases
  - [X] Phase 2: Add 'copy' keyword for explicit copy semantics (COMPLETE)
    - Added 'copy' token to lexer (lexer.rs:25, 208, 262)
    - Added is_copy field to Declaration and SymbolInfo (parser.rs:19, init.rs:22)
    - Parser validates 'copy' and 'mut' are mutually exclusive (parser.rs:536-546)
    - Type checker allows modification of copy parameters (typer.rs:930, 937)
    - Interpreter allows assignment to copy parameters (interpreter.rs:946, 953)
    - Comprehensive tests in src/test/args.til (lines 344-467)
    - All existing tests pass
  - [X] Phase 3: Implement pass-by-reference for ALL struct types (COMPLETE)
    - Status: COMPLETE - pass-by-reference now works for ALL struct types
    - Implementation: Non-copy, non-own, non-Dynamic, non-Type parameters share arena offsets (zero-copy)
    - Key insight: Field offset refactoring (commit 2b9d08d) enables simple offset sharing
      - Only base offset stored in arena_index
      - Field offsets calculated dynamically from struct definitions
      - Inline memory layout means sharing base offset shares all fields
    - Implementation details (interpreter.rs:1671-1722):
      - Share base offset between caller and callee
      - Copy nested field offsets (e.g., "l.start.x") to callee's arena_index
      - Register field symbols for UFCS method resolution
      - Track pass-by-ref params to skip map_instance_fields on return
    - Test coverage: All core tests pass (args.til, structs.til, nested struct mutations)
    - Performance: ~42s runtime unchanged (copying small structs is already fast)
  - [X] Phase 3a: Separate Type from Dynamic (COMPLETE - prerequisite for Bug #26 fix)
    - Added Type := struct {} in core.til (line 7) for type name parameters
    - Updated type name parameters to use Type instead of Dynamic:
      - Ptr.new(T: Type), Array.new(T: Type), Vec.new(T: Type)
      - Map.new(KeyType: Type, ValueType: Type)
      - List.push/set(T: Type, value: Dynamic)
      - size_of(type: Type), type_as_str(type: Type)
    - Dynamic now only used for actual value parameters (e.g., Vec.get(mut T: Dynamic))
    - Rust side updated to handle Type like Dynamic (typer.rs, interpreter.rs)
    - Both Type and Dynamic excluded from pass-by-reference (for now)
    - All tests pass (exit code 0)
  - [X] Phase 3b: Enable pass-by-reference for Dynamic and own parameters (COMPLETE)
    - Status: COMPLETE - ALL non-copy, non-Type parameters now use pass-by-reference
    - Implementation: interpreter.rs:1680 - only copy and Type excluded from pass-by-ref
      - Dynamic parameters (including mut) use pass-by-ref
      - own parameters use pass-by-ref (transfer ownership of arena offset, not data)
      - mut parameters use pass-by-ref (write directly to caller's memory via to_ptr)
    - Benefits: Reduced copying, cleaner semantics for ownership transfer
    - All core tests pass (exit code 0)
  - [X] Bug #26: Vec/Map corruption with nested structs (FIXED)
    - Root cause: insert_struct allocated nested structs separately instead of inline
      - When creating Outer with field inner: Inner, Inner was allocated at separate offset
      - Vec.push/get used memcpy which copied parent struct bytes, not nested struct data
      - Result: nested fields corrupted to zero after Vec.push/get round-trip
    - Fix 1: Modified insert_struct_at_offset to use existing offset for nested structs
      - Nested structs now allocated inline within parent struct's memory block
      - Field offsets calculated correctly relative to parent (init.rs:1510-1625)
    - Fix 2: Extended pass-by-reference to field access parameters
      - Previously only simple identifiers (e.g., x) used pass-by-ref
      - Now field access (e.g., o1.inner_vec) also uses pass-by-ref (interpreter.rs:1820-1872)
      - Register field symbols for UFCS method resolution (line 1869)
    - Fix 3: Zero-copy return value transfers
      - Return values already shared offsets (no copy in return handling)
      - mut declarations from temp return values now share offset instead of copy (interpreter.rs:970-985)
      - Only copy when source is a real variable (not temporary)
    - test_parser.til struct test re-enabled (line 423)
    - All tests pass (exit code 0)
  - [ ] Phase 4: Update core library to remove Bug #24 workarounds (READY)
    - Status: READY - Phase 3 now supports ALL struct types with pass-by-reference
    - Can now remove copy-modify-reassign patterns (e.g., tmp = x; tmp.field = val; x = tmp)
    - Bug #24 workarounds can be removed from:
      - List.push(), List.set(), List.pop() (src/core/core.til:1003-1009, etc.)
      - Other locations using the copy-modify-reassign pattern
    - Next step: Systematically find and remove all Bug #24 workarounds
  - Impact: Fixes Bug #24, cleaner semantics, better performance
  - See: doc/todo/plan_by_reference.org for detailed implementation plan

- [X] Standardize len/cap API across collections (COMPLETE - fixes Bug #25)
  - Renamed internal fields: len → _len, cap → cap (kept as-is for internal use)
  - Added uniform methods: len() returns element count, size() returns byte size
  - Implemented for: Vec, List, Array (lines 540-652, 957-1165, 488-545 in core.til)
  - Updated all core library files to use .len() method calls
  - Updated all test files to use .len() method calls
  - For-loop ranges: store len() result in local variable (e.g., `mut args_len := args.len()`)
  - Bug #25 FIXED: Method resolution now works correctly (e.g., `s.items.len().eq(0)`)
  - All tests pass (exit code 0)
  - Added len() and size() to Map (renamed Map.size field to Map._size to avoid conflict)
  - INCONSISTENCY: Field naming is inconsistent across types:
    - Vec, Array, List use: mut _len (with underscore prefix)
    - Map uses: mut _size (with underscore prefix, renamed from 'size')
    - Vec, Array use: mut cap (no underscore)
    - Bool, U8 use: mut data (no underscore)
    - Str uses: mut c_string, mut cap (no underscores)
  - TODO: Consider standardizing all internal fields to use _ prefix consistently
  - Reason for inconsistency: Incremental development, avoiding breaking changes

* Notes

Focus on rstil, Not til Implementation:
This tracks what the Rust interpreter (rstil) needs to support self-hosting.
Completing interpreter.til, typer.til, etc. is the GOAL of self-hosting, not prerequisites.

Workarounds Are Okay Temporarily:
Some workarounds are acceptable short-term. Priority is getting rstil stable enough to run the self-hosted code.
