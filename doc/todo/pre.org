#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #161: Namespace constants, static mutables, and per-instance immutables
:PROPERTIES:
:DISCOVERED: 2026-02-04
:IMPACT: Unified syntax for type-level and instance-level data
:STATUS: Open - detailed plan ready
:RELATED: Issue #108 (namespace blocks - implemented)
:END:

*** Overview

Follow-up to Issue #108 (namespace blocks for associated functions). This issue
extends namespaces to support constants and mutable state, and adds per-instance
immutable fields to structs.

After this issue, four kinds of declarations exist:

| Location  | Syntax             | Meaning                          |
|-----------+--------------------+----------------------------------|
| namespace | ~Max := 100~       | Associated constant (static)     |
| namespace | ~mut counter := 0~ | Associated mutable (static)      |
| struct    | ~id := 0~          | Per-instance immutable (frozen)  |
| struct    | ~mut name := ""~   | Per-instance mutable             |

*** Step 1: Associated constants in namespace blocks

Move type-level constants from standalone globals into type namespaces.

**** Current state
Constants are standalone globals with naming conventions:
#+BEGIN_SRC til
MAX_I64 := 9223372036854775807
MIN_I64 := -9223372036854775808
I64_SIZE := 8
#+END_SRC

**** Target state
Constants live in type namespaces:
#+BEGIN_SRC til
namespace I64 {
    Max := 9223372036854775807
    Min := -9223372036854775808
    Size := 8
}
// Usage: I64.Max instead of MAX_I64
#+END_SRC

**** Implementation

***** Step 1.1: Verify namespace blocks support constants
Namespace blocks already support function definitions. Verify they also support
constant declarations (non-mut, non-function). This likely already works since
init.rs merges all namespace members into the type.

Test with:
#+BEGIN_SRC til
namespace I64 {
    TestConst := 42
}
assert_eq(loc(), 42, I64.TestConst)
#+END_SRC

Files to check: init.rs:1311-1400, init.til (NamespaceDef handling)

***** Step 1.2: Audit existing constants
Find all type-related constants in the codebase:
- I64: MAX_I64, MIN_I64, I64_SIZE
- U8: (check if any exist)
- Str: (check if any exist)
- Other types in src/core/

***** Step 1.3: Migrate constants to namespaces
For each type, move constants into namespace blocks:
#+BEGIN_SRC til
// Before (in i64.til)
MAX_I64 := 9223372036854775807

// After (in i64.til)
namespace I64 {
    Max := 9223372036854775807
}
#+END_SRC

***** Step 1.4: Update all usages
Find and replace all old constant names:
- ~MAX_I64~ -> ~I64.Max~
- ~MIN_I64~ -> ~I64.Min~
- etc.

***** Step 1.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 2: Associated mutable state in namespace blocks

Allow ~mut~ declarations in namespace blocks - these work like static variables.

**** Use case
#+BEGIN_SRC til
Soldier := struct {
    mut id := 0
    mut name := "unknown"
}

namespace Soldier {
    mut counter := 0  // Static counter shared by all instances

    new := func(name: Str = "unknown") returns Soldier {
        s := Soldier(id=counter, name=name)
        counter = counter + 1
        return s
    }
}

// Usage:
s1 := Soldier.new("Alice")  // id=0
s2 := Soldier.new("Bob")    // id=1
#+END_SRC

**** Implementation

***** Step 2.1: Parser - allow mut in namespace blocks
Check if parser already accepts ~mut~ declarations in namespace blocks.
If not, update parse_namespace_definition to accept them.

Files: parser.rs, parser.til

***** Step 2.2: Init - register namespace mutables
When init processes NamespaceDef, it currently registers functions.
Extend to also register mutable variables with their initial values.

The mutable needs to be:
- Registered as a symbol with is_mut=true
- Stored in the global scope (not per-instance)

Files: init.rs, init.til

***** Step 2.3: Interpreter - handle namespace mutable access
When evaluating ~TypeName.mutable_var~, look up and return/assign the value.
This is similar to how ~TypeName.constant~ works, but allows mutation.

Files: interpreter.rs, interpreter.til

***** Step 2.4: Ccodegen - emit namespace mutable as static
In C, namespace mutables become static variables:
#+BEGIN_SRC c
// For: namespace Soldier { mut counter := 0 }
static long long til_Soldier_counter = 0;
#+END_SRC

Files: ccodegen.rs, ccodegen.til, scavenger.rs, scavenger.til

***** Step 2.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 3: Per-instance immutable fields in structs

Allow non-mut fields in structs that are set at construction and frozen afterward.

**** Use case
#+BEGIN_SRC til
Entry := struct {
    id := 0              // Immutable after construction
    mut name := ""       // Mutable
    mut desc := ""       // Mutable
}

mut e := Entry(id=get_unique_id(), name="test", desc="description")
e.name = "new name"  // OK - name is mut
e.id = 999           // ERROR - id is not mut, frozen after construction
#+END_SRC

**** Current state
Non-mut fields in structs are currently used for associated constants/functions:
#+BEGIN_SRC til
MyStruct := struct {
    static_const := 42       // Associated constant (no mut)
    mut instance_data := 0   // Instance field (mut)
}
#+END_SRC

After Issue #108, functions are in namespace blocks. But constants in struct
still work as associated constants (e.g., Cell.CHAR_WIDTH in hello_gui.til).

**** Design decision
With namespace blocks, associated constants should move to namespaces (Step 1).
This frees up non-mut struct fields for a new meaning: per-instance immutables.

Migration path:
1. Step 1 moves associated constants to namespaces
2. Step 3 repurposes non-mut fields for instance immutables
3. Deprecation warning for old pattern during transition

**** Implementation

***** Step 3.1: Migrate existing struct constants to namespaces
Before changing semantics, move all existing struct constants to namespace blocks.
Example from hello_gui.til:
#+BEGIN_SRC til
// Before
Cell := struct {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}

// After
Cell := struct {}
namespace Cell {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}
#+END_SRC

***** Step 3.2: Typer - track field mutability
The typer needs to know which struct fields are mutable vs immutable.
Add check: if assigning to a non-mut field after construction, emit error.

Challenge: distinguishing construction from assignment.
- Construction: ~Entry(id=42)~ - allowed to set immutable fields
- Assignment: ~e.id = 42~ - not allowed for immutable fields

Files: typer.rs, typer.til

***** Step 3.3: Interpreter - enforce field immutability
After struct construction, track which fields are frozen.
Reject mutations to immutable fields.

Approach: In eval_set, before modifying a struct field, check if field is mut.
If not mut and struct already exists, error.

Files: interpreter.rs, interpreter.til

***** Step 3.4: Ccodegen - enforce field immutability (optional)
Could add runtime checks in generated C, or rely on typer catching it.
Typer-only enforcement is simpler and sufficient.

***** Step 3.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Testing

**** Step 1 tests
#+BEGIN_SRC til
// Test namespace constants
namespace I64 {
    TestMax := 9223372036854775807
}
assert_eq(loc(), 9223372036854775807, I64.TestMax)
#+END_SRC

**** Step 2 tests
#+BEGIN_SRC til
// Test namespace mutable (static)
Counter := struct {}
namespace Counter {
    mut value := 0
    increment := func() returns I64 {
        value = value + 1
        return value
    }
}
assert_eq(loc(), 1, Counter.increment())
assert_eq(loc(), 2, Counter.increment())
assert_eq(loc(), 2, Counter.value)
#+END_SRC

**** Step 3 tests
#+BEGIN_SRC til
// Test per-instance immutable
ImmutableTest := struct {
    id := 0        // Immutable
    mut name := "" // Mutable
}

mut t := ImmutableTest(id=42, name="test")
assert_eq(loc(), 42, t.id)
t.name = "changed"  // OK
// t.id = 99       // Should error: cannot assign to immutable field
#+END_SRC

*** Verification
1. Run ~make benchmark~ after each step - all tests must pass
2. Port each .rs change to .til immediately
3. Test both interpreter and compiler modes

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open - Steps 1-9 done, Step 10A done, Step 10B done (98/98 pass)
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation), Bug #144 (for-in by-ref), Bug #168 (ccodegen return copies)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Garbager clone prerequisites (DONE)

**[X] Add Str to garbager clone set** - e4788b62
Remove "Str" from primitives exclusion in garbager clone logic.

**[X] Eliminate Str double-copy via arena_offset** - 31a10477
EvalResult carries arena_offset (0 = None) through eval/return/call chains.

**** Step 5: Typer own-consumption analysis (DONE - Bug #162)

Control-flow-aware tracking of variables consumed by ~own~ params.
(Dependency: needed before Step 7 container own params can work.)

File: typer.rs, typer.til:
- Mut check: only ~mut~ params require mut variables, NOT ~own~ params
- Lazy removal tracking via ~RemovedSymbol~ struct + ScopeStack methods:
  ~begin_removal_tracking~, ~end_removal_tracking~, ~removal_mark~,
  ~drain_removals_since~, ~restore_removed~ (replaces full map snapshot/restore,
  cost proportional to actual removals instead of total symbol count)
- ~check_if_statement~: begin tracking, mark/drain/restore per branch.
  After all branches, remove symbols consumed in ALL branches (intersection).
  If-without-else: no definite consumption.
- ~check_switch_statement~: begin tracking, mark/drain/restore per case body
- ~check_func_proc_types~: snapshot before body type-check, restore before
  ~check_body_returns_throws~ (needs UFCS resolution, which needs all symbols)

File: init.rs, init.til:
- Added ~RemovedSymbol~ struct, tracking fields (~removed_log~, ~removal_tracking_depth~)
- Modified ~remove_symbol~ to log when tracking is active
- Added ~Vec.split_off~ to core/vec.til (used by ~drain_removals_since~)

**** Step 6: Ccodegen - remove ~const~ for struct/enum locals (DONE - Bug #162)

Garbager inserts ~Type.delete()~ calls on local variables. C ~const~ prevents
calling ~delete()~ (takes ~mut self~). Remove ~const~ for struct/enum locals.

File: ccodegen.rs, ccodegen.til (7 locations):
1. ~emit_precomputed_vec_assignment~: remove ~is_mut~ param, remove const logic
2. Struct empty init: remove ~if !is_mut { "const " }~
3. Struct zero init: same
4. Struct designated init: same
5. Struct fallback: same
6. Enum declaration: same
7. General const declaration: skip ~const~ for non-primitive TCustom types:
   ~matches!(&decl.value_type, ValueType::TCustom(s) if s != "I64" && ...)~

**** Step 7: Container ~own~ params + clone fixes (DONE)

(Depends on Step 5: typer must accept const vars for ~own~ params.)

~push~, ~set~, ~insert~, ~insert_at~ take ~own value: Dynamic~.
The type checker removes the variable from scope after consumption,
forcing call sites to use ~.clone()~ when they need the value afterwards.

Container files: vec.til, array.til, set.til, list.til, map.til, hashmap.til
- Vec: push, set, insert_at, extend_with (inlined - can't call push with own)
- Array: set
- Set: insert
- List: push, set (both cases: same-size and different-size)
- Map: insert, set
- HashMap: insert, set (compute bucket BEFORE push moves key)

Clone fixes (~own~ params consume variables, call sites need ~.clone()~):
- builder.til: ~insert(core_path.clone())~ x3
- eval_arena.til: ~push(frame.clone())~ x2, ~set(temp_id.clone(), ...)~ x2
- ccodegen.til: ~set(name, idx.clone())~, ~push(pop_idx.clone())~,
  ~set(next, next_degree.clone())~
- interpreter.til: ~set(struct_type, template_offset.clone())~,
  ~set(var_name.clone(), offset)~
- parser.til: ~push(result.clone())~ x2
- init.til: ~name.clone()~ inline (Bug #162 UFCS fix enabled this)
- tests.til: ~push(time_ms.clone())~
- hashmap.til: ~set(bucket_idx, i.clone())~ in resize/remove
- Test/example files: bug57.til, vecs.til, lists.til, maps.til,
  cross_file_forward.til, music.til - loop vars consumed by push/insert

***** Zeroing deferred — replaced by ~dont_delete~ in Step 9
Zeroing (~memset(to_ptr(value), zero, size)~ after copy) was attempted
but removed. TIL's shared-offset reference chain causes zeroing to
cascade: e.g. ~declare_struct(name: Str)~ calls ~Map.set(own key=name)~
which calls ~Vec.insert_at(own value=key)~. Zeroing ~value~ zeroes ~key~
zeroes ~name~ zeroes ~decl.name~ in the original caller. This broke the
entire self-hosted compiler (87/98 test failures).

Replaced by ~dont_delete(value)~ in Step 9: a garbager-phase directive
that tells the garbager to skip inserting ~Type.delete()~ for that
variable and removes the ~dont_delete~ call from the AST. Combined with
~own~ (caller's variable removed from scope), nobody deletes the value.
Heap data lives on in the container, freed when container is deleted.
Same memory behavior as zeroing but no cascading corruption.

***** Bug #162 UFCS + own params (FIXED)
Root cause: ~check_body_returns_throws~ re-walked the AST doing UFCS
resolution after the type-check pass removed own-consumed symbols.
Parameters were not re-declared (unlike locals). Fix: restore removed
symbols before ~check_body_returns_throws~ via removal tracking.
Workarounds in init.til removed.

**** Step 8: ~dont_delete~ directive (replaces zeroing) — DONE

Garbager-phase directive. When the garbager sees ~dont_delete(var)~ in
the AST: (1) add ~var~ to skip set, (2) don't insert ~Type.delete(var)~,
(3) remove the ~dont_delete~ call from AST. No runtime cost — purely
garbager-phase. Used inside container methods with ~own~ params:
#+begin_src til
push := proc(mut self: Vec, own value: Dynamic) {
    dont_delete(value)  // garbager strips this, skips delete for value
    // ... copy bytes into vec ...
}
#+end_src
Files: garbager.rs, garbager.til, mem.til + container files (vec, array, map, etc.)

Implementation: declared as ~ext_func~ in ~mem.til~ so the type checker
accepts it. Garbager strips the calls from FuncDef bodies. ~dont_delete~
placed at top of function body (before any ownership-consuming calls).

Container methods with ~dont_delete~: Vec.push, Vec.set, Vec.extend_with,
Vec.insert_at, Array.set, Set.insert, Map.insert, Map.set,
HashMap.insert, HashMap.set, List.push, List.set.

Prerequisite for Step 9 (Bug #144 fix) and Step 10 (auto-delete).

**** Step 9: Fix ~get~ shallow copy + ~get_by_ref~ + ~create_alias~ (Bug #144) — DONE

Current ~get(self, index, mut dest)~ does memcpy (shallow copy). The caller's
local aliases the container element's heap data. Auto-deleting the local
corrupts the container (double-free).

Agreed approach:
1. DONE — ~get_by_ref~ added to Vec, Map, HashMap. Returns borrowed Ptr
   (~offset~ sets ~is_borrowed=1~). Tests in vecs.til and maps.til.
2. DONE — ~create_alias~ standalone ext_func added. Rebinds a local variable's
   arena offset to a Ptr's data address (interpreter) or emits memcpy (compiler).
   Not a Ptr method (wrapper can't rebind caller's variable). Declared in mem.til,
   implemented in ext.rs/ext.til, inline codegen in ccodegen.rs/ccodegen.til.
   Test in pointers.til.
3. DONE — Fix Bug #144 — 3-arg compound directive ~create_alias(item, MyStruct, addr)~.
   Declares variable + aliases to address + skips auto-delete, all in one FCall.
   No wasteful default construction, no separate ~dont_delete~. Every phase with
   scope tracking recognizes it: init, typer, ufcs, precomp, ccodegen, interpreter.
   Desugared for-in for non-primitives is now:
#+begin_src til
_ref := get_by_ref(vec, _for_i_func_N)
catch (...) { panic(...) }
create_alias(item, MyStruct, _ref.data)   // declares + aliases + skips delete
// user's body
#+end_src
   Performance gain modest (~0.6%), see Bug #144 for details. But the real
   value is correctness: create_alias variables are properly excluded from
   auto-delete, which is what Step 10 needs. Without this, Step 10 would
   double-free for-in loop variables over containers.
4. Decide on ~get~ API — break it (make ~get~ return ref by default) or
   keep both ~get~ (copy) / ~get_by_ref~ (reference).

Dependencies: Step 8 (~dont_delete~), ~get_by_ref~, ~create_alias~ ext_func.
Files: desugarer.rs, desugarer.til, container files, ptr ext_funcs,
  ufcs.rs, ufcs.til, precomp.rs, precomp.til, init.rs, init.til,
  typer.rs, typer.til, ccodegen.rs, ccodegen.til, ext.rs, ext.til,
  garbager.rs, garbager.til, mem.til, pointers.til.

**** Step 10A: Auto-insert Type.delete() at function body end — DONE

Files: ~src/rs/garbager.rs~ and ~src/self/garbager.til~

Implementation complete. 98/98 tests pass. Two fixes needed after initial implementation:
- ~is_deletable_type~: check struct has mutable fields (not just is-a-struct).
  Empty structs (EmptyStruct, BadAlloc, DivideByZero) have no heap data.
- Catch guard: any catch block (not just non-final) means throws can skip
  declarations, making unconditional deletes at function end unsafe.

***** Edits (Rust)

****** 1. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC rust
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
fn is_deletable_type(type_name: &str, context: &Context) -> bool {
    let is_primitive = matches!(type_name, "I64" | "U8" | "Type" | "Dynamic" | "Ptr");
    !is_primitive && context.scope_stack.has_struct(type_name)
}
#+END_SRC

****** 2. Replace 4 inline is_primitive checks with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType::Declaration~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType::Assignment~ arm):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if !is_primitive && context.scope_stack.has_struct(type_name) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: let is_primitive = matches!(type_name.as_str(), "I64" | "U8" | "Type" | "Dynamic");
:      if is_primitive || !context.scope_stack.has_struct(type_name) {
:          continue;
:      }
: NEW: if !is_deletable_type(type_name, context) {
:          continue;
:      }

NOTE: Location D uses inverted logic (continue if NOT deletable).
NOTE: The new helper adds "Ptr" to the exclusion list. This is intentional
(per Step 10 design in pre.org Issue #117). Doesn't change existing behavior
since Ptr was never in has_struct().

****** 3. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC rust
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
fn build_delete_call_expr(type_name: &str, var_name: &str, line: usize, col: usize) -> Expr {
    let delete_ident = Expr::new_explicit(
        NodeType::Identifier("delete".to_string()), vec![], line, col);
    let type_delete_access = Expr::new_explicit(
        NodeType::Identifier(type_name.to_string()), vec![delete_ident], line, col);
    let var_expr = Expr::new_explicit(
        NodeType::Identifier(var_name.to_string()), vec![], line, col);
    Expr::new_explicit(NodeType::FCall(false), vec![type_delete_access, var_expr], line, col)
}
#+END_SRC

****** 4. Add ~get_create_alias_var~ helper (after ~get_dont_delete_var~)

#+BEGIN_SRC rust
/// Extract variable name from create_alias(var, type, addr) call.
fn get_create_alias_var(e: &Expr) -> Option<String> {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(name) = get_func_name(e) {
            if name == "create_alias" && e.params.len() >= 3 {
                if let NodeType::Identifier(var_name) = &e.params[1].node_type {
                    return Some(var_name.clone());
                }
            }
        }
    }
    None
}
#+END_SRC

****** 5. Add ~collect_own_transfers~ helpers (after ~get_create_alias_var~)

#+BEGIN_SRC rust
/// Scan statements for variables passed as `own` args to function calls.
fn collect_own_transfers(stmts: &[Expr], context: &Context) -> HashSet<String> {
    let mut result = HashSet::new();
    for stmt in stmts {
        collect_own_transfers_recursive(stmt, context, &mut result);
    }
    result
}

fn collect_own_transfers_recursive(e: &Expr, context: &Context, result: &mut HashSet<String>) {
    if let NodeType::FCall(_) = &e.node_type {
        if let Some(func_name) = get_func_name(e) {
            if !func_name.ends_with(".clone") && !func_name.ends_with(".delete") {
                if let Some(func_def) = context.scope_stack.lookup_func(&func_name) {
                    for (i, arg_def) in func_def.args.iter().enumerate() {
                        let param_idx = i + 1;
                        if param_idx < e.params.len() && arg_def.is_own {
                            if let NodeType::Identifier(var_name) = &e.params[param_idx].node_type {
                                if e.params[param_idx].params.is_empty() {
                                    result.insert(var_name.clone());
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    for param in &e.params {
        collect_own_transfers_recursive(param, context, result);
    }
    if let NodeType::FuncDef(func_def) = &e.node_type {
        for stmt in &func_def.body {
            collect_own_transfers_recursive(stmt, context, result);
        }
    }
}
#+END_SRC

****** 6. Replace FuncDef handler (the ~NodeType::FuncDef~ arm in ~garbager_recursive~)

Replace the entire ~NodeType::FuncDef(func_def) => { ... }~ arm:

#+BEGIN_SRC rust
        NodeType::FuncDef(func_def) => {
            // Step 1: Strip dont_delete calls, collect protected var names
            let mut new_body = Vec::new();
            let mut dont_delete_vars: HashSet<String> = HashSet::new();
            for stmt in &func_def.body {
                if is_dont_delete_call(stmt) {
                    if let Some(var_name) = get_dont_delete_var(stmt) {
                        dont_delete_vars.insert(var_name);
                    }
                    continue;
                }
                // Step 2: Collect create_alias var names
                if let Some(alias_var) = get_create_alias_var(stmt) {
                    dont_delete_vars.insert(alias_var);
                }
                new_body.push(garbager_recursive(context, stmt)?);
            }

            // Step 3: Collect delete candidates
            let mut candidates: Vec<(String, String)> = Vec::new();

            // 3a: copy/own params with deletable types
            for arg_def in &func_def.args {
                if arg_def.is_copy || arg_def.is_own {
                    if let ValueType::TCustom(type_name) = &arg_def.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((arg_def.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // 3b: Scan new_body for Declaration nodes with deletable types
            for stmt in &new_body {
                if let NodeType::Declaration(decl) = &stmt.node_type {
                    if let ValueType::TCustom(type_name) = &decl.value_type {
                        if is_deletable_type(type_name, context) {
                            candidates.push((decl.name.clone(), type_name.clone()));
                        }
                    }
                }
            }

            // Step 4: Remove dont_delete_vars and own-transferred vars
            let own_transfers = collect_own_transfers(&new_body, context);
            candidates.retain(|(var_name, _)| {
                !dont_delete_vars.contains(var_name) && !own_transfers.contains(var_name)
            });

            // Step 5: Append Type.delete(var) calls in reverse declaration order
            let last_line = new_body.last().map_or(e.line, |s| s.line);
            let last_col = new_body.last().map_or(e.col, |s| s.col);
            candidates.reverse();
            for (var_name, type_name) in &candidates {
                new_body.push(build_delete_call_expr(type_name, var_name, last_line, last_col));
            }

            let new_func_def = SFuncDef {
                function_type: func_def.function_type.clone(),
                args: func_def.args.clone(),
                return_types: func_def.return_types.clone(),
                throw_types: func_def.throw_types.clone(),
                body: new_body,
                source_path: func_def.source_path.clone(),
            };
            let mut new_params = Vec::new();
            for param in &e.params {
                new_params.push(garbager_recursive(context, param)?);
            }
            Ok(Expr::new_explicit(NodeType::FuncDef(new_func_def), new_params, e.line, e.col))
        }
#+END_SRC

***** Edits (TIL)

****** 7. Add ~is_deletable_type~ helper (after ~build_clone_call_expr~)

#+BEGIN_SRC til
/// Check if a type should have delete() calls inserted.
/// Excludes primitives: I64, U8, Type, Dynamic, Ptr. NOT Str (has heap data).
is_deletable_type := func(type_name: Str, context: Context) returns Bool {
    is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic")).or(type_name.eq("Ptr"))
    return not(is_primitive).and(context.scope_stack.has_struct(type_name))
}
#+END_SRC

****** 8. Replace 4 inline is_primitive checks in TIL with ~is_deletable_type~

*Location A* (in ~garbager_recursive~, ~NodeType.Declaration~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location B* (in ~garbager_recursive~, ~NodeType.Assignment~ case):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location C* (in ~transform_fcall_copy_params~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

*Location D* (in ~transform_struct_literal_fields~):
: OLD: is_primitive := type_name.eq("I64").or(type_name.eq("U8")).or(type_name.eq("Type")).or(type_name.eq("Dynamic"))
:      if not(is_primitive).and(context.scope_stack.has_struct(type_name)) {
: NEW: if is_deletable_type(type_name, context) {

****** 9. Add ~build_delete_call_expr~ helper (after ~is_deletable_type~)

#+BEGIN_SRC til
/// Build AST for Type.delete(var): FCall( Identifier("Type").Identifier("delete"), Identifier("var") )
build_delete_call_expr := func(type_name: Str, var_name: Str, line: I64, col: I64) returns Expr {
    delete_ident := Expr(node_type=NodeType.Identifier("delete"), line=line, col=col)
    mut type_delete_access := Expr(node_type=NodeType.Identifier(type_name), line=line, col=col)
    type_delete_access.params.push(delete_ident)
    var_expr := Expr(node_type=NodeType.Identifier(var_name), line=line, col=col)
    mut delete_call := Expr(node_type=NodeType.FCall(false), line=line, col=col)
    delete_call.params.push(type_delete_access)
    delete_call.params.push(var_expr)
    return delete_call
}
#+END_SRC

****** 10. Add ~get_dont_delete_var~ to TIL (after ~is_dont_delete_call~)

Currently missing from TIL. Rust version is ~get_dont_delete_var~ in garbager.rs.

#+BEGIN_SRC til
/// Extract variable name from dont_delete(var) call.
/// The variable is params[1] (params[0] is the function name).
get_dont_delete_var := func(e: Expr) returns Str {
    if e.params.len().lt(2) {
        return ""
    }
    mut param1 := Expr()
    e.params.get(1, param1)?
    catch (err: IndexOutOfBoundsError) {
        return ""
    }
    switch param1.node_type {
    case NodeType.Identifier(var_name):
        return var_name
    case:
        return ""
    }
}
#+END_SRC

****** 11. Add ~get_create_alias_var~ to TIL (after ~get_dont_delete_var~)

#+BEGIN_SRC til
/// Extract variable name from create_alias(var, type, addr) call.
get_create_alias_var := func(e: Expr) returns Str {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.eq("create_alias").and(e.params.len().gteq(3)) {
            mut param1 := Expr()
            e.params.get(1, param1)?
            catch (err: IndexOutOfBoundsError) {
                return ""
            }
            switch param1.node_type {
            case NodeType.Identifier(var_name):
                return var_name
            case:
            }
        }
    case:
    }
    return ""
}
#+END_SRC

****** 12. Add ~collect_own_transfers~ to TIL (after ~get_create_alias_var~)

Uses Vec<Str> instead of HashSet. Returns the Vec directly.

#+BEGIN_SRC til
/// Scan statements for variables passed as `own` args to function calls.
collect_own_transfers := proc(stmts: Vec, context: Context) returns Vec {
    mut result := Vec.new(Str)
    for stmt: Expr in stmts {
        collect_own_transfers_recursive(stmt, context, result)
    }
    return result
}

collect_own_transfers_recursive := proc(e: Expr, context: Context, mut result: Vec) {
    switch e.node_type {
    case NodeType.FCall(_):
        func_name := get_func_name(e)
        if func_name.len().gt(0).and(not(func_name.ends_with(".clone"))).and(not(func_name.ends_with(".delete"))) {
            mut func_def := SFuncDef()
            mut found := false
            func_def = context.scope_stack.lookup_func(func_name)?
            found = true
            catch (err: KeyNotFoundError) { }
            if found {
                for i in 0..func_def.args.len() {
                    mut arg_def := Declaration()
                    func_def.args.get(i, arg_def)?
                    catch (err: IndexOutOfBoundsError) { }
                    param_idx := i.add(1)
                    if param_idx.lt(e.params.len()).and(arg_def.is_own) {
                        mut param_expr := Expr()
                        e.params.get(param_idx, param_expr)?
                        catch (err: IndexOutOfBoundsError) { }
                        switch param_expr.node_type {
                        case NodeType.Identifier(var_name):
                            if param_expr.params.len().eq(0) {
                                result.push(var_name)
                            }
                        case:
                        }
                    }
                }
            }
        }
    case:
    }
    // Recurse into children
    for param: Expr in e.params {
        collect_own_transfers_recursive(param, context, result)
    }
    // Recurse into FuncDef body if present
    switch e.node_type {
    case NodeType.FuncDef(inner_func_def):
        for stmt: Expr in inner_func_def.body {
            collect_own_transfers_recursive(stmt, context, result)
        }
    case:
    }
}
#+END_SRC

****** 13. Replace FuncDef handler in TIL (the ~NodeType.FuncDef~ case in ~garbager_recursive~)

Replace from ~case NodeType.FuncDef(func_def):~ through ~return Expr.new_explicit(...)~:

#+BEGIN_SRC til
    case NodeType.FuncDef(func_def):
        // Step 1: Strip dont_delete calls, collect protected var names
        mut new_body := Vec.new(Expr)
        mut dont_delete_vars := Vec.new(Str)
        for stmt: Expr in func_def.body {
            if is_dont_delete_call(stmt) {
                dd_var := get_dont_delete_var(stmt)
                if dd_var.len().gt(0) {
                    dont_delete_vars.push(dd_var)
                }
            } else {
                // Step 2: Collect create_alias var names
                alias_var := get_create_alias_var(stmt)
                if alias_var.len().gt(0) {
                    dont_delete_vars.push(alias_var)
                }
                new_body.push(garbager_recursive(context, stmt)?)
            }
        }

        // Step 3: Collect delete candidates (parallel vecs: var names + type names)
        mut cand_vars := Vec.new(Str)
        mut cand_types := Vec.new(Str)

        // 3a: copy/own params with deletable types
        for arg_def: Declaration in func_def.args {
            if arg_def.is_copy.or(arg_def.is_own) {
                switch arg_def.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(arg_def.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            }
        }

        // 3b: Scan new_body for Declaration nodes with deletable types
        for stmt: Expr in new_body {
            switch stmt.node_type {
            case NodeType.Declaration(decl):
                switch decl.value_type {
                case ValueType.TCustom(type_name):
                    if is_deletable_type(type_name, context) {
                        cand_vars.push(decl.name)
                        cand_types.push(type_name)
                    }
                case:
                }
            case:
            }
        }

        // Step 4: Remove dont_delete_vars and own-transferred vars
        own_transfers := collect_own_transfers(new_body, context)
        mut filtered_vars := Vec.new(Str)
        mut filtered_types := Vec.new(Str)
        for i in 0..cand_vars.len() {
            mut var_name := ""
            cand_vars.get(i, var_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut type_name := ""
            cand_types.get(i, type_name)?
            catch (err: IndexOutOfBoundsError) { }
            mut excluded := false
            for dd: Str in dont_delete_vars {
                if dd.eq(var_name) { excluded = true }
            }
            for ot: Str in own_transfers {
                if ot.eq(var_name) { excluded = true }
            }
            if not(excluded) {
                filtered_vars.push(var_name)
                filtered_types.push(type_name)
            }
        }

        // Step 5: Append Type.delete(var) calls in reverse declaration order
        mut last_line := e.line
        mut last_col := e.col
        if new_body.len().gt(0) {
            mut last_stmt := Expr()
            new_body.get(new_body.len().sub(1), last_stmt)?
            catch (err: IndexOutOfBoundsError) { }
            last_line = last_stmt.line
            last_col = last_stmt.col
        }
        mut ri := filtered_vars.len()
        while ri.gt(0) {
            ri = ri.sub(1)
            mut del_var := ""
            filtered_vars.get(ri, del_var)?
            catch (err: IndexOutOfBoundsError) { }
            mut del_type := ""
            filtered_types.get(ri, del_type)?
            catch (err: IndexOutOfBoundsError) { }
            new_body.push(build_delete_call_expr(del_type, del_var, last_line, last_col))
        }

        new_func_def := SFuncDef(
            function_type=func_def.function_type,
            args=func_def.args.clone(),
            return_types=func_def.return_types.clone(),
            throw_types=func_def.throw_types.clone(),
            body=new_body,
            source_path=func_def.source_path
        )
        // Also recurse into params (e.g., default argument values)
        mut new_params := Vec.new(Expr)
        for param: Expr in e.params {
            new_params.push(garbager_recursive(context, param)?)
        }
        return Expr.new_explicit(NodeType.FuncDef(new_func_def), new_params, e.line, e.col)
#+END_SRC

**** Step 10B: ASAP last-use deletion for copy/own params — DONE

Files: ~src/rs/garbager.rs~, ~src/self/garbager.til~, ~src/self/ccodegen.til~

Moves ~Type.delete(var)~ calls from function body END to right after the
variable's last use — but only for ~copy~/~own~ params (deep copies, no aliasing).
Locals stay at function end (shared offsets mean locals can alias through
field assignment).

***** New helpers (both Rust + TIL)

- ~expr_references_var(e, var_name) -> bool~: Recursively checks if any
  Identifier node in the expression tree matches var_name. Recurses into
  e.params but NOT into nested FuncDef bodies (separate scope).

- ~find_last_use_index(body, var_name) -> Option<usize>~ (Rust) /
  ~-> I64~ (TIL, -1 = not found): Scans body from end to start, returns
  index of last statement referencing the variable.

***** Modified Step 5 logic

Step 5 now separates candidates into two groups:
- ~asap_candidates~ (copy/own params): insert delete after last use via
  HashMap (Rust) / parallel Vecs (TIL) for insertion positions
- ~end_candidates~ (locals): append at function end in reverse declaration order

When multiple deletes land at the same position, they appear in reverse
declaration order (last declared -> first deleted).

***** Bug fix: dont_delete for field aliases in ccodegen.til

ASAN revealed a pre-existing double-free from Step 10A in
~emit_precomputed_vec_assignment~: ~elem_type := contents.element_type_name~
creates a shared-pointer alias. Both ~Str.delete(elem_type)~ and
~VecContents.delete(contents)~ freed the same Str. Fixed with
~dont_delete(elem_type)~. Rust version uses ~&contents.element_type_name~
(a reference), so no issue there.

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Ownership Model for Containers
- ~push~/~set~/~insert~ use ~own~ params: ownership transfers IN (zeroing deferred to Step 9)
- ~get~ returns borrowed Ptr: no copy, no ownership transfer OUT
- Caller reads through Ptr; to get owned copy, explicitly clone
- This makes the ownership flow clean: containers own their data, ~get~ borrows,
  ~push~/~own~ transfers in. No hidden aliasing from shallow copies.

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Bug #168: ccodegen return values create copies the interpreter doesn't
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic divergence between interpreter and compiled code; root cause of memory leak gap
:STATUS: Partially done -- Commit 1 on master, rest on failed168 branch
:RELATED: Bug #159 (shallow copies), Bug #165 (memory leak), Bug #80 (ccodegen divergence), Issue #117 (ASAP destruction)
:END:

*** Description
In the interpreter, function returns are shared offsets -- no copy happens.
In ccodegen, every struct return is a memcpy:
#+begin_src c
*_ret = value;          // callee: struct assignment = implicit memcpy
var = func_call();      // caller: receives shallow copy
#+end_src

This means ccodegen creates copies the interpreter never does. The original
value in the callee's scope is abandoned (heap pointers aliased, never freed).
This is the fundamental semantic gap between interpreter and compiled memory
behavior, and the reason compiled TIL leaks far more than interpreted.

In C, return values are effectively pointer-based anyway (NRVO, hidden
destination pointer). The memcpy is semantically unnecessary. Same applies
to throw values and out params.

*** Why this matters
- #117 (ASAP destruction) can't be completed for ccodegen while returns
  create aliases the interpreter doesn't have
- #80 (ccodegen match) can't be verified because compiled TIL eats too
  much memory to run =make diff til.til=
- #100 (self-hosting) is blocked by #80 which is blocked by this

*** Inventory (from Bug #159 section 1)
- =*_ret = value;= -- callee struct assignment
- =var = _ret_X;= -- call site receives shallow copy
- Every function returning a struct creates a shallow copy at the call site
- throw values -- same pattern
- out params -- same pattern

*** Implementation

**** Commit 1: Throwing calls -- eliminate intermediate =_ret_N= temp -- DONE

Throwing functions already use the out-pointer pattern. Eliminated the
unnecessary intermediate temp at call sites:

#+begin_src c
// BEFORE:
til_Str _ret_N;                              // temp
int _status_N = func(&_ret_N, &_err, args);  // write to temp
dest = _ret_N;                               // UNNECESSARY COPY

// AFTER:
int _status_N = func(&dest, &_err, args);    // write to dest directly
#+end_src

Added =build_dest_ptr_expr= helper. Modified =emit_throwing_call_propagate=
and =emit_throwing_call_with_goto= to skip temp, use dest ptr, skip copy.
Ported to ccodegen.til. On master at 639c1741.

**** Commit 2+3: Out-pointer + placement construction -- FAILED (branch: failed168)

Attempted to switch non-throwing struct returns to out-pointer (=void func(Type* _ret, ...)=)
as infrastructure for "placement construction" (constructing directly into =*_ret=
instead of a local, eliminating the unreachable delete after return).

Commit 2 (out-pointer conversion) worked but added significant complexity to
ccodegen for zero performance gain on its own. Benchmark times increased.
Commit 3 (placement construction) was planned but not completed.

The approach was shelved because:
- Commit 2 alone was pure overhead (more complex codegen, slower benchmarks)
- Placement construction requires deep changes to how every function emits code
- The complexity-to-benefit ratio was poor
- Better to find a simpler approach to the memory leak problem

Code preserved on =failed168= branch for reference.

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

