#+TITLE: Pre-1.0 Release Features
#+AUTHOR: TIL Development
#+DATE: 2026-01-30
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks features and improvements planned for the 1.0 release.
These are not blocking self-hosting but are important for a polished release.

For bugs, see bugs.org. For post-self-hosting features, see post.org.

* Open Issues

** Issue #161: Namespace constants, static mutables, and per-instance immutables
:PROPERTIES:
:DISCOVERED: 2026-02-04
:IMPACT: Unified syntax for type-level and instance-level data
:STATUS: Open - detailed plan ready
:RELATED: Issue #108 (namespace blocks - implemented)
:END:

*** Overview

Follow-up to Issue #108 (namespace blocks for associated functions). This issue
extends namespaces to support constants and mutable state, and adds per-instance
immutable fields to structs.

After this issue, four kinds of declarations exist:

| Location  | Syntax             | Meaning                          |
|-----------+--------------------+----------------------------------|
| namespace | ~Max := 100~       | Associated constant (static)     |
| namespace | ~mut counter := 0~ | Associated mutable (static)      |
| struct    | ~id := 0~          | Per-instance immutable (frozen)  |
| struct    | ~mut name := ""~   | Per-instance mutable             |

*** Step 1: Associated constants in namespace blocks

Move type-level constants from standalone globals into type namespaces.

**** Current state
Constants are standalone globals with naming conventions:
#+BEGIN_SRC til
MAX_I64 := 9223372036854775807
MIN_I64 := -9223372036854775808
I64_SIZE := 8
#+END_SRC

**** Target state
Constants live in type namespaces:
#+BEGIN_SRC til
namespace I64 {
    Max := 9223372036854775807
    Min := -9223372036854775808
    Size := 8
}
// Usage: I64.Max instead of MAX_I64
#+END_SRC

**** Implementation

***** Step 1.1: Verify namespace blocks support constants
Namespace blocks already support function definitions. Verify they also support
constant declarations (non-mut, non-function). This likely already works since
init.rs merges all namespace members into the type.

Test with:
#+BEGIN_SRC til
namespace I64 {
    TestConst := 42
}
assert_eq(loc(), 42, I64.TestConst)
#+END_SRC

Files to check: init.rs:1311-1400, init.til (NamespaceDef handling)

***** Step 1.2: Audit existing constants
Find all type-related constants in the codebase:
- I64: MAX_I64, MIN_I64, I64_SIZE
- U8: (check if any exist)
- Str: (check if any exist)
- Other types in src/core/

***** Step 1.3: Migrate constants to namespaces
For each type, move constants into namespace blocks:
#+BEGIN_SRC til
// Before (in i64.til)
MAX_I64 := 9223372036854775807

// After (in i64.til)
namespace I64 {
    Max := 9223372036854775807
}
#+END_SRC

***** Step 1.4: Update all usages
Find and replace all old constant names:
- ~MAX_I64~ -> ~I64.Max~
- ~MIN_I64~ -> ~I64.Min~
- etc.

***** Step 1.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 2: Associated mutable state in namespace blocks

Allow ~mut~ declarations in namespace blocks - these work like static variables.

**** Use case
#+BEGIN_SRC til
Soldier := struct {
    mut id := 0
    mut name := "unknown"
}

namespace Soldier {
    mut counter := 0  // Static counter shared by all instances

    new := func(name: Str = "unknown") returns Soldier {
        s := Soldier(id=counter, name=name)
        counter = counter + 1
        return s
    }
}

// Usage:
s1 := Soldier.new("Alice")  // id=0
s2 := Soldier.new("Bob")    // id=1
#+END_SRC

**** Implementation

***** Step 2.1: Parser - allow mut in namespace blocks
Check if parser already accepts ~mut~ declarations in namespace blocks.
If not, update parse_namespace_definition to accept them.

Files: parser.rs, parser.til

***** Step 2.2: Init - register namespace mutables
When init processes NamespaceDef, it currently registers functions.
Extend to also register mutable variables with their initial values.

The mutable needs to be:
- Registered as a symbol with is_mut=true
- Stored in the global scope (not per-instance)

Files: init.rs, init.til

***** Step 2.3: Interpreter - handle namespace mutable access
When evaluating ~TypeName.mutable_var~, look up and return/assign the value.
This is similar to how ~TypeName.constant~ works, but allows mutation.

Files: interpreter.rs, interpreter.til

***** Step 2.4: Ccodegen - emit namespace mutable as static
In C, namespace mutables become static variables:
#+BEGIN_SRC c
// For: namespace Soldier { mut counter := 0 }
static long long til_Soldier_counter = 0;
#+END_SRC

Files: ccodegen.rs, ccodegen.til, scavenger.rs, scavenger.til

***** Step 2.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 3: Per-instance immutable fields in structs

Allow non-mut fields in structs that are set at construction and frozen afterward.

**** Use case
#+BEGIN_SRC til
Entry := struct {
    id := 0              // Immutable after construction
    mut name := ""       // Mutable
    mut desc := ""       // Mutable
}

mut e := Entry(id=get_unique_id(), name="test", desc="description")
e.name = "new name"  // OK - name is mut
e.id = 999           // ERROR - id is not mut, frozen after construction
#+END_SRC

**** Current state
Non-mut fields in structs are currently used for associated constants/functions:
#+BEGIN_SRC til
MyStruct := struct {
    static_const := 42       // Associated constant (no mut)
    mut instance_data := 0   // Instance field (mut)
}
#+END_SRC

After Issue #108, functions are in namespace blocks. But constants in struct
still work as associated constants (e.g., Cell.CHAR_WIDTH in hello_gui.til).

**** Design decision
With namespace blocks, associated constants should move to namespaces (Step 1).
This frees up non-mut struct fields for a new meaning: per-instance immutables.

Migration path:
1. Step 1 moves associated constants to namespaces
2. Step 3 repurposes non-mut fields for instance immutables
3. Deprecation warning for old pattern during transition

**** Implementation

***** Step 3.1: Migrate existing struct constants to namespaces
Before changing semantics, move all existing struct constants to namespace blocks.
Example from hello_gui.til:
#+BEGIN_SRC til
// Before
Cell := struct {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}

// After
Cell := struct {}
namespace Cell {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}
#+END_SRC

***** Step 3.2: Typer - track field mutability
The typer needs to know which struct fields are mutable vs immutable.
Add check: if assigning to a non-mut field after construction, emit error.

Challenge: distinguishing construction from assignment.
- Construction: ~Entry(id=42)~ - allowed to set immutable fields
- Assignment: ~e.id = 42~ - not allowed for immutable fields

Files: typer.rs, typer.til

***** Step 3.3: Interpreter - enforce field immutability
After struct construction, track which fields are frozen.
Reject mutations to immutable fields.

Approach: In eval_set, before modifying a struct field, check if field is mut.
If not mut and struct already exists, error.

Files: interpreter.rs, interpreter.til

***** Step 3.4: Ccodegen - enforce field immutability (optional)
Could add runtime checks in generated C, or rely on typer catching it.
Typer-only enforcement is simpler and sufficient.

***** Step 3.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Testing

**** Step 1 tests
#+BEGIN_SRC til
// Test namespace constants
namespace I64 {
    TestMax := 9223372036854775807
}
assert_eq(loc(), 9223372036854775807, I64.TestMax)
#+END_SRC

**** Step 2 tests
#+BEGIN_SRC til
// Test namespace mutable (static)
Counter := struct {}
namespace Counter {
    mut value := 0
    increment := func() returns I64 {
        value = value + 1
        return value
    }
}
assert_eq(loc(), 1, Counter.increment())
assert_eq(loc(), 2, Counter.increment())
assert_eq(loc(), 2, Counter.value)
#+END_SRC

**** Step 3 tests
#+BEGIN_SRC til
// Test per-instance immutable
ImmutableTest := struct {
    id := 0        // Immutable
    mut name := "" // Mutable
}

mut t := ImmutableTest(id=42, name="test")
assert_eq(loc(), 42, t.id)
t.name = "changed"  // OK
// t.id = 99       // Should error: cannot assign to immutable field
#+END_SRC

*** Verification
1. Run ~make benchmark~ after each step - all tests must pass
2. Port each .rs change to .til immediately
3. Test both interpreter and compiler modes

** Issue #159: copy keyword does shallow copies (byte copy, not clone)
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Affects ASAP destruction safety, copy semantics clarity
:STATUS: Open - implementation plan ready
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Analysis Summary

The ~copy~ keyword and ~mut x := y~ declarations use ~EvalArena::copy_fields()~
which performs a **shallow byte copy**, not a deep clone.

*** What copy_fields Does (eval_arena.rs:239-307)

1. Iterates through struct fields
2. For each mutable field:
   - Reads raw bytes from source offset
   - Writes raw bytes to destination offset
   - Recursively copies nested struct fields

*** The Problem: Shared Heap Pointers

For structs containing ~Ptr~ fields (Vec, Str, Map, etc.), copying creates two
structs pointing to the **same heap allocation**:

#+BEGIN_SRC til
original := Vec.new(I64)
original.push(42)
mut copy := original  // shallow copy - copy.ptr = original.ptr

copy.push(100)        // modifies shared heap data!
println(original.len())  // Also shows 2 - they share the same buffer
#+END_SRC

*** Implications for ASAP Destruction (Issue #117)

This is why Step 4 (liveness analysis) in the garbager was disabled:

#+BEGIN_SRC til
process := proc() {
    data := Vec.new(I64)
    mut backup := data    // shallow copy - both point to same heap
    use(data)             // "last use" of data
    // ASAP would insert: data.delete() here - WRONG!
    // backup.ptr is now dangling
    use(backup)           // CRASH or corruption
}
#+END_SRC

*** Current Behavior vs Expected

| Operation | Current | Expected | Notes |
|-----------+---------+----------+-------|
| ~x := y~ (const) | Reference (alias) | Reference | Safe - can't modify |
| ~mut x := y~ | Shallow byte copy | Deep copy? | Problematic for Ptr |
| ~copy param~ | Shallow byte copy | Deep copy? | Problematic for Ptr |

*** Why This Hasn't Broken Tests

1. **Const bindings are safe**: ~x := y~ creates an alias, no copy
2. **Tests don't share then modify**: Most tests don't copy-then-mutate-both
3. **No ASAP destruction yet**: We manually delete at scope end

*** What Doesn't Need Changing

1. **const bindings** (~x := y~): Already safe - just an alias
2. **Function params** (default): Already pass-by-reference
3. **Primitive copies** (I64, U8, Bool): No heap data, shallow = deep

*** Solution: Auto-generate clone() and use it for copies

Instead of shallow byte copies, we'll use ~clone()~ methods for all copies.
This ensures deep copies that don't share heap allocations.

*** Implementation Plan

**** Step 1: Auto-generate clone() methods

Add to garbager phase (which already auto-generates ~delete()~):

1. For any struct without a ~clone()~ method, generate one
2. Generated clone creates a new instance and clones each field:
   #+BEGIN_SRC til
   // Auto-generated for:
   // MyStruct := struct { mut name: Str, mut data: Vec, mut count: I64 }

   clone := func(self: MyStruct) returns MyStruct {
       return MyStruct(
           name = self.name.clone(),
           data = self.data.clone(),
           count = self.count.clone()  // I64.clone() returns self
       )
   }
   #+END_SRC

3. **Exception for borrowed Ptr fields**: If a field is a borrowed Ptr
   (is_borrowed = true or marked as borrowed in Issue #115), just copy the
   pointer value, don't clone the pointed-to data.

4. **Primitives**: I64, U8, Bool get trivial ~clone()~ that returns self.
   (May already exist or can be added.)

5. **Validation**: Remove manually-written clone() methods that would be
   identical to auto-generated ones. This tests that auto-generation works
   correctly and reduces code duplication.

Files: garbager.rs, garbager.til

**** Step 2: Replace copy_fields() with clone()

**copy_fields call sites (interpreter.rs) - DONE items use clone() now:**

| Line | Context | Pattern | Status |
|------|---------|---------|--------|
| 641 | Struct literal field | ~MyStruct(field = nested_struct)~ | TODO |
| 1006 | Struct member default | Nested struct in struct definition | TODO |
| 1094 | mut declaration | ~mut x := struct_expr~ (Bug #25 fix) | DONE |
| 1194 | Assignment | ~x = struct_expr~ | TODO |
| 2153 | copy param (saved offsets) | Complex case with name collision | TODO |
| 2183 | copy param (identifier) | ~func(copy p: T)~ with variable | TODO |
| 2208 | copy param (expression) | ~func(copy p: T)~ with expr | TODO |

**ccodegen call sites (ccodegen.rs) - generates C code:**

| Context | Pattern | Status |
|---------|---------|--------|
| mut declaration | ~mut x := existing_var~ | DONE |

Note: Compiler generates ~Type_clone(&var)~ for struct identifier assignments.

**Current pattern (complex):**
#+BEGIN_SRC rust
// 1. Allocate destination space
insert_struct_instance(context, &dest, type_name, e)?;
// 2. [lots of temp key setup for arena lookups]
// 3. Copy bytes from source to destination
EvalArena::copy_fields(context, type_name, &src, &dest, e)?;
// 4. [lots of temp key cleanup]
#+END_SRC

**New pattern (simpler):**
#+BEGIN_SRC rust
// 1. Call clone which allocates + returns new instance
let result = call_clone_method(context, type_name, &src, e)?;
// 2. Bind dest name to the cloned instance's offset
context.scope_stack.insert_var(dest, result.offset);
#+END_SRC

**Implementation approach:**

Add helper function in interpreter.rs:
#+BEGIN_SRC rust
/// Call Type.clone(source) and return the cloned instance
fn call_clone_method(ctx: &mut Context, type_name: &str, src: &str, e: &Expr) -> Result<EvalResult, String> {
    // Build AST: Type.clone(src)
    let clone_call = make_ufcs_call(type_name, "clone", vec![make_id(src, e.line, e.col)], e.line, e.col);
    eval_expr(ctx, &clone_call)
}
#+END_SRC

This simplifies the function parameter binding code significantly - no more:
- Temporary frame pushing/popping
- Saved offset management for name collisions
- Temporary key registration and cleanup

When ~copy_fields()~ becomes dead code, Rust warnings will force removal.

Files: interpreter.rs, interpreter.til, eval_arena.rs, eval_arena.til

*** Interaction with Other Issues

- **Issue #117 (ASAP destruction)**: With proper deep copies, Step 4 (liveness
  analysis) becomes safe. No more shared heap pointers from copies.
- **Issue #115 (owned fields)**: Borrowed fields need special handling in
  clone() - copy pointer, don't clone pointed-to data.

*** Testing

1. Write test that copies a Vec, modifies copy, verifies original unchanged
2. Write test that copies nested struct with Vec fields
3. Remove manual clone() methods and verify auto-generated ones work
4. Run ~make benchmark~ - all tests must pass

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Issue #117: ASAP Destruction (auto-delete on last use)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Fixes memory leaks automatically, Mojo-style memory management
:STATUS: Open
:DEPENDS: Bug #101 (unused warnings - shared infrastructure)
:RELATED: Bug #114 (memory leak documentation)
:END:

*** Description
Implement Mojo-style automatic destructor calls on last use. When a variable with
heap data is last used, the compiler automatically inserts a ~delete()~ call.

*** Prerequisites
- Bug #101: Unused variable warnings use similar liveness analysis

*** Types with delete()

**** Delete Hierarchy (after Ptr refactor)
Types use Ptr internally, so delete() cascades automatically:

| Type  | Internal Storage    | delete() behavior                    |
|-------+---------------------+--------------------------------------|
| Ptr   | raw heap pointer    | checks is_borrowed, then free()      |
| Vec   | Ptr                 | calls ptr.delete()                   |
| Array | raw I64 ptr         | calls free() directly (not Ptr type) |
| Str   | Ptr                 | calls c_string.delete()              |
| Set   | Vec                 | calls elements.delete()              |
| Map   | Vec x2              | calls keys.delete(), values.delete() |
| List  | Ptr + Vec x2        | calls data/type_names/type_sizes.delete() |

**** Implication for ASAP destruction
ASAP destruction only needs to track top-level variables. When we call
~map.delete()~, it cascades: Map -> Vec -> Ptr -> free(). No need to
separately track nested Ptr fields.

*** Implementation Approach

AST transformation in a new "garbager" phase. Inserts ~var.delete()~ calls directly
into the AST after last use. Both compiler and interpreter benefit automatically.

Pipeline position: typer -> desugar -> ufcs -> *garbager* -> precomp -> ...

Files: garbager.rs, garbager.til (new)

*** Implementation Steps

**** Step 1: Add is_borrowed to Ptr (DONE)
Add ownership tracking to Ptr:
#+BEGIN_SRC til
Ptr := struct {
    mut data : I64 = 0
    mut is_borrowed : Bool = false

    new := proc(T: Type, is_borrowed: Bool = false) returns Ptr { ... }
    new_by_size := proc(size: I64, is_borrowed: Bool = false) returns Ptr { ... }

    delete := proc(mut self: Ptr) {
        if not(self.is_borrowed) and not(self.is_null()) {
            free(self.data)
        }
        self.data = 0
    }
}
#+END_SRC

- String literals in ccodegen set is_borrowed=true
- Ptr.new_by_size() defaults to is_borrowed=false (owned)
- Add Str.delete() that calls c_string.delete()
- Files: ptr.til, ptr.rs, str.til, str.rs, ccodegen.rs, ccodegen.til

**** Step 2: Add delete() to primitive types (DONE)
Add no-op ~delete()~ to primitive types (I64, U8, Bool).
This ensures ALL types have ~delete()~, simplifying the garbager phase.

Files: i64.til, u8.til, bool.til

**** Step 3: Garbager Phase - Auto-generate delete() for structs (DONE)
New phase after ufcs that auto-generates ~delete()~ method for any struct that lacks one.

Algorithm:
1. When processing a struct definition, check if it has a ~delete~ method
2. If not, generate one that calls ~field.delete()~ for every mutable field
   - Fields processed in reverse declaration order (like C++/Rust destructors)
   - Skip structs with no mutable fields (error types like BadAlloc)
3. Insert the generated method into the struct's members and default_values

Example - given:
#+BEGIN_SRC til
MyStruct := struct {
    mut name: Str = ""
    mut data: Vec = Vec.new(I64)
    mut count: I64 = 0
}
#+END_SRC

Auto-generate:
#+BEGIN_SRC til
delete := proc(mut self: MyStruct) {
    self.count.delete()  // I64.delete() is a no-op
    self.data.delete()   // Vec.delete() frees memory
    self.name.delete()   // Str.delete() frees memory
}
#+END_SRC

Files: garbager.rs, garbager.til (new)

**** Step 4: Liveness Analysis and Delete Insertion
Add liveness analysis to track when variables are last used, then insert ~var.delete()~ calls.

Data structure:
#+BEGIN_SRC rust
struct VarLifetime {
    name: String,
    value_type: ValueType,
    last_use_stmt_idx: Option<usize>,
    is_deleted: bool,
}
#+END_SRC

Note: No need for ~has_delete~ field - after Step 3, every struct has ~delete()~.

Algorithm:
1. Analysis pass: Scan statements, track last use index per variable
2. Transform pass: Insert ~var.delete()~ statement after last_use_stmt_idx

Handle control flow:
- Early exits (return/throw): Insert deletes for all still-live variables before exit
- Branches (if/else/switch): Conservative - only delete if ALL paths agree variable is dead, otherwise delete after branch
- Loops: Most conservative - variables used in loop body deleted after loop ends
- Scope exit: Safety net - insert deletes for any remaining live variables at function end

Files: garbager.rs, garbager.til

*** Design Decisions
- Method name: Use existing ~delete()~
- Double-free prevention: Existing delete() sets ptr/data to 0 after free
- Destruction order: Reverse order of declaration (like C++/Rust)
- AST transformation: Insert delete() calls in garbage phase, so both compiler and interpreter benefit
- Cascading deletes: Only track top-level variables; nested Ptr fields handled by type's delete()
- Borrowed vs owned: Ptr.is_borrowed distinguishes static memory (literals) from heap allocations

*** Verification
1. Run under valgrind - no leaks
2. Double-free tests - delete() is idempotent
3. Control flow tests - returns, throws, branches, loops
4. ~make benchmark~ must pass

** Issue #115: Owned struct fields and auto-generated methods
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Enables proper ASAP destruction for composite types
:STATUS: Open
:RELATED: Bug #114 (memory leaks), Issue #134 (Ptr type), ownership.org
:END:

*** Description
Struct fields should be able to declare ownership semantics. Currently fields are
just "mut" or not, but we need to express whether a struct OWNS its fields (and
should delete them) vs BORROWS them (someone else deletes).

*** Example Use Case
Neural network layer:
#+BEGIN_SRC til
Layer := struct {
    own weights: Vec    // Layer owns this, deletes it
    own output: Vec     // Layer owns this, deletes it
    input: Vec          // Borrowed from previous layer, don't delete
}
#+END_SRC

User sees Vec in all cases. The ~own~ keyword affects:
- Owned field: Actual data stored, delete() called when parent deleted
- Borrowed field: Internally stored as pointer, NOT deleted when parent deleted

The previous layer's ~output~ IS the next layer's ~input~ - same memory, two views.

*** Auto-Generated Methods
With ownership info, compiler could auto-generate:
- delete(): Calls delete() on all owned fields
- size(): Sums size of all fields
- clone(): Deep clones owned fields, shallow copies borrowed

Without auto-generation, users must write these manually (error-prone).

*** Syntax Options
1. ~own weights: Vec~ - keyword before field name
2. ~weights: own Vec~ - keyword before type
3. ~weights: Vec @own~ - attribute syntax

*** Interaction with ASAP Destruction
When parent struct is deleted (ASAP or explicit):
- Owned fields: cascade delete
- Borrowed fields: leave alone

*** Open Questions
- Default: owned or borrowed? (Probably owned, like Rust)
- Can primitives (I64, Bool) be "owned"? (Probably no - always copy)
- How does this interact with const/mut/copy/own function parameters?
- How is a borrowed field assigned? (Must point to something that outlives the struct)

** Issue #135: True cross-compilation via precompiled ext.o per platform
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Enables compiling from any host to any target (like Rust)
:STATUS: Open
:RELATED: Issue #131 (clang support)
:END:

*** Description
Currently, cross-compilation to macOS from Linux/Windows fails because:
1. Generated C code includes OS-specific headers (~<stdio.h>~, ~<stdlib.h>~)
2. These headers differ per OS and aren't redistributable (especially Apple's)
3. Even with clang's ~-target~ flag, we need the target's SDK

Rust solves this by using LLVM and shipping precompiled std libs per platform.
We can do something similar for TIL.

*** Proposed Solution
Move all OS-specific code into ~ext.c~ and precompile it for each target:

1. *Refactor ext.c*: Move ALL OS-dependent code there (printf wrappers, malloc,
   file I/O, syscalls). The generated C should have zero ~#include~ statements.

2. *Precompile ext.o per platform*: Build ~ext-linux-x64.o~, ~ext-macos-arm64.o~,
   ~ext-windows-x64.o~, etc. on actual hardware (via CI).

3. *Ship precompiled objects with rstil*: These ~.o~ files become part of the
   distribution.

4. *Generate header-free C*: Instead of ~#include <stdio.h>~, just declare:
   #+BEGIN_SRC c
   // Function signatures provided by ext.o
   void til_print(const char* s);
   void* til_malloc(long long size);
   // ... generated code follows ...
   #+END_SRC

5. *Compile and link*:
   #+BEGIN_SRC bash
   clang -target arm64-apple-macos11 -c music.c -o music.o
   clang -target arm64-apple-macos11 music.o ext-macos-arm64.o -o music
   #+END_SRC

*** Benefits
- Compile from any host to any target (Linux->macOS, Windows->Linux, etc.)
- No SDK dependencies at compile time
- Matches Rust's cross-compilation model
- ext.o files built once per release via CI

*** Implementation Steps
1. Audit ext.c - identify all OS-specific includes and calls
2. Create abstraction layer in ext.c for all OS functions
3. Modify ccodegen to emit header-free C with extern declarations
4. Set up CI jobs to build ext.o for each platform on native runners
5. Update builder.rs to link against precompiled ext.o instead of including ext.c
6. Package ext.o files in rstil distribution

*** Open Questions
- How to handle platform-specific behavior differences (line endings, paths)?
- Size impact of shipping multiple .o files?
- Alternative: use ~zig cc~ which bundles everything (simpler but adds dependency)

** Issue #82: make.til - Replace Makefile with TIL
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Build system, dogfooding, portability
:STATUS: Open
:RELATED: Issue #81 (rs2til.til - another tool in TIL)
:END:

*** Background
The current Makefile works but is external to the TIL ecosystem. A make.til
with shebang would:
- Dogfood TIL for build orchestration
- Reduce external dependencies
- Allow richer build logic in a familiar language

*** Requirements

1. *New mode: make*
   - ~mode make~ for build scripts
   - Appropriate permissions for file ops, shell commands

2. *File modification tracking*
   - Need to check if source files are newer than targets
   - Implies: file stat functionality (mtime)

3. *Dependency graph*
   - Track which targets depend on which sources
   - Only rebuild what's needed

*** Example Structure
#+begin_src til
#!/usr/bin/env til interpret
mode make

// Makefile content in TIL syntax
#+end_src

*** Implementation Notes

File stat would need new builtins:
- ~file_mtime(path: Str) returns I64~ - modification time as epoch
- Or ~file_newer(a: Str, b: Str) returns Bool~ - simpler comparison

*** Open Questions
- How to handle parallel builds?
- Should it support general make-like syntax or be TIL-native?
- Bootstrap problem: how to build til before make.til can run?

