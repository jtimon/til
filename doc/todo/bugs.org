#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-11-10

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :MINOR:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Developer experience, debugging
:STATUS: Active
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors
- Pros: Balanced approach, maintains backward compatibility
- Cons: Still requires some refactoring

*Relevant Code Locations:*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Fixed Bugs Summary

Bugs #1-#8 have been fixed and their tests integrated into the regular test suite (=enums.til=, =flow.til=, =arithmetics.til=, =return_value_usage.til=).

* Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

* Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

* Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

* Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

* Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

* Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

* Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

* Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

* Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*: ✅ FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

*** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

*** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

*** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

*** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

*** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

*** Valid Code Patterns
```til
// ✅ Capture the return value
result := my_add(1, 2)

// ✅ Use as argument to another function
double(my_add(3, 4))

// ✅ Explicitly discard with _
_ := get_value()

// ✅ Procs don't return values, no capture needed
print_hello()

// ❌ ERROR: Return value not captured
my_add(1, 2)
```

*** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

*** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

*** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
