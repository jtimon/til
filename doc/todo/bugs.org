#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it,
# BOT: add them at the top of active bugs, when fixed, move them to the top of fixed bugs

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #129: Parser cannot handle explicit ~auto~ type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Inconsistent syntax - ~a := 69~ works but ~a : auto = 69~ fails
:STATUS: Open
:END:

*** Description
The syntax ~a := 69~ is internally parsed as a Declaration with value_type="auto" (INFER_TYPE).
However, writing ~a : auto = 69~ explicitly fails with a parse error.

Similarly, ~for elem: auto in collection~ parses but typer doesn't resolve the element type,
causing type errors downstream.

*** Root Cause
In parser.rs, parse_declaration uses ~explicit_type != INFER_TYPE~ to determine whether
to skip a type token. When user writes ~: auto~, the parser passes "auto" as explicit_type.
Since "auto" == INFER_TYPE, the condition is false and the parser doesn't skip the type token,
causing it to see ~=~ where it expects the value expression.

The code path:
1. ~a : auto = 69~ tokens: [a, :, auto, =, 69]
2. Parser sees ~auto~ (Identifier), passes "auto" to parse_declaration
3. advance(3) skips [a, :, auto], now at ~=~
4. ~"auto" != INFER_TYPE~ is FALSE, no extra advance
5. parse_primary() sees ~=~ instead of ~69~ -> error

*** Expected Behavior
~a : auto = 69~ should parse identically to ~a := 69~.

*** Possible Fixes
1. Use a different internal sentinel for INFER_TYPE (not "auto")
2. Pass a boolean ~has_type_token~ to parse_declaration instead of relying on value
3. Re-architect parsing to handle this case

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Bug #126: Error message divergence between rstil and til
:PROPERTIES:
:DISCOVERED: 2026-01-19
:IMPACT: Tests must be in rs_common/til_common separately, not all_common
:STATUS: Open
:RELATED: Issue #69 (test organization), Bug #125 (non-deterministic errors)
:END:

*** Description
When the same code produces errors in both rstil and til, the error messages
differ in content, format, and/or order. This prevents tests from being in
all_common (which requires identical output across all 4 modes).

*** Examples (from src/test/sugar.til)

rstil produces extra errors that til doesn't:
- "Type 'Thing' has no method 'eq'" (init ERROR)

rstil has debug markers that til doesn't:
- "struct 'Thing' has no member 'eq' c" (trailing " c")
- See src/rs/init.rs:530 (" b"), 708 (" c"), 716 (" d")

*** Root Cause
1. Debug markers (" b", " c", " d") in Rust error messages not ported to TIL
2. Different code paths triggered between Rust and TIL implementations
3. Error collection/reporting order differs

*** Workaround
Tests with error output divergence go in rs_common AND til_common separately
(per Issue #69), with separate expected output files for each.

For sugar.til specifically, underscore-prefixed variables (_t1, _t2) avoid
Bug #125's non-deterministic unused variable errors.

*** Fix
Align error messages between src/rs/ and src/self/:
1. Remove debug markers from Rust or add them to TIL
2. Ensure same code paths produce same errors in same order
3. Port any error message changes bidirectionally

** Bug #124: I64 literals cannot be passed to U8 parameters in method calls
:PROPERTIES:
:DISCOVERED: 2026-01-17
:IMPACT: Must declare U8 constants for literals when calling U8 methods
:STATUS: Open
:END:

*** Description
When calling methods on U8 values using UFCS syntax, I64 numeric literals (like 42 or 255)
cannot be directly passed as arguments to U8 parameters. The type checker rejects them even
though I64 literals work fine in other contexts where U8 is expected (like variable assignment).

*** Example
#+BEGIN_SRC til
mut val : U8 = 41
val.inc()
test(loc(), val.eq(42), "should work but fails")  // ERROR: expects U8, got I64

// Workaround: declare constant first
u8_42 : U8 = 42
test(loc(), val.eq(u8_42), "works")  // OK
#+END_SRC

*** Root Cause
After refactoring U8.lt and U8.gt to use native u8_lt/u8_gt ext_funcs (instead of converting
to I64 internally), the type checker now strictly enforces U8 parameter types. The issue is
that literal type inference doesn't work for method call arguments the same way it works for
variable assignments.

Variable assignment: `val : U8 = 42` - the literal 42 is inferred as U8 (works)
Method call: `val.eq(42)` - the literal 42 is typed as I64 (fails)

*** Workaround
Declare U8 constants before passing them to U8 methods:
#+BEGIN_SRC til
u8_42 : U8 = 42
test(loc(), val.eq(u8_42), "works")
#+END_SRC

*** Notes
This affects U8.eq, U8.lt, U8.gt, U8.lteq, U8.gteq and any other U8 methods that take U8 parameters.
The old implementation of U8.lt/U8.gt worked around this by converting to I64 internally, but that
defeated the purpose of having native U8 comparison functions.

** Bug #123: UFCS method calls fail on recursive nested function results
:PROPERTIES:
:DISCOVERED: 2026-01-16
:IMPACT: Workaround required (use explicit Type.method() syntax)
:STATUS: Open
:END:

*** Description
When a nested function (defined inside a proc) calls itself recursively, UFCS method
resolution fails to find the return type. This prevents using `.add()`, `.sub()`, etc.
on the recursive call's result.

*** Example
#+BEGIN_SRC til
test := proc() {
    // This FAILS - UFCS can't resolve .add() on fib() result
    fib := func(n: I64) returns I64 {
        if lt(n, 2) { return n }
        return fib(n.sub(1)).add(fib(n.sub(2)))  // ERROR: Undefined symbol 'add'
    }

    // This WORKS - explicit I64.add() bypasses UFCS resolution
    fib_ok := func(n: I64) returns I64 {
        if lt(n, 2) { return n }
        return I64.add(fib_ok(n.sub(1)), fib_ok(n.sub(2)))  // OK
    }
}
#+END_SRC

*** Root Cause
UFCS resolution needs to know the return type of `fib(...)` to find the `.add()` method.
For recursive calls inside the function being defined, the function's signature may not
be fully registered in the scope at the time of UFCS resolution.

Non-recursive nested functions work fine because their definitions are complete before
their results are used with UFCS.

*** Workaround
Use explicit `I64.add(a, b)` syntax instead of `a.add(b)` when chaining methods on
recursive nested function results.

*** Note
This bug was exposed when moving `add`, `sub`, `mul`, `div` inside the I64 struct.
Previously these were global ext_funcs that didn't need UFCS resolution.

** Bug #118: Unreachable code error message should clarify catch blocks are statements
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Developer confusion, especially for LLMs and those from try/catch languages
:STATUS: Open
:END:

*** Description
The unreachable code error message doesn't clarify that catch blocks are also subject
to this rule. Developers (and LLMs) coming from languages with try/catch syntax often
place catch blocks after return statements, expecting them to work like Java/Python/C++
where catch is syntactically bound to try and doesn't need to be "reached".

In TIL, catch is a statement like any other - it must be reachable in normal control
flow. It catches errors from statements above it, but only if execution can reach
the catch line itself.

*** Example of the confusion
#+BEGIN_SRC til
// WRONG - catch is unreachable (common mistake)
clone := func(self: Array) returns Array {
    cloned.ptr = malloc(total_bytes)
    return cloned
    catch (err: BadAlloc) { panic(...) }  // Dead code!
}

// CORRECT - catch before return
clone := func(self: Array) returns Array {
    cloned.ptr = malloc(total_bytes)
    catch (err: BadAlloc) { panic(...) }  // Reachable
    return cloned
}
#+END_SRC

*** Proposed fix
Add clarification to the unreachable code error message, something like:
"unreachable code after return/throw. Note: this includes catch blocks - in TIL,
catch is a statement that must be reachable, not a construct bound to try."

** Bug #114: ScopeStack lookup functions leak memory by copying entire ScopeFrame
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Memory leak in self-hosted interpreter, grows with scope depth and lookup frequency
:STATUS: Open - needs solution design
:END:

*** Description
TIL's ScopeStack lookup functions (lookup_var, lookup_symbol, lookup_func, lookup_enum,
lookup_struct, is_closure_capture, all_structs, etc.) copy entire ScopeFrame objects
when iterating through frames:

#+BEGIN_SRC til
// Current pattern (leaks memory)
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()   // Allocates new ScopeFrame
    self.frames.get(i, frame)   // Copies ALL fields including 5 Maps

    if frame.arena_index.contains_key(name) {
        // ...
    }
    // frame goes out of scope - Maps inside are NOT freed
}
#+END_SRC

ScopeFrame contains 5 Maps (arena_index, symbols, funcs, enums, structs). Each copy
duplicates the Map struct which holds pointers to heap-allocated Vec data. When the
copied frame goes out of scope, those Map copies leak because TIL has no automatic
destructor/drop mechanism.

*** Why Rust Doesn't Have This Problem
Rust iterates by reference, not by copy:
#+BEGIN_SRC rust
for frame in self.frames.iter().rev() {
    if let Some(offset) = frame.arena_index.get(name) {
        // frame is &ScopeFrame - no copy, no allocation
    }
}
#+END_SRC

*** Potential Solutions

**** Option A: Return references from Vec.get (language change)
Change Vec.get to return a reference/pointer instead of copying:
#+BEGIN_SRC til
// Hypothetical - would require language support for references
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame := self.frames.get_ref(i)  // Returns reference, no copy
    if frame.arena_index.contains_key(name) { ... }
}
#+END_SRC
Pros: Matches Rust semantics, clean syntax
Cons: Major language change, needs reference/borrow system

**** Option B: Vec.get_ptr + manual offset calculation (branch approach)
Use pointer arithmetic to access fields without copying entire struct:
#+BEGIN_SRC til
structs_offset := mul(size_of(Map), 4)
mut scratch_map := Map.new(Str, SStructDef)
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame_ptr := self.frames.get_ptr(i)
    structs_ptr := add(frame_ptr, structs_offset)
    memcpy(to_ptr(scratch_map), structs_ptr, size_of(Map))
    if scratch_map.contains_key(name) { ... }
}
#+END_SRC
Pros: Works now, fixes leak
Cons: Fragile (hardcoded offsets), diverges from Rust significantly, error-prone

**** Option C: Existence-check methods (has_struct, has_symbol, etc.)
Add cheap existence-check methods that avoid full struct retrieval:
#+BEGIN_SRC til
// Instead of:
_ := self.scope_stack.lookup_struct(name)  // Copies SStructDef
catch { }

// Use:
if self.scope_stack.has_struct(name) { ... }  // Just checks existence
#+END_SRC
Pros: Simple, matches Rust .is_some() pattern, no language changes
Cons: Only helps existence checks (~40 places), doesn't fix cases needing the value

**** Option D: Explicit free/drop for complex types
Add manual memory management:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    // ... use frame ...
    frame.free()  // Explicitly free copied Maps
}
#+END_SRC
Pros: Explicit, controllable
Cons: Error-prone, verbose, easy to forget

**** Option E: For-in loop over Vec doesn't copy (compiler optimization)
Make the compiler smart enough to not copy when iterating:
#+BEGIN_SRC til
for frame: ScopeFrame in self.frames.reverse() {
    // frame is a reference, not a copy (compiler detects loop pattern)
}
#+END_SRC
Pros: Clean syntax, no code changes needed
Cons: Significant compiler work, may be complex to implement correctly

**** Option F: ASAP destruction (Mojo-style automatic delete on last use)
Compiler inserts destructor calls automatically when a value is last used:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    if frame.arena_index.contains_key(name) {
        // ...
    }
    // Compiler detects frame's last use and inserts: frame.__del__()
}
#+END_SRC
Pros: Automatic, no manual memory management, matches Mojo semantics
Cons: Requires:
  - Destructor support (__del__ methods on types with heap data)
  - Liveness analysis in compiler to detect last use
  - Careful handling of control flow (returns, throws, branches)
  - May interact poorly with references if added later

This is how Mojo handles memory: values are destroyed as soon as they're last used,
not at end of scope. This enables deterministic destruction without garbage collection.

*** Recommended Approach
Start with Option C (has_* methods) as immediate mitigation - it's simple, matches Rust,
and fixes ~40 call sites. For long-term, evaluate:
- Option F (ASAP destruction) - most automatic, Mojo-proven approach
- Option A (references) - matches Rust semantics closely
- Option E (smart for-in) - transparent optimization

*** Related Work
- Branch ~claude/detect-ccodegen-translation-diffs-A08OT~ attempted Option B
- That branch was not merged due to Rust/TIL divergence concerns
- ~has_struct~ method was prototyped on that branch

** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #112: Map uses O(n) linear scan instead of hash lookup
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Major performance bottleneck - self-hosted interpreter 2.7x slower than Rust
:STATUS: Blocked by Bug #113
:END:

*** BLOCKER: Bug #113
HashMap implementation was attempted but is blocked by Bug #113 (self-hosted
interpreter fails with "symbol 'msg' not found"). The HashMap code itself works
correctly with rstil, but when the self-hosted interpreter (bin/til) is rebuilt
with the new Map, tests fail due to Bug #113. Must fix Bug #113 first.

*** Attempted Implementation (branch wip_112)
Full HashMap implementation exists on branch ~wip_112~:
- Hash table with separate chaining (buckets + nexts arrays)
- ~hash_key()~ using ~Str.hash()~ for string keys, FNV-1a for others
- ~hash_lookup()~ for O(1) average key lookup
- Same API preserved (same throws and returns)
- All rstil tests pass, til_interpreted tests fail due to Bug #113

*** Description
The ~Map~ type in ~src/std/map.til~ uses O(n) linear scan for all operations (get,
set, contains_key, insert). Rust uses ~HashMap~ with O(1) average lookup. This is
the primary reason the TIL self-hosted interpreter is ~2.7x slower than rstil.

*** Current Implementation (O(n))
#+BEGIN_SRC til
// src/std/map.til lines 58-86
while lt(i, self._size) {
    // Linear scan through ALL keys for every lookup
    if Str.eq(self.key_type_name, "Str") {
        // String comparison for each key
    }
    i = add(i, 1)
}
#+END_SRC

*** Impact Analysis
- ~ScopeFrame~ uses 4 Maps: arena_index, symbols, funcs, enums
- 227 ~lookup_*~ calls throughout the codebase
- Each lookup scans potentially hundreds of entries
- With nested scopes, lookups iterate through multiple frames
- Result: quadratic behavior in hot paths

*** Fix Strategy (Two Phases)

**** Phase 1: Sorted Vec + Binary Search (O(log n))
- Keep keys sorted on insert
- Use binary search for lookups
- Simpler to implement, no hash function needed
- Good enough for initial improvement

**** Phase 2: Hash Map (O(1) average)
- Implement proper hash table with buckets
- Need hash function for Str keys

*** Hash Function Options (for Phase 2)

| Algorithm | Used By | Speed | Quality | Notes |
|-----------+------------+-------+---------+---------------------------------------|
| FNV-1a | Rust (old) | Fast | Good | Simple, 32/64-bit, good distribution |
| SipHash | Rust | Med | Best | DoS-resistant, cryptographic quality |
| xxHash | Many | Fast | Good | Extremely fast, good for large data |
| MurmurHash3 | Java, etc | Fast | Good | Popular, well-tested |
| wyhash | Go (new) | Fast | Good | Very fast, simple implementation |
| djb2 | Classic | Fast | OK | Very simple, older |

**** Recommended: FNV-1a
- Simple implementation (~10 lines)
- Good distribution for string keys
- Fast enough for interpreter use
- No external dependencies

#+BEGIN_SRC c
// FNV-1a hash (64-bit)
uint64_t fnv1a(const char* str, size_t len) {
    uint64_t hash = 14695981039346656037ULL;  // FNV offset basis
    for (size_t i = 0; i < len; i++) {
        hash ^= (uint8_t)str[i];
        hash *= 1099511628211ULL;  // FNV prime
    }
    return hash;
}
#+END_SRC

*** Implementation Notes
- Bucket count: power of 2 (allows bitwise AND instead of modulo)
- Collision handling: chaining (linked list) or open addressing
- Load factor: resize when > 0.75 full
- For TIL: can use ~ext_proc~ for C hash function, or implement in pure TIL

** Bug #101: Warn/error on unused things
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-01-13
:IMPACT: Code quality, catch dead code
:STATUS: Fixed
:END:

*** Description
Add warnings or errors for unused variables, functions, imports, struct fields, etc.
Currently we rely on rustc to catch these. Once rstil is gone, TIL needs this itself.

*** Implementation
- Error (not warning) for unused local variables and function arguments
- Suppression: prefix with underscore (e.g., ~_unused_var~)
- Tracks usage via ~used_symbols~ HashSet in ScopeStack
- ~mark_symbol_used()~ called when Identifier is checked
- ~get_unused_symbols()~ returns declared-but-unused symbols at function end
- Nested functions: inner usage merges back to outer scope

*** Files Changed
- src/rs/init.rs, src/self/init.til: Added used_symbols, mark_symbol_used, get_unused_symbols
- src/rs/typer.rs, src/self/typer.til: Mark symbols used, check at function end
- Various test and compiler files: Prefixed intentionally unused vars with ~_~

*** Decisions Made
- Error not warning: forces action, matches Go's approach
- Underscore prefix: simple, familiar convention from Python/Rust/Go
- Function-local only: global unused detection is more complex (may be used by other files)
- Nested function propagation: fixes false positives for outer vars used by inner functions

** Bug #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [ ] Issue #82: make.til - Replace Makefile with TIL
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [ ] Issue #91: First-Class Functions
- [ ] Bug #92: Range loops should allow explicit iterator type annotation
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Partial fix is sufficient. Shadowing detection is in both Rust and TIL
  typers, all existing code renamed. Final design decision (allow vs disallow)
  can wait until after #100.

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (2026-01-13)
Audit of generated C code shows these warning types:

| Type                         | Priority | Notes                                      |
|------------------------------+----------+--------------------------------------------|
| -Wdangling-pointer           | High     | Statement expressions return &local_var    |
| -Wreturn-type                | High     | Control reaches end of non-void function   |
| -Wincompatible-pointer-types | Medium   | Vec_push receives typed* instead of void** |
| -Wunused-variable            | Low      | Generated temp vars not always used        |
| -Wunused-but-set-variable    | Low      | Similar to above                           |
| -Wunused-label               | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           | Low      | ext.c has unused _err params               |

*** Fix Strategy (Incremental)
Current state: -Werror enabled with specific warning suppressions.

1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Once stable, switch to ~-Wall -Wextra -Werror~

*** Current Warning Suppressions (target.rs/til)
- ~-Wno-return-type~: clang is stricter than gcc about missing returns in all paths

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [ ] Step 3d: Enable and fix -Wdangling-pointer
- [ ] Step 3e: Enable and fix -Wreturn-type
- [ ] Step 3f: Enable and fix -Wunused-variable
- [ ] Step 3g: Enable and fix -Wunused-but-set-variable
- [ ] Step 3h: Enable and fix -Wunused-label
- [ ] Step 3i: Enable and fix -Wunused-parameter
- [ ] Step 3j: Enable and fix -Wshadow
- [ ] Step 4: Switch to -Wall -Wextra -Werror

** Bug #98: ext_proc errors should throw specific error types instead of panicking
:PROPERTIES:
:DISCOVERED: 2026-01-10
:IMPACT: ext_proc failures (writefile, readfile, etc.) panic instead of throwing catchable errors
:STATUS: Open
:END:

*** Description
Currently, ext_proc functions like writefile, readfile, etc. either:
- Rust (ext.rs): Return Err() which bubbles up and crashes
- C (ext.c): Panic with fprintf+exit

Instead, they should throw specific TIL error types (like WriteError, ReadError) that
can be caught with TIL's catch blocks, similar to how AllocError works for malloc.

*** Example (future behavior)
#+BEGIN_SRC til
write_err := writefile(path, contents)
catch (err: WriteError) {
    println("Write failed: ", err.msg)
}
#+END_SRC

*** Current Workaround
Check return values manually (for functions that return error strings) or let the
program crash on I/O failures.

** Bug #97: Disallow variable shadowing - type checker should error "X already declared"
:PROPERTIES:
:DISCOVERED: 2026-01-10
:IMPACT: Variable shadowing causes C codegen to mix up types, generating broken C code
:STATUS: Partially Fixed
:END:

*** Description
TIL's C code generator doesn't properly handle variable shadowing (reusing the same
variable name in nested scopes). When Rust code uses shadowing (like ~let arg = ...~
multiple times), the translated TIL code reuses variable names, but the C codegen
assigns all shadowed variables to a single C variable, causing type conflicts.

*** Example
TIL code with shadowing:
#+BEGIN_SRC til
mut arg := Declaration()  // Outer scope
// ... use arg ...
mut arg := Expr()         // Inner scope - shadows outer arg
// ... use arg ...
#+END_SRC

Generated C code (BROKEN):
#+BEGIN_SRC c
til_Declaration til_arg;  // Declared once as Declaration
// ...
til_arg = (til_Expr){...};  // ERROR: assigning Expr to Declaration variable
#+END_SRC

*** Root Cause
The C codegen hoists all variable declarations to function scope and reuses the
same C variable for all TIL variables with the same name, even when they're
shadowed in different scopes.

*** Existing Checks (that aren't catching this)
There are already 2 "already declared" checks in src/rs/init.rs:

1. Line 165 in ~declare_var_in_arena()~: Checks ~current_frame.arena_index~ for duplicates
   #+BEGIN_SRC rust
   if name != "_" && current_frame.arena_index.contains_key(&name) {
       return Err(format!("Variable '{}' already declared in this scope", name));
   }
   #+END_SRC

2. Line 1022 in ~init_context()~: Checks if func/symbol already exists using ~lookup_symbol()~
   #+BEGIN_SRC rust
   if decl.name != "_" && (context.scope_stack.lookup_func(&decl.name).is_some() ||
                           context.scope_stack.lookup_symbol(&decl.name).is_some()) {
       errors.push(e.error(&context.path, "init", &format!("'{}' already declared.", decl.name)));
   }
   #+END_SRC

These checks aren't catching the shadowing cases that cause C codegen bugs.

*Why they don't catch nested scope shadowing:*
- ~init_context()~ only processes frame 0 (top-level/global scope of files)
- It only pushes 2 scope types: Global and Function (no Block scopes for if/while/for)
- Shadowing bugs occur in nested blocks INSIDE functions, which init never processes
- The typer processes nested scopes, but has no "already declared" check for current frame

*** Solution Attempts

*Attempt 1: Check in typer's check_declaration() function*

Added new helper method in ~src/rs/init.rs~ (ScopeStack impl):
#+BEGIN_SRC rust
pub fn lookup_symbol_current_frame(&self, name: &str) -> Option<&SymbolInfo> {
    if let Some(current_frame) = self.frames.last() {
        current_frame.symbols.get(name)
    } else {
        None
    }
}
#+END_SRC

Added check in ~check_declaration()~ function in ~src/rs/typer.rs~, after extracting
inner_e and before the existing ~lookup_symbol().is_none()~ check:
#+BEGIN_SRC rust
// Bug #97: Disallow variable redeclaration in same scope
// Skip check for "_" - it's special for discarding values
// Skip frame 0 - already checked by init_context
if decl.name != "_" && context.scope_stack.frames.len() > 1 {
    if context.scope_stack.lookup_symbol_current_frame(&decl.name).is_some() {
        errors.push(e.error(&context.path, "type", &format!("Variable '{}' already declared in this scope", decl.name)));
        return errors;
    }
}
#+END_SRC

*Result:* Check worked but triggered false positives on 43 legitimate declarations. Examples:
- ~src/core/vec.til:286~: "Variable 'elem' already declared in this scope"
- ~src/core/vec.til:303-304~: "Variable 'prev' already declared in this scope", "Variable 'curr' already declared"
- ~src/core/str.til:28-29~: "Variable 'self_byte' already declared", "Variable 'other_byte' already declared"

*Problems:*
1. These are legitimate declarations inside for-in loop bodies, not actual shadowing bugs
2. Each variable is only declared once in the source code (e.g., line 303: ~mut prev := ""~)
3. The typer only walks code once during type checking, doesn't execute loop iterations
4. Yet the check sees them as "already declared in this scope"

*Mystery:* Why is ~check_declaration()~ being called multiple times for the same
declaration, or why does ~lookup_symbol_current_frame()~ find the symbol already
declared when it should be the first time seeing it?

Need to investigate:
- Does catch block processing cause multiple passes?
- Does ~check_types_with_context()~ get called multiple times on the same Body?
- Is there something about how for-in bodies are type-checked that repeats?

This matches CLAUDE.md guidance: "AVOID variable shadowing in Rust - TIL doesn't
support shadowing the same way" (Issue #66 in future.org).

*** Reproduction
Test file: ~src/test/shadowing.til~ (not in tests.til until fixed)

#+BEGIN_SRC til
mode test

test_shadowing_different_types := proc() {
    mut x := 1        // I64
    if true {
        mut x := "hi" // Str - different type, C will fail to compile
    }
}
test_shadowing_different_types()
#+END_SRC

*Results:*
- ~rstil interpret src/test/shadowing.til~ - passes (exit 0), interpreter allows shadowing
- ~rstil run src/test/shadowing.til~ - fails (exit 1), C compilation error:
#+BEGIN_SRC
gen/c/test/shadowing.c:64:17: error: incompatible types when assigning to type 'til_I64' from type 'til_Str'
   64 |         til_x = ((til_Str){(til_I64)"hi", 2});
#+END_SRC

This demonstrates the bug: C codegen reuses the outer variable ~til_x~ (declared as I64)
instead of creating a new variable for the inner shadowing declaration.

*** Workaround
Manually rename shadowed variables to unique names (e.g., ~arg1~, ~arg2~, or
~outer_arg~, ~inner_arg~) in both TIL and Rust code to maintain consistency.

*** Design Options

This is a design decision, not just a bug fix. Options:

*Option A: Minimal - only disallow what C disallows*
- Disallow shadowing with different types in same function (what breaks C codegen)
- Allow same-type shadowing (C handles this fine)
- Least restrictive, matches C's actual limitations
- Typer cost: check type matches if name exists in any enclosing scope

*Option B: Strict - disallow all shadowing in same scope*
- Disallow any redeclaration in the same block scope, regardless of type
- More restrictive than C (C allows same-type shadowing in nested blocks)
- Typer cost: check name doesn't exist in current frame only
- Codegen benefit: can keep simple variable hoisting, no renaming needed

*Option C: Very strict - disallow all shadowing in entire function*
- Disallow any reuse of variable name anywhere in a function
- Most restrictive, prevents all shadowing confusion
- Typer cost: check name doesn't exist in any frame
- Codegen benefit: maximum simplicity

*Option D: Permissive like Rust - allow all shadowing*
- Allow shadowing anywhere, like Rust does
- Requires codegen to rename variables (e.g., ~x~ -> ~x_1~, ~x_2~)
- Typer cost: track shadow depth per variable
- Codegen cost: variable renaming logic, scope tracking

*** Two-Step Fix Plan

*Step 1 (initial):* Check in ccodegen, not typer - disallow ALL shadowing in function
- Keep ~declared_vars~ as simple ~HashSet<String>~ (no type tracking needed)
- If variable name already exists when declaring, emit TIL error
- Stricter than necessary (blocks same-type shadowing too) but much simpler
- Avoids the typer false positive mystery entirely
- Error message: "variable 'x' already declared in this function"

*Step 2 (final):* Implement the chosen design option in typer
- May require more sophisticated scope tracking
- Deferred until design is finalized (needs more examples to decide)

*Attempt 2: Check in ccodegen at hoist points*

Tried the "initial solution" approach: check in ccodegen's hoisting code, error on
ANY redeclaration using simple ~HashSet<String>~.

Added check at hoist points (emit_if, emit_while, emit_switch, emit_stmts catch):
#+BEGIN_SRC rust
if ctx.declared_vars.contains(&c_var_name) {
    return Err("Variable 'x' already declared in this function (shadowing not allowed)");
}
#+END_SRC

*Result:* Broke legitimate code patterns. Examples:
- ~for arg in a {}; for arg in b {}~ - same variable reused in sibling loops
- Variables declared in both if and else branches

*Root cause:* Hoisting makes ALL variables function-scoped in C. When we hoist from
sibling blocks (two loops, if/else branches), they share the same ~declared_vars~.
The check can't distinguish:
1. *Real shadowing:* outer variable shadowed by inner block declaration
2. *Legitimate reuse:* same variable used in multiple sibling blocks

*Approaches considered:*
- Track which vars were "hoisted" vs "top-level declared" - adds complexity
- Track types with HashMap, only error on type mismatch - also adds complexity
- Both defeated the goal of "simpler than type tracking"

*** Lessons Learned

The "simple HashSet" approach doesn't work because hoisting fundamentally changes
the problem. In TIL source, variables have block scope. In generated C, all
variables are hoisted to function scope. This means:

1. Sibling blocks (loops, if/else) legitimately share hoisted variables
2. We can't just check "name exists" - we need to know WHERE it was declared
3. Some complexity is unavoidable to distinguish shadowing from reuse

*** Decision

Final solution: TBD (needs more examples, possibly look at Haskell approach)
Initial solution: Deferred - the "simple" approach turned out to be not simple

*** Partial Fix (2026-01-11)

*What was done:*

1. Added shadowing detection in Rust typer (src/rs/typer.rs, src/rs/init.rs):
   - Added ~function_locals: HashSet<(String, usize, usize)>~ to ScopeStack
   - Added helper methods: ~is_inside_function~, ~is_shadowing_in_function~,
     ~is_already_processed~, ~register_function_local~
   - Added check in ~check_declaration()~ that errors on shadowing within functions
   - Tracks by (name, line, col) to handle AST duplication from for-in desugaring

2. Renamed all shadowed variables in TIL source files:
   - interpreter.til: ~270 renamed variables
   - ccodegen.til: Numerous renames (fcall_arg, hoisted_arg, ref_arg, etc.)
   - typer.til: Variable renames in switch cases and loops
   - precomp.til, scavenger.til: Context-specific prefixes added
   - builder.til, eval_arena.til, init.til: Various shadow fixes
   - Core files (str.til, set.til, list.til, map.til): Minor renames
   - enums.til test: Renamed name_copy to blue_name_copy

3. All 136 tests pass with ~make benchmark~

*What's still pending:*

1. Final design decision: TBD (see Design Options section above)
   - Current solution: Option C (disallow all shadowing within a function)
   - Possible final solutions:
     - Option A: Only disallow different-type shadowing (least restrictive)
     - Option D: Allow all shadowing like Rust, rename variables in C codegen (e.g., x -> x_1, x_2)

2. Port TIL variable renames to Rust for consistency: DONE
   - ccodegen.til -> ccodegen.rs: DONE (added nh_, emit_, else_, loop_, ntv_ prefixes)
   - init.til -> init.rs: DONE (added contextual prefixes)
   - typer.til -> typer.rs: DONE (added idx, nested, exh_, field_ prefixes)
   - lexer.til -> lexer.rs: DONE (err_token, peek_idx renames)
   - scavenger.til -> scavenger.rs: NOT NEEDED (Rust uses Option patterns)
   - precomp.til -> precomp.rs: NOT NEEDED (Rust uses block scoping)
   - interpreter.til -> interpreter.rs: NOT NEEDED (Rust uses match arms with separate scopes)
   - eval_arena.til -> eval_arena.rs: ALREADY HAD (existing_ prefixes)
   - builder.til -> builder.rs: ALREADY HAD (core_saved_path, mode_saved_path, etc.)
   - parser.til -> parser.rs: NOT NEEDED (Rust uses derive Clone, no manual clones)
   - mode.til -> mode.rs: NOT NEEDED (Rust uses inline vec![] literals)

   NOTE: Many TIL renames aren't needed in Rust because:
   - Rust supports proper block scoping (variables in match arms, if blocks are independent)
   - Rust uses Option<T> patterns instead of TIL's "found_X = true; catch" patterns
   - TIL needs unique names because C codegen hoists all variables to function scope

3. Port Rust shadowing detection to TIL for consistency: DONE
   - Added function_locals field to ScopeStack in init.til
   - Added helper methods to init.til (is_inside_function, is_shadowing_in_function,
     is_already_processed, register_function_local)
   - Added check in check_declaration() in typer.til
   - Added function_locals.clear() at start of check_func_proc_types() in typer.til

** Bug #96: Unreachable code error when return is before catch in early-return pattern
:PROPERTIES:
:DISCOVERED: 2026-01-09
:IMPACT: Cannot translate Rust's if-let-some early-return pattern directly
:STATUS: Open
:END:

*** Description
When translating Rust's ~if let Some(x) = map.get(key) { use(x); return; }~ pattern,
the natural TIL translation puts a ~return~ before the catch block, causing an
"unreachable code" error because the compiler doesn't understand that the catch
is reachable via the throw path.

*** Example
Rust:
#+BEGIN_SRC rust
if let Some(temp_var) = ctx.hoisted_exprs.get(&expr_addr) {
    output.push_str(temp_var);
    return Ok(());
}
// continue with normal processing...
#+END_SRC

TIL (BROKEN - unreachable code error):
#+BEGIN_SRC til
ctx.hoisted_exprs.get(expr_addr, temp_var)
output.push_str(temp_var)
return  // ERROR: makes catch unreachable
catch (err: KeyNotFoundError) {
    // Not found, continue
}
// continue with normal processing...
#+END_SRC

*** Workaround
Wrap the success-case code in ~if true { }~. This makes the catch reachable
because the compiler sees the return as conditional:

#+BEGIN_SRC til
ctx.hoisted_exprs.get(expr_addr, temp_var)
if true {  // TODO Bug #96 workaround
    output.push_str(temp_var)
    return
}
catch (err: KeyNotFoundError) {
    // Not found, continue
}
// continue with normal processing...
#+END_SRC

*** Proper Fix
The compiler should recognize that catch blocks are reachable via the throw path,
even when there's a return statement before them in the textual order.

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-01-13)
| Mode            | Result              | Time  |
|-----------------+---------------------+-------|
| rstil interpret | pass                | 2.3s  |
| rstil run       | pass                | 5.2s  |
| til interpret   | pass                | 53s   |
| til run         | OOM killed (exit 137) | ~61s  |

~til run~ gets SIGKILL from OOM killer after ~61s (with 10s sys time indicating
memory pressure). The til ccodegen uses excessive memory when processing
bug47.til which imports self.typer (most of the compiler).

Note: til is ~20x slower than rstil for interpretation, but the real issue
is memory consumption during ccodegen causing OOM.

*** Current Warnings (2026-01-13)
1654 total warnings when compiling with ~gcc -Wall -Wextra~:

| Count | Type                        | Severity |
|-------+-----------------------------+----------|
|   933 | -Wunused-variable           | Low      |
|   318 | -Wdangling-pointer          | High     |
|   195 | -Wincompatible-pointer-types | Medium   |
|   135 | -Wunused-but-set-variable   | Low      |
|    66 | -Wunused-label              | Low      |
|     5 | -Wunused-parameter          | Low      |
|     1 | -Wreturn-type               | High     |
|     1 | null character in literal   | Low      |

**** Dangling Pointer (318 occurrences)
Statement expressions return pointers to local variables that go out of scope:
#+BEGIN_SRC c
// Generated code pattern:
if (til_not(({ til_Bool _tmp = til_U8_eq(&a, &b); &_tmp; })).data) { ... }
//                                                 ^^^^^
// _tmp goes out of scope, pointer dangles
#+END_SRC

**** Incompatible Pointer Types (195 occurrences)
Vec_push expects ~void**~ but receives typed pointers:
#+BEGIN_SRC c
til_Vec_push(&_err, &vec, &_tmp_str);  // _tmp_str is til_Str*
#+END_SRC

**** Return Type (1 occurrence)
Function ~til_get_value_type~ at line 13360 - control reaches end without return.

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [ ] Fix til ccodegen memory usage (high priority - OOM on large files)
- [ ] Fix dangling pointer pattern in ccodegen (high priority)
- [ ] Fix missing return statement (high priority)
- [ ] Add casts for Vec_push calls or specialize per type
- [ ] Consider which unused-* warnings to fix vs suppress

** Bug #92: Range loops should allow explicit iterator type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Type safety, code clarity
:STATUS: Open - attempted approach failed
:END:

*** Description
Range loops (e.g., ~for i in 0..100~) infer the iterator type automatically.
However, there's no way to explicitly specify the iterator type when desired
for clarity or type safety.

*** Failed Attempt (2026-01-08): Unified iteration via I64Range struct

**** Approach
Tried to unify range and collection iteration by creating an I64Range struct
with len()/get() methods, allowing range loops to use the same desugaring
path as collection loops (for-in over Vec, Array, etc.):

- Created ~src/core/range.til~ with I64Range struct
- Parser changes: removed range-to-while desugaring, created ForIn nodes
- Precomp changes: wrapped Range expressions with I64Range(start=X, end=Y)
- Range loops would then use standard len()/get() desugaring

**** Why It Failed
The I64Range.get() method throws IndexOutOfBoundsError. The for-in desugaring
generates a catch block for this error that panics. This catch block contains
a variable ~til_err~.

When C code is generated, all local variables are hoisted to function scope.
If a function has multiple for-in loops over ranges, each generates its own
catch block with ~til_err~, causing redeclaration errors in C.

Additionally, the existing parser-based range desugaring was simpler and
didn't require any error handling (it used direct increment/decrement without
bounds checking on each iteration).

**** Key Diff Insight (from bootstrap/til.c)
OLD (parser desugaring):
#+BEGIN_SRC c
til_I64 til_i = 0;
while (til_lt(&til_i, &end).data) {
    // body
    til_I64_inc(&til_i);
}
#+END_SRC

NEW (I64Range approach):
#+BEGIN_SRC c
til_I64 _for_i_func_0 = 0;
til_I64 til_i;
while (til_lt(&_for_i_func_0, &(til_I64){til_I64Range_len(...)}).data) {
    til_IndexOutOfBoundsError _thrown_...;
    til_I64Range_get(...);  // throws
    if (0) { _catch_...:
        til_IndexOutOfBoundsError til_err = ...;  // PROBLEM: hoisted
        til_panic(...);
    }
    // body
}
#+END_SRC

The ~til_err~ variable gets hoisted, and multiple catch blocks in the same
function cause redeclaration errors.

**** Code: I64Range struct (src/core/range.til)
#+BEGIN_SRC til
mode lib

// I64Range struct for unified iteration over numeric ranges
// Used by for-in loops: `for i in 0..10` becomes iteration over I64Range(start=0, end=10)
// Named I64Range (not Range) to prepare for future template support: Range<I64>, Range<U8>, etc.

I64Range := struct {
    mut start: I64 = 0
    mut end: I64 = 0

    // Required by collection interface
    size := func(self: I64Range) returns I64 {
        return 16  // Two I64 fields (8 bytes each)
    }

    len := func(self: I64Range) returns I64 {
        if self.end.gteq(self.start) {
            return self.end.sub(self.start)
        }
        return self.start.sub(self.end)
    }

    get := proc(self: I64Range, index: I64, mut out: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self.len()) {
            throw IndexOutOfBoundsError(msg="I64Range.get: index out of bounds")
        }
        if self.end.gteq(self.start) {
            out = self.start.add(index)  // Forward: 0..10 -> 0,1,2...
        } else {
            out = self.start.sub(index)  // Reverse: 10..0 -> 10,9,8...
        }
    }
}
#+END_SRC

**** Code: Precomp change to wrap Range in I64Range (src/rs/precomp.rs)
#+BEGIN_SRC rust
// In precomp_forin(), after getting raw_collection_expr:

// Bug #92: If collection is a Range expression, wrap it in I64Range(start=..., end=...)
// This allows range loops to use the same len()/get() desugaring as collections
let collection_expr = if let NodeType::Range = &raw_collection_expr.node_type {
    let start_expr = raw_collection_expr.get(0)?.clone();
    let end_expr = raw_collection_expr.get(1)?.clone();
    // Build: I64Range(start=<start>, end=<end>)
    Expr::new_explicit(
        NodeType::FCall,
        vec![
            Expr::new_explicit(NodeType::Identifier("I64Range".to_string()), vec![], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("start".to_string()), vec![start_expr], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("end".to_string()), vec![end_expr], e.line, e.col),
        ],
        e.line,
        e.col,
    )
} else {
    raw_collection_expr
};
#+END_SRC

**** Alternative Approaches to Consider
1. **Non-throwing Range.get()**: Return a sentinel/default instead of throwing.
   But this breaks the collection interface contract.

2. **Special-case ranges**: Keep ranges separate from collections. They're
   fundamentally different (arithmetic progression vs stored elements).

3. **Fix C hoisting**: Track catch block error variables specially to avoid
   redeclaration. Complex.

4. **Keep current parser desugaring**: The simplest approach. Range loops
   work correctly as-is. Focus on adding type annotation support without
   changing the desugaring mechanism.

*** What's Still Needed
- Type annotation syntax: ~for i: I64 in 0..10~ (parser change only)
- No need to unify with collection iteration for this feature

** Bug #90: Parser requires semicolon for bodyless func/proc definitions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Syntax ergonomics
:STATUS: Partially Fixed
:END:

*** Description
The parser cannot determine where a function/proc definition ends when there
is no body. Previously required a semicolon as a terminator.

*** Initial Fix (2026-01-07)
Semicolons are now completely optional - skipped by the lexer as whitespace.
~ext_func~ and ~ext_proc~ require an empty body ~{}~ instead of a semicolon.

*** Final Solution (pending)
Make the parser smart enough to not require empty bodies at all.
Then remove all ~{}~ from ext_func/ext_proc declarations.

*** Examples
#+BEGIN_SRC til
// Has body - no semicolon needed
add := func(a: I64, b: I64) returns I64 {
    return a.add(b)
}

// No body (ext) - uses empty body {}
// From src/core/print.til:
single_print := ext_proc(s: Str) {}
print_flush  := ext_proc() {}

// Inside struct definitions - also uses {}
// From src/std/meta.til:
Introspection := struct {
    has_const := ext_func(type_name: Str, const_name: Str) returns Bool {}
}

// Semicolons are now completely optional everywhere:
;;;;;;;;;;;;;;;;;;;;  // Just whitespace, ignored
#+END_SRC

*** Changes Made

*Lexer changes:*
- Removed ~Semicolon~ and ~DoubleSemicolon~ token types
- Lexer now skips any sequence of semicolons (treated as whitespace)

*Parser changes:*
- Removed ~TokenType::Semicolon~ from ~func_proc_returns()~ and ~func_proc_throws()~
- Removed ~do_parse_body~ parameter from ~parse_func_proc_definition()~
- Always parse body, error if non-empty for ext_func/ext_proc
- Removed dead code for semicolon handling in ~parse_switch_statement()~ and ~parse_body()~
- Removed ~go_back()~ method (no longer needed)

*Test changes:*
- Added semicolon regression test in src/test/flow.til
- Removed ~test_lexer_go_back~ test (method removed)

*** Future Enhancement (Step 3)
Context-aware lookahead could allow:
#+BEGIN_SRC til
single_print := ext_proc(s: Str)  // Just works without {}
#+END_SRC
Parser would infer end of definition from context. Post-self-hosting enhancement.

*** Files Changed
- src/rs/lexer.rs, src/self/lexer.til
- src/rs/parser.rs, src/self/parser.til
- src/std/meta.til (changed ; to {} for struct ext_funcs)
- src/test/flow.til (added regression test)
- src/test/test_lexer.til (removed go_back test)

** Bug #89: Constant folding only works at global scope
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Performance, macro implementation
:STATUS: Active
:END:

*** Description
Pure function calls with all compile-time known arguments are only constant
folded at global scope. Inside function bodies, they are not folded even when
all arguments are literals.

*** Example
#+BEGIN_SRC til
double := func(x: I64) returns I64 { return x.mul(2) }

// Global scope - folded to literal 10
global_result := double(5)

test := proc() {
    // Inside function - NOT folded, calls double() at runtime
    inner_result := double(10)
}
#+END_SRC

Generated C shows:
- ~til_global_result = 10~ (folded)
- ~til_inner_result = til_double(...)~ (not folded)

*** Location
~precomp_expr()~ in src/rs/precomp.rs / src/self/precomp.til has:
#+BEGIN_SRC til
at_global_scope := context.scope_stack.frames.len().eq(1)
if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
    const_folded = eval_comptime(context, const_folded)
}
#+END_SRC

The ~at_global_scope~ check should be removed.

*** Impact on Issue #88 (Macros)
This bug blocks proper macro implementation. Macros should be evaluated at
compile time regardless of where they are called.

*** Why the Fix is Safe

The ~at_global_scope~ check was added for Bug #41 to prevent double output from
functions with side effects. However, this is overly conservative because:

1. *~is_proc()~ correctly identifies side effects*: The type system guarantees
   that ~func~ cannot call ~proc~ (enforced by typer). Only ~proc~ can call
   ~ext_proc~, which is where actual side effects (I/O, memory allocation) live.

2. *Trust the type system*: If ~is_proc()~ returns false, the function is pure.
   The ~is_comptime_evaluable()~ check already calls ~is_proc()~ and rejects
   procs from folding.

3. *liba/pura exception is a debugging hack*: These modes allow ~func~ to call
   ~println~ as a convenience for debugging pure/lib code. If such funcs get
   evaluated twice (once at compile-time, once at runtime), that's an acceptable
   consequence of using the debugging modes.

4. *User responsibility*: If someone declares an ~ext_func~ that actually has
   side effects (instead of ~ext_proc~), that's the user's or mode designer's
   fault. The type system is correct; misuse is not our problem.

*** Future Enhancement
Add warnings when ~proc~ is used but ~func~ would suffice. Using ~proc~
unnecessarily causes a cascade effect - anything calling it must also be ~proc~
or in a special mode. This means users miss constant folding optimizations for
entire call chains.

*** Implementation Attempt (2026-01-07)

Tried removing ~at_global_scope~ checks from three locations. Result: build fails.

**** Three Locations with at_global_scope Check

1. *FCall folding* in ~precomp_expr()~ (precomp.rs line 229-235, precomp.til line 301-307):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // Only fold at global scope - inside function definitions, values from other
   // modules may not be available yet (import ordering). Interpreter doesn't
   // evaluate function bodies during import either.
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope && is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects
   // via the type system (func cannot call proc, only proc can call ext_proc).
   if is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

2. *Primitive storage* (I64/U8/Str) in ~precomp_declaration()~ (precomp.rs line 958-973, precomp.til line 1174-1191):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // Only do this at global scope - inside function bodies, evaluating could cause side effects
   // to run at compile time AND runtime (e.g., print_debug func in mode liba).
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope {
       if let ValueType::TCustom(ref custom_type_name) = &value_type {
           match custom_type_name.as_str() {
               "I64" | "U8" | "Str" => {
                   if is_comptime_evaluable(context, &new_params[0]) {
                       let inner_e = &new_params[0];
                       let result = eval_expr(context, inner_e)?;
                       if !result.is_throw {
                           EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                       }
                   }
               },
               _ => {},
           }
       }
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects.
   if let ValueType::TCustom(ref custom_type_name) = &value_type {
       match custom_type_name.as_str() {
           "I64" | "U8" | "Str" => {
               if is_comptime_evaluable(context, &new_params[0]) {
                   let inner_e = &new_params[0];
                   let result = eval_expr(context, inner_e)?;
                   if !result.is_throw {
                       EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                   }
               }
           },
           _ => {},
       }
   }
   #+END_SRC

3. *Struct instance storage* in ~precomp_declaration()~ (precomp.rs line 975-991, precomp.til line 1193-1206):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
   if at_global_scope && !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   if !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

**** Error When Removing All Three Checks

#+BEGIN_SRC
./bin/rstil build make.til
ERROR: src/core/array.til:41:45: rstil insert_string_into_frame ERROR:
  Str template not found - ensure str.til is imported
#+END_SRC

**** Root Cause Analysis

The issue is NOT about side effects (the "Why Fix is Safe" analysis is correct for that).
The issue is about *infrastructure availability during precompilation*:

1. *Precomp vs Eval timing*: ~precomp_expr~ runs before ~eval~. During precomp of
   function bodies, we're still in the syntactic transformation phase.

2. *Templates created during eval*: The ~EvalArena.default_instances["Str"]~ template
   is created when global Str declarations are evaluated, not during precomp.

3. *Order problem*: When precompiling ~src/core/array.til~'s function bodies (which
   contain format() calls that create Str), the Str template doesn't exist yet
   because we haven't finished evaluating global scope.

4. *Why global scope works*: At global scope, declarations are both precompiled AND
   evaluated in sequence. The Str template gets created by earlier declarations
   before later ones need it.

5. *Why function bodies fail*: Function bodies are precompiled during the module
   import phase, but not evaluated. The template infrastructure isn't available.

**** What Needs to Change

Simply removing ~at_global_scope~ doesn't work. The fix requires understanding
the precomp/eval interaction:

- *FCall folding (Location 1)*: Might work alone if ~eval_comptime~ doesn't try
  to store values that need templates. Needs investigation.

- *Primitive/Struct storage (Locations 2 & 3)*: Cannot work without templates.
  Options:
  1. Make template lookup fail gracefully (skip storage, don't error)
  2. Defer non-global storage to evaluation phase
  3. Initialize templates earlier (during precomp init?)
  4. Only fold to literals, don't store in arena for non-global

**** Files to Investigate Further

- ~src/rs/eval_arena.rs~: ~insert_string_into_frame()~, ~default_instances~ map
- ~src/rs/precomp.rs~: ~eval_comptime()~, understand what it stores vs returns
- ~src/rs/interpreter.rs~: When/how templates get initialized
- The interaction between ~precomp_expr~ -> ~eval_comptime~ -> ~EvalArena~

**** TIL Equivalents

The same changes were ported to ~src/self/precomp.til~:
- Location 1: lines 301-307 (FCall folding)
- Location 2: lines 1174-1191 (primitive storage)
- Location 3: lines 1193-1206 (struct instance storage)

The TIL syntax differs slightly (e.g., ~at_global_scope.and(...)~ instead of
~at_global_scope && ...~) but the logic is identical.

*** Tests
- tmp/test_constfold_scope.til - demonstrates the issue

** Bug #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Active (workaround exists)
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** History

**** 2026-01-01 to 2026-01-08: Initial Approach (Abandoned)
Original approach was to incrementally fix divergences in the existing ccodegen.til
through line-by-line comparison with ccodegen.rs. This proved problematic because:
- ccodegen.til had many missing ports from Rust
- Contained unauthorized workarounds and non-matching comments
- AI assistants kept adding more divergences instead of fixing them
- The accumulation of issues made systematic comparison impossible

**** 2026-01-09: Fresh Rewrite
Decision made to delete all self-hosted compiler files and start fresh:
- Commit ~1f29279a~: "Remove self-hosted compiler files for fresh rewrite"
- Blind translation of ccodegen.til, builder.til, til.til from Rust
- ~150+ commits fixing syntax, types, missing methods, etc.

***** WARNING: Broken Commit Range
Commits from ~1f29279a~ (origin/master + 1) through ~fad411f8~ are ALL BROKEN.
The build fails throughout this range because:
1. Fresh translation introduced many syntax/type errors
2. Each commit fixed some errors but build still failed
3. Only at ~fad411f8~ "Fix uninitialized variables..." does build pass again

This matters for:
- ~git bisect~: Skip this entire range, it's all broken
- ~git rebase -i~: Could squash ~1f29279a..fad411f8~ into single commit
- Archaeology: Don't waste time investigating individual commits in this range

**** 2026-01-12: Progress - Fixed if-let-Ok pattern in init.til
Build passes. 80/80 tests pass (0 failures). Test breakdown:
- 65 tests in all_common (pass all 4 modes) - includes maps.til!
- 1 test in til_common (panic.til)
- 4 tests in rs_interpreted
- 3 tests in rs_compiled
- 7 tests in rs_common
- 0 tests in til_interpreted (empty!)

Recent fixes:
- Fixed gcc stderr handling in builder.til to match Rust (capture stderr, only show on failure)
- Fixed hoisted_exprs collision: clear per-function to avoid cross-file line/col key collisions
- Fixed many if-let-Some translation bugs in ccodegen.til per rs2til.org rules:
  - emit_switch: enum_has_payloads, collect_declarations, payload lookup patterns
  - collect_declarations_recursive: type inference pattern
  - emit_assignment, emit_if, emit_while: vt check patterns
  - Various enum/struct lookup patterns with flag variables
- KEY FIX: Fixed if-let-Ok translation bug in init.til get_fcall_value_type
  - target_type was used after get_value_type could throw, causing garbage data
  - Added flag pattern: ~mut have_target_type := true~ with catch setting to false
  - This fixed enums.til and other nested function + switch case failures
- KEY FIX: Fixed ext.c run_cmd returning wrong exit code when output exceeds 64KB buffer
  - Rust's Command::output() captures all output; ext.c had 64KB limit
  - When buffer filled, pclose() with unread data caused gcc to get SIGPIPE -> non-zero exit
  - Added drain loop to consume remaining output before pclose()
  - This fixed maps.til and allowed moving it to all_common (all 4 modes pass)

*** Root Cause Analysis

The recurring bug pattern was if-let-Some/if-let-Ok translations from Rust:

#+begin_src rust
// Rust: if get_value_type fails, body is skipped
if let Ok(target_type) = get_value_type(context, first_arg) {
    // use target_type
}
#+end_src

#+begin_src til
// WRONG TIL: target_type is garbage if get_value_type throws!
target_type := get_value_type(context, first_arg)
catch (err: Str) { }
switch target_type {  // Uses garbage!
#+end_src

#+begin_src til
// CORRECT TIL: flag pattern per rs2til.org
mut have_target_type := true
target_type := get_value_type(context, first_arg)
catch (err: Str) {
    have_target_type = false
}
if have_target_type {
    switch target_type {  // Safe to use
#+end_src

*** Remaining Work
- 7 tests in rs_common (pass with rstil but not with til)
- Final verification: ~./src/til_diff.til src/til.til~ must show no differences
  - Note: times out at 300s - likely infinite loop (til compiled total is only 80s)

*** Debugging Tools

- ~./src/til_diff.til src/test/foo.til~ - compare rstil vs til generated C code
- ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ - test single file
- ~./make.til til_debug~ - build til with debug symbols for gdb
- ~gdb ./bin/til_debug~ - step through with breakpoints, inspect variable values
- ~gdb -batch -ex "run ..." -ex "bt" ./bin/til~ - get crash backtrace
- Look at ~gen/c/test/*.c~ for generated code

TIL code must be an exact translation from Rust (comments and variable names included)
using rs2til.org translation rules. Any differences detected must be fixed immediately,
even if only cosmetic.

Current test: ~src/test/c_mem.til~

**** Iterative Fix Workflow
1. User picks a test from til_interpreted that they want working in til_compiled
2. Run ~./src/til_diff.til src/test/chosen_test.til~ to compare rstil vs til generated C code
3. Analyze the diff - identify what's different in the generated C
4. Identify root cause in ccodegen.til
5. Verify against Rust - check equivalent code in ccodegen.rs
6. Fix following rs2til.org - apply correct translation pattern
7. Test the fix: ~./bin/til run src/test/chosen_test.til~
8. Run ~timeout 300 make benchmark~ (always use timeout 300 for make benchmark)
9. Re-run all failing tests in parallel to update TODO comments:
   - Run ~timeout 10 ./bin/til run src/test/X.til 2>&1~ for each test in til_interpreted
   - Update inline TODO comments with current errors
   - If any tests now pass, move them from til_interpreted + rs_common to all_common
   - If tests were moved, run ~make benchmark~ again to verify
10. Commit the fix (tests.til now has up-to-date TODOs and test locations)
11. Wait for user to pick next test to fix

**** Test Tracking
Each test in til_interpreted (src/tests.til) has an inline TODO comment explaining
why it fails in til_compiled:
#+BEGIN_SRC til
til_interpreted.push(TestEntry(path="src/test/foo.til"))  // TODO: too few args to til_Array_get
#+END_SRC
When a test passes til_compiled, remove TODO and move to all_common.

**** Updating TODO Comments
- Run ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ for each test to get the error
- Use timeout to catch infinite loops (exit code 124 = timeout)
- Run tests in parallel (multiple Bash tool calls), no shell loops
- NO filtering (no head, tail, grep) - see full output
- Extract the key error from output and add as inline TODO comment

**** Critical Rules
- Source of truth is Rust + rs2til.org - TIL code must match Rust translated per rs2til.org rules
- Validate changes by comparing Rust to TIL - run ~git diff~ and check both sides match per rs2til.org
- Correctness per rs2til.org is primary - whether a change "fixes" a test is secondary
- If change follows rs2til.org but doesn't fix issue - there's a DIFFERENT bug elsewhere
- NEVER filter make benchmark output - see ALL errors
- Avoid variable shadowing - Bug #97 disallows it
- Port fixes to BOTH Rust and TIL when needed

**** Files Modified
- src/self/ccodegen.til
- src/self/builder.til
- src/til.til
- src/rs/ccodegen.rs (when porting fixes)
- src/rs/builder.rs (when porting fixes)
- src/tests.til (when moving tests back to all_common)

*** Progress

**** Fixed Issues (from fresh rewrite)
1. Variable shadowing in emit_declaration (fcall_arg, hoisted_arg, ref_arg)
2. Variable shadowing in builder (reuse errors vector, default_fd rename)
3. Uninitialized variables after throwing calls:
   - detect_variadic_fcall (8 locations)
   - get_type_arg_name
   - lookup_struct
   - get_fcall_func_def in emit_throw
   - get_fcall_func_def in hoist_throwing_expr

**** Issues Found in hello_script.til Diff (2026-01-11)
Current diff from ~./src/til_diff.til src/examples/hello_script.til~:

***** Issue 1: til_Array_get missing 3 arguments
rstil generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1, til_extra_msgs, &_for_i_panic_0, (til_Dynamic*)&til_extra_msg);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1);
#+END_SRC
Affects 5 locations in hello_script.til (lines 101, 132, 165, 185, 233)

****** 2026-01-11: Fixed - Multiple issues in emit_throwing_call* functions
Root cause: Several interrelated bugs in argument emission for throwing function calls.

1. Catch block placement: Catch blocks were placed AFTER emit_arg_with_param_type(),
   so when param_by_ref.get() or param_types.get() threw IndexOutOfBoundsError,
   emit_arg_with_param_type was skipped entirely, causing missing arguments.

2. param_types type mismatch: emit_throwing_call_propagate and emit_throwing_call_with_goto
   stored Vec<Ptr> but hoist_for_dynamic_params expected Vec<ValueType>. This caused
   incorrect Dynamic casts to be applied to all arguments.

3. regular_arg_count defaulting to 0: In emit_throwing_call_with_goto, for non-variadic
   functions, regular_arg_count came from variadic_info.regular_count which defaults to 0.
   The loop `if arg_i.sub(1).gteq(regular_arg_count)` would break immediately.
   Fixed by using 999999999 for non-variadic (matches Rust's usize::MAX pattern).

Fixed in emit_throwing_call, emit_throwing_call_propagate, emit_throwing_call_with_goto:
- Move catch blocks immediately after .get() calls, before emit_arg_with_param_type
- Change param_types from Vec<Ptr> to Vec<ValueType>
- Convert ValueType to Ptr when calling emit_arg_with_param_type
- Use large default for regular_arg_count in non-variadic case

After fix: til_Array_get arguments now match rstil output.
Remaining diffs are hoisting differences (temp var numbering) which are cosmetic.

***** Issue 2: til_malloc missing 1 argument
rstil generates:
#+BEGIN_SRC c
til_I64 _tmp_format_13 = til_add(&til_result.cap, &(til_I64){1});
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12, &_tmp_format_13);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12);
#+END_SRC

***** Issue 3: Hoisting differences
rstil hoists expressions to temp vars:
#+BEGIN_SRC c
til_I64 _tmp_format_14 = til_mul(til_index, &til_self->type_size);
const til_I64 til_src = til_add(&til_self->ptr, &_tmp_format_14);
#+END_SRC
til uses inline compound literals:
#+BEGIN_SRC c
const til_I64 til_src = til_add(&til_self->ptr, &(til_I64){til_mul(til_index, &til_self->type_size)});
#+END_SRC
Both are valid C but cause temp variable numbering drift.

***** Issue 4: .msg inline vs hoisted
rstil hoists format call:
#+BEGIN_SRC c
til_Str _tmp_til_Array_get_7 = til_format(...);
*_err1 = (til_IndexOutOfBoundsError){.msg = _tmp_til_Array_get_7};
#+END_SRC
til inlines:
#+BEGIN_SRC c
*_err1 = (til_IndexOutOfBoundsError){.msg = til_format(...)};
#+END_SRC

****** 2026-01-12: Fixed - is_struct_constructor catch placement in init.til
The is_struct_constructor function in init.til had a catch block placed outside
the if block where the throwing code was:

#+BEGIN_SRC til
// WRONG - catch was outside if block, never catches lookup_struct exceptions
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    return true
}
catch (err: KeyNotFoundError) {  // Never triggered!
    return false
}
#+END_SRC

Fixed by moving the catch inside the if block:

#+BEGIN_SRC til
// CORRECT - catch inside same scope as throwing code
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    catch (err: KeyNotFoundError) {
        return false
    }
    return true
}
#+END_SRC

This fix resolves the hoisting differences - til_diff.til now shows "OK: No differences found!"

****** 2026-01-12: Test re-categorization after is_struct_constructor fix
With the catch placement fix, many tests now pass til_compiled mode.
Updated test categories in src/tests.til:
- 17 tests in all_common (pass all 4 modes)
- 49 tests in til_interpreted (pass til interpret, fail til compile)
- 53 tests in rs_common (pass rstil, fail til compile)

****** 2026-01-12: Discovered til.til run_cmd_vec swallows output
Tests showing "empty output" in til_compiled mode are caused by til.til's
run_cmd_vec function capturing stdout into a variable but never printing it:

#+BEGIN_SRC til
run_cmd_vec := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args { full_cmd = full_cmd.concat(" ").concat(arg) }
    mut output := ""
    return output.run_cmd("bash", "-c", full_cmd)  // output captured but never printed!
}
#+END_SRC

In contrast, rstil.rs uses Command::new().status() which inherits stdout.
This is NOT a ccodegen bug - the C code is identical. Needs separate fix in til.til.

****** 2026-01-12: Fixed run_cmd_vec output swallowing
Added run_cmd_vec_print to sys.til that prints captured output after run_cmd:

#+BEGIN_SRC til
run_cmd_vec_print := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)
    if output.len().gt(0) {
        print(output)
    }
    return exit_code
}
#+END_SRC

Updated til.til's run_file_or_exit to use run_cmd_vec_print instead of run_cmd_vec.
This matches rstil.rs's Command::new().status() behavior of inheriting stdout.

****** 2026-01-12: Final test re-categorization after run_cmd_vec_print fix
Tests that were failing with "empty output" now work correctly.
Updated test categories in src/tests.til:
- 22 tests in all_common (pass all 4 modes)
- 1 test in til_common (panic.til - error msg format differs "til" vs "rstil")
- 43 tests in til_interpreted (pass til interpret, fail til compile)
- 48 tests in rs_common (pass rstil, fail til compile)
- Total: 121 tests, 0 failures

Tests moved to all_common:
- hello_cli.til, hello_script.til, lolalalo.til (examples)
- bug46.til, underscore.til (tests)

****** 2026-01-12: Fixed hello_test.til constant folding
Two fixes to make hello_test.til pass til_compiled:

1. emit_arg_with_param_type in ccodegen.til: Added fc_fd_found flag to prevent
   double-emission when catch block handles KeyNotFoundError. The catch block
   would emit the expression, then code continued to emit it again.

2. is_comptime_evaluable in precomp.til: Changed from lookup_func to
   get_func_def_for_fcall_with_expr for proper UFCS resolution. This allows
   constant folding of expressions like ~not(I64.eq(42, 43))~.

Tests moved to all_common (11 tests):
- hello_test.til, arithmetics.til, boolean.til
- branchless.til, bug41.til, circular_test.til, comparisons.til
- eval.til, intro.til, literals.til, namespaces.til, variadic.til

Tests moved back from all_common (failed til_compiled):
- arenas.til (gcc type mismatch)
- arrays.til (gcc type mismatch)
- bug52.til (gcc shadow warning)
- underscore.til (segfault)

**** Known Error Patterns in Generated C
- ~too few arguments to function~ - missing args in generated calls
- ~undeclared variable~ - variable not emitted

*** Files That Must Match
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Final Verification
~make benchmark~ - all tests pass

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Active
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Reproducing Issue 1 (I64 args in interpreted mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, count: I64) {
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

Running: ~./bin/rstil interpret test.til hello 42~

Error: ~calling function 'main' expects 'I64' for arg 'count', but 'Str' was provided~

*** Reproducing Issue 2 (custom named args in compiled mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, value: Str) {
    println("name:", name, "value:", value)
}
#+END_SRC

Running: ~./bin/rstil run test.til hello world~

Error: C codegen produces ~til_main(&_main_args)~ with 1 arg but til_main expects 2+.
The C codegen only handles the standard ~args: ..Str~ pattern.

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.

* Fixed Bugs

** Bug #128: INFER_TYPE should not exist in AST after typer phase
:PROPERTIES:
:DISCOVERED: 2026-01-20
:FIXED: 2026-01-21
:IMPACT: Phases after typer require type inference machinery they shouldn't need
:STATUS: Fixed
:RELATED: Issue #127, Bug #130 (remaining work)
:END:

*** Description
After typer completes, no INFER_TYPE references should remain in the AST.
Declaration nodes had value_type=INFER_TYPE after typer, requiring later phases
(precomp, interpreter, ccodegen) to re-infer types.

*** Fix Summary
Cleaned up INFER_TYPE handling across the codebase in 6 steps:
- Step 2: Added resolve_inferred_types() calls to builder.til
- Step 3: Simplified resolve_inferred_types() to use get_value_type() directly
- Step 4: Fixed desugarer to use I64 directly for _for_i index variables
- Step 4b: Fixed resolve_inferred_types to recurse into StructDef default_values
- Step 5: Removed INFER_TYPE handling from precomp (both Rust and TIL)
- Step 6: Removed INFER_TYPE handling from ccodegen (both Rust and TIL)

Remaining work (unifying type checking with type resolution) split to Bug #130.

** Bug #125: Non-deterministic unused variable error ordering
:PROPERTIES:
:DISCOVERED: 2026-01-19
:FIXED: 2026-01-21
:IMPACT: Minor - warnings appeared in random order
:STATUS: Fixed
:END:

*** Description
Unused variable warnings were reported in non-deterministic order because
`function_locals` was stored in a HashSet (unordered).

*** Fix
Changed `function_locals` from HashSet to Vec<FunctionLocal>, which maintains
insertion order. Errors now consistently report in declaration order (a, b, c).

Verified by running the same test file multiple times with both rstil and til -
output is now deterministic.

** Bug #102: Automatic dependency tracking from imports
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-01-16
:IMPACT: Build performance, eliminates unnecessary recompilation
:STATUS: Fixed
:END:

*** Description
Have ~til run~ analyze dependencies from import() calls automatically. When the
binary already exists and neither the source nor any of its dependencies changed,
run the binary directly without recompiling.

*** Implementation
Added automatic dependency collection and mtime checking to the ~run~ command:

1. ~collect_all_deps(path)~ in builder.rs/builder.til:
   - Parses main file to get mode and imports
   - Recursively collects all transitive imports
   - Includes core.til and mode-specific imports
   - Returns list of all .til file dependencies

2. ~needs_rebuild(binary_path, deps)~ in rstil.rs/til.til:
   - Checks if binary exists
   - Compares binary mtime against all dependency mtimes
   - Returns true if any dep is newer than binary

3. Modified ~run_file_or_exit~ to:
   - Compute expected binary path
   - Collect dependencies
   - Skip build if binary is up-to-date
   - Execute binary directly

*** Design Decisions
- No caching: Dependencies recomputed each run (simpler, no invalidation issues)
- No ext_dep syntax: Only tracks .til files for now
- Lightweight parsing: Uses parse-only pass without full init/typer phases

*** Results
- ~til compiled~ test time dropped from 72s to 6s (binaries reused) when deps unchanged
- ~rs compiled~ drops from 28s to 3s on incremental runs (binaries reused)
- No change to build correctness (touching any dep triggers rebuild)

*** Files Modified
- src/rs/builder.rs: Added ~collect_import_paths~, ~collect_all_deps~
- src/rstil.rs: Added ~file_mtime~, ~source_to_binary_path~, ~needs_rebuild~;
  modified ~build_file_or_exit~ and ~run_file_or_exit~; added ~--force-rebuild~ flag
- src/self/builder.til: Ported ~collect_import_paths~, ~collect_all_deps~
- src/til.til: Added ~source_to_binary_path~, ~needs_rebuild~;
  modified ~build_file_or_exit~ and ~run_file_or_exit~; added ~--force-rebuild~ flag
- make.til: Simplified - removed manual .til dep tracking (now automatic);
  changed shebang to ~rstil run~; tracks ~g_compiler_changed~ to pass ~--force-rebuild~ to tests
- src/test_runner.til: Accepts ~--force-rebuild~ flag; shebang changed to ~rstil run~
- src/tests.til: Accepts ~--force-rebuild~ flag and passes to test_runner; shebang changed to ~rstil run~
- src/til_diff.til: Shebang changed to ~rstil run~

*** --force-rebuild Flag
Tests only force rebuild when compiler changed:
1. make.til sets ~g_compiler_changed~ when ~bin/rstil~ is newer than ~bin/til~
2. ~run_tests~ passes ~--force-rebuild~ to ~tests.til~ only when compiler changed
3. ~tests.til~ passes it to ~test_runner.til~
4. ~test_runner.til~ passes it to ~rstil run~ / ~til run~
This ensures fresh test builds after compiler changes, while allowing binary reuse otherwise.

*** Fair Benchmark Timing
For compiled mode tests, build time is now separated from execution timing:
1. For tests expecting success (~expected_status == 0~), ~test_runner.til~ first runs
   ~rstil build~ or ~til build~ (with ~--force-rebuild~ if needed) before timing
2. The timed command (~rstil run~ / ~til run~) then just executes the already-built binary
3. Error tests (~expected_status != 0~) skip pre-building since they're designed to fail
This ensures benchmark times are consistent whether the binary needed building or not.

** Bug #115: Map iteration using wrong pattern (len() instead of direct iteration)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:FIXED: 2026-01-15
:IMPACT: Potential data corruption with Map lazy deletion; deviation from rs2til.org rules
:STATUS: Fixed
:END:

*** Description
Several places in interpreter.til and typer.til used index-based Map iteration with
~map.len()~ instead of direct iteration over ~map.keys~ as specified in rs2til.org.
This pattern would fail with lazy deletion where ~_size < keys._len~.

*** Root Cause
The Rust code uses ~for (k, v) in &map~ which iterates all keys. The correct TIL
translation per rs2til.org is ~for k: Str in map.keys~, but several places used:

#+BEGIN_SRC til
// WRONG: Uses map.len() which returns _size
for i in 0..map.len() {
    map.keys.get(i, key)
    ...
}
#+END_SRC

*** Fix
Changed all occurrences to use direct iteration per rs2til.org:

#+BEGIN_SRC til
// CORRECT: Direct iteration over keys Vec
for key: Str in map.keys {
    mut val := ...
    map.get(key, val)
    ...
}
#+END_SRC

*** Files Modified
- src/self/interpreter.til:
  - Line ~161: nested_values iteration in read_struct_primitive_fields
  - Line ~251: nested map iteration in eval_struct_defaults
  - Line ~264: primitive_values iteration in eval_struct_defaults
  - Lines ~2011, ~2044, ~2391: catch handler iterations (keys._len pattern)
- src/self/typer.til:
  - Line ~2821: default_values iteration in is_expr_calling_procs

*** Notes
- The keys._len pattern at lines 2011, 2044, 2391 is kept for future HashMap support
- Removed now-unnecessary IndexOutOfBoundsError catch blocks
- No performance impact (within noise margin)

** Bug #86: For-in loop fails with enum that has enum payload
:PROPERTIES:
:DISCOVERED: 2026-01-06
:FIXED: 2026-01-15
:IMPACT: Cannot use for-in loops with certain enum types
:STATUS: Fixed
:END:

*** Description
When an enum's first variant has another enum as its payload type, using that
enum type in a for-in loop fails at init time with the error:
"Enum constructor X expects payload of type Y, but got enum"

*** Example
#+BEGIN_SRC til
InnerEnum := enum { FTFunc, FTProc }
OuterEnum := enum {
    TFunction: InnerEnum,  // First variant has enum payload
    TCustom: Str,
}

mut v := Vec.new(OuterEnum)
for item: OuterEnum in v {  // ERROR at init time
    // ...
}
#+END_SRC

*** Root Cause
~build_default_value~ in precomp.rs/til was generating invalid enum constructors.
For an enum whose first variant has an enum payload, it generated ~InnerEnum()~
instead of the correct ~InnerEnum.FTFunc~ (or appropriate default variant).

*** Fix
Made ~build_default_value~ recursive: when the first variant has an enum payload,
it now calls ~build_default_value~ again for that nested enum, producing the
correct default constructor chain.

*** Tests
- src/test/loops.til: test_forin_payload_enum (previously commented out, now works)

** Bug #93: Test runner returns exit code 0 even with failures
:PROPERTIES:
:DISCOVERED: 2026-01-08
:FIXED: 2026-01-10
:IMPACT: CI/CD reliability
:STATUS: Fixed
:END:

*** Description
~make tests~ returned exit code 0 even when tests failed. This broke CI/CD
pipelines that rely on exit codes to detect failures.

*** Root Cause
In make.til's ~run_tests~ proc, the exit code from ~./bin/tests~ was being
overwritten by the subsequent ~cp~ command before checking.

*** Fix
Save the tests exit code before running cp:
#+BEGIN_SRC til
status = run_stream_cmd("./bin/tests")
tests_status := status  // Save before cp overwrites it
status = run_stream_cmd("cp gen/c/test/constfold.c src/test/constfold.c")
if tests_status.eq(0).not() {
    exit(1)
}
#+END_SRC

*** Test
Added src/test/panic.til with expected_status=1 to verify exit code handling.

** Bug #95: Need spread operator to expand Vec/Array for variadic arguments
:PROPERTIES:
:DISCOVERED: 2026-01-09
:IMPACT: Cannot pass collected arguments to variadic functions
:STATUS: Duplicate of Bug #83
:END:

See Bug #83 for full details. All unique content merged there.

** Bug #87: Scavenger not pruning struct methods
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Generated C code 10x larger than necessary
:STATUS: Fixed
:END:

*** Description
The scavenger phase was not properly pruning unused struct methods. An empty
script (just =mode script=) generated 1,167 lines of C code instead of ~100.

*** Root Cause
In =compute_reachable=, when processing struct constructors (e.g., =Bool()=),
the code walked into ALL =default_values= including method bodies (FuncDef).
This incorrectly marked all methods as reachable even when not called.

#+begin_src rust
// BUG: This walked into method bodies too
for default_expr in struct_def.default_values.values() {
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Fix
Skip FuncDef values when processing struct constructors - methods should only
be walked if explicitly called via their qualified name (e.g., =I64.eq=).

#+begin_src rust
for default_expr in struct_def.default_values.values() {
    if let NodeType::FuncDef(_) = &default_expr.node_type {
        continue;  // Skip methods
    }
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Files Changed
- =src/rs/scavenger.rs= (lines 239-244)
- =src/self/scavenger.til= (lines 274-280)

*** Results
- =empty.c=: 1,167 lines -> 99 lines (92% reduction)
- =til compiled= benchmark: 39s -> 27s (~30% faster)
- All 107 tests pass

*** Additional Fix: Prune Unused Struct Definitions

After fixing method pruning, we also added pruning of unused struct/enum definitions.
The scavenger now tracks which types are actually used (in function signatures, declarations,
constructors) and removes struct definitions that aren't referenced.

**** Implementation
- Added =used_types: HashSet<String>= to =ComputeReachableResult=
- Added =EXT_C_TYPES= constant for types required by ext.c (Bool, Str, I64, U8, AllocError, Array)
- Added =extract_type_name()=, =collect_used_types_from_expr()=, =collect_used_types_from_func()=
- Transitive closure: when a type is used, its field types are also marked as used
- Struct filtering in AST rebuild checks =used_types.contains(&decl.name)=

**** Results
- =empty.c=: 99 lines -> 61 lines (additional 38% reduction)
- All 107 tests pass

**** Also Added
- =Ptr.is_null()= method to src/core/ptr.til (matches rs2til.org documentation)

** Bug #84: run_cmd output capture broken in compiled mode
:PROPERTIES:
:DISCOVERED: 2026-01-05
:FIXED: 2026-01-05
:IMPACT: Cannot use compiled test.til
:STATUS: Fixed
:END:

*** Description
The =run_cmd= ext_proc didn't capture command output correctly in compiled mode.
The mutable output string parameter remained empty (or got only a newline).

*** Root Cause
The C implementation in =src/ext.c= used =popen()= which passes commands through the shell.
Arguments weren't quoted, so =bash -c echo hello= was executed instead of =bash -c 'echo hello'=.

*** Fix
1. =src/ext.c=: Added single-quote wrapping for arguments (except command) with proper escaping of embedded single quotes as ='\''=.
2. =src/self/ext.til=: Implemented =proc_run_cmd= to call the host's =run_cmd= via =bash -c= with properly quoted arguments. This was previously throwing "not yet implemented".

*** Test
=src/test/syscalls.til= has =test_run_cmd_output()= which verifies output capture works.

** Bug #85: Typer accepts struct literal with non-existent field name
:PROPERTIES:
:DISCOVERED: 2026-01-05
:FIXED: 2026-01-08
:IMPACT: Silent code generation with wrong semantics
:STATUS: Fixed
:END:

*** Description
The type checker accepts struct literals with field names that don't exist in the struct definition.

*** Example
#+begin_src til
KeyNotFoundError := struct {
    mut msg: Str = ""
}

// This should be a type error but compiles successfully:
throw KeyNotFoundError(key="not variadic")
// Should be: throw KeyNotFoundError(msg="not variadic")
#+end_src

The struct only has a ~msg~ field, but ~key=~ is accepted without error.

*** Solution
Added field name validation in ~check_fcall()~ (typer.rs/typer.til).

When a function call returns ~None~ from ~get_func_def_for_fcall_with_expr~
(indicating struct/enum instantiation), we now:
1. Look up the struct definition
2. Collect all valid field names
3. For each ~NamedArg~ in the call, verify the field name exists
4. Report type error if field doesn't exist

The fix also type-checks argument values, which was previously skipped for
struct instantiation.

*** Files Modified
- ~src/rs/typer.rs~: Added validation in ~check_fcall()~
- ~src/self/typer.til~: Ported same changes

*** Bonus Fix
The fix caught a pre-existing bug in ~src/self/ccodegen.til~ where
~SymbolInfo~ was being constructed with non-existent fields:
- ~symbol_type~ (doesn't exist - removed)
- ~is_mutable~ (should be ~is_mut~ - corrected)

** Bug #78: TIL scavenger/ccodegen divergence from Rust
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_compiled (./bin/til build/run) crashes
:STATUS: Fixed
:END:

*** Description
The self-hosted TIL compiler crashed when running ~./bin/til build src/examples/empty.til~.
Multiple divergences between Rust and TIL implementations were causing issues.

*** Root Causes and Fixes

1. **scavenger.til compute_reachable return type**: TIL version handled
   ~needs_variadic_support~ inside the function with a recursive call, while Rust
   handled it at the call site. Fixed by adding ~ComputeReachableResult~ struct
   to both Rust and TIL, returning both values and handling at call site.

2. **ccodegen.til topological_sort_types**: TIL version used ~List~ with nested
   ~Vec~ elements, but modifications to copies didn't persist (TIL collections
   return copies, not references). Fixed by:
   - Changed parameter from ~List~ to ~Vec~
   - Changed internal ~List~ of ~Vec~ to ~Map<I64, Vec>~ with get/modify/set pattern
   - All catch blocks now throw ~err.msg~ instead of being empty (matching Rust panics)

3. **rs2til.org documentation**: Added new section "Implicit panics become throws Str"
   documenting that Rust code that would panic should throw Str in TIL.

*** Current Status
Scavenger and topological sort phases complete successfully. Crash now occurs
later in emit phase - investigation continues.

** Bug #77: Nested enum patterns incorrectly treated as binding variables
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_interpreted tests fail - bug47 and til.til help blocked
:STATUS: Fixed
:END:

*** Description
When parsing switch case patterns like ~case ValueType.TType(TTypeDef.TEnumDef):~,
the parser incorrectly treated the nested identifier ~TTypeDef.TEnumDef~ as a binding
variable with name "TTypeDef", causing the typer to declare a local symbol "TTypeDef"
with value_type TCustom("TTypeDef") that shadowed the real enum definition.

*** Root Cause
In parser.til parse_case_expr function, when checking if an FCall argument is a binding
variable (line 2005), it only checked if ~p1.node_type~ was an Identifier, but did not
check if the identifier had nested params. The Rust version had an additional check:
~if left.params[1].params.is_empty()~ to only treat simple identifiers as bindings.

*** Fix
Added check in parser.til at line 2008: ~if p1.params.len().eq(0)~
This ensures only simple identifiers (no nested params like TTypeDef.TEnumDef) are
treated as binding variables. Nested patterns remain as FCall for proper matching.

** Bug #73: TTypeDef value_type stored as TStructDef (actually Bug #77)
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: Cannot import self.init with til interpret
:STATUS: Fixed (was actually Bug #77)
:END:

*** Description
The symptoms were "Struct 'TTypeDef' not found" when processing init.til, but the
actual root cause was Bug #77 - nested enum patterns being incorrectly treated as
bindings, causing TTypeDef to be declared as TCustom("TTypeDef") in a local scope.

** Bug #74: TIL interpreter mut enum parameter write-back loses payload
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: vecs.til test fails - enum payload lost when extracting via switch
:STATUS: Fixed
:END:

*** Description
When a mut enum parameter is passed to a function (like Vec.get), and that function
modifies the enum (via memcpy), the payload is lost when writing back to the caller.

*** Root Cause
TIL's interpreter.til was missing the Bug #38 fix in the ~MutArgValue.Enum~ case
of the mut argument write-back logic. Rust sets ~context.temp_enum_payload~ before
calling ~insert_enum~ to preserve the payload data, but TIL was not doing this.

*** Fix
Added the Bug #38 fix to interpreter.til line 3154-3167:
#+BEGIN_SRC til
case MutArgValue.Enum(enum_val):
    // Bug #38 fix: Set temp_enum_payload so insert_enum preserves the payload
    if not(NULL.eq(enum_val.payload.data)).and(not(NULL.eq(enum_val.payload_type.data))) {
        // Read payload Vec and ValueType from the pointers
        mut payload_vec := Vec.new(U8)
        memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
        mut payload_type := ValueType.TCustom("")
        memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
        // Create EnumPayload and set temp_enum_payload
        mut temp_payload := EnumPayload(data=payload_vec.clone(), value_type=payload_type)
        heap_payload_ptr := malloc(size_of(EnumPayload))
        memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
        context.temp_enum_payload.data = heap_payload_ptr
    }
    _ := EvalArena.insert_enum(...)
#+END_SRC

*** Test
~src/test/vecs.til~ - now passes with ~til interpret~.

** Bug #75: TIL interpreter missing string range comparison support
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: test_lexer.til fails - lexer uses case "0".."9" patterns
:STATUS: Fixed
:END:

*** Description
The TIL interpreter threw "String range comparisons not yet supported" when
encountering switch case patterns like ~case "0".."9"~ in lexer.til. This
blocked the test_lexer.til test from running with ~./bin/til interpret~.

*** Root Cause
The Rust interpreter uses native string comparison operators (~>=~ and ~<=~)
for lexicographic comparison, but TIL's interpreter.til was throwing an error
instead of implementing the comparison.

*** Fix
Added ~Str.cmp()~ method to str.til that performs lexicographic comparison:
#+BEGIN_SRC til
cmp := func(self: Str, other: Str) returns I64 {
    mut min_len := self.len()
    if other.len().lt(min_len) {
        min_len = other.len()
    }
    for i in 0..min_len {
        a_byte := self.char_at(i)
        b_byte := other.char_at(i)
        a_val := U8.to_i64(a_byte)
        b_val := U8.to_i64(b_byte)
        if a_val.lt(b_val) {
            return sub(0, 1)
        }
        if a_val.gt(b_val) {
            return 1
        }
    }
    return sub(self.len(), other.len())
}
#+END_SRC

Updated interpreter.til to use it instead of throwing:
#+BEGIN_SRC til
// Lexicographic string comparison
cmp_start := result_to_switch.value.cmp(start.value)
cmp_end := result_to_switch.value.cmp(end.value)
is_match = cmp_start.gteq(0).and(cmp_end.lteq(0))
#+END_SRC

*** Test
~src/test/test_lexer.til~ - now passes with ~til interpret~.

** Bug #76: Optional function arguments not working in til_interpreted
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: optional_args.til fails - functions with default arg values have args.len() = 0
:STATUS: Fixed
:END:

*** Description
Functions with optional arguments (e.g., ~greeting: Str = "Hello"~) were failing
in the til-interpreted tests with "expects at most 0 args" error. The function's
args.len() was 0 when looked up, even though it was declared with correct args.

*** Root Cause
In ~parse_func_proc_args~ in parser.til, when parsing optional argument default
values, the code was:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    decl.default_value.data = to_ptr(default_expr)  // BUG: pointer to local!
#+END_SRC

~default_expr~ is a local variable on the stack. Taking a pointer to it with
~to_ptr(default_expr)~ creates a dangling pointer when the function returns.
This is a use-after-free bug - the memory at that address gets reused for other
data, corrupting the default_value pointer.

*** Fix
Allocate heap memory for the Expr and copy it there:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    // Must allocate heap memory - to_ptr(default_expr) would create dangling pointer
    decl.default_value.data = malloc(size_of(Expr))
    memcpy(decl.default_value.data, to_ptr(default_expr), size_of(Expr))
#+END_SRC

*** Test
~src/test/optional_args.til~ - now passes with ~til interpret~.

** Bug #72: Copying global enum with payload segfaults in til interpreter
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2026-01-01
:IMPACT: enums.til test fails with til interpret
:STATUS: Fixed
:END:

*** Description
When a global enum variable has a payload (e.g., ~Color.Green(true)~) and is copied
to a local variable inside a function, the til interpreter segfaults.

*** Root Cause
Two issues in ~eval_arena.til~'s ~get_enum~ and ~get_enum_at_offset~ functions:
1. ~payload_bytes~ and ~payload_type~ are local stack variables
2. ~to_ptr()~ returns pointers to these stack variables
3. When the function returns, these pointers become stale (use-after-free)

Additionally, pattern binding for enum payloads that are themselves enums was missing
proper arena insertion.

*** Fix
1. In ~get_enum~ and ~get_enum_at_offset~: heap-allocate the Vec and ValueType structs
   using ~malloc(size_of(...))~ before returning, so pointers remain valid.
2. In ~interpreter.til~ pattern binding: added TEnumDef case that properly looks up
   the inner enum variant, sets ~temp_enum_payload~ if needed, and calls ~insert_enum~.

*** Test
~src/test/enums.til~ - now passes with ~til interpret~.

** Bug #71: TIL interpreter enum pattern binding use-after-free
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Pattern binding in switch cases failed with "Type unknown not supported yet"
:STATUS: Fixed
:END:

*** Description
When pattern matching on enum variants with payloads (e.g., ~case TestEnum.TypeC(n)~),
the bound variable ~n~ could not be used - accessing it gave "Type unknown not supported yet".

*** Root Cause
~EnumVal~ in TIL uses ~Ptr~ fields for ~payload~ and ~payload_type~, pointing to local
stack variables in ~get_enum~. When ~get_enum~ returns, these pointers become stale
(use-after-free). The Rust version uses owned ~Option<Vec<u8>>~ and ~Option<ValueType>~
which don't have this issue.

*** Fix
Changed pattern binding code in ~interpreter.til~ to look up payload type directly from
the enum definition (via ~lookup_enum~) and read payload bytes directly from the arena,
instead of using the stale ~EnumVal.payload_type~ and ~EnumVal.payload~ pointers.

Supports all payload types: I64, Str, and structs (including Bool and custom structs).

*** Test
~src/test/ufcs.til~ - tests pattern matching with I64 and Str enum payloads.

** Bug #70: C codegen variable type collision causes struct default garbage
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Struct fields with default I64 values returned garbage in til interpret
:STATUS: Fixed
:END:

*** Description
~src/test/mut_test.til~ failed with ~til interpret~, returning garbage values for
struct fields with default I64 values:
#+BEGIN_EXAMPLE
src/test/mut_test.til:65:19:assert_eq failed: expected '0', found '2147395840'
#+END_EXAMPLE

*** Root Cause
In ~src/self/eval_arena.til~'s ~insert_struct_core~, both U8 and I64 branches
used a local variable named ~v~:
#+BEGIN_SRC til
if type_name.eq("U8") {
    v := U8.from_str(default_value)  // v declared as U8
    ...
} else {
    if type_name.eq("I64") {
        v := I64.from_str(default_value)  // v redeclared as I64
        ...
#+END_SRC

The C code generator reused the same variable declaration:
#+BEGIN_SRC c
til_U8 til_v;  // Declared as U8
...
til_v = til_I64_from_str(&til_default_value);  // Assigned I64 to U8!
#+END_SRC

This caused an 8-byte I64 value to be stored in a 1-byte U8 variable,
then only 1 byte was copied to the arena, resulting in garbage values.

*** Fix
Renamed variables to be unique: ~u8_val~ for U8 branch, ~i64_val~ for I64 branch.
This prevents variable name collisions across different type branches.

Files modified:
- ~src/self/eval_arena.til~ (TIL version)
- ~src/rs/eval_arena.rs~ (Rust version, for consistency)

** Bug #63: Typer allows passing const variable to own parameter
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-31
:IMPACT: Incorrect ownership semantics, gcc warnings about discarding const
:STATUS: Fixed
:END:

*** Description
When a function has an ~own~ parameter, the typer should require the caller
to pass a ~mut~ variable, just like it does for ~mut~ parameters. Currently,
the typer allows passing const variables to ~own~ parameters.

*** Reproducing
#+BEGIN_SRC til
consume := proc(own v: Vec2) returns I64 {
    return add(v.x, v.y)
}

test := proc() {
    original := Vec2(x=1, y=2)  // const, not mut
    result := consume(original)  // Should error, but doesn't
}
#+END_SRC

*** Expected behavior
Typer should emit an error like: "Cannot pass const variable 'original' to own parameter 'v'"

*** Fix Applied
Added check in typer.rs and typer.til for ~is_own~ parameter, similar to existing
~is_mut~ check. When processing FCall args, if the parameter is ~own~ and the
argument is a const variable (identifier with ~!symbol_info.is_mut~), emit type error.

** Bug #68: TIL typer doesn't remove symbol for own parameter (Bug #49 fix not working)
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: til_interpreted output mismatch on bug49.til (1 error vs 2)
:STATUS: Fixed
:RELATED: Bug #49 (original fix), Bug #65 (similar Rust/TIL divergence)
:END:

*** Description
The Bug #49 fix (remove_symbol for own parameters) exists in both typer.rs and typer.til,
but the TIL version doesn't work. When a variable is passed to an ~own~ parameter:
- rstil: 2 errors (type ERROR + init ERROR for undefined symbol)
- til: 1 error (init ERROR only)

The ~remove_symbol~ call at typer.til:861 is being executed, but the symbol remains
findable by subsequent lookups.

*** Code Location
typer.til lines 854-866:
#+BEGIN_SRC til
// Bug #49: Handle ownership transfer for 'own' parameters
if arg.is_own {
    switch arg_expr.node_type {
    case NodeType.Identifier(var_name):
        if arg_expr.params.len().eq(0) {
            _ := context.scope_stack.remove_symbol(var_name)
        }
    case:
    }
}
#+END_SRC

*** Investigation Notes (2025-12-31)
- Debug prints confirmed ~remove_symbol~ IS being called and modifies the frame correctly
- After removal, ~lookup_symbol~ correctly shows ~contains_key=false~ for all frames
- BUT ~symbol_found~ is still set to ~true~ after the catch block

*** Root Cause Hypothesis
Examined generated C code in bootstrap/til.c. Found that when there are TWO consecutive
catch blocks for the SAME error type, the second one is MISSING the ~goto~ statement:

~lookup_func~ (first catch - CORRECT):
#+BEGIN_SRC c
int _status_104 = til_ScopeStack_lookup_func(...);
if (_status_104 == 1) { ... goto _catch_KeyNotFoundError_96; }  // <-- goto EXISTS
til_func_found = true;
if (0) { _catch_KeyNotFoundError_96: ... }
#+END_SRC

~lookup_symbol~ (second catch - BROKEN):
#+BEGIN_SRC c
int _status_105 = til_ScopeStack_lookup_symbol(...);
// <-- NO GOTO HERE! Missing: if (_status_105 == 1) { goto _catch_97; }
til_symbol_found = true;
if (0) { _catch_KeyNotFoundError_97: ... }
#+END_SRC

This is a ccodegen.rs bug: consecutive catch blocks for same error type lose their goto.

*** Reproducing Test
Test file: src/test/bug68.til

- ~rstil interpret src/test/bug68.til~  PASS (symbol_found=false, catch works)
- ~rstil run src/test/bug68.til~  FAIL (symbol_found=true, catch doesn't execute)

The test imports typer.til and calls ~check_types_with_context~ directly, which
contains the buggy consecutive catch pattern.

*** Partial Fix Applied
Added explicit ~func_found = false~ and ~symbol_found = false~ in catch blocks in typer.til.
This is correct - per rs2til.org, catching KeyNotFoundError is like ~.is_some() = false~.
The catch blocks now have the right code, but ccodegen.rs doesn't generate the goto to reach them.

*** Plan to Fix
1.  Created reproducing test (bug68.til)
2.  Verified ~rstil interpret~ works but ~rstil run~ fails
3.  Added explicit false assignments in catch blocks (typer.til)
4.  Fixed ccodegen.rs: added ~func_level_catches.is_empty()~ check to propagate condition
5.  Ported fix to ccodegen.til

*** Fix Applied
The propagate condition was missing the ~func_level_catches.is_empty()~ check.
When ~local_catch_labels~ was empty (after processing an earlier catch), the code
would propagate errors even when there were more catches in the block.

Fix: Changed propagate condition from:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() {
#+END_SRC
To:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() && func_level_catches.is_empty() {
#+END_SRC

This ensures we only propagate when there are NO catches in the block, not just when
~local_catch_labels~ happens to be empty due to earlier catch processing.

** Bug #67: Enum variant payload type comes through as empty string in til
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 4 til_interpreted tests affected (bug56, editor_mode_test, enums, forward_declarations)
:STATUS: Fixed (3 of 4 tests)
:END:

*** Description
When an enum has a variant with a payload type (e.g., ~Variant1: Str~), the self-hosted
TIL interpreter receives the type as empty string, causing "uses undefined type ''" errors.
The Rust interpreter works correctly.

*** Root Cause
In parser.til, ~to_ptr(payload_type)~ was storing a pointer to a stack variable that
became invalid when the loop continued or function returned. The Rust version uses
~Option<Box<ValueType>>~ which properly heap-allocates, but the TIL translation using
~Ptr~ (per rs2til.org for Option fields) requires explicit heap allocation.

Two locations affected:
1. ~EnumVariant.clone()~ - stored pointer to stack variable ~cloned_type~
2. ~enum_definition()~ - stored pointer to stack variable ~payload_type~

*** Fix
Used malloc to allocate heap memory instead of storing stack pointer:
#+BEGIN_SRC til
// In EnumVariant.clone():
result.payload_type.data = malloc(size_of(ValueType))
memcpy(result.payload_type.data, self.payload_type.data, size_of(ValueType))

// In enum_definition():
payload_ptr.data = malloc(size_of(ValueType))
memcpy(payload_ptr.data, to_ptr(payload_type), size_of(ValueType))
#+END_SRC

*** Results
- bug56.til: Fixed (now in til_interpreted)
- editor_mode_test.til: Fixed (now in til_interpreted)
- forward_declarations.til: Fixed (now in til_interpreted)
- enums.til: Still segfaults (different bug, not enum payload related)

** Bug #65: "Source 'X' not found in caller context" with Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 10 til_interpreted tests fail (arenas, arrays, clone, lists, loops, maps, etc.)
:STATUS: Fixed
:RELATED: Issue #66 (shadowing policy)
:END:

*** Description
When passing literal values to Dynamic parameters (e.g., ~v.push(10)~ on a Vec),
the self-hosted TIL interpreter fails with "Source '10' not found in caller context".
The Rust interpreter works correctly.

*** Root Cause
Rust/TIL divergence in interpreter.rs/interpreter.til:

Rust used variable shadowing (~let custom_type_name = ...~) to resolve Dynamic/Type
parameters to their actual types. TIL doesn't support shadowing the same way, so it
used a different variable (~resolved_type_name~) but then inconsistently used the
original ~custom_type_name~ in subsequent code.

*** Fix
Changed both Rust and TIL to use ~resolved_type_name~ consistently (no shadowing).
Updated ~-Wshadow~ flag for gcc to catch similar issues in generated C code.

Test file: src/test/bug65.til

See Issue #66 in doc/todo/future.org for long-term shadowing policy discussion.

** Bug #60: ccodegen passes const/own args by value instead of by pointer
:PROPERTIES:
:DISCOVERED: 2025-12-28
:FIXED: 2025-12-29
:IMPACT: Stack overflow on recursive functions with large struct args
:STATUS: Fixed
:END:

*** Description
In TIL, function arguments should be passed as follows:
- *const (default)*: by const pointer (const T*)
- *own*: by pointer (T*) - caller transfers ownership
- *mut*: by pointer (T*) - currently correct
- *copy*: by value (T) - currently correct

Currently, ccodegen.rs passes const and own args by value, causing stack
overflow when functions with large struct arguments are called recursively.

*** Reproducing
Inspect gen/c/test/args.c after running ~./bin/rstil run src/test/args.til~:

#+BEGIN_SRC c
// WRONG - const args passed by value:
til_I64 til_test_i64_arg(const til_I64 til_n);
til_Bool til_test_bool_arg(const til_Bool til_b);

// WRONG - own args passed by value:
til_I64 til_consume_i64(til_I64 til_n);
til_I64 til_consume_vec(til_Vec2 til_v);

// CORRECT - mut args passed by pointer:
til_I64 til_mixed_params(const til_I64 til_normal, til_I64* til_m, til_I64 til_o);

// CORRECT - copy args passed by value:
til_I64 til_test_copy_i64(til_I64 til_x);
til_Vec2 til_test_copy_struct(til_Vec2 til_v);
#+END_SRC

Expected signatures:
#+BEGIN_SRC c
// const args should be const pointers:
til_I64 til_test_i64_arg(const til_I64* til_n);
til_Bool til_test_bool_arg(const til_Bool* til_b);

// own args should be pointers:
til_I64 til_consume_i64(til_I64* til_n);
til_I64 til_consume_vec(til_Vec2* til_v);
#+END_SRC

*** Fix
Requires changes in several places in ccodegen.rs:

1. *emit_func_signature* - Change signature generation for const and own:
   - const: ~const til_Type* til_arg~
   - own: ~til_Type* til_arg~

2. *param_by_ref calculation* - Change from ~is_mut~ to ~!is_copy~:
   - Affects all places that calculate ~param_by_ref~ vector

3. *current_ref_params tracking* - Track all non-copy params:
   - Change from ~is_mut~ to ~!is_copy~ in function body setup

4. *hoist_for_ref_params* - Add hoisting for literals that can't use ~&~:
   - Similar pattern to existing ~hoist_for_dynamic_params~
   - Only TWO cases need hoisting:
     a) *I64 literals*: ~&69~ is invalid C (can't take address of rvalue)
        Must hoist to: ~til_I64 _tmp = 69; func(&_tmp);~
     b) *Type literals*: ~&"Str"~ gives ~char**~ but we need ~const char* const*~
        Must hoist to: ~til_Type _tmp = "Str"; func(&_tmp);~
   - Note: Type is a special type like Dynamic - see how Dynamic is handled

5. *emit_arg_with_param_type* - For identifiers that are ref params:
   - When ~param_by_ref~ is true and arg is already a pointer, just emit name
   - Don't call ~emit_expr~ which would dereference with ~(*name)~

6. *ext.c functions* - Update to accept pointers for const/own args:
   - All ext functions should use ~const til_Type*~ for const args
   - Example: ~til_add(const til_I64* a, const til_I64* b)~
   - This keeps everything consistent - no special-casing ext funcs

*** Literal Types - What CAN vs CANNOT use ~&~ prefix

*CAN use ~&~ directly (compound literals in C99+):*
- Str: ~&((til_Str){(til_I64)"hello", 5})~ - valid, compound literal is lvalue
- U8: ~&((til_U8){42})~ - valid, compound literal is lvalue
- Bool: ~&((til_Bool){1})~ - valid, compound literal is lvalue
- Any struct: ~&((til_MyStruct){...})~ - valid, compound literal is lvalue

*CANNOT use ~&~ - must hoist to temp var:*
- I64: ~&69~ - INVALID, plain integer is rvalue
- Type: ~&"Str"~ - gives wrong type (~char**~ instead of ~const char* const*~)

*** Solution
Implemented all the planned fixes:
1. Added ~param_needs_by_ref~ helper function to determine if param should be passed by pointer
2. Changed ~param_by_ref~ calculation from ~is_mut~ to ~param_needs_by_ref(arg)~
3. Added ~hoist_for_ref_params~ function to hoist I64 literals and function call results
4. Updated ~emit_func_signature~ to emit const pointers for const params
5. Updated ~emit_arg_with_param_type~ to handle by-ref params correctly
6. Updated ~ext.c~ functions to accept pointers for const/own args
7. Fixed hardcoded main args initialization to use compound literals for I64

Files modified:
- src/rs/ccodegen.rs, src/self/ccodegen.til
- src/rs/init.rs, src/self/init.til (added is_enum_constructor helpers)
- src/ext.c (updated function signatures)

*Performance Impact:*
Passing primitives (I64, Bool) by pointer adds overhead:
- til_interpreted tests: ~8.5s -> ~13.8s per test (~60% slower)
- Total til_interpreted: 338s -> 543s
This is expected since primitives were previously passed by value (fast) and now
require pointer indirection. The correctness fix was necessary to prevent stack
overflow on recursive functions with large struct arguments.

** Bug #61: Optional args before variadic don't use default when type mismatches
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Cannot have optional args before variadic with type-based defaulting
:STATUS: Fixed
:END:

*** Description
When a function has an optional argument (with default value) before a variadic
argument, and the caller omits the optional arg, the typer doesn't detect that
the provided arg type doesn't match and use the default.

*** Fix
Modified check_fcall in typer.rs to track definition arg index separately from
provided arg index. When type doesn't match and the param has a default value
and variadic follows, skip the optional param and continue matching.

Also modified precompute_fcall_args in precomp.rs to insert default values for
skipped optional args before variadic.

Files modified:
- src/rs/typer.rs - check_fcall with def_arg_idx tracking and skip logic
- src/rs/precomp.rs - reorder_named_args with optional-before-variadic handling
- src/self/typer.til - same changes
- src/self/precomp.til - same changes
- src/test/args.til - uncommented test_optional_before_variadic test

** Bug #62: U8 type annotations generate I64 in C codegen
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Wrong type in generated C code, potential overflow/truncation bugs
:STATUS: Fixed
:END:

*** Description
When declaring a variable with explicit U8 type annotation, the C codegen
generates til_I64 instead of til_U8.

*** Root Cause
In ccodegen.rs emit_declaration, the code always called get_value_type() to
infer the type from the RHS expression, ignoring explicit type annotations.
Integer literals return I64 from get_value_type(), so U8 annotations were lost.

*** Fix
Check if decl.value_type is INFER_TYPE before inferring. If an explicit type
is provided, use it directly instead of inferring from RHS.

Files modified:
- src/rs/ccodegen.rs - emit_declaration, mut and const branches
- src/self/ccodegen.til - emit_declaration, mut and const branches

Test: src/test/literals.til

** Bug #58: Error messages show file path twice
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Confusing error messages
:STATUS: Fixed
:END:

*** Description
Error messages show the file path duplicated:
#+BEGIN_EXAMPLE
src/test/bug50.til:src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

Should show:
#+BEGIN_EXAMPLE
src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

*** Root Cause
In interpreter.rs and builder.rs, errors were printed with ~println!("{}:{}", path, err)~
but ~err~ already contains the path from ~error()~ / ~todo_error()~ which format as
~"path:line:col: ..."~.

*** Fix
Removed the duplicate path prefix from error printing in:
- src/rs/interpreter.rs (lines 2889, 2917, 2949)
- src/rs/builder.rs (lines 158, 165, 189, 205, 214)
- src/self/interpreter.til (lines 3222, 3255, 3296)
- src/self/builder.til (5 locations)

** Bug #50: Codegen doesn't capture outer variables in nested functions
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-27
:IMPACT: Nested functions fail to compile when accessing outer scope variables
:STATUS: Fixed
:END:

*** Description
Nested functions (closures) in TIL can access variables from their enclosing scope.
This works correctly in the interpreter but fails during C code generation - the
outer variables are not captured/passed to the nested function.

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug50.til
#+END_SRC

*** Error Output
#+BEGIN_EXAMPLE
gen/c/test/bug50.c: In function 'til_test_closure_inner':
gen/c/test/bug50.c:1703:12: error: 'til_outer_var' undeclared (first use in this function)
#+END_EXAMPLE

*** Root Cause
In ccodegen, when emitting nested functions, variables from the outer scope (s1, s2,
silabes) are referenced but not passed as parameters or captured in a closure struct.

*** Potential Solutions

**** 1. Lambda Lifting (Recommended)
Transform nested functions into top-level functions, adding captured variables as
explicit parameters. The compiler would:
- Analyze which outer variables are referenced inside the nested function
- Add those as extra parameters to the lifted function
- At call sites, pass the captured variables explicitly

Pros: Simple, no runtime overhead, matches how TIL already handles explicit params
Cons: Recursive nested functions need care (captured vars passed through each call)

**** 2. Closure Struct
Create a struct containing all captured variables, pass pointer to nested function:
#+BEGIN_SRC c
struct poem_closure { Str s1; Str s2; };
Str poem(I64 depth, Str current, struct poem_closure* ctx) {
    // use ctx->s1, ctx->s2
}
#+END_SRC

Pros: Clean abstraction, single extra parameter regardless of capture count
Cons: Slightly more complex codegen, minor indirection overhead

**** 3. GCC Nested Functions Extension
GCC supports nested functions as a non-standard extension. We could use this directly.

Pros: Zero codegen changes for nested function bodies
Cons: GCC-only (not clang/MSVC), uses trampolines (executable stack), less portable

**** 4. Restrict Nested Function Captures (CHOSEN)
Disallow nested functions from capturing outer variables - require explicit parameters.
This is a language design change rather than a fix.

Pros: Simpler language semantics, no closure machinery needed
Cons: Breaking change, less ergonomic for users

*** Fix (2025-12-27)
Added =is_closure_capture()= function to ScopeStack (init.rs/init.til) that detects
when a symbol access would require closure capture. In typer (typer.rs/typer.til),
when an identifier is found to be a closure capture, emit a todo_error:
"Closures are not supported yet. Pass 'varname' as a parameter instead."

Full closure support deferred to post.org.

*** Files Modified
- src/rs/init.rs: Added =is_closure_capture()= to ScopeStack
- src/rs/typer.rs: Added closure capture check in NodeType::Identifier handling
- src/self/init.til: Ported =is_closure_capture()=
- src/self/typer.til: Ported closure capture check
- src/examples/lolalalo.til: Fixed to pass captured vars as explicit parameters
- src/test/bug50.til: Regression test (expected to fail with todo_error)

*** Historical: Lambda Lifting Attempt (2025-12-19, abandoned)
Before choosing option 4, started "Phase A: Const Args by Reference" in =wio= branch
as a prerequisite for lambda lifting. This is no longer needed since we chose to
forbid closures instead of implementing them.

Phase A completed items (for reference if lambda lifting is revisited):
- emit_func_signature: all non-copy params now const Type*
- by_ref calculations: changed from is_mut to !is_copy (7 locations)
- current_ref_params: now includes all non-copy params
- Variadic handling: fixed in emit_fcall_name_and_args_for_throwing and emit_fcall
- Compound literals: added for number/string literals

Phase A remaining issue:
- Nested struct-returning function calls passed to by-ref params need hoisting
- Current hoisting only works at statement level (indent > 0)

** Bug #47: Self-hosted TIL interpreter fails with "NodeType.?" error
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-27
:IMPACT: ./bin/til interpret fails on any file
:STATUS: Fixed
:END:

*** Description
The compiled self-hosted TIL interpreter (./bin/til) fails immediately when trying
to interpret any file, including empty.til. The error occurs during core library
initialization (vec.til:63).

*** Error Message
#+BEGIN_EXAMPLE
Error during file execution: src/core/core.til:src/core/vec.til:63:63: til init ERROR: Identifiers can only contain identifiers, found 'NodeType.?'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Analysis
The "NodeType.?" indicates an invalid enum tag value is being read from memory.
This happens in init.til's =get_value_type= function when iterating over
=e.params= (a Vec of Expr) - some Expr has a corrupted NodeType field.

*** Bug Type
CODEGEN BUG - rstil works, compiled til fails. Per methodology: "interpret works
but run fails" = codegen issue in ccodegen.rs

*** Investigation Notes
- rstil interpret works fine, only til (compiled self-hosted) fails
- The error is consistent - always at vec.til:63 during init
- Struct sizes match between TIL calculation and C sizeof for Expr (288 bytes)
- Invalid NodeType tag value found: 840973088 (0x32202E32) - looks like ASCII data

*** Key Discovery (2025-12-19)
Added =Expr.to_str()= and debug prints to =get_value_type= in init.til.

The expression =self.ptr= at vec.til:63 is processed 3 times:
#+BEGIN_EXAMPLE
1st call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
2nd call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
3rd call: e.params = [Expr{NodeType.?, ...}]         <- CORRUPTED
#+END_EXAMPLE

*Critical*: The corruption is visible in =e.to_str()= BEFORE iterating over params.
This means corruption happens BETWEEN calls to get_value_type, not during the
for-in loop or Vec.get. Something external is corrupting the Expr data.

*** What Was Ruled Out
- Bug #52 (static buffer in ext.c) - fixed, didn't solve this
- Bug #53 (missing null termination in str.til) - fixed, didn't solve this
- for-in vs while+Vec.get - both show same corruption

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug47.til  # PASS
./bin/til interpret src/test/bug47.til    # FAIL with NodeType.?
#+END_SRC

The test file (src/test/bug47.til) calls check_types directly without
using interpret_file, isolating the bug to the typer code path.

*** Notes
Bug #52 and #53 were discovered while investigating this issue. Both are now fixed
but did not resolve the NodeType memory corruption.

*** Narrowed Down Location (2025-12-19)
The corruption happens in =check_types_with_context= function in typer.til:
- Specifically in the =NodeType.Identifier(name)= case (lines 237-272)
- Around the =lookup_symbol= call (lines 259-265)

Call tracing showed:
- get_value_type calls #477 and #478 share the same =params.ptr=
- Call #477 sees valid data: =self.ptr line=63=
- Call #478 sees corrupted data: =? line=26726118198=
- Corruption happens BETWEEN these calls, during check_types_with_context

*** Debug Strategy
To find the exact line causing corruption:
1. Add debug print with =e.to_str()= after EVERY line in check_types_with_context
2. Run test once
3. Find where output changes from valid to corrupted

*** Minimal Reproducer (2025-12-26)
Found a minimal reproducer in =src/test/bug47.til=:

#+BEGIN_SRC til
mode test
import("self.builder")

run_it := proc(path: Str) throws Str, AllocError {
    mut args := Vec.new(Str)
    _ := run_file(path, args)
}

wrapper := proc() {
    run_it("src/examples/empty.til")
    catch (err: Str) { println(err) }  // Using 'err' triggers bug
    catch (err: AllocError) { }
}

wrapper()
#+END_SRC

Key finding: The bug only triggers when the caught error variable =err= is actually
USED inside the catch block (e.g., =println(err)=). An empty catch block or one that
doesn't reference =err= does NOT trigger the bug.

Reproduce:
#+BEGIN_SRC bash
./bin/rstil run src/test/bug47.til  # FAILS with NodeType.?
#+END_SRC

*** What Triggers vs What Doesn't
| Catch block code         | Result   |
|--------------------------+----------|
| catch (err: Str) { }     | Works    |
| catch (err: Str) { println("Error") } | Works |
| catch (err: Str) { println(err) }     | BUG    |

This suggests the bug is related to how the caught error variable is stored/accessed
in the generated C code when used inside the catch block body.

*** Fix (2025-12-27)
Removed 4 =id_params.delete()= calls in typer.til (lines 2657, 2694, 2699, 2704).

The issue was that =id_params= was a shallow clone of expression params, and
=extra_arg_e= (used in UFCS transformation) still referenced memory owned by
=id_params=. When =id_params.delete()= was called, it freed memory that
=extra_arg_e= was still using, causing memory corruption.

Note: ./bin/til still segfaults on other issues, but the NodeType.? error is fixed.
The test src/test/bug47.til now passes in rs_common (both interpret and run).

** Bug #56: Interpreter rejects FCall in enum payload inside func/proc
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Workaround required for clone calls in enum constructors
:STATUS: Fixed
:END:

*** Description
When constructing an enum with a payload that is a function call (FCall),
the interpreter rejected it with "Struct payload must be a variable identifier
or literal, got FCall". This only happened inside func/proc bodies - top level
declarations worked fine. Compiled mode also worked fine.

*** Root Cause
In interpreter.rs, the match statement handling struct payloads (for enum
variants) only handled Identifier and Literal node types, not FCall. Top-level
worked because it used a different code path.

*** Fix
Added a case for NodeType::FCall when the struct type is "Str". The fix creates
a temporary variable to hold the FCall result, then uses that variable name
as the payload. This mirrors what the existing Identifier and Literal handlers do.

Changes made:
- interpreter.rs: Added FCall case for Str payloads in enum variant construction
- interpreter.til: Ported fix to TIL self-hosted implementation
- Also fixed error message from "Struct payload" to "Enum variant payload"

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug56.til
# Output: All tests passed
#+END_SRC

** Bug #57: continue in for loops causes infinite loop
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Must use while loops instead of for when continue is needed
:STATUS: Fixed
:END:

*** Description
The ~continue~ statement caused infinite loops when used in ~for~ loops.
This happened because ~for~ desugars to ~while~ with the loop variable increment
at the END of the body. ~continue~ skips the rest of the body including the
increment, causing the loop variable to never change.

*** Root Cause
The parser desugars ~for i in 0..N { body }~ to:
#+BEGIN_SRC til
mut i := 0
while lt(i, N) {
    body
    i.inc()  // increment at END
}
#+END_SRC

When ~continue~ is in the body, it jumps to the while condition check,
skipping ~i.inc()~.

*** Fix
Transform continue statements to include the step expression before the continue.
The transformation replaces ~continue~ with ~{ i.inc(); continue }~.

This ensures the loop variable is always incremented/decremented before jumping
to the condition check, regardless of whether continue was used.

Changes made:
- parser.rs: Added ~transform_continue_with_step~ helper, applied to range-based for loops
- precomp.rs: Same fix for collection-based for-in loops
- parser.til, precomp.til: Ported fixes to TIL self-hosted implementation

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug57.til
# Output: Bug #57 test passed: continue in for loops works correctly
#+END_SRC

** Bug #55: C codegen generates wrong code for throwing function calls inside struct literals
:PROPERTIES:
:DISCOVERED: 2025-12-26
:FIXED: 2025-12-26
:IMPACT: C compile error, blocks removing legacy .new() methods
:STATUS: Fixed
:END:

*** Description
When a function that throws (uses out-parameter calling convention in C) is called
inside a struct literal field initializer, the C codegen generates incorrect code
with 1 argument instead of 3 (out-param + error-param + actual args).

*** Example
#+BEGIN_SRC til
Item := struct {
    mut name: Str = ""
    mut count: I64 = 0
}

test := proc() {
    original := "hello"
    // Bug: clone() inside struct literal generates wrong C code
    items.push(Item(name=original.clone(), count=42))
}
#+END_SRC

*** Generated C (incorrect)
#+BEGIN_SRC c
til_Item _tmp = (til_Item){.name = til_Str_clone(til_original), .count = 42};
// ERROR: til_Str_clone expects 3 args: (til_Str* _ret, til_AllocError* _err, til_Str self)
#+END_SRC

*** Expected C (correct)
#+BEGIN_SRC c
til_Str _cloned_name;
til_AllocError _err;
if (til_Str_clone(&_cloned_name, &_err, til_original)) { /* handle error */ }
til_Item _tmp = (til_Item){.name = _cloned_name, .count = 42};
#+END_SRC

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug55.til
# Previously: ERROR: gcc failed: too few arguments to function 'til_Str_clone'
# Now: passes
#+END_SRC

*** Root Cause
In ~hoist_throwing_args~, non-FCall arguments (like NamedArg nodes inside struct
literals) were not being processed. When ~items.push(Item(name=original.clone()))~
was passed, the struct literal's arguments are NamedArg nodes, and these fell
through the if/else-if chain without being processed, so the throwing call inside
the NamedArg never got hoisted.

*** Fix
Added an else clause at the end of ~hoist_throwing_args~ to call ~hoist_throwing_expr~
for non-FCall arguments. This ensures throwing calls inside named args (and other
non-FCall expression types) are properly hoisted.

Files changed:
- src/rs/ccodegen.rs: Added else clause in hoist_throwing_args
- src/self/ccodegen.til: Same fix ported
- src/test/bug55.til: Test case added to rs_common

** Bug #42: Temp variable naming inconsistency causes undeclared _tmp_N errors
:PROPERTIES:
:DISCOVERED: 2025-12-17
:FIXED: 2025-12-26
:IMPACT: Compilation fails
:STATUS: Fixed
:END:

*** Description
After commit 5707c2d (Make _for_i_ variable names deterministic), some code paths generate temp variables with old-style names (_tmp_N) while others use new-style names (_tmp_funcname_N). This causes gcc errors for undeclared variables.

#+BEGIN_EXAMPLE
gcc error: '_tmp_13' undeclared (first use in this function)
In til_Vec_clone:
til_Vec til_cloned = {..., .ptr = _tmp_13, ...};
#+END_EXAMPLE

*** Root Cause
~emit_struct_func_body~ (ccodegen.rs:2527-2597) did NOT set ~current_function_name~
before emitting the function body, while regular functions did. This caused struct
methods like ~Array.new~, ~Array.get~, ~Vec.clone~ to generate temp names like
~_tmp_0~ instead of ~_tmp_Array_new_0~.

*** The Fix
Added save/set/restore pattern for ~current_function_name~ and ~mangling_counter~
in ~emit_struct_func_body~, matching the pattern used for regular functions.

Also fixed TIL's ~next_mangled~ to include function name prefix (was missing entirely).

*** Files Modified
- src/rs/ccodegen.rs: Added current_function_name handling to emit_struct_func_body
- src/self/ccodegen.til: Same fix + updated next_mangled to include function prefix

** Bug #54: Pure functions that throw are not folded at compile time
:PROPERTIES:
:DISCOVERED: 2025-12-20
:FIXED: 2025-12-26
:IMPACT: Missed compile-time error detection, deferred to runtime
:STATUS: Fixed
:END:

*** Description
Pure functions with ~throws~ in their signature are not evaluated at compile
time, even when called with literal arguments. This prevents catching errors
at compile time that could be detected during precomputation.

*** Example
#+BEGIN_SRC til
always_throws := func(n: I64) returns I64 throws Str {
    if gt(n, 0) {
        throw "intentional error"
    }
    return 0
}
x := always_throws(5)  // Should fail at compile time, but runs at runtime
#+END_SRC

*** Reproducing
See ~src/test/precomp_throw.til~ - the test is expected to fail at precomp time
but currently reaches runtime instead.

*** Root Cause
In commit 9a79e93c (Dec 11, 2025), a check was added to ~is_comptime_evaluable~
that blocks folding for any function with throw_types:

#+BEGIN_SRC rust
// src/rs/precomp.rs lines 265-269
if !func_def.throw_types.is_empty() {
    return false;
}
#+END_SRC

Before this change, the comment said: "Functions that can throw are allowed -
if they actually throw, we'll report the error in eval_comptime"

The ~eval_comptime~ function already has infrastructure to handle thrown
exceptions (lines 291-296) and report them as precomp errors.

*** Solution
Removed the blanket throw_types check. Now only functions throwing ~AllocError~,
~IndexOutOfBoundsError~, or ~KeyNotFoundError~ are excluded (these depend on runtime state).
Other throwing functions are evaluated at compile time, and if they throw, the exception
is caught by ~eval_comptime~ and reported as a compile-time error.

*** Fix Details
Part of the precomp overhaul (see doc/todo/precomp_overhaul.org):
- Modified ~is_comptime_evaluable~ to only exclude specific runtime-dependent error types
- Added is_proc() check and return_types.is_empty() check
- Added U8 support in ~eval_comptime~
- Many other structural improvements to make precomp work like interpreter

** Bug #48: Typer missing validation that mut arguments must be lvalues
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: No clear error message when passing literals to mut params
:STATUS: Fixed
:END:

*** Description
The typer phase is missing a validation check: arguments to =mut= parameters
must be lvalues (identifiers or field access). This affects both interpreter
and compiler paths - both should catch this in the typer phase.

*** Example
#+BEGIN_SRC til
test_mut := proc(mut n: I64) {
    n = 99
}
test_mut(42)  // Should be rejected by typer
#+END_SRC

*** Fix Applied (2025-12-18, commit ae0b5eb)
Added =NodeType::LLiteral= case in =check_fcall= to reject literals passed to
mut parameters. Error message: "Cannot pass literal to mut parameter 'X'. Use
a variable instead."

*** Files Modified
- src/rs/typer.rs: Added LLiteral case in is_mut check
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug48.til with expected_status=1

*** Regression Test
src/test/bug48.til (expects exit code 1 - type error)

** Bug #49: Typer missing use-after-move check for own parameters
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-20
:IMPACT: Compiled code allows use of moved variable
:STATUS: Fixed
:END:

*** Description
When a variable is passed to an =own= parameter, the variable should be
invalidated in the caller's scope. The interpreter catches this at eval time,
but the typer doesn't track it - so compiled code allows using the variable.

*** Example
#+BEGIN_SRC til
consume := proc(own n: I64) returns I64 {
    return mul(n, 2)
}

test := proc() {
    mut x := 42
    result := consume(x)
    println(I64.to_str(x))  // Should be rejected - x was moved
}
#+END_SRC

*** Expected Behavior
Typer should reject use of =x= after it was passed to =own= parameter:
"Variable 'x' was moved and can no longer be used"

*** Actual Behavior
- Typer: No tracking of moved variables (the bug)
- Interpreter: Catches at eval - "Undefined symbol 'x'" (wrong phase)
- Compiler: No catch at all - x still usable with original value

*** Fix Applied (2025-12-20)
In typer's =check_fcall= function, after all type checking for an argument is complete,
if the parameter has =is_own= and the argument is a simple identifier, remove the
symbol from scope using =context.scope_stack.remove_symbol()=.

Key insight: The removal must happen AFTER =get_value_type= is called on the argument,
not before - otherwise the type lookup fails for the current argument.

*** Files Modified
- src/rs/typer.rs: Added remove_symbol call at end of argument loop in check_fcall
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug49.til with expected_status=1

*** Regression Test
src/test/bug49.til (expects exit code 1 - type error)

*** Related
- Bug #48: Similar issue for =mut= parameters (lvalue check)
- See doc/ownership.org for full ownership design

** Bug #34: Code after catch blocks doesn't run in error path
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

*** Description
Code placed AFTER catch blocks doesn't run when an error is caught.

*** Example
#+BEGIN_EXAMPLE til
throwing_call()
between = true      // Between throw and catch - correctly skipped on error
catch (err: Error) {
    // error caught
}
code_after_catch()  // Now runs correctly in both success and error paths
#+END_EXAMPLE

*** Root Cause
In the C code generator, statements after the last catch block were emitted BEFORE
the ~goto _end_catches~ jump, so they only ran on the success path.

*** Complete Fix (2025-12-15, commit 9781c41)
The initial partial fix used emit_expr directly for statements after the last
catch block. However, emit_expr doesn't do throwing call detection, causing
throwing functions like Vec.push to be emitted without error parameters.

The complete fix:
1. Find the index of the last catch block in emit_stmts
2. Only emit statements up to and including the last catch in the main loop
3. After emitting _end_catches label, call emit_stmts recursively for remaining
   statements - this properly handles throwing calls with error detection and
   goto labels

*** Files Modified
- src/rs/ccodegen.rs: emit_stmts recursive call for statements after last catch
- src/self/ccodegen.til: Same fix ported
- src/test/errors.til: Regression test (test_bug34)

** Bug #46: Infinite loop in typer.til due to catch catching later throw
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: til interpret/run hangs indefinitely
:STATUS: Fixed
:END:

*** Description
When running =./bin/til interpret= or =./bin/til run=, the self-hosted compiler hangs
in an infinite loop. Debug output shows "struct_found=true" printing infinitely in
typer.til's struct/enum lookup code.

*** Root Cause
In typer.til around lines 2500-2520, a catch block catches a throw that comes AFTER it
lexically, creating an infinite loop:

#+BEGIN_EXAMPLE til
// typer.til lines ~2500-2520 (approximate)
struct_def = context.scope_stack.lookup_struct(combined_name)
struct_found = true
catch (err: KeyNotFoundError) {  // Line ~2508 - catches lookup_struct errors
    // Struct not found, continue to enum check
}

if struct_found {
    // Line ~2515 - THIS throw gets caught by the catch at line ~2508!
    throw KeyNotFoundError(msg=format("Struct instantiation: ", combined_name))
}
#+END_EXAMPLE

The flow:
1. lookup_struct throws KeyNotFoundError
2. Catch at ~2508 handles it, struct_found remains false
3. Code continues, struct_found is set true later
4. Throw at ~2515 is caught by the catch at ~2508 (wrong!)
5. Execution continues after catch, loops back, struct_found=true prints
6. Infinite loop

*** Expected Behavior
The throw at line ~2515 should propagate UP to the caller, not be caught by
the catch at ~2508 which is meant only for lookup_struct errors.

*** Actual Behavior
The catch block's scope extends beyond just the lookup_struct call, incorrectly
catching throws that come after it in the source code.

*** Reproducing Test
src/test/bug46.til - Passes with interpreter, fails with compiler:
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug46.til  # PASS
./bin/rstil run src/test/bug46.til        # FAIL - Bug #46 present
#+END_SRC

Self-hosted compiler hangs:
#+BEGIN_SRC bash
timeout 30 ./bin/rstil build src/til.til && timeout 10 ./bin/til interpret src/examples/empty.til
# Times out (exit code 124)
#+END_SRC

*** Related
- Bug #34: Code after catch blocks doesn't run in error path (partially fixed)
- Bug #39: Non-consecutive catches fail (fixed)
- Bug #44: Codegen missing status check after blocks with catches (fixed)

All these bugs relate to catch block scope/semantics in generated C code.

*** Fix Applied (2025-12-18)
The issue was in ccodegen's emit_stmts function. When processing catch blocks,
they were added to =local_catch_labels= at the START of statement processing.
This meant ALL throws anywhere in the function could jump to ANY catch, even
catches that appeared BEFORE the throw lexically.

The fix: After emitting a catch block, remove it from =local_catch_labels=.
This ensures only throws that come BEFORE a catch can use it, mirroring the
interpreter's behavior where =pending_throw= is set by statements and only
subsequent catches can handle it.

*Rust* (src/rs/ccodegen.rs lines 3149-3153):
#+BEGIN_SRC rust
// Bug #46 fix: Remove this catch from local_catch_labels
// Catches should only handle throws from BEFORE them, not after.
ctx.local_catch_labels.remove(err_type_name);
#+END_SRC

*TIL* (src/self/ccodegen.til lines 4551-4555):
#+BEGIN_SRC til
// Bug #46 fix: Remove this catch from local_catch_labels
ctx.local_catch_labels.remove(err_type_name)
#+END_SRC

*** Files Modified
- src/rs/ccodegen.rs: Added removal of catch from local_catch_labels after processing
- src/self/ccodegen.til: Same fix ported

** Bug #45: init.til uses invalid fallthrough switch syntax
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Functions not registered - til fails with "Undefined symbol 'sub'"
:STATUS: Fixed
:END:

*** Description
init.til incorrectly uses C-style switch fallthrough syntax, which TIL does not support.
TIL requires each case to have its own body - there is no fallthrough.

This causes functions (FTFunc, FTProc, etc.) to not be registered in init_context, since
only the FTMacro case has the declare_func call.

*** Wrong TIL Source (init.til lines 1466-1474)
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
case FunctionType.FTFuncExt:
case FunctionType.FTProc:
case FunctionType.FTProcExt:
case FunctionType.FTMacro:
    // WRONG: only FTMacro case has the body!
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Correct TIL (bodies must be repeated)
Per doc/translate_rs2til.org lines 39-50, TIL requires separate case arms:
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTFuncExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProcExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTMacro:
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Root Cause
Translation error from Rust to TIL. Rust uses | to combine patterns, TIL requires
repeated bodies. See doc/translate_rs2til.org for the translation rules.

*** Fix Applied (2025-12-18)
Fixed init.til lines 1465-1511 to repeat the switch body for each FunctionType case:
- FTFunc, FTFuncExt, FTProc, FTProcExt, FTMacro all now have identical bodies
- Each case calls declare_symbol and declare_func

Searched all other .til files in src/self/ for similar patterns - none found.
Other consecutive case patterns are either:
1. Cases with bodies on same line (e.g., `case X: return "x"`)
2. Intentional "do nothing" cases with comments (e.g., skip primitives I64/U8/Str)

** Bug #44: Codegen missing status check for throwing call after block with catches
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: Wrong code execution - statements after throwing call run when they shouldn't
:STATUS: Fixed
:END:

*** Description
When a throwing function call is followed by catch, but there's a preceding block
(if/switch) that also contains catches, the status check for the later throwing call
is sometimes missing from the generated C code.

This causes the "func 'Bool' returns multiple values" error when til processes
bool.til, because get_fcall_value_type incorrectly finds Bool as a function (due
to lookup_func not properly short-circuiting on KeyNotFoundError).

*** Example Problem
#+BEGIN_EXAMPLE til
test_func := func() returns I64 throws Str {
    // Block with catches
    if true {
        mut val := maybe_throw_A(false)
        catch (err: ErrorA) { }
    }

    // After the block - status check is MISSING for this call!
    mut found := false
    mut result := maybe_throw_C(true)  // This throws
    found = true  // BUG: This runs even though C threw!
    catch (err: ErrorC) { }

    if found { throw "found should be false!" }
    return 0
}
#+END_EXAMPLE

*** Generated C Code (broken)
The call at line 10488 in til.c is missing the status check:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
// MISSING: if (_status_... == 1) { goto _catch_...; }
til_standalone_func_def = _ret_...;
til_found_standalone = true;  // Runs unconditionally!
if (0) { _catch_KeyNotFoundError_...: ... }
#+END_EXAMPLE

Compare with line 24060 which is correct:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
if (_status_... == 1) { _thrown_... = _err0_...; goto _catch_...; }  // Correct!
til_func_def = _ret_...;
#+END_EXAMPLE

*** Root Cause (Likely)
In ccodegen.rs, the `local_catch_labels` map is being cleared/repopulated
incorrectly when processing blocks with catches, causing the catch for the
later throwing call to not be registered when the call is processed.

The bug affects get_fcall_value_type in init.til (line 651) but NOT
is_expr_calling_procs in typer.til (same pattern, but generates correctly).

*** Reproducing Test
src/test/bug44.til

*** Files to Investigate
- src/rs/ccodegen.rs: emit_stmts, local_catch_labels handling
- Specifically the logic at lines 3215-3233 where next_catches is built
- Compare what's different about init.til vs typer.til that causes only one to fail

** Bug #43: Map.get returns wrong value when Map is field inside struct (rstil interpreter)
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Data corruption in interpreter
:STATUS: Fixed
:END:

*** Description
When a Map is stored as a field inside a struct, the rstil interpreter's Map.get returns incorrect values (0 instead of actual stored value). The compiled version (rstil run) works correctly.

*** Example Problem
#+BEGIN_EXAMPLE til
import("std.map")

Frame := struct {
    mut funcs: Map = Map.new(Str, I64)
}

test_map_in_struct := proc() {
    mut frame := Frame()
    frame.funcs.insert("test", 42)

    mut val := 0
    frame.funcs.get("test", val)
    println("Got value = ", val.to_str())  // BUG: prints 0, should print 42
}
#+END_EXAMPLE

*** Test Results (Before Fix)
- =rstil interpret tmp/test_scope_pattern.til= -> val = 0 (WRONG)
- =rstil run tmp/test_scope_pattern.til= -> val = 42 (CORRECT)

*** Root Cause
Three issues were discovered when structs have nested struct defaults like =Map.new(Str, I64)=:

1. *Vec.ptr not initialized*: When struct templates were created, ptr fields were
   skipped (to avoid dangling pointers), but Vec.push didn't check for ptr=0.
   This caused pushes to write to NULL memory when Vec was part of a struct default.

2. *Str fields not copied*: read_struct_primitive_fields only read I64/U8 values.
   Str fields like =key_type_name= weren't being read from the evaluated instance,
   causing Map to have empty type names and fail key comparisons.

3. *Vec.cap not preserved*: The Vec's capacity from Vec.new was lost because nested
   struct fields weren't being recursively read. This caused malloc(0) in Vec.push.

*** Fix Applied (2025-12-18)

*Part 1: Vec.push null pointer check* (src/core/vec.til lines 60-71)
Added check at start of push to allocate if ptr=0:
#+BEGIN_SRC til
if self.ptr.eq(0) {
    if self.cap.eq(0) {
        self.cap = Vec.INIT_CAP
    }
    self.ptr = malloc(mul(self.cap, self.type_size))
    if NULL.eq(self.ptr) {
        throw AllocError(msg=format(loc(), "Vec.push: malloc failed"))
    }
}
#+END_SRC

*Part 2: read_struct_primitive_fields* (src/rs/interpreter.rs lines 214-279)
New function that reads primitive values from evaluated struct instances:
- Reads I64 values (skipping ptr/c_string to avoid dangling pointers)
- Reads U8 values
- Reads Str values using string_from_context (gets actual string content)
- Recursively reads nested struct primitive fields (Vec, etc.)

*Part 3: eval_struct_defaults* (src/rs/interpreter.rs lines 303-319)
After getting static defaults for nested structs, override with actual primitive
values from the evaluated instance:
#+BEGIN_SRC rust
let primitive_values = read_struct_primitive_fields(ctx, &instance_id, type_name, "", e)?;
for (k, v) in primitive_values {
    defaults.insert(format!("{}.{}", decl.name, k), v);
}
#+END_SRC

*Part 4: TIL port* (src/self/interpreter.til lines 138-219, 304-316)
Same changes ported to the self-hosted interpreter.

*** Reproducing Test
src/test/bug43.til (now passes both interpret and run)

*** Files Modified
- src/rs/interpreter.rs: Added read_struct_primitive_fields, modified eval_struct_defaults
- src/rs/eval_arena.rs: Minor cleanup
- src/core/vec.til: Added null pointer check in Vec.push
- src/self/interpreter.til: Ported fix to TIL version

** Bug #40: Precomp generates non-deterministic _for_i_ variable names
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Build reproducibility
:STATUS: Fixed
:END:

*** Description
The precomp phase generates `_for_i_N` variable names for desugared for-in loops using a global counter (`Arena::g().temp_id_counter`). This counter accumulates across file compilations, causing the same source code to produce different C output depending on compilation order or what was compiled before.

#+BEGIN_EXAMPLE
// First compilation produces:
til_I64 _for_i_159 = 0;

// Second compilation (same source) produces:
til_I64 _for_i_160 = 0;
#+END_EXAMPLE

This makes diffs between generated C files noisy and harder to review.

*** Root Cause
In precomp.rs (line 422-424), the `_for_i_` index variable name is generated using a global singleton counter:

#+BEGIN_SRC rust
let forin_id = Arena::g().temp_id_counter;
Arena::g().temp_id_counter += 1;
let index_var_name = format!("_for_i_{}", forin_id);
#+END_SRC

Unlike ccodegen's `next_mangled()` which was fixed to reset per-function and include function name prefix, precomp still uses this global counter.

*** Related
- ccodegen's `_tmp_` variables were fixed to be deterministic (counter moved to CodegenContext, reset per-function, includes function name prefix)
- interpreter.rs also uses `Arena::g().temp_id_counter` for return instance names

*** Proposed Fix
Apply similar pattern as ccodegen fix:
1. Add function name context to precomp (track current function being processed)
2. Reset counter when entering each function in `precomp_func_def`
3. Include function name in generated variable name: `_for_i_funcname_N`

*** Files to Modify
- src/rs/precomp.rs: Add counter reset in precomp_func_def, modify index_var_name format
- src/self/precomp.til: Same changes ported

*** Fix Details
Added two new fields to Context:
- `current_precomp_func`: Tracks the current function being processed (Option<String> in Rust, Str in TIL)
- `precomp_forin_counter`: Per-function counter for _for_i_ variable names

Modified three functions:
1. `precomp_declaration`: Sets function name and resets counter BEFORE processing function body
2. `precomp_struct_def`: Sets function name for struct method definitions (default values)
3. `precomp_forin`: Uses context fields instead of global counter, generates names like `_for_i_funcname_N`

Files modified:
- src/rs/init.rs: Added fields to Context struct
- src/rs/precomp.rs: Bug #40 fix in precomp_declaration, precomp_struct_def, precomp_forin
- src/self/init.til: Added fields to Context struct
- src/self/precomp.til: Same fixes ported

Test: src/test/deterministic.til

** Bug #52: Static buffer in ext.c til_i64_to_str caused string corruption
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Multiple to_str() calls before println showed wrong values
:STATUS: Fixed
:END:

*** Description
When multiple =to_str()= calls happened before =println= (e.g., printing two numbers),
they all showed the same value - the last one converted. This was because all calls
shared the same static buffer.

*** Root Cause
The =til_i64_to_str= function in =src/ext.c= used a static buffer:
#+BEGIN_SRC c
static char buf[32];  // SHARED BY ALL CALLS!
snprintf(buf, sizeof(buf), "%lld", (long long)v);
#+END_SRC

Each =to_str()= call returned a Str pointing to this same buffer. When a second
call happened, it overwrote the buffer, making both Strs show the second value.

*** Fix
Changed =til_i64_to_str=, =til_input_read_line=, and =til_run_cmd= in =src/ext.c=
to allocate memory with =malloc()= instead of using static buffers.

*** Regression Test
src/test/bug52.til - tests reading global variables inside for-in loops
with multiple =to_str()= calls to detect buffer sharing issues.

*** Notes
Discovered while investigating Bug #47 (NodeType corruption). The static buffer
issue explained why debug output showed wrong values, but Bug #47 itself is a
different issue that remains open.

** Bug #53: String functions missing null termination
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Garbage characters in string output, potential memory corruption
:STATUS: Fixed (no regression test - see notes)
:END:

*** Description
String functions =clone()=, =concat()=, =format()=, and =replace()= in str.til
allocated memory without +1 for the null terminator and didn't write the null
byte. This caused garbage characters when strings were printed via C's printf.

*** Root Cause
All four functions used =malloc(cap)= instead of =malloc(cap.add(1))= and didn't
call =memset= to write the null terminator at position =cap=.

*** Fix Applied (2025-12-19)
Changed all four functions in src/core/str.til:
- =clone()=: malloc(cap.add(1)), memset null at cap
- =concat()=: malloc(cap.add(1)), memset null at cap
- =format()=: malloc(cap.add(1)), memset null at cap
- =replace()=: malloc(new_len.add(1)), memset null at cap

*** Regression Test
No regression test was created because the bug cannot be reliably reproduced in
a unit test. The issue only manifests when malloc returns memory with non-zero
bytes at position =cap= (outside the allocated region without the fix). Modern
allocators typically return zeroed memory, making the bug appear to not exist
even without the fix.

The bug was discovered during Bug #47 investigation when "NodeType.?" garbage
appeared in debug output. This occurred because the heap was heavily fragmented
during ./bin/til execution, causing non-zero bytes to appear at string boundaries.

*** Files Modified
- src/core/str.til: Fixed clone, concat, format, replace functions

** Bug #41: mode liba not respected when file is imported
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Debugging, purity rules
:STATUS: Fixed
:END:

*** Description
When a file with `mode liba` is imported into another file (e.g., `mode cli`), the purity rules of the importing file apply instead of the imported file's mode. This means `func` definitions in `mode liba` files cannot call `print`/`println` when imported, even though `mode liba` is supposed to allow print in funcs for debugging.

*** Root Cause
The typer phase's `typer_import_declarations` function only saved and restored `context.path` when type-checking imported files, but did not save and restore `context.mode_def`. This caused the importing file's mode to be used for type checking the imported file.

*** Fix Applied (2025-12-17)
Two-part fix:

1. *Store mode during init phase* (src/rs/init.rs, src/self/init.til):
   - Added `imported_modes: HashMap<String, ModeDef>` to Context struct
   - In `init_import_declarations`, store the imported file's mode alongside its AST

2. *Use stored mode during type checking* (src/rs/typer.rs, src/self/typer.til):
   - In `typer_import_declarations`, retrieve stored mode and set `context.mode_def`
   - Save and restore both `context.path` AND `context.mode_def`

Also added `ModeDef.clone()` method to src/self/mode.til for proper mode copying.

*** Test Coverage
Regression test: src/test/bug41.til

*** Files Modified
- src/rs/init.rs: Added imported_modes field, store mode during import
- src/rs/typer.rs: Save/restore mode_def in typer_import_declarations
- src/self/init.til: Same changes ported
- src/self/typer.til: Same changes ported
- src/self/mode.til: Added ModeDef.clone() method
- src/test/bug41.til: Regression test
- src/test/bug41_liba_helper.til: Helper file for test

** Bug #39: Non-consecutive catches fail - second catch never executes
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-16
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

Related: Bug #34 (same underlying goto structure issue)

*** Description
When a function has multiple throw+catch pairs separated by code, only the first catch works. The second catch block never executes because the code generator's goto structure jumps past subsequent throw+catch pairs after the first catch completes.

#+BEGIN_EXAMPLE til
throw_a_maybe(true)  // throws ErrorA
after_a_ran = true   // correctly skipped
catch (err: ErrorA) { caught_a = true }

throw_b_maybe(true)  // throws ErrorB - NEVER EXECUTES!
after_b_ran = true
catch (err: ErrorB) { caught_b = true }  // NEVER EXECUTES!
#+END_EXAMPLE

*** Root Cause
The C code generator groups ALL catches at the end with shared labels:

#+BEGIN_SRC c
if (_status_A == 1) { goto _catch_A; }
if (_status_B == 1) { goto _catch_B; }
goto _end_catches;

_catch_A: { ... goto _end_catches; }  // BUG: jumps PAST throw_b_maybe!
_catch_B: { ... }
_end_catches:;
#+END_SRC

After catching ErrorA, ~goto _end_catches~ jumps past the second throw+catch entirely. The second throwing call never executes.

*** Proposed Fix
Instead of shared goto labels, use if-else blocks for each throw+catch pair:

#+BEGIN_SRC c
// First throw+catch
int _status_A = call_a();
if (_status_A == 0) {
    after_a_ran = true;
} else if (_status_A == 1) {
    // catch A body
}

// Second throw+catch - executes regardless of first catch
int _status_B = call_b();
if (_status_B == 0) {
    after_b_ran = true;
} else if (_status_B == 1) {
    // catch B body
}
#+END_SRC

*** Files to Modify
- src/rs/ccodegen.rs: emit_stmts, emit_throwing_call_with_goto
- src/self/ccodegen.til: Same changes ported

*** Test Coverage
Tests added in src/test/errors.til:
- test_non_consecutive_catches
- test_caller_callee_different_throws
- test_multi_throw_single_catch
- test_multi_throw_success

*** Fix Applied
Key changes to ccodegen.rs and ccodegen.til:

1. **Call ~next_mangled()~ inside the loop, not before** - Previously called once
   before the loop, giving all catches the same suffix. Now called for EACH catch,
   so multiple catches of the same error type get different labels.

2. **Store statement index with each catch** - ~all_catch_info~ tracks
   ~(stmt_index, type_name, label, temp_var, catch_block)~ to match throwing
   calls to their NEXT catch by position in the source.

3. **Emit catches inline with ~if(0) { label: }~** - Instead of grouping all
   catches at the end with ~goto _end_catches~, catches are emitted inline where
   they appear. The ~if(0)~ block is skipped in normal execution but ~goto~ can
   jump into it. Execution falls through after the catch body.

4. **Update ~local_catch_labels~ before each throwing call** - Clear and rebuild
   with only catches AFTER current statement position. Each throwing call now
   jumps to its correct NEXT catch, not always the first one.

5. **Only use immediate-catch optimization when ~func_level_catches.is_empty()~** -
   Prevents inline handling when the catch is also needed by earlier throwing calls
   (which need the label to be emitted).

Also added ~Map.clear()~ method to src/std/map.til, and removed unused
~get_variant_payload_type~ function from init.rs.

** Bug #38: Vec.get doesn't preserve enum payload values
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When storing enums with payloads in a Vec and retrieving them with Vec.get, the enum tag is preserved but the payload value is corrupted.

#+BEGIN_EXAMPLE til
PayloadEnum := enum {
    None,
    Number: I64,
    Text: Str,
}

p := PayloadEnum.Number(42)
mut items := Vec.new(PayloadEnum)
items.push(p)

mut out := PayloadEnum.None
items.get(0, out)

// Expected: out is PayloadEnum.Number(42)
// Actual: out is PayloadEnum.Number(2745) - payload corrupted
#+END_EXAMPLE

*** Root Cause
When passing an enum constructor like `PayloadEnum.None` to a Dynamic parameter (as in Vec.push),
the argument binding code incorrectly identified `PayloadEnum` as a type identifier (because TEnumDef
is a TType) and stored just the type name string instead of the actual enum value. This caused the
enum data to not be inserted into the function frame, resulting in memcpy reading from garbage memory.

The issue was in interpreter.rs at the Dynamic/Type parameter handling: the code checked if the
identifier resolved to a TType but didn't check if the expression had params (field access).
`PayloadEnum.None` has params (the `.None` access), so it should NOT be treated as a bare type.

*** Fix
Added a check for `current_arg.params.is_empty()` before treating an identifier as a type identifier.
This ensures enum constructors like `PayloadEnum.None` fall through to normal enum handling.

Files changed:
- src/rs/interpreter.rs: Added params.is_empty() check in Dynamic/Type handling
- src/self/interpreter.til: Same fix ported to self-hosted version

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_payload() (enabled)

** Bug #37: Vec.push with direct enum constructor doesn't store data correctly :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When pushing an enum value directly using a constructor expression (e.g., `colors.push(SimpleColor.Red)`), the data is not stored correctly in the Vec. However, pushing via a variable works correctly.

#+BEGIN_EXAMPLE til
SimpleColor := enum { Red, Green, Blue }

mut colors := Vec.new(SimpleColor)

// This FAILS - data is corrupted:
colors.push(SimpleColor.Red)

// This WORKS:
c := SimpleColor.Red
colors.push(c)
#+END_EXAMPLE

*** Root Cause (Found)
The bug was in the interpreter's handling of Dynamic parameters. When an enum constructor expression like `SimpleColor.Green` was passed to a Dynamic parameter:

1. The parser creates an Identifier("SimpleColor") node with params [Identifier("Green")]
2. The interpreter checked if "SimpleColor" was a type reference (TType)
3. Since SimpleColor is an enum type definition, it matched as TType
4. The code incorrectly treated it as a bare type reference, storing "SimpleColor" as a string
5. This caused to_ptr(value) to return the wrong arena offset

*** Fix (2025-12-15)
Added check for `current_arg.params.is_empty()` before treating an identifier as a type reference:

*interpreter.rs (line 1938):*
#+BEGIN_SRC rust
if current_arg.params.is_empty() {
    if let Some(sym) = context.scope_stack.lookup_symbol(id_name) {
        if let ValueType::TType(_) = &sym.value_type {
            // Only treat as type reference if params are empty
        }
    }
}
#+END_SRC

*interpreter.til (line 2022):*
#+BEGIN_SRC til
if current_arg.params.len().eq(0) {
    // Only treat as type reference if params are empty
}
#+END_SRC

Workarounds in std/map.til were also removed - now uses Vec.push() directly.

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_direct_push() (enabled)

** Bug #35: Special `_` variable does not allow repeated declarations :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
The special `_` variable (used for discarding return values) throws "already declared" errors when used multiple times in the same scope.

#+BEGIN_EXAMPLE til
// This should work (both values are discarded):
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)  // ERROR: '_' already declared
#+END_EXAMPLE

*** Fix (2025-12-14)
Modified type checker and code generator to special-case "_" declarations:

*Type checker (init.rs, init.til):*
1. In =declare_var()=: Skip the "already declared in this scope" check when name is "_"
2. In =init_context()= Declaration handler: Skip the "already declared" check when name is "_"

*Code generator (ccodegen.rs, ccodegen.til):*
1. In =emit_constant_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
2. In =emit_global_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
3. In =emit_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
4. In =emit_variadic_call()=: Skip variable declaration entirely for "_", just emit the function call (2026-01-04)

This approach:
- Allows multiple "_" declarations in the same TIL scope
- Generates unique C variable names (like =_tmp0=, =_tmp1=) to avoid C redefinition errors
- Evaluates the RHS expression for its side effects (return value is discarded)

*** Now Works
#+BEGIN_EXAMPLE til
// Both values are discarded - no error
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)
#+END_EXAMPLE

*** Test Coverage
- src/test/underscore.til: Tests multiple "_" declarations at both top-level and function scope, including variadic function calls

*** Files Modified
- src/rs/init.rs: declare_var, init_context
- src/rs/ccodegen.rs: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call
- src/self/init.til: declare_var, init_context
- src/self/ccodegen.til: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call

** Bug #33: for-in loops don't work with enum collections
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:FIXED: 2025-12-15
:END:

*** Description
The for-in loop syntax doesn't work when iterating over collections of enum values (e.g., Vec<ValueType>).

#+BEGIN_EXAMPLE til
// This fails:
for val: ValueType in vec_of_valuetypes {
    // ...
}
#+END_EXAMPLE

*** Root Cause
The for-in desugaring in precomp.rs creates code like:

#+BEGIN_EXAMPLE til
for _for_i in 0..collection.len() {
    mut val := ValueType()    // <-- Problem: no parameterless constructor
    collection.get(_for_i, val)
    // body
}
#+END_EXAMPLE

For structs, `StructName()` creates a default-initialized instance. But enums don't have a parameterless constructor - all variants require payloads (e.g., `ValueType.TCustom(Str)`, `ValueType.TFunction(FunctionType)`).

*** Fix Applied
Changed for-in desugaring to detect when the iteration type is an enum and generate
an appropriate placeholder value using the first variant:
- For variants without payload: `EnumType.FirstVariant`
- For variants with payload: `EnumType.FirstVariant(default_payload)`

The placeholder value is immediately overwritten by the get() call, so any valid
variant works as an initializer.

*** Files Changed
- src/rs/precomp.rs: Added build_default_value() helper and updated precomp_forin()
- src/self/precomp.til: TIL port with build_default_value_for_forin() and updated precomp_forin()
- src/test/forin_enum.til: Regression test
- src/tests.til: Added forin_enum.til to test suite
- src/test/run_cmd.til: Updated directory list (bots/ removed, c/ and out/ added)

*** Affected Code
- src/self/typer.til: Converted for-in loops over ValueType to while loops
- src/self/ccodegen.til: Same workaround applied

** Bug #32: TIL doesn't support chained field access + method calls
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
TIL doesn't support chained field access followed by method calls like:
#+BEGIN_EXAMPLE til
lexer.peek().token_type.eq(TokenType.Colon)
#+END_EXAMPLE

This causes parse errors like:
#+BEGIN_EXAMPLE
Expected '(' after method name 'token_type', found 'Dot'
#+END_EXAMPLE

Or type errors like:
#+BEGIN_EXAMPLE
Cannot call 'peeked.token_type', it is not a function, it is 'TokenType'
#+END_EXAMPLE

*** Fix
Parser now handles field access after function/method calls by using
Identifier("_") as a marker where params[0] holds the base expression
and params[1..] holds the field chain. Changes in parser, init, typer,
interpreter, and ccodegen (both Rust and TIL).

Tests added to src/test/structs.til.

*** Affected Code
- src/self/parser.til: parse_for_statement (workaround removed)

** Bug #36: Throwing functions in struct literal parameters not recognized :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Type checker correctness
:STATUS: Fixed
:END:

*** Description
When calling a throwing function inside struct literal named parameters, the compiler failed to recognize that the function throws and incorrectly reported that the error type is never thrown.

*** Fix
Modified =check_body_returns_throws= in typer.rs/typer.til to:
1. Handle =NamedArg= nodes inside function call arguments
2. Check arguments of struct/enum constructors (=Ok(None)= / =KeyNotFoundError= case)
3. Track thrown types from nested function calls in both cases

*** Changes
- src/rs/typer.rs: Added NamedArg handling and struct constructor argument checking
- src/self/typer.til: Ported same fix from Rust
- src/std/map.til: Removed workaround (can now inline clone() calls)
- src/self/init.til: Added throws declarations to clone() functions
- src/test/errors.til: Regression test (test_bug36)

** Bug #31: Switch on struct field with pattern matching fails :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-06
:FIXED: 2025-12-06
:IMPACT: Self-hosting, pattern matching
:STATUS: Fixed
:END:

*** Description
When using =switch= on a struct field that is an enum (e.g., =switch s.color=), pattern matching with payload extraction failed with "Enum definition for 'StructName' not found" error.

*** Example Problem
#+BEGIN_EXAMPLE til
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)
    switch s.color {
    case Color.Number(n): result = n  // FAILED: Enum definition not found
    case: result = 0
    }
}
#+END_EXAMPLE

*** Root Cause
Two issues in interpreter and arena code:

1. *Pattern matching code extracted only base identifier* (interpreter.rs:390-394):
   When processing =switch s.color=, the code only extracted "s" from =to_switch.node_type= instead of constructing the full path "s.color".

2. *get_enum didn't resolve field types* (arena.rs:764+):
   =get_enum= looked up the base variable's type instead of the field's type. For "s.color", it got =StructWithPayloadEnum= instead of =Color=.

*** Fix (2025-12-06)
*Rust side:*

1. *interpreter.rs*: Modified pattern matching code to construct full field path from to_switch expression params:
#+BEGIN_SRC rust
let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
    if !to_switch.params.is_empty() {
        let mut full_path = name.clone();
        for param in &to_switch.params {
            if let NodeType::Identifier(field_name) = &param.node_type {
                full_path.push('.');
                full_path.push_str(field_name);
            }
        }
        full_path
    } else {
        name.clone()
    }
} else { /* error */ };
#+END_SRC

2. *arena.rs*: Modified =get_enum= to use =get_field_type= for dotted paths:
#+BEGIN_SRC rust
let enum_type = if id.contains('.') {
    match ctx.get_field_type(id) {
        Ok(ValueType::TCustom(type_name)) => type_name,
        // ... error handling
    }
} else {
    // original lookup_symbol logic
};
#+END_SRC

3. *init.rs*: Added =get_field_type= function to resolve the ValueType for a field path.

*TIL side:*
- Ported same changes to interpreter.til, arena.til, and init.til

*** Test Coverage
- src/test/enums.til: =test_switch_on_struct_field= (simple switch on field)
- src/test/enums.til: =test_switch_on_struct_field_with_payload= (pattern matching with payload)

** Bug #30: ext_proc signature mismatch between TIL and Rust :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-03
:FIXED: 2025-12-03
:IMPACT: Type safety
:STATUS: Fixed
:END:

*** Description
=single_print= was incorrectly declared as variadic (=..Str=) in TIL, but =proc_single_print= in ext.rs expects exactly 1 argument.

*** Problem
#+begin_src til
// Wrong declaration (variadic):
single_print := ext_proc(args: ..Str);

// Both pass type check AND runtime (variadic wraps args into Array):
single_print("one")        // Works: Array with 1 element
single_print("one", "two") // Also "works": prints Array representation
#+end_src

*** Why It Wasn't Caught
Variadic parameters get wrapped into an Array before being passed to ext.rs. So =validate_arg_count= sees 1 argument (the Array), passing validation. The function then prints whatever =result.value= is - which would be the Array's string representation instead of the expected Str.

*** Fix (2025-12-03)
1. Changed declaration from variadic to single parameter in core.til:
#+begin_src til
// Correct declaration:
single_print := ext_proc(s: Str);
#+end_src

2. Added warning comment to =proc_single_print= in ext.rs referencing Bug #30.

*** Systemic Issue
The compiler cannot verify that ext_proc TIL declarations match their Rust implementations. Variadic wrapping bypasses =validate_arg_count= by passing all args as a single Array. This is an inherent FFI limitation.

** Bug #28: UFCS fails inside pattern match case bodies with bindings :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-02
:FIXED: 2025-12-02
:IMPACT: Self-hosting, type checking
:STATUS: Fixed
:END:

*** Description
UFCS method calls failed with "Could not find function definition" when inside pattern match case bodies that have bindings (e.g., =case Enum.Variant(binding):=).

*** Root Cause
The =check_body_returns_throws= function ran without proper scope tracking:
1. Pattern binding variables weren't declared in the scope
2. Local variables declared within case bodies weren't visible

*** Fix (2025-12-02)
Added proper scope management to =check_body_returns_throws= in =typer.rs=:

1. *Pattern binding scope*: When processing switch cases with pattern bindings, push a Block scope and declare the binding variable with its payload type (mirrors =check_switch_statement=).

2. *Variable declarations*: When processing Declaration nodes, infer the type from the initializer and declare the variable in the current scope (if not already declared).

Files modified:
- =src/rs/typer.rs= lines 767-825 (NodeType::Switch handler)
- =src/rs/typer.rs= lines 828-845 (NodeType::Declaration handler)

*** Test Coverage
- =src/test/ufcs.til=: =test_ufcs_struct_field_in_pattern_match=
- =src/test/enums.til=: =test_bug28_ufcs_push_in_binding=, =test_bug28_ufcs_len_in_binding=

All tests pass.

** Bug #29: Catch variable not accessible in arena :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-19
:FIXED: 2025-11-19
:IMPACT: Error handling, catch blocks
:STATUS: Fixed
:END:

*** Description
Caught error variable (=err=) not properly stored in execution arena. Accessing =err.msg= in catch block caused:
- Type error: "Undefined symbol 'err'"
- Runtime error: "base variable 'err' not found in arena_index"

Affected: =throw err.msg=, =return err.msg=, =msg = err.msg= - any field access on caught errors.

*** Fix (2025-11-19, commit 0024caa)
Properly register catch parameter in both interpreter and typer:
- =interpreter.rs=: Register base variable when propagating throws (line 3020) and in catch fallback (line 2438)
- =typer.rs=: Create temp_context with catch parameter before type-checking catch body (lines 665-692)

*** Test Coverage
- =src/test/errors.til=: =test_rethrow_error_field= (tests =throw err.msg=)
- =src/test/errors.til=: =test_rethrow_error_field_via_assign= (tests =msg = err.msg= then =throw msg=)

** Bug #1: Enum Comparison in Switch/Case

- *Status*:  NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*:  NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*:  FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*:  FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*:  FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*:  FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*:  FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*:  FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     //  Prints
    lexer.expect(TokenType.LeftParen)      //  Causes function to return!
    println("[DEBUG 2] After expect")      //  Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
//  Capture the return value
result := my_add(1, 2)

//  Use as argument to another function
double(my_add(3, 4))

//  Explicitly discard with _
_ := get_value()

//  Procs don't return values, no capture needed
print_hello()

//  ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*:  FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

** Bug #27: Cannot inline Vec.new() as function argument :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-18
:FIXED: 2025-11-18
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
The TIL evaluator cannot handle inline Vec.new(Expr) calls when passed as arguments to functions. This requires creating a variable first instead of passing the expression directly.

*** Example Problem
#+BEGIN_EXAMPLE til
// Rust does (parser.rs:1180):
return Ok(Expr::new_explicit(
    NodeType::Pattern(pattern_info),
    Vec::new(),  // Inline Vec::new() works
    left.line,
    left.col
));

// TIL must do (parser.til:1326-1330):
empty_params := Vec.new(Expr)  // Create variable first
return Expr.new_explicit(NodeType.Pattern(pattern_info), empty_params, left.line, left.col)
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil eval ERROR: Struct argument must be an identifier or field access
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 1780-1796

When evaluating function calls with struct arguments, the evaluator checks if the parameter is marked as 'own'. For non-own struct parameters, it requires the argument to be an identifier or field access (not an arbitrary expression).

The 'params' parameter in Expr.new_explicit is declared as 'params: Vec' (not 'own Vec'), so inline expressions like Vec.new(Expr) are rejected.

*** Fix (2025-11-18)
Modified interpreter.rs to allow non-identifier expression arguments for struct parameters:

1. Lines 1778-1782: For field access chains with expressions, use result_str
2. Lines 1787-1795: For simple expressions (like Vec.new()), use result_str
3. Lines 1899-1904: For non-Identifier node types, allocate struct and copy fields from result_str

The key insight: when an expression is evaluated (like Vec.new(Expr)), the result
is allocated in the arena and result_str contains the identifier. We can use this
to copy the struct to the parameter, just like we do for identifier arguments.

*** Now Works
#+BEGIN_SRC til
// Can inline Vec.new(Expr) directly as argument
return Expr.new_explicit(NodeType.Pattern(pattern_info), Vec.new(Expr), left.line, left.col)
#+END_SRC

*** Previous Workaround (No Longer Needed)
#+BEGIN_SRC til
// Old workaround - create variable first
empty_params := Vec.new(Expr)
return Expr.new_explicit(..., empty_params, ...)
#+END_SRC

** Bug #26: Nested struct corruption in Vec/Map :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-17
:FIXED: 2025-11-17
:IMPACT: Data integrity, collection storage
:STATUS: Fixed
:COMMIT: ea8cd2b
:END:

*** Description
When structs containing nested structs (like Vec, Map, List) were stored in collections, the nested structs were allocated separately instead of inline, causing memory corruption.

*** Fix
Modified insert_struct_at_offset in init.rs to accept optional existing_offset parameter, allowing nested structs to be allocated inline within parent's memory block.

*** Commit
ea8cd2b: Fix Bug #26: nested struct corruption in Vec/Map

** Bug #25: Field offset refactor breaks typer method resolution :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-13
:FIXED: 2025-11-13
:IMPACT: API consistency, method resolution
:STATUS: Fixed - uniform len() API implemented
:END:

*** Description
The typer fails to find I64.eq method when chaining method calls on struct field access (e.g., `s.items.len.eq(0)`). This was discovered during field offset refactoring work but the root cause was different.

*** Example Problem
#+BEGIN_EXAMPLE til
// In ufcs.til line 300 - this WORKS:
items_len := s.items.len

// In ufcs.til line 304 - this FAILS:
len_check := s.items.len.eq(0)  // Error: "Could not find function definition"
#+END_EXAMPLE

The field access works, but method resolution on the result fails!

*** Root Cause (FOUND!)
The real issue was NOT the field offset refactor, but an API inconsistency:
- Vec, List, and Array had `len` as a FIELD instead of a METHOD
- When the typer tried to resolve `s.items.len.eq(0)`, it saw `.len` as a field access
- Field accesses return `auto` type (requiring type inference)
- The typer couldn't properly infer the type for chained method calls
- Result: "Could not find function definition" for `.eq(0)`

This became apparent when `s.items.len` was accessed - it worked as a field, but the moment you tried to call a method on the result, type resolution failed.

*** Solution (2025-11-13)
Implemented uniform len() API across all collection types:

1. **Renamed internal fields**: `len`  `_len` (cap kept as-is)
2. **Added uniform methods**:
   - `len()` returns element count (_len)
   - `size()` returns byte size (len * type_size)
3. **Implemented for**: Vec, List, Array (src/core/core.til)
4. **Updated all code** to use `.len()` method calls:
   - Core library: lexer.til, parser.til, typer.til, interpreter.til
   - Test files: ufcs.til, args.til, arrays.til, dynamic_arrays.til, lists.til, maps.til, mut_test.til, variadic.til
5. **Updated interpreter**: init.rs to look for `._len` field offset
6. **For-loop workaround**: Store `len()` in local variable (e.g., `mut args_len := args.len()`)

*** Now Works
#+BEGIN_EXAMPLE til
//  All these patterns now work correctly:
items_len := s.items.len()
len_check := s.items.len().eq(0)
if i.lt(s.items.len().add(5)) { }
comparison := i.lt(e.params.len())
#+END_EXAMPLE

*** Test Coverage (Regression Prevention)
The existing test file `src/test/ufcs.til` provides comprehensive regression coverage:

**test_bug10_fixed()** (lines 296-317):
- Line 304: `len_check := s.items.len().eq(0)` - EXACT failing pattern
- Line 309: `comparison := i.lt(s.items.len().add(5))` - Chained method calls
- Line 314: `name_len := name.len()` - String len() method

**test_bug10_parser_patterns_fixed()** (lines 320-341):
- Line 334: `len_is_zero := e.params.len().eq(0)` - Another instance of failing pattern
- Line 338: `len_plus_five := e.params.len().add(5)` - Arithmetic on method result

These tests run in the standard test suite and will catch any regression
that breaks chained method calls on field access. All tests pass (exit code 0).

*** Commits
- 27dc3ae: Fix Bug #25: Implement uniform len() API for Vec, List, and Array
- 1444a8b: Complete len() API standardization - fixes Bug #25

** Bug #24: Variable Declarations Share Arena Offsets Instead of Copying :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Fixed - mut declarations now copy
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Fix Applied

**Design Decision**: Only mut declarations create copies. Non-mut declarations share offsets (read-only aliases).

**Implementation** (src/rs/interpreter.rs lines 923-935):
- **mut declarations**: Call insert_struct() + copy_fields() to create independent copy
- **non-mut declarations**: Share arena offset (efficient, type checker enforces immutability)

**Result**:
#+BEGIN_SRC til
mut dup := original  // Creates independent copy
dup := original      // Shares offset (read-only alias)
#+END_SRC

This design aligns with Mojo's ownership model:
- mut = mutable copy (prevents aliasing)
- default = reference (efficient, safe with type checker)
- Future: 'own' keyword for ownership transfer

See doc/ownership.org for full design analysis and Mojo comparison.

**All tests pass**, including test_declaration_creates_copy (args.til:484)

** Bug #24: Struct Field Access Returns Copy Instead of Reference :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-18
:IMPACT: Data structure mutation, memory management
:STATUS: Fixed - Pass-by-reference for field access
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Fix Applied (2025-11-18)

Bug #24 was fixed as part of implementing pass-by-reference for field access parameters and fixing Bug #26.

**Three-part solution:**

*Fix 1: Inline nested struct allocation* (init.rs:1510-1625)
- Modified insert_struct_at_offset to accept optional existing_offset
- Nested structs now allocated inline within parent's memory block
- Previously: nested structs allocated separately, causing corruption

*Fix 2: Pass-by-reference for field access parameters* (interpreter.rs:1820-1872)
- Extended pass-by-ref to field access like `self.type_names.push(...)`
- Share arena offset instead of allocating and copying
- Register field symbols for UFCS method resolution
- Previously only simple identifiers used pass-by-ref

*Fix 3: Zero-copy return value transfers* (interpreter.rs:970-985)
- Detect temporary return values and share offset instead of copy
- mut x := func() now zero-copy (transfers ownership)
- Only copy when source is real variable (preserves Bug #25 fix)

**Result:**
The workaround pattern is no longer needed. Direct field mutations now work:

#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  //  NOW WORKS - modifies via reference!
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

**Test Coverage:**
- src/test/tmp/test_bug24.til - Comprehensive test verifying direct field mutations
- All existing tests pass with the fix

**Note on Workarounds:**
While the bug is fixed, existing workarounds (copy-modify-reassign pattern) can remain for now
as they are functionally equivalent. Workarounds exist in:
- src/core/core.til (List.push, List.set, List.pop, etc.)
- src/core/lexer.til
- src/core/parser.til
- src/core/std.til (potentially)
They can be removed in a future cleanup pass to simplify the code and potentially improve performance.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` 
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` 
- Throw from regular function 

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` 

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  //  Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
