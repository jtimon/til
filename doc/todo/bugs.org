#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New bugs use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new bugs at the top of Active Bugs section.
# BOT: When fixed, move to the top of Fixed Bugs section in doc/todo/fixed.org.

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #172: Codegen bug returning for-in loop variable of same type as return type
:PROPERTIES:
:DISCOVERED: 2026-02-18
:IMPACT: SIGSEGV at runtime -- generated C reads uninitialized _ret and never writes return value
:STATUS: Open -- workaround is to use range-based loop instead
:END:

*** Problem
When a for-in loop variable has the same type as the function's return type,
and the loop variable is returned directly (e.g. `return member`), the C
codegen confuses the loop variable with the return value `_ret`. Two bugs in
the generated C:

1. Field access uses `_ret->field` instead of `loop_var->field`
2. Return statement does `return 0;` without setting `*_ret = *loop_var`

*** Reproduction
#+begin_src til
get_member := func(self: SStructDef, member_name: Str) returns Declaration throws Str {
    for member: Declaration in self.members {
        if member.name.eq(member_name) {
            return member  // BUG: codegen uses _ret->name instead of member->name
        }
    }
    throw format(loc(), "Member '", member_name, "' not found")
}
#+end_src

Generated C (wrong):
#+begin_src c
til_Declaration* til_Declaration_member;
til_Declaration_member = (til_Declaration*)_ref_forin_0.data;
if (til_Str_eq(&_ret->name, til_Str_member_name).data) {  // BUG: _ret not member
    return 0;  // BUG: never sets *_ret
}
#+end_src

*** Notes
- Returning a FIELD of the loop variable works fine (e.g. `return v.payload_type`)
- Only triggers when the loop variable type matches the function return type exactly
- Workaround: use `for i in 0..collection.len()` with `.get(i, var)` instead
- SStructDef.get_member left as range-based loop for this reason (commit 0e4f942b)


** Bug #165: Compiled TIL binary leaks 200-800x memory vs Rust
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Compiled TIL programs use 200-800x more memory than equivalent Rust interpreter
:STATUS: Blocked by Bug #159 (shallow copies prevent safe ASAP deletion)
:RELATED: Bug #159 (shallow copies), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame copy leak), Issue #117 (ASAP destruction)
:END:

*** Description
The compiled TIL binary (generated C code) leaks memory massively compared to the
Rust interpreter. Clone/delete imbalance: ~2500 Str clones vs ~1850 Str deletes in
generated C code, leaving ~650 leaked Str allocations per test run.

*** Failed attempt: ASAP deletion for named locals (wip165 branch)
Branch ~wip165~ has 2 commits ahead of master implementing ASAP deletion for named
locals with alias/escape detection:

**** Rules implemented
- Rule A (alias detection): Skip delete if variable was assigned from another local
  (e.g., ~x := y~ -- deleting x would corrupt y's data via shared pointer)
- Rule B (escape detection): Skip delete if variable was passed to a function after
  its last read (value may have escaped into another data structure)
- Rule C (owned return): Only delete variables assigned from known-allocating functions
  (constructors, .new(), .clone(), .to_str(), .format(), .concat(), etc.)

**** Results
- All 98 tests pass in all 4 modes
- Zero memory improvement -- clone/delete ratio unchanged
- Root cause: most leaks come from shallow copies (memcpy of structs with heap
  pointers), not from missing deletes of named locals

**** Why ASAP deletion doesn't help
The ~650 leaked Str allocations come from:
- Function return values (shallow memcpy at call site)
- Container operations (get/push/set all use copy_to_dynamic/copy_from_dynamic)
- Temporary expressions (_tmp_ variables holding intermediate results)

None of these are named locals that ASAP deletion can target. The fundamental
problem is Bug #159: shallow copies create hidden aliases that make it unsafe
to delete anything without risking double-free.

*** Blocked by
Bug #159 must be resolved first. Until shallow copies are eliminated, any
deletion strategy risks double-free on aliased heap pointers.


** Bug #133: Precomputed heap values (Vec, List, etc.) have invalid pointers at runtime (COMPILED MODES)
:PROPERTIES:
:DISCOVERED: 2026-01-22
:IMPACT: Compiled programs crash/segfault when using precomputed collections
:STATUS: Partial - Vec types work (including nested); List, Map still broken
:REPRODUCER: src/test/test_bug133.til (passes for simple types)
:RELATED: Bug #145 (FIXED - was similar issue in til_interpreted mode)
:BRANCH: current133
:END:

NOTE: This bug affects COMPILED modes only (rs_compiled, til_compiled).
For a related issue in til_interpreted mode, see Bug #145.

*** Description
When global declarations like ~chromatic := create_chromatic()~ are precomputed
at compile time, the resulting Vec/List values contain heap pointers from the
interpreter's memory space. These raw pointer values are serialized directly
into C struct literals, causing segfaults at runtime.

*** Example
In music.til:
#+BEGIN_SRC til
chromatic := create_chromatic()  // Returns Vec of Str
#+END_SRC

Generated C code (in main()):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.type_name = (til_Str){.c_string = (til_Ptr){2146}, .cap = 3},
                          .type_size = 16, .ptr = (til_Ptr){3615}, ._len = 12, .cap = 16};
#+END_SRC

Those values (2146, 3615) are raw pointers from the precomp interpreter's arena.
At runtime they point to invalid memory, causing segfaults in Vec.get().

*** Root Cause
1. precomp.rs evaluates global declarations at compile time via eval_comptime()
2. eval_comptime() runs the interpreter, which allocates Vec contents on heap
3. The Vec struct fields (including Ptr fields) are serialized as integer literals
4. At runtime, the compiled program has different memory layout - those pointers are garbage

*** Affected Types
- Vec (Ptr field points to heap-allocated element array)
- List (likely same issue with Ptr node pointers)
- Any struct with Ptr fields pointing to heap data
- Str when dynamically allocated (c_string Ptr field)

*** Fix
Serialize heap data to static arrays: Copy the heap contents into C static
arrays and patch the pointers to reference them. This preserves the
optimization benefit of precomputation.

**** Generic approach
The correct solution is NOT to hardcode specific types (Vec, List, Map), but to
handle ANY struct with owned Ptr fields generically:

1. For each Ptr field in the struct, check if ~is_borrowed~ is false (owned)
2. If owned, the Ptr points to heap data that needs serialization
3. Recursively serialize whatever that Ptr points to (could be another struct
   with Ptr fields, requiring further recursion)
4. Emit static arrays for the serialized data
5. Patch the Ptr to reference the static array instead of the heap address

This approach automatically handles:
- Vec (ptr field points to element array)
- List (node pointers)
- Map (bucket pointers)
- Any user-defined struct with owned Ptr fields
- Arbitrary nesting depth

Current implementation handles Vec specifically; List and Map need the same
treatment but haven't been implemented yet.

*** Workaround (for unsupported types)
Change ~func~ to ~proc~ for functions that return unsupported heap types.
Since precomp only evaluates ~func~ (pure functions), using ~proc~ forces runtime evaluation:

#+BEGIN_SRC til
// Works (all Vec types now supported):
create_chromatic := func() returns Vec { ... }
create_mode_intervals := func() returns Vec { ... }  // Vec<Vec<I64>>

// Broken (List, Map not yet supported), use proc:
create_items := proc() returns List { ... }
#+END_SRC

*** Progress (2026-01-30)
Rust fix merged to master. Files modified:
- ~src/rs/eval_arena.rs~ - VecContents, StrContents extraction functions
- ~src/rs/init.rs~ - PrecomputedHeapValue struct
- ~src/rs/precomp.rs~ - track precomputed heap values
- ~src/rs/ccodegen.rs~ - emit static arrays and patched assignments

TIL port complete (2026-01-30). Files modified:
- ~src/self/eval_arena.til~ - VecContents, extract_vec_contents, extract_str_at_offset, type_needs_heap_serialization
- ~src/self/init.til~ - PrecomputedHeapValue struct
- ~src/self/precomp.til~ - track precomputed heap values
- ~src/self/ccodegen.til~ - PrecomputedStaticInfo, emit_precomputed_static_arrays, hex_byte, bytes_to_i64
- ~src/core/str.til~ - Str.from_byte (consolidation)
- ~src/test/strings.til~ - tests for char_at and from_byte

**** Current test results (simple Vec<I64>, Vec<U8>, Vec<Str>):
- rs_interpreted: PASS
- rs_compiled: PASS (Bug #133 fix works)
- til_interpreted: PASS (Bug #145 resolved)
- til_compiled: PASS (TIL port complete)

*** Simplification (2026-02-18)
Two improvements to the generated C output:
1. Inline all string literals directly in struct initializers instead of emitting
   intermediate ~static const char~ variables. C string literals already have
   static storage duration -- no need for named variables.
2. Move Vec initialization from assignment in ~main()~ to the static declaration
   site. All values are compile-time constants (string literal addresses, static
   array addresses, integers), so this is valid as a C static initializer.
   Removed ~emit_precomputed_vec_assignment~ (both .rs and .til).

**** What works now (both rs_compiled and til_compiled):
- ~Vec<I64>~ - emits static I64 array
- ~Vec<U8>~ - emits static U8 array
- ~Vec<Str>~ - emits string literals + Str struct array (two-level)
- ~Vec<Vec<T>>~ - recursive serialization of nested Vecs

**** Still broken (both rs_compiled and til_compiled):
- ~List~ - linked node pointers not serialized
- ~Map~ - internal structure not serialized

**** Future work:
1. Generalize to handle any struct with owned Ptr fields (not just Vec)
2. Add List serialization support (linked node pointers)
3. Add Map serialization support (internal structure)

*** Implementation Plan
Serialize heap contents to static C arrays and patch pointers to reference them.

**** Before (broken):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.ptr = (til_Ptr){3615}, ._len = 12, ...};  // 3615 is garbage
#+END_SRC

**** After (working, simplified 2026-02-18):
#+BEGIN_SRC c
// Static data array with inline string literals (no intermediate variables):
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)"do", 1, 0, 0, 0}, ._len =2, .cap = 0},
    {.c_string = (til_Ptr){(til_I64)"do#", 1, 0, 0, 0}, ._len =3, .cap = 0},
    // ...
};
// Initialized at declaration site (not assigned in main):
static til_Vec til_Vec_chromatic = {
    .type_name = (til_Str){(til_Ptr){(til_I64)"Str", 1, 0, 0, 0}, 3, 0},
    .type_size = 56,
    .ptr = (til_Ptr){(til_I64)_precomp_chromatic_data, 1, 0, 0, 0},
    ._len = 12, .cap = 12
};
#+END_SRC

**** Step 1: Add Vec/Str extraction to eval_arena.rs [DONE]
Add struct and function to extract Vec contents given an instance name:
#+BEGIN_SRC rust
pub struct VecContents {
    pub element_type_name: String,
    pub type_size: i64,
    pub element_bytes: Vec<Vec<u8>>,
}

pub fn extract_vec_contents(ctx: &Context, instance_name: &str)
    -> Result<VecContents, String>
#+END_SRC

**** Step 2: Track precomputed heap values in precomp.rs [DONE]
Add struct for tracking precomputed heap values:
#+BEGIN_SRC rust
pub struct PrecomputedHeapValue {
    pub var_name: String,
    pub instance_name: String,
    pub type_name: String,
}
#+END_SRC

In ~precomp_declaration()~, when a global declaration has a precomputed Vec/List:
- Store in new ~Context.precomputed_heap_values: Vec<PrecomputedHeapValue>~

**** Step 3: Emit static arrays in ccodegen.rs [DONE for simple types]
Before emitting main(), add a new pass:
#+BEGIN_SRC rust
for phv in &context.precomputed_heap_values {
    if phv.type_name == "Vec" {
        let contents = EvalArena::extract_vec_contents(ctx, &phv.instance_name)?;
        emit_static_vec_data(&phv.var_name, &contents, output)?;
    }
}
#+END_SRC

**** Step 4: Patch struct literals to use static pointers [DONE]
When emitting a global declaration in ~precomputed_heap_values~:
- Instead of ~.ptr = (til_Ptr){1234}~
- Emit ~.ptr = (til_Ptr){(til_I64)_precomp_{var_name}_data}~

**** Handling Nested Types
For Vec<I64>: [DONE]
#+BEGIN_SRC c
static til_I64 _precomp_myints_data[5] = {1, 2, 3, 4, 5};
til_myints = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_myints_data}, ._len = 5, ...};
#+END_SRC

For Vec<Str> (two-level): [DONE]
#+BEGIN_SRC c
static const char _precomp_chromatic_str_0[] = "do";
static const char _precomp_chromatic_str_1[] = "do#";
// ...
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_0}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_1}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ...};
#+END_SRC

For Vec<Vec<T>>: Recursively emit inner arrays first, then outer. [TODO]

**** Complexity Notes
- Vec<Str> requires two-level static arrays (strings + Str structs) [DONE]
- Vec<Vec<T>> requires recursive serialization [TODO]
- List would need similar treatment (linked nodes -> static array) [TODO]
- Start with Vec only, extend to List/Map later if needed


** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (updated 2026-02-11)
Audit of generated C code with ~gcc -Wall -Wextra~:

| Type                         | Count | Priority | Notes                                      |
|------------------------------+-------+----------+--------------------------------------------|
| -Wunused-variable            |  1711 | Low      | Generated temp vars not always used        |
| -Wdangling-pointer           |   971 | High     | Statement expressions return &local_var    |
| -Wunused-but-set-variable    |     9 | Low      | Similar to above                           |
| -Wunused-label               |   195 | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           |     0 | Low      | FIXED 2026-02-11 - (void) casts            |
| -Wmissing-braces             |     0 | Low      | FIXED 2026-01-25                           |
| -Wmissing-field-initializers |     0 | Low      | FIXED 2026-01-25                           |
| -Wreturn-type                |     0 | High     | FIXED 2026-01-25                           |
| -Wincompatible-pointer-types |     0 | Medium   | FIXED 2026-01-13                           |
| -Wc23-extensions             |     0 | Low      | FIXED 2026-01-28 - emit param names always |

*** Fix Strategy (Incremental)
1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Switch to ~-Wall -Wextra -Werror~ with suppressions (DONE - 2026-01-25)
5. Remove suppressions one by one as each warning category is fixed

*** Current Build Flags (target.rs/til)
Now using ~-Wall -Wextra -Werror~ with suppressions for unfixed warnings (2026-01-26):

**** Common flags (both gcc and clang)
- ~-Wno-unused-variable~ (1514 occurrences)
- ~-Wno-unused-but-set-variable~ (386 occurrences)
- ~-Wno-unused-label~ (153 occurrences)

**** GCC-only flags
- ~-Wno-dangling-pointer~ (971 occurrences) - high priority to fix

**** Clang-only flags
- ~-Wno-sometimes-uninitialized~ - exception control flow paths
- ~-Wno-self-assign~ - til_result = til_result patterns in generated code
- ~-Wno-c23-extensions~ - unnamed parameters in function definitions
- ~-Wno-uninitialized~ - variable used before initialization in some paths
- ~-Wno-unused-function~ - enum to_str functions generated but not always used

To fix a warning category: remove the ~-Wno-~ flag and fix the resulting errors.

*** Testing with clang locally (Issue #131)
To build til.til with clang (this is what fails in macOS CI):
#+begin_src bash
./bin/rstil build src/til.til --cc=clang --force-rebuild
#+end_src

To run tests with clang instead of gcc:
#+begin_src bash
./bin/rs/make tests --cc=clang
#+end_src

Note: ~./make.til tests --cc=clang~ does NOT work because the shebang causes
rstil to consume the flag. Use the compiled binary ~./bin/rs/make~ directly.

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [X] Step 3e: Enable and fix -Wreturn-type (2026-01-25) - add implicit return 0 to throwing functions, add zero-initialized fallback return to non-throwing functions with return types
- [X] Step 4: Switch to -Wall -Wextra -Werror with suppressions (2026-01-25)
- [X] Step 5a: Remove -Wno-dangling-pointer (971 occurrences) - fixed by Bug #143, flag removed in Bug #140 fix
- [-] Step 5b: Remove -Wno-unused-variable (1514 occurrences, partial progress)
- [-] Step 5c: Remove -Wno-unused-but-set-variable (9 occurrences, down from 386). Blocks Bug #94 (bug47.til rs_compiled). Two categories: TIL source vars set but not read (3), dead ccodegen temps (4 Str temps in collect_namespace_methods). See Bug #94 for full list.
- [ ] Step 5d: Remove -Wno-unused-label (195 occurrences)
- [X] Step 5e: Remove -Wno-unused-parameter (2026-02-11) - emit (void)param; casts at top of function bodies for _-prefixed params and all params in empty-body functions (e.g., empty delete stubs)
- [X] Step 5f: Remove -Wno-missing-braces (2026-01-25) - use Ptr() instead of NULL for Declaration.default_value in desugarer.til/garbager.til; Ptr() emits ~((til_Ptr){0})~ with proper braces
- [X] Step 5g: Remove -Wno-missing-field-initializers (2026-01-25) - add cap=0 to Str literals for Type params in ccodegen emit_main_args

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-02-11)
| Mode            | Result                             | Time  |
|-----------------+------------------------------------+-------|
| rstil interpret | pass                               | ~9.5s |
| rstil run       | FAIL - unused-but-set-variable (8) | -     |
| til interpret   | pass (but >120s, excluded from benchmark) | -     |
| til run         | OOM killed (exit 137)              | ~61s  |

~rstil run~ fails due to 8 ~-Wunused-but-set-variable~ warnings in generated C:
#+BEGIN_SRC
gen/rs/c/test/bug47.c:4968:  _ignore = til_reset_loop_var_counter()     -- TIL source var
gen/rs/c/test/bug47.c:8841:  _tmp_collect_namespace_methods_15 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8888:  _tmp_collect_namespace_methods_38 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8962:  _tmp_collect_namespace_methods_69 (Str)    -- dead temp
gen/rs/c/test/bug47.c:9009:  _tmp_collect_namespace_methods_92 (Str)    -- dead temp
gen/rs/c/test/bug47.c:18317: custom_symbol_found (Bool)                 -- TIL source var
gen/rs/c/test/bug47.c:19102: have_switch_type (Bool)                    -- TIL source var
gen/rs/c/test/bug47.c:24269: has_switch_type (Bool)                     -- TIL source var
#+END_SRC

Two categories:
1. TIL source variables set but not read (3 vars: ~_ignore~, ~custom_symbol_found~,
   ~have_switch_type~/~has_switch_type~) - fix in TIL source or mark with ~__attribute__((unused))~
2. Dead temps from ccodegen (4 Str temps in ~collect_namespace_methods~) - fix in ccodegen

*** Original Warnings (2026-01-13, historical)
1654 total warnings when compiling with ~gcc -Wall -Wextra~ (all now fixed or
suppressed via Bug #99):
- 933 -Wunused-variable (suppressed, Bug #99 step 5b)
- 318 -Wdangling-pointer (FIXED, Bug #143)
- 195 -Wincompatible-pointer-types (FIXED, Bug #99 step 3a)
- 135 -Wunused-but-set-variable (down to 9, Bug #99 step 5c)
- 66 -Wunused-label (suppressed, Bug #99 step 5d)
- 5 -Wunused-parameter (FIXED, Bug #99 step 5e)
- 1 -Wreturn-type (FIXED, commit 129ba21a)
- 1 null character in literal (FIXED, Bug #99 step 3d)

*** Progress (2026-02-11)
All original warnings now fixed or suppressed via Bug #99. Remaining blocker for
compiled mode is Bug #99 step 5c (9 unused-but-set-variable warnings). OOM in
~til run~ remains open (Issue #117).

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [X] Fix missing return statement (commit 129ba21a)
- [X] Add casts for Vec_push calls - fixed in Bug #99 Step 3a (-Wincompatible-pointer-types)
- [X] Consider which unused-* warnings to fix vs suppress - done in Bug #99 Step 4
- [X] Fix dangling pointer pattern - fixed by Bug #143
- [ ] Fix 8 unused-but-set-variable warnings - same as Bug #99 Step 5c
- [ ] Fix til ccodegen memory usage (OOM on large files) - may be fixed by Issue #117 (borrow checker)

*** Related Issues
- Bug #99 Step 5c: Remove -Wno-unused-but-set-variable (direct blocker for rs_compiled)
- Bug #140: Dangling pointers in generated C code (FIXED via Bug #143)
- Issue #117: Borrow checker / memory management (may fix OOM)

