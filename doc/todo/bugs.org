#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New bugs use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new bugs at the top of Active Bugs section.
# BOT: When fixed, move to the top of Fixed Bugs section in doc/todo/fixed.org.

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #136: Switch on structs compares instance names, not values
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPACT: Switch on struct values silently fails to match
:STATUS: Open
:REPRODUCER: see tmp/test_switch_no_eq.til
:END:

*** Description
Switch statements on struct types don't work correctly. The interpreter compares
instance names (like "p1" vs "__return_instance_0") instead of actual struct values.

*** Example
#+BEGIN_SRC til
Point := struct { mut x: I64 = 0 }

p := Point(x=5)
switch p {
    case Point(x=5): println("matched")   // Never matches!
    case: println("not matched")          // Always hits this
}
#+END_SRC

*** Root Cause
In interpreter.rs, switch comparison uses ~result_to_switch.value == result_case.value~
(line 757). For structs:
- Variable ~p~ evaluates to its name: ~"p"~
- Literal ~Point(x=5)~ evaluates to temp name: ~"__return_instance_N"~
- These strings never match

For I64/Str this works because they evaluate to actual values ("5", "hello").
For enums, special pattern matching code handles comparison (not string compare).

*** Resolution
Fix switch comparison directly in interpreter to use ~eq()~ for struct types:

1. In interpreter's switch handling (interpreter.rs ~line 757, interpreter.til equivalent):
   - Detect when switch expression is a struct type
   - Instead of comparing instance names, call the struct's ~eq()~ method
   - If struct has no ~eq()~ method, emit error: "Struct X requires eq() method for switch"

2. Same fix needed in ccodegen for compiled mode

3. Structs must implement ~eq()~ to be usable in switch case patterns:
   #+BEGIN_SRC til
   Point := struct {
       mut x: I64 = 0
       eq := func(self: Point, other: Point) returns Bool {
           return self.x.eq(other.x)
       }
   }
   #+END_SRC

This is a direct fix that doesn't depend on Issue #110 (desugar switch to if/else).

** Bug #133: Precomputed heap values (Vec, List, etc.) have invalid pointers at runtime
:PROPERTIES:
:DISCOVERED: 2026-01-22
:IMPACT: Compiled programs crash/segfault when using precomputed collections
:STATUS: Open
:REPRODUCER: rstil run src/examples/music.til jonio fa
:END:

*** Description
When global declarations like ~chromatic := create_chromatic()~ are precomputed
at compile time, the resulting Vec/List values contain heap pointers from the
interpreter's memory space. These raw pointer values are serialized directly
into C struct literals, causing segfaults at runtime.

*** Example
In music.til:
#+BEGIN_SRC til
chromatic := create_chromatic()  // Returns Vec of Str
#+END_SRC

Generated C code (in main()):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.type_name = (til_Str){.c_string = 2146, .cap = 3},
                          .type_size = 16, .ptr = 3615, ._len = 12, .cap = 16};
#+END_SRC

Those values (2146, 3615) are raw pointers from the precomp interpreter's arena.
At runtime they point to invalid memory, causing segfaults in Vec.get().

*** Root Cause
1. precomp.rs evaluates global declarations at compile time via eval_comptime()
2. eval_comptime() runs the interpreter, which allocates Vec contents on heap
3. The Vec struct fields (including ptr) are serialized as integer literals
4. At runtime, the compiled program has different memory layout - those pointers are garbage

*** Affected Types
- Vec (ptr field points to heap-allocated element array)
- List (likely same issue with node pointers)
- Any struct with heap-allocated fields
- Str when dynamically allocated (c_string field)

*** Possible Fixes
1. **Don't precompute heap types**: Detect when a type contains heap pointers
   and skip precomputation, forcing runtime initialization instead

2. **Serialize heap data to static arrays**: Copy the heap contents into C static
   arrays and patch the pointers to reference them. Complex but preserves the
   optimization benefit.

3. **Mark types as non-precomputable**: Add metadata to Vec/List/etc. indicating
   they shouldn't be precomputed at global scope

Option 1 is simplest and safest. Option 2 would be more optimal but significantly
more complex.

*** Workaround (current)
Change ~func~ to ~proc~ for functions that return heap types. Since precomp
only evaluates ~func~ (pure functions), using ~proc~ forces runtime evaluation:

#+BEGIN_SRC til
// Before (broken - precomputed Vec has invalid pointers):
create_chromatic := func() returns Vec { ... }
chromatic := create_chromatic()

// After (works - evaluated at runtime):
create_chromatic := proc() returns Vec { ... }
chromatic := create_chromatic()
#+END_SRC

See src/examples/music.til for example usage.

*** Dependencies
- Depends on Issue #134 (Ptr type refactor) for proper fix

*** Implementation Plan (for proper fix)
Serialize heap contents to static C arrays and patch pointers to reference them.

**** Before (broken):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.ptr = 3615, ._len = 12, ...};  // 3615 is garbage
#+END_SRC

**** After (working):
#+BEGIN_SRC c
static til_Str _precomp_chromatic_data[12] = {
    {(til_I64)"do", 2}, {(til_I64)"do#", 3}, ...
};
til_chromatic = (til_Vec){.ptr = (til_I64)_precomp_chromatic_data, ._len = 12, ...};
#+END_SRC

**** Step 1: Add Vec/Str extraction to eval_arena.rs
Add function to extract Vec contents given an instance name:
#+BEGIN_SRC rust
pub fn extract_vec_contents(ctx: &Context, instance_name: &str)
    -> Result<(String, i64, Vec<Vec<u8>>), String>
#+END_SRC
Returns: (element_type_name, type_size, element_bytes_list)

**** Step 2: Track precomputed heap values in precomp.rs
In ~precomp_declaration()~, when a global declaration has a precomputed Vec/List:
- Store in new ~Context.precomputed_heap_values: Vec<(String, String, String)>~
- Tuple: (var_name, instance_name, type_name)

**** Step 3: Emit static arrays in ccodegen.rs
Before emitting main(), add a new pass:
#+BEGIN_SRC rust
for (var_name, instance_name, type_name) in &context.precomputed_heap_values {
    if type_name == "Vec" {
        let (elem_type, elem_size, elements) = EvalArena::extract_vec_contents(...)?;
        emit_static_vec_data(var_name, &elem_type, elem_size, &elements, output)?;
    }
}
#+END_SRC

**** Step 4: Patch struct literals to use static pointers
When emitting a global declaration in ~precomputed_heap_values~:
- Instead of ~.ptr = 1234~
- Emit ~.ptr = (til_I64)_precomp_{var_name}_data~

**** Handling Nested Types
For Vec<I64>:
#+BEGIN_SRC c
static til_I64 _precomp_myints_data[5] = {1, 2, 3, 4, 5};
til_myints = (til_Vec){.ptr = (til_I64)_precomp_myints_data, ._len = 5, ...};
#+END_SRC

For Vec<Str> (two-level):
#+BEGIN_SRC c
static const char _precomp_chromatic_str_0[] = "do";
static const char _precomp_chromatic_str_1[] = "do#";
// ...
static til_Str _precomp_chromatic_data[12] = {
    {(til_I64)_precomp_chromatic_str_0, 2},
    {(til_I64)_precomp_chromatic_str_1, 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_I64)_precomp_chromatic_data, ...};
#+END_SRC

For Vec<Vec<T>>: Recursively emit inner arrays first, then outer.

**** Complexity Notes
- Vec<Str> requires two-level static arrays (strings + Str structs)
- Vec<Vec<T>> requires recursive serialization
- List would need similar treatment (linked nodes -> static array)
- Start with Vec only, extend to List/Map later if needed

** Bug #129: Parser cannot handle explicit ~auto~ type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Inconsistent syntax - ~a := 69~ works but ~a : auto = 69~ fails
:STATUS: Open
:END:

*** Description
The syntax ~a := 69~ is internally parsed as a Declaration with value_type="auto" (INFER_TYPE).
However, writing ~a : auto = 69~ explicitly fails with a parse error.

Similarly, ~for elem: auto in collection~ parses but typer doesn't resolve the element type,
causing type errors downstream.

*** Root Cause
In parser.rs, parse_declaration uses ~explicit_type != INFER_TYPE~ to determine whether
to skip a type token. When user writes ~: auto~, the parser passes "auto" as explicit_type.
Since "auto" == INFER_TYPE, the condition is false and the parser doesn't skip the type token,
causing it to see ~=~ where it expects the value expression.

The code path:
1. ~a : auto = 69~ tokens: [a, :, auto, =, 69]
2. Parser sees ~auto~ (Identifier), passes "auto" to parse_declaration
3. advance(3) skips [a, :, auto], now at ~=~
4. ~"auto" != INFER_TYPE~ is FALSE, no extra advance
5. parse_primary() sees ~=~ instead of ~69~ -> error

*** Expected Behavior
~a : auto = 69~ should parse identically to ~a := 69~.

*** Possible Fixes
1. Use a different internal sentinel for INFER_TYPE (not "auto")
2. Pass a boolean ~has_type_token~ to parse_declaration instead of relying on value
3. Re-architect parsing to handle this case

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Bug #114: ScopeStack lookup functions leak memory by copying entire ScopeFrame
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Memory leak in self-hosted interpreter, grows with scope depth and lookup frequency
:STATUS: Open - needs solution design
:END:

*** Description
TIL's ScopeStack lookup functions (lookup_var, lookup_symbol, lookup_func, lookup_enum,
lookup_struct, is_closure_capture, all_structs, etc.) copy entire ScopeFrame objects
when iterating through frames:

#+BEGIN_SRC til
// Current pattern (leaks memory)
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()   // Allocates new ScopeFrame
    self.frames.get(i, frame)   // Copies ALL fields including 5 Maps

    if frame.arena_index.contains_key(name) {
        // ...
    }
    // frame goes out of scope - Maps inside are NOT freed
}
#+END_SRC

ScopeFrame contains 5 Maps (arena_index, symbols, funcs, enums, structs). Each copy
duplicates the Map struct which holds pointers to heap-allocated Vec data. When the
copied frame goes out of scope, those Map copies leak because TIL has no automatic
destructor/drop mechanism.

*** Why Rust Doesn't Have This Problem
Rust iterates by reference, not by copy:
#+BEGIN_SRC rust
for frame in self.frames.iter().rev() {
    if let Some(offset) = frame.arena_index.get(name) {
        // frame is &ScopeFrame - no copy, no allocation
    }
}
#+END_SRC

*** Potential Solutions

**** Option A: Return references from Vec.get (language change)
Change Vec.get to return a reference/pointer instead of copying:
#+BEGIN_SRC til
// Hypothetical - would require language support for references
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame := self.frames.get_ref(i)  // Returns reference, no copy
    if frame.arena_index.contains_key(name) { ... }
}
#+END_SRC
Pros: Matches Rust semantics, clean syntax
Cons: Major language change, needs reference/borrow system

**** Option B: Vec.get_ptr + manual offset calculation (branch approach)
Use pointer arithmetic to access fields without copying entire struct:
#+BEGIN_SRC til
structs_offset := mul(size_of(Map), 4)
mut scratch_map := Map.new(Str, SStructDef)
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame_ptr := self.frames.get_ptr(i)
    structs_ptr := add(frame_ptr, structs_offset)
    memcpy(to_ptr(scratch_map), structs_ptr, size_of(Map))
    if scratch_map.contains_key(name) { ... }
}
#+END_SRC
Pros: Works now, fixes leak
Cons: Fragile (hardcoded offsets), diverges from Rust significantly, error-prone

**** Option C: Existence-check methods (has_struct, has_symbol, etc.)
Add cheap existence-check methods that avoid full struct retrieval:
#+BEGIN_SRC til
// Instead of:
_ := self.scope_stack.lookup_struct(name)  // Copies SStructDef
catch { }

// Use:
if self.scope_stack.has_struct(name) { ... }  // Just checks existence
#+END_SRC
Pros: Simple, matches Rust .is_some() pattern, no language changes
Cons: Only helps existence checks (~40 places), doesn't fix cases needing the value

**** Option D: Explicit free/drop for complex types
Add manual memory management:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    // ... use frame ...
    frame.free()  // Explicitly free copied Maps
}
#+END_SRC
Pros: Explicit, controllable
Cons: Error-prone, verbose, easy to forget

**** Option E: For-in loop over Vec doesn't copy (compiler optimization)
Make the compiler smart enough to not copy when iterating:
#+BEGIN_SRC til
for frame: ScopeFrame in self.frames.reverse() {
    // frame is a reference, not a copy (compiler detects loop pattern)
}
#+END_SRC
Pros: Clean syntax, no code changes needed
Cons: Significant compiler work, may be complex to implement correctly

**** Option F: ASAP destruction (Mojo-style automatic delete on last use)
Compiler inserts destructor calls automatically when a value is last used:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    if frame.arena_index.contains_key(name) {
        // ...
    }
    // Compiler detects frame's last use and inserts: frame.__del__()
}
#+END_SRC
Pros: Automatic, no manual memory management, matches Mojo semantics
Cons: Requires:
  - Destructor support (__del__ methods on types with heap data)
  - Liveness analysis in compiler to detect last use
  - Careful handling of control flow (returns, throws, branches)
  - May interact poorly with references if added later

This is how Mojo handles memory: values are destroyed as soon as they're last used,
not at end of scope. This enables deterministic destruction without garbage collection.

*** Recommended Approach
Start with Option C (has_* methods) as immediate mitigation - it's simple, matches Rust,
and fixes ~40 call sites. For long-term, evaluate:
- Option F (ASAP destruction) - most automatic, Mojo-proven approach
- Option A (references) - matches Rust semantics closely
- Option E (smart for-in) - transparent optimization

*** Related Work
- Branch ~claude/detect-ccodegen-translation-diffs-A08OT~ attempted Option B
- That branch was not merged due to Rust/TIL divergence concerns
- ~has_struct~ method was prototyped on that branch

** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #112: Map uses O(n) linear scan instead of hash lookup
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Major performance bottleneck - self-hosted interpreter 2.7x slower than Rust
:STATUS: Blocked by Bug #113
:END:

*** BLOCKER: Bug #113
HashMap implementation was attempted but is blocked by Bug #113 (self-hosted
interpreter fails with "symbol 'msg' not found"). The HashMap code itself works
correctly with rstil, but when the self-hosted interpreter (bin/til) is rebuilt
with the new Map, tests fail due to Bug #113. Must fix Bug #113 first.

*** Attempted Implementation (branch wip_112)
Full HashMap implementation exists on branch ~wip_112~:
- Hash table with separate chaining (buckets + nexts arrays)
- ~hash_key()~ using ~Str.hash()~ for string keys, FNV-1a for others
- ~hash_lookup()~ for O(1) average key lookup
- Same API preserved (same throws and returns)
- All rstil tests pass, til_interpreted tests fail due to Bug #113

*** Description
The ~Map~ type in ~src/std/map.til~ uses O(n) linear scan for all operations (get,
set, contains_key, insert). Rust uses ~HashMap~ with O(1) average lookup. This is
the primary reason the TIL self-hosted interpreter is ~2.7x slower than rstil.

*** Current Implementation (O(n))
#+BEGIN_SRC til
// src/std/map.til lines 58-86
while lt(i, self._size) {
    // Linear scan through ALL keys for every lookup
    if Str.eq(self.key_type_name, "Str") {
        // String comparison for each key
    }
    i = add(i, 1)
}
#+END_SRC

*** Impact Analysis
- ~ScopeFrame~ uses 4 Maps: arena_index, symbols, funcs, enums
- 227 ~lookup_*~ calls throughout the codebase
- Each lookup scans potentially hundreds of entries
- With nested scopes, lookups iterate through multiple frames
- Result: quadratic behavior in hot paths

*** Fix Strategy (Two Phases)

**** Phase 1: Sorted Vec + Binary Search (O(log n))
- Keep keys sorted on insert
- Use binary search for lookups
- Simpler to implement, no hash function needed
- Good enough for initial improvement

**** Phase 2: Hash Map (O(1) average)
- Implement proper hash table with buckets
- Need hash function for Str keys

*** Hash Function Options (for Phase 2)

| Algorithm | Used By | Speed | Quality | Notes |
|-----------+------------+-------+---------+---------------------------------------|
| FNV-1a | Rust (old) | Fast | Good | Simple, 32/64-bit, good distribution |
| SipHash | Rust | Med | Best | DoS-resistant, cryptographic quality |
| xxHash | Many | Fast | Good | Extremely fast, good for large data |
| MurmurHash3 | Java, etc | Fast | Good | Popular, well-tested |
| wyhash | Go (new) | Fast | Good | Very fast, simple implementation |
| djb2 | Classic | Fast | OK | Very simple, older |

**** Recommended: FNV-1a
- Simple implementation (~10 lines)
- Good distribution for string keys
- Fast enough for interpreter use
- No external dependencies

#+BEGIN_SRC c
// FNV-1a hash (64-bit)
uint64_t fnv1a(const char* str, size_t len) {
    uint64_t hash = 14695981039346656037ULL;  // FNV offset basis
    for (size_t i = 0; i < len; i++) {
        hash ^= (uint8_t)str[i];
        hash *= 1099511628211ULL;  // FNV prime
    }
    return hash;
}
#+END_SRC

*** Implementation Notes
- Bucket count: power of 2 (allows bitwise AND instead of modulo)
- Collision handling: chaining (linked list) or open addressing
- Load factor: resize when > 0.75 full
- For TIL: can use ~ext_proc~ for C hash function, or implement in pure TIL

** Bug #101: Warn/error on unused things
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-01-13
:IMPACT: Code quality, catch dead code
:STATUS: Fixed
:END:

*** Description
Add warnings or errors for unused variables, functions, imports, struct fields, etc.
Currently we rely on rustc to catch these. Once rstil is gone, TIL needs this itself.

*** Implementation
- Error (not warning) for unused local variables and function arguments
- Suppression: prefix with underscore (e.g., ~_unused_var~)
- Tracks usage via ~used_symbols~ HashSet in ScopeStack
- ~mark_symbol_used()~ called when Identifier is checked
- ~get_unused_symbols()~ returns declared-but-unused symbols at function end
- Nested functions: inner usage merges back to outer scope

*** Files Changed
- src/rs/init.rs, src/self/init.til: Added used_symbols, mark_symbol_used, get_unused_symbols
- src/rs/typer.rs, src/self/typer.til: Mark symbols used, check at function end
- Various test and compiler files: Prefixed intentionally unused vars with ~_~

*** Decisions Made
- Error not warning: forces action, matches Go's approach
- Underscore prefix: simple, familiar convention from Python/Rust/Go
- Function-local only: global unused detection is more complex (may be used by other files)
- Nested function propagation: fixes false positives for outer vars used by inner functions

** Bug #100: Get rid of rstil
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Remove dependency on Rust implementation
:STATUS: Blocked
:END:

*** Description
Track requirements for removing the Rust implementation (rstil) and relying solely
on the self-hosted TIL compiler/interpreter.

*** Why This Matters
The current workflow is painful: every change must be made in two places (Rust and
Til), following strict translation rules in rs2til.org that are easy to forget under
pressure. Mistakes compound into bugs like #80.

Once #80 is done, the 4-mode tests become the source of truth. We can trust them to
catch divergence instead of manually policing every edit against rs2til.org.

Once #100 is done - real liberation. One codebase, no translation burden, freedom to
refactor and simplify without asking "does this still match the Rust?" The Til code
can finally be idiomatic Til instead of "Til that looks like Rust."

*** Requirements
- [ ] Bug #64: Custom main args in mode cli don't work properly
- [ ] Bug #78: TIL scavenger/ccodegen divergence from Rust
- [ ] Bug #80: ccodegen.til must generate identical C code to ccodegen.rs
- [ ] Issue #82: make.til - Replace Makefile with TIL
- [ ] Bug #83: No spread/splat operator for variadic argument forwarding
- [ ] Bug #84: run_cmd output capture broken in compiled mode
- [ ] Bug #85: Typer accepts struct literal with non-existent field name
- [X] Bug #86: For-in loop fails with enum that has enum payload
- [ ] Bug #87: Scavenger not pruning struct methods
- [ ] Issue #88: Macro Support (Compile-Time Evaluation)
- [ ] Issue #91: First-Class Functions
- [ ] Bug #92: Range loops should allow explicit iterator type annotation
- [ ] Bug #94: gcc warnings cause bug47.til compilation failure
- [ ] Bug #98: ext_proc errors should throw specific error types instead of panicking
- [ ] Bug #99: Eliminate all C compiler warnings and enable -Werror
- [X] Bug #101: Warn/error on unused things
- [ ] Remove Makefile, build with just gcc + make.til
  - Bootstrap: ~gcc bootstrap/til.c -o bin/til && ./make.til install~
  - make.til handles all build logic (rebuilding bin/til, itself, tests, etc.)
  - Remove rust targets from tests.til
  - Two fewer dependencies: rustc and make gone, only gcc remains
- [ ] Verify feature parity: all modes work (interpret, run, build, translate, repl)
- [X] Bug #102: Automatic dependency tracking from imports (Fixed 2026-01-16)
- [ ] Decide on acceptable performance and binary size criteria
  - Current state:
    - Size: til 2.3M vs rstil 6.8M
    - Dependencies: til (libc only) vs rstil (libc + libgcc_s)
  - Possible performance metrics:
    - All tests in all_common show "faster til" for both interpreted and compiled
    - ~til build til.til~ vs ~rstil build til.til~ (blocked by #80 infinite loop)
  - Possible performance criteria:
    - Ambitious: til faster or equal to rstil on every test
    - Moderate: no test more than 20% slower than rstil
    - Less ambitious: accept whatever we have when other requirements are met
  - Possible size criteria:
    - Ideal: til binary smaller than rstil
    - Accept growth if justified by performance (e.g., templates/monomorphization)

*** Not Required for #100
- Bug #97: Partial fix is sufficient. Shadowing detection is in both Rust and TIL
  typers, all existing code renamed. Final design decision (allow vs disallow)
  can wait until after #100.

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (2026-01-13)
Audit of generated C code shows these warning types:

| Type                         | Priority | Notes                                      |
|------------------------------+----------+--------------------------------------------|
| -Wdangling-pointer           | High     | Statement expressions return &local_var    |
| -Wreturn-type                | High     | Control reaches end of non-void function   |
| -Wincompatible-pointer-types | Medium   | Vec_push receives typed* instead of void** |
| -Wunused-variable            | Low      | Generated temp vars not always used        |
| -Wunused-but-set-variable    | Low      | Similar to above                           |
| -Wunused-label               | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           | Low      | ext.c has unused _err params               |

*** Fix Strategy (Incremental)
Current state: -Werror enabled with specific warning suppressions.

1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Once stable, switch to ~-Wall -Wextra -Werror~

*** Current Warning Suppressions (target.rs/til)
- ~-Wno-return-type~: clang is stricter than gcc about missing returns in all paths

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [ ] Step 3d: Enable and fix -Wdangling-pointer
- [ ] Step 3e: Enable and fix -Wreturn-type
- [-] Step 3f: Enable and fix -Wunused-variable (partial 2026-01-21: added __attribute__((unused)) to _status_, _arr_status_, _err_idx_ - reduced from 2877 to 1418 warnings)
- [ ] Step 3g: Enable and fix -Wunused-but-set-variable
- [ ] Step 3h: Enable and fix -Wunused-label
- [ ] Step 3i: Enable and fix -Wunused-parameter
- [ ] Step 3j: Enable and fix -Wshadow
- [ ] Step 4: Switch to -Wall -Wextra -Werror

** Bug #98: ext_proc errors should throw specific error types instead of panicking
:PROPERTIES:
:DISCOVERED: 2026-01-10
:IMPACT: ext_proc failures (writefile, readfile, etc.) panic instead of throwing catchable errors
:STATUS: Open
:END:

*** Description
Currently, ext_proc functions like writefile, readfile, etc. either:
- Rust (ext.rs): Return Err() which bubbles up and crashes
- C (ext.c): Panic with fprintf+exit

Instead, they should throw specific TIL error types (like WriteError, ReadError) that
can be caught with TIL's catch blocks, similar to how AllocError works for malloc.

*** Example (future behavior)
#+BEGIN_SRC til
write_err := writefile(path, contents)
catch (err: WriteError) {
    println("Write failed: ", err.msg)
}
#+END_SRC

*** Current Workaround
Check return values manually (for functions that return error strings) or let the
program crash on I/O failures.

** Bug #97: Disallow variable shadowing - type checker should error "X already declared"
:PROPERTIES:
:DISCOVERED: 2026-01-10
:IMPACT: Variable shadowing causes C codegen to mix up types, generating broken C code
:STATUS: Partially Fixed
:RELATED: Issue #66 (shadowing policy decision)
:END:

*** Description
TIL's C code generator doesn't properly handle variable shadowing (reusing the same
variable name in nested scopes). When Rust code uses shadowing (like ~let arg = ...~
multiple times), the translated TIL code reuses variable names, but the C codegen
assigns all shadowed variables to a single C variable, causing type conflicts.

*** Example
TIL code with shadowing:
#+BEGIN_SRC til
mut arg := Declaration()  // Outer scope
// ... use arg ...
mut arg := Expr()         // Inner scope - shadows outer arg
// ... use arg ...
#+END_SRC

Generated C code (BROKEN):
#+BEGIN_SRC c
til_Declaration til_arg;  // Declared once as Declaration
// ...
til_arg = (til_Expr){...};  // ERROR: assigning Expr to Declaration variable
#+END_SRC

*** Root Cause
The C codegen hoists all variable declarations to function scope and reuses the
same C variable for all TIL variables with the same name, even when they're
shadowed in different scopes.

*** Existing Checks (that aren't catching this)
There are already 2 "already declared" checks in src/rs/init.rs:

1. Line 165 in ~declare_var_in_arena()~: Checks ~current_frame.arena_index~ for duplicates
   #+BEGIN_SRC rust
   if name != "_" && current_frame.arena_index.contains_key(&name) {
       return Err(format!("Variable '{}' already declared in this scope", name));
   }
   #+END_SRC

2. Line 1022 in ~init_context()~: Checks if func/symbol already exists using ~lookup_symbol()~
   #+BEGIN_SRC rust
   if decl.name != "_" && (context.scope_stack.lookup_func(&decl.name).is_some() ||
                           context.scope_stack.lookup_symbol(&decl.name).is_some()) {
       errors.push(e.error(&context.path, "init", &format!("'{}' already declared.", decl.name)));
   }
   #+END_SRC

These checks aren't catching the shadowing cases that cause C codegen bugs.

*Why they don't catch nested scope shadowing:*
- ~init_context()~ only processes frame 0 (top-level/global scope of files)
- It only pushes 2 scope types: Global and Function (no Block scopes for if/while/for)
- Shadowing bugs occur in nested blocks INSIDE functions, which init never processes
- The typer processes nested scopes, but has no "already declared" check for current frame

*** Solution Attempts

*Attempt 1: Check in typer's check_declaration() function*

Added new helper method in ~src/rs/init.rs~ (ScopeStack impl):
#+BEGIN_SRC rust
pub fn lookup_symbol_current_frame(&self, name: &str) -> Option<&SymbolInfo> {
    if let Some(current_frame) = self.frames.last() {
        current_frame.symbols.get(name)
    } else {
        None
    }
}
#+END_SRC

Added check in ~check_declaration()~ function in ~src/rs/typer.rs~, after extracting
inner_e and before the existing ~lookup_symbol().is_none()~ check:
#+BEGIN_SRC rust
// Bug #97: Disallow variable redeclaration in same scope
// Skip check for "_" - it's special for discarding values
// Skip frame 0 - already checked by init_context
if decl.name != "_" && context.scope_stack.frames.len() > 1 {
    if context.scope_stack.lookup_symbol_current_frame(&decl.name).is_some() {
        errors.push(e.error(&context.path, "type", &format!("Variable '{}' already declared in this scope", decl.name)));
        return errors;
    }
}
#+END_SRC

*Result:* Check worked but triggered false positives on 43 legitimate declarations. Examples:
- ~src/core/vec.til:286~: "Variable 'elem' already declared in this scope"
- ~src/core/vec.til:303-304~: "Variable 'prev' already declared in this scope", "Variable 'curr' already declared"
- ~src/core/str.til:28-29~: "Variable 'self_byte' already declared", "Variable 'other_byte' already declared"

*Problems:*
1. These are legitimate declarations inside for-in loop bodies, not actual shadowing bugs
2. Each variable is only declared once in the source code (e.g., line 303: ~mut prev := ""~)
3. The typer only walks code once during type checking, doesn't execute loop iterations
4. Yet the check sees them as "already declared in this scope"

*Mystery:* Why is ~check_declaration()~ being called multiple times for the same
declaration, or why does ~lookup_symbol_current_frame()~ find the symbol already
declared when it should be the first time seeing it?

Need to investigate:
- Does catch block processing cause multiple passes?
- Does ~check_types_with_context()~ get called multiple times on the same Body?
- Is there something about how for-in bodies are type-checked that repeats?

This matches CLAUDE.md guidance: "AVOID variable shadowing in Rust - TIL doesn't
support shadowing the same way" (Issue #66 in future.org).

*** Reproduction
Test file: ~src/test/shadowing.til~ (not in tests.til until fixed)

#+BEGIN_SRC til
mode test

test_shadowing_different_types := proc() {
    mut x := 1        // I64
    if true {
        mut x := "hi" // Str - different type, C will fail to compile
    }
}
test_shadowing_different_types()
#+END_SRC

*Results:*
- ~rstil interpret src/test/shadowing.til~ - passes (exit 0), interpreter allows shadowing
- ~rstil run src/test/shadowing.til~ - fails (exit 1), C compilation error:
#+BEGIN_SRC
gen/c/test/shadowing.c:64:17: error: incompatible types when assigning to type 'til_I64' from type 'til_Str'
   64 |         til_x = ((til_Str){(til_I64)"hi", 2});
#+END_SRC

This demonstrates the bug: C codegen reuses the outer variable ~til_x~ (declared as I64)
instead of creating a new variable for the inner shadowing declaration.

*** Workaround
Manually rename shadowed variables to unique names (e.g., ~arg1~, ~arg2~, or
~outer_arg~, ~inner_arg~) in both TIL and Rust code to maintain consistency.

*** Design Options

This is a design decision, not just a bug fix. Options:

*Option A: Minimal - only disallow what C disallows*
- Disallow shadowing with different types in same function (what breaks C codegen)
- Allow same-type shadowing (C handles this fine)
- Least restrictive, matches C's actual limitations
- Typer cost: check type matches if name exists in any enclosing scope

*Option B: Strict - disallow all shadowing in same scope*
- Disallow any redeclaration in the same block scope, regardless of type
- More restrictive than C (C allows same-type shadowing in nested blocks)
- Typer cost: check name doesn't exist in current frame only
- Codegen benefit: can keep simple variable hoisting, no renaming needed

*Option C: Very strict - disallow all shadowing in entire function*
- Disallow any reuse of variable name anywhere in a function
- Most restrictive, prevents all shadowing confusion
- Typer cost: check name doesn't exist in any frame
- Codegen benefit: maximum simplicity

*Option D: Permissive like Rust - allow all shadowing*
- Allow shadowing anywhere, like Rust does
- Requires codegen to rename variables (e.g., ~x~ -> ~x_1~, ~x_2~)
- Typer cost: track shadow depth per variable
- Codegen cost: variable renaming logic, scope tracking

*** Two-Step Fix Plan

*Step 1 (initial):* Check in ccodegen, not typer - disallow ALL shadowing in function
- Keep ~declared_vars~ as simple ~HashSet<String>~ (no type tracking needed)
- If variable name already exists when declaring, emit TIL error
- Stricter than necessary (blocks same-type shadowing too) but much simpler
- Avoids the typer false positive mystery entirely
- Error message: "variable 'x' already declared in this function"

*Step 2 (final):* Implement the chosen design option in typer
- May require more sophisticated scope tracking
- Deferred until design is finalized (needs more examples to decide)

*Attempt 2: Check in ccodegen at hoist points*

Tried the "initial solution" approach: check in ccodegen's hoisting code, error on
ANY redeclaration using simple ~HashSet<String>~.

Added check at hoist points (emit_if, emit_while, emit_switch, emit_stmts catch):
#+BEGIN_SRC rust
if ctx.declared_vars.contains(&c_var_name) {
    return Err("Variable 'x' already declared in this function (shadowing not allowed)");
}
#+END_SRC

*Result:* Broke legitimate code patterns. Examples:
- ~for arg in a {}; for arg in b {}~ - same variable reused in sibling loops
- Variables declared in both if and else branches

*Root cause:* Hoisting makes ALL variables function-scoped in C. When we hoist from
sibling blocks (two loops, if/else branches), they share the same ~declared_vars~.
The check can't distinguish:
1. *Real shadowing:* outer variable shadowed by inner block declaration
2. *Legitimate reuse:* same variable used in multiple sibling blocks

*Approaches considered:*
- Track which vars were "hoisted" vs "top-level declared" - adds complexity
- Track types with HashMap, only error on type mismatch - also adds complexity
- Both defeated the goal of "simpler than type tracking"

*** Lessons Learned

The "simple HashSet" approach doesn't work because hoisting fundamentally changes
the problem. In TIL source, variables have block scope. In generated C, all
variables are hoisted to function scope. This means:

1. Sibling blocks (loops, if/else) legitimately share hoisted variables
2. We can't just check "name exists" - we need to know WHERE it was declared
3. Some complexity is unavoidable to distinguish shadowing from reuse

*** Decision

Final solution: TBD (needs more examples, possibly look at Haskell approach)
Initial solution: Deferred - the "simple" approach turned out to be not simple

*** Partial Fix (2026-01-11)

*What was done:*

1. Added shadowing detection in Rust typer (src/rs/typer.rs, src/rs/init.rs):
   - Added ~function_locals: HashSet<(String, usize, usize)>~ to ScopeStack
   - Added helper methods: ~is_inside_function~, ~is_shadowing_in_function~,
     ~is_already_processed~, ~register_function_local~
   - Added check in ~check_declaration()~ that errors on shadowing within functions
   - Tracks by (name, line, col) to handle AST duplication from for-in desugaring

2. Renamed all shadowed variables in TIL source files:
   - interpreter.til: ~270 renamed variables
   - ccodegen.til: Numerous renames (fcall_arg, hoisted_arg, ref_arg, etc.)
   - typer.til: Variable renames in switch cases and loops
   - precomp.til, scavenger.til: Context-specific prefixes added
   - builder.til, eval_arena.til, init.til: Various shadow fixes
   - Core files (str.til, set.til, list.til, map.til): Minor renames
   - enums.til test: Renamed name_copy to blue_name_copy

3. All 136 tests pass with ~make benchmark~

*What's still pending:*

1. Final design decision: TBD (see Design Options section above)
   - Current solution: Option C (disallow all shadowing within a function)
   - Possible final solutions:
     - Option A: Only disallow different-type shadowing (least restrictive)
     - Option D: Allow all shadowing like Rust, rename variables in C codegen (e.g., x -> x_1, x_2)

2. Port TIL variable renames to Rust for consistency: DONE
   - ccodegen.til -> ccodegen.rs: DONE (added nh_, emit_, else_, loop_, ntv_ prefixes)
   - init.til -> init.rs: DONE (added contextual prefixes)
   - typer.til -> typer.rs: DONE (added idx, nested, exh_, field_ prefixes)
   - lexer.til -> lexer.rs: DONE (err_token, peek_idx renames)
   - scavenger.til -> scavenger.rs: NOT NEEDED (Rust uses Option patterns)
   - precomp.til -> precomp.rs: NOT NEEDED (Rust uses block scoping)
   - interpreter.til -> interpreter.rs: NOT NEEDED (Rust uses match arms with separate scopes)
   - eval_arena.til -> eval_arena.rs: ALREADY HAD (existing_ prefixes)
   - builder.til -> builder.rs: ALREADY HAD (core_saved_path, mode_saved_path, etc.)
   - parser.til -> parser.rs: NOT NEEDED (Rust uses derive Clone, no manual clones)
   - mode.til -> mode.rs: NOT NEEDED (Rust uses inline vec![] literals)

   NOTE: Many TIL renames aren't needed in Rust because:
   - Rust supports proper block scoping (variables in match arms, if blocks are independent)
   - Rust uses Option<T> patterns instead of TIL's "found_X = true; catch" patterns
   - TIL needs unique names because C codegen hoists all variables to function scope

3. Port Rust shadowing detection to TIL for consistency: DONE
   - Added function_locals field to ScopeStack in init.til
   - Added helper methods to init.til (is_inside_function, is_shadowing_in_function,
     is_already_processed, register_function_local)
   - Added check in check_declaration() in typer.til
   - Added function_locals.clear() at start of check_func_proc_types() in typer.til

** Bug #96: Unreachable code error when return is before catch in early-return pattern
:PROPERTIES:
:DISCOVERED: 2026-01-09
:IMPACT: Cannot translate Rust's if-let-some early-return pattern directly
:STATUS: Open
:END:

*** Description
When translating Rust's ~if let Some(x) = map.get(key) { use(x); return; }~ pattern,
the natural TIL translation puts a ~return~ before the catch block, causing an
"unreachable code" error because the compiler doesn't understand that the catch
is reachable via the throw path.

*** Example
Rust:
#+BEGIN_SRC rust
if let Some(temp_var) = ctx.hoisted_exprs.get(&expr_addr) {
    output.push_str(temp_var);
    return Ok(());
}
// continue with normal processing...
#+END_SRC

TIL (BROKEN - unreachable code error):
#+BEGIN_SRC til
ctx.hoisted_exprs.get(expr_addr, temp_var)
output.push_str(temp_var)
return  // ERROR: makes catch unreachable
catch (err: KeyNotFoundError) {
    // Not found, continue
}
// continue with normal processing...
#+END_SRC

*** Workaround
Wrap the success-case code in ~if true { }~. This makes the catch reachable
because the compiler sees the return as conditional:

#+BEGIN_SRC til
ctx.hoisted_exprs.get(expr_addr, temp_var)
if true {  // TODO Bug #96 workaround
    output.push_str(temp_var)
    return
}
catch (err: KeyNotFoundError) {
    // Not found, continue
}
// continue with normal processing...
#+END_SRC

*** Proper Fix
The compiler should recognize that catch blocks are reachable via the throw path,
even when there's a return statement before them in the textual order.

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-01-13)
| Mode            | Result              | Time  |
|-----------------+---------------------+-------|
| rstil interpret | pass                | 2.3s  |
| rstil run       | pass                | 5.2s  |
| til interpret   | pass                | 53s   |
| til run         | OOM killed (exit 137) | ~61s  |

~til run~ gets SIGKILL from OOM killer after ~61s (with 10s sys time indicating
memory pressure). The til ccodegen uses excessive memory when processing
bug47.til which imports self.typer (most of the compiler).

Note: til is ~20x slower than rstil for interpretation, but the real issue
is memory consumption during ccodegen causing OOM.

*** Current Warnings (2026-01-13)
1654 total warnings when compiling with ~gcc -Wall -Wextra~:

| Count | Type                        | Severity |
|-------+-----------------------------+----------|
|   933 | -Wunused-variable           | Low      |
|   318 | -Wdangling-pointer          | High     |
|   195 | -Wincompatible-pointer-types | Medium   |
|   135 | -Wunused-but-set-variable   | Low      |
|    66 | -Wunused-label              | Low      |
|     5 | -Wunused-parameter          | Low      |
|     1 | -Wreturn-type               | High     |
|     1 | null character in literal   | Low      |

**** Dangling Pointer (318 occurrences)
Statement expressions return pointers to local variables that go out of scope:
#+BEGIN_SRC c
// Generated code pattern:
if (til_not(({ til_Bool _tmp = til_U8_eq(&a, &b); &_tmp; })).data) { ... }
//                                                 ^^^^^
// _tmp goes out of scope, pointer dangles
#+END_SRC

**** Incompatible Pointer Types (195 occurrences)
Vec_push expects ~void**~ but receives typed pointers:
#+BEGIN_SRC c
til_Vec_push(&_err, &vec, &_tmp_str);  // _tmp_str is til_Str*
#+END_SRC

**** Return Type (1 occurrence)
Function ~til_get_value_type~ at line 13360 - control reaches end without return.

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [ ] Fix til ccodegen memory usage (high priority - OOM on large files)
- [ ] Fix dangling pointer pattern in ccodegen (high priority)
- [ ] Fix missing return statement (high priority)
- [ ] Add casts for Vec_push calls or specialize per type
- [ ] Consider which unused-* warnings to fix vs suppress

** Bug #92: Range loops should allow explicit iterator type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Type safety, code clarity
:STATUS: Open - attempted approach failed
:END:

*** Description
Range loops (e.g., ~for i in 0..100~) infer the iterator type automatically.
However, there's no way to explicitly specify the iterator type when desired
for clarity or type safety.

*** Failed Attempt (2026-01-08): Unified iteration via I64Range struct

**** Approach
Tried to unify range and collection iteration by creating an I64Range struct
with len()/get() methods, allowing range loops to use the same desugaring
path as collection loops (for-in over Vec, Array, etc.):

- Created ~src/core/range.til~ with I64Range struct
- Parser changes: removed range-to-while desugaring, created ForIn nodes
- Precomp changes: wrapped Range expressions with I64Range(start=X, end=Y)
- Range loops would then use standard len()/get() desugaring

**** Why It Failed
The I64Range.get() method throws IndexOutOfBoundsError. The for-in desugaring
generates a catch block for this error that panics. This catch block contains
a variable ~til_err~.

When C code is generated, all local variables are hoisted to function scope.
If a function has multiple for-in loops over ranges, each generates its own
catch block with ~til_err~, causing redeclaration errors in C.

Additionally, the existing parser-based range desugaring was simpler and
didn't require any error handling (it used direct increment/decrement without
bounds checking on each iteration).

**** Key Diff Insight (from bootstrap/til.c)
OLD (parser desugaring):
#+BEGIN_SRC c
til_I64 til_i = 0;
while (til_lt(&til_i, &end).data) {
    // body
    til_I64_inc(&til_i);
}
#+END_SRC

NEW (I64Range approach):
#+BEGIN_SRC c
til_I64 _for_i_func_0 = 0;
til_I64 til_i;
while (til_lt(&_for_i_func_0, &(til_I64){til_I64Range_len(...)}).data) {
    til_IndexOutOfBoundsError _thrown_...;
    til_I64Range_get(...);  // throws
    if (0) { _catch_...:
        til_IndexOutOfBoundsError til_err = ...;  // PROBLEM: hoisted
        til_panic(...);
    }
    // body
}
#+END_SRC

The ~til_err~ variable gets hoisted, and multiple catch blocks in the same
function cause redeclaration errors.

**** Code: I64Range struct (src/core/range.til)
#+BEGIN_SRC til
mode lib

// I64Range struct for unified iteration over numeric ranges
// Used by for-in loops: `for i in 0..10` becomes iteration over I64Range(start=0, end=10)
// Named I64Range (not Range) to prepare for future template support: Range<I64>, Range<U8>, etc.

I64Range := struct {
    mut start: I64 = 0
    mut end: I64 = 0

    // Required by collection interface
    size := func(self: I64Range) returns I64 {
        return 16  // Two I64 fields (8 bytes each)
    }

    len := func(self: I64Range) returns I64 {
        if self.end.gteq(self.start) {
            return self.end.sub(self.start)
        }
        return self.start.sub(self.end)
    }

    get := proc(self: I64Range, index: I64, mut out: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self.len()) {
            throw IndexOutOfBoundsError(msg="I64Range.get: index out of bounds")
        }
        if self.end.gteq(self.start) {
            out = self.start.add(index)  // Forward: 0..10 -> 0,1,2...
        } else {
            out = self.start.sub(index)  // Reverse: 10..0 -> 10,9,8...
        }
    }
}
#+END_SRC

**** Code: Precomp change to wrap Range in I64Range (src/rs/precomp.rs)
#+BEGIN_SRC rust
// In precomp_forin(), after getting raw_collection_expr:

// Bug #92: If collection is a Range expression, wrap it in I64Range(start=..., end=...)
// This allows range loops to use the same len()/get() desugaring as collections
let collection_expr = if let NodeType::Range = &raw_collection_expr.node_type {
    let start_expr = raw_collection_expr.get(0)?.clone();
    let end_expr = raw_collection_expr.get(1)?.clone();
    // Build: I64Range(start=<start>, end=<end>)
    Expr::new_explicit(
        NodeType::FCall,
        vec![
            Expr::new_explicit(NodeType::Identifier("I64Range".to_string()), vec![], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("start".to_string()), vec![start_expr], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("end".to_string()), vec![end_expr], e.line, e.col),
        ],
        e.line,
        e.col,
    )
} else {
    raw_collection_expr
};
#+END_SRC

**** Alternative Approaches to Consider
1. **Non-throwing Range.get()**: Return a sentinel/default instead of throwing.
   But this breaks the collection interface contract.

2. **Special-case ranges**: Keep ranges separate from collections. They're
   fundamentally different (arithmetic progression vs stored elements).

3. **Fix C hoisting**: Track catch block error variables specially to avoid
   redeclaration. Complex.

4. **Keep current parser desugaring**: The simplest approach. Range loops
   work correctly as-is. Focus on adding type annotation support without
   changing the desugaring mechanism.

*** What's Still Needed
- Type annotation syntax: ~for i: I64 in 0..10~ (parser change only)
- No need to unify with collection iteration for this feature

** Bug #90: Parser requires semicolon for bodyless func/proc definitions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Syntax ergonomics
:STATUS: Partially Fixed
:END:

*** Description
The parser cannot determine where a function/proc definition ends when there
is no body. Previously required a semicolon as a terminator.

*** Initial Fix (2026-01-07)
Semicolons are now completely optional - skipped by the lexer as whitespace.
~ext_func~ and ~ext_proc~ require an empty body ~{}~ instead of a semicolon.

*** Final Solution (pending)
Make the parser smart enough to not require empty bodies at all.
Then remove all ~{}~ from ext_func/ext_proc declarations.

*** Examples
#+BEGIN_SRC til
// Has body - no semicolon needed
add := func(a: I64, b: I64) returns I64 {
    return a.add(b)
}

// No body (ext) - uses empty body {}
// From src/core/print.til:
single_print := ext_proc(s: Str) {}
print_flush  := ext_proc() {}

// Inside struct definitions - also uses {}
// From src/std/meta.til:
Introspection := struct {
    has_const := ext_func(type_name: Str, const_name: Str) returns Bool {}
}

// Semicolons are now completely optional everywhere:
;;;;;;;;;;;;;;;;;;;;  // Just whitespace, ignored
#+END_SRC

*** Changes Made

*Lexer changes:*
- Removed ~Semicolon~ and ~DoubleSemicolon~ token types
- Lexer now skips any sequence of semicolons (treated as whitespace)

*Parser changes:*
- Removed ~TokenType::Semicolon~ from ~func_proc_returns()~ and ~func_proc_throws()~
- Removed ~do_parse_body~ parameter from ~parse_func_proc_definition()~
- Always parse body, error if non-empty for ext_func/ext_proc
- Removed dead code for semicolon handling in ~parse_switch_statement()~ and ~parse_body()~
- Removed ~go_back()~ method (no longer needed)

*Test changes:*
- Added semicolon regression test in src/test/flow.til
- Removed ~test_lexer_go_back~ test (method removed)

*** Future Enhancement (Step 3)
Context-aware lookahead could allow:
#+BEGIN_SRC til
single_print := ext_proc(s: Str)  // Just works without {}
#+END_SRC
Parser would infer end of definition from context. Post-self-hosting enhancement.

*** Files Changed
- src/rs/lexer.rs, src/self/lexer.til
- src/rs/parser.rs, src/self/parser.til
- src/std/meta.til (changed ; to {} for struct ext_funcs)
- src/test/flow.til (added regression test)
- src/test/test_lexer.til (removed go_back test)

** Bug #89: Constant folding only works at global scope
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Performance, macro implementation
:STATUS: Active
:END:

*** Description
Pure function calls with all compile-time known arguments are only constant
folded at global scope. Inside function bodies, they are not folded even when
all arguments are literals.

*** Example
#+BEGIN_SRC til
double := func(x: I64) returns I64 { return x.mul(2) }

// Global scope - folded to literal 10
global_result := double(5)

test := proc() {
    // Inside function - NOT folded, calls double() at runtime
    inner_result := double(10)
}
#+END_SRC

Generated C shows:
- ~til_global_result = 10~ (folded)
- ~til_inner_result = til_double(...)~ (not folded)

*** Location
~precomp_expr()~ in src/rs/precomp.rs / src/self/precomp.til has:
#+BEGIN_SRC til
at_global_scope := context.scope_stack.frames.len().eq(1)
if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
    const_folded = eval_comptime(context, const_folded)
}
#+END_SRC

The ~at_global_scope~ check should be removed.

*** Impact on Issue #88 (Macros)
This bug blocks proper macro implementation. Macros should be evaluated at
compile time regardless of where they are called.

*** Why the Fix is Safe

The ~at_global_scope~ check was added for Bug #41 to prevent double output from
functions with side effects. However, this is overly conservative because:

1. *~is_proc()~ correctly identifies side effects*: The type system guarantees
   that ~func~ cannot call ~proc~ (enforced by typer). Only ~proc~ can call
   ~ext_proc~, which is where actual side effects (I/O, memory allocation) live.

2. *Trust the type system*: If ~is_proc()~ returns false, the function is pure.
   The ~is_comptime_evaluable()~ check already calls ~is_proc()~ and rejects
   procs from folding.

3. *liba/pura exception is a debugging hack*: These modes allow ~func~ to call
   ~println~ as a convenience for debugging pure/lib code. If such funcs get
   evaluated twice (once at compile-time, once at runtime), that's an acceptable
   consequence of using the debugging modes.

4. *User responsibility*: If someone declares an ~ext_func~ that actually has
   side effects (instead of ~ext_proc~), that's the user's or mode designer's
   fault. The type system is correct; misuse is not our problem.

*** Future Enhancement
Add warnings when ~proc~ is used but ~func~ would suffice. Using ~proc~
unnecessarily causes a cascade effect - anything calling it must also be ~proc~
or in a special mode. This means users miss constant folding optimizations for
entire call chains.

*** Implementation Attempt (2026-01-07)

Tried removing ~at_global_scope~ checks from three locations. Result: build fails.

**** Three Locations with at_global_scope Check

1. *FCall folding* in ~precomp_expr()~ (precomp.rs line 229-235, precomp.til line 301-307):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // Only fold at global scope - inside function definitions, values from other
   // modules may not be available yet (import ordering). Interpreter doesn't
   // evaluate function bodies during import either.
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope && is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Try compile-time constant folding for pure functions with literal args.
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects
   // via the type system (func cannot call proc, only proc can call ext_proc).
   if is_comptime_evaluable(context, &const_folded) {
       const_folded = eval_comptime(context, &const_folded)?;
   }
   #+END_SRC

2. *Primitive storage* (I64/U8/Str) in ~precomp_declaration()~ (precomp.rs line 958-973, precomp.til line 1174-1191):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // Only do this at global scope - inside function bodies, evaluating could cause side effects
   // to run at compile time AND runtime (e.g., print_debug func in mode liba).
   let at_global_scope = context.scope_stack.frames.len() == 1;
   if at_global_scope {
       if let ValueType::TCustom(ref custom_type_name) = &value_type {
           match custom_type_name.as_str() {
               "I64" | "U8" | "Str" => {
                   if is_comptime_evaluable(context, &new_params[0]) {
                       let inner_e = &new_params[0];
                       let result = eval_expr(context, inner_e)?;
                       if !result.is_throw {
                           EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                       }
                   }
               },
               _ => {},
           }
       }
   }
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // Store I64/U8/Str declarations in arena when their initializer is comptime-evaluable.
   // ...
   // is_comptime_evaluable checks is_proc() which correctly identifies side effects.
   if let ValueType::TCustom(ref custom_type_name) = &value_type {
       match custom_type_name.as_str() {
           "I64" | "U8" | "Str" => {
               if is_comptime_evaluable(context, &new_params[0]) {
                   let inner_e = &new_params[0];
                   let result = eval_expr(context, inner_e)?;
                   if !result.is_throw {
                       EvalArena::insert_primitive(context, &decl.name, &value_type, &result.value, e)?;
                   }
               }
           },
           _ => {},
       }
   }
   #+END_SRC

3. *Struct instance storage* in ~precomp_declaration()~ (precomp.rs line 975-991, precomp.til line 1193-1206):

   BEFORE (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   // Only do this at global scope (same reason as above - avoid side effects inside func bodies).
   if at_global_scope && !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

   AFTER (Rust):
   #+BEGIN_SRC rust
   // For non-mut struct instance declarations (like `true := Bool.from_i64(1)`),
   // run eval_declaration to store the instance in EvalArena so ccodegen can find it.
   if !decl.is_mut && !decl.is_copy && !decl.is_own && is_comptime_evaluable(context, &new_params[0]) {
   #+END_SRC

**** Error When Removing All Three Checks

#+BEGIN_SRC
./bin/rstil build make.til
ERROR: src/core/array.til:41:45: rstil insert_string_into_frame ERROR:
  Str template not found - ensure str.til is imported
#+END_SRC

**** Root Cause Analysis

The issue is NOT about side effects (the "Why Fix is Safe" analysis is correct for that).
The issue is about *infrastructure availability during precompilation*:

1. *Precomp vs Eval timing*: ~precomp_expr~ runs before ~eval~. During precomp of
   function bodies, we're still in the syntactic transformation phase.

2. *Templates created during eval*: The ~EvalArena.default_instances["Str"]~ template
   is created when global Str declarations are evaluated, not during precomp.

3. *Order problem*: When precompiling ~src/core/array.til~'s function bodies (which
   contain format() calls that create Str), the Str template doesn't exist yet
   because we haven't finished evaluating global scope.

4. *Why global scope works*: At global scope, declarations are both precompiled AND
   evaluated in sequence. The Str template gets created by earlier declarations
   before later ones need it.

5. *Why function bodies fail*: Function bodies are precompiled during the module
   import phase, but not evaluated. The template infrastructure isn't available.

**** What Needs to Change

Simply removing ~at_global_scope~ doesn't work. The fix requires understanding
the precomp/eval interaction:

- *FCall folding (Location 1)*: Might work alone if ~eval_comptime~ doesn't try
  to store values that need templates. Needs investigation.

- *Primitive/Struct storage (Locations 2 & 3)*: Cannot work without templates.
  Options:
  1. Make template lookup fail gracefully (skip storage, don't error)
  2. Defer non-global storage to evaluation phase
  3. Initialize templates earlier (during precomp init?)
  4. Only fold to literals, don't store in arena for non-global

**** Files to Investigate Further

- ~src/rs/eval_arena.rs~: ~insert_string_into_frame()~, ~default_instances~ map
- ~src/rs/precomp.rs~: ~eval_comptime()~, understand what it stores vs returns
- ~src/rs/interpreter.rs~: When/how templates get initialized
- The interaction between ~precomp_expr~ -> ~eval_comptime~ -> ~EvalArena~

**** TIL Equivalents

The same changes were ported to ~src/self/precomp.til~:
- Location 1: lines 301-307 (FCall folding)
- Location 2: lines 1174-1191 (primitive storage)
- Location 3: lines 1193-1206 (struct instance storage)

The TIL syntax differs slightly (e.g., ~at_global_scope.and(...)~ instead of
~at_global_scope && ...~) but the logic is identical.

*** Tests
- tmp/test_constfold_scope.til - demonstrates the issue

** Bug #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Active (workaround exists)
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** History

**** 2026-01-01 to 2026-01-08: Initial Approach (Abandoned)
Original approach was to incrementally fix divergences in the existing ccodegen.til
through line-by-line comparison with ccodegen.rs. This proved problematic because:
- ccodegen.til had many missing ports from Rust
- Contained unauthorized workarounds and non-matching comments
- AI assistants kept adding more divergences instead of fixing them
- The accumulation of issues made systematic comparison impossible

**** 2026-01-09: Fresh Rewrite
Decision made to delete all self-hosted compiler files and start fresh:
- Commit ~1f29279a~: "Remove self-hosted compiler files for fresh rewrite"
- Blind translation of ccodegen.til, builder.til, til.til from Rust
- ~150+ commits fixing syntax, types, missing methods, etc.

***** WARNING: Broken Commit Range
Commits from ~1f29279a~ (origin/master + 1) through ~fad411f8~ are ALL BROKEN.
The build fails throughout this range because:
1. Fresh translation introduced many syntax/type errors
2. Each commit fixed some errors but build still failed
3. Only at ~fad411f8~ "Fix uninitialized variables..." does build pass again

This matters for:
- ~git bisect~: Skip this entire range, it's all broken
- ~git rebase -i~: Could squash ~1f29279a..fad411f8~ into single commit
- Archaeology: Don't waste time investigating individual commits in this range

**** 2026-01-12: Progress - Fixed if-let-Ok pattern in init.til
Build passes. 80/80 tests pass (0 failures). Test breakdown:
- 65 tests in all_common (pass all 4 modes) - includes maps.til!
- 1 test in til_common (panic.til)
- 4 tests in rs_interpreted
- 3 tests in rs_compiled
- 7 tests in rs_common
- 0 tests in til_interpreted (empty!)

Recent fixes:
- Fixed gcc stderr handling in builder.til to match Rust (capture stderr, only show on failure)
- Fixed hoisted_exprs collision: clear per-function to avoid cross-file line/col key collisions
- Fixed many if-let-Some translation bugs in ccodegen.til per rs2til.org rules:
  - emit_switch: enum_has_payloads, collect_declarations, payload lookup patterns
  - collect_declarations_recursive: type inference pattern
  - emit_assignment, emit_if, emit_while: vt check patterns
  - Various enum/struct lookup patterns with flag variables
- KEY FIX: Fixed if-let-Ok translation bug in init.til get_fcall_value_type
  - target_type was used after get_value_type could throw, causing garbage data
  - Added flag pattern: ~mut have_target_type := true~ with catch setting to false
  - This fixed enums.til and other nested function + switch case failures
- KEY FIX: Fixed ext.c run_cmd returning wrong exit code when output exceeds 64KB buffer
  - Rust's Command::output() captures all output; ext.c had 64KB limit
  - When buffer filled, pclose() with unread data caused gcc to get SIGPIPE -> non-zero exit
  - Added drain loop to consume remaining output before pclose()
  - This fixed maps.til and allowed moving it to all_common (all 4 modes pass)

*** Root Cause Analysis

The recurring bug pattern was if-let-Some/if-let-Ok translations from Rust:

#+begin_src rust
// Rust: if get_value_type fails, body is skipped
if let Ok(target_type) = get_value_type(context, first_arg) {
    // use target_type
}
#+end_src

#+begin_src til
// WRONG TIL: target_type is garbage if get_value_type throws!
target_type := get_value_type(context, first_arg)
catch (err: Str) { }
switch target_type {  // Uses garbage!
#+end_src

#+begin_src til
// CORRECT TIL: flag pattern per rs2til.org
mut have_target_type := true
target_type := get_value_type(context, first_arg)
catch (err: Str) {
    have_target_type = false
}
if have_target_type {
    switch target_type {  // Safe to use
#+end_src

*** Remaining Work
- 7 tests in rs_common (pass with rstil but not with til)
- Final verification: ~./src/til_diff.til src/til.til~ must show no differences
  - Note: times out at 300s - likely infinite loop (til compiled total is only 80s)

*** Debugging Tools

- ~./src/til_diff.til src/test/foo.til~ - compare rstil vs til generated C code
- ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ - test single file
- ~./make.til til_debug~ - build til with debug symbols for gdb
- ~gdb ./bin/til_debug~ - step through with breakpoints, inspect variable values
- ~gdb -batch -ex "run ..." -ex "bt" ./bin/til~ - get crash backtrace
- Look at ~gen/c/test/*.c~ for generated code

TIL code must be an exact translation from Rust (comments and variable names included)
using rs2til.org translation rules. Any differences detected must be fixed immediately,
even if only cosmetic.

Current test: ~src/test/c_mem.til~

**** Iterative Fix Workflow
1. User picks a test from til_interpreted that they want working in til_compiled
2. Run ~./src/til_diff.til src/test/chosen_test.til~ to compare rstil vs til generated C code
3. Analyze the diff - identify what's different in the generated C
4. Identify root cause in ccodegen.til
5. Verify against Rust - check equivalent code in ccodegen.rs
6. Fix following rs2til.org - apply correct translation pattern
7. Test the fix: ~./bin/til run src/test/chosen_test.til~
8. Run ~timeout 300 make benchmark~ (always use timeout 300 for make benchmark)
9. Re-run all failing tests in parallel to update TODO comments:
   - Run ~timeout 10 ./bin/til run src/test/X.til 2>&1~ for each test in til_interpreted
   - Update inline TODO comments with current errors
   - If any tests now pass, move them from til_interpreted + rs_common to all_common
   - If tests were moved, run ~make benchmark~ again to verify
10. Commit the fix (tests.til now has up-to-date TODOs and test locations)
11. Wait for user to pick next test to fix

**** Test Tracking
Each test in til_interpreted (src/tests.til) has an inline TODO comment explaining
why it fails in til_compiled:
#+BEGIN_SRC til
til_interpreted.push(TestEntry(path="src/test/foo.til"))  // TODO: too few args to til_Array_get
#+END_SRC
When a test passes til_compiled, remove TODO and move to all_common.

**** Updating TODO Comments
- Run ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ for each test to get the error
- Use timeout to catch infinite loops (exit code 124 = timeout)
- Run tests in parallel (multiple Bash tool calls), no shell loops
- NO filtering (no head, tail, grep) - see full output
- Extract the key error from output and add as inline TODO comment

**** Critical Rules
- Source of truth is Rust + rs2til.org - TIL code must match Rust translated per rs2til.org rules
- Validate changes by comparing Rust to TIL - run ~git diff~ and check both sides match per rs2til.org
- Correctness per rs2til.org is primary - whether a change "fixes" a test is secondary
- If change follows rs2til.org but doesn't fix issue - there's a DIFFERENT bug elsewhere
- NEVER filter make benchmark output - see ALL errors
- Avoid variable shadowing - Bug #97 disallows it
- Port fixes to BOTH Rust and TIL when needed

**** Files Modified
- src/self/ccodegen.til
- src/self/builder.til
- src/til.til
- src/rs/ccodegen.rs (when porting fixes)
- src/rs/builder.rs (when porting fixes)
- src/tests.til (when moving tests back to all_common)

*** Progress

**** Fixed Issues (from fresh rewrite)
1. Variable shadowing in emit_declaration (fcall_arg, hoisted_arg, ref_arg)
2. Variable shadowing in builder (reuse errors vector, default_fd rename)
3. Uninitialized variables after throwing calls:
   - detect_variadic_fcall (8 locations)
   - get_type_arg_name
   - lookup_struct
   - get_fcall_func_def in emit_throw
   - get_fcall_func_def in hoist_throwing_expr

**** Issues Found in hello_script.til Diff (2026-01-11)
Current diff from ~./src/til_diff.til src/examples/hello_script.til~:

***** Issue 1: til_Array_get missing 3 arguments
rstil generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1, til_extra_msgs, &_for_i_panic_0, (til_Dynamic*)&til_extra_msg);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1);
#+END_SRC
Affects 5 locations in hello_script.til (lines 101, 132, 165, 185, 233)

****** 2026-01-11: Fixed - Multiple issues in emit_throwing_call* functions
Root cause: Several interrelated bugs in argument emission for throwing function calls.

1. Catch block placement: Catch blocks were placed AFTER emit_arg_with_param_type(),
   so when param_by_ref.get() or param_types.get() threw IndexOutOfBoundsError,
   emit_arg_with_param_type was skipped entirely, causing missing arguments.

2. param_types type mismatch: emit_throwing_call_propagate and emit_throwing_call_with_goto
   stored Vec<Ptr> but hoist_for_dynamic_params expected Vec<ValueType>. This caused
   incorrect Dynamic casts to be applied to all arguments.

3. regular_arg_count defaulting to 0: In emit_throwing_call_with_goto, for non-variadic
   functions, regular_arg_count came from variadic_info.regular_count which defaults to 0.
   The loop `if arg_i.sub(1).gteq(regular_arg_count)` would break immediately.
   Fixed by using 999999999 for non-variadic (matches Rust's usize::MAX pattern).

Fixed in emit_throwing_call, emit_throwing_call_propagate, emit_throwing_call_with_goto:
- Move catch blocks immediately after .get() calls, before emit_arg_with_param_type
- Change param_types from Vec<Ptr> to Vec<ValueType>
- Convert ValueType to Ptr when calling emit_arg_with_param_type
- Use large default for regular_arg_count in non-variadic case

After fix: til_Array_get arguments now match rstil output.
Remaining diffs are hoisting differences (temp var numbering) which are cosmetic.

***** Issue 2: til_malloc missing 1 argument
rstil generates:
#+BEGIN_SRC c
til_I64 _tmp_format_13 = til_add(&til_result.cap, &(til_I64){1});
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12, &_tmp_format_13);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12);
#+END_SRC

***** Issue 3: Hoisting differences
rstil hoists expressions to temp vars:
#+BEGIN_SRC c
til_I64 _tmp_format_14 = til_mul(til_index, &til_self->type_size);
const til_I64 til_src = til_add(&til_self->ptr, &_tmp_format_14);
#+END_SRC
til uses inline compound literals:
#+BEGIN_SRC c
const til_I64 til_src = til_add(&til_self->ptr, &(til_I64){til_mul(til_index, &til_self->type_size)});
#+END_SRC
Both are valid C but cause temp variable numbering drift.

***** Issue 4: .msg inline vs hoisted
rstil hoists format call:
#+BEGIN_SRC c
til_Str _tmp_til_Array_get_7 = til_format(...);
*_err1 = (til_IndexOutOfBoundsError){.msg = _tmp_til_Array_get_7};
#+END_SRC
til inlines:
#+BEGIN_SRC c
*_err1 = (til_IndexOutOfBoundsError){.msg = til_format(...)};
#+END_SRC

****** 2026-01-12: Fixed - is_struct_constructor catch placement in init.til
The is_struct_constructor function in init.til had a catch block placed outside
the if block where the throwing code was:

#+BEGIN_SRC til
// WRONG - catch was outside if block, never catches lookup_struct exceptions
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    return true
}
catch (err: KeyNotFoundError) {  // Never triggered!
    return false
}
#+END_SRC

Fixed by moving the catch inside the if block:

#+BEGIN_SRC til
// CORRECT - catch inside same scope as throwing code
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    catch (err: KeyNotFoundError) {
        return false
    }
    return true
}
#+END_SRC

This fix resolves the hoisting differences - til_diff.til now shows "OK: No differences found!"

****** 2026-01-12: Test re-categorization after is_struct_constructor fix
With the catch placement fix, many tests now pass til_compiled mode.
Updated test categories in src/tests.til:
- 17 tests in all_common (pass all 4 modes)
- 49 tests in til_interpreted (pass til interpret, fail til compile)
- 53 tests in rs_common (pass rstil, fail til compile)

****** 2026-01-12: Discovered til.til run_cmd_vec swallows output
Tests showing "empty output" in til_compiled mode are caused by til.til's
run_cmd_vec function capturing stdout into a variable but never printing it:

#+BEGIN_SRC til
run_cmd_vec := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args { full_cmd = full_cmd.concat(" ").concat(arg) }
    mut output := ""
    return output.run_cmd("bash", "-c", full_cmd)  // output captured but never printed!
}
#+END_SRC

In contrast, rstil.rs uses Command::new().status() which inherits stdout.
This is NOT a ccodegen bug - the C code is identical. Needs separate fix in til.til.

****** 2026-01-12: Fixed run_cmd_vec output swallowing
Added run_cmd_vec_print to sys.til that prints captured output after run_cmd:

#+BEGIN_SRC til
run_cmd_vec_print := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)
    if output.len().gt(0) {
        print(output)
    }
    return exit_code
}
#+END_SRC

Updated til.til's run_file_or_exit to use run_cmd_vec_print instead of run_cmd_vec.
This matches rstil.rs's Command::new().status() behavior of inheriting stdout.

****** 2026-01-12: Final test re-categorization after run_cmd_vec_print fix
Tests that were failing with "empty output" now work correctly.
Updated test categories in src/tests.til:
- 22 tests in all_common (pass all 4 modes)
- 1 test in til_common (panic.til - error msg format differs "til" vs "rstil")
- 43 tests in til_interpreted (pass til interpret, fail til compile)
- 48 tests in rs_common (pass rstil, fail til compile)
- Total: 121 tests, 0 failures

Tests moved to all_common:
- hello_cli.til, hello_script.til, lolalalo.til (examples)
- bug46.til, underscore.til (tests)

****** 2026-01-12: Fixed hello_test.til constant folding
Two fixes to make hello_test.til pass til_compiled:

1. emit_arg_with_param_type in ccodegen.til: Added fc_fd_found flag to prevent
   double-emission when catch block handles KeyNotFoundError. The catch block
   would emit the expression, then code continued to emit it again.

2. is_comptime_evaluable in precomp.til: Changed from lookup_func to
   get_func_def_for_fcall_with_expr for proper UFCS resolution. This allows
   constant folding of expressions like ~not(I64.eq(42, 43))~.

Tests moved to all_common (11 tests):
- hello_test.til, arithmetics.til, boolean.til
- branchless.til, bug41.til, circular_test.til, comparisons.til
- eval.til, intro.til, literals.til, namespaces.til, variadic.til

Tests moved back from all_common (failed til_compiled):
- arenas.til (gcc type mismatch)
- arrays.til (gcc type mismatch)
- bug52.til (gcc shadow warning)
- underscore.til (segfault)

**** Known Error Patterns in Generated C
- ~too few arguments to function~ - missing args in generated calls
- ~undeclared variable~ - variable not emitted

*** Files That Must Match
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Final Verification
~make benchmark~ - all tests pass

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Active
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Reproducing Issue 1 (I64 args in interpreted mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, count: I64) {
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

Running: ~./bin/rstil interpret test.til hello 42~

Error: ~calling function 'main' expects 'I64' for arg 'count', but 'Str' was provided~

*** Reproducing Issue 2 (custom named args in compiled mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, value: Str) {
    println("name:", name, "value:", value)
}
#+END_SRC

Running: ~./bin/rstil run test.til hello world~

Error: C codegen produces ~til_main(&_main_args)~ with 1 arg but til_main expects 2+.
The C codegen only handles the standard ~args: ..Str~ pattern.

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.

