#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it,
# BOT: add them at the top of active bugs, when fixed, move them to the top of fixed bugs

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #90: Parser requires semicolon for bodyless func/proc definitions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Syntax ergonomics
:STATUS: Fixed
:END:

*** Description
The parser cannot determine where a function/proc definition ends when there
is no body. Previously required a semicolon as a terminator.

*** Solution
Semicolons are now completely optional - skipped by the lexer as whitespace.
~ext_func~ and ~ext_proc~ require an empty body ~{}~ instead of a semicolon.

*** Examples
#+BEGIN_SRC til
// Has body - no semicolon needed
add := func(a: I64, b: I64) returns I64 {
    return a.add(b)
}

// No body (ext) - uses empty body {}
// From src/core/print.til:
single_print := ext_proc(s: Str) {}
print_flush  := ext_proc() {}

// Inside struct definitions - also uses {}
// From src/std/meta.til:
Introspection := struct {
    has_const := ext_func(type_name: Str, const_name: Str) returns Bool {}
}

// Semicolons are now completely optional everywhere:
;;;;;;;;;;;;;;;;;;;;  // Just whitespace, ignored
#+END_SRC

*** Changes Made

*Lexer changes:*
- Removed ~Semicolon~ and ~DoubleSemicolon~ token types
- Lexer now skips any sequence of semicolons (treated as whitespace)

*Parser changes:*
- Removed ~TokenType::Semicolon~ from ~func_proc_returns()~ and ~func_proc_throws()~
- Removed ~do_parse_body~ parameter from ~parse_func_proc_definition()~
- Always parse body, error if non-empty for ext_func/ext_proc
- Removed dead code for semicolon handling in ~parse_switch_statement()~ and ~parse_body()~
- Removed ~go_back()~ method (no longer needed)

*Test changes:*
- Added semicolon regression test in src/test/flow.til
- Removed ~test_lexer_go_back~ test (method removed)

*** Future Enhancement (Step 3)
Context-aware lookahead could allow:
#+BEGIN_SRC til
single_print := ext_proc(s: Str)  // Just works without {}
#+END_SRC
Parser would infer end of definition from context. Post-self-hosting enhancement.

*** Files Changed
- src/rs/lexer.rs, src/self/lexer.til
- src/rs/parser.rs, src/self/parser.til
- src/std/meta.til (changed ; to {} for struct ext_funcs)
- src/test/flow.til (added regression test)
- src/test/test_lexer.til (removed go_back test)

** Bug #89: Constant folding only works at global scope
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Performance, macro implementation
:STATUS: Active
:END:

*** Description
Pure function calls with all compile-time known arguments are only constant
folded at global scope. Inside function bodies, they are not folded even when
all arguments are literals.

*** Example
#+BEGIN_SRC til
double := func(x: I64) returns I64 { return x.mul(2) }

// Global scope - folded to literal 10
global_result := double(5)

test := proc() {
    // Inside function - NOT folded, calls double() at runtime
    inner_result := double(10)
}
#+END_SRC

Generated C shows:
- ~til_global_result = 10~ (folded)
- ~til_inner_result = til_double(...)~ (not folded)

*** Location
~precomp_expr()~ in src/rs/precomp.rs / src/self/precomp.til has:
#+BEGIN_SRC til
at_global_scope := context.scope_stack.frames.len().eq(1)
if at_global_scope.and(is_comptime_evaluable(context, const_folded)) {
    const_folded = eval_comptime(context, const_folded)
}
#+END_SRC

The ~at_global_scope~ check should be removed.

*** Impact on Issue #88 (Macros)
This bug blocks proper macro implementation. Macros should be evaluated at
compile time regardless of where they are called.

*** Tests
- tmp/test_constfold_scope.til - demonstrates the issue

** Bug #86: For-in loop fails with enum that has enum payload
:PROPERTIES:
:DISCOVERED: 2026-01-06
:IMPACT: Cannot use for-in loops with certain enum types
:STATUS: Active (workaround: use while loop with get())
:END:

*** Description
When an enum's first variant has another enum as its payload type, using that
enum type in a for-in loop fails at init time with the error:
"Enum constructor X expects payload of type Y, but got enum"

*** Example
#+BEGIN_SRC til
InnerEnum := enum { FTFunc, FTProc }
OuterEnum := enum {
    TFunction: InnerEnum,  // First variant has enum payload
    TCustom: Str,
}

mut v := Vec.new(OuterEnum)
for item: OuterEnum in v {  // ERROR at init time
    // ...
}
#+END_SRC

*** Workaround
Use a while loop with get() instead of for-in:
#+BEGIN_SRC til
mut i := 0
while i.lt(v.len()) {
    mut item := OuterEnum.TCustom("")
    v.get(i, item)
    // ...
    i = i.add(1)
}
#+END_SRC

*** Tests
- src/test/bug86.til - demonstrates init error with enum-in-enum payload
- src/test/loops.til - commented out test_forin_payload_enum (segfaults til run)

** Bug #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Active (workaround exists)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array into variadic arguments.
This prevents forwarding variadic args from one function to another.

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                   | Notes                                    |
|--------+--------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~         | Go-style, suffix                         |
| B      | ~run_cmd(*args)~           | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~         | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~          | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** Method to Find Divergences
Use the til_diff.til script to compare C output from rstil vs rstil_til:

#+BEGIN_SRC bash
./bin/rstil interpret src/til_diff.til src/examples/hello_script.til
#+END_SRC

*** Methodology: Fix Once, Fix Correctly

CRITICAL: The goal is to fix Bug #80 ONCE, correctly. Not to move fast.

**** Why Conservative Status Updates Matter
- Marking uncertain items as MATCH creates false confidence
- If we later discover false MATCHes, we must reset Status column and re-read ALL functions
- Multiple careful passes are better than one fast pass followed by a full reset
- Only mark MATCH when 100% certain: either actual code change made, or line-by-line verification done

**** What "MATCH" Actually Means

MATCH is NOT:
- "Logic is semantically equivalent"
- "Tests pass"
- "Structured slightly differently but works"
- "Close enough"

MATCH IS:
- Every line verified against Rust
- Variable names identical to Rust
- Comments copied verbatim from Rust
- Control flow structure identical (only rs2til.org patterns allowed to differ)
- If you haven't read BOTH versions line-by-line, it's DIVERGE

**** Rules for Status Column
1. *MATCH* - Only when:
   - Line-by-line comparison of ENTIRE function done
   - ALL differences follow rs2til.org RULES exactly
   - Same variable names as Rust
   - Same comments as Rust (copy verbatim)
   - Same control flow structure
   - CRITICAL: Fixing ONE issue does NOT make it MATCH - must verify ALL lines
2. *DIVERGE* - When in doubt:
   - Assumed patterns are "acceptable" without verification against rs2til.org
   - Similar but not verified identical line-by-line
   - rs2til.org doesn't explicitly cover the case
3. *DELETED* - Function removed from TIL to match Rust

**** Incremental Pass Workflow
1. Pick one DIVERGE item
2. Read Rust version line-by-line
3. Read TIL version line-by-line
4. Either fix TIL to match, or verify it already matches
5. Run ~time timeout 600 make benchmark~
6. If passes: Update Status, commit immediately
7. If fails: Revert, keep as DIVERGE, move to next

**** Final Bulk Pass (Last Resort)
Only when incremental passes stop making progress:
1. Translate ALL remaining DIVERGE items at once
2. No testing until complete
3. Very risky - minimize items reaching this phase
4. If fails, bisect to find problem

*** Findings
The diff revealed these divergences:

1. *Struct definition style* - FIXED
   - rstil: ~struct til_Str { ... };~
   - til: ~typedef struct { ... } Str;~
   - Fix: Changed emit_struct_declaration to use ~struct til_Name { };~ format

2. *Field types for Str fields* - FIXED
   - rstil: ~til_Str msg;~
   - til: ~const char* msg;~
   - Fix: Removed wrong special case in til_type_to_c that returned ~const char*~ for Str

**** Remaining issues for empty.til (boilerplate/header):

3. *Forward declarations position differs* - FIXED
   - rstil emits forward declarations before ~#include <ext.c>~
   - til emits them after
   - Top-level function names now have til_ prefix (FIXED via emit_func_prototype/declaration)
   - Struct function names now have til_ prefix (FIXED via emit_struct_func_prototypes/bodies)
   - Fix: Reordered passes in emit() to match Rust (prototypes → ext.c → constants)

4. *~#include <ext.c>~ vs inline helpers* - FIXED
   - rstil: ~#include <ext.c>~
   - til: emits inline helpers (u8_to_i64, single_print, etc.) instead
   - Fix: Removed Pass 1c that emitted inline helpers; ext.c is already included

5. *Constants missing til_ prefix* - FIXED
   - rstil: ~const til_I64 til_NULL = 0;~
   - til: ~const I64 NULL = 0;~
   - Both the type and variable name are missing prefix
   - Fix: Changed emit_constant_declaration to use til_name() for both var_name and type

**** Remaining issues for empty.til (function bodies):

6. *Parameter passing style in size_of* - FIXED
   - rstil: ~const til_Str* type_name~ (pointer)
   - til: ~til_Str type_name~ (by value)
   - Fix: emit_size_of_function now uses pointer param, call sites use &

7. *Temp variable naming*
   - rstil: ~_tmp_or_0~, ~_tmp_or_1~, etc. (incrementing counter)
   - til: ~_tmp_or__tmp_~ (counter not incrementing, outputs "_tmp_" instead of number)

8. *Function call argument passing*
   - rstil: ~til_I64_to_str(&til_MAX_U8)~ (address-of for pointer params)
   - til: ~til_I64_to_str(til_MAX_U8)~ (by value)
   - Follows from pointer param handling - if param is pointer, must use &

9. *Pointer dereference style*
   - rstil: ~(*til_b).data~ (explicit dereference then field access)
   - til: ~til_b.data~ (direct field access on pointer - wrong)

10. *Literal hoisting for pointer params*
    - rstil: Hoists Type and I64 literals into temp variables, then passes &temp
      #+BEGIN_EXAMPLE
      til_Type _tmp_or_4 = "Str";
      til_I64 _tmp_or_5 = 0;
      int _arr_status = til_Array_new(&_tmp_or_2, &_err_alloc, _tmp_or_4, &_tmp_or_5);
      #+END_EXAMPLE
    - til: Passes literals inline without hoisting
      #+BEGIN_EXAMPLE
      int _arr_status = til_Array_new(&_tmp_or__tmp_, &_err_alloc, "Str", 0);
      #+END_EXAMPLE

11. *Dynamic pointer casting*
    - rstil: ~(til_Dynamic*)&til_val~ (explicit cast to Dynamic pointer)
    - til: ~til_val~ (missing cast and address-of)

**** Detailed Fix Analysis

***** Issue 7: Temp naming - ~next_mangled~ produces "_tmp_" instead of counter number

*Symptom*: All temp vars have suffix ~_tmp_~ instead of incrementing numbers (0, 1, 2...)
- rstil output: ~_tmp_or_0~, ~_tmp_or_1~, ~_tmp_or_2~ (incrementing)
- til output: ~_tmp_or__tmp_~ (all same, counter value replaced by "_tmp_")

*Location*: ~src/self/ccodegen.til~ lines 112-119

*Rust reference*: ~src/rs/ccodegen.rs~ lines 74-80

****** Investigation findings

The ~next_mangled~ function itself looks correct:
#+BEGIN_SRC til
next_mangled := proc(mut ctx: CodegenContext) returns Str {
    n := ctx.mangling_counter
    ctx.mangling_counter.inc()
    if gt(ctx.current_function_name.len(), 0) {
        return concat("_tmp_", ctx.current_function_name).concat("_").concat(n.to_str())
    }
    return concat("_tmp_", n.to_str())
}
#+END_SRC

However, investigation revealed *TWO locations missing the counter reset pattern*:

****** Missing reset #1: ~emit_func_declaration~ (lines 3043-3120)

TIL code (WRONG):
#+BEGIN_SRC til
// Save and set current function name for nested function mangling
mut prev_function_name := ctx.current_function_name
ctx.current_function_name = decl.name
// MISSING: prev_mangling_counter save and reset!
#+END_SRC

Rust code (CORRECT - lines 3250-3253):
#+BEGIN_SRC rust
let prev_function_name = ctx.current_function_name.clone();
let prev_mangling_counter = ctx.mangling_counter;
ctx.current_function_name = Some(decl.name.clone());
ctx.mangling_counter = 0;  // Reset counter per-function for determinism
#+END_SRC

TIL also missing restore at end (line 3120 only restores ~prev_function_name~).

****** Missing reset #2: ~emit_declaration~ nested function handling (lines 7384-7463)

TIL saves/restores these context fields:
- ~saved_throw_types~, ~saved_return_types~
- ~saved_mut_params~, ~saved_variadic_params~
- ~saved_declared_vars~, ~saved_function_name~

But does NOT save/restore ~mangling_counter~!

Rust (lines 4844, 4849, 4905) correctly does:
#+BEGIN_SRC rust
let prev_mangling_counter = ctx.mangling_counter;
ctx.mangling_counter = 0;  // Reset counter per-function for determinism
// ... later ...
ctx.mangling_counter = prev_mangling_counter;
#+END_SRC

****** Correctly handled: ~emit_struct_func_bodies~ (lines 2566-2589)

This case DOES have correct handling:
#+BEGIN_SRC til
mut prev_mangling_counter := ctx.mangling_counter
ctx.current_function_name = mangled_name
ctx.mangling_counter = 0
// ... function body ...
ctx.mangling_counter = prev_mangling_counter
#+END_SRC

****** Unexplained symptom

The missing resets would cause the counter to keep incrementing globally (47, 48, 49...),
but the actual symptom is ~n.to_str()~ returning ~"_tmp_"~ instead of any number.
This suggests there may be an *additional issue* beyond missing resets, possibly:
- Type confusion where ~n~ is somehow a Str instead of I64
- Bug in how method calls on local variables are compiled
- Some form of variable shadowing in TIL's scoping

****** Fix steps

1. Add counter save/reset/restore to ~emit_func_declaration~ (3 lines)
2. Add counter save/reset/restore to ~emit_declaration~ nested function case (3 lines)
3. Test if this fixes the symptom
4. If symptom persists, investigate method call compilation for ~n.to_str()~

***** Issue 8: Argument passing - missing ~&~ for pointer params

*Symptom*: Function calls pass values directly instead of addresses

*Location*: Multiple emit_* functions that generate function call arguments

*Rust reference*: Rust uses ~format!("&{}", ...)~ or ~output.push_str("&")~ for ref params

*Analysis*:
When a function parameter is by-ref (pointer), the caller must use ~&var~ syntax.
TIL ccodegen is emitting just ~var~ without the address-of operator.

*Fix steps*:
1. In ~emit_arg_with_param_type~ (or equivalent), check if param is by-ref
2. If param is by-ref and arg is not already an address expression, prepend "&"
3. Key functions to check: ~emit_fcall~, ~emit_arg_or_hoisted~, ~emit_arg_with_param_type~

***** Issue 9: Pointer dereference - ~til_b.data~ should be ~(*til_b).data~ - FIXED

*Symptom*: Field access on pointer params uses ~.~ instead of ~->~ or ~(*ptr).~

*Location*: Three places where ~current_ref_params~ is populated

*Rust reference*: ccodegen.rs lines 2927-2930 and 3206-3209 and 4852-4855

*Root cause*:
TIL only added ~mut~ params to ~current_ref_params~, but Rust adds ALL non-copy
params (Bug #60 fix). Non-copy params (including const struct params) are passed
by pointer in C, so they need dereference when accessed as values.

*Fix applied*:
Changed three locations from ~if arg.is_mut~ to ~if not(arg.is_copy)~:
1. ~emit_struct_func_bodies~ (line 2527)
2. ~emit_func_declaration~ (line 3065)
3. ~emit_declaration~ for nested functions (line 7408)

Added "Bug #60" comment to match Rust for future reference.

***** Issue 10: Literal hoisting - Type and I64 literals need temp variables - FIXED

*Symptom*: Can't take address of string/integer literal for pointer params

*Location*: ~hoist_variadic_args~ function (line 8973)

*Rust reference*: ~src/rs/ccodegen.rs~ lines 1352-1389 (Bug #60 fix)

*Root cause*:
When calling Array.new, the Type and I64 params need hoisting because:
- Can't do ~&"Str"~ (address of string literal for const char* const*)
- Can't do ~&0~ (address of integer literal)

TIL was passing literals directly but Rust hoists them into temp vars.

*Fix applied*:
Added hoisting for Type and I64 params before Array.new call:
1. ~til_Type type_temp = "elem_type";~
2. ~til_I64 count_temp = N;~
3. Pass ~type_temp~ (no &, already const char*) and ~&count_temp~ to Array.new

Added Bug #60 comments to match Rust.

***** Issue 11: Dynamic casting - need ~(til_Dynamic*)&val~ - FIXED

*Symptom*: Array.get/set calls missing Dynamic pointer cast

*Location*: ~hoist_variadic_args~ and ~emit_throwing_call_with_goto~

*Rust reference*: ccodegen.rs lines 1439-1442 shows ~(til_Dynamic*)&~ pattern

*Analysis*:
When passing values to Array.set which expects ~til_Dynamic*~, we need:
- ~(til_Dynamic*)&value~ for the value argument
TIL ccodegen was just passing ~&value~ without the Dynamic cast.

*Fix applied*:
1. In ~hoist_variadic_args~ (line 9033): Changed ~", &"~ to ~", (til_Dynamic*)&"~
   using TIL_PREFIX for consistency with Rust
2. In ~emit_throwing_call_with_goto~ (line 5692): Changed hardcoded
   ~"(til_Dynamic*)&"~ to use TIL_PREFIX (~"(".concat(TIL_PREFIX).concat("Dynamic*)&")~)

***** Issue 3: Forward declarations position - FIXED

*Symptom*: Forward declarations appear after ~#include <ext.c>~ instead of before

*Location*: ~emit~ function main pass ordering

*Rust reference*: Check pass ordering in ccodegen.rs ~emit~ function

*Analysis*:
The pass order in emit() differs between Rust and TIL. Rust emits:
1. Typedefs
2. Forward declarations
3. ~#include <ext.c>~
4. Function bodies

TIL has different ordering. Need to match Rust's pass sequence.

*Fix applied*: Reordered passes in emit() to match Rust:
- Pass 2: function prototypes (forward declarations)
- Pass 3: #include <ext.c>
- Pass 4: constants and til_size_of
- Pass 5: function definitions
- Pass 6: other statements

*** Root Cause
ccodegen.til has diverged significantly from ccodegen.rs and needs to be re-synced.

*** Files That Must Match
All self-hosted TIL files must match their Rust counterparts:
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Fix
Systematically compare each .rs file with its .til counterpart and fix all divergences.
Use the diff method above to verify generated C code is identical.

*** Comprehensive Comparison

**** target.rs vs target.til - COMPLETE MATCH
All enums and functions match:
- Enums: Lang, Target
- Functions: lang_from_str, lang_to_str, lang_file_extension, target_from_str, target_to_str,
  default_lang_for_target, supported_langs_for_target, is_lang_supported_for_target,
  validate_lang_for_target, toolchain_command, toolchain_extra_args, executable_extension,
  detect_current_target

**** builder.rs vs builder.til - NEEDS REVIEW
| Rust | TIL | Status |
|------|-----|--------|
| parse_file | parse_file | ? |
| collect_imports | collect_imports_single | Different name |
| merge_asts | - | Missing in TIL |
| is_import_call | is_import_call | ? |
| build | build | ? |
| - | merge_dep_params | TIL only |
| - | get_import_path | TIL only |

**** rstil.rs vs til.til - NEEDS REVIEW
| Rust | TIL | Status |
|------|-----|--------|
| parse_build_options | - | Not ported (CLI arg parsing) |
| usage | usage | ? |
| interpret_file_or_exit | interpret_file_or_exit | ? |
| build_file_or_exit | build_file_or_exit | ? |
| run_file_or_exit | run_file_or_exit | ? |
| main | main | ? |
| - | translate_file_or_exit | TIL only |

**** ccodegen.rs vs ccodegen.til - PARTIAL MATCH

***** Structs - Comparison

****** Structs in Both
| Struct | Status | Notes |
|--------|--------|-------|
| VariadicParamInfo | MATCH | |
| CatchLabelInfo | MATCH | |
| HoistedArg | MATCH | |
| VariantInfo | MATCH | |
| CollectedDeclaration | MATCH | |
| ThrowingDefault | MATCH | |
| CatchLabelInfoEntry | PARTIAL | TIL has extra ~catch_block: Expr~ - cannot remove (causes hangs in til_compiled), assignment removed |
| ParamTypeInfo | MATCH | Changed to use ~Ptr~ for value_type, removed ~has_type~ |
| SwitchCaseInfo | MATCH | Struct removed entirely from both Rust and TIL - parser enforces default-last |
| ThrowingFCallInfo | MATCH | Struct removed entirely from both Rust and TIL - logic inlined at call sites |
| VariadicFCallInfo | MATCH | Removed ~is_variadic~ field, detect_variadic_fcall throws KeyNotFoundError |
| CodegenContext | MATCH | Rust changed to ~String~ with ~""~ = None per rs2til.org |

****** TIL-only Structs (UNNECESSARY per rs2til.org)
All unnecessary result structs have been removed:
- FuncNameResult removed (2026-01-05) - get_func_name_string/get_til_func_name_string now throw KeyNotFoundError
- FuncLookupResult removed (2026-01-05) - get_fcall_func_def now throws KeyNotFoundError, callers use
  scoped catch blocks (if true { }) to distinguish between different KeyNotFoundError sources

***** Helper Functions - Present
| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| next_mangled | Y | Y | MATCH | Uses func_name variable and method chaining (2026-01-05) |
| til_name | Y | Y | MATCH | Combined if statements match Rust match arms (2026-01-05) |
| emit_struct_literal_assign | Y | Y | MATCH | Uses push_str like Rust |
| emit_struct_literal_start | Y | Y | MATCH | Uses push_str like Rust |
| til_func_name | Y | Y | MATCH | |
| get_func_name_string | Y | Y | MATCH | vec+join vs string concat produces same result, acceptable |
| get_til_func_name_string | Y | Y | MATCH | vec+join vs string concat produces same result, acceptable |
| get_type_arg_name | Y | Y | MATCH | Option->throws is correct rs2til.org translation |
| get_fcall_func_def | Y | Y | MATCH | Option->throws, TIL wrapper call is equivalent |
| param_needs_by_ref | Y | Y | MATCH | |
| til_type_to_c | Y | Y | MATCH | Removed extra default case |
| value_type_to_c_name | Y | Y | MATCH | Error uses value_type_to_str (acceptable - no {:?} in TIL) |
| has_str | - | - | DELETED | Removed 2026-01-05 - inlined at call sites like Rust |
| get_field_type_dependency | Y | Y | MATCH | Added 2026-01-05 - returns empty for None |

***** Type/Struct/Enum Detection - Present
| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| is_struct_declaration | Y | Y | MATCH | Single return false at end, not(is_empty()), commit f07f8e7c |
| is_enum_declaration | Y | Y | MATCH | Single return false at end, commit bb4ba851 |
| is_enum_with_payloads | Y | Y | MATCH | Single return false at end, commit 9ae61d8b |
| is_constant_declaration | Y | Y | MATCH | Single return false at end, added Rust comments, commit ded07f40 |
| is_global_declaration | Y | Y | MATCH | Single return false at end, grouped cases, commit fdae1c87 |
| is_throwing_fcall | Y | Y | MATCH | proc vs func is TIL idiom, logic matches Rust (2026-01-05) |
| is_func_declaration | Y | Y | MATCH | Single return false at end |
| enum_has_payloads | Y | Y | MATCH | Uses for-in loop like Rust iterator (2026-01-05) |
| variant_has_payload | - | - | DELETED | Removed 2026-01-05 - was not in Rust |
| get_struct_name | Y | Y | MATCH | "" sentinel for Option per rs2til.org, fixed unused var (2026-01-05) |
| get_struct_dependencies | Y | Y | MATCH | Now uses get_field_type_dependency helper (2026-01-05) |
| get_enum_name | Y | Y | MATCH | "" sentinel for Option per rs2til.org, fixed unused var (2026-01-05) |
| get_enum_dependencies | Y | Y | MATCH | Uses for-in loop, method chaining (2026-01-05) |
| get_type_name | Y | Y | MATCH | "" sentinel for Option<String> per rs2til.org |
| get_type_dependencies | Y | Y | MATCH | Simplified empty return: return Vec.new(Str) |
| get_fcall_func_name | Y | Y | MATCH | Rust Option -> TIL throws KeyNotFoundError per rs2til.org |
| get_struct_construction_type | Y | Y | MATCH | Method chaining fixed (2026-01-05), actual code change |
| get_enum_construction_type | Y | Y | MATCH | Option<String>->"" sentinel per rs2til.org |
| get_case_variant_info | Y | Y | MATCH | mut result pattern is acceptable TIL idiom per rs2til.org |
| parse_pattern_variant_name | Y | Y | MATCH | Extra catches needed for TIL's throwing get_substr |

***** Topological Sort - Present
| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| topological_sort_types | Y | Y | MATCH | Now uses Vec<Vec> like Rust |
| topological_sort_structs | - | - | DELETED | Removed 2026-01-05 - old function, Rust uses topological_sort_types |

***** Emit Functions - All Present
NOTE: All emit functions follow common divergence patterns:
- TIL uses `mut result := output` + return instead of mutating output in place
- TIL uses switch/case instead of if-let pattern matching
- TIL uses get() + catch instead of direct indexing
- TIL has extra catch blocks for error handling

| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| emit | Y (pub) | Y | MATCH | Fixed: variable names (fd, main_has_variadic, has_multi, child), combined conditions with .and() |
| emit_struct_declaration | Y | Y | MATCH | Fixed: now uses if member.is_mut { } like Rust |
| emit_struct_constants | Y | Y | MATCH | Fixed: for-in loop, catch for til_type_to_c failures |
| emit_struct_func_prototypes | Y | Y | MATCH | Fixed: for-in loop, removed is_ext check not in Rust |
| emit_struct_func_body | Y | Y | MATCH | Added 2026-01-05 - extracted from emit_struct_func_bodies |
| emit_struct_func_bodies | Y | Y | MATCH | Now uses emit_struct_func_body helper (2026-01-05) |
| emit_enum_declaration | Y | Y | MATCH | Fixed: added til_name(), removed TIL-only comments |
| emit_enum_with_payloads | Y | Y | MATCH | Fixed: struct EnumName {} instead of typedef struct {} |
| emit_enum_to_str_function | Y | Y | MATCH | Fixed: removed TIL-only Bug #38 comment |
| emit_enum_to_str_for_declaration | Y | Y | MATCH | Already matches with rs2til.org patterns |
| emit_enum_size_of_constant | Y | Y | MATCH | Already matches with rs2til.org patterns |
| emit_size_of_function | Y | Y | MATCH | Fixed: for-in loop, removed Bug #38 comment |
| emit_func_signature | Y | Y | MATCH | Fixed: removed unused ctx parameter to match Rust |
| emit_func_prototype | Y | Y | MATCH | Fixed: removed unused ctx parameter |
| emit_func_declaration | Y | Y | MATCH | Fixed: reordered operations to match Rust exactly, fixed all comments (2026-01-06) |
| emit_constant_declaration | Y | Y | MATCH | Fixed: uses c_type + emit_literal() like Rust, var_name order matches (2026-01-06) |
| emit_global_declaration | Y | Y | MATCH | Fixed: var_name order, c_type fallback with "int", output structure (2026-01-06) |
| emit_expr | Y | Y | MATCH | Fixed: removed extra comments not in Rust (2026-01-06) |
| emit_body | Y | Y | MATCH | Same logic: save/restore catch_labels, call emit_stmts (2026-01-06) |
| emit_stmts | Y | Y | DIVERGE | ~200 lines, loop var ~scan_idx~ vs Rust ~idx~, many gteq() vs .gteq() |
| emit_if | Y | Y | MATCH | Uses acceptable TIL idioms: switch/case, get()+catch, method syntax (2026-01-06) |
| emit_while | Y | Y | MATCH | Fixed: range loops for indent building |
| emit_break | Y | Y | MATCH | Fixed: range loop for indent building |
| emit_continue | Y | Y | MATCH | Fixed: range loop for indent building |
| emit_switch | Y | Y | MATCH | Removed SwitchCaseInfo, parser enforces default-last |
| emit_fcall | Y | Y | DIVERGE | ~500 lines, Option→has_*:Bool pattern, many minor style diffs |
| emit_declaration | Y | Y | MATCH | Restructured: removed duplicate underscore check, added prototype generation, fixed order (2026-01-06) |
| emit_funcdef | Y | Y | MATCH | Used indent_str like Rust, _func_def naming, same comments (2026-01-06) |
| emit_assignment | Y | Y | MATCH | Added throwing FCall check before hoist, indent_str at top (2026-01-06) |
| emit_return | Y | Y | MATCH | Restructured to match Rust flow: is_throwing var, early return for throwing FCall (2026-01-06) |
| emit_throw | Y | Y | MATCH | Consolidated indent_str to top, fixed variable names to match Rust (2026-01-06) |
| emit_literal | Y | Y | MATCH | Added character escaping loop to match Rust (2026-01-06) |
| emit_str_literal | Y | Y | MATCH | Added character escaping loop with for-in to match Rust (2026-01-06) |
| emit_identifier_without_nested | - | - | DELETED | Removed 2026-01-05 - was not in Rust |
| prescan_func_level_catches | Y | Y | MATCH | Comments moved inside function to match Rust (2026-01-06) |

***** Hoisting/Throwing Functions - Present
NOTE: Same common divergence patterns as Emit Functions (see above).

| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| check_throwing_fcall | N | N | MATCH | Function removed entirely from both - logic inlined at 3 call sites |
| hoist_throwing_expr | Y | Y | DIVERGE | ~150 lines, Option→has_*:Bool pattern for variadic_arr_var |
| hoist_throwing_args | Y | Y | DIVERGE | ~250 lines, slicing &params[1..] vs separate start index |
| hoist_for_ref_params | Y | Y | MATCH | Fixed: chained concat for func_name, logic matches Rust (2026-01-06) |
| hoist_for_dynamic_params | Y | Y | MATCH | Fresh translation from Rust following rs2til.org (2026-01-06) |
| hoist_variadic_args | Y | Y | DIVERGE | ~150 lines, HashMap iteration differs (keys+get vs iter) |
| detect_variadic_fcall | Y | Y | MATCH | Fixed: uses get_til_func_name_string, same comment/vars as Rust |
| emit_variadic_call | Y | Y | DIVERGE | ~200 lines, Option→has_*:Bool for variadic_arr_var param |
| emit_throwing_call | Y | Y | DIVERGE | ~300 lines, Option→has_*:Bool pattern throughout |
| emit_throwing_call_propagate | Y | Y | DIVERGE | ~250 lines, Option→has_*:Bool pattern |
| emit_throwing_call_with_goto | Y | Y | DIVERGE | ~250 lines, Option→has_*:Bool pattern |
| emit_fcall_with_hoisted | Y | Y | DIVERGE | ~150 lines, Option→has_*:Bool pattern |
| emit_fcall_name_and_args_for_throwing | Y | Y | DIVERGE | ~100 lines, Option→has_*:Bool for variadic_arr_var |
| emit_arg_or_hoisted | Y | Y | DIVERGE | Structural: calls emit_arg_with_param_type with has_param_type:Bool |
| emit_arg_with_param_type | Y | Y | DIVERGE | Structural: Option<&ValueType>→ValueType+has_param_type:Bool |
| emit_arg_with_mut | - | - | DELETED | Removed 2026-01-05 - Rust uses emit_arg_with_param_type |

***** Collection Functions - Present

***** DIVERGE Pattern Summary (2026-01-06)
The remaining 23 DIVERGE items share these common patterns:

1. *Option<T> parameters* → TIL uses ~T~ + ~has_*: Bool~ flag
   - rs2til.org says use ~Ptr~ with NULL=None, but TIL uses Bool flags
   - Affects: emit_arg_with_param_type, hoist_for_ref_params, hoist_for_dynamic_params, etc.
   - Fix: Change TIL to use ~Ptr~ pattern per rs2til.org

2. *Option<T> return from map.get()* → TIL uses try/catch with Bool flag
   - Pattern: ~mut found := false; map.get(k, v); found = true; catch {}~
   - Acceptable per rs2til.org (throws KeyNotFoundError)

3. *Loop variable names* differ (TIL ~ai~, ~scan_idx~ vs Rust ~idx~, ~i~)
   - Simple fix: rename to match Rust

4. *Method style* - TIL uses ~gteq(x, y)~ vs Rust-like ~x.gteq(y)~
   - rs2til.org says prefer method chaining
   - Simple fix: change to method style

5. *HashMap iteration* - TIL uses ~keys.get()~ loop vs Rust ~.iter()~
   - Acceptable TIL idiom (no direct iterator support)

6. *Structural differences* - Some functions have fundamentally different code organization
   - emit_constant_declaration, emit_global_declaration: inline literal handling vs emit_literal()
   - These need careful refactoring

| Function | Rust | TIL | Status | Notes |
|----------|------|-----|--------|-------|
| collect_func_info | Y | Y | MATCH | Fixed loop vars to idx, comments match, HashMap iter via for-in+get (rs2til.org rule 20) |
| collect_nested_func_info | Y | Y | MATCH | Fixed: chained concat for mangled_name, Option<&str>→Str per rs2til.org (2026-01-06) |
| collect_declarations_in_body | Y | Y | MATCH | Same comments, same vars (decls, collected, stmt), switch/case OK |
| collect_declarations_recursive | Y | Y | MATCH | Fixed name→type_name, method chaining for gteq/lt/add, comments match |

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Active
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Reproducing Issue 1 (I64 args in interpreted mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, count: I64) {
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

Running: ~./bin/rstil interpret test.til hello 42~

Error: ~calling function 'main' expects 'I64' for arg 'count', but 'Str' was provided~

*** Reproducing Issue 2 (custom named args in compiled mode)
#+BEGIN_SRC til
mode cli
main := proc(name: Str, value: Str) {
    println("name:", name, "value:", value)
}
#+END_SRC

Running: ~./bin/rstil run test.til hello world~

Error: C codegen produces ~til_main(&_main_args)~ with 1 arg but til_main expects 2+.
The C codegen only handles the standard ~args: ..Str~ pattern.

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.

* Fixed Bugs

** Bug #87: Scavenger not pruning struct methods
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Generated C code 10x larger than necessary
:STATUS: Fixed
:END:

*** Description
The scavenger phase was not properly pruning unused struct methods. An empty
script (just =mode script=) generated 1,167 lines of C code instead of ~100.

*** Root Cause
In =compute_reachable=, when processing struct constructors (e.g., =Bool()=),
the code walked into ALL =default_values= including method bodies (FuncDef).
This incorrectly marked all methods as reachable even when not called.

#+begin_src rust
// BUG: This walked into method bodies too
for default_expr in struct_def.default_values.values() {
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Fix
Skip FuncDef values when processing struct constructors - methods should only
be walked if explicitly called via their qualified name (e.g., =I64.eq=).

#+begin_src rust
for default_expr in struct_def.default_values.values() {
    if let NodeType::FuncDef(_) = &default_expr.node_type {
        continue;  // Skip methods
    }
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Files Changed
- =src/rs/scavenger.rs= (lines 239-244)
- =src/self/scavenger.til= (lines 274-280)

*** Results
- =empty.c=: 1,167 lines -> 99 lines (92% reduction)
- =til compiled= benchmark: 39s -> 27s (~30% faster)
- All 107 tests pass

*** Additional Fix: Prune Unused Struct Definitions

After fixing method pruning, we also added pruning of unused struct/enum definitions.
The scavenger now tracks which types are actually used (in function signatures, declarations,
constructors) and removes struct definitions that aren't referenced.

**** Implementation
- Added =used_types: HashSet<String>= to =ComputeReachableResult=
- Added =EXT_C_TYPES= constant for types required by ext.c (Bool, Str, I64, U8, AllocError, Array)
- Added =extract_type_name()=, =collect_used_types_from_expr()=, =collect_used_types_from_func()=
- Transitive closure: when a type is used, its field types are also marked as used
- Struct filtering in AST rebuild checks =used_types.contains(&decl.name)=

**** Results
- =empty.c=: 99 lines -> 61 lines (additional 38% reduction)
- All 107 tests pass

**** Also Added
- =Ptr.is_null()= method to src/core/ptr.til (matches rs2til.org documentation)

** Bug #84: run_cmd output capture broken in compiled mode
:PROPERTIES:
:DISCOVERED: 2026-01-05
:FIXED: 2026-01-05
:IMPACT: Cannot use compiled test.til
:STATUS: Fixed
:END:

*** Description
The =run_cmd= ext_proc didn't capture command output correctly in compiled mode.
The mutable output string parameter remained empty (or got only a newline).

*** Root Cause
The C implementation in =src/ext.c= used =popen()= which passes commands through the shell.
Arguments weren't quoted, so =bash -c echo hello= was executed instead of =bash -c 'echo hello'=.

*** Fix
1. =src/ext.c=: Added single-quote wrapping for arguments (except command) with proper escaping of embedded single quotes as ='\''=.
2. =src/self/ext.til=: Implemented =proc_run_cmd= to call the host's =run_cmd= via =bash -c= with properly quoted arguments. This was previously throwing "not yet implemented".

*** Test
=src/test/syscalls.til= has =test_run_cmd_output()= which verifies output capture works.

** Bug #85: Typer accepts struct literal with non-existent field name
:PROPERTIES:
:DISCOVERED: 2026-01-05
:IMPACT: Silent code generation with wrong semantics
:STATUS: Open
:END:

*** Description
The type checker accepts struct literals with field names that don't exist in the struct definition.

*** Example
#+begin_src til
KeyNotFoundError := struct {
    mut msg: Str = ""
}

// This should be a type error but compiles successfully:
throw KeyNotFoundError(key="not variadic")
// Should be: throw KeyNotFoundError(msg="not variadic")
#+end_src

The struct only has a ~msg~ field, but ~key=~ is accepted without error.

*** Expected behavior
The typer should report an error like:
#+begin_example
type ERROR: Field 'key' does not exist in struct 'KeyNotFoundError'
#+end_example

*** Impact
- Silent bugs where struct fields are misnamed
- Generated C code may have undefined behavior
- Discovered during Bug #80 work when ~KeyNotFoundError(key="...")~ was accidentally used

*** Reproduction
=src/test/bug85.til= - currently fails at eval phase with:
#+begin_example
src/test/bug85.til:12:21: eval ERROR: Field 'nonexistent' not found in struct 'TestStruct'
#+end_example

The error should be caught at type phase, not eval phase.

** Bug #78: TIL scavenger/ccodegen divergence from Rust
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_compiled (./bin/til build/run) crashes
:STATUS: Fixed
:END:

*** Description
The self-hosted TIL compiler crashed when running ~./bin/til build src/examples/empty.til~.
Multiple divergences between Rust and TIL implementations were causing issues.

*** Root Causes and Fixes

1. **scavenger.til compute_reachable return type**: TIL version handled
   ~needs_variadic_support~ inside the function with a recursive call, while Rust
   handled it at the call site. Fixed by adding ~ComputeReachableResult~ struct
   to both Rust and TIL, returning both values and handling at call site.

2. **ccodegen.til topological_sort_types**: TIL version used ~List~ with nested
   ~Vec~ elements, but modifications to copies didn't persist (TIL collections
   return copies, not references). Fixed by:
   - Changed parameter from ~List~ to ~Vec~
   - Changed internal ~List~ of ~Vec~ to ~Map<I64, Vec>~ with get/modify/set pattern
   - All catch blocks now throw ~err.msg~ instead of being empty (matching Rust panics)

3. **rs2til.org documentation**: Added new section "Implicit panics become throws Str"
   documenting that Rust code that would panic should throw Str in TIL.

*** Current Status
Scavenger and topological sort phases complete successfully. Crash now occurs
later in emit phase - investigation continues.

** Bug #77: Nested enum patterns incorrectly treated as binding variables
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_interpreted tests fail - bug47 and til.til help blocked
:STATUS: Fixed
:END:

*** Description
When parsing switch case patterns like ~case ValueType.TType(TTypeDef.TEnumDef):~,
the parser incorrectly treated the nested identifier ~TTypeDef.TEnumDef~ as a binding
variable with name "TTypeDef", causing the typer to declare a local symbol "TTypeDef"
with value_type TCustom("TTypeDef") that shadowed the real enum definition.

*** Root Cause
In parser.til parse_case_expr function, when checking if an FCall argument is a binding
variable (line 2005), it only checked if ~p1.node_type~ was an Identifier, but did not
check if the identifier had nested params. The Rust version had an additional check:
~if left.params[1].params.is_empty()~ to only treat simple identifiers as bindings.

*** Fix
Added check in parser.til at line 2008: ~if p1.params.len().eq(0)~
This ensures only simple identifiers (no nested params like TTypeDef.TEnumDef) are
treated as binding variables. Nested patterns remain as FCall for proper matching.

** Bug #73: TTypeDef value_type stored as TStructDef (actually Bug #77)
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: Cannot import self.init with til interpret
:STATUS: Fixed (was actually Bug #77)
:END:

*** Description
The symptoms were "Struct 'TTypeDef' not found" when processing init.til, but the
actual root cause was Bug #77 - nested enum patterns being incorrectly treated as
bindings, causing TTypeDef to be declared as TCustom("TTypeDef") in a local scope.

** Bug #74: TIL interpreter mut enum parameter write-back loses payload
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: vecs.til test fails - enum payload lost when extracting via switch
:STATUS: Fixed
:END:

*** Description
When a mut enum parameter is passed to a function (like Vec.get), and that function
modifies the enum (via memcpy), the payload is lost when writing back to the caller.

*** Root Cause
TIL's interpreter.til was missing the Bug #38 fix in the ~MutArgValue.Enum~ case
of the mut argument write-back logic. Rust sets ~context.temp_enum_payload~ before
calling ~insert_enum~ to preserve the payload data, but TIL was not doing this.

*** Fix
Added the Bug #38 fix to interpreter.til line 3154-3167:
#+BEGIN_SRC til
case MutArgValue.Enum(enum_val):
    // Bug #38 fix: Set temp_enum_payload so insert_enum preserves the payload
    if not(NULL.eq(enum_val.payload.data)).and(not(NULL.eq(enum_val.payload_type.data))) {
        // Read payload Vec and ValueType from the pointers
        mut payload_vec := Vec.new(U8)
        memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
        mut payload_type := ValueType.TCustom("")
        memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
        // Create EnumPayload and set temp_enum_payload
        mut temp_payload := EnumPayload(data=payload_vec.clone(), value_type=payload_type)
        heap_payload_ptr := malloc(size_of(EnumPayload))
        memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
        context.temp_enum_payload.data = heap_payload_ptr
    }
    _ := EvalArena.insert_enum(...)
#+END_SRC

*** Test
~src/test/vecs.til~ - now passes with ~til interpret~.

** Bug #75: TIL interpreter missing string range comparison support
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: test_lexer.til fails - lexer uses case "0".."9" patterns
:STATUS: Fixed
:END:

*** Description
The TIL interpreter threw "String range comparisons not yet supported" when
encountering switch case patterns like ~case "0".."9"~ in lexer.til. This
blocked the test_lexer.til test from running with ~./bin/til interpret~.

*** Root Cause
The Rust interpreter uses native string comparison operators (~>=~ and ~<=~)
for lexicographic comparison, but TIL's interpreter.til was throwing an error
instead of implementing the comparison.

*** Fix
Added ~Str.cmp()~ method to str.til that performs lexicographic comparison:
#+BEGIN_SRC til
cmp := func(self: Str, other: Str) returns I64 {
    mut min_len := self.len()
    if other.len().lt(min_len) {
        min_len = other.len()
    }
    for i in 0..min_len {
        a_byte := self.char_at(i)
        b_byte := other.char_at(i)
        a_val := U8.to_i64(a_byte)
        b_val := U8.to_i64(b_byte)
        if a_val.lt(b_val) {
            return sub(0, 1)
        }
        if a_val.gt(b_val) {
            return 1
        }
    }
    return sub(self.len(), other.len())
}
#+END_SRC

Updated interpreter.til to use it instead of throwing:
#+BEGIN_SRC til
// Lexicographic string comparison
cmp_start := result_to_switch.value.cmp(start.value)
cmp_end := result_to_switch.value.cmp(end.value)
is_match = cmp_start.gteq(0).and(cmp_end.lteq(0))
#+END_SRC

*** Test
~src/test/test_lexer.til~ - now passes with ~til interpret~.

** Bug #76: Optional function arguments not working in til_interpreted
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: optional_args.til fails - functions with default arg values have args.len() = 0
:STATUS: Fixed
:END:

*** Description
Functions with optional arguments (e.g., ~greeting: Str = "Hello"~) were failing
in the til-interpreted tests with "expects at most 0 args" error. The function's
args.len() was 0 when looked up, even though it was declared with correct args.

*** Root Cause
In ~parse_func_proc_args~ in parser.til, when parsing optional argument default
values, the code was:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    decl.default_value.data = to_ptr(default_expr)  // BUG: pointer to local!
#+END_SRC

~default_expr~ is a local variable on the stack. Taking a pointer to it with
~to_ptr(default_expr)~ creates a dangling pointer when the function returns.
This is a use-after-free bug - the memory at that address gets reused for other
data, corrupting the default_value pointer.

*** Fix
Allocate heap memory for the Expr and copy it there:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    // Must allocate heap memory - to_ptr(default_expr) would create dangling pointer
    decl.default_value.data = malloc(size_of(Expr))
    memcpy(decl.default_value.data, to_ptr(default_expr), size_of(Expr))
#+END_SRC

*** Test
~src/test/optional_args.til~ - now passes with ~til interpret~.

** Bug #72: Copying global enum with payload segfaults in til interpreter
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2026-01-01
:IMPACT: enums.til test fails with til interpret
:STATUS: Fixed
:END:

*** Description
When a global enum variable has a payload (e.g., ~Color.Green(true)~) and is copied
to a local variable inside a function, the til interpreter segfaults.

*** Root Cause
Two issues in ~eval_arena.til~'s ~get_enum~ and ~get_enum_at_offset~ functions:
1. ~payload_bytes~ and ~payload_type~ are local stack variables
2. ~to_ptr()~ returns pointers to these stack variables
3. When the function returns, these pointers become stale (use-after-free)

Additionally, pattern binding for enum payloads that are themselves enums was missing
proper arena insertion.

*** Fix
1. In ~get_enum~ and ~get_enum_at_offset~: heap-allocate the Vec and ValueType structs
   using ~malloc(size_of(...))~ before returning, so pointers remain valid.
2. In ~interpreter.til~ pattern binding: added TEnumDef case that properly looks up
   the inner enum variant, sets ~temp_enum_payload~ if needed, and calls ~insert_enum~.

*** Test
~src/test/enums.til~ - now passes with ~til interpret~.

** Bug #71: TIL interpreter enum pattern binding use-after-free
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Pattern binding in switch cases failed with "Type unknown not supported yet"
:STATUS: Fixed
:END:

*** Description
When pattern matching on enum variants with payloads (e.g., ~case TestEnum.TypeC(n)~),
the bound variable ~n~ could not be used - accessing it gave "Type unknown not supported yet".

*** Root Cause
~EnumVal~ in TIL uses ~Ptr~ fields for ~payload~ and ~payload_type~, pointing to local
stack variables in ~get_enum~. When ~get_enum~ returns, these pointers become stale
(use-after-free). The Rust version uses owned ~Option<Vec<u8>>~ and ~Option<ValueType>~
which don't have this issue.

*** Fix
Changed pattern binding code in ~interpreter.til~ to look up payload type directly from
the enum definition (via ~lookup_enum~) and read payload bytes directly from the arena,
instead of using the stale ~EnumVal.payload_type~ and ~EnumVal.payload~ pointers.

Supports all payload types: I64, Str, and structs (including Bool and custom structs).

*** Test
~src/test/ufcs.til~ - tests pattern matching with I64 and Str enum payloads.

** Bug #70: C codegen variable type collision causes struct default garbage
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Struct fields with default I64 values returned garbage in til interpret
:STATUS: Fixed
:END:

*** Description
~src/test/mut_test.til~ failed with ~til interpret~, returning garbage values for
struct fields with default I64 values:
#+BEGIN_EXAMPLE
src/test/mut_test.til:65:19:assert_eq failed: expected '0', found '2147395840'
#+END_EXAMPLE

*** Root Cause
In ~src/self/eval_arena.til~'s ~insert_struct_core~, both U8 and I64 branches
used a local variable named ~v~:
#+BEGIN_SRC til
if type_name.eq("U8") {
    v := U8.from_str(default_value)  // v declared as U8
    ...
} else {
    if type_name.eq("I64") {
        v := I64.from_str(default_value)  // v redeclared as I64
        ...
#+END_SRC

The C code generator reused the same variable declaration:
#+BEGIN_SRC c
til_U8 til_v;  // Declared as U8
...
til_v = til_I64_from_str(&til_default_value);  // Assigned I64 to U8!
#+END_SRC

This caused an 8-byte I64 value to be stored in a 1-byte U8 variable,
then only 1 byte was copied to the arena, resulting in garbage values.

*** Fix
Renamed variables to be unique: ~u8_val~ for U8 branch, ~i64_val~ for I64 branch.
This prevents variable name collisions across different type branches.

Files modified:
- ~src/self/eval_arena.til~ (TIL version)
- ~src/rs/eval_arena.rs~ (Rust version, for consistency)

** Bug #63: Typer allows passing const variable to own parameter
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-31
:IMPACT: Incorrect ownership semantics, gcc warnings about discarding const
:STATUS: Fixed
:END:

*** Description
When a function has an ~own~ parameter, the typer should require the caller
to pass a ~mut~ variable, just like it does for ~mut~ parameters. Currently,
the typer allows passing const variables to ~own~ parameters.

*** Reproducing
#+BEGIN_SRC til
consume := proc(own v: Vec2) returns I64 {
    return add(v.x, v.y)
}

test := proc() {
    original := Vec2(x=1, y=2)  // const, not mut
    result := consume(original)  // Should error, but doesn't
}
#+END_SRC

*** Expected behavior
Typer should emit an error like: "Cannot pass const variable 'original' to own parameter 'v'"

*** Fix Applied
Added check in typer.rs and typer.til for ~is_own~ parameter, similar to existing
~is_mut~ check. When processing FCall args, if the parameter is ~own~ and the
argument is a const variable (identifier with ~!symbol_info.is_mut~), emit type error.

** Bug #68: TIL typer doesn't remove symbol for own parameter (Bug #49 fix not working)
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: til_interpreted output mismatch on bug49.til (1 error vs 2)
:STATUS: Fixed
:RELATED: Bug #49 (original fix), Bug #65 (similar Rust/TIL divergence)
:END:

*** Description
The Bug #49 fix (remove_symbol for own parameters) exists in both typer.rs and typer.til,
but the TIL version doesn't work. When a variable is passed to an ~own~ parameter:
- rstil: 2 errors (type ERROR + init ERROR for undefined symbol)
- til: 1 error (init ERROR only)

The ~remove_symbol~ call at typer.til:861 is being executed, but the symbol remains
findable by subsequent lookups.

*** Code Location
typer.til lines 854-866:
#+BEGIN_SRC til
// Bug #49: Handle ownership transfer for 'own' parameters
if arg.is_own {
    switch arg_expr.node_type {
    case NodeType.Identifier(var_name):
        if arg_expr.params.len().eq(0) {
            _ := context.scope_stack.remove_symbol(var_name)
        }
    case:
    }
}
#+END_SRC

*** Investigation Notes (2025-12-31)
- Debug prints confirmed ~remove_symbol~ IS being called and modifies the frame correctly
- After removal, ~lookup_symbol~ correctly shows ~contains_key=false~ for all frames
- BUT ~symbol_found~ is still set to ~true~ after the catch block

*** Root Cause Hypothesis
Examined generated C code in bootstrap/til.c. Found that when there are TWO consecutive
catch blocks for the SAME error type, the second one is MISSING the ~goto~ statement:

~lookup_func~ (first catch - CORRECT):
#+BEGIN_SRC c
int _status_104 = til_ScopeStack_lookup_func(...);
if (_status_104 == 1) { ... goto _catch_KeyNotFoundError_96; }  // <-- goto EXISTS
til_func_found = true;
if (0) { _catch_KeyNotFoundError_96: ... }
#+END_SRC

~lookup_symbol~ (second catch - BROKEN):
#+BEGIN_SRC c
int _status_105 = til_ScopeStack_lookup_symbol(...);
// <-- NO GOTO HERE! Missing: if (_status_105 == 1) { goto _catch_97; }
til_symbol_found = true;
if (0) { _catch_KeyNotFoundError_97: ... }
#+END_SRC

This is a ccodegen.rs bug: consecutive catch blocks for same error type lose their goto.

*** Reproducing Test
Test file: src/test/bug68.til

- ~rstil interpret src/test/bug68.til~ → PASS (symbol_found=false, catch works)
- ~rstil run src/test/bug68.til~ → FAIL (symbol_found=true, catch doesn't execute)

The test imports typer.til and calls ~check_types_with_context~ directly, which
contains the buggy consecutive catch pattern.

*** Partial Fix Applied
Added explicit ~func_found = false~ and ~symbol_found = false~ in catch blocks in typer.til.
This is correct - per rs2til.org, catching KeyNotFoundError is like ~.is_some() = false~.
The catch blocks now have the right code, but ccodegen.rs doesn't generate the goto to reach them.

*** Plan to Fix
1. ✓ Created reproducing test (bug68.til)
2. ✓ Verified ~rstil interpret~ works but ~rstil run~ fails
3. ✓ Added explicit false assignments in catch blocks (typer.til)
4. ✓ Fixed ccodegen.rs: added ~func_level_catches.is_empty()~ check to propagate condition
5. ✓ Ported fix to ccodegen.til

*** Fix Applied
The propagate condition was missing the ~func_level_catches.is_empty()~ check.
When ~local_catch_labels~ was empty (after processing an earlier catch), the code
would propagate errors even when there were more catches in the block.

Fix: Changed propagate condition from:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() {
#+END_SRC
To:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() && func_level_catches.is_empty() {
#+END_SRC

This ensures we only propagate when there are NO catches in the block, not just when
~local_catch_labels~ happens to be empty due to earlier catch processing.

** Bug #67: Enum variant payload type comes through as empty string in til
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 4 til_interpreted tests affected (bug56, editor_mode_test, enums, forward_declarations)
:STATUS: Fixed (3 of 4 tests)
:END:

*** Description
When an enum has a variant with a payload type (e.g., ~Variant1: Str~), the self-hosted
TIL interpreter receives the type as empty string, causing "uses undefined type ''" errors.
The Rust interpreter works correctly.

*** Root Cause
In parser.til, ~to_ptr(payload_type)~ was storing a pointer to a stack variable that
became invalid when the loop continued or function returned. The Rust version uses
~Option<Box<ValueType>>~ which properly heap-allocates, but the TIL translation using
~Ptr~ (per rs2til.org for Option fields) requires explicit heap allocation.

Two locations affected:
1. ~EnumVariant.clone()~ - stored pointer to stack variable ~cloned_type~
2. ~enum_definition()~ - stored pointer to stack variable ~payload_type~

*** Fix
Used malloc to allocate heap memory instead of storing stack pointer:
#+BEGIN_SRC til
// In EnumVariant.clone():
result.payload_type.data = malloc(size_of(ValueType))
memcpy(result.payload_type.data, self.payload_type.data, size_of(ValueType))

// In enum_definition():
payload_ptr.data = malloc(size_of(ValueType))
memcpy(payload_ptr.data, to_ptr(payload_type), size_of(ValueType))
#+END_SRC

*** Results
- bug56.til: Fixed (now in til_interpreted)
- editor_mode_test.til: Fixed (now in til_interpreted)
- forward_declarations.til: Fixed (now in til_interpreted)
- enums.til: Still segfaults (different bug, not enum payload related)

** Bug #65: "Source 'X' not found in caller context" with Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 10 til_interpreted tests fail (arenas, arrays, clone, lists, loops, maps, etc.)
:STATUS: Fixed
:RELATED: Issue #66 (shadowing policy)
:END:

*** Description
When passing literal values to Dynamic parameters (e.g., ~v.push(10)~ on a Vec),
the self-hosted TIL interpreter fails with "Source '10' not found in caller context".
The Rust interpreter works correctly.

*** Root Cause
Rust/TIL divergence in interpreter.rs/interpreter.til:

Rust used variable shadowing (~let custom_type_name = ...~) to resolve Dynamic/Type
parameters to their actual types. TIL doesn't support shadowing the same way, so it
used a different variable (~resolved_type_name~) but then inconsistently used the
original ~custom_type_name~ in subsequent code.

*** Fix
Changed both Rust and TIL to use ~resolved_type_name~ consistently (no shadowing).
Updated ~-Wshadow~ flag for gcc to catch similar issues in generated C code.

Test file: src/test/bug65.til

See Issue #66 in doc/todo/future.org for long-term shadowing policy discussion.

** Bug #60: ccodegen passes const/own args by value instead of by pointer
:PROPERTIES:
:DISCOVERED: 2025-12-28
:FIXED: 2025-12-29
:IMPACT: Stack overflow on recursive functions with large struct args
:STATUS: Fixed
:END:

*** Description
In TIL, function arguments should be passed as follows:
- *const (default)*: by const pointer (const T*)
- *own*: by pointer (T*) - caller transfers ownership
- *mut*: by pointer (T*) - currently correct
- *copy*: by value (T) - currently correct

Currently, ccodegen.rs passes const and own args by value, causing stack
overflow when functions with large struct arguments are called recursively.

*** Reproducing
Inspect gen/c/test/args.c after running ~./bin/rstil run src/test/args.til~:

#+BEGIN_SRC c
// WRONG - const args passed by value:
til_I64 til_test_i64_arg(const til_I64 til_n);
til_Bool til_test_bool_arg(const til_Bool til_b);

// WRONG - own args passed by value:
til_I64 til_consume_i64(til_I64 til_n);
til_I64 til_consume_vec(til_Vec2 til_v);

// CORRECT - mut args passed by pointer:
til_I64 til_mixed_params(const til_I64 til_normal, til_I64* til_m, til_I64 til_o);

// CORRECT - copy args passed by value:
til_I64 til_test_copy_i64(til_I64 til_x);
til_Vec2 til_test_copy_struct(til_Vec2 til_v);
#+END_SRC

Expected signatures:
#+BEGIN_SRC c
// const args should be const pointers:
til_I64 til_test_i64_arg(const til_I64* til_n);
til_Bool til_test_bool_arg(const til_Bool* til_b);

// own args should be pointers:
til_I64 til_consume_i64(til_I64* til_n);
til_I64 til_consume_vec(til_Vec2* til_v);
#+END_SRC

*** Fix
Requires changes in several places in ccodegen.rs:

1. *emit_func_signature* - Change signature generation for const and own:
   - const: ~const til_Type* til_arg~
   - own: ~til_Type* til_arg~

2. *param_by_ref calculation* - Change from ~is_mut~ to ~!is_copy~:
   - Affects all places that calculate ~param_by_ref~ vector

3. *current_ref_params tracking* - Track all non-copy params:
   - Change from ~is_mut~ to ~!is_copy~ in function body setup

4. *hoist_for_ref_params* - Add hoisting for literals that can't use ~&~:
   - Similar pattern to existing ~hoist_for_dynamic_params~
   - Only TWO cases need hoisting:
     a) *I64 literals*: ~&69~ is invalid C (can't take address of rvalue)
        Must hoist to: ~til_I64 _tmp = 69; func(&_tmp);~
     b) *Type literals*: ~&"Str"~ gives ~char**~ but we need ~const char* const*~
        Must hoist to: ~til_Type _tmp = "Str"; func(&_tmp);~
   - Note: Type is a special type like Dynamic - see how Dynamic is handled

5. *emit_arg_with_param_type* - For identifiers that are ref params:
   - When ~param_by_ref~ is true and arg is already a pointer, just emit name
   - Don't call ~emit_expr~ which would dereference with ~(*name)~

6. *ext.c functions* - Update to accept pointers for const/own args:
   - All ext functions should use ~const til_Type*~ for const args
   - Example: ~til_add(const til_I64* a, const til_I64* b)~
   - This keeps everything consistent - no special-casing ext funcs

*** Literal Types - What CAN vs CANNOT use ~&~ prefix

*CAN use ~&~ directly (compound literals in C99+):*
- Str: ~&((til_Str){(til_I64)"hello", 5})~ - valid, compound literal is lvalue
- U8: ~&((til_U8){42})~ - valid, compound literal is lvalue
- Bool: ~&((til_Bool){1})~ - valid, compound literal is lvalue
- Any struct: ~&((til_MyStruct){...})~ - valid, compound literal is lvalue

*CANNOT use ~&~ - must hoist to temp var:*
- I64: ~&69~ - INVALID, plain integer is rvalue
- Type: ~&"Str"~ - gives wrong type (~char**~ instead of ~const char* const*~)

*** Solution
Implemented all the planned fixes:
1. Added ~param_needs_by_ref~ helper function to determine if param should be passed by pointer
2. Changed ~param_by_ref~ calculation from ~is_mut~ to ~param_needs_by_ref(arg)~
3. Added ~hoist_for_ref_params~ function to hoist I64 literals and function call results
4. Updated ~emit_func_signature~ to emit const pointers for const params
5. Updated ~emit_arg_with_param_type~ to handle by-ref params correctly
6. Updated ~ext.c~ functions to accept pointers for const/own args
7. Fixed hardcoded main args initialization to use compound literals for I64

Files modified:
- src/rs/ccodegen.rs, src/self/ccodegen.til
- src/rs/init.rs, src/self/init.til (added is_enum_constructor helpers)
- src/ext.c (updated function signatures)

*Performance Impact:*
Passing primitives (I64, Bool) by pointer adds overhead:
- til_interpreted tests: ~8.5s -> ~13.8s per test (~60% slower)
- Total til_interpreted: 338s -> 543s
This is expected since primitives were previously passed by value (fast) and now
require pointer indirection. The correctness fix was necessary to prevent stack
overflow on recursive functions with large struct arguments.

** Bug #61: Optional args before variadic don't use default when type mismatches
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Cannot have optional args before variadic with type-based defaulting
:STATUS: Fixed
:END:

*** Description
When a function has an optional argument (with default value) before a variadic
argument, and the caller omits the optional arg, the typer doesn't detect that
the provided arg type doesn't match and use the default.

*** Fix
Modified check_fcall in typer.rs to track definition arg index separately from
provided arg index. When type doesn't match and the param has a default value
and variadic follows, skip the optional param and continue matching.

Also modified precompute_fcall_args in precomp.rs to insert default values for
skipped optional args before variadic.

Files modified:
- src/rs/typer.rs - check_fcall with def_arg_idx tracking and skip logic
- src/rs/precomp.rs - reorder_named_args with optional-before-variadic handling
- src/self/typer.til - same changes
- src/self/precomp.til - same changes
- src/test/args.til - uncommented test_optional_before_variadic test

** Bug #62: U8 type annotations generate I64 in C codegen
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Wrong type in generated C code, potential overflow/truncation bugs
:STATUS: Fixed
:END:

*** Description
When declaring a variable with explicit U8 type annotation, the C codegen
generates til_I64 instead of til_U8.

*** Root Cause
In ccodegen.rs emit_declaration, the code always called get_value_type() to
infer the type from the RHS expression, ignoring explicit type annotations.
Integer literals return I64 from get_value_type(), so U8 annotations were lost.

*** Fix
Check if decl.value_type is INFER_TYPE before inferring. If an explicit type
is provided, use it directly instead of inferring from RHS.

Files modified:
- src/rs/ccodegen.rs - emit_declaration, mut and const branches
- src/self/ccodegen.til - emit_declaration, mut and const branches

Test: src/test/literals.til

** Bug #58: Error messages show file path twice
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Confusing error messages
:STATUS: Fixed
:END:

*** Description
Error messages show the file path duplicated:
#+BEGIN_EXAMPLE
src/test/bug50.til:src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

Should show:
#+BEGIN_EXAMPLE
src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

*** Root Cause
In interpreter.rs and builder.rs, errors were printed with ~println!("{}:{}", path, err)~
but ~err~ already contains the path from ~error()~ / ~todo_error()~ which format as
~"path:line:col: ..."~.

*** Fix
Removed the duplicate path prefix from error printing in:
- src/rs/interpreter.rs (lines 2889, 2917, 2949)
- src/rs/builder.rs (lines 158, 165, 189, 205, 214)
- src/self/interpreter.til (lines 3222, 3255, 3296)
- src/self/builder.til (5 locations)

** Bug #50: Codegen doesn't capture outer variables in nested functions
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-27
:IMPACT: Nested functions fail to compile when accessing outer scope variables
:STATUS: Fixed
:END:

*** Description
Nested functions (closures) in TIL can access variables from their enclosing scope.
This works correctly in the interpreter but fails during C code generation - the
outer variables are not captured/passed to the nested function.

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug50.til
#+END_SRC

*** Error Output
#+BEGIN_EXAMPLE
gen/c/test/bug50.c: In function 'til_test_closure_inner':
gen/c/test/bug50.c:1703:12: error: 'til_outer_var' undeclared (first use in this function)
#+END_EXAMPLE

*** Root Cause
In ccodegen, when emitting nested functions, variables from the outer scope (s1, s2,
silabes) are referenced but not passed as parameters or captured in a closure struct.

*** Potential Solutions

**** 1. Lambda Lifting (Recommended)
Transform nested functions into top-level functions, adding captured variables as
explicit parameters. The compiler would:
- Analyze which outer variables are referenced inside the nested function
- Add those as extra parameters to the lifted function
- At call sites, pass the captured variables explicitly

Pros: Simple, no runtime overhead, matches how TIL already handles explicit params
Cons: Recursive nested functions need care (captured vars passed through each call)

**** 2. Closure Struct
Create a struct containing all captured variables, pass pointer to nested function:
#+BEGIN_SRC c
struct poem_closure { Str s1; Str s2; };
Str poem(I64 depth, Str current, struct poem_closure* ctx) {
    // use ctx->s1, ctx->s2
}
#+END_SRC

Pros: Clean abstraction, single extra parameter regardless of capture count
Cons: Slightly more complex codegen, minor indirection overhead

**** 3. GCC Nested Functions Extension
GCC supports nested functions as a non-standard extension. We could use this directly.

Pros: Zero codegen changes for nested function bodies
Cons: GCC-only (not clang/MSVC), uses trampolines (executable stack), less portable

**** 4. Restrict Nested Function Captures (CHOSEN)
Disallow nested functions from capturing outer variables - require explicit parameters.
This is a language design change rather than a fix.

Pros: Simpler language semantics, no closure machinery needed
Cons: Breaking change, less ergonomic for users

*** Fix (2025-12-27)
Added =is_closure_capture()= function to ScopeStack (init.rs/init.til) that detects
when a symbol access would require closure capture. In typer (typer.rs/typer.til),
when an identifier is found to be a closure capture, emit a todo_error:
"Closures are not supported yet. Pass 'varname' as a parameter instead."

Full closure support deferred to post.org.

*** Files Modified
- src/rs/init.rs: Added =is_closure_capture()= to ScopeStack
- src/rs/typer.rs: Added closure capture check in NodeType::Identifier handling
- src/self/init.til: Ported =is_closure_capture()=
- src/self/typer.til: Ported closure capture check
- src/examples/lolalalo.til: Fixed to pass captured vars as explicit parameters
- src/test/bug50.til: Regression test (expected to fail with todo_error)

*** Historical: Lambda Lifting Attempt (2025-12-19, abandoned)
Before choosing option 4, started "Phase A: Const Args by Reference" in =wio= branch
as a prerequisite for lambda lifting. This is no longer needed since we chose to
forbid closures instead of implementing them.

Phase A completed items (for reference if lambda lifting is revisited):
- emit_func_signature: all non-copy params now const Type*
- by_ref calculations: changed from is_mut to !is_copy (7 locations)
- current_ref_params: now includes all non-copy params
- Variadic handling: fixed in emit_fcall_name_and_args_for_throwing and emit_fcall
- Compound literals: added for number/string literals

Phase A remaining issue:
- Nested struct-returning function calls passed to by-ref params need hoisting
- Current hoisting only works at statement level (indent > 0)

** Bug #47: Self-hosted TIL interpreter fails with "NodeType.?" error
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-27
:IMPACT: ./bin/til interpret fails on any file
:STATUS: Fixed
:END:

*** Description
The compiled self-hosted TIL interpreter (./bin/til) fails immediately when trying
to interpret any file, including empty.til. The error occurs during core library
initialization (vec.til:63).

*** Error Message
#+BEGIN_EXAMPLE
Error during file execution: src/core/core.til:src/core/vec.til:63:63: til init ERROR: Identifiers can only contain identifiers, found 'NodeType.?'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Analysis
The "NodeType.?" indicates an invalid enum tag value is being read from memory.
This happens in init.til's =get_value_type= function when iterating over
=e.params= (a Vec of Expr) - some Expr has a corrupted NodeType field.

*** Bug Type
CODEGEN BUG - rstil works, compiled til fails. Per methodology: "interpret works
but run fails" = codegen issue in ccodegen.rs

*** Investigation Notes
- rstil interpret works fine, only til (compiled self-hosted) fails
- The error is consistent - always at vec.til:63 during init
- Struct sizes match between TIL calculation and C sizeof for Expr (288 bytes)
- Invalid NodeType tag value found: 840973088 (0x32202E32) - looks like ASCII data

*** Key Discovery (2025-12-19)
Added =Expr.to_str()= and debug prints to =get_value_type= in init.til.

The expression =self.ptr= at vec.til:63 is processed 3 times:
#+BEGIN_EXAMPLE
1st call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
2nd call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
3rd call: e.params = [Expr{NodeType.?, ...}]         <- CORRUPTED
#+END_EXAMPLE

*Critical*: The corruption is visible in =e.to_str()= BEFORE iterating over params.
This means corruption happens BETWEEN calls to get_value_type, not during the
for-in loop or Vec.get. Something external is corrupting the Expr data.

*** What Was Ruled Out
- Bug #52 (static buffer in ext.c) - fixed, didn't solve this
- Bug #53 (missing null termination in str.til) - fixed, didn't solve this
- for-in vs while+Vec.get - both show same corruption

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug47.til  # PASS
./bin/til interpret src/test/bug47.til    # FAIL with NodeType.?
#+END_SRC

The test file (src/test/bug47.til) calls check_types directly without
using interpret_file, isolating the bug to the typer code path.

*** Notes
Bug #52 and #53 were discovered while investigating this issue. Both are now fixed
but did not resolve the NodeType memory corruption.

*** Narrowed Down Location (2025-12-19)
The corruption happens in =check_types_with_context= function in typer.til:
- Specifically in the =NodeType.Identifier(name)= case (lines 237-272)
- Around the =lookup_symbol= call (lines 259-265)

Call tracing showed:
- get_value_type calls #477 and #478 share the same =params.ptr=
- Call #477 sees valid data: =self.ptr line=63=
- Call #478 sees corrupted data: =? line=26726118198=
- Corruption happens BETWEEN these calls, during check_types_with_context

*** Debug Strategy
To find the exact line causing corruption:
1. Add debug print with =e.to_str()= after EVERY line in check_types_with_context
2. Run test once
3. Find where output changes from valid to corrupted

*** Minimal Reproducer (2025-12-26)
Found a minimal reproducer in =src/test/bug47.til=:

#+BEGIN_SRC til
mode test
import("self.builder")

run_it := proc(path: Str) throws Str, AllocError {
    mut args := Vec.new(Str)
    _ := run_file(path, args)
}

wrapper := proc() {
    run_it("src/examples/empty.til")
    catch (err: Str) { println(err) }  // Using 'err' triggers bug
    catch (err: AllocError) { }
}

wrapper()
#+END_SRC

Key finding: The bug only triggers when the caught error variable =err= is actually
USED inside the catch block (e.g., =println(err)=). An empty catch block or one that
doesn't reference =err= does NOT trigger the bug.

Reproduce:
#+BEGIN_SRC bash
./bin/rstil run src/test/bug47.til  # FAILS with NodeType.?
#+END_SRC

*** What Triggers vs What Doesn't
| Catch block code         | Result   |
|--------------------------+----------|
| catch (err: Str) { }     | Works    |
| catch (err: Str) { println("Error") } | Works |
| catch (err: Str) { println(err) }     | BUG    |

This suggests the bug is related to how the caught error variable is stored/accessed
in the generated C code when used inside the catch block body.

*** Fix (2025-12-27)
Removed 4 =id_params.delete()= calls in typer.til (lines 2657, 2694, 2699, 2704).

The issue was that =id_params= was a shallow clone of expression params, and
=extra_arg_e= (used in UFCS transformation) still referenced memory owned by
=id_params=. When =id_params.delete()= was called, it freed memory that
=extra_arg_e= was still using, causing memory corruption.

Note: ./bin/til still segfaults on other issues, but the NodeType.? error is fixed.
The test src/test/bug47.til now passes in rs_common (both interpret and run).

** Bug #56: Interpreter rejects FCall in enum payload inside func/proc
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Workaround required for clone calls in enum constructors
:STATUS: Fixed
:END:

*** Description
When constructing an enum with a payload that is a function call (FCall),
the interpreter rejected it with "Struct payload must be a variable identifier
or literal, got FCall". This only happened inside func/proc bodies - top level
declarations worked fine. Compiled mode also worked fine.

*** Root Cause
In interpreter.rs, the match statement handling struct payloads (for enum
variants) only handled Identifier and Literal node types, not FCall. Top-level
worked because it used a different code path.

*** Fix
Added a case for NodeType::FCall when the struct type is "Str". The fix creates
a temporary variable to hold the FCall result, then uses that variable name
as the payload. This mirrors what the existing Identifier and Literal handlers do.

Changes made:
- interpreter.rs: Added FCall case for Str payloads in enum variant construction
- interpreter.til: Ported fix to TIL self-hosted implementation
- Also fixed error message from "Struct payload" to "Enum variant payload"

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug56.til
# Output: All tests passed
#+END_SRC

** Bug #57: continue in for loops causes infinite loop
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Must use while loops instead of for when continue is needed
:STATUS: Fixed
:END:

*** Description
The ~continue~ statement caused infinite loops when used in ~for~ loops.
This happened because ~for~ desugars to ~while~ with the loop variable increment
at the END of the body. ~continue~ skips the rest of the body including the
increment, causing the loop variable to never change.

*** Root Cause
The parser desugars ~for i in 0..N { body }~ to:
#+BEGIN_SRC til
mut i := 0
while lt(i, N) {
    body
    i.inc()  // increment at END
}
#+END_SRC

When ~continue~ is in the body, it jumps to the while condition check,
skipping ~i.inc()~.

*** Fix
Transform continue statements to include the step expression before the continue.
The transformation replaces ~continue~ with ~{ i.inc(); continue }~.

This ensures the loop variable is always incremented/decremented before jumping
to the condition check, regardless of whether continue was used.

Changes made:
- parser.rs: Added ~transform_continue_with_step~ helper, applied to range-based for loops
- precomp.rs: Same fix for collection-based for-in loops
- parser.til, precomp.til: Ported fixes to TIL self-hosted implementation

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug57.til
# Output: Bug #57 test passed: continue in for loops works correctly
#+END_SRC

** Bug #55: C codegen generates wrong code for throwing function calls inside struct literals
:PROPERTIES:
:DISCOVERED: 2025-12-26
:FIXED: 2025-12-26
:IMPACT: C compile error, blocks removing legacy .new() methods
:STATUS: Fixed
:END:

*** Description
When a function that throws (uses out-parameter calling convention in C) is called
inside a struct literal field initializer, the C codegen generates incorrect code
with 1 argument instead of 3 (out-param + error-param + actual args).

*** Example
#+BEGIN_SRC til
Item := struct {
    mut name: Str = ""
    mut count: I64 = 0
}

test := proc() {
    original := "hello"
    // Bug: clone() inside struct literal generates wrong C code
    items.push(Item(name=original.clone(), count=42))
}
#+END_SRC

*** Generated C (incorrect)
#+BEGIN_SRC c
til_Item _tmp = (til_Item){.name = til_Str_clone(til_original), .count = 42};
// ERROR: til_Str_clone expects 3 args: (til_Str* _ret, til_AllocError* _err, til_Str self)
#+END_SRC

*** Expected C (correct)
#+BEGIN_SRC c
til_Str _cloned_name;
til_AllocError _err;
if (til_Str_clone(&_cloned_name, &_err, til_original)) { /* handle error */ }
til_Item _tmp = (til_Item){.name = _cloned_name, .count = 42};
#+END_SRC

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug55.til
# Previously: ERROR: gcc failed: too few arguments to function 'til_Str_clone'
# Now: passes
#+END_SRC

*** Root Cause
In ~hoist_throwing_args~, non-FCall arguments (like NamedArg nodes inside struct
literals) were not being processed. When ~items.push(Item(name=original.clone()))~
was passed, the struct literal's arguments are NamedArg nodes, and these fell
through the if/else-if chain without being processed, so the throwing call inside
the NamedArg never got hoisted.

*** Fix
Added an else clause at the end of ~hoist_throwing_args~ to call ~hoist_throwing_expr~
for non-FCall arguments. This ensures throwing calls inside named args (and other
non-FCall expression types) are properly hoisted.

Files changed:
- src/rs/ccodegen.rs: Added else clause in hoist_throwing_args
- src/self/ccodegen.til: Same fix ported
- src/test/bug55.til: Test case added to rs_common

** Bug #42: Temp variable naming inconsistency causes undeclared _tmp_N errors
:PROPERTIES:
:DISCOVERED: 2025-12-17
:FIXED: 2025-12-26
:IMPACT: Compilation fails
:STATUS: Fixed
:END:

*** Description
After commit 5707c2d (Make _for_i_ variable names deterministic), some code paths generate temp variables with old-style names (_tmp_N) while others use new-style names (_tmp_funcname_N). This causes gcc errors for undeclared variables.

#+BEGIN_EXAMPLE
gcc error: '_tmp_13' undeclared (first use in this function)
In til_Vec_clone:
til_Vec til_cloned = {..., .ptr = _tmp_13, ...};
#+END_EXAMPLE

*** Root Cause
~emit_struct_func_body~ (ccodegen.rs:2527-2597) did NOT set ~current_function_name~
before emitting the function body, while regular functions did. This caused struct
methods like ~Array.new~, ~Array.get~, ~Vec.clone~ to generate temp names like
~_tmp_0~ instead of ~_tmp_Array_new_0~.

*** The Fix
Added save/set/restore pattern for ~current_function_name~ and ~mangling_counter~
in ~emit_struct_func_body~, matching the pattern used for regular functions.

Also fixed TIL's ~next_mangled~ to include function name prefix (was missing entirely).

*** Files Modified
- src/rs/ccodegen.rs: Added current_function_name handling to emit_struct_func_body
- src/self/ccodegen.til: Same fix + updated next_mangled to include function prefix

** Bug #54: Pure functions that throw are not folded at compile time
:PROPERTIES:
:DISCOVERED: 2025-12-20
:FIXED: 2025-12-26
:IMPACT: Missed compile-time error detection, deferred to runtime
:STATUS: Fixed
:END:

*** Description
Pure functions with ~throws~ in their signature are not evaluated at compile
time, even when called with literal arguments. This prevents catching errors
at compile time that could be detected during precomputation.

*** Example
#+BEGIN_SRC til
always_throws := func(n: I64) returns I64 throws Str {
    if gt(n, 0) {
        throw "intentional error"
    }
    return 0
}
x := always_throws(5)  // Should fail at compile time, but runs at runtime
#+END_SRC

*** Reproducing
See ~src/test/precomp_throw.til~ - the test is expected to fail at precomp time
but currently reaches runtime instead.

*** Root Cause
In commit 9a79e93c (Dec 11, 2025), a check was added to ~is_comptime_evaluable~
that blocks folding for any function with throw_types:

#+BEGIN_SRC rust
// src/rs/precomp.rs lines 265-269
if !func_def.throw_types.is_empty() {
    return false;
}
#+END_SRC

Before this change, the comment said: "Functions that can throw are allowed -
if they actually throw, we'll report the error in eval_comptime"

The ~eval_comptime~ function already has infrastructure to handle thrown
exceptions (lines 291-296) and report them as precomp errors.

*** Solution
Removed the blanket throw_types check. Now only functions throwing ~AllocError~,
~IndexOutOfBoundsError~, or ~KeyNotFoundError~ are excluded (these depend on runtime state).
Other throwing functions are evaluated at compile time, and if they throw, the exception
is caught by ~eval_comptime~ and reported as a compile-time error.

*** Fix Details
Part of the precomp overhaul (see doc/todo/precomp_overhaul.org):
- Modified ~is_comptime_evaluable~ to only exclude specific runtime-dependent error types
- Added is_proc() check and return_types.is_empty() check
- Added U8 support in ~eval_comptime~
- Many other structural improvements to make precomp work like interpreter

** Bug #48: Typer missing validation that mut arguments must be lvalues
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: No clear error message when passing literals to mut params
:STATUS: Fixed
:END:

*** Description
The typer phase is missing a validation check: arguments to =mut= parameters
must be lvalues (identifiers or field access). This affects both interpreter
and compiler paths - both should catch this in the typer phase.

*** Example
#+BEGIN_SRC til
test_mut := proc(mut n: I64) {
    n = 99
}
test_mut(42)  // Should be rejected by typer
#+END_SRC

*** Fix Applied (2025-12-18, commit ae0b5eb)
Added =NodeType::LLiteral= case in =check_fcall= to reject literals passed to
mut parameters. Error message: "Cannot pass literal to mut parameter 'X'. Use
a variable instead."

*** Files Modified
- src/rs/typer.rs: Added LLiteral case in is_mut check
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug48.til with expected_status=1

*** Regression Test
src/test/bug48.til (expects exit code 1 - type error)

** Bug #49: Typer missing use-after-move check for own parameters
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-20
:IMPACT: Compiled code allows use of moved variable
:STATUS: Fixed
:END:

*** Description
When a variable is passed to an =own= parameter, the variable should be
invalidated in the caller's scope. The interpreter catches this at eval time,
but the typer doesn't track it - so compiled code allows using the variable.

*** Example
#+BEGIN_SRC til
consume := proc(own n: I64) returns I64 {
    return mul(n, 2)
}

test := proc() {
    mut x := 42
    result := consume(x)
    println(I64.to_str(x))  // Should be rejected - x was moved
}
#+END_SRC

*** Expected Behavior
Typer should reject use of =x= after it was passed to =own= parameter:
"Variable 'x' was moved and can no longer be used"

*** Actual Behavior
- Typer: No tracking of moved variables (the bug)
- Interpreter: Catches at eval - "Undefined symbol 'x'" (wrong phase)
- Compiler: No catch at all - x still usable with original value

*** Fix Applied (2025-12-20)
In typer's =check_fcall= function, after all type checking for an argument is complete,
if the parameter has =is_own= and the argument is a simple identifier, remove the
symbol from scope using =context.scope_stack.remove_symbol()=.

Key insight: The removal must happen AFTER =get_value_type= is called on the argument,
not before - otherwise the type lookup fails for the current argument.

*** Files Modified
- src/rs/typer.rs: Added remove_symbol call at end of argument loop in check_fcall
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug49.til with expected_status=1

*** Regression Test
src/test/bug49.til (expects exit code 1 - type error)

*** Related
- Bug #48: Similar issue for =mut= parameters (lvalue check)
- See doc/ownership.org for full ownership design

** Bug #34: Code after catch blocks doesn't run in error path
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

*** Description
Code placed AFTER catch blocks doesn't run when an error is caught.

*** Example
#+BEGIN_EXAMPLE til
throwing_call()
between = true      // Between throw and catch - correctly skipped on error
catch (err: Error) {
    // error caught
}
code_after_catch()  // Now runs correctly in both success and error paths
#+END_EXAMPLE

*** Root Cause
In the C code generator, statements after the last catch block were emitted BEFORE
the ~goto _end_catches~ jump, so they only ran on the success path.

*** Complete Fix (2025-12-15, commit 9781c41)
The initial partial fix used emit_expr directly for statements after the last
catch block. However, emit_expr doesn't do throwing call detection, causing
throwing functions like Vec.push to be emitted without error parameters.

The complete fix:
1. Find the index of the last catch block in emit_stmts
2. Only emit statements up to and including the last catch in the main loop
3. After emitting _end_catches label, call emit_stmts recursively for remaining
   statements - this properly handles throwing calls with error detection and
   goto labels

*** Files Modified
- src/rs/ccodegen.rs: emit_stmts recursive call for statements after last catch
- src/self/ccodegen.til: Same fix ported
- src/test/errors.til: Regression test (test_bug34)

** Bug #46: Infinite loop in typer.til due to catch catching later throw
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: til interpret/run hangs indefinitely
:STATUS: Fixed
:END:

*** Description
When running =./bin/til interpret= or =./bin/til run=, the self-hosted compiler hangs
in an infinite loop. Debug output shows "struct_found=true" printing infinitely in
typer.til's struct/enum lookup code.

*** Root Cause
In typer.til around lines 2500-2520, a catch block catches a throw that comes AFTER it
lexically, creating an infinite loop:

#+BEGIN_EXAMPLE til
// typer.til lines ~2500-2520 (approximate)
struct_def = context.scope_stack.lookup_struct(combined_name)
struct_found = true
catch (err: KeyNotFoundError) {  // Line ~2508 - catches lookup_struct errors
    // Struct not found, continue to enum check
}

if struct_found {
    // Line ~2515 - THIS throw gets caught by the catch at line ~2508!
    throw KeyNotFoundError(msg=format("Struct instantiation: ", combined_name))
}
#+END_EXAMPLE

The flow:
1. lookup_struct throws KeyNotFoundError
2. Catch at ~2508 handles it, struct_found remains false
3. Code continues, struct_found is set true later
4. Throw at ~2515 is caught by the catch at ~2508 (wrong!)
5. Execution continues after catch, loops back, struct_found=true prints
6. Infinite loop

*** Expected Behavior
The throw at line ~2515 should propagate UP to the caller, not be caught by
the catch at ~2508 which is meant only for lookup_struct errors.

*** Actual Behavior
The catch block's scope extends beyond just the lookup_struct call, incorrectly
catching throws that come after it in the source code.

*** Reproducing Test
src/test/bug46.til - Passes with interpreter, fails with compiler:
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug46.til  # PASS
./bin/rstil run src/test/bug46.til        # FAIL - Bug #46 present
#+END_SRC

Self-hosted compiler hangs:
#+BEGIN_SRC bash
timeout 30 ./bin/rstil build src/til.til && timeout 10 ./bin/til interpret src/examples/empty.til
# Times out (exit code 124)
#+END_SRC

*** Related
- Bug #34: Code after catch blocks doesn't run in error path (partially fixed)
- Bug #39: Non-consecutive catches fail (fixed)
- Bug #44: Codegen missing status check after blocks with catches (fixed)

All these bugs relate to catch block scope/semantics in generated C code.

*** Fix Applied (2025-12-18)
The issue was in ccodegen's emit_stmts function. When processing catch blocks,
they were added to =local_catch_labels= at the START of statement processing.
This meant ALL throws anywhere in the function could jump to ANY catch, even
catches that appeared BEFORE the throw lexically.

The fix: After emitting a catch block, remove it from =local_catch_labels=.
This ensures only throws that come BEFORE a catch can use it, mirroring the
interpreter's behavior where =pending_throw= is set by statements and only
subsequent catches can handle it.

*Rust* (src/rs/ccodegen.rs lines 3149-3153):
#+BEGIN_SRC rust
// Bug #46 fix: Remove this catch from local_catch_labels
// Catches should only handle throws from BEFORE them, not after.
ctx.local_catch_labels.remove(err_type_name);
#+END_SRC

*TIL* (src/self/ccodegen.til lines 4551-4555):
#+BEGIN_SRC til
// Bug #46 fix: Remove this catch from local_catch_labels
ctx.local_catch_labels.remove(err_type_name)
#+END_SRC

*** Files Modified
- src/rs/ccodegen.rs: Added removal of catch from local_catch_labels after processing
- src/self/ccodegen.til: Same fix ported

** Bug #45: init.til uses invalid fallthrough switch syntax
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Functions not registered - til fails with "Undefined symbol 'sub'"
:STATUS: Fixed
:END:

*** Description
init.til incorrectly uses C-style switch fallthrough syntax, which TIL does not support.
TIL requires each case to have its own body - there is no fallthrough.

This causes functions (FTFunc, FTProc, etc.) to not be registered in init_context, since
only the FTMacro case has the declare_func call.

*** Wrong TIL Source (init.til lines 1466-1474)
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
case FunctionType.FTFuncExt:
case FunctionType.FTProc:
case FunctionType.FTProcExt:
case FunctionType.FTMacro:
    // WRONG: only FTMacro case has the body!
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Correct TIL (bodies must be repeated)
Per doc/translate_rs2til.org lines 39-50, TIL requires separate case arms:
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTFuncExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProcExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTMacro:
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Root Cause
Translation error from Rust to TIL. Rust uses | to combine patterns, TIL requires
repeated bodies. See doc/translate_rs2til.org for the translation rules.

*** Fix Applied (2025-12-18)
Fixed init.til lines 1465-1511 to repeat the switch body for each FunctionType case:
- FTFunc, FTFuncExt, FTProc, FTProcExt, FTMacro all now have identical bodies
- Each case calls declare_symbol and declare_func

Searched all other .til files in src/self/ for similar patterns - none found.
Other consecutive case patterns are either:
1. Cases with bodies on same line (e.g., `case X: return "x"`)
2. Intentional "do nothing" cases with comments (e.g., skip primitives I64/U8/Str)

** Bug #44: Codegen missing status check for throwing call after block with catches
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: Wrong code execution - statements after throwing call run when they shouldn't
:STATUS: Fixed
:END:

*** Description
When a throwing function call is followed by catch, but there's a preceding block
(if/switch) that also contains catches, the status check for the later throwing call
is sometimes missing from the generated C code.

This causes the "func 'Bool' returns multiple values" error when til processes
bool.til, because get_fcall_value_type incorrectly finds Bool as a function (due
to lookup_func not properly short-circuiting on KeyNotFoundError).

*** Example Problem
#+BEGIN_EXAMPLE til
test_func := func() returns I64 throws Str {
    // Block with catches
    if true {
        mut val := maybe_throw_A(false)
        catch (err: ErrorA) { }
    }

    // After the block - status check is MISSING for this call!
    mut found := false
    mut result := maybe_throw_C(true)  // This throws
    found = true  // BUG: This runs even though C threw!
    catch (err: ErrorC) { }

    if found { throw "found should be false!" }
    return 0
}
#+END_EXAMPLE

*** Generated C Code (broken)
The call at line 10488 in til.c is missing the status check:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
// MISSING: if (_status_... == 1) { goto _catch_...; }
til_standalone_func_def = _ret_...;
til_found_standalone = true;  // Runs unconditionally!
if (0) { _catch_KeyNotFoundError_...: ... }
#+END_EXAMPLE

Compare with line 24060 which is correct:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
if (_status_... == 1) { _thrown_... = _err0_...; goto _catch_...; }  // Correct!
til_func_def = _ret_...;
#+END_EXAMPLE

*** Root Cause (Likely)
In ccodegen.rs, the `local_catch_labels` map is being cleared/repopulated
incorrectly when processing blocks with catches, causing the catch for the
later throwing call to not be registered when the call is processed.

The bug affects get_fcall_value_type in init.til (line 651) but NOT
is_expr_calling_procs in typer.til (same pattern, but generates correctly).

*** Reproducing Test
src/test/bug44.til

*** Files to Investigate
- src/rs/ccodegen.rs: emit_stmts, local_catch_labels handling
- Specifically the logic at lines 3215-3233 where next_catches is built
- Compare what's different about init.til vs typer.til that causes only one to fail

** Bug #43: Map.get returns wrong value when Map is field inside struct (rstil interpreter)
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Data corruption in interpreter
:STATUS: Fixed
:END:

*** Description
When a Map is stored as a field inside a struct, the rstil interpreter's Map.get returns incorrect values (0 instead of actual stored value). The compiled version (rstil run) works correctly.

*** Example Problem
#+BEGIN_EXAMPLE til
import("std.map")

Frame := struct {
    mut funcs: Map = Map.new(Str, I64)
}

test_map_in_struct := proc() {
    mut frame := Frame()
    frame.funcs.insert("test", 42)

    mut val := 0
    frame.funcs.get("test", val)
    println("Got value = ", val.to_str())  // BUG: prints 0, should print 42
}
#+END_EXAMPLE

*** Test Results (Before Fix)
- =rstil interpret tmp/test_scope_pattern.til= -> val = 0 (WRONG)
- =rstil run tmp/test_scope_pattern.til= -> val = 42 (CORRECT)

*** Root Cause
Three issues were discovered when structs have nested struct defaults like =Map.new(Str, I64)=:

1. *Vec.ptr not initialized*: When struct templates were created, ptr fields were
   skipped (to avoid dangling pointers), but Vec.push didn't check for ptr=0.
   This caused pushes to write to NULL memory when Vec was part of a struct default.

2. *Str fields not copied*: read_struct_primitive_fields only read I64/U8 values.
   Str fields like =key_type_name= weren't being read from the evaluated instance,
   causing Map to have empty type names and fail key comparisons.

3. *Vec.cap not preserved*: The Vec's capacity from Vec.new was lost because nested
   struct fields weren't being recursively read. This caused malloc(0) in Vec.push.

*** Fix Applied (2025-12-18)

*Part 1: Vec.push null pointer check* (src/core/vec.til lines 60-71)
Added check at start of push to allocate if ptr=0:
#+BEGIN_SRC til
if self.ptr.eq(0) {
    if self.cap.eq(0) {
        self.cap = Vec.INIT_CAP
    }
    self.ptr = malloc(mul(self.cap, self.type_size))
    if NULL.eq(self.ptr) {
        throw AllocError(msg=format(loc(), "Vec.push: malloc failed"))
    }
}
#+END_SRC

*Part 2: read_struct_primitive_fields* (src/rs/interpreter.rs lines 214-279)
New function that reads primitive values from evaluated struct instances:
- Reads I64 values (skipping ptr/c_string to avoid dangling pointers)
- Reads U8 values
- Reads Str values using string_from_context (gets actual string content)
- Recursively reads nested struct primitive fields (Vec, etc.)

*Part 3: eval_struct_defaults* (src/rs/interpreter.rs lines 303-319)
After getting static defaults for nested structs, override with actual primitive
values from the evaluated instance:
#+BEGIN_SRC rust
let primitive_values = read_struct_primitive_fields(ctx, &instance_id, type_name, "", e)?;
for (k, v) in primitive_values {
    defaults.insert(format!("{}.{}", decl.name, k), v);
}
#+END_SRC

*Part 4: TIL port* (src/self/interpreter.til lines 138-219, 304-316)
Same changes ported to the self-hosted interpreter.

*** Reproducing Test
src/test/bug43.til (now passes both interpret and run)

*** Files Modified
- src/rs/interpreter.rs: Added read_struct_primitive_fields, modified eval_struct_defaults
- src/rs/eval_arena.rs: Minor cleanup
- src/core/vec.til: Added null pointer check in Vec.push
- src/self/interpreter.til: Ported fix to TIL version

** Bug #40: Precomp generates non-deterministic _for_i_ variable names
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Build reproducibility
:STATUS: Fixed
:END:

*** Description
The precomp phase generates `_for_i_N` variable names for desugared for-in loops using a global counter (`Arena::g().temp_id_counter`). This counter accumulates across file compilations, causing the same source code to produce different C output depending on compilation order or what was compiled before.

#+BEGIN_EXAMPLE
// First compilation produces:
til_I64 _for_i_159 = 0;

// Second compilation (same source) produces:
til_I64 _for_i_160 = 0;
#+END_EXAMPLE

This makes diffs between generated C files noisy and harder to review.

*** Root Cause
In precomp.rs (line 422-424), the `_for_i_` index variable name is generated using a global singleton counter:

#+BEGIN_SRC rust
let forin_id = Arena::g().temp_id_counter;
Arena::g().temp_id_counter += 1;
let index_var_name = format!("_for_i_{}", forin_id);
#+END_SRC

Unlike ccodegen's `next_mangled()` which was fixed to reset per-function and include function name prefix, precomp still uses this global counter.

*** Related
- ccodegen's `_tmp_` variables were fixed to be deterministic (counter moved to CodegenContext, reset per-function, includes function name prefix)
- interpreter.rs also uses `Arena::g().temp_id_counter` for return instance names

*** Proposed Fix
Apply similar pattern as ccodegen fix:
1. Add function name context to precomp (track current function being processed)
2. Reset counter when entering each function in `precomp_func_def`
3. Include function name in generated variable name: `_for_i_funcname_N`

*** Files to Modify
- src/rs/precomp.rs: Add counter reset in precomp_func_def, modify index_var_name format
- src/self/precomp.til: Same changes ported

*** Fix Details
Added two new fields to Context:
- `current_precomp_func`: Tracks the current function being processed (Option<String> in Rust, Str in TIL)
- `precomp_forin_counter`: Per-function counter for _for_i_ variable names

Modified three functions:
1. `precomp_declaration`: Sets function name and resets counter BEFORE processing function body
2. `precomp_struct_def`: Sets function name for struct method definitions (default values)
3. `precomp_forin`: Uses context fields instead of global counter, generates names like `_for_i_funcname_N`

Files modified:
- src/rs/init.rs: Added fields to Context struct
- src/rs/precomp.rs: Bug #40 fix in precomp_declaration, precomp_struct_def, precomp_forin
- src/self/init.til: Added fields to Context struct
- src/self/precomp.til: Same fixes ported

Test: src/test/deterministic.til

** Bug #52: Static buffer in ext.c til_i64_to_str caused string corruption
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Multiple to_str() calls before println showed wrong values
:STATUS: Fixed
:END:

*** Description
When multiple =to_str()= calls happened before =println= (e.g., printing two numbers),
they all showed the same value - the last one converted. This was because all calls
shared the same static buffer.

*** Root Cause
The =til_i64_to_str= function in =src/ext.c= used a static buffer:
#+BEGIN_SRC c
static char buf[32];  // SHARED BY ALL CALLS!
snprintf(buf, sizeof(buf), "%lld", (long long)v);
#+END_SRC

Each =to_str()= call returned a Str pointing to this same buffer. When a second
call happened, it overwrote the buffer, making both Strs show the second value.

*** Fix
Changed =til_i64_to_str=, =til_input_read_line=, and =til_run_cmd= in =src/ext.c=
to allocate memory with =malloc()= instead of using static buffers.

*** Regression Test
src/test/bug52.til - tests reading global variables inside for-in loops
with multiple =to_str()= calls to detect buffer sharing issues.

*** Notes
Discovered while investigating Bug #47 (NodeType corruption). The static buffer
issue explained why debug output showed wrong values, but Bug #47 itself is a
different issue that remains open.

** Bug #53: String functions missing null termination
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Garbage characters in string output, potential memory corruption
:STATUS: Fixed (no regression test - see notes)
:END:

*** Description
String functions =clone()=, =concat()=, =format()=, and =replace()= in str.til
allocated memory without +1 for the null terminator and didn't write the null
byte. This caused garbage characters when strings were printed via C's printf.

*** Root Cause
All four functions used =malloc(cap)= instead of =malloc(cap.add(1))= and didn't
call =memset= to write the null terminator at position =cap=.

*** Fix Applied (2025-12-19)
Changed all four functions in src/core/str.til:
- =clone()=: malloc(cap.add(1)), memset null at cap
- =concat()=: malloc(cap.add(1)), memset null at cap
- =format()=: malloc(cap.add(1)), memset null at cap
- =replace()=: malloc(new_len.add(1)), memset null at cap

*** Regression Test
No regression test was created because the bug cannot be reliably reproduced in
a unit test. The issue only manifests when malloc returns memory with non-zero
bytes at position =cap= (outside the allocated region without the fix). Modern
allocators typically return zeroed memory, making the bug appear to not exist
even without the fix.

The bug was discovered during Bug #47 investigation when "NodeType.?" garbage
appeared in debug output. This occurred because the heap was heavily fragmented
during ./bin/til execution, causing non-zero bytes to appear at string boundaries.

*** Files Modified
- src/core/str.til: Fixed clone, concat, format, replace functions

** Bug #41: mode liba not respected when file is imported
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Debugging, purity rules
:STATUS: Fixed
:END:

*** Description
When a file with `mode liba` is imported into another file (e.g., `mode cli`), the purity rules of the importing file apply instead of the imported file's mode. This means `func` definitions in `mode liba` files cannot call `print`/`println` when imported, even though `mode liba` is supposed to allow print in funcs for debugging.

*** Root Cause
The typer phase's `typer_import_declarations` function only saved and restored `context.path` when type-checking imported files, but did not save and restore `context.mode_def`. This caused the importing file's mode to be used for type checking the imported file.

*** Fix Applied (2025-12-17)
Two-part fix:

1. *Store mode during init phase* (src/rs/init.rs, src/self/init.til):
   - Added `imported_modes: HashMap<String, ModeDef>` to Context struct
   - In `init_import_declarations`, store the imported file's mode alongside its AST

2. *Use stored mode during type checking* (src/rs/typer.rs, src/self/typer.til):
   - In `typer_import_declarations`, retrieve stored mode and set `context.mode_def`
   - Save and restore both `context.path` AND `context.mode_def`

Also added `ModeDef.clone()` method to src/self/mode.til for proper mode copying.

*** Test Coverage
Regression test: src/test/bug41.til

*** Files Modified
- src/rs/init.rs: Added imported_modes field, store mode during import
- src/rs/typer.rs: Save/restore mode_def in typer_import_declarations
- src/self/init.til: Same changes ported
- src/self/typer.til: Same changes ported
- src/self/mode.til: Added ModeDef.clone() method
- src/test/bug41.til: Regression test
- src/test/bug41_liba_helper.til: Helper file for test

** Bug #39: Non-consecutive catches fail - second catch never executes
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-16
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

Related: Bug #34 (same underlying goto structure issue)

*** Description
When a function has multiple throw+catch pairs separated by code, only the first catch works. The second catch block never executes because the code generator's goto structure jumps past subsequent throw+catch pairs after the first catch completes.

#+BEGIN_EXAMPLE til
throw_a_maybe(true)  // throws ErrorA
after_a_ran = true   // correctly skipped
catch (err: ErrorA) { caught_a = true }

throw_b_maybe(true)  // throws ErrorB - NEVER EXECUTES!
after_b_ran = true
catch (err: ErrorB) { caught_b = true }  // NEVER EXECUTES!
#+END_EXAMPLE

*** Root Cause
The C code generator groups ALL catches at the end with shared labels:

#+BEGIN_SRC c
if (_status_A == 1) { goto _catch_A; }
if (_status_B == 1) { goto _catch_B; }
goto _end_catches;

_catch_A: { ... goto _end_catches; }  // BUG: jumps PAST throw_b_maybe!
_catch_B: { ... }
_end_catches:;
#+END_SRC

After catching ErrorA, ~goto _end_catches~ jumps past the second throw+catch entirely. The second throwing call never executes.

*** Proposed Fix
Instead of shared goto labels, use if-else blocks for each throw+catch pair:

#+BEGIN_SRC c
// First throw+catch
int _status_A = call_a();
if (_status_A == 0) {
    after_a_ran = true;
} else if (_status_A == 1) {
    // catch A body
}

// Second throw+catch - executes regardless of first catch
int _status_B = call_b();
if (_status_B == 0) {
    after_b_ran = true;
} else if (_status_B == 1) {
    // catch B body
}
#+END_SRC

*** Files to Modify
- src/rs/ccodegen.rs: emit_stmts, emit_throwing_call_with_goto
- src/self/ccodegen.til: Same changes ported

*** Test Coverage
Tests added in src/test/errors.til:
- test_non_consecutive_catches
- test_caller_callee_different_throws
- test_multi_throw_single_catch
- test_multi_throw_success

*** Fix Applied
Key changes to ccodegen.rs and ccodegen.til:

1. **Call ~next_mangled()~ inside the loop, not before** - Previously called once
   before the loop, giving all catches the same suffix. Now called for EACH catch,
   so multiple catches of the same error type get different labels.

2. **Store statement index with each catch** - ~all_catch_info~ tracks
   ~(stmt_index, type_name, label, temp_var, catch_block)~ to match throwing
   calls to their NEXT catch by position in the source.

3. **Emit catches inline with ~if(0) { label: }~** - Instead of grouping all
   catches at the end with ~goto _end_catches~, catches are emitted inline where
   they appear. The ~if(0)~ block is skipped in normal execution but ~goto~ can
   jump into it. Execution falls through after the catch body.

4. **Update ~local_catch_labels~ before each throwing call** - Clear and rebuild
   with only catches AFTER current statement position. Each throwing call now
   jumps to its correct NEXT catch, not always the first one.

5. **Only use immediate-catch optimization when ~func_level_catches.is_empty()~** -
   Prevents inline handling when the catch is also needed by earlier throwing calls
   (which need the label to be emitted).

Also added ~Map.clear()~ method to src/std/map.til, and removed unused
~get_variant_payload_type~ function from init.rs.

** Bug #38: Vec.get doesn't preserve enum payload values
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When storing enums with payloads in a Vec and retrieving them with Vec.get, the enum tag is preserved but the payload value is corrupted.

#+BEGIN_EXAMPLE til
PayloadEnum := enum {
    None,
    Number: I64,
    Text: Str,
}

p := PayloadEnum.Number(42)
mut items := Vec.new(PayloadEnum)
items.push(p)

mut out := PayloadEnum.None
items.get(0, out)

// Expected: out is PayloadEnum.Number(42)
// Actual: out is PayloadEnum.Number(2745) - payload corrupted
#+END_EXAMPLE

*** Root Cause
When passing an enum constructor like `PayloadEnum.None` to a Dynamic parameter (as in Vec.push),
the argument binding code incorrectly identified `PayloadEnum` as a type identifier (because TEnumDef
is a TType) and stored just the type name string instead of the actual enum value. This caused the
enum data to not be inserted into the function frame, resulting in memcpy reading from garbage memory.

The issue was in interpreter.rs at the Dynamic/Type parameter handling: the code checked if the
identifier resolved to a TType but didn't check if the expression had params (field access).
`PayloadEnum.None` has params (the `.None` access), so it should NOT be treated as a bare type.

*** Fix
Added a check for `current_arg.params.is_empty()` before treating an identifier as a type identifier.
This ensures enum constructors like `PayloadEnum.None` fall through to normal enum handling.

Files changed:
- src/rs/interpreter.rs: Added params.is_empty() check in Dynamic/Type handling
- src/self/interpreter.til: Same fix ported to self-hosted version

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_payload() (enabled)

** Bug #37: Vec.push with direct enum constructor doesn't store data correctly :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When pushing an enum value directly using a constructor expression (e.g., `colors.push(SimpleColor.Red)`), the data is not stored correctly in the Vec. However, pushing via a variable works correctly.

#+BEGIN_EXAMPLE til
SimpleColor := enum { Red, Green, Blue }

mut colors := Vec.new(SimpleColor)

// This FAILS - data is corrupted:
colors.push(SimpleColor.Red)

// This WORKS:
c := SimpleColor.Red
colors.push(c)
#+END_EXAMPLE

*** Root Cause (Found)
The bug was in the interpreter's handling of Dynamic parameters. When an enum constructor expression like `SimpleColor.Green` was passed to a Dynamic parameter:

1. The parser creates an Identifier("SimpleColor") node with params [Identifier("Green")]
2. The interpreter checked if "SimpleColor" was a type reference (TType)
3. Since SimpleColor is an enum type definition, it matched as TType
4. The code incorrectly treated it as a bare type reference, storing "SimpleColor" as a string
5. This caused to_ptr(value) to return the wrong arena offset

*** Fix (2025-12-15)
Added check for `current_arg.params.is_empty()` before treating an identifier as a type reference:

*interpreter.rs (line 1938):*
#+BEGIN_SRC rust
if current_arg.params.is_empty() {
    if let Some(sym) = context.scope_stack.lookup_symbol(id_name) {
        if let ValueType::TType(_) = &sym.value_type {
            // Only treat as type reference if params are empty
        }
    }
}
#+END_SRC

*interpreter.til (line 2022):*
#+BEGIN_SRC til
if current_arg.params.len().eq(0) {
    // Only treat as type reference if params are empty
}
#+END_SRC

Workarounds in std/map.til were also removed - now uses Vec.push() directly.

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_direct_push() (enabled)

** Bug #35: Special `_` variable does not allow repeated declarations :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
The special `_` variable (used for discarding return values) throws "already declared" errors when used multiple times in the same scope.

#+BEGIN_EXAMPLE til
// This should work (both values are discarded):
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)  // ERROR: '_' already declared
#+END_EXAMPLE

*** Fix (2025-12-14)
Modified type checker and code generator to special-case "_" declarations:

*Type checker (init.rs, init.til):*
1. In =declare_var()=: Skip the "already declared in this scope" check when name is "_"
2. In =init_context()= Declaration handler: Skip the "already declared" check when name is "_"

*Code generator (ccodegen.rs, ccodegen.til):*
1. In =emit_constant_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
2. In =emit_global_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
3. In =emit_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
4. In =emit_variadic_call()=: Skip variable declaration entirely for "_", just emit the function call (2026-01-04)

This approach:
- Allows multiple "_" declarations in the same TIL scope
- Generates unique C variable names (like =_tmp0=, =_tmp1=) to avoid C redefinition errors
- Evaluates the RHS expression for its side effects (return value is discarded)

*** Now Works
#+BEGIN_EXAMPLE til
// Both values are discarded - no error
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)
#+END_EXAMPLE

*** Test Coverage
- src/test/underscore.til: Tests multiple "_" declarations at both top-level and function scope, including variadic function calls

*** Files Modified
- src/rs/init.rs: declare_var, init_context
- src/rs/ccodegen.rs: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call
- src/self/init.til: declare_var, init_context
- src/self/ccodegen.til: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call

** Bug #33: for-in loops don't work with enum collections
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:FIXED: 2025-12-15
:END:

*** Description
The for-in loop syntax doesn't work when iterating over collections of enum values (e.g., Vec<ValueType>).

#+BEGIN_EXAMPLE til
// This fails:
for val: ValueType in vec_of_valuetypes {
    // ...
}
#+END_EXAMPLE

*** Root Cause
The for-in desugaring in precomp.rs creates code like:

#+BEGIN_EXAMPLE til
for _for_i in 0..collection.len() {
    mut val := ValueType()    // <-- Problem: no parameterless constructor
    collection.get(_for_i, val)
    // body
}
#+END_EXAMPLE

For structs, `StructName()` creates a default-initialized instance. But enums don't have a parameterless constructor - all variants require payloads (e.g., `ValueType.TCustom(Str)`, `ValueType.TFunction(FunctionType)`).

*** Fix Applied
Changed for-in desugaring to detect when the iteration type is an enum and generate
an appropriate placeholder value using the first variant:
- For variants without payload: `EnumType.FirstVariant`
- For variants with payload: `EnumType.FirstVariant(default_payload)`

The placeholder value is immediately overwritten by the get() call, so any valid
variant works as an initializer.

*** Files Changed
- src/rs/precomp.rs: Added build_default_value() helper and updated precomp_forin()
- src/self/precomp.til: TIL port with build_default_value_for_forin() and updated precomp_forin()
- src/test/forin_enum.til: Regression test
- src/tests.til: Added forin_enum.til to test suite
- src/test/run_cmd.til: Updated directory list (bots/ removed, c/ and out/ added)

*** Affected Code
- src/self/typer.til: Converted for-in loops over ValueType to while loops
- src/self/ccodegen.til: Same workaround applied

** Bug #32: TIL doesn't support chained field access + method calls
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
TIL doesn't support chained field access followed by method calls like:
#+BEGIN_EXAMPLE til
lexer.peek().token_type.eq(TokenType.Colon)
#+END_EXAMPLE

This causes parse errors like:
#+BEGIN_EXAMPLE
Expected '(' after method name 'token_type', found 'Dot'
#+END_EXAMPLE

Or type errors like:
#+BEGIN_EXAMPLE
Cannot call 'peeked.token_type', it is not a function, it is 'TokenType'
#+END_EXAMPLE

*** Fix
Parser now handles field access after function/method calls by using
Identifier("_") as a marker where params[0] holds the base expression
and params[1..] holds the field chain. Changes in parser, init, typer,
interpreter, and ccodegen (both Rust and TIL).

Tests added to src/test/structs.til.

*** Affected Code
- src/self/parser.til: parse_for_statement (workaround removed)

** Bug #36: Throwing functions in struct literal parameters not recognized :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Type checker correctness
:STATUS: Fixed
:END:

*** Description
When calling a throwing function inside struct literal named parameters, the compiler failed to recognize that the function throws and incorrectly reported that the error type is never thrown.

*** Fix
Modified =check_body_returns_throws= in typer.rs/typer.til to:
1. Handle =NamedArg= nodes inside function call arguments
2. Check arguments of struct/enum constructors (=Ok(None)= / =KeyNotFoundError= case)
3. Track thrown types from nested function calls in both cases

*** Changes
- src/rs/typer.rs: Added NamedArg handling and struct constructor argument checking
- src/self/typer.til: Ported same fix from Rust
- src/std/map.til: Removed workaround (can now inline clone() calls)
- src/self/init.til: Added throws declarations to clone() functions
- src/test/errors.til: Regression test (test_bug36)

** Bug #31: Switch on struct field with pattern matching fails :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-06
:FIXED: 2025-12-06
:IMPACT: Self-hosting, pattern matching
:STATUS: Fixed
:END:

*** Description
When using =switch= on a struct field that is an enum (e.g., =switch s.color=), pattern matching with payload extraction failed with "Enum definition for 'StructName' not found" error.

*** Example Problem
#+BEGIN_EXAMPLE til
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)
    switch s.color {
    case Color.Number(n): result = n  // FAILED: Enum definition not found
    case: result = 0
    }
}
#+END_EXAMPLE

*** Root Cause
Two issues in interpreter and arena code:

1. *Pattern matching code extracted only base identifier* (interpreter.rs:390-394):
   When processing =switch s.color=, the code only extracted "s" from =to_switch.node_type= instead of constructing the full path "s.color".

2. *get_enum didn't resolve field types* (arena.rs:764+):
   =get_enum= looked up the base variable's type instead of the field's type. For "s.color", it got =StructWithPayloadEnum= instead of =Color=.

*** Fix (2025-12-06)
*Rust side:*

1. *interpreter.rs*: Modified pattern matching code to construct full field path from to_switch expression params:
#+BEGIN_SRC rust
let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
    if !to_switch.params.is_empty() {
        let mut full_path = name.clone();
        for param in &to_switch.params {
            if let NodeType::Identifier(field_name) = &param.node_type {
                full_path.push('.');
                full_path.push_str(field_name);
            }
        }
        full_path
    } else {
        name.clone()
    }
} else { /* error */ };
#+END_SRC

2. *arena.rs*: Modified =get_enum= to use =get_field_type= for dotted paths:
#+BEGIN_SRC rust
let enum_type = if id.contains('.') {
    match ctx.get_field_type(id) {
        Ok(ValueType::TCustom(type_name)) => type_name,
        // ... error handling
    }
} else {
    // original lookup_symbol logic
};
#+END_SRC

3. *init.rs*: Added =get_field_type= function to resolve the ValueType for a field path.

*TIL side:*
- Ported same changes to interpreter.til, arena.til, and init.til

*** Test Coverage
- src/test/enums.til: =test_switch_on_struct_field= (simple switch on field)
- src/test/enums.til: =test_switch_on_struct_field_with_payload= (pattern matching with payload)

** Bug #30: ext_proc signature mismatch between TIL and Rust :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-03
:FIXED: 2025-12-03
:IMPACT: Type safety
:STATUS: Fixed
:END:

*** Description
=single_print= was incorrectly declared as variadic (=..Str=) in TIL, but =proc_single_print= in ext.rs expects exactly 1 argument.

*** Problem
#+begin_src til
// Wrong declaration (variadic):
single_print := ext_proc(args: ..Str);

// Both pass type check AND runtime (variadic wraps args into Array):
single_print("one")        // Works: Array with 1 element
single_print("one", "two") // Also "works": prints Array representation
#+end_src

*** Why It Wasn't Caught
Variadic parameters get wrapped into an Array before being passed to ext.rs. So =validate_arg_count= sees 1 argument (the Array), passing validation. The function then prints whatever =result.value= is - which would be the Array's string representation instead of the expected Str.

*** Fix (2025-12-03)
1. Changed declaration from variadic to single parameter in core.til:
#+begin_src til
// Correct declaration:
single_print := ext_proc(s: Str);
#+end_src

2. Added warning comment to =proc_single_print= in ext.rs referencing Bug #30.

*** Systemic Issue
The compiler cannot verify that ext_proc TIL declarations match their Rust implementations. Variadic wrapping bypasses =validate_arg_count= by passing all args as a single Array. This is an inherent FFI limitation.

** Bug #28: UFCS fails inside pattern match case bodies with bindings :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-02
:FIXED: 2025-12-02
:IMPACT: Self-hosting, type checking
:STATUS: Fixed
:END:

*** Description
UFCS method calls failed with "Could not find function definition" when inside pattern match case bodies that have bindings (e.g., =case Enum.Variant(binding):=).

*** Root Cause
The =check_body_returns_throws= function ran without proper scope tracking:
1. Pattern binding variables weren't declared in the scope
2. Local variables declared within case bodies weren't visible

*** Fix (2025-12-02)
Added proper scope management to =check_body_returns_throws= in =typer.rs=:

1. *Pattern binding scope*: When processing switch cases with pattern bindings, push a Block scope and declare the binding variable with its payload type (mirrors =check_switch_statement=).

2. *Variable declarations*: When processing Declaration nodes, infer the type from the initializer and declare the variable in the current scope (if not already declared).

Files modified:
- =src/rs/typer.rs= lines 767-825 (NodeType::Switch handler)
- =src/rs/typer.rs= lines 828-845 (NodeType::Declaration handler)

*** Test Coverage
- =src/test/ufcs.til=: =test_ufcs_struct_field_in_pattern_match=
- =src/test/enums.til=: =test_bug28_ufcs_push_in_binding=, =test_bug28_ufcs_len_in_binding=

All tests pass.

** Bug #29: Catch variable not accessible in arena :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-19
:FIXED: 2025-11-19
:IMPACT: Error handling, catch blocks
:STATUS: Fixed
:END:

*** Description
Caught error variable (=err=) not properly stored in execution arena. Accessing =err.msg= in catch block caused:
- Type error: "Undefined symbol 'err'"
- Runtime error: "base variable 'err' not found in arena_index"

Affected: =throw err.msg=, =return err.msg=, =msg = err.msg= - any field access on caught errors.

*** Fix (2025-11-19, commit 0024caa)
Properly register catch parameter in both interpreter and typer:
- =interpreter.rs=: Register base variable when propagating throws (line 3020) and in catch fallback (line 2438)
- =typer.rs=: Create temp_context with catch parameter before type-checking catch body (lines 665-692)

*** Test Coverage
- =src/test/errors.til=: =test_rethrow_error_field= (tests =throw err.msg=)
- =src/test/errors.til=: =test_rethrow_error_field_via_assign= (tests =msg = err.msg= then =throw msg=)

** Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*: ✅ FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
// ✅ Capture the return value
result := my_add(1, 2)

// ✅ Use as argument to another function
double(my_add(3, 4))

// ✅ Explicitly discard with _
_ := get_value()

// ✅ Procs don't return values, no capture needed
print_hello()

// ❌ ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

** Bug #27: Cannot inline Vec.new() as function argument :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-18
:FIXED: 2025-11-18
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
The TIL evaluator cannot handle inline Vec.new(Expr) calls when passed as arguments to functions. This requires creating a variable first instead of passing the expression directly.

*** Example Problem
#+BEGIN_EXAMPLE til
// Rust does (parser.rs:1180):
return Ok(Expr::new_explicit(
    NodeType::Pattern(pattern_info),
    Vec::new(),  // Inline Vec::new() works
    left.line,
    left.col
));

// TIL must do (parser.til:1326-1330):
empty_params := Vec.new(Expr)  // Create variable first
return Expr.new_explicit(NodeType.Pattern(pattern_info), empty_params, left.line, left.col)
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil eval ERROR: Struct argument must be an identifier or field access
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 1780-1796

When evaluating function calls with struct arguments, the evaluator checks if the parameter is marked as 'own'. For non-own struct parameters, it requires the argument to be an identifier or field access (not an arbitrary expression).

The 'params' parameter in Expr.new_explicit is declared as 'params: Vec' (not 'own Vec'), so inline expressions like Vec.new(Expr) are rejected.

*** Fix (2025-11-18)
Modified interpreter.rs to allow non-identifier expression arguments for struct parameters:

1. Lines 1778-1782: For field access chains with expressions, use result_str
2. Lines 1787-1795: For simple expressions (like Vec.new()), use result_str
3. Lines 1899-1904: For non-Identifier node types, allocate struct and copy fields from result_str

The key insight: when an expression is evaluated (like Vec.new(Expr)), the result
is allocated in the arena and result_str contains the identifier. We can use this
to copy the struct to the parameter, just like we do for identifier arguments.

*** Now Works
#+BEGIN_SRC til
// Can inline Vec.new(Expr) directly as argument
return Expr.new_explicit(NodeType.Pattern(pattern_info), Vec.new(Expr), left.line, left.col)
#+END_SRC

*** Previous Workaround (No Longer Needed)
#+BEGIN_SRC til
// Old workaround - create variable first
empty_params := Vec.new(Expr)
return Expr.new_explicit(..., empty_params, ...)
#+END_SRC

** Bug #26: Nested struct corruption in Vec/Map :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-17
:FIXED: 2025-11-17
:IMPACT: Data integrity, collection storage
:STATUS: Fixed
:COMMIT: ea8cd2b
:END:

*** Description
When structs containing nested structs (like Vec, Map, List) were stored in collections, the nested structs were allocated separately instead of inline, causing memory corruption.

*** Fix
Modified insert_struct_at_offset in init.rs to accept optional existing_offset parameter, allowing nested structs to be allocated inline within parent's memory block.

*** Commit
ea8cd2b: Fix Bug #26: nested struct corruption in Vec/Map

** Bug #25: Field offset refactor breaks typer method resolution :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-13
:FIXED: 2025-11-13
:IMPACT: API consistency, method resolution
:STATUS: Fixed - uniform len() API implemented
:END:

*** Description
The typer fails to find I64.eq method when chaining method calls on struct field access (e.g., `s.items.len.eq(0)`). This was discovered during field offset refactoring work but the root cause was different.

*** Example Problem
#+BEGIN_EXAMPLE til
// In ufcs.til line 300 - this WORKS:
items_len := s.items.len

// In ufcs.til line 304 - this FAILS:
len_check := s.items.len.eq(0)  // Error: "Could not find function definition"
#+END_EXAMPLE

The field access works, but method resolution on the result fails!

*** Root Cause (FOUND!)
The real issue was NOT the field offset refactor, but an API inconsistency:
- Vec, List, and Array had `len` as a FIELD instead of a METHOD
- When the typer tried to resolve `s.items.len.eq(0)`, it saw `.len` as a field access
- Field accesses return `auto` type (requiring type inference)
- The typer couldn't properly infer the type for chained method calls
- Result: "Could not find function definition" for `.eq(0)`

This became apparent when `s.items.len` was accessed - it worked as a field, but the moment you tried to call a method on the result, type resolution failed.

*** Solution (2025-11-13)
Implemented uniform len() API across all collection types:

1. **Renamed internal fields**: `len` → `_len` (cap kept as-is)
2. **Added uniform methods**:
   - `len()` returns element count (_len)
   - `size()` returns byte size (len * type_size)
3. **Implemented for**: Vec, List, Array (src/core/core.til)
4. **Updated all code** to use `.len()` method calls:
   - Core library: lexer.til, parser.til, typer.til, interpreter.til
   - Test files: ufcs.til, args.til, arrays.til, dynamic_arrays.til, lists.til, maps.til, mut_test.til, variadic.til
5. **Updated interpreter**: init.rs to look for `._len` field offset
6. **For-loop workaround**: Store `len()` in local variable (e.g., `mut args_len := args.len()`)

*** Now Works
#+BEGIN_EXAMPLE til
// ✅ All these patterns now work correctly:
items_len := s.items.len()
len_check := s.items.len().eq(0)
if i.lt(s.items.len().add(5)) { }
comparison := i.lt(e.params.len())
#+END_EXAMPLE

*** Test Coverage (Regression Prevention)
The existing test file `src/test/ufcs.til` provides comprehensive regression coverage:

**test_bug10_fixed()** (lines 296-317):
- Line 304: `len_check := s.items.len().eq(0)` - EXACT failing pattern
- Line 309: `comparison := i.lt(s.items.len().add(5))` - Chained method calls
- Line 314: `name_len := name.len()` - String len() method

**test_bug10_parser_patterns_fixed()** (lines 320-341):
- Line 334: `len_is_zero := e.params.len().eq(0)` - Another instance of failing pattern
- Line 338: `len_plus_five := e.params.len().add(5)` - Arithmetic on method result

These tests run in the standard test suite and will catch any regression
that breaks chained method calls on field access. All tests pass (exit code 0).

*** Commits
- 27dc3ae: Fix Bug #25: Implement uniform len() API for Vec, List, and Array
- 1444a8b: Complete len() API standardization - fixes Bug #25

** Bug #24: Variable Declarations Share Arena Offsets Instead of Copying :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Fixed - mut declarations now copy
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Fix Applied

**Design Decision**: Only mut declarations create copies. Non-mut declarations share offsets (read-only aliases).

**Implementation** (src/rs/interpreter.rs lines 923-935):
- **mut declarations**: Call insert_struct() + copy_fields() to create independent copy
- **non-mut declarations**: Share arena offset (efficient, type checker enforces immutability)

**Result**:
#+BEGIN_SRC til
mut dup := original  // Creates independent copy
dup := original      // Shares offset (read-only alias)
#+END_SRC

This design aligns with Mojo's ownership model:
- mut = mutable copy (prevents aliasing)
- default = reference (efficient, safe with type checker)
- Future: 'own' keyword for ownership transfer

See doc/ownership.org for full design analysis and Mojo comparison.

**All tests pass**, including test_declaration_creates_copy (args.til:484)

** Bug #24: Struct Field Access Returns Copy Instead of Reference :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-18
:IMPACT: Data structure mutation, memory management
:STATUS: Fixed - Pass-by-reference for field access
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Fix Applied (2025-11-18)

Bug #24 was fixed as part of implementing pass-by-reference for field access parameters and fixing Bug #26.

**Three-part solution:**

*Fix 1: Inline nested struct allocation* (init.rs:1510-1625)
- Modified insert_struct_at_offset to accept optional existing_offset
- Nested structs now allocated inline within parent's memory block
- Previously: nested structs allocated separately, causing corruption

*Fix 2: Pass-by-reference for field access parameters* (interpreter.rs:1820-1872)
- Extended pass-by-ref to field access like `self.type_names.push(...)`
- Share arena offset instead of allocating and copying
- Register field symbols for UFCS method resolution
- Previously only simple identifiers used pass-by-ref

*Fix 3: Zero-copy return value transfers* (interpreter.rs:970-985)
- Detect temporary return values and share offset instead of copy
- mut x := func() now zero-copy (transfers ownership)
- Only copy when source is real variable (preserves Bug #25 fix)

**Result:**
The workaround pattern is no longer needed. Direct field mutations now work:

#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  // ✅ NOW WORKS - modifies via reference!
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

**Test Coverage:**
- src/test/tmp/test_bug24.til - Comprehensive test verifying direct field mutations
- All existing tests pass with the fix

**Note on Workarounds:**
While the bug is fixed, existing workarounds (copy-modify-reassign pattern) can remain for now
as they are functionally equivalent. Workarounds exist in:
- src/core/core.til (List.push, List.set, List.pop, etc.)
- src/core/lexer.til
- src/core/parser.til
- src/core/std.til (potentially)
They can be removed in a future cleanup pass to simplify the code and potentially improve performance.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` ✅
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` ✅
- Throw from regular function ✅

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` ❌

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // ✅ Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
