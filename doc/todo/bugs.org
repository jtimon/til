#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New bugs use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new bugs at the top of Active Bugs section.
# BOT: When fixed, move to the top of Fixed Bugs section in doc/todo/fixed.org.

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #171: make.til doesn't detect when it needs to rebuild itself
:PROPERTIES:
:DISCOVERED: 2026-02-11
:END:

Changing make.til requires `make clean` before `make benchmark` because the
build system doesn't detect that make.til itself changed. The compiled
`bin/rs/make` binary is stale but gets reused.

** Bug #170: Scope-exit deletion for local variables
:PROPERTIES:
:DISCOVERED: 2026-02-11
:IMPACT: Memory leak -- locals only deleted at function end (or never if catch blocks exist)
:STATUS: Open -- two approaches failed 2026-02-11, see implementation notes
:RELATED: Bug #165 (memory leak), Bug #159 (shallow copies), Issue #117 (ASAP destruction)
:END:

*** Problem
The garbager deletes local mut variables at function end only (and skips them
entirely if the function has catch blocks). Locals declared in inner scopes
(if/while/for) leak until function end or forever. copy/own params get ASAP
deletion after last use, but locals don't.

*** Design: unified scope-exit deletion
One concept: *delete at scope exit*. Every deletable variable gets deleted when
its declaring scope ends. All current deletion triggers are specific cases of
scope exit:

| Trigger                  | What it is                                    |
|--------------------------+-----------------------------------------------|
| ~}~ of if/while/for      | Scope exit for variables declared inside       |
| ~return~                  | Scope exit for entire function                 |
| ~throw~                   | Scope exit for entire function                 |
| ~own~ arg call            | Early scope exit for that one variable         |

Reverse declaration order within a scope naturally handles the container-
outlives-alias problem: ~elem := vec.get(0)~ is declared after ~vec~, so
~elem~ is deleted first, then ~vec~.

*** What the garbager needs to do

**** For each scope boundary (~}~ of if/while/for/block):
Insert ~Type.delete(var)~ for each deletable mut variable declared in that
scope, in reverse declaration order. Respect ~dont_delete~ as today.

**** For ~return~ statements:
Insert deletes for ALL in-scope deletable mut variables before the return.
Reverse declaration order, innermost scope first.

**** For ~throw~ paths:
Same as return -- delete everything in scope before the throw. But only
variables guaranteed to have been initialized (declared before the throw
point, not conditionally).

**** For ~own~ transfers:
Already handled: variable is consumed, removed from deletion candidates.

*** Open questions

1. *Const locals:* Should const locals also get scope-exit deletion (relying
   on reverse declaration order for safety), or only mut locals for now?
   Const locals are more likely to be aliases (field extractions), but reverse
   declaration order may handle that. Need to verify with concrete examples.

2. *Catch blocks:* Keep current conservative approach (skip all deletion if
   any catch exists) or implement smarter analysis (only skip variables whose
   initialization could be skipped by a throw)? Smarter is more complex but
   covers more functions since many functions have catch blocks.

3. *Scope tracking in garbager:* Currently does a flat scan of function body.
   Needs to understand nesting (if/while/for bodies are nested Expr params).
   The garbager already recurses into bodies for other transforms -- need to
   check if scope info is available or needs threading through.

4. *ccodegen impact:* If garbager inserts scope-exit deletes into the AST,
   ccodegen just emits them -- probably no ccodegen changes needed. Verify.

5. *Reassignment:* ~mut x := Str.new("a"); x = Str.new("b")~ -- the old value
   leaks. Scope-exit deletion only frees the final value. The old value needs
   clone-on-assign + delete-old-value semantics (Bug #159 territory, not this
   bug).

*** Implementation attempt 2026-02-11 -- two approaches failed

**** Attempt 1: ASAP deletion for top-level locals
Changed end-of-function locals to use ~find_last_use_index()~ (same as
copy/own params). Result: 89/92 tests failed with ~free(): invalid pointer~.

Root cause: shallow-copy aliasing (Bug #159). Pattern:
#+begin_example
mut tokens := lex("mode safe_script")
mut first_token := Token()
tokens.get(0, first_token)   // shallow copy -- first_token aliases tokens[0]
// ... more code using first_token ...
// ASAP: Vec.delete(tokens) inserted here (last direct reference to "tokens")
// ... first_token.text is now dangling -- freed with tokens
#+end_example

~Vec.get()~, ~Array.get()~, field access -- all do shallow memcpy. The
extracted value aliases heap pointers in the container. Deleting the container
ASAP frees the shared heap data while the alias is still live.

The original code comment was correct:
: // locals: at function end (shared offsets mean locals can alias).

ASAP deletion is only safe for copy/own params because the garbager inserts
~Type.clone()~ for those, giving them independent heap data.

**** Attempt 2: Collect inner-scope locals, delete at function end
Added ~collect_declarations_recursive()~ to scan Body nodes inside
if/while/for and add their declarations to the function-end deletion list.
Result: 69/92 tests failed with signal 11 (SIGSEGV).

Root cause: conditional initialization. Pattern:
#+begin_example
func foo(x: I64) {
    if x > 0 {
        mut thing := SomeStruct()   // only initialized when x > 0
    }
    // garbager inserts: SomeStruct.delete(thing)  -- SIGSEGV when x <= 0
}
#+end_example

Inner-scope variables are only initialized when the scope executes. Inserting
unconditional ~delete()~ at function end crashes when the scope was skipped.

**** What would work: scope-exit deletion in the Body handler
The correct approach: insert ~Type.delete(var)~ at the end of the BODY node
where the variable was declared, not at function end. This guarantees the
variable is initialized (we're inside the scope that declared it).

Still has the shallow-copy aliasing risk (Bug #159), but no worse than
current function-end deletion for top-level locals. The aliasing risk is
mitigated by reverse declaration order: if ~elem := vec.get(0)~ is declared
after ~vec~, then ~elem~ is deleted first, then ~vec~.

Needs:
- Modify ~garbager_recursive~ Body handler to scan for declarations and
  append deletes at body end
- Per-scope ~dont_delete~ / ~own_transfer~ filtering (or inherit from parent)
- Per-scope ~has_any_catch~ check
- Name collision avoidance: TIL has flat namespace, helper functions must not
  collide with ~collect_declarations_recursive~ in ccodegen.til

Also learned: name ~collect_declarations_recursive~ already exists in
ccodegen.til. TIL's flat namespace causes collision. Any new helpers in
garbager.til need prefixed names (e.g., ~garbager_collect_decls~).

** Bug #166: Containers duplicate type info already in Ptr
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Wasted memory, inconsistency, blocks clean ownership model
:STATUS: Part 1 done, Part 2 deferred
:RELATED: Bug #159 (shallow copies), Issue #151 (pointer syntax)
:END:

Vec, Array, and List store ~type_name~ and ~type_size~ fields that duplicate
the ~elem_type~ and ~elem_size~ already in their ~Ptr~ field.

Affected containers:
- ~Vec~ (vec.til:11-12): ~type_name: Str~, ~type_size: I64~
- ~Array~ (array.til:11-12): ~type_name: Str~, ~type_size: I64~
- ~Set~ (set.til:6-7): ~elem_type_name: Str~, ~elem_type_size: I64~ -- DONE
- ~Map~ (map.til:39-42): 4 fields -- DONE (partial, see below)
- ~HashMap~ (hashmap.til:27-30): 4 fields
- ~List~ (list.til:15-16): ~type_names: Vec~, ~type_sizes: Vec~ (per-element!)

~Ptr~ already has (ptr.til:11-12):
- ~mut elem_type: I64~ (pointer to C string type name)
- ~mut elem_size: I64~ (bytes per element)

When these fields were added to Ptr, the originals in containers should
have been removed. Fix: remove type_name/type_size from containers, access
them through their Ptr (or Vec's Ptr) instead. E.g. ~self.keys.ptr.elem_size~
instead of ~self.key_type_size~. May need a helper to convert elem_type
(raw C string pointer) back to Str for cases that need it.

Array is a special case -- it uses ~mut ptr: I64~ (raw integer) instead of
~Ptr~. It should be migrated to use ~Ptr~ as well.

Future direction: containers like Map, HashMap, Set, List, and Arena currently
use Vec internally but could use Ptr directly instead. They'd manage their own
growth logic (they used to before Vec was introduced) but would have less
indirection and smaller struct sizes. Vec is essentially Ptr + len + cap +
growth, and some containers (e.g. Map with sorted binary search) already have
custom growth/insertion logic that doesn't benefit from Vec's abstraction.

*** Progress

**** Step 1: Set (DONE)
Removed ~elem_type_name~ and ~elem_type_size~ from Set struct.
Reads go through ~self.elements.type_name~ and ~self.elements.ptr.elem_size~.
All 98 tests pass. Committed at ece4fa89.

**** Step 2: Map (DONE - partial)
Removed ~key_type_name~, ~key_type_size~, ~value_type_name~, ~value_type_size~
from Map struct. Type name reads go through ~self.keys.type_name~ /
~self.values.type_name~. However, type SIZE reads use ~self.keys.type_size~ /
~self.values.type_size~ (Vec's field), NOT ~self.keys.ptr.elem_size~ (Ptr's
field). Map's own 4 fields are removed, but it still depends on Vec.type_size.

***** Why Set can use ptr.elem_size but Map cannot

Set.insert uses a copy-local-modify-copy-back pattern:
#+begin_src til
mut elems_arr := self.elements    // copy Vec to local
elems_arr.push(elem)             // push allocates new Ptr with elem_size set
self.elements = elems_arr        // copy back entire Vec including updated Ptr
#+end_src

The copy-back writes the entire Vec (with its updated Ptr that has elem_size
set by ~_alloc_ptr~) back into ~self.elements~.

Map.insert calls methods directly on chained fields:
#+begin_src til
self.keys.insert_at(search.index, key)
#+end_src

The interpreter passes ~self.keys~ as ~mut self~ to ~insert_at~, which
allocates a new Ptr and stores it in ~self.ptr~. The Vec's ~_len~ and
~ptr.data~ propagate back correctly (Map works), but ~ptr.elem_size~ reads
as 0 when accessed later via ~self.keys.ptr.elem_size~. This causes
~memcmp(..., 0)~ to always return 0 (match), breaking binary search.

Tested empirically: ~ptr.elem_size~ is 0 in both rs_interpreted and
rs_compiled modes for Map. Set works because the explicit copy-back ensures
the complete Ptr (including elem_size) survives.

When Vec.type_size is removed (later step), Map will need to be revisited.
Options: (a) adopt the copy-local-copy-back pattern like Set, (b) fix the
interpreter's chained field propagation, or (c) set ptr.elem_size in Vec.new
itself (not just in _alloc_ptr).

**** Step 3: Vec.insert_at _alloc_ptr fix (DONE)
Vec.insert_at used ~Ptr.new_by_size()~ directly instead of ~self._alloc_ptr()~
when growing, so the new Ptr never got elem_type/elem_size set. This is the
root cause of Map failing with ptr.elem_size (insert_at is Map's growth path).
Fixed + regression test added.

**** Remaining steps (Part 1: container-level dedup, relying on Vec.type_size)

Attempted to set ptr.elem_size in all Vec constructors (INIT_CAP=1) so
containers could use ptr.elem_size everywhere. Failed: bare ~Vec()~ struct
literals (used as default field values in Map, HashMap, etc.) have type_size=0,
and cloning such Vecs caused OOM in til_interpreted (compounding with Bug #165
memory leak). Abandoned INIT_CAP=1 approach.

Plan: Part 1 removes container-level duplication while relying on Vec.type_size.
Part 2 (future) removes Vec's own type_size once a proper __init__ mechanism
exists (see future.org) or Map/HashMap use Ptr directly.

- Step 4: Fix Set to use type_size instead of ptr.elem_size, remove expensive
  copy-local-copy-back pattern. Make Set work like Map (direct chained calls).
  DONE. The generated C confirms ~til_Vec_clone~ calls are gone from
  Set.insert/remove/contains (previously ~mut elems_arr := self.elements~
  compiled to a full Vec clone on every call). However, benchmarks show no
  improvement (slightly worse within noise). Likely the garbager is inserting
  clones elsewhere for the ~self.elements~ parameter passing, replacing the
  explicit copy with implicit ones. Needs further investigation (Bug #165
  territory -- shallow copy overhead).
- Step 5: HashMap (same pattern as Map -- remove 4 fields, use type_size). DONE.
- Step 6: Remove Vec.new_from_type_info -- SKIPPED. Callers (Set, Map, HashMap)
  still need it because they receive Type params and call type_as_str/size_of.
  Can't use Vec.new(Type) through nested calls. Leave for Part 2.

Part 1 DONE. Container-level duplication removed from Set, Map, HashMap.

Part 2 (future, blocked on __init__ or Map-uses-Ptr-directly):
- Vec -- remove type_size, use ptr.elem_size everywhere.
  Update eval_heap.rs + eval_heap.til for new Vec layout.
- Array -- remove type_name/type_size, migrate ptr from I64 to Ptr.
  Update eval_heap.rs + eval_heap.til for new Array layout.
- List (needs investigation, heterogeneous)

** Bug #169: Get rid of memcmp
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic correctness -- memcmp compares raw bytes (pointers, padding) not logical values
:STATUS: Step 1 done (pure TIL memcmp)
:RELATED: Bug #166 (container type info duplication, memcmp elem_size=0 breakage)
:END:

*** Problem
Containers (Vec, Set, Map, HashMap) use ~memcmp~ to compare elements. This
compares raw struct bytes -- meaning pointer values, padding bytes, and all.
Two structs with identical logical content but different pointer addresses
(e.g. two Str with same text but different allocations) will compare as
NOT equal. Creates interpreted/compiled divergence.

*** Plan
- Step 1: Replace ext_func memcmp with pure TIL implementation (DONE)
  Removed C/Rust/TIL-interpreter implementations. memcmp is now a regular
  TIL function in mem.til using byte-by-byte comparison via memcpy+to_ptr.
- Step 2: Add typed equality (.eq()) to containers
- Step 3: Migrate containers from memcmp to typed equality
- Step 4: Remove memcmp entirely (or keep for low-level use only)

** Bug #165: Compiled TIL binary leaks 200-800x memory vs Rust
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Compiled TIL programs use 200-800x more memory than equivalent Rust interpreter
:STATUS: Blocked by Bug #159 (shallow copies prevent safe ASAP deletion)
:RELATED: Bug #159 (shallow copies), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame copy leak), Issue #117 (ASAP destruction)
:END:

*** Description
The compiled TIL binary (generated C code) leaks memory massively compared to the
Rust interpreter. Clone/delete imbalance: ~2500 Str clones vs ~1850 Str deletes in
generated C code, leaving ~650 leaked Str allocations per test run.

*** Failed attempt: ASAP deletion for named locals (wip165 branch)
Branch ~wip165~ has 2 commits ahead of master implementing ASAP deletion for named
locals with alias/escape detection:

**** Rules implemented
- Rule A (alias detection): Skip delete if variable was assigned from another local
  (e.g., ~x := y~ -- deleting x would corrupt y's data via shared pointer)
- Rule B (escape detection): Skip delete if variable was passed to a function after
  its last read (value may have escaped into another data structure)
- Rule C (owned return): Only delete variables assigned from known-allocating functions
  (constructors, .new(), .clone(), .to_str(), .format(), .concat(), etc.)

**** Results
- All 98 tests pass in all 4 modes
- Zero memory improvement -- clone/delete ratio unchanged
- Root cause: most leaks come from shallow copies (memcpy of structs with heap
  pointers), not from missing deletes of named locals

**** Why ASAP deletion doesn't help
The ~650 leaked Str allocations come from:
- Function return values (shallow memcpy at call site)
- Container operations (get/push/set all use copy_to_dynamic/copy_from_dynamic)
- Temporary expressions (_tmp_ variables holding intermediate results)

None of these are named locals that ASAP deletion can target. The fundamental
problem is Bug #159: shallow copies create hidden aliases that make it unsafe
to delete anything without risking double-free.

*** Blocked by
Bug #159 must be resolved first. Until shallow copies are eliminated, any
deletion strategy risks double-free on aliased heap pointers.

** Bug #159: Shallow copy semantics for structs with Ptr/Vec fields (REOPENED)
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Memory corruption, prevents ASAP deletion, root cause of memory leaks
:STATUS: Open -- clone-after-get for container out-params, shallow copies remain elsewhere
:RELATED: Bug #165 (memory leak blocked by this), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame leak)
:END:

*** Description
When doing =mut cloned := original=, the interpreter used =copy_fields= which did
a byte-level copy. For structs containing Ptr or Vec fields, both the original and
clone shared the same underlying memory.

*** What was done (2026-02-07, originally declared fixed)
Removed =copy_fields= (shallow copy) from the interpreter. Replaced with:
1. Garbager inserts =Type.clone()= calls for struct-typed identifier args (4 sites)
2. Interpreter uses offset binding or memcpy instead of copy_fields

Steps completed:
- Step 1: preinit generates clone/delete methods
- Step 2: Dynamic type info added to Ptr
- Step 3: mut declarations (clone + offset binding)
- Step 4: Function copy params (clone + offset binding)
- Step 5: Struct literal fields (memcpy)
- Step 6: Assignment statements (memcpy)
- Step 7: Nested member assign + own params (memcpy), copy_fields deleted
- Step 8: Own params simplified to pure offset binding

Dead code removed: =copy_fields=, =SavedOffsets=, =insert_struct_instance_into_frame=,
=EvalArenaMapping= import.

Test: src/test/bug159.til (passes all 4 modes)

*** What remains -- shallow copies still present
The interpreter fix only addressed =copy_fields=. Shallow copies remain throughout
the codebase via memcpy in generated C code and core library operations.

**** 1. ccodegen -- Function return values
- =*_ret = value;= (struct assignment = implicit memcpy in C)
- =var = _ret_X;= (call site receives shallow copy of return value)
- Every function returning a struct creates a shallow copy at the call site

**** 2. src/core/ptr.til -- Raw memcpy operations
- =copy_to_dynamic= (line 108): =memcpy(to_ptr(dest), self.data, size)=
- =copy_from_dynamic= (line 103): =memcpy(self.data, to_ptr(src), size)=
- =copy_to= (line 93): =memcpy(dest.data, self.data, size)=
- =copy_from= (line 89): =memcpy(self.data, src.data, size)=
- =dereference= (line 113): =memcpy(to_ptr(dest), self.data, size)=
- =Ptr.clone= (line 72): copies struct bytes, shared heap pointer

**** 3. src/core/vec.til -- Collection operations using copy_to/from_dynamic
- =get= (line 127): =src.copy_to_dynamic(T, self.type_size)= -- out-param
- =push= (line 112): =dest.copy_from_dynamic(value, self.type_size)=
- =set= (line 150): =dest.copy_from_dynamic(value, self.type_size)=
- =clone= (line 189): =cloned.ptr.copy_from(self.ptr, ...)= -- byte copy of all elements
- =extend= (line 225): =dest.copy_from(src, self.type_size)=
- =extend_with= (line 258): =dest.copy_from_dynamic(value, self.type_size)=
- =contains= (lines 272/274): =src.copy_to_dynamic= + =memcpy= for comparison
- =remove= (line 299): =dest.copy_from(src, ...)= -- shift elements left
- =insert_at= (lines 340/346): shift + =dest.copy_from_dynamic(value, ...)=
- =to_str= (line 362): =src.copy_to_dynamic(elem, ...)= for string building
- =split_off= (line 391): =result.ptr.copy_from(src, ...)=
- =pop= (line 161): via =self.get(...)= -- shallow copy

**** 4. src/core/set.til -- Uses Vec internally
- =insert= (lines 42/44): copy_to_dynamic for comparison
- =remove= (lines 78/80/97): copy_to_dynamic for comparison
- =contains= (lines 120/122): copy_to_dynamic for comparison
- =get= (line 152): copy_to_dynamic for retrieval

**** 5. src/core/array.til -- Direct memcpy
- =get= (line 54): =src.copy_to_dynamic(dest, self.type_size)=
- =set= (line 80): =dest.copy_from_dynamic(value, self.type_size)=
- =clone= (line 99): =cloned_ptr.copy_from(self.ptr, ...)=

**** 6. ccodegen -- enum_get_payload
- Shallow memcpy of enum payload data

**** 7. ccodegen -- create_alias directive
- Intentional shallow copy (aliases by design, dont_delete protects it)

*** Step 9: Clone-after-get for container out-params (2026-02-11)
Container =get()= and =pop()= methods extract elements via =copy_to_dynamic=
(memcpy), creating shallow copies that alias the container's internal heap
pointers. The garbager now inserts =elem = ElemType.clone(elem)= after every
container get/pop call where the out-param is a local variable with a deletable
struct type.

Whitelist of affected methods:
- =Vec.get=, =Vec.pop=, =Array.get=, =Set.get=
- =Map.get=, =HashMap.get=, =List.get=, =List.pop=

New garbager functions:
- =build_clone_assignment_expr= -- builds AST for =var = Type.clone(var)=
- =detect_shallow_copy_outparam= -- checks if stmt is a whitelisted get/pop call
- =insert_clone_after_get= / =process_stmt_for_clone_after_get= -- inserts clones
  after matching calls, recursing into nested Body/If/While/For/Switch nodes

Step 2.7 in FuncDef handler runs after local_types is built, before Step 3
(delete candidate collection). The =local_types= map was moved earlier (from
Step 4 to after Step 2.5) so it's available for both clone-after-get and
own-transfer detection.

All 92 tests pass in all 4 modes.

*** Parameter passing semantics (unchanged)
| Mode      | Semantics                                      |
|-----------+------------------------------------------------|
| (default) | By reference - share offset                    |
| =mut=     | By reference - share offset                    |
| =own=     | Ownership transfer - share offset, remove src  |
| =copy=    | Deep copy - garbager inserts clone, bind result |

** Issue #152: Migrate doc/todo files to numbered issue system
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Documentation cleanup, better tracking
:STATUS: Open
:END:

*** Description
Several doc/todo files use older TODO/checklist systems instead of the numbered
issue tracking system. These should be reviewed and migrated.

*** Files Using Numbered System (done)
- bugs.org - Bug #N format
- future.org - Issue #N format
- post.org - Issue #N format
- os.org - Issue #N format
- optimizations.org - Optimization #N format

*** Files to Migrate

**** post_old.org (31KB) - partial extraction done
Remaining items to extract or delete:
- List/Tuple support
- Negative number literals
- Guards for pattern matching
- Default keyword for switch
- Struct literals
- Cast operations
- Operator overloading
- Type checking edge cases
- safe_script mode
- pure mode
- Performance optimizations
- Memory management
- Better error messages
- Code quality improvements
- Memory error handling
- More test cases
- Improve documentation
- Other number types
- Unset default values in structs
- Better import caching

Likely duplicates to verify:
- Closures -> Issue #91 (First-Class Functions)
- Macros -> Issue #88 (Macro Support)
- Error handling -> Bug #98 (ext_proc error types) - FIXED
- Code quality -> Issue #142 (Context Error Helpers)

**** wish.org (1.6KB) - wishlist/checklist
- Forbidden keywords with helpful error messages
- Dynamic error messages with user identifiers

**** clone.org (6.3KB) - task tracker
- 368 missing .clone() calls to port from Rust to TIL
- 6/14 files done

**** introspection.org (6.4KB) - design doc
- Runtime introspection system design
- has_const/has_field implemented, more TODO

**** special.org (8.6KB) - technical debt catalog
- Catalog of Rust special cases for primitive types
- Reference doc, may not need issues

**** mandatory.org (7.8KB) - completed feature
- clone/len/size requirements - all phases complete
- Could be moved to doc/ as reference

**** pre.org - DONE (migrated to fixed.org as #pre, file deleted)

**** pass_by_ref.org - DONE (content already in doc/ownership.org, file deleted)

**** 108.org (11.8KB) - deep dive doc
- Detailed design for Issue #108 (Namespaces)
- Supplement to future.org entry

**** Obsolete files (can delete)
- shadow.org (3KB) - obsolete plan, Bug #65 already fixed
- byref_plan.org, byref-params-plan.md - likely obsolete
- attempt_const.org - likely obsolete attempt
- wip_offsets.org - likely obsolete WIP
- scope.org, scope_refactor_prep.md - likely obsolete
- precomp_overhaul.org - likely obsolete

**** Unchecked files
- dry.org (21KB)
- techdebt.org (22.8KB)
- self_hosting.org (24KB)
- self.md (15KB)

*** After Migration
Delete or archive files once content is properly tracked in numbered issues.

** Bug #144: for-in loops iterate by copy instead of by reference
:PROPERTIES:
:DISCOVERED: 2026-01-27
:IMPACT: Performance overhead, breaks pointer identity assumptions
:STATUS: Partial - 3-arg create_alias directive implemented, performance gain modest
:RELATED: Bug #143 (hoisted_exprs identity depends on this), Issue #117 Step 9.3
:END:

*** Description
For-in loops copy each element via ~get()~. With Step 10 (auto-delete), the
local copy's ~delete()~ would corrupt the container (double-free).

*** Current State (2026-02-09)
3-arg ~create_alias(item, MyStruct, addr)~ compound directive implemented.
Eliminates the wasteful default ~MyStruct()~ construction and separate
~dont_delete~ call. Desugared non-primitive for-in is now just:
#+BEGIN_SRC til
_ref_forin_N := get_by_ref(vec, _for_i_func_N)
catch (_err_forin_N: IndexOutOfBoundsError) { panic(loc(), _err_forin_N.msg) }
create_alias(item, MyStruct, _ref_forin_N.data)
#+END_SRC

Every phase with scope tracking recognizes create_alias as a variable
declaration: init, typer, ufcs, precomp, ccodegen, interpreter (ext.rs).

All 98 tests pass in all 4 modes. Performance improvement is modest (~0.6%):
| Mode             | Before (9aadaed1) | After   | Delta  |
|------------------+--------------------+---------+--------|
| rust interpreted | 160.274s           | 159.4s  | -0.9s  |
| til interpreted  | 611.296s           | 607.5s  | -3.8s  |
| Total            | 805.389s           | 800.7s  | -4.7s  |

Expected bigger gains for for-in over large/deep structs in src/self.
Possible reasons the gain is small:
- CCodegen still emits memcpy (C can't do arena rebind, so it copies anyway)
- Interpreter saves one default construction per iteration, but the get_by_ref
  call + Ptr construction overhead dominates
- Most for-in loops in src/self iterate over small types (Expr params, etc.)

*** Previous State (2026-02-08)
Desugarer used ~get_by_ref~ + ~create_alias~ + ~dont_delete~ but still
constructed a wasteful default ~MyStruct()~ which ~create_alias~ immediately
abandoned. No net performance improvement over the old copy pattern.

*** Design notes

**** create_alias API
~create_alias(var_identifier: Dynamic, type_name: Type, source_addr: I64)~

Declared in ~src/core/mem.til~ as ext_func. The ~Dynamic~ parameter is the
variable name (unevaluated identifier). The ~Type~ parameter follows the
same convention as ~size_of(type: Type)~.

**** How each phase handles create_alias
Each phase that maintains a scope_stack must recognize ~create_alias~ FCall
nodes and call ~declare_symbol(var_name, TCustom(type_name))~:
- **Init**: declares variable (only reaches root-level create_alias)
- **Typer**: validates type exists, declares variable, type-checks addr expr
- **UFCS**: declares variable so ~item.method()~ resolves correctly
- **Precomp**: declares variable so ~get_value_type~ lookups work
- **Interpreter** (ext.rs): declares symbol + inserts arena var at addr
- **CCodegen**: emits C variable declaration + memcpy from addr

**** TIL's design principle at play
TIL defaults to by-const-ref for function args — no ~&~, no annotations, most
efficient is the default with least syntax. For-in follows the same principle:
~for item: T in vec~ is by const ref, zero-copy. Rust needs ~for item in &vec~
or ~for item in vec.iter()~ — TIL drops that ceremony.

If copy semantics are later needed in for-in, add ~copy~ explicitly (like args).

*** Files modified so far
- ~src/rs/desugarer.rs~ + ~src/self/desugarer.til~ - new for-in desugaring
- ~src/rs/garbager.rs~ + ~src/self/garbager.til~ - strip ~dont_delete~ from Body nodes
- ~src/core/array.til~ - added ~Array.get_by_ref~
- ~src/core/set.til~ - added ~Set.get_by_ref~

** Bug #133: Precomputed heap values (Vec, List, etc.) have invalid pointers at runtime (COMPILED MODES)
:PROPERTIES:
:DISCOVERED: 2026-01-22
:IMPACT: Compiled programs crash/segfault when using precomputed collections
:STATUS: Partial - Vec types work (including nested); List, Map still broken
:REPRODUCER: src/test/test_bug133.til (passes for simple types)
:RELATED: Bug #145 (FIXED - was similar issue in til_interpreted mode)
:BRANCH: current133
:END:

NOTE: This bug affects COMPILED modes only (rs_compiled, til_compiled).
For a related issue in til_interpreted mode, see Bug #145.

*** Description
When global declarations like ~chromatic := create_chromatic()~ are precomputed
at compile time, the resulting Vec/List values contain heap pointers from the
interpreter's memory space. These raw pointer values are serialized directly
into C struct literals, causing segfaults at runtime.

*** Example
In music.til:
#+BEGIN_SRC til
chromatic := create_chromatic()  // Returns Vec of Str
#+END_SRC

Generated C code (in main()):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.type_name = (til_Str){.c_string = (til_Ptr){2146}, .cap = 3},
                          .type_size = 16, .ptr = (til_Ptr){3615}, ._len = 12, .cap = 16};
#+END_SRC

Those values (2146, 3615) are raw pointers from the precomp interpreter's arena.
At runtime they point to invalid memory, causing segfaults in Vec.get().

*** Root Cause
1. precomp.rs evaluates global declarations at compile time via eval_comptime()
2. eval_comptime() runs the interpreter, which allocates Vec contents on heap
3. The Vec struct fields (including Ptr fields) are serialized as integer literals
4. At runtime, the compiled program has different memory layout - those pointers are garbage

*** Affected Types
- Vec (Ptr field points to heap-allocated element array)
- List (likely same issue with Ptr node pointers)
- Any struct with Ptr fields pointing to heap data
- Str when dynamically allocated (c_string Ptr field)

*** Fix
Serialize heap data to static arrays: Copy the heap contents into C static
arrays and patch the pointers to reference them. This preserves the
optimization benefit of precomputation.

**** Generic approach
The correct solution is NOT to hardcode specific types (Vec, List, Map), but to
handle ANY struct with owned Ptr fields generically:

1. For each Ptr field in the struct, check if ~is_borrowed~ is false (owned)
2. If owned, the Ptr points to heap data that needs serialization
3. Recursively serialize whatever that Ptr points to (could be another struct
   with Ptr fields, requiring further recursion)
4. Emit static arrays for the serialized data
5. Patch the Ptr to reference the static array instead of the heap address

This approach automatically handles:
- Vec (ptr field points to element array)
- List (node pointers)
- Map (bucket pointers)
- Any user-defined struct with owned Ptr fields
- Arbitrary nesting depth

Current implementation handles Vec specifically; List and Map need the same
treatment but haven't been implemented yet.

*** Workaround (for unsupported types)
Change ~func~ to ~proc~ for functions that return unsupported heap types.
Since precomp only evaluates ~func~ (pure functions), using ~proc~ forces runtime evaluation:

#+BEGIN_SRC til
// Works (all Vec types now supported):
create_chromatic := func() returns Vec { ... }
create_mode_intervals := func() returns Vec { ... }  // Vec<Vec<I64>>

// Broken (List, Map not yet supported), use proc:
create_items := proc() returns List { ... }
#+END_SRC

*** Progress (2026-01-30)
Rust fix merged to master. Files modified:
- ~src/rs/eval_arena.rs~ - VecContents, StrContents extraction functions
- ~src/rs/init.rs~ - PrecomputedHeapValue struct
- ~src/rs/precomp.rs~ - track precomputed heap values
- ~src/rs/ccodegen.rs~ - emit static arrays and patched assignments

TIL port complete (2026-01-30). Files modified:
- ~src/self/eval_arena.til~ - VecContents, extract_vec_contents, extract_str_at_offset, type_needs_heap_serialization
- ~src/self/init.til~ - PrecomputedHeapValue struct
- ~src/self/precomp.til~ - track precomputed heap values
- ~src/self/ccodegen.til~ - PrecomputedStaticInfo, emit_precomputed_static_arrays, hex_byte, bytes_to_i64
- ~src/core/str.til~ - Str.from_byte (consolidation)
- ~src/test/strings.til~ - tests for char_at and from_byte

**** Current test results (simple Vec<I64>, Vec<U8>, Vec<Str>):
- rs_interpreted: PASS
- rs_compiled: PASS (Bug #133 fix works)
- til_interpreted: PASS (Bug #145 resolved)
- til_compiled: PASS (TIL port complete)

**** What works now (both rs_compiled and til_compiled):
- ~Vec<I64>~ - emits static I64 array
- ~Vec<U8>~ - emits static U8 array
- ~Vec<Str>~ - emits string literals + Str struct array (two-level)
- ~Vec<Vec<T>>~ - recursive serialization of nested Vecs

**** Still broken (both rs_compiled and til_compiled):
- ~List~ - linked node pointers not serialized
- ~Map~ - internal structure not serialized

**** Future work:
1. Generalize to handle any struct with owned Ptr fields (not just Vec)
2. Add List serialization support (linked node pointers)
3. Add Map serialization support (internal structure)

*** Implementation Plan
Serialize heap contents to static C arrays and patch pointers to reference them.

**** Before (broken):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.ptr = (til_Ptr){3615}, ._len = 12, ...};  // 3615 is garbage
#+END_SRC

**** After (working):
#+BEGIN_SRC c
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)"do"}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)"do#"}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ._len = 12, ...};
#+END_SRC

**** Step 1: Add Vec/Str extraction to eval_arena.rs [DONE]
Add struct and function to extract Vec contents given an instance name:
#+BEGIN_SRC rust
pub struct VecContents {
    pub element_type_name: String,
    pub type_size: i64,
    pub element_bytes: Vec<Vec<u8>>,
}

pub fn extract_vec_contents(ctx: &Context, instance_name: &str)
    -> Result<VecContents, String>
#+END_SRC

**** Step 2: Track precomputed heap values in precomp.rs [DONE]
Add struct for tracking precomputed heap values:
#+BEGIN_SRC rust
pub struct PrecomputedHeapValue {
    pub var_name: String,
    pub instance_name: String,
    pub type_name: String,
}
#+END_SRC

In ~precomp_declaration()~, when a global declaration has a precomputed Vec/List:
- Store in new ~Context.precomputed_heap_values: Vec<PrecomputedHeapValue>~

**** Step 3: Emit static arrays in ccodegen.rs [DONE for simple types]
Before emitting main(), add a new pass:
#+BEGIN_SRC rust
for phv in &context.precomputed_heap_values {
    if phv.type_name == "Vec" {
        let contents = EvalArena::extract_vec_contents(ctx, &phv.instance_name)?;
        emit_static_vec_data(&phv.var_name, &contents, output)?;
    }
}
#+END_SRC

**** Step 4: Patch struct literals to use static pointers [DONE]
When emitting a global declaration in ~precomputed_heap_values~:
- Instead of ~.ptr = (til_Ptr){1234}~
- Emit ~.ptr = (til_Ptr){(til_I64)_precomp_{var_name}_data}~

**** Handling Nested Types
For Vec<I64>: [DONE]
#+BEGIN_SRC c
static til_I64 _precomp_myints_data[5] = {1, 2, 3, 4, 5};
til_myints = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_myints_data}, ._len = 5, ...};
#+END_SRC

For Vec<Str> (two-level): [DONE]
#+BEGIN_SRC c
static const char _precomp_chromatic_str_0[] = "do";
static const char _precomp_chromatic_str_1[] = "do#";
// ...
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_0}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_1}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ...};
#+END_SRC

For Vec<Vec<T>>: Recursively emit inner arrays first, then outer. [TODO]

**** Complexity Notes
- Vec<Str> requires two-level static arrays (strings + Str structs) [DONE]
- Vec<Vec<T>> requires recursive serialization [TODO]
- List would need similar treatment (linked nodes -> static array) [TODO]
- Start with Vec only, extend to List/Map later if needed

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Bug #114: ScopeStack lookup functions leak memory by copying entire ScopeFrame
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Memory leak in self-hosted interpreter, grows with scope depth and lookup frequency
:STATUS: Partial - Option C implemented, ScopeFrame copy remains (see Bug #144)
:END:

*** Description
TIL's ScopeStack lookup functions (lookup_var, lookup_symbol, lookup_func, lookup_enum,
lookup_struct, is_closure_capture, all_structs, etc.) copy entire ScopeFrame objects
when iterating through frames:

#+BEGIN_SRC til
// Current pattern (leaks memory)
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()   // Allocates new ScopeFrame
    self.frames.get(i, frame)   // Copies ALL fields including 5 Maps

    if frame.arena_index.contains_key(name) {
        // ...
    }
    // frame goes out of scope - Maps inside are NOT freed
}
#+END_SRC

ScopeFrame contains 5 Maps (arena_index, symbols, funcs, enums, structs). Each copy
duplicates the Map struct which holds pointers to heap-allocated Vec data. When the
copied frame goes out of scope, those Map copies leak because TIL has no automatic
destructor/drop mechanism.

*** Why Rust Doesn't Have This Problem
Rust iterates by reference, not by copy:
#+BEGIN_SRC rust
for frame in self.frames.iter().rev() {
    if let Some(offset) = frame.arena_index.get(name) {
        // frame is &ScopeFrame - no copy, no allocation
    }
}
#+END_SRC

*** Potential Solutions

**** Option A: Return references from Vec.get (language change)
Change Vec.get to return a reference/pointer instead of copying:
#+BEGIN_SRC til
// Hypothetical - would require language support for references
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame := self.frames.get_ref(i)  // Returns reference, no copy
    if frame.arena_index.contains_key(name) { ... }
}
#+END_SRC
Pros: Matches Rust semantics, clean syntax
Cons: Major language change, needs reference/borrow system

**** Option B: Vec.get_ptr + manual offset calculation (branch approach)
Use pointer arithmetic to access fields without copying entire struct:
#+BEGIN_SRC til
structs_offset := mul(size_of(Map), 4)
mut scratch_map := Map.new(Str, SStructDef)
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame_ptr := self.frames.get_ptr(i)
    structs_ptr := add(frame_ptr, structs_offset)
    memcpy(to_ptr(scratch_map), structs_ptr, size_of(Map))
    if scratch_map.contains_key(name) { ... }
}
#+END_SRC
Pros: Works now, fixes leak
Cons: Fragile (hardcoded offsets), diverges from Rust significantly, error-prone

**** Option C: Existence-check methods (has_struct, has_symbol, etc.)
Add cheap existence-check methods that avoid full struct retrieval:
#+BEGIN_SRC til
// Instead of:
_ := self.scope_stack.lookup_struct(name)  // Copies SStructDef
catch { }

// Use:
if self.scope_stack.has_struct(name) { ... }  // Just checks existence
#+END_SRC
Pros: Simple, matches Rust .is_some() pattern, no language changes
Cons: Only helps existence checks (~40 places), doesn't fix cases needing the value

**** Option D: Explicit free/drop for complex types
Add manual memory management:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    // ... use frame ...
    frame.free()  // Explicitly free copied Maps
}
#+END_SRC
Pros: Explicit, controllable
Cons: Error-prone, verbose, easy to forget

**** Option E: For-in loop over Vec doesn't copy (compiler optimization)
Make the compiler smart enough to not copy when iterating:
#+BEGIN_SRC til
for frame: ScopeFrame in self.frames.reverse() {
    // frame is a reference, not a copy (compiler detects loop pattern)
}
#+END_SRC
Pros: Clean syntax, no code changes needed
Cons: Significant compiler work, may be complex to implement correctly

**** Option F: ASAP destruction (Mojo-style automatic delete on last use)
Compiler inserts destructor calls automatically when a value is last used:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    if frame.arena_index.contains_key(name) {
        // ...
    }
    // Compiler detects frame's last use and inserts: frame.__del__()
}
#+END_SRC
Pros: Automatic, no manual memory management, matches Mojo semantics
Cons: Requires:
  - Destructor support (__del__ methods on types with heap data)
  - Liveness analysis in compiler to detect last use
  - Careful handling of control flow (returns, throws, branches)
  - May interact poorly with references if added later

This is how Mojo handles memory: values are destroyed as soon as they're last used,
not at end of scope. This enables deterministic destruction without garbage collection.

*** Recommended Approach
Start with Option C (has_* methods) as immediate mitigation - it's simple, matches Rust,
and fixes ~40 call sites. For long-term, evaluate:
- Option F (ASAP destruction) - most automatic, Mojo-proven approach
- Option A (references) - matches Rust semantics closely
- Option E (smart for-in) - transparent optimization

*** Progress
**** Option C implemented (2026-01-29)
Added has_var, has_symbol, has_func, has_enum, has_struct methods to ScopeStack.
Updated all call sites using lookup_*.is_some() pattern to use has_* instead.

Note: The has_* methods still copy ScopeFrame in the for-in loop, which is
Bug #144's problem (for-in iterates by copy). Option C avoids copying the
*definition* objects (VarDef, FuncDef, etc.) but not the ScopeFrame itself.

*** Related Work
- Branch ~claude/detect-ccodegen-translation-diffs-A08OT~ attempted Option B
- That branch was not merged due to Rust/TIL divergence concerns
- ~has_struct~ method was prototyped on that branch

** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (updated 2026-02-11)
Audit of generated C code with ~gcc -Wall -Wextra~:

| Type                         | Count | Priority | Notes                                      |
|------------------------------+-------+----------+--------------------------------------------|
| -Wunused-variable            |  1711 | Low      | Generated temp vars not always used        |
| -Wdangling-pointer           |   971 | High     | Statement expressions return &local_var    |
| -Wunused-but-set-variable    |     9 | Low      | Similar to above                           |
| -Wunused-label               |   195 | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           |     0 | Low      | FIXED 2026-02-11 - (void) casts            |
| -Wmissing-braces             |     0 | Low      | FIXED 2026-01-25                           |
| -Wmissing-field-initializers |     0 | Low      | FIXED 2026-01-25                           |
| -Wreturn-type                |     0 | High     | FIXED 2026-01-25                           |
| -Wincompatible-pointer-types |     0 | Medium   | FIXED 2026-01-13                           |
| -Wc23-extensions             |     0 | Low      | FIXED 2026-01-28 - emit param names always |

*** Fix Strategy (Incremental)
1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Switch to ~-Wall -Wextra -Werror~ with suppressions (DONE - 2026-01-25)
5. Remove suppressions one by one as each warning category is fixed

*** Current Build Flags (target.rs/til)
Now using ~-Wall -Wextra -Werror~ with suppressions for unfixed warnings (2026-01-26):

**** Common flags (both gcc and clang)
- ~-Wno-unused-variable~ (1514 occurrences)
- ~-Wno-unused-but-set-variable~ (386 occurrences)
- ~-Wno-unused-label~ (153 occurrences)

**** GCC-only flags
- ~-Wno-dangling-pointer~ (971 occurrences) - high priority to fix

**** Clang-only flags
- ~-Wno-sometimes-uninitialized~ - exception control flow paths
- ~-Wno-self-assign~ - til_result = til_result patterns in generated code
- ~-Wno-c23-extensions~ - unnamed parameters in function definitions
- ~-Wno-uninitialized~ - variable used before initialization in some paths
- ~-Wno-unused-function~ - enum to_str functions generated but not always used

To fix a warning category: remove the ~-Wno-~ flag and fix the resulting errors.

*** Testing with clang locally (Issue #131)
To build til.til with clang (this is what fails in macOS CI):
#+begin_src bash
./bin/rstil build src/til.til --cc=clang --force-rebuild
#+end_src

To run tests with clang instead of gcc:
#+begin_src bash
./bin/rs/make tests --cc=clang
#+end_src

Note: ~./make.til tests --cc=clang~ does NOT work because the shebang causes
rstil to consume the flag. Use the compiled binary ~./bin/rs/make~ directly.

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [X] Step 3e: Enable and fix -Wreturn-type (2026-01-25) - add implicit return 0 to throwing functions, add zero-initialized fallback return to non-throwing functions with return types
- [X] Step 4: Switch to -Wall -Wextra -Werror with suppressions (2026-01-25)
- [X] Step 5a: Remove -Wno-dangling-pointer (971 occurrences) - fixed by Bug #143, flag removed in Bug #140 fix
- [-] Step 5b: Remove -Wno-unused-variable (1514 occurrences, partial progress)
- [-] Step 5c: Remove -Wno-unused-but-set-variable (9 occurrences, down from 386). Blocks Bug #94 (bug47.til rs_compiled). Two categories: TIL source vars set but not read (3), dead ccodegen temps (4 Str temps in collect_namespace_methods). See Bug #94 for full list.
- [ ] Step 5d: Remove -Wno-unused-label (195 occurrences)
- [X] Step 5e: Remove -Wno-unused-parameter (2026-02-11) - emit (void)param; casts at top of function bodies for _-prefixed params and all params in empty-body functions (e.g., empty delete stubs)
- [X] Step 5f: Remove -Wno-missing-braces (2026-01-25) - use Ptr() instead of NULL for Declaration.default_value in desugarer.til/garbager.til; Ptr() emits ~((til_Ptr){0})~ with proper braces
- [X] Step 5g: Remove -Wno-missing-field-initializers (2026-01-25) - add cap=0 to Str literals for Type params in ccodegen emit_main_args

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-02-11)
| Mode            | Result                             | Time  |
|-----------------+------------------------------------+-------|
| rstil interpret | pass                               | ~9.5s |
| rstil run       | FAIL - unused-but-set-variable (8) | -     |
| til interpret   | pass (but >120s, excluded from benchmark) | -     |
| til run         | OOM killed (exit 137)              | ~61s  |

~rstil run~ fails due to 8 ~-Wunused-but-set-variable~ warnings in generated C:
#+BEGIN_SRC
gen/rs/c/test/bug47.c:4968:  _ignore = til_reset_loop_var_counter()     -- TIL source var
gen/rs/c/test/bug47.c:8841:  _tmp_collect_namespace_methods_15 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8888:  _tmp_collect_namespace_methods_38 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8962:  _tmp_collect_namespace_methods_69 (Str)    -- dead temp
gen/rs/c/test/bug47.c:9009:  _tmp_collect_namespace_methods_92 (Str)    -- dead temp
gen/rs/c/test/bug47.c:18317: custom_symbol_found (Bool)                 -- TIL source var
gen/rs/c/test/bug47.c:19102: have_switch_type (Bool)                    -- TIL source var
gen/rs/c/test/bug47.c:24269: has_switch_type (Bool)                     -- TIL source var
#+END_SRC

Two categories:
1. TIL source variables set but not read (3 vars: ~_ignore~, ~custom_symbol_found~,
   ~have_switch_type~/~has_switch_type~) - fix in TIL source or mark with ~__attribute__((unused))~
2. Dead temps from ccodegen (4 Str temps in ~collect_namespace_methods~) - fix in ccodegen

*** Original Warnings (2026-01-13, historical)
1654 total warnings when compiling with ~gcc -Wall -Wextra~ (all now fixed or
suppressed via Bug #99):
- 933 -Wunused-variable (suppressed, Bug #99 step 5b)
- 318 -Wdangling-pointer (FIXED, Bug #143)
- 195 -Wincompatible-pointer-types (FIXED, Bug #99 step 3a)
- 135 -Wunused-but-set-variable (down to 9, Bug #99 step 5c)
- 66 -Wunused-label (suppressed, Bug #99 step 5d)
- 5 -Wunused-parameter (FIXED, Bug #99 step 5e)
- 1 -Wreturn-type (FIXED, commit 129ba21a)
- 1 null character in literal (FIXED, Bug #99 step 3d)

*** Progress (2026-02-11)
All original warnings now fixed or suppressed via Bug #99. Remaining blocker for
compiled mode is Bug #99 step 5c (9 unused-but-set-variable warnings). OOM in
~til run~ remains open (Issue #117).

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [X] Fix missing return statement (commit 129ba21a)
- [X] Add casts for Vec_push calls - fixed in Bug #99 Step 3a (-Wincompatible-pointer-types)
- [X] Consider which unused-* warnings to fix vs suppress - done in Bug #99 Step 4
- [X] Fix dangling pointer pattern - fixed by Bug #143
- [ ] Fix 8 unused-but-set-variable warnings - same as Bug #99 Step 5c
- [ ] Fix til ccodegen memory usage (OOM on large files) - may be fixed by Issue #117 (borrow checker)

*** Related Issues
- Bug #99 Step 5c: Remove -Wno-unused-but-set-variable (direct blocker for rs_compiled)
- Bug #140: Dangling pointers in generated C code (FIXED via Bug #143)
- Issue #117: Borrow checker / memory management (may fix OOM)

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:RELATED: Bug #168 (ccodegen return copies), Issue #117 (ASAP destruction), Issue #100 (get rid of rstil)
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** History

**** 2026-01-01 to 2026-01-08: Initial Approach (Abandoned)
Original approach was to incrementally fix divergences in the existing ccodegen.til
through line-by-line comparison with ccodegen.rs. This proved problematic because:
- ccodegen.til had many missing ports from Rust
- Contained unauthorized workarounds and non-matching comments
- AI assistants kept adding more divergences instead of fixing them
- The accumulation of issues made systematic comparison impossible

**** 2026-01-09: Fresh Rewrite
Decision made to delete all self-hosted compiler files and start fresh:
- Commit ~1f29279a~: "Remove self-hosted compiler files for fresh rewrite"
- Blind translation of ccodegen.til, builder.til, til.til from Rust
- ~150+ commits fixing syntax, types, missing methods, etc.

***** WARNING: Broken Commit Range
Commits from ~1f29279a~ (origin/master + 1) through ~fad411f8~ are ALL BROKEN.
The build fails throughout this range because:
1. Fresh translation introduced many syntax/type errors
2. Each commit fixed some errors but build still failed
3. Only at ~fad411f8~ "Fix uninitialized variables..." does build pass again

This matters for:
- ~git bisect~: Skip this entire range, it's all broken
- ~git rebase -i~: Could squash ~1f29279a..fad411f8~ into single commit
- Archaeology: Don't waste time investigating individual commits in this range

**** 2026-01-12: Progress - Fixed if-let-Ok pattern in init.til
Build passes. 80/80 tests pass (0 failures). Test breakdown:
- 65 tests in all_common (pass all 4 modes) - includes maps.til!
- 1 test in til_common (panic.til)
- 4 tests in rs_interpreted
- 3 tests in rs_compiled
- 7 tests in rs_common
- 0 tests in til_interpreted (empty!)

Recent fixes:
- Fixed gcc stderr handling in builder.til to match Rust (capture stderr, only show on failure)
- Fixed hoisted_exprs collision: clear per-function to avoid cross-file line/col key collisions
- Fixed many if-let-Some translation bugs in ccodegen.til per rs2til.org rules:
  - emit_switch: enum_has_payloads, collect_declarations, payload lookup patterns
  - collect_declarations_recursive: type inference pattern
  - emit_assignment, emit_if, emit_while: vt check patterns
  - Various enum/struct lookup patterns with flag variables
- KEY FIX: Fixed if-let-Ok translation bug in init.til get_fcall_value_type
  - target_type was used after get_value_type could throw, causing garbage data
  - Added flag pattern: ~mut have_target_type := true~ with catch setting to false
  - This fixed enums.til and other nested function + switch case failures
- KEY FIX: Fixed ext.c run_cmd returning wrong exit code when output exceeds 64KB buffer
  - Rust's Command::output() captures all output; ext.c had 64KB limit
  - When buffer filled, pclose() with unread data caused gcc to get SIGPIPE -> non-zero exit
  - Added drain loop to consume remaining output before pclose()
  - This fixed maps.til and allowed moving it to all_common (all 4 modes pass)

*** Root Cause Analysis

The recurring bug pattern was if-let-Some/if-let-Ok translations from Rust:

#+begin_src rust
// Rust: if get_value_type fails, body is skipped
if let Ok(target_type) = get_value_type(context, first_arg) {
    // use target_type
}
#+end_src

#+begin_src til
// WRONG TIL: target_type is garbage if get_value_type throws!
target_type := get_value_type(context, first_arg)
catch (err: Str) { }
switch target_type {  // Uses garbage!
#+end_src

#+begin_src til
// CORRECT TIL: flag pattern per rs2til.org
mut have_target_type := true
target_type := get_value_type(context, first_arg)
catch (err: Str) {
    have_target_type = false
}
if have_target_type {
    switch target_type {  // Safe to use
#+end_src

*** Remaining Work
- 7 tests in rs_common (pass with rstil but not with til)
- Final verification: ~./src/til_diff.til src/til.til~ must show no differences
  - Note: times out at 300s - likely infinite loop (til compiled total is only 80s)

*** Debugging Tools

- ~./src/til_diff.til src/test/foo.til~ - compare rstil vs til generated C code
- ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ - test single file
- ~./make.til til_debug~ - build til with debug symbols for gdb
- ~gdb ./bin/til_debug~ - step through with breakpoints, inspect variable values
- ~gdb -batch -ex "run ..." -ex "bt" ./bin/til~ - get crash backtrace
- Look at ~gen/c/test/*.c~ for generated code

TIL code must be an exact translation from Rust (comments and variable names included)
using rs2til.org translation rules. Any differences detected must be fixed immediately,
even if only cosmetic.

Current test: ~src/test/c_mem.til~

**** Iterative Fix Workflow
1. User picks a test from til_interpreted that they want working in til_compiled
2. Run ~./src/til_diff.til src/test/chosen_test.til~ to compare rstil vs til generated C code
3. Analyze the diff - identify what's different in the generated C
4. Identify root cause in ccodegen.til
5. Verify against Rust - check equivalent code in ccodegen.rs
6. Fix following rs2til.org - apply correct translation pattern
7. Test the fix: ~./bin/til run src/test/chosen_test.til~
8. Run ~timeout 300 make benchmark~ (always use timeout 300 for make benchmark)
9. Re-run all failing tests in parallel to update TODO comments:
   - Run ~timeout 10 ./bin/til run src/test/X.til 2>&1~ for each test in til_interpreted
   - Update inline TODO comments with current errors
   - If any tests now pass, move them from til_interpreted + rs_common to all_common
   - If tests were moved, run ~make benchmark~ again to verify
10. Commit the fix (tests.til now has up-to-date TODOs and test locations)
11. Wait for user to pick next test to fix

**** Test Tracking
Each test in til_interpreted (src/tests.til) has an inline TODO comment explaining
why it fails in til_compiled:
#+BEGIN_SRC til
til_interpreted.push(TestEntry(path="src/test/foo.til"))  // TODO: too few args to til_Array_get
#+END_SRC
When a test passes til_compiled, remove TODO and move to all_common.

**** Updating TODO Comments
- Run ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ for each test to get the error
- Use timeout to catch infinite loops (exit code 124 = timeout)
- Run tests in parallel (multiple Bash tool calls), no shell loops
- NO filtering (no head, tail, grep) - see full output
- Extract the key error from output and add as inline TODO comment

**** Critical Rules
- Source of truth is Rust + rs2til.org - TIL code must match Rust translated per rs2til.org rules
- Validate changes by comparing Rust to TIL - run ~git diff~ and check both sides match per rs2til.org
- Correctness per rs2til.org is primary - whether a change "fixes" a test is secondary
- If change follows rs2til.org but doesn't fix issue - there's a DIFFERENT bug elsewhere
- NEVER filter make benchmark output - see ALL errors
- Variable shadowing is now supported (Bug #97 fixed via name mangling)
- Port fixes to BOTH Rust and TIL when needed

**** Files Modified
- src/self/ccodegen.til
- src/self/builder.til
- src/til.til
- src/rs/ccodegen.rs (when porting fixes)
- src/rs/builder.rs (when porting fixes)
- src/tests.til (when moving tests back to all_common)

*** Progress

**** Fixed Issues (from fresh rewrite)
1. Variable shadowing in emit_declaration (fcall_arg, hoisted_arg, ref_arg)
2. Variable shadowing in builder (reuse errors vector, default_fd rename)
3. Uninitialized variables after throwing calls:
   - detect_variadic_fcall (8 locations)
   - get_type_arg_name
   - lookup_struct
   - get_fcall_func_def in emit_throw
   - get_fcall_func_def in hoist_throwing_expr

**** Issues Found in hello_script.til Diff (2026-01-11)
Current diff from ~./src/til_diff.til src/examples/hello_script.til~:

***** Issue 1: til_Array_get missing 3 arguments
rstil generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1, til_extra_msgs, &_for_i_panic_0, (til_Dynamic*)&til_extra_msg);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1);
#+END_SRC
Affects 5 locations in hello_script.til (lines 101, 132, 165, 185, 233)

****** 2026-01-11: Fixed - Multiple issues in emit_throwing_call* functions
Root cause: Several interrelated bugs in argument emission for throwing function calls.

1. Catch block placement: Catch blocks were placed AFTER emit_arg_with_param_type(),
   so when param_by_ref.get() or param_types.get() threw IndexOutOfBoundsError,
   emit_arg_with_param_type was skipped entirely, causing missing arguments.

2. param_types type mismatch: emit_throwing_call_propagate and emit_throwing_call_with_goto
   stored Vec<Ptr> but hoist_for_dynamic_params expected Vec<ValueType>. This caused
   incorrect Dynamic casts to be applied to all arguments.

3. regular_arg_count defaulting to 0: In emit_throwing_call_with_goto, for non-variadic
   functions, regular_arg_count came from variadic_info.regular_count which defaults to 0.
   The loop `if arg_i.sub(1).gteq(regular_arg_count)` would break immediately.
   Fixed by using 999999999 for non-variadic (matches Rust's usize::MAX pattern).

Fixed in emit_throwing_call, emit_throwing_call_propagate, emit_throwing_call_with_goto:
- Move catch blocks immediately after .get() calls, before emit_arg_with_param_type
- Change param_types from Vec<Ptr> to Vec<ValueType>
- Convert ValueType to Ptr when calling emit_arg_with_param_type
- Use large default for regular_arg_count in non-variadic case

After fix: til_Array_get arguments now match rstil output.
Remaining diffs are hoisting differences (temp var numbering) which are cosmetic.

***** Issue 2: til_malloc missing 1 argument
rstil generates:
#+BEGIN_SRC c
til_I64 _tmp_format_13 = til_add(&til_result.cap, &(til_I64){1});
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12, &_tmp_format_13);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12);
#+END_SRC

***** Issue 3: Hoisting differences
rstil hoists expressions to temp vars:
#+BEGIN_SRC c
til_I64 _tmp_format_14 = til_mul(til_index, &til_self->type_size);
const til_I64 til_src = til_add(&til_self->ptr, &_tmp_format_14);
#+END_SRC
til uses inline compound literals:
#+BEGIN_SRC c
const til_I64 til_src = til_add(&til_self->ptr, &(til_I64){til_mul(til_index, &til_self->type_size)});
#+END_SRC
Both are valid C but cause temp variable numbering drift.

***** Issue 4: .msg inline vs hoisted
rstil hoists format call:
#+BEGIN_SRC c
til_Str _tmp_til_Array_get_7 = til_format(...);
*_err1 = (til_IndexOutOfBoundsError){.msg = _tmp_til_Array_get_7};
#+END_SRC
til inlines:
#+BEGIN_SRC c
*_err1 = (til_IndexOutOfBoundsError){.msg = til_format(...)};
#+END_SRC

****** 2026-01-12: Fixed - is_struct_constructor catch placement in init.til
The is_struct_constructor function in init.til had a catch block placed outside
the if block where the throwing code was:

#+BEGIN_SRC til
// WRONG - catch was outside if block, never catches lookup_struct exceptions
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    return true
}
catch (err: KeyNotFoundError) {  // Never triggered!
    return false
}
#+END_SRC

Fixed by moving the catch inside the if block:

#+BEGIN_SRC til
// CORRECT - catch inside same scope as throwing code
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    catch (err: KeyNotFoundError) {
        return false
    }
    return true
}
#+END_SRC

This fix resolves the hoisting differences - til_diff.til now shows "OK: No differences found!"

****** 2026-01-12: Test re-categorization after is_struct_constructor fix
With the catch placement fix, many tests now pass til_compiled mode.
Updated test categories in src/tests.til:
- 17 tests in all_common (pass all 4 modes)
- 49 tests in til_interpreted (pass til interpret, fail til compile)
- 53 tests in rs_common (pass rstil, fail til compile)

****** 2026-01-12: Discovered til.til run_cmd_vec swallows output
Tests showing "empty output" in til_compiled mode are caused by til.til's
run_cmd_vec function capturing stdout into a variable but never printing it:

#+BEGIN_SRC til
run_cmd_vec := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args { full_cmd = full_cmd.concat(" ").concat(arg) }
    mut output := ""
    return output.run_cmd("bash", "-c", full_cmd)  // output captured but never printed!
}
#+END_SRC

In contrast, rstil.rs uses Command::new().status() which inherits stdout.
This is NOT a ccodegen bug - the C code is identical. Needs separate fix in til.til.

****** 2026-01-12: Fixed run_cmd_vec output swallowing
Added run_cmd_vec_print to sys.til that prints captured output after run_cmd:

#+BEGIN_SRC til
run_cmd_vec_print := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)
    if output.len().gt(0) {
        print(output)
    }
    return exit_code
}
#+END_SRC

Updated til.til's run_file_or_exit to use run_cmd_vec_print instead of run_cmd_vec.
This matches rstil.rs's Command::new().status() behavior of inheriting stdout.

****** 2026-01-12: Final test re-categorization after run_cmd_vec_print fix
Tests that were failing with "empty output" now work correctly.
Updated test categories in src/tests.til:
- 22 tests in all_common (pass all 4 modes)
- 1 test in til_common (panic.til - error msg format differs "til" vs "rstil")
- 43 tests in til_interpreted (pass til interpret, fail til compile)
- 48 tests in rs_common (pass rstil, fail til compile)
- Total: 121 tests, 0 failures

Tests moved to all_common:
- hello_cli.til, hello_script.til, lolalalo.til (examples)
- bug46.til, underscore.til (tests)

****** 2026-01-12: Fixed hello_test.til constant folding
Two fixes to make hello_test.til pass til_compiled:

1. emit_arg_with_param_type in ccodegen.til: Added fc_fd_found flag to prevent
   double-emission when catch block handles KeyNotFoundError. The catch block
   would emit the expression, then code continued to emit it again.

2. is_comptime_evaluable in precomp.til: Changed from lookup_func to
   get_func_def_for_fcall_with_expr for proper UFCS resolution. This allows
   constant folding of expressions like ~not(I64.eq(42, 43))~.

Tests moved to all_common (11 tests):
- hello_test.til, arithmetics.til, boolean.til
- branchless.til, bug41.til, circular_test.til, comparisons.til
- eval.til, intro.til, literals.til, namespaces.til, variadic.til

Tests moved back from all_common (failed til_compiled):
- arenas.til (gcc type mismatch)
- arrays.til (gcc type mismatch)
- bug52.til (gcc shadow warning)
- underscore.til (segfault)

**** Known Error Patterns in Generated C
- ~too few arguments to function~ - missing args in generated calls
- ~undeclared variable~ - variable not emitted

*** Files That Must Match
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Final Verification
~make benchmark~ - all tests pass
