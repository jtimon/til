#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-11-10
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it,
# BOT: add them at the top of active bugs, when fixed, move them to the top of fixed bugs

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #51: Precomp doesn't propagate constants through function parameters
:PROPERTIES:
:DISCOVERED: 2025-12-19
:IMPACT: Missed compile-time optimizations, larger generated code
:STATUS: Open
:END:

*** Description
When a function is called with literal arguments, the parameters inside the
function body are not treated as compile-time constants, preventing constfolding.

*** Example
#+BEGIN_SRC til
test_equal := proc(s1: Str, s2: Str) {
    preffix := "\nPara "
    for_whom := preffix.concat(s1).concat(s2)  // NOT folded
    ...
}
test_equal("lo", "la")  // Called with literals
#+END_SRC

Even though ~test_equal("lo", "la")~ passes literals, inside the function:
- ~preffix~ is a literal -> comptime
- ~s1~, ~s2~ are parameters -> NOT comptime
- ~preffix.concat(s1)~ cannot fold because ~s1~ isn't comptime

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/examples/lolalalo.til
# Inspect gen/c/examples/lolalalo.c line 771:
# til_for_whom = til_concat(til_concat(til_preffix, til_s1), til_s2);
# Should be: til_for_whom = ((til_Str){(til_I64)"\nPara lola", 10});
#+END_SRC

*** Root Cause
In ~precomp_func_def~ (src/rs/precomp.rs:736):
#+BEGIN_SRC rust
is_comptime_const: false,  // Function args are not comptime constants
#+END_SRC

Function parameters are unconditionally marked as non-comptime, even when
the function is called exclusively with literal arguments.

*** Potential Solutions

**** 1. Function Specialization (Recommended)
When a function is called with all-literal arguments, create a specialized
copy with those values inlined and marked as comptime, then constfold it.

Pros: Full optimization, works for any function
Cons: Can cause code bloat if many call sites with different literals

**** 2. Inline Small Functions
Inline functions called with literal arguments, then constfold the inlined body.

Pros: Simple, leverages existing constfolding
Cons: Code bloat, doesn't work for recursive functions

*** Workaround
None - this is an optimization issue, not a correctness bug. Code runs correctly
but with more runtime computation than necessary.

** Bug #50: Codegen doesn't capture outer variables in nested functions
:PROPERTIES:
:DISCOVERED: 2025-12-19
:IMPACT: Nested functions fail to compile when accessing outer scope variables
:STATUS: Open
:END:

*** Description
Nested functions (closures) in TIL can access variables from their enclosing scope.
This works correctly in the interpreter but fails during C code generation - the
outer variables are not captured/passed to the nested function.

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil interpret src/tests.til test rs_common src/examples/lolalalo.til
#+END_SRC

Or uncomment in tests.til:
#+BEGIN_SRC til
// rs_common.push(TestEntry(path="src/examples/lolalalo.til")) // TODO Bug #50
#+END_SRC

*** Error Output
#+BEGIN_EXAMPLE
gen/c/examples/lolalalo.c:1396:117: error: 'til_s2' undeclared (first use in this function)
gen/c/examples/lolalalo.c:1410:107: error: 'til_silabes' undeclared (first use in this function)
#+END_EXAMPLE

*** Root Cause
In ccodegen, when emitting nested functions, variables from the outer scope (s1, s2,
silabes) are referenced but not passed as parameters or captured in a closure struct.

*** Potential Solutions

**** 1. Lambda Lifting (Recommended)
Transform nested functions into top-level functions, adding captured variables as
explicit parameters. The compiler would:
- Analyze which outer variables are referenced inside the nested function
- Add those as extra parameters to the lifted function
- At call sites, pass the captured variables explicitly

Pros: Simple, no runtime overhead, matches how TIL already handles explicit params
Cons: Recursive nested functions need care (captured vars passed through each call)

**** 2. Closure Struct
Create a struct containing all captured variables, pass pointer to nested function:
#+BEGIN_SRC c
struct poem_closure { Str s1; Str s2; };
Str poem(I64 depth, Str current, struct poem_closure* ctx) {
    // use ctx->s1, ctx->s2
}
#+END_SRC

Pros: Clean abstraction, single extra parameter regardless of capture count
Cons: Slightly more complex codegen, minor indirection overhead

**** 3. GCC Nested Functions Extension
GCC supports nested functions as a non-standard extension. We could use this directly.

Pros: Zero codegen changes for nested function bodies
Cons: GCC-only (not clang/MSVC), uses trampolines (executable stack), less portable

**** 4. Restrict Nested Function Captures
Disallow nested functions from capturing outer variables - require explicit parameters.
This is a language design change rather than a fix.

Pros: Simpler language semantics, no closure machinery needed
Cons: Breaking change, less ergonomic for users

*** Workaround
Use the interpreter instead of the compiler for files with nested functions that
capture outer variables. The file is in rs_interpreted instead of rs_common.

*** Work In Progress (2025-12-19)
Prerequisite refactor "Phase A: Const Args by Reference" is in progress in the
=wio= branch. This changes all non-copy params to pointers (const Type*) which
simplifies the lambda lifting implementation.

Phase A completed items:
- emit_func_signature: all non-copy params now const Type*
- by_ref calculations: changed from is_mut to !is_copy (7 locations)
- current_ref_params: now includes all non-copy params
- Variadic handling: fixed in emit_fcall_name_and_args_for_throwing and emit_fcall
- Compound literals: added for number/string literals

Phase A remaining issue:
- Nested struct-returning function calls passed to by-ref params need hoisting
- Current hoisting only works at statement level (indent > 0)
- Need recursive hoisting before emitting expressions
- See =wio= branch for debug output and partial implementation

** Bug #48: Typer missing validation that mut arguments must be lvalues
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: No clear error message when passing literals to mut params
:STATUS: Open
:END:

*** Description
The typer phase is missing a validation check: arguments to =mut= parameters
must be lvalues (identifiers or field access). This affects both interpreter
and compiler paths - both should catch this in the typer phase.

*** Example
#+BEGIN_SRC til
test_mut := proc(mut n: I64) {
    n = 99
}
test_mut(42)  // Should be rejected by typer
#+END_SRC

*** Expected Behavior
Typer should reject =test_mut(42)= with an error like:
"mut arguments must be passed as identifiers or field access"

*** Actual Behavior
- Typer: No validation (the bug)
- Interpreter: Happens to catch it later during eval (wrong phase)
- Compiler: No catch at all - GCC rejects generated C code

*** Fix Required
Add validation in typer.rs and typer.til to check that arguments passed to
=mut= parameters are lvalues. Should catch all literal types: I64, U8, Str.
Will need a new error type or message.

*** Related
- Bug #49: Similar issue for =own= parameters (use-after-move check)

*** Reproducing Test
src/test/bug48_test.til

#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug48_test.til  # FAIL - eval error (should be typer)
./bin/rstil run src/test/bug48_test.til        # FAIL - GCC error (should be typer)
#+END_SRC

** Bug #47: Self-hosted TIL interpreter fails with "NodeType.?" error
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: ./bin/til interpret fails on any file
:STATUS: Open - Codegen bug, examining generated C patterns
:END:

*** Description
The compiled self-hosted TIL interpreter (./bin/til) fails immediately when trying
to interpret any file, including empty.til. The error occurs during core library
initialization (vec.til:63).

*** Error Message
#+BEGIN_EXAMPLE
Error during file execution: src/core/core.til:src/core/vec.til:63:63: til init ERROR: Identifiers can only contain identifiers, found 'NodeType.?'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Analysis
The "NodeType.?" indicates an invalid enum tag value is being read from memory.
This happens in init.til's =get_value_type= function when iterating over
=e.params= (a Vec of Expr) - some Expr has a corrupted NodeType field.

*** Bug Type
CODEGEN BUG - rstil works, compiled til fails. Per methodology: "interpret works
but run fails" = codegen issue in ccodegen.rs

*** Investigation Notes
- rstil interpret works fine, only til (compiled self-hosted) fails
- The error is consistent - always at vec.til:63 during init
- Struct sizes match between TIL calculation and C sizeof for Expr (288 bytes)
- Invalid NodeType tag value found: 840973088 (0x32202E32) - looks like ASCII data

*** Key Discovery (2025-12-19)
Added =Expr.to_str()= and debug prints to =get_value_type= in init.til.

The expression =self.ptr= at vec.til:63 is processed 3 times:
#+BEGIN_EXAMPLE
1st call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
2nd call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
3rd call: e.params = [Expr{NodeType.?, ...}]         <- CORRUPTED
#+END_EXAMPLE

*Critical*: The corruption is visible in =e.to_str()= BEFORE iterating over params.
This means corruption happens BETWEEN calls to get_value_type, not during the
for-in loop or Vec.get. Something external is corrupting the Expr data.

*** What Was Ruled Out
- Bug #52 (static buffer in ext.c) - fixed, didn't solve this
- Bug #53 (missing null termination in str.til) - fixed, didn't solve this
- for-in vs while+Vec.get - both show same corruption

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil interpret src/examples/empty.til  # PASS
./bin/til interpret src/examples/empty.til    # FAIL
#+END_SRC

*** Notes
Bug #52 and #53 were discovered while investigating this issue. Both are now fixed
but did not resolve the NodeType memory corruption.

*** Narrowed Down Location (2025-12-19)
The corruption happens in =check_types_with_context= function in typer.til:
- Specifically in the =NodeType.Identifier(name)= case (lines 237-272)
- Around the =lookup_symbol= call (lines 259-265)

Call tracing showed:
- get_value_type calls #477 and #478 share the same =params.ptr=
- Call #477 sees valid data: =self.ptr line=63=
- Call #478 sees corrupted data: =? line=26726118198=
- Corruption happens BETWEEN these calls, during check_types_with_context

*** Debug Strategy
To find the exact line causing corruption:
1. Add debug print with =e.to_str()= after EVERY line in check_types_with_context
2. Run test once
3. Find where output changes from valid to corrupted
4. That line (or function called on that line) is the culprit
5. Drill into that function with more prints
6. Repeat until exact codegen bug found in ccodegen.rs

** Bug #42: Temp variable naming inconsistency causes undeclared _tmp_N errors
:PROPERTIES:
:DISCOVERED: 2025-12-17
:IMPACT: Compilation fails
:STATUS: Active
:END:

*** Description
After commit 5707c2d (Make _for_i_ variable names deterministic), some code paths generate temp variables with old-style names (_tmp_N) while others use new-style names (_tmp_funcname_N). This causes gcc errors for undeclared variables.

#+BEGIN_EXAMPLE
gcc error: '_tmp_13' undeclared (first use in this function)
In til_Vec_clone:
til_Vec til_cloned = {..., .ptr = _tmp_13, ...};
#+END_EXAMPLE

*** Root Cause
The deterministic naming commit (5707c2d) updated many code paths to use function-prefixed temp names like _tmp_funcname_N, but at least one code path still uses the old _tmp_N naming without function prefix. The declaration uses the new style while the reference uses the old style, or vice versa.

*** Related
- Commit 5707c2d: Fix Bug #40: Make _for_i_ variable names deterministic
- The commit changed next_mangled() to include function name prefix

*** Files to Investigate
- src/rs/ccodegen.rs: Check all code paths that generate temp variables
- src/self/ccodegen.til: Same for TIL version

* Fixed Bugs

** Bug #49: Typer missing use-after-move check for own parameters
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-20
:IMPACT: Compiled code allows use of moved variable
:STATUS: Fixed
:END:

*** Description
When a variable is passed to an =own= parameter, the variable should be
invalidated in the caller's scope. The interpreter catches this at eval time,
but the typer doesn't track it - so compiled code allows using the variable.

*** Example
#+BEGIN_SRC til
consume := proc(own n: I64) returns I64 {
    return mul(n, 2)
}

test := proc() {
    mut x := 42
    result := consume(x)
    println(I64.to_str(x))  // Should be rejected - x was moved
}
#+END_SRC

*** Expected Behavior
Typer should reject use of =x= after it was passed to =own= parameter:
"Variable 'x' was moved and can no longer be used"

*** Actual Behavior
- Typer: No tracking of moved variables (the bug)
- Interpreter: Catches at eval - "Undefined symbol 'x'" (wrong phase)
- Compiler: No catch at all - x still usable with original value

*** Fix Applied (2025-12-20)
In typer's =check_fcall= function, after all type checking for an argument is complete,
if the parameter has =is_own= and the argument is a simple identifier, remove the
symbol from scope using =context.scope_stack.remove_symbol()=.

Key insight: The removal must happen AFTER =get_value_type= is called on the argument,
not before - otherwise the type lookup fails for the current argument.

*** Files Modified
- src/rs/typer.rs: Added remove_symbol call at end of argument loop in check_fcall
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug49_test.til with expected_status=1

*** Regression Test
src/test/bug49_test.til (expects exit code 1 - type error)

*** Related
- Bug #48: Similar issue for =mut= parameters (lvalue check)
- See doc/ownership.org for full ownership design

** Bug #34: Code after catch blocks doesn't run in error path
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

*** Description
Code placed AFTER catch blocks doesn't run when an error is caught.

*** Example
#+BEGIN_EXAMPLE til
throwing_call()
between = true      // Between throw and catch - correctly skipped on error
catch (err: Error) {
    // error caught
}
code_after_catch()  // Now runs correctly in both success and error paths
#+END_EXAMPLE

*** Root Cause
In the C code generator, statements after the last catch block were emitted BEFORE
the ~goto _end_catches~ jump, so they only ran on the success path.

*** Complete Fix (2025-12-15, commit 9781c41)
The initial partial fix used emit_expr directly for statements after the last
catch block. However, emit_expr doesn't do throwing call detection, causing
throwing functions like Vec.push to be emitted without error parameters.

The complete fix:
1. Find the index of the last catch block in emit_stmts
2. Only emit statements up to and including the last catch in the main loop
3. After emitting _end_catches label, call emit_stmts recursively for remaining
   statements - this properly handles throwing calls with error detection and
   goto labels

*** Files Modified
- src/rs/ccodegen.rs: emit_stmts recursive call for statements after last catch
- src/self/ccodegen.til: Same fix ported
- src/test/errors.til: Regression test (test_bug34)

** Bug #46: Infinite loop in typer.til due to catch catching later throw
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: til interpret/run hangs indefinitely
:STATUS: Fixed
:END:

*** Description
When running =./bin/til interpret= or =./bin/til run=, the self-hosted compiler hangs
in an infinite loop. Debug output shows "struct_found=true" printing infinitely in
typer.til's struct/enum lookup code.

*** Root Cause
In typer.til around lines 2500-2520, a catch block catches a throw that comes AFTER it
lexically, creating an infinite loop:

#+BEGIN_EXAMPLE til
// typer.til lines ~2500-2520 (approximate)
struct_def = context.scope_stack.lookup_struct(combined_name)
struct_found = true
catch (err: KeyNotFoundError) {  // Line ~2508 - catches lookup_struct errors
    // Struct not found, continue to enum check
}

if struct_found {
    // Line ~2515 - THIS throw gets caught by the catch at line ~2508!
    throw KeyNotFoundError(msg=format("Struct instantiation: ", combined_name))
}
#+END_EXAMPLE

The flow:
1. lookup_struct throws KeyNotFoundError
2. Catch at ~2508 handles it, struct_found remains false
3. Code continues, struct_found is set true later
4. Throw at ~2515 is caught by the catch at ~2508 (wrong!)
5. Execution continues after catch, loops back, struct_found=true prints
6. Infinite loop

*** Expected Behavior
The throw at line ~2515 should propagate UP to the caller, not be caught by
the catch at ~2508 which is meant only for lookup_struct errors.

*** Actual Behavior
The catch block's scope extends beyond just the lookup_struct call, incorrectly
catching throws that come after it in the source code.

*** Reproducing Test
src/test/bug46_test.til - Passes with interpreter, fails with compiler:
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug46_test.til  # PASS
./bin/rstil run src/test/bug46_test.til        # FAIL - Bug #46 present
#+END_SRC

Self-hosted compiler hangs:
#+BEGIN_SRC bash
timeout 30 ./bin/rstil build src/til.til && timeout 10 ./bin/til interpret src/examples/empty.til
# Times out (exit code 124)
#+END_SRC

*** Related
- Bug #34: Code after catch blocks doesn't run in error path (partially fixed)
- Bug #39: Non-consecutive catches fail (fixed)
- Bug #44: Codegen missing status check after blocks with catches (fixed)

All these bugs relate to catch block scope/semantics in generated C code.

*** Fix Applied (2025-12-18)
The issue was in ccodegen's emit_stmts function. When processing catch blocks,
they were added to =local_catch_labels= at the START of statement processing.
This meant ALL throws anywhere in the function could jump to ANY catch, even
catches that appeared BEFORE the throw lexically.

The fix: After emitting a catch block, remove it from =local_catch_labels=.
This ensures only throws that come BEFORE a catch can use it, mirroring the
interpreter's behavior where =pending_throw= is set by statements and only
subsequent catches can handle it.

*Rust* (src/rs/ccodegen.rs lines 3149-3153):
#+BEGIN_SRC rust
// Bug #46 fix: Remove this catch from local_catch_labels
// Catches should only handle throws from BEFORE them, not after.
ctx.local_catch_labels.remove(err_type_name);
#+END_SRC

*TIL* (src/self/ccodegen.til lines 4551-4555):
#+BEGIN_SRC til
// Bug #46 fix: Remove this catch from local_catch_labels
ctx.local_catch_labels.remove(err_type_name)
#+END_SRC

*** Files Modified
- src/rs/ccodegen.rs: Added removal of catch from local_catch_labels after processing
- src/self/ccodegen.til: Same fix ported

** Bug #45: init.til uses invalid fallthrough switch syntax
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Functions not registered - til fails with "Undefined symbol 'sub'"
:STATUS: Fixed
:END:

*** Description
init.til incorrectly uses C-style switch fallthrough syntax, which TIL does not support.
TIL requires each case to have its own body - there is no fallthrough.

This causes functions (FTFunc, FTProc, etc.) to not be registered in init_context, since
only the FTMacro case has the declare_func call.

*** Wrong TIL Source (init.til lines 1466-1474)
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
case FunctionType.FTFuncExt:
case FunctionType.FTProc:
case FunctionType.FTProcExt:
case FunctionType.FTMacro:
    // WRONG: only FTMacro case has the body!
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Correct TIL (bodies must be repeated)
Per doc/translate_rs2til.org lines 39-50, TIL requires separate case arms:
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTFuncExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProcExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTMacro:
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Root Cause
Translation error from Rust to TIL. Rust uses | to combine patterns, TIL requires
repeated bodies. See doc/translate_rs2til.org for the translation rules.

*** Fix Applied (2025-12-18)
Fixed init.til lines 1465-1511 to repeat the switch body for each FunctionType case:
- FTFunc, FTFuncExt, FTProc, FTProcExt, FTMacro all now have identical bodies
- Each case calls declare_symbol and declare_func

Searched all other .til files in src/self/ for similar patterns - none found.
Other consecutive case patterns are either:
1. Cases with bodies on same line (e.g., `case X: return "x"`)
2. Intentional "do nothing" cases with comments (e.g., skip primitives I64/U8/Str)

** Bug #44: Codegen missing status check for throwing call after block with catches
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: Wrong code execution - statements after throwing call run when they shouldn't
:STATUS: Fixed
:END:

*** Description
When a throwing function call is followed by catch, but there's a preceding block
(if/switch) that also contains catches, the status check for the later throwing call
is sometimes missing from the generated C code.

This causes the "func 'Bool' returns multiple values" error when til processes
bool.til, because get_fcall_value_type incorrectly finds Bool as a function (due
to lookup_func not properly short-circuiting on KeyNotFoundError).

*** Example Problem
#+BEGIN_EXAMPLE til
test_func := func() returns I64 throws Str {
    // Block with catches
    if true {
        mut val := maybe_throw_A(false)
        catch (err: ErrorA) { }
    }

    // After the block - status check is MISSING for this call!
    mut found := false
    mut result := maybe_throw_C(true)  // This throws
    found = true  // BUG: This runs even though C threw!
    catch (err: ErrorC) { }

    if found { throw "found should be false!" }
    return 0
}
#+END_EXAMPLE

*** Generated C Code (broken)
The call at line 10488 in til.c is missing the status check:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
// MISSING: if (_status_... == 1) { goto _catch_...; }
til_standalone_func_def = _ret_...;
til_found_standalone = true;  // Runs unconditionally!
if (0) { _catch_KeyNotFoundError_...: ... }
#+END_EXAMPLE

Compare with line 24060 which is correct:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
if (_status_... == 1) { _thrown_... = _err0_...; goto _catch_...; }  // Correct!
til_func_def = _ret_...;
#+END_EXAMPLE

*** Root Cause (Likely)
In ccodegen.rs, the `local_catch_labels` map is being cleared/repopulated
incorrectly when processing blocks with catches, causing the catch for the
later throwing call to not be registered when the call is processed.

The bug affects get_fcall_value_type in init.til (line 651) but NOT
is_expr_calling_procs in typer.til (same pattern, but generates correctly).

*** Reproducing Test
src/test/bug44_test.til

*** Files to Investigate
- src/rs/ccodegen.rs: emit_stmts, local_catch_labels handling
- Specifically the logic at lines 3215-3233 where next_catches is built
- Compare what's different about init.til vs typer.til that causes only one to fail

** Bug #43: Map.get returns wrong value when Map is field inside struct (rstil interpreter)
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Data corruption in interpreter
:STATUS: Fixed
:END:

*** Description
When a Map is stored as a field inside a struct, the rstil interpreter's Map.get returns incorrect values (0 instead of actual stored value). The compiled version (rstil run) works correctly.

*** Example Problem
#+BEGIN_EXAMPLE til
import("std.map")

Frame := struct {
    mut funcs: Map = Map.new(Str, I64)
}

test_map_in_struct := proc() {
    mut frame := Frame()
    frame.funcs.insert("test", 42)

    mut val := 0
    frame.funcs.get("test", val)
    println("Got value = ", val.to_str())  // BUG: prints 0, should print 42
}
#+END_EXAMPLE

*** Test Results (Before Fix)
- =rstil interpret tmp/test_scope_pattern.til= -> val = 0 (WRONG)
- =rstil run tmp/test_scope_pattern.til= -> val = 42 (CORRECT)

*** Root Cause
Three issues were discovered when structs have nested struct defaults like =Map.new(Str, I64)=:

1. *Vec.ptr not initialized*: When struct templates were created, ptr fields were
   skipped (to avoid dangling pointers), but Vec.push didn't check for ptr=0.
   This caused pushes to write to NULL memory when Vec was part of a struct default.

2. *Str fields not copied*: read_struct_primitive_fields only read I64/U8 values.
   Str fields like =key_type_name= weren't being read from the evaluated instance,
   causing Map to have empty type names and fail key comparisons.

3. *Vec.cap not preserved*: The Vec's capacity from Vec.new was lost because nested
   struct fields weren't being recursively read. This caused malloc(0) in Vec.push.

*** Fix Applied (2025-12-18)

*Part 1: Vec.push null pointer check* (src/core/vec.til lines 60-71)
Added check at start of push to allocate if ptr=0:
#+BEGIN_SRC til
if self.ptr.eq(0) {
    if self.cap.eq(0) {
        self.cap = Vec.INIT_CAP
    }
    self.ptr = malloc(mul(self.cap, self.type_size))
    if NULL.eq(self.ptr) {
        throw AllocError(msg=format(loc(), "Vec.push: malloc failed"))
    }
}
#+END_SRC

*Part 2: read_struct_primitive_fields* (src/rs/interpreter.rs lines 214-279)
New function that reads primitive values from evaluated struct instances:
- Reads I64 values (skipping ptr/c_string to avoid dangling pointers)
- Reads U8 values
- Reads Str values using string_from_context (gets actual string content)
- Recursively reads nested struct primitive fields (Vec, etc.)

*Part 3: eval_struct_defaults* (src/rs/interpreter.rs lines 303-319)
After getting static defaults for nested structs, override with actual primitive
values from the evaluated instance:
#+BEGIN_SRC rust
let primitive_values = read_struct_primitive_fields(ctx, &instance_id, type_name, "", e)?;
for (k, v) in primitive_values {
    defaults.insert(format!("{}.{}", decl.name, k), v);
}
#+END_SRC

*Part 4: TIL port* (src/self/interpreter.til lines 138-219, 304-316)
Same changes ported to the self-hosted interpreter.

*** Reproducing Test
src/test/bug43_test.til (now passes both interpret and run)

*** Files Modified
- src/rs/interpreter.rs: Added read_struct_primitive_fields, modified eval_struct_defaults
- src/rs/eval_arena.rs: Minor cleanup
- src/core/vec.til: Added null pointer check in Vec.push
- src/self/interpreter.til: Ported fix to TIL version

** Bug #40: Precomp generates non-deterministic _for_i_ variable names
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Build reproducibility
:STATUS: Fixed
:END:

*** Description
The precomp phase generates `_for_i_N` variable names for desugared for-in loops using a global counter (`Arena::g().temp_id_counter`). This counter accumulates across file compilations, causing the same source code to produce different C output depending on compilation order or what was compiled before.

#+BEGIN_EXAMPLE
// First compilation produces:
til_I64 _for_i_159 = 0;

// Second compilation (same source) produces:
til_I64 _for_i_160 = 0;
#+END_EXAMPLE

This makes diffs between generated C files noisy and harder to review.

*** Root Cause
In precomp.rs (line 422-424), the `_for_i_` index variable name is generated using a global singleton counter:

#+BEGIN_SRC rust
let forin_id = Arena::g().temp_id_counter;
Arena::g().temp_id_counter += 1;
let index_var_name = format!("_for_i_{}", forin_id);
#+END_SRC

Unlike ccodegen's `next_mangled()` which was fixed to reset per-function and include function name prefix, precomp still uses this global counter.

*** Related
- ccodegen's `_tmp_` variables were fixed to be deterministic (counter moved to CodegenContext, reset per-function, includes function name prefix)
- interpreter.rs also uses `Arena::g().temp_id_counter` for return instance names

*** Proposed Fix
Apply similar pattern as ccodegen fix:
1. Add function name context to precomp (track current function being processed)
2. Reset counter when entering each function in `precomp_func_def`
3. Include function name in generated variable name: `_for_i_funcname_N`

*** Files to Modify
- src/rs/precomp.rs: Add counter reset in precomp_func_def, modify index_var_name format
- src/self/precomp.til: Same changes ported

*** Fix Details
Added two new fields to Context:
- `current_precomp_func`: Tracks the current function being processed (Option<String> in Rust, Str in TIL)
- `precomp_forin_counter`: Per-function counter for _for_i_ variable names

Modified three functions:
1. `precomp_declaration`: Sets function name and resets counter BEFORE processing function body
2. `precomp_struct_def`: Sets function name for struct method definitions (default values)
3. `precomp_forin`: Uses context fields instead of global counter, generates names like `_for_i_funcname_N`

Files modified:
- src/rs/init.rs: Added fields to Context struct
- src/rs/precomp.rs: Bug #40 fix in precomp_declaration, precomp_struct_def, precomp_forin
- src/self/init.til: Added fields to Context struct
- src/self/precomp.til: Same fixes ported

Test: src/test/deterministic.til

** Bug #52: Static buffer in ext.c til_i64_to_str caused string corruption
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Multiple to_str() calls before println showed wrong values
:STATUS: Fixed
:END:

*** Description
When multiple =to_str()= calls happened before =println= (e.g., printing two numbers),
they all showed the same value - the last one converted. This was because all calls
shared the same static buffer.

*** Root Cause
The =til_i64_to_str= function in =src/ext.c= used a static buffer:
#+BEGIN_SRC c
static char buf[32];  // SHARED BY ALL CALLS!
snprintf(buf, sizeof(buf), "%lld", (long long)v);
#+END_SRC

Each =to_str()= call returned a Str pointing to this same buffer. When a second
call happened, it overwrote the buffer, making both Strs show the second value.

*** Fix
Changed =til_i64_to_str=, =til_input_read_line=, and =til_run_cmd= in =src/ext.c=
to allocate memory with =malloc()= instead of using static buffers.

*** Regression Test
src/test/bug52_test.til - tests reading global variables inside for-in loops
with multiple =to_str()= calls to detect buffer sharing issues.

*** Notes
Discovered while investigating Bug #47 (NodeType corruption). The static buffer
issue explained why debug output showed wrong values, but Bug #47 itself is a
different issue that remains open.

** Bug #53: String functions missing null termination
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Garbage characters in string output, potential memory corruption
:STATUS: Fixed (no regression test - see notes)
:END:

*** Description
String functions =clone()=, =concat()=, =format()=, and =replace()= in str.til
allocated memory without +1 for the null terminator and didn't write the null
byte. This caused garbage characters when strings were printed via C's printf.

*** Root Cause
All four functions used =malloc(cap)= instead of =malloc(cap.add(1))= and didn't
call =memset= to write the null terminator at position =cap=.

*** Fix Applied (2025-12-19)
Changed all four functions in src/core/str.til:
- =clone()=: malloc(cap.add(1)), memset null at cap
- =concat()=: malloc(cap.add(1)), memset null at cap
- =format()=: malloc(cap.add(1)), memset null at cap
- =replace()=: malloc(new_len.add(1)), memset null at cap

*** Regression Test
No regression test was created because the bug cannot be reliably reproduced in
a unit test. The issue only manifests when malloc returns memory with non-zero
bytes at position =cap= (outside the allocated region without the fix). Modern
allocators typically return zeroed memory, making the bug appear to not exist
even without the fix.

The bug was discovered during Bug #47 investigation when "NodeType.?" garbage
appeared in debug output. This occurred because the heap was heavily fragmented
during ./bin/til execution, causing non-zero bytes to appear at string boundaries.

*** Files Modified
- src/core/str.til: Fixed clone, concat, format, replace functions

** Bug #41: mode liba not respected when file is imported
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Debugging, purity rules
:STATUS: Fixed
:END:

*** Description
When a file with `mode liba` is imported into another file (e.g., `mode cli`), the purity rules of the importing file apply instead of the imported file's mode. This means `func` definitions in `mode liba` files cannot call `print`/`println` when imported, even though `mode liba` is supposed to allow print in funcs for debugging.

*** Root Cause
The typer phase's `typer_import_declarations` function only saved and restored `context.path` when type-checking imported files, but did not save and restore `context.mode_def`. This caused the importing file's mode to be used for type checking the imported file.

*** Fix Applied (2025-12-17)
Two-part fix:

1. *Store mode during init phase* (src/rs/init.rs, src/self/init.til):
   - Added `imported_modes: HashMap<String, ModeDef>` to Context struct
   - In `init_import_declarations`, store the imported file's mode alongside its AST

2. *Use stored mode during type checking* (src/rs/typer.rs, src/self/typer.til):
   - In `typer_import_declarations`, retrieve stored mode and set `context.mode_def`
   - Save and restore both `context.path` AND `context.mode_def`

Also added `ModeDef.clone()` method to src/self/mode.til for proper mode copying.

*** Test Coverage
Regression test: src/test/bug41_test.til

*** Files Modified
- src/rs/init.rs: Added imported_modes field, store mode during import
- src/rs/typer.rs: Save/restore mode_def in typer_import_declarations
- src/self/init.til: Same changes ported
- src/self/typer.til: Same changes ported
- src/self/mode.til: Added ModeDef.clone() method
- src/test/bug41_test.til: Regression test
- src/test/bug41_liba_helper.til: Helper file for test

** Bug #39: Non-consecutive catches fail - second catch never executes
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-16
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

Related: Bug #34 (same underlying goto structure issue)

*** Description
When a function has multiple throw+catch pairs separated by code, only the first catch works. The second catch block never executes because the code generator's goto structure jumps past subsequent throw+catch pairs after the first catch completes.

#+BEGIN_EXAMPLE til
throw_a_maybe(true)  // throws ErrorA
after_a_ran = true   // correctly skipped
catch (err: ErrorA) { caught_a = true }

throw_b_maybe(true)  // throws ErrorB - NEVER EXECUTES!
after_b_ran = true
catch (err: ErrorB) { caught_b = true }  // NEVER EXECUTES!
#+END_EXAMPLE

*** Root Cause
The C code generator groups ALL catches at the end with shared labels:

#+BEGIN_SRC c
if (_status_A == 1) { goto _catch_A; }
if (_status_B == 1) { goto _catch_B; }
goto _end_catches;

_catch_A: { ... goto _end_catches; }  // BUG: jumps PAST throw_b_maybe!
_catch_B: { ... }
_end_catches:;
#+END_SRC

After catching ErrorA, ~goto _end_catches~ jumps past the second throw+catch entirely. The second throwing call never executes.

*** Proposed Fix
Instead of shared goto labels, use if-else blocks for each throw+catch pair:

#+BEGIN_SRC c
// First throw+catch
int _status_A = call_a();
if (_status_A == 0) {
    after_a_ran = true;
} else if (_status_A == 1) {
    // catch A body
}

// Second throw+catch - executes regardless of first catch
int _status_B = call_b();
if (_status_B == 0) {
    after_b_ran = true;
} else if (_status_B == 1) {
    // catch B body
}
#+END_SRC

*** Files to Modify
- src/rs/ccodegen.rs: emit_stmts, emit_throwing_call_with_goto
- src/self/ccodegen.til: Same changes ported

*** Test Coverage
Tests added in src/test/errors.til:
- test_non_consecutive_catches
- test_caller_callee_different_throws
- test_multi_throw_single_catch
- test_multi_throw_success

*** Fix Applied
Key changes to ccodegen.rs and ccodegen.til:

1. **Call ~next_mangled()~ inside the loop, not before** - Previously called once
   before the loop, giving all catches the same suffix. Now called for EACH catch,
   so multiple catches of the same error type get different labels.

2. **Store statement index with each catch** - ~all_catch_info~ tracks
   ~(stmt_index, type_name, label, temp_var, catch_block)~ to match throwing
   calls to their NEXT catch by position in the source.

3. **Emit catches inline with ~if(0) { label: }~** - Instead of grouping all
   catches at the end with ~goto _end_catches~, catches are emitted inline where
   they appear. The ~if(0)~ block is skipped in normal execution but ~goto~ can
   jump into it. Execution falls through after the catch body.

4. **Update ~local_catch_labels~ before each throwing call** - Clear and rebuild
   with only catches AFTER current statement position. Each throwing call now
   jumps to its correct NEXT catch, not always the first one.

5. **Only use immediate-catch optimization when ~func_level_catches.is_empty()~** -
   Prevents inline handling when the catch is also needed by earlier throwing calls
   (which need the label to be emitted).

Also added ~Map.clear()~ method to src/std/map.til, and removed unused
~get_variant_payload_type~ function from init.rs.

** Bug #38: Vec.get doesn't preserve enum payload values
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When storing enums with payloads in a Vec and retrieving them with Vec.get, the enum tag is preserved but the payload value is corrupted.

#+BEGIN_EXAMPLE til
PayloadEnum := enum {
    None,
    Number: I64,
    Text: Str,
}

p := PayloadEnum.Number(42)
mut items := Vec.new(PayloadEnum)
items.push(p)

mut out := PayloadEnum.None
items.get(0, out)

// Expected: out is PayloadEnum.Number(42)
// Actual: out is PayloadEnum.Number(2745) - payload corrupted
#+END_EXAMPLE

*** Root Cause
When passing an enum constructor like `PayloadEnum.None` to a Dynamic parameter (as in Vec.push),
the argument binding code incorrectly identified `PayloadEnum` as a type identifier (because TEnumDef
is a TType) and stored just the type name string instead of the actual enum value. This caused the
enum data to not be inserted into the function frame, resulting in memcpy reading from garbage memory.

The issue was in interpreter.rs at the Dynamic/Type parameter handling: the code checked if the
identifier resolved to a TType but didn't check if the expression had params (field access).
`PayloadEnum.None` has params (the `.None` access), so it should NOT be treated as a bare type.

*** Fix
Added a check for `current_arg.params.is_empty()` before treating an identifier as a type identifier.
This ensures enum constructors like `PayloadEnum.None` fall through to normal enum handling.

Files changed:
- src/rs/interpreter.rs: Added params.is_empty() check in Dynamic/Type handling
- src/self/interpreter.til: Same fix ported to self-hosted version

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_payload() (enabled)

** Bug #37: Vec.push with direct enum constructor doesn't store data correctly :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When pushing an enum value directly using a constructor expression (e.g., `colors.push(SimpleColor.Red)`), the data is not stored correctly in the Vec. However, pushing via a variable works correctly.

#+BEGIN_EXAMPLE til
SimpleColor := enum { Red, Green, Blue }

mut colors := Vec.new(SimpleColor)

// This FAILS - data is corrupted:
colors.push(SimpleColor.Red)

// This WORKS:
c := SimpleColor.Red
colors.push(c)
#+END_EXAMPLE

*** Root Cause (Found)
The bug was in the interpreter's handling of Dynamic parameters. When an enum constructor expression like `SimpleColor.Green` was passed to a Dynamic parameter:

1. The parser creates an Identifier("SimpleColor") node with params [Identifier("Green")]
2. The interpreter checked if "SimpleColor" was a type reference (TType)
3. Since SimpleColor is an enum type definition, it matched as TType
4. The code incorrectly treated it as a bare type reference, storing "SimpleColor" as a string
5. This caused to_ptr(value) to return the wrong arena offset

*** Fix (2025-12-15)
Added check for `current_arg.params.is_empty()` before treating an identifier as a type reference:

*interpreter.rs (line 1938):*
#+BEGIN_SRC rust
if current_arg.params.is_empty() {
    if let Some(sym) = context.scope_stack.lookup_symbol(id_name) {
        if let ValueType::TType(_) = &sym.value_type {
            // Only treat as type reference if params are empty
        }
    }
}
#+END_SRC

*interpreter.til (line 2022):*
#+BEGIN_SRC til
if current_arg.params.len().eq(0) {
    // Only treat as type reference if params are empty
}
#+END_SRC

Workarounds in std/map.til were also removed - now uses Vec.push() directly.

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_direct_push() (enabled)

** Bug #35: Special `_` variable does not allow repeated declarations :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
The special `_` variable (used for discarding return values) throws "already declared" errors when used multiple times in the same scope.

#+BEGIN_EXAMPLE til
// This should work (both values are discarded):
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)  // ERROR: '_' already declared
#+END_EXAMPLE

*** Fix (2025-12-14)
Modified type checker and code generator to special-case "_" declarations:

*Type checker (init.rs, init.til):*
1. In =declare_var()=: Skip the "already declared in this scope" check when name is "_"
2. In =init_context()= Declaration handler: Skip the "already declared" check when name is "_"

*Code generator (ccodegen.rs, ccodegen.til):*
1. In =emit_constant_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
2. In =emit_global_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
3. In =emit_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations

This approach:
- Allows multiple "_" declarations in the same TIL scope
- Generates unique C variable names (like =_tmp0=, =_tmp1=) to avoid C redefinition errors
- Evaluates the RHS expression for its side effects (return value is discarded)

*** Now Works
#+BEGIN_EXAMPLE til
// Both values are discarded - no error
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)
#+END_EXAMPLE

*** Test Coverage
- src/test/underscore.til: Tests multiple "_" declarations at both top-level and function scope

*** Files Modified
- src/rs/init.rs: declare_var, init_context
- src/rs/ccodegen.rs: emit_constant_declaration, emit_global_declaration, emit_declaration
- src/self/init.til: declare_var, init_context
- src/self/ccodegen.til: emit_constant_declaration, emit_global_declaration, emit_declaration

** Bug #33: for-in loops don't work with enum collections
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:FIXED: 2025-12-15
:END:

*** Description
The for-in loop syntax doesn't work when iterating over collections of enum values (e.g., Vec<ValueType>).

#+BEGIN_EXAMPLE til
// This fails:
for val: ValueType in vec_of_valuetypes {
    // ...
}
#+END_EXAMPLE

*** Root Cause
The for-in desugaring in precomp.rs creates code like:

#+BEGIN_EXAMPLE til
for _for_i in 0..collection.len() {
    mut val := ValueType()    // <-- Problem: no parameterless constructor
    collection.get(_for_i, val)
    // body
}
#+END_EXAMPLE

For structs, `StructName()` creates a default-initialized instance. But enums don't have a parameterless constructor - all variants require payloads (e.g., `ValueType.TCustom(Str)`, `ValueType.TFunction(FunctionType)`).

*** Fix Applied
Changed for-in desugaring to detect when the iteration type is an enum and generate
an appropriate placeholder value using the first variant:
- For variants without payload: `EnumType.FirstVariant`
- For variants with payload: `EnumType.FirstVariant(default_payload)`

The placeholder value is immediately overwritten by the get() call, so any valid
variant works as an initializer.

*** Files Changed
- src/rs/precomp.rs: Added build_default_value() helper and updated precomp_forin()
- src/self/precomp.til: TIL port with build_default_value_for_forin() and updated precomp_forin()
- src/test/forin_enum.til: Regression test
- src/tests.til: Added forin_enum.til to test suite
- src/test/run_cmd.til: Updated directory list (bots/ removed, c/ and out/ added)

*** Affected Code
- src/self/typer.til: Converted for-in loops over ValueType to while loops
- src/self/ccodegen.til: Same workaround applied

** Bug #32: TIL doesn't support chained field access + method calls
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
TIL doesn't support chained field access followed by method calls like:
#+BEGIN_EXAMPLE til
lexer.peek().token_type.eq(TokenType.Colon)
#+END_EXAMPLE

This causes parse errors like:
#+BEGIN_EXAMPLE
Expected '(' after method name 'token_type', found 'Dot'
#+END_EXAMPLE

Or type errors like:
#+BEGIN_EXAMPLE
Cannot call 'peeked.token_type', it is not a function, it is 'TokenType'
#+END_EXAMPLE

*** Fix
Parser now handles field access after function/method calls by using
Identifier("_") as a marker where params[0] holds the base expression
and params[1..] holds the field chain. Changes in parser, init, typer,
interpreter, and ccodegen (both Rust and TIL).

Tests added to src/test/structs.til.

*** Affected Code
- src/self/parser.til: parse_for_statement (workaround removed)

** Bug #36: Throwing functions in struct literal parameters not recognized :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Type checker correctness
:STATUS: Fixed
:END:

*** Description
When calling a throwing function inside struct literal named parameters, the compiler failed to recognize that the function throws and incorrectly reported that the error type is never thrown.

*** Fix
Modified =check_body_returns_throws= in typer.rs/typer.til to:
1. Handle =NamedArg= nodes inside function call arguments
2. Check arguments of struct/enum constructors (=Ok(None)= / =KeyNotFoundError= case)
3. Track thrown types from nested function calls in both cases

*** Changes
- src/rs/typer.rs: Added NamedArg handling and struct constructor argument checking
- src/self/typer.til: Ported same fix from Rust
- src/std/map.til: Removed workaround (can now inline clone() calls)
- src/self/init.til: Added throws declarations to clone() functions
- src/test/errors.til: Regression test (test_bug36)

** Bug #31: Switch on struct field with pattern matching fails :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-06
:FIXED: 2025-12-06
:IMPACT: Self-hosting, pattern matching
:STATUS: Fixed
:END:

*** Description
When using =switch= on a struct field that is an enum (e.g., =switch s.color=), pattern matching with payload extraction failed with "Enum definition for 'StructName' not found" error.

*** Example Problem
#+BEGIN_EXAMPLE til
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)
    switch s.color {
    case Color.Number(n): result = n  // FAILED: Enum definition not found
    case: result = 0
    }
}
#+END_EXAMPLE

*** Root Cause
Two issues in interpreter and arena code:

1. *Pattern matching code extracted only base identifier* (interpreter.rs:390-394):
   When processing =switch s.color=, the code only extracted "s" from =to_switch.node_type= instead of constructing the full path "s.color".

2. *get_enum didn't resolve field types* (arena.rs:764+):
   =get_enum= looked up the base variable's type instead of the field's type. For "s.color", it got =StructWithPayloadEnum= instead of =Color=.

*** Fix (2025-12-06)
*Rust side:*

1. *interpreter.rs*: Modified pattern matching code to construct full field path from to_switch expression params:
#+BEGIN_SRC rust
let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
    if !to_switch.params.is_empty() {
        let mut full_path = name.clone();
        for param in &to_switch.params {
            if let NodeType::Identifier(field_name) = &param.node_type {
                full_path.push('.');
                full_path.push_str(field_name);
            }
        }
        full_path
    } else {
        name.clone()
    }
} else { /* error */ };
#+END_SRC

2. *arena.rs*: Modified =get_enum= to use =get_field_type= for dotted paths:
#+BEGIN_SRC rust
let enum_type = if id.contains('.') {
    match ctx.get_field_type(id) {
        Ok(ValueType::TCustom(type_name)) => type_name,
        // ... error handling
    }
} else {
    // original lookup_symbol logic
};
#+END_SRC

3. *init.rs*: Added =get_field_type= function to resolve the ValueType for a field path.

*TIL side:*
- Ported same changes to interpreter.til, arena.til, and init.til

*** Test Coverage
- src/test/enums.til: =test_switch_on_struct_field= (simple switch on field)
- src/test/enums.til: =test_switch_on_struct_field_with_payload= (pattern matching with payload)

** Bug #30: ext_proc signature mismatch between TIL and Rust :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-03
:FIXED: 2025-12-03
:IMPACT: Type safety
:STATUS: Fixed
:END:

*** Description
=single_print= was incorrectly declared as variadic (=..Str=) in TIL, but =proc_single_print= in ext.rs expects exactly 1 argument.

*** Problem
#+begin_src til
// Wrong declaration (variadic):
single_print := ext_proc(args: ..Str);

// Both pass type check AND runtime (variadic wraps args into Array):
single_print("one")        // Works: Array with 1 element
single_print("one", "two") // Also "works": prints Array representation
#+end_src

*** Why It Wasn't Caught
Variadic parameters get wrapped into an Array before being passed to ext.rs. So =validate_arg_count= sees 1 argument (the Array), passing validation. The function then prints whatever =result.value= is - which would be the Array's string representation instead of the expected Str.

*** Fix (2025-12-03)
1. Changed declaration from variadic to single parameter in core.til:
#+begin_src til
// Correct declaration:
single_print := ext_proc(s: Str);
#+end_src

2. Added warning comment to =proc_single_print= in ext.rs referencing Bug #30.

*** Systemic Issue
The compiler cannot verify that ext_proc TIL declarations match their Rust implementations. Variadic wrapping bypasses =validate_arg_count= by passing all args as a single Array. This is an inherent FFI limitation.

** Bug #28: UFCS fails inside pattern match case bodies with bindings :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-02
:FIXED: 2025-12-02
:IMPACT: Self-hosting, type checking
:STATUS: Fixed
:END:

*** Description
UFCS method calls failed with "Could not find function definition" when inside pattern match case bodies that have bindings (e.g., =case Enum.Variant(binding):=).

*** Root Cause
The =check_body_returns_throws= function ran without proper scope tracking:
1. Pattern binding variables weren't declared in the scope
2. Local variables declared within case bodies weren't visible

*** Fix (2025-12-02)
Added proper scope management to =check_body_returns_throws= in =typer.rs=:

1. *Pattern binding scope*: When processing switch cases with pattern bindings, push a Block scope and declare the binding variable with its payload type (mirrors =check_switch_statement=).

2. *Variable declarations*: When processing Declaration nodes, infer the type from the initializer and declare the variable in the current scope (if not already declared).

Files modified:
- =src/rs/typer.rs= lines 767-825 (NodeType::Switch handler)
- =src/rs/typer.rs= lines 828-845 (NodeType::Declaration handler)

*** Test Coverage
- =src/test/ufcs.til=: =test_ufcs_struct_field_in_pattern_match=
- =src/test/enums.til=: =test_bug28_ufcs_push_in_binding=, =test_bug28_ufcs_len_in_binding=

All tests pass.

** Bug #29: Catch variable not accessible in arena :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-19
:FIXED: 2025-11-19
:IMPACT: Error handling, catch blocks
:STATUS: Fixed
:END:

*** Description
Caught error variable (=err=) not properly stored in execution arena. Accessing =err.msg= in catch block caused:
- Type error: "Undefined symbol 'err'"
- Runtime error: "base variable 'err' not found in arena_index"

Affected: =throw err.msg=, =return err.msg=, =msg = err.msg= - any field access on caught errors.

*** Fix (2025-11-19, commit 0024caa)
Properly register catch parameter in both interpreter and typer:
- =interpreter.rs=: Register base variable when propagating throws (line 3020) and in catch fallback (line 2438)
- =typer.rs=: Create temp_context with catch parameter before type-checking catch body (lines 665-692)

*** Test Coverage
- =src/test/errors.til=: =test_rethrow_error_field= (tests =throw err.msg=)
- =src/test/errors.til=: =test_rethrow_error_field_via_assign= (tests =msg = err.msg= then =throw msg=)

** Bug #1: Enum Comparison in Switch/Case

- *Status*:  NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*:  NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*:  FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*:  FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*:  FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*:  FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*:  FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*:  FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     //  Prints
    lexer.expect(TokenType.LeftParen)      //  Causes function to return!
    println("[DEBUG 2] After expect")      //  Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
//  Capture the return value
result := my_add(1, 2)

//  Use as argument to another function
double(my_add(3, 4))

//  Explicitly discard with _
_ := get_value()

//  Procs don't return values, no capture needed
print_hello()

//  ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*:  FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

** Bug #27: Cannot inline Vec.new() as function argument :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-18
:FIXED: 2025-11-18
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
The TIL evaluator cannot handle inline Vec.new(Expr) calls when passed as arguments to functions. This requires creating a variable first instead of passing the expression directly.

*** Example Problem
#+BEGIN_EXAMPLE til
// Rust does (parser.rs:1180):
return Ok(Expr::new_explicit(
    NodeType::Pattern(pattern_info),
    Vec::new(),  // Inline Vec::new() works
    left.line,
    left.col
));

// TIL must do (parser.til:1326-1330):
empty_params := Vec.new(Expr)  // Create variable first
return Expr.new_explicit(NodeType.Pattern(pattern_info), empty_params, left.line, left.col)
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil eval ERROR: Struct argument must be an identifier or field access
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 1780-1796

When evaluating function calls with struct arguments, the evaluator checks if the parameter is marked as 'own'. For non-own struct parameters, it requires the argument to be an identifier or field access (not an arbitrary expression).

The 'params' parameter in Expr.new_explicit is declared as 'params: Vec' (not 'own Vec'), so inline expressions like Vec.new(Expr) are rejected.

*** Fix (2025-11-18)
Modified interpreter.rs to allow non-identifier expression arguments for struct parameters:

1. Lines 1778-1782: For field access chains with expressions, use result_str
2. Lines 1787-1795: For simple expressions (like Vec.new()), use result_str
3. Lines 1899-1904: For non-Identifier node types, allocate struct and copy fields from result_str

The key insight: when an expression is evaluated (like Vec.new(Expr)), the result
is allocated in the arena and result_str contains the identifier. We can use this
to copy the struct to the parameter, just like we do for identifier arguments.

*** Now Works
#+BEGIN_SRC til
// Can inline Vec.new(Expr) directly as argument
return Expr.new_explicit(NodeType.Pattern(pattern_info), Vec.new(Expr), left.line, left.col)
#+END_SRC

*** Previous Workaround (No Longer Needed)
#+BEGIN_SRC til
// Old workaround - create variable first
empty_params := Vec.new(Expr)
return Expr.new_explicit(..., empty_params, ...)
#+END_SRC

** Bug #26: Nested struct corruption in Vec/Map :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-17
:FIXED: 2025-11-17
:IMPACT: Data integrity, collection storage
:STATUS: Fixed
:COMMIT: ea8cd2b
:END:

*** Description
When structs containing nested structs (like Vec, Map, List) were stored in collections, the nested structs were allocated separately instead of inline, causing memory corruption.

*** Fix
Modified insert_struct_at_offset in init.rs to accept optional existing_offset parameter, allowing nested structs to be allocated inline within parent's memory block.

*** Commit
ea8cd2b: Fix Bug #26: nested struct corruption in Vec/Map

** Bug #25: Field offset refactor breaks typer method resolution :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-13
:FIXED: 2025-11-13
:IMPACT: API consistency, method resolution
:STATUS: Fixed - uniform len() API implemented
:END:

*** Description
The typer fails to find I64.eq method when chaining method calls on struct field access (e.g., `s.items.len.eq(0)`). This was discovered during field offset refactoring work but the root cause was different.

*** Example Problem
#+BEGIN_EXAMPLE til
// In ufcs.til line 300 - this WORKS:
items_len := s.items.len

// In ufcs.til line 304 - this FAILS:
len_check := s.items.len.eq(0)  // Error: "Could not find function definition"
#+END_EXAMPLE

The field access works, but method resolution on the result fails!

*** Root Cause (FOUND!)
The real issue was NOT the field offset refactor, but an API inconsistency:
- Vec, List, and Array had `len` as a FIELD instead of a METHOD
- When the typer tried to resolve `s.items.len.eq(0)`, it saw `.len` as a field access
- Field accesses return `auto` type (requiring type inference)
- The typer couldn't properly infer the type for chained method calls
- Result: "Could not find function definition" for `.eq(0)`

This became apparent when `s.items.len` was accessed - it worked as a field, but the moment you tried to call a method on the result, type resolution failed.

*** Solution (2025-11-13)
Implemented uniform len() API across all collection types:

1. **Renamed internal fields**: `len`  `_len` (cap kept as-is)
2. **Added uniform methods**:
   - `len()` returns element count (_len)
   - `size()` returns byte size (len * type_size)
3. **Implemented for**: Vec, List, Array (src/core/core.til)
4. **Updated all code** to use `.len()` method calls:
   - Core library: lexer.til, parser.til, typer.til, interpreter.til
   - Test files: ufcs.til, args.til, arrays.til, dynamic_arrays.til, lists.til, maps.til, mut_test.til, variadic.til
5. **Updated interpreter**: init.rs to look for `._len` field offset
6. **For-loop workaround**: Store `len()` in local variable (e.g., `mut args_len := args.len()`)

*** Now Works
#+BEGIN_EXAMPLE til
//  All these patterns now work correctly:
items_len := s.items.len()
len_check := s.items.len().eq(0)
if i.lt(s.items.len().add(5)) { }
comparison := i.lt(e.params.len())
#+END_EXAMPLE

*** Test Coverage (Regression Prevention)
The existing test file `src/test/ufcs.til` provides comprehensive regression coverage:

**test_bug10_fixed()** (lines 296-317):
- Line 304: `len_check := s.items.len().eq(0)` - EXACT failing pattern
- Line 309: `comparison := i.lt(s.items.len().add(5))` - Chained method calls
- Line 314: `name_len := name.len()` - String len() method

**test_bug10_parser_patterns_fixed()** (lines 320-341):
- Line 334: `len_is_zero := e.params.len().eq(0)` - Another instance of failing pattern
- Line 338: `len_plus_five := e.params.len().add(5)` - Arithmetic on method result

These tests run in the standard test suite and will catch any regression
that breaks chained method calls on field access. All tests pass (exit code 0).

*** Commits
- 27dc3ae: Fix Bug #25: Implement uniform len() API for Vec, List, and Array
- 1444a8b: Complete len() API standardization - fixes Bug #25

** Bug #24: Variable Declarations Share Arena Offsets Instead of Copying :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Fixed - mut declarations now copy
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Fix Applied

**Design Decision**: Only mut declarations create copies. Non-mut declarations share offsets (read-only aliases).

**Implementation** (src/rs/interpreter.rs lines 923-935):
- **mut declarations**: Call insert_struct() + copy_fields() to create independent copy
- **non-mut declarations**: Share arena offset (efficient, type checker enforces immutability)

**Result**:
#+BEGIN_SRC til
mut dup := original  // Creates independent copy
dup := original      // Shares offset (read-only alias)
#+END_SRC

This design aligns with Mojo's ownership model:
- mut = mutable copy (prevents aliasing)
- default = reference (efficient, safe with type checker)
- Future: 'own' keyword for ownership transfer

See doc/ownership.org for full design analysis and Mojo comparison.

**All tests pass**, including test_declaration_creates_copy (args.til:484)

** Bug #24: Struct Field Access Returns Copy Instead of Reference :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-18
:IMPACT: Data structure mutation, memory management
:STATUS: Fixed - Pass-by-reference for field access
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Fix Applied (2025-11-18)

Bug #24 was fixed as part of implementing pass-by-reference for field access parameters and fixing Bug #26.

**Three-part solution:**

*Fix 1: Inline nested struct allocation* (init.rs:1510-1625)
- Modified insert_struct_at_offset to accept optional existing_offset
- Nested structs now allocated inline within parent's memory block
- Previously: nested structs allocated separately, causing corruption

*Fix 2: Pass-by-reference for field access parameters* (interpreter.rs:1820-1872)
- Extended pass-by-ref to field access like `self.type_names.push(...)`
- Share arena offset instead of allocating and copying
- Register field symbols for UFCS method resolution
- Previously only simple identifiers used pass-by-ref

*Fix 3: Zero-copy return value transfers* (interpreter.rs:970-985)
- Detect temporary return values and share offset instead of copy
- mut x := func() now zero-copy (transfers ownership)
- Only copy when source is real variable (preserves Bug #25 fix)

**Result:**
The workaround pattern is no longer needed. Direct field mutations now work:

#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  //  NOW WORKS - modifies via reference!
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

**Test Coverage:**
- src/test/tmp/test_bug24.til - Comprehensive test verifying direct field mutations
- All existing tests pass with the fix

**Note on Workarounds:**
While the bug is fixed, existing workarounds (copy-modify-reassign pattern) can remain for now
as they are functionally equivalent. Workarounds exist in:
- src/core/core.til (List.push, List.set, List.pop, etc.)
- src/core/lexer.til
- src/core/parser.til
- src/core/std.til (potentially)
They can be removed in a future cleanup pass to simplify the code and potentially improve performance.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` 
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` 
- Throw from regular function 

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` 

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  //  Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
