#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New bugs use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new bugs at the top of Active Bugs section.
# BOT: When fixed, move to the top of Fixed Bugs section in doc/todo/fixed.org.

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #172: Codegen bug returning for-in loop variable of same type as return type
:PROPERTIES:
:DISCOVERED: 2026-02-18
:IMPACT: SIGSEGV at runtime -- generated C reads uninitialized _ret and never writes return value
:STATUS: Open -- workaround is to use range-based loop instead
:END:

*** Problem
When a for-in loop variable has the same type as the function's return type,
and the loop variable is returned directly (e.g. `return member`), the C
codegen confuses the loop variable with the return value `_ret`. Two bugs in
the generated C:

1. Field access uses `_ret->field` instead of `loop_var->field`
2. Return statement does `return 0;` without setting `*_ret = *loop_var`

*** Reproduction
#+begin_src til
get_member := func(self: SStructDef, member_name: Str) returns Declaration throws Str {
    for member: Declaration in self.members {
        if member.name.eq(member_name) {
            return member  // BUG: codegen uses _ret->name instead of member->name
        }
    }
    throw format(loc(), "Member '", member_name, "' not found")
}
#+end_src

Generated C (wrong):
#+begin_src c
til_Declaration* til_Declaration_member;
til_Declaration_member = (til_Declaration*)_ref_forin_0.data;
if (til_Str_eq(&_ret->name, til_Str_member_name).data) {  // BUG: _ret not member
    return 0;  // BUG: never sets *_ret
}
#+end_src

*** Notes
- Returning a FIELD of the loop variable works fine (e.g. `return v.payload_type`)
- Only triggers when the loop variable type matches the function return type exactly
- Workaround: use `for i in 0..collection.len()` with `.get(i, var)` instead
- SStructDef.get_member left as range-based loop for this reason (commit 0e4f942b)

** Bug #170: Scope-exit deletion for local variables
:PROPERTIES:
:DISCOVERED: 2026-02-11
:IMPACT: Memory leak -- locals only deleted at function end (or never if catch blocks exist)
:STATUS: Open -- two approaches failed 2026-02-11, see implementation notes
:RELATED: Bug #165 (memory leak), Bug #159 (shallow copies), Issue #117 (ASAP destruction)
:END:

*** Problem
The garbager deletes local mut variables at function end only (and skips them
entirely if the function has catch blocks). Locals declared in inner scopes
(if/while/for) leak until function end or forever. copy/own params get ASAP
deletion after last use, but locals don't.

*** Design: unified scope-exit deletion
One concept: *delete at scope exit*. Every deletable variable gets deleted when
its declaring scope ends. All current deletion triggers are specific cases of
scope exit:

| Trigger                  | What it is                                    |
|--------------------------+-----------------------------------------------|
| ~}~ of if/while/for      | Scope exit for variables declared inside       |
| ~return~                  | Scope exit for entire function                 |
| ~throw~                   | Scope exit for entire function                 |
| ~own~ arg call            | Early scope exit for that one variable         |

Reverse declaration order within a scope naturally handles the container-
outlives-alias problem: ~elem := vec.get(0)~ is declared after ~vec~, so
~elem~ is deleted first, then ~vec~.

*** What the garbager needs to do

**** For each scope boundary (~}~ of if/while/for/block):
Insert ~Type.delete(var)~ for each deletable mut variable declared in that
scope, in reverse declaration order. Respect ~dont_delete~ as today.

**** For ~return~ statements:
Insert deletes for ALL in-scope deletable mut variables before the return.
Reverse declaration order, innermost scope first.

**** For ~throw~ paths:
Same as return -- delete everything in scope before the throw. But only
variables guaranteed to have been initialized (declared before the throw
point, not conditionally).

**** For ~own~ transfers:
Already handled: variable is consumed, removed from deletion candidates.

*** Open questions

1. *Const locals:* Should const locals also get scope-exit deletion (relying
   on reverse declaration order for safety), or only mut locals for now?
   Const locals are more likely to be aliases (field extractions), but reverse
   declaration order may handle that. Need to verify with concrete examples.

2. *Catch blocks:* Keep current conservative approach (skip all deletion if
   any catch exists) or implement smarter analysis (only skip variables whose
   initialization could be skipped by a throw)? Smarter is more complex but
   covers more functions since many functions have catch blocks.

3. *Scope tracking in garbager:* Currently does a flat scan of function body.
   Needs to understand nesting (if/while/for bodies are nested Expr params).
   The garbager already recurses into bodies for other transforms -- need to
   check if scope info is available or needs threading through.

4. *ccodegen impact:* If garbager inserts scope-exit deletes into the AST,
   ccodegen just emits them -- probably no ccodegen changes needed. Verify.

5. *Reassignment:* ~mut x := Str.new("a"); x = Str.new("b")~ -- the old value
   leaks. Scope-exit deletion only frees the final value. The old value needs
   clone-on-assign + delete-old-value semantics (Bug #159 territory, not this
   bug).

*** Implementation attempt 2026-02-11 -- two approaches failed

**** Attempt 1: ASAP deletion for top-level locals
Changed end-of-function locals to use ~find_last_use_index()~ (same as
copy/own params). Result: 89/92 tests failed with ~free(): invalid pointer~.

Root cause: shallow-copy aliasing (Bug #159). Pattern:
#+begin_example
mut tokens := lex("mode safe_script")
mut first_token := Token()
tokens.get(0, first_token)   // shallow copy -- first_token aliases tokens[0]
// ... more code using first_token ...
// ASAP: Vec.delete(tokens) inserted here (last direct reference to "tokens")
// ... first_token.text is now dangling -- freed with tokens
#+end_example

~Vec.get()~, ~Array.get()~, field access -- all do shallow memcpy. The
extracted value aliases heap pointers in the container. Deleting the container
ASAP frees the shared heap data while the alias is still live.

The original code comment was correct:
: // locals: at function end (shared offsets mean locals can alias).

ASAP deletion is only safe for copy/own params because the garbager inserts
~Type.clone()~ for those, giving them independent heap data.

**** Attempt 2: Collect inner-scope locals, delete at function end
Added ~collect_declarations_recursive()~ to scan Body nodes inside
if/while/for and add their declarations to the function-end deletion list.
Result: 69/92 tests failed with signal 11 (SIGSEGV).

Root cause: conditional initialization. Pattern:
#+begin_example
func foo(x: I64) {
    if x > 0 {
        mut thing := SomeStruct()   // only initialized when x > 0
    }
    // garbager inserts: SomeStruct.delete(thing)  -- SIGSEGV when x <= 0
}
#+end_example

Inner-scope variables are only initialized when the scope executes. Inserting
unconditional ~delete()~ at function end crashes when the scope was skipped.

**** What would work: scope-exit deletion in the Body handler
The correct approach: insert ~Type.delete(var)~ at the end of the BODY node
where the variable was declared, not at function end. This guarantees the
variable is initialized (we're inside the scope that declared it).

Still has the shallow-copy aliasing risk (Bug #159), but no worse than
current function-end deletion for top-level locals. The aliasing risk is
mitigated by reverse declaration order: if ~elem := vec.get(0)~ is declared
after ~vec~, then ~elem~ is deleted first, then ~vec~.

Needs:
- Modify ~garbager_recursive~ Body handler to scan for declarations and
  append deletes at body end
- Per-scope ~dont_delete~ / ~own_transfer~ filtering (or inherit from parent)
- Per-scope ~has_any_catch~ check
- Name collision avoidance: TIL has flat namespace, helper functions must not
  collide with ~collect_declarations_recursive~ in ccodegen.til

Also learned: name ~collect_declarations_recursive~ already exists in
ccodegen.til. TIL's flat namespace causes collision. Any new helpers in
garbager.til need prefixed names (e.g., ~garbager_collect_decls~).

** Bug #169: Get rid of memcmp
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Semantic correctness -- memcmp compares raw bytes (pointers, padding) not logical values
:STATUS: Step 1 done (pure TIL memcmp). Steps 2-4 blocked by Dynamic having no type dispatch.
:RELATED: Bug #166 (container type info duplication, memcmp elem_size=0 breakage)
:END:

*** Problem
Containers (Vec, Set, Map, HashMap) use ~memcmp~ to compare elements. This
compares raw struct bytes -- meaning pointer values, padding bytes, and all.
Two structs with identical logical content but different pointer addresses
(e.g. two Str with same text but different allocations) will compare as
NOT equal. Creates interpreted/compiled divergence.

*** Current usage (as of 2026-02-20)
7 call sites in production code, all in containers:
- set.til (3): insert, remove, contains -- element comparison
- vec.til (2): _is_str_type (type tag check) + contains (element comparison)
- map.til (1): key comparison for non-Str keys
- hashmap.til (1): key comparison for non-Str keys
All containers already special-case Str (using Str.eq()). memcmp is the
fallback for all other types. Works correctly for value types (I64, U8, Bool)
since their raw bytes ARE the value. Broken for any struct with heap pointers.

*** Blocker
Containers hold ~Dynamic~ parameters and use ~elem_type~ (a string) to know
the type. They already special-case Str. Could extend the pattern to dispatch
.eq() for other types, but that's a lot of per-type boilerplate. In practice
memcmp works for value types (I64, U8, Bool) which are the common case.
The real problem is only for struct types with heap pointers as container
elements, which is rare.

*** Plan
- Step 1: Replace ext_func memcmp with pure TIL implementation (DONE)
  Removed C/Rust/TIL-interpreter implementations. memcmp is now a regular
  TIL function in mem.til using byte-by-byte comparison via memcpy+to_ptr.
- Step 2: Extend elem_type dispatch to cover more types if needed
- Step 3: Remove memcmp entirely (or keep for low-level use only)

** Bug #165: Compiled TIL binary leaks 200-800x memory vs Rust
:PROPERTIES:
:DISCOVERED: 2026-02-10
:IMPACT: Compiled TIL programs use 200-800x more memory than equivalent Rust interpreter
:STATUS: Blocked by Bug #159 (shallow copies prevent safe ASAP deletion)
:RELATED: Bug #159 (shallow copies), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame copy leak), Issue #117 (ASAP destruction)
:END:

*** Description
The compiled TIL binary (generated C code) leaks memory massively compared to the
Rust interpreter. Clone/delete imbalance: ~2500 Str clones vs ~1850 Str deletes in
generated C code, leaving ~650 leaked Str allocations per test run.

*** Failed attempt: ASAP deletion for named locals (wip165 branch)
Branch ~wip165~ has 2 commits ahead of master implementing ASAP deletion for named
locals with alias/escape detection:

**** Rules implemented
- Rule A (alias detection): Skip delete if variable was assigned from another local
  (e.g., ~x := y~ -- deleting x would corrupt y's data via shared pointer)
- Rule B (escape detection): Skip delete if variable was passed to a function after
  its last read (value may have escaped into another data structure)
- Rule C (owned return): Only delete variables assigned from known-allocating functions
  (constructors, .new(), .clone(), .to_str(), .format(), .concat(), etc.)

**** Results
- All 98 tests pass in all 4 modes
- Zero memory improvement -- clone/delete ratio unchanged
- Root cause: most leaks come from shallow copies (memcpy of structs with heap
  pointers), not from missing deletes of named locals

**** Why ASAP deletion doesn't help
The ~650 leaked Str allocations come from:
- Function return values (shallow memcpy at call site)
- Container operations (get/push/set all use copy_to_dynamic/copy_from_dynamic)
- Temporary expressions (_tmp_ variables holding intermediate results)

None of these are named locals that ASAP deletion can target. The fundamental
problem is Bug #159: shallow copies create hidden aliases that make it unsafe
to delete anything without risking double-free.

*** Blocked by
Bug #159 must be resolved first. Until shallow copies are eliminated, any
deletion strategy risks double-free on aliased heap pointers.

** Bug #159: Shallow copy semantics for structs with Ptr/Vec fields (REOPENED)
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Memory corruption, prevents ASAP deletion, root cause of memory leaks
:STATUS: Open -- interpreter copy_fields removed; ccodegen shallow copies remain; deep Vec.clone/delete blocked on Issue #91 (function pointers); Map.get eliminated, cast replaces create_alias
:RELATED: Bug #165 (memory leak blocked by this), Bug #168 (ccodegen return copies), Bug #114 (ScopeFrame leak), Bug #170 (scope-exit deletion blocked by this), Issue #91 (function pointers needed for deep clone/delete)
:END:

*** Description
When doing =mut cloned := original=, the interpreter used =copy_fields= which did
a byte-level copy. For structs containing Ptr or Vec fields, both the original and
clone shared the same underlying memory.

*** What was done (2026-02-07, originally declared fixed)
Removed =copy_fields= (shallow copy) from the interpreter. Replaced with:
1. Garbager inserts =Type.clone()= calls for struct-typed identifier args (4 sites)
2. Interpreter uses offset binding or memcpy instead of copy_fields

Steps completed:
- Step 1: preinit generates clone/delete methods
- Step 2: Dynamic type info added to Ptr
- Step 3: mut declarations (clone + offset binding)
- Step 4: Function copy params (clone + offset binding)
- Step 5: Struct literal fields (memcpy)
- Step 6: Assignment statements (memcpy)
- Step 7: Nested member assign + own params (memcpy), copy_fields deleted
- Step 8: Own params simplified to pure offset binding

Dead code removed: =copy_fields=, =SavedOffsets=, =insert_struct_instance_into_frame=,
=EvalArenaMapping= import.

Test: src/test/bug159.til (passes all 4 modes)

*** What remains -- shallow copies still present
The interpreter fix only addressed =copy_fields=. Shallow copies remain throughout
the codebase via memcpy in generated C code and core library operations.

**** 1. ccodegen -- Function return values (partially addressed by Bug #168)
- =*_ret = value;= -- 696 remaining (was 976, commits 1/1b/2 eliminated 280)
- Non-throwing by-value returns: 485 =return til_*= statements
- See Bug #168 in pre.org for full details and commit history

**** 2. src/core/ptr.til -- Raw memcpy operations
- =copy_to_dynamic= (line 108): =memcpy(to_ptr(dest), self.data, size)=
- =copy_from_dynamic= (line 103): =memcpy(self.data, to_ptr(src), size)=
- =copy_to= (line 93): =memcpy(dest.data, self.data, size)=
- =copy_from= (line 89): =memcpy(self.data, src.data, size)=
- =dereference= (line 113): =memcpy(to_ptr(dest), self.data, size)=
- =Ptr.clone= (line 72): copies struct bytes, shared heap pointer

**** 3. src/core/vec.til -- Collection operations using copy_to/from_dynamic
Handled by =dont_delete= in garbager: the shallow copies still happen, but the
aliased data is not double-freed. The copies still leak memory (root cause of #165).
- =get= REMOVED, =push=, =set=, =clone=, =extend=, =extend_with=, =contains=, =remove=,
  =insert_at=, =to_str=, =split_off=, =pop= -- all use copy_to/from_dynamic

**** 4. src/core/set.til -- Uses Vec internally, same dont_delete protection
- =insert=, =remove=, =contains=, =get= REMOVED -- copy_to_dynamic for comparison/retrieval

**** 5. src/core/array.til -- Direct memcpy, same dont_delete protection
- =get= REMOVED, =set=, =clone= -- copy_to/from_dynamic

**** 6. ccodegen -- enum_get_payload
- Shallow memcpy of enum payload data

**** 7. ccodegen -- create_alias directive (FIXED)
=create_alias= replaced by =cast(Type, Ptr)= which emits =Type* var = (Type*)ptr.data;=
-- true pointer aliasing, zero copy in both interpreter and ccodegen.

*** Step 9: Clone-after-get for container out-params (2026-02-11)
Container =get()= and =pop()= methods extract elements via =copy_to_dynamic=
(memcpy), creating shallow copies that alias the container's internal heap
pointers. The garbager now inserts =elem = ElemType.clone(elem)= after every
container get/pop call where the out-param is a local variable with a deletable
struct type.

Whitelist of affected methods:
- =Vec.pop= (Vec.get, Array.get, Set.get, Map.get all REMOVED)
- =HashMap.get=, =List.get=, =List.pop=

New garbager functions:
- =build_clone_assignment_expr= -- builds AST for =var = Type.clone(var)=
- =detect_shallow_copy_outparam= -- checks if stmt is a whitelisted get/pop call
- =insert_clone_after_get= / =process_stmt_for_clone_after_get= -- inserts clones
  after matching calls, recursing into nested Body/If/While/For/Switch nodes

Step 2.7 in FuncDef handler runs after local_types is built, before Step 3
(delete candidate collection). The =local_types= map was moved earlier (from
Step 4 to after Step 2.5) so it's available for both clone-after-get and
own-transfer detection.

All 92 tests pass in all 4 modes.

*** Parameter passing semantics (unchanged)
| Mode      | Semantics                                      |
|-----------+------------------------------------------------|
| (default) | By reference - share offset                    |
| =mut=     | By reference - share offset                    |
| =own=     | Ownership transfer - share offset, remove src  |
| =copy=    | Deep copy - garbager inserts clone, bind result |

*** Step 3b attempts -- local deletion (2026-02-17, FAILED)

Multiple attempts to enable ASAP deletion for local variables at function end.
All reverted. This is the key step needed to actually FREE the cloned data.

**** Attempt 1: ASAP deletion for locals (89/92 fail, free(): invalid pointer)
Shallow-copy aliasing via Vec.get(), field access etc. creates aliases to
local's heap data. Deleting local ASAP frees data still referenced through aliases.

**** Attempt 2: Inner-scope collection to function-end (69/92 fail, SIGSEGV)
Variables declared inside if/while/for may never be initialized. Unconditional
delete at function end crashes when scope was skipped.

**** Attempt 3: Garbager clone gaps + step 3b (88/92 SIGSEGV)
- Fix A: Clone ALL Identifier-init declarations (removed is_mut check)
- Fix B: Clone field-access assignments (removed params.is_empty check)
- Fix C: Remove has_any_catch restriction, zero-init hoisted locals

Fixes A+B alone pass 92/92 but are net-negative on memory (more clones, no deletes).
Step 3b crashes because cloned locals get embedded in returned data via by-ref
function calls. Root cause: functions like =Expr.new_explicit= take params by-ref
(not =own=), so =collect_own_transfers= doesn't detect that the caller's variable
was consumed. The variable becomes a deletion candidate, gets deleted at function
end, and corrupts the returned Expr that shares the same data buffer.

*** Issue #105 Step 4a regression (2026-02-22)

Commit 96361e5d (Move NamespaceDef into StructDef/EnumDef as =ns= field)
introduced a performance regression:
- til_interpreted: 794s/4406MB -> 1245s/8253MB (+56% time, +87% memory)
- til_built: 639s/9989MB -> 1086s/21863MB (+70% time, +119% memory)

Root cause: 3 phases (desugarer, garbager, ufcs) now recurse into
=ns.default_values= (namespace method bodies) inside the StructDef handler.
Before, NamespaceDef was a separate sibling node at Body level. These phases
hit the default case which just cloned it opaquely -- no recursion into
method body Expr trees. Only precomp had explicit NamespaceDef handling.

After embedding ns in StructDef, each phase's StructDef handler explicitly
iterates =ns.default_values= and calls =desugar_expr= / =garbager_recursive= /
=ufcs_expr= on each method body. This is more correct behavior -- namespace
method bodies should be fully processed by all phases -- but expensive.

Accepted as cost of correctness. Will be absorbed by Issue #117 optimizations.

*** Root cause analysis (2026-02-17)

The fundamental problem is that TIL/C has no ownership tracking. Every struct
assignment is a shallow memcpy. The garbager inserts clones for some patterns,
but many sources of shallow copies remain:

1. *ccodegen return values*: =*_ret = var= is a shallow copy. The returned local
   and =*_ret= share heap pointers. (Bug #168)
2. *Vec.clone*: byte-wise copy of buffer. Element heap pointers are shared.
3. *Vec.delete*: frees only the buffer, not element heap data.
4. *Consuming functions*: =Expr.new_explicit=, =build_clone_call_expr= etc. take
   struct params by-ref instead of =own=. The garbager can't detect ownership transfer.
5. *Collection .get()*: copy_to_dynamic memcpy creates aliases. Partially mitigated
   by clone-after-get (Step 9). Map.get eliminated (2026-02-20). Vec/Array/Set .get()
   remain -- should use get + cast (zero-copy pointer into collection storage).

*** Remediation plan

**** Phase 1: Eliminate copying .get() from all collections (no dependencies) -- DONE
All copying .get() methods removed from Vec, Map, Array, Set, List.
All callers converted to get + cast (zero-copy pointer into storage).
(~get~ was previously named ~get_by_ref~, renamed for simplicity.)

=.pop()= methods (Vec.pop, List.pop) are NOT part of Phase 1 -- pop removes the
element from the collection, so a zero-copy pointer into storage would dangle.
Pop needs ownership transfer (move semantics). Ideal API: pop returns a Ptr
(is_borrowed=false), caller uses cast. Internally, pop would get the last
element, clone it, decrement length, return Ptr to the clone. But cloning a
type-erased Dynamic element requires calling =Type.clone()= from =self.type_name=
at runtime -- blocked by Phase 2 (Issue #91, function pointers).

**** Phase 2: Function pointer builtins (Issue #91, minimal scope)
Deep Vec.clone/delete requires calling Type.clone()/Type.delete() on type-erased
Dynamic elements. TIL has no function pointer support (Issue #91). Minimal fix:
4 new builtins that work with raw I64 function pointer values:
- =delete_fn_of(T: Type) returns I64= -- returns address of =til_T_delete=
- =clone_fn_of(T: Type) returns I64= -- returns address of =til_T_clone=
- =call_delete_fn(fn_ptr: I64, elem: Ptr)= -- casts I64 to fn ptr and calls it
- =call_clone_fn(fn_ptr: I64, src: Ptr, dst: Ptr)= -- same for clone

Vec gets two new fields: =delete_fn: I64= and =clone_fn: I64=, set at Vec.new(T)
time when T is still concrete. Vec.delete iterates elements calling delete_fn.
Vec.clone iterates elements calling clone_fn. Map/Set/Array cascade through Vec.

**** Phase 3: =own= params on consuming functions
Functions that embed their parameter data (Expr.new_explicit, build_clone_call_expr,
etc.) must take =own= + =dont_delete= internally. This lets =collect_own_transfers=
exclude caller variables from deletion candidates. Vec.push/set/insert_at already
use this pattern correctly.

**** Phase 4: Garbager skips delete for returned locals
Part of Issue #117 (ASAP destruction). When a local variable is returned
(=return var=), the garbager should NOT insert a delete for it -- the caller
now owns the data via =*_ret=. The garbager already has =dont_delete_vars= --
returned locals should be added to that set.

**** Phase 5: Garbager clone gaps
- Clone ALL Identifier-init declarations (not just mut)
- Clone field-access assignments (remove params.is_empty check)

**** Phase 6: Enable step 3b (local deletion)
With Phases 2-5 complete, local deletion is safe:
- =own= params -> collect_own_transfers excludes consumed variables
- Deep Vec.clone/delete -> no shared element data
- Return move -> returned locals zeroed, deletion is no-op
- Clone gaps -> all declarations/assignments produce owned data

Changes: remove has_any_catch restriction, zero-init hoisted locals,
add delete-before-return (exclude returned var).

** Issue #152: Migrate doc/todo files to numbered issue system
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Documentation cleanup, better tracking
:STATUS: Open
:END:

*** Description
Several doc/todo files use older TODO/checklist systems instead of the numbered
issue tracking system. These should be reviewed and migrated.

*** Files Using Numbered System (done)
- bugs.org - Bug #N format
- future.org - Issue #N format
- post.org - Issue #N format
- os.org - Issue #N format
- optimizations.org - Optimization #N format

*** Files to Migrate

**** post_old.org (31KB) - partial extraction done
Remaining items to extract or delete:
- List/Tuple support
- Negative number literals
- Guards for pattern matching
- Default keyword for switch
- Struct literals
- Cast operations
- Operator overloading
- Type checking edge cases
- safe_script mode
- pure mode
- Performance optimizations
- Memory management
- Better error messages
- Code quality improvements
- Memory error handling
- More test cases
- Improve documentation
- Other number types
- Unset default values in structs
- Better import caching

Likely duplicates to verify:
- Closures -> Issue #91 (First-Class Functions)
- Macros -> Issue #88 (Macro Support)
- Error handling -> Bug #98 (ext_proc error types) - FIXED
- Code quality -> Issue #142 (Context Error Helpers)

**** wish.org (1.6KB) - wishlist/checklist
- Forbidden keywords with helpful error messages
- Dynamic error messages with user identifiers

**** clone.org (6.3KB) - task tracker
- 368 missing .clone() calls to port from Rust to TIL
- 6/14 files done

**** introspection.org (6.4KB) - design doc
- Runtime introspection system design
- has_const/has_field implemented, more TODO

**** special.org (8.6KB) - technical debt catalog
- Catalog of Rust special cases for primitive types
- Reference doc, may not need issues

**** mandatory.org (7.8KB) - completed feature
- clone/len/size requirements - all phases complete
- Could be moved to doc/ as reference

**** pre.org - DONE (migrated to fixed.org as #pre, file deleted)

**** pass_by_ref.org - DONE (content already in doc/ownership.org, file deleted)

**** 108.org (11.8KB) - deep dive doc
- Detailed design for Issue #108 (Namespaces)
- Supplement to future.org entry

**** Obsolete files (can delete)
- shadow.org (3KB) - obsolete plan, Bug #65 already fixed
- byref_plan.org, byref-params-plan.md - likely obsolete
- attempt_const.org - likely obsolete attempt
- wip_offsets.org - likely obsolete WIP
- scope.org, scope_refactor_prep.md - likely obsolete
- precomp_overhaul.org - likely obsolete

**** Unchecked files
- dry.org (21KB)
- techdebt.org (22.8KB)
- self_hosting.org (24KB)
- self.md (15KB)

*** After Migration
Delete or archive files once content is properly tracked in numbered issues.

** Bug #133: Precomputed heap values (Vec, List, etc.) have invalid pointers at runtime (COMPILED MODES)
:PROPERTIES:
:DISCOVERED: 2026-01-22
:IMPACT: Compiled programs crash/segfault when using precomputed collections
:STATUS: Partial - Vec types work (including nested); List, Map still broken
:REPRODUCER: src/test/test_bug133.til (passes for simple types)
:RELATED: Bug #145 (FIXED - was similar issue in til_interpreted mode)
:BRANCH: current133
:END:

NOTE: This bug affects COMPILED modes only (rs_compiled, til_compiled).
For a related issue in til_interpreted mode, see Bug #145.

*** Description
When global declarations like ~chromatic := create_chromatic()~ are precomputed
at compile time, the resulting Vec/List values contain heap pointers from the
interpreter's memory space. These raw pointer values are serialized directly
into C struct literals, causing segfaults at runtime.

*** Example
In music.til:
#+BEGIN_SRC til
chromatic := create_chromatic()  // Returns Vec of Str
#+END_SRC

Generated C code (in main()):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.type_name = (til_Str){.c_string = (til_Ptr){2146}, .cap = 3},
                          .type_size = 16, .ptr = (til_Ptr){3615}, ._len = 12, .cap = 16};
#+END_SRC

Those values (2146, 3615) are raw pointers from the precomp interpreter's arena.
At runtime they point to invalid memory, causing segfaults in Vec.get().

*** Root Cause
1. precomp.rs evaluates global declarations at compile time via eval_comptime()
2. eval_comptime() runs the interpreter, which allocates Vec contents on heap
3. The Vec struct fields (including Ptr fields) are serialized as integer literals
4. At runtime, the compiled program has different memory layout - those pointers are garbage

*** Affected Types
- Vec (Ptr field points to heap-allocated element array)
- List (likely same issue with Ptr node pointers)
- Any struct with Ptr fields pointing to heap data
- Str when dynamically allocated (c_string Ptr field)

*** Fix
Serialize heap data to static arrays: Copy the heap contents into C static
arrays and patch the pointers to reference them. This preserves the
optimization benefit of precomputation.

**** Generic approach
The correct solution is NOT to hardcode specific types (Vec, List, Map), but to
handle ANY struct with owned Ptr fields generically:

1. For each Ptr field in the struct, check if ~is_borrowed~ is false (owned)
2. If owned, the Ptr points to heap data that needs serialization
3. Recursively serialize whatever that Ptr points to (could be another struct
   with Ptr fields, requiring further recursion)
4. Emit static arrays for the serialized data
5. Patch the Ptr to reference the static array instead of the heap address

This approach automatically handles:
- Vec (ptr field points to element array)
- List (node pointers)
- Map (bucket pointers)
- Any user-defined struct with owned Ptr fields
- Arbitrary nesting depth

Current implementation handles Vec specifically; List and Map need the same
treatment but haven't been implemented yet.

*** Workaround (for unsupported types)
Change ~func~ to ~proc~ for functions that return unsupported heap types.
Since precomp only evaluates ~func~ (pure functions), using ~proc~ forces runtime evaluation:

#+BEGIN_SRC til
// Works (all Vec types now supported):
create_chromatic := func() returns Vec { ... }
create_mode_intervals := func() returns Vec { ... }  // Vec<Vec<I64>>

// Broken (List, Map not yet supported), use proc:
create_items := proc() returns List { ... }
#+END_SRC

*** Progress (2026-01-30)
Rust fix merged to master. Files modified:
- ~src/rs/eval_arena.rs~ - VecContents, StrContents extraction functions
- ~src/rs/init.rs~ - PrecomputedHeapValue struct
- ~src/rs/precomp.rs~ - track precomputed heap values
- ~src/rs/ccodegen.rs~ - emit static arrays and patched assignments

TIL port complete (2026-01-30). Files modified:
- ~src/self/eval_arena.til~ - VecContents, extract_vec_contents, extract_str_at_offset, type_needs_heap_serialization
- ~src/self/init.til~ - PrecomputedHeapValue struct
- ~src/self/precomp.til~ - track precomputed heap values
- ~src/self/ccodegen.til~ - PrecomputedStaticInfo, emit_precomputed_static_arrays, hex_byte, bytes_to_i64
- ~src/core/str.til~ - Str.from_byte (consolidation)
- ~src/test/strings.til~ - tests for char_at and from_byte

**** Current test results (simple Vec<I64>, Vec<U8>, Vec<Str>):
- rs_interpreted: PASS
- rs_compiled: PASS (Bug #133 fix works)
- til_interpreted: PASS (Bug #145 resolved)
- til_compiled: PASS (TIL port complete)

*** Simplification (2026-02-18)
Two improvements to the generated C output:
1. Inline all string literals directly in struct initializers instead of emitting
   intermediate ~static const char~ variables. C string literals already have
   static storage duration -- no need for named variables.
2. Move Vec initialization from assignment in ~main()~ to the static declaration
   site. All values are compile-time constants (string literal addresses, static
   array addresses, integers), so this is valid as a C static initializer.
   Removed ~emit_precomputed_vec_assignment~ (both .rs and .til).

**** What works now (both rs_compiled and til_compiled):
- ~Vec<I64>~ - emits static I64 array
- ~Vec<U8>~ - emits static U8 array
- ~Vec<Str>~ - emits string literals + Str struct array (two-level)
- ~Vec<Vec<T>>~ - recursive serialization of nested Vecs

**** Still broken (both rs_compiled and til_compiled):
- ~List~ - linked node pointers not serialized
- ~Map~ - internal structure not serialized

**** Future work:
1. Generalize to handle any struct with owned Ptr fields (not just Vec)
2. Add List serialization support (linked node pointers)
3. Add Map serialization support (internal structure)

*** Implementation Plan
Serialize heap contents to static C arrays and patch pointers to reference them.

**** Before (broken):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.ptr = (til_Ptr){3615}, ._len = 12, ...};  // 3615 is garbage
#+END_SRC

**** After (working, simplified 2026-02-18):
#+BEGIN_SRC c
// Static data array with inline string literals (no intermediate variables):
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)"do", 1, 0, 0, 0}, ._len =2, .cap = 0},
    {.c_string = (til_Ptr){(til_I64)"do#", 1, 0, 0, 0}, ._len =3, .cap = 0},
    // ...
};
// Initialized at declaration site (not assigned in main):
static til_Vec til_Vec_chromatic = {
    .type_name = (til_Str){(til_Ptr){(til_I64)"Str", 1, 0, 0, 0}, 3, 0},
    .type_size = 56,
    .ptr = (til_Ptr){(til_I64)_precomp_chromatic_data, 1, 0, 0, 0},
    ._len = 12, .cap = 12
};
#+END_SRC

**** Step 1: Add Vec/Str extraction to eval_arena.rs [DONE]
Add struct and function to extract Vec contents given an instance name:
#+BEGIN_SRC rust
pub struct VecContents {
    pub element_type_name: String,
    pub type_size: i64,
    pub element_bytes: Vec<Vec<u8>>,
}

pub fn extract_vec_contents(ctx: &Context, instance_name: &str)
    -> Result<VecContents, String>
#+END_SRC

**** Step 2: Track precomputed heap values in precomp.rs [DONE]
Add struct for tracking precomputed heap values:
#+BEGIN_SRC rust
pub struct PrecomputedHeapValue {
    pub var_name: String,
    pub instance_name: String,
    pub type_name: String,
}
#+END_SRC

In ~precomp_declaration()~, when a global declaration has a precomputed Vec/List:
- Store in new ~Context.precomputed_heap_values: Vec<PrecomputedHeapValue>~

**** Step 3: Emit static arrays in ccodegen.rs [DONE for simple types]
Before emitting main(), add a new pass:
#+BEGIN_SRC rust
for phv in &context.precomputed_heap_values {
    if phv.type_name == "Vec" {
        let contents = EvalArena::extract_vec_contents(ctx, &phv.instance_name)?;
        emit_static_vec_data(&phv.var_name, &contents, output)?;
    }
}
#+END_SRC

**** Step 4: Patch struct literals to use static pointers [DONE]
When emitting a global declaration in ~precomputed_heap_values~:
- Instead of ~.ptr = (til_Ptr){1234}~
- Emit ~.ptr = (til_Ptr){(til_I64)_precomp_{var_name}_data}~

**** Handling Nested Types
For Vec<I64>: [DONE]
#+BEGIN_SRC c
static til_I64 _precomp_myints_data[5] = {1, 2, 3, 4, 5};
til_myints = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_myints_data}, ._len = 5, ...};
#+END_SRC

For Vec<Str> (two-level): [DONE]
#+BEGIN_SRC c
static const char _precomp_chromatic_str_0[] = "do";
static const char _precomp_chromatic_str_1[] = "do#";
// ...
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_0}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_1}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ...};
#+END_SRC

For Vec<Vec<T>>: Recursively emit inner arrays first, then outer. [TODO]

**** Complexity Notes
- Vec<Str> requires two-level static arrays (strings + Str structs) [DONE]
- Vec<Vec<T>> requires recursive serialization [TODO]
- List would need similar treatment (linked nodes -> static array) [TODO]
- Start with Vec only, extend to List/Map later if needed

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (updated 2026-02-11)
Audit of generated C code with ~gcc -Wall -Wextra~:

| Type                         | Count | Priority | Notes                                      |
|------------------------------+-------+----------+--------------------------------------------|
| -Wunused-variable            |  1711 | Low      | Generated temp vars not always used        |
| -Wdangling-pointer           |   971 | High     | Statement expressions return &local_var    |
| -Wunused-but-set-variable    |     9 | Low      | Similar to above                           |
| -Wunused-label               |   195 | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           |     0 | Low      | FIXED 2026-02-11 - (void) casts            |
| -Wmissing-braces             |     0 | Low      | FIXED 2026-01-25                           |
| -Wmissing-field-initializers |     0 | Low      | FIXED 2026-01-25                           |
| -Wreturn-type                |     0 | High     | FIXED 2026-01-25                           |
| -Wincompatible-pointer-types |     0 | Medium   | FIXED 2026-01-13                           |
| -Wc23-extensions             |     0 | Low      | FIXED 2026-01-28 - emit param names always |

*** Fix Strategy (Incremental)
1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Switch to ~-Wall -Wextra -Werror~ with suppressions (DONE - 2026-01-25)
5. Remove suppressions one by one as each warning category is fixed

*** Current Build Flags (target.rs/til)
Now using ~-Wall -Wextra -Werror~ with suppressions for unfixed warnings (2026-01-26):

**** Common flags (both gcc and clang)
- ~-Wno-unused-variable~ (1514 occurrences)
- ~-Wno-unused-but-set-variable~ (386 occurrences)
- ~-Wno-unused-label~ (153 occurrences)

**** GCC-only flags
- ~-Wno-dangling-pointer~ (971 occurrences) - high priority to fix

**** Clang-only flags
- ~-Wno-sometimes-uninitialized~ - exception control flow paths
- ~-Wno-self-assign~ - til_result = til_result patterns in generated code
- ~-Wno-c23-extensions~ - unnamed parameters in function definitions
- ~-Wno-uninitialized~ - variable used before initialization in some paths
- ~-Wno-unused-function~ - enum to_str functions generated but not always used

To fix a warning category: remove the ~-Wno-~ flag and fix the resulting errors.

*** Testing with clang locally (Issue #131)
To build til.til with clang (this is what fails in macOS CI):
#+begin_src bash
./bin/rstil build src/til.til --cc=clang --force-rebuild
#+end_src

To run tests with clang instead of gcc:
#+begin_src bash
./bin/rs/make tests --cc=clang
#+end_src

Note: ~./make.til tests --cc=clang~ does NOT work because the shebang causes
rstil to consume the flag. Use the compiled binary ~./bin/rs/make~ directly.

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [X] Step 3e: Enable and fix -Wreturn-type (2026-01-25) - add implicit return 0 to throwing functions, add zero-initialized fallback return to non-throwing functions with return types
- [X] Step 4: Switch to -Wall -Wextra -Werror with suppressions (2026-01-25)
- [X] Step 5a: Remove -Wno-dangling-pointer (971 occurrences) - fixed by Bug #143, flag removed in Bug #140 fix
- [-] Step 5b: Remove -Wno-unused-variable (1514 occurrences, partial progress)
- [-] Step 5c: Remove -Wno-unused-but-set-variable (9 occurrences, down from 386). Blocks Bug #94 (bug47.til rs_compiled). Two categories: TIL source vars set but not read (3), dead ccodegen temps (4 Str temps in collect_namespace_methods). See Bug #94 for full list.
- [ ] Step 5d: Remove -Wno-unused-label (195 occurrences)
- [X] Step 5e: Remove -Wno-unused-parameter (2026-02-11) - emit (void)param; casts at top of function bodies for _-prefixed params and all params in empty-body functions (e.g., empty delete stubs)
- [X] Step 5f: Remove -Wno-missing-braces (2026-01-25) - use Ptr() instead of NULL for Declaration.default_value in desugarer.til/garbager.til; Ptr() emits ~((til_Ptr){0})~ with proper braces
- [X] Step 5g: Remove -Wno-missing-field-initializers (2026-01-25) - add cap=0 to Str literals for Type params in ccodegen emit_main_args

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-02-11)
| Mode            | Result                             | Time  |
|-----------------+------------------------------------+-------|
| rstil interpret | pass                               | ~9.5s |
| rstil run       | FAIL - unused-but-set-variable (8) | -     |
| til interpret   | pass (but >120s, excluded from benchmark) | -     |
| til run         | OOM killed (exit 137)              | ~61s  |

~rstil run~ fails due to 8 ~-Wunused-but-set-variable~ warnings in generated C:
#+BEGIN_SRC
gen/rs/c/test/bug47.c:4968:  _ignore = til_reset_loop_var_counter()     -- TIL source var
gen/rs/c/test/bug47.c:8841:  _tmp_collect_namespace_methods_15 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8888:  _tmp_collect_namespace_methods_38 (Str)    -- dead temp
gen/rs/c/test/bug47.c:8962:  _tmp_collect_namespace_methods_69 (Str)    -- dead temp
gen/rs/c/test/bug47.c:9009:  _tmp_collect_namespace_methods_92 (Str)    -- dead temp
gen/rs/c/test/bug47.c:18317: custom_symbol_found (Bool)                 -- TIL source var
gen/rs/c/test/bug47.c:19102: have_switch_type (Bool)                    -- TIL source var
gen/rs/c/test/bug47.c:24269: has_switch_type (Bool)                     -- TIL source var
#+END_SRC

Two categories:
1. TIL source variables set but not read (3 vars: ~_ignore~, ~custom_symbol_found~,
   ~have_switch_type~/~has_switch_type~) - fix in TIL source or mark with ~__attribute__((unused))~
2. Dead temps from ccodegen (4 Str temps in ~collect_namespace_methods~) - fix in ccodegen

*** Original Warnings (2026-01-13, historical)
1654 total warnings when compiling with ~gcc -Wall -Wextra~ (all now fixed or
suppressed via Bug #99):
- 933 -Wunused-variable (suppressed, Bug #99 step 5b)
- 318 -Wdangling-pointer (FIXED, Bug #143)
- 195 -Wincompatible-pointer-types (FIXED, Bug #99 step 3a)
- 135 -Wunused-but-set-variable (down to 9, Bug #99 step 5c)
- 66 -Wunused-label (suppressed, Bug #99 step 5d)
- 5 -Wunused-parameter (FIXED, Bug #99 step 5e)
- 1 -Wreturn-type (FIXED, commit 129ba21a)
- 1 null character in literal (FIXED, Bug #99 step 3d)

*** Progress (2026-02-11)
All original warnings now fixed or suppressed via Bug #99. Remaining blocker for
compiled mode is Bug #99 step 5c (9 unused-but-set-variable warnings). OOM in
~til run~ remains open (Issue #117).

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [X] Fix missing return statement (commit 129ba21a)
- [X] Add casts for Vec_push calls - fixed in Bug #99 Step 3a (-Wincompatible-pointer-types)
- [X] Consider which unused-* warnings to fix vs suppress - done in Bug #99 Step 4
- [X] Fix dangling pointer pattern - fixed by Bug #143
- [ ] Fix 8 unused-but-set-variable warnings - same as Bug #99 Step 5c
- [ ] Fix til ccodegen memory usage (OOM on large files) - may be fixed by Issue #117 (borrow checker)

*** Related Issues
- Bug #99 Step 5c: Remove -Wno-unused-but-set-variable (direct blocker for rs_compiled)
- Bug #140: Dangling pointers in generated C code (FIXED via Bug #143)
- Issue #117: Borrow checker / memory management (may fix OOM)

