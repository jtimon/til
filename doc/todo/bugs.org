#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-11-10

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #25: Variable Declarations Share Arena Offsets Instead of Copying :OPEN:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Open - Fix in progress
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Planned Fix
Change declaration path to use copy_fields() instead of sharing offset:
1. Replace offset sharing with copy_fields() call in declaration handler
2. Make declarations consistent with assignments
3. Verify all tests pass

** Bug #24: Struct Field Access Returns Copy Instead of Reference :OPEN:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Data structure mutation, memory management
:STATUS: Open - Implementation planned in pre.org
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Planned Fix - Implementation in Progress
This bug is being fixed by implementing pass-by-reference semantics with three argument modes. See doc/todo/plan_by_reference.org for detailed implementation plan.

*Phase 1: Type checker immutability enforcement* ✅ COMPLETE
- Prevents modification of immutable parameters
- Prevents field modification of immutable parameters
- Foundation for reference semantics working

*Phase 2: Add 'copy' keyword* ✅ COMPLETE (2025-11-12)
- Added Copy token to lexer, parser, type checker, interpreter
- Added is_copy field to Declaration and SymbolInfo
- Parser validates mut and copy are mutually exclusive
- Type checker and interpreter allow modification of copy parameters
- Comprehensive tests in src/test/args.til
- All tests pass

*Phase 3: Use references for all non-copy parameters* ⏸ DEFERRED
- Status: DEFERRED until after self-hosting (2025-11-12)
- Reason: Added complexity without simplification, introduced subtle bugs
- Attempted implementation encountered context corruption with arena offset sharing
- See doc/bot/phase3_findings.org and doc/todo/plan_by_reference.org for details

*Phase 4: Update core library* ⏸ BLOCKED
- Status: BLOCKED by Phase 3 deferral
- Cannot remove Bug #24 workarounds without reference semantics from Phase 3
- Workarounds must remain until Phase 3 is completed

*Current Status*
- Bug #24 remains OPEN - workarounds still necessary
- Phase 2 (copy keyword) provides explicit control but doesn't fix underlying issue
- Bug will be revisited after self-hosting when better debugging tools available

After this implementation, the example will work naturally:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  // ✅ WORKS - modifies via reference
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

See doc/bot/bug24_investigation.org for detailed root cause analysis.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` ✅
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` ✅
- Throw from regular function ✅

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` ❌

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // ✅ Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Fixed Bugs Summary

Bugs #1-#8 have been fixed and their tests integrated into the regular test suite (=enums.til=, =flow.til=, =arithmetics.til=, =return_value_usage.til=).

** Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*: ✅ FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
// ✅ Capture the return value
result := my_add(1, 2)

// ✅ Use as argument to another function
double(my_add(3, 4))

// ✅ Explicitly discard with _
_ := get_value()

// ✅ Procs don't return values, no capture needed
print_hello()

// ❌ ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
