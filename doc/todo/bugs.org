#+TITLE: rstil Bug Fixes - Historical Reference
# BOT: New bugs use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new bugs at the top of Active Bugs section.
# BOT: When fixed, move to the top of Fixed Bugs section in doc/todo/fixed.org.

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #159: Shallow copy semantics for structs with Ptr/Vec fields
:PROPERTIES:
:DISCOVERED: 2026-01-31
:IMPACT: Memory corruption, shared state between clones
:STATUS: Partially Fixed (deep copy via clone works; nested Ptr cloning still TODO)
:END:

*** Description
When doing =mut cloned := original=, the interpreter uses =copy_fields= which does
a byte-level copy. For structs containing Ptr or Vec fields, this results in both
the original and clone sharing the same underlying memory.

Test case: src/test/bug159.til (currently expects failure)

*** Root Cause
Vec.clone copies element bytes (memcpy), not calling .clone() on each element.
To fix properly, Ptr needs to know element type/size to enable deep cloning.

*** Dependencies
- Bug #160: Eliminate lookup fallbacks, use deterministic field offset calculation

*** Implementation Plan

**** Step 1: DONE - preinit generates clone/delete, cleanup manual clones
- preinit phase auto-generates delete() and clone() methods for structs/enums
- Auto-generated clone calls =self.field.clone()= for each field (deep copy pattern)
- Added Ptr.clone() (borrowed shallow copy to prevent double-free)
- Removed redundant manual clones that are now auto-generated
- Kept manual clones for containers (Vec, Map, etc.) and special cases

**** Step 2: TODO - Move dynamic type info to Ptr
Add fields to Ptr to enable deep cloning:
- =size: I64= - total allocation size
- =elem_type: Str= - element type name (for arrays/vecs)
- =elem_size: I64= - size of each element

This allows Ptr.clone to:
- Allocate new memory of correct size
- Call =ElemType.clone()= on each element for deep copy

Vec/Map/etc can then delegate to Ptr, simplifying their implementations.

**** Step 3: DONE - Move clone logic from interpreter to garbager
Changed garbager phase to transform =mut x := y= (where y is a struct identifier)
to =mut x := Type.clone(y)= at the AST level. This means:
- Clone insertion happens at AST transformation time, not during interpretation
- Removed =call_clone_method= function from interpreter (both Rust and TIL)
- Simplified interpreter declaration handling to just bind offsets

**Root cause of previous stack overflow**: Bool was incorrectly marked as "primitive"
in garbager's exclusion list. When =mut val := false= was not transformed to
=Bool.clone(false)=, the interpreter just shared offsets. Since =false= is a global
constant, modifying =val= later would corrupt =false=, causing infinite loops in
code that depended on =false= being correct. Fix: removed Bool from primitives list.

*** Failed Attempt: branch failure159
Branch =failure159= contains Steps 2-8 of the implementation, but caused massive
performance regression (benchmark total went from ~570s to ~1179s). The approach
of adding dynamic type info to Ptr and using clone everywhere was too expensive.

*** Future Optimization (post self-hosting)
Make Ptr templated (=Ptr(T)=) instead of storing type info at runtime:
- Static type info, compile-time type checking
- Better performance (no runtime field overhead)
- Cost: larger binary size (monomorphization)

This addresses the performance concern of adding fields to Ptr.

** Issue #152: Migrate doc/todo files to numbered issue system
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Documentation cleanup, better tracking
:STATUS: Open
:END:

*** Description
Several doc/todo files use older TODO/checklist systems instead of the numbered
issue tracking system. These should be reviewed and migrated.

*** Files Using Numbered System (done)
- bugs.org - Bug #N format
- future.org - Issue #N format
- post.org - Issue #N format
- os.org - Issue #N format
- optimizations.org - Optimization #N format

*** Files to Migrate

**** post_old.org (31KB) - partial extraction done
Remaining items to extract or delete:
- List/Tuple support
- Negative number literals
- Guards for pattern matching
- Default keyword for switch
- Struct literals
- Cast operations
- Operator overloading
- Type checking edge cases
- safe_script mode
- pure mode
- Performance optimizations
- Memory management
- Better error messages
- Code quality improvements
- Memory error handling
- More test cases
- Improve documentation
- Other number types
- Unset default values in structs
- Better import caching

Likely duplicates to verify:
- Closures -> Issue #91 (First-Class Functions)
- Macros -> Issue #88 (Macro Support)
- Error handling -> Bug #98 (ext_proc error types) - FIXED
- Code quality -> Issue #142 (Context Error Helpers)

**** wish.org (1.6KB) - wishlist/checklist
- Forbidden keywords with helpful error messages
- Dynamic error messages with user identifiers

**** clone.org (6.3KB) - task tracker
- 368 missing .clone() calls to port from Rust to TIL
- 6/14 files done

**** introspection.org (6.4KB) - design doc
- Runtime introspection system design
- has_const/has_field implemented, more TODO

**** special.org (8.6KB) - technical debt catalog
- Catalog of Rust special cases for primitive types
- Reference doc, may not need issues

**** mandatory.org (7.8KB) - completed feature
- clone/len/size requirements - all phases complete
- Could be moved to doc/ as reference

**** pre.org - DONE (migrated to fixed.org as #pre, file deleted)

**** pass_by_ref.org - DONE (content already in doc/ownership.org, file deleted)

**** 108.org (11.8KB) - deep dive doc
- Detailed design for Issue #108 (Namespaces)
- Supplement to future.org entry

**** Obsolete files (can delete)
- shadow.org (3KB) - obsolete plan, Bug #65 already fixed
- byref_plan.org, byref-params-plan.md - likely obsolete
- attempt_const.org - likely obsolete attempt
- wip_offsets.org - likely obsolete WIP
- scope.org, scope_refactor_prep.md - likely obsolete
- precomp_overhaul.org - likely obsolete

**** Unchecked files
- dry.org (21KB)
- techdebt.org (22.8KB)
- self_hosting.org (24KB)
- self.md (15KB)

*** After Migration
Delete or archive files once content is properly tracked in numbered issues.

** Bug #144: for-in loops iterate by copy instead of by reference
:PROPERTIES:
:DISCOVERED: 2026-01-27
:IMPACT: Performance overhead, breaks pointer identity assumptions
:STATUS: Open
:RELATED: Bug #143 (hoisted_exprs identity depends on this)
:END:

*** Description
When iterating over a Vec with ~for x: T in vec~, TIL copies each element into
the loop variable instead of providing a reference to the element in the Vec.

Current behavior:
#+BEGIN_SRC til
for expr: Expr in exprs {
    // expr is a COPY of exprs[i]
    // to_ptr(expr) gives address of local variable, not element in Vec
}
#+END_SRC

This differs from Rust where ~for expr in exprs.iter()~ gives references to
the actual elements in the Vec.

*** Problems
1. **Performance**: Unnecessary copying of potentially large structs
2. **Pointer identity**: ~to_ptr(expr)~ gives different addresses in different
   contexts for the "same" logical element, breaking identity-based lookups
3. **Mutation**: Cannot mutate elements in-place (must use index-based access)

*** Proposed Solution
Default to iteration by reference, or provide syntax for both:

#+BEGIN_SRC til
// Option A: Default to reference
for expr: Expr in exprs {
    // expr is a reference to exprs[i]
}

// Option B: Explicit syntax
for expr: Expr in exprs {        // by reference (default)
for copy expr: Expr in exprs {   // by copy (explicit)

// Option C: Different keywords
for ref expr: Expr in exprs {    // by reference
for expr: Expr in exprs {        // by copy (current behavior)
#+END_SRC

*** Impact on Bug #143
If for-in iterated by reference, ~to_ptr(expr)~ would give the same address
for the same element regardless of which function is iterating. This would
make the Rust-style memory address approach work in TIL too.

** Bug #133: Precomputed heap values (Vec, List, etc.) have invalid pointers at runtime (COMPILED MODES)
:PROPERTIES:
:DISCOVERED: 2026-01-22
:IMPACT: Compiled programs crash/segfault when using precomputed collections
:STATUS: Partial - Vec types work (including nested); List, Map still broken
:REPRODUCER: src/test/test_bug133.til (passes for simple types)
:RELATED: Bug #145 (FIXED - was similar issue in til_interpreted mode)
:BRANCH: current133
:END:

NOTE: This bug affects COMPILED modes only (rs_compiled, til_compiled).
For a related issue in til_interpreted mode, see Bug #145.

*** Description
When global declarations like ~chromatic := create_chromatic()~ are precomputed
at compile time, the resulting Vec/List values contain heap pointers from the
interpreter's memory space. These raw pointer values are serialized directly
into C struct literals, causing segfaults at runtime.

*** Example
In music.til:
#+BEGIN_SRC til
chromatic := create_chromatic()  // Returns Vec of Str
#+END_SRC

Generated C code (in main()):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.type_name = (til_Str){.c_string = (til_Ptr){2146}, .cap = 3},
                          .type_size = 16, .ptr = (til_Ptr){3615}, ._len = 12, .cap = 16};
#+END_SRC

Those values (2146, 3615) are raw pointers from the precomp interpreter's arena.
At runtime they point to invalid memory, causing segfaults in Vec.get().

*** Root Cause
1. precomp.rs evaluates global declarations at compile time via eval_comptime()
2. eval_comptime() runs the interpreter, which allocates Vec contents on heap
3. The Vec struct fields (including Ptr fields) are serialized as integer literals
4. At runtime, the compiled program has different memory layout - those pointers are garbage

*** Affected Types
- Vec (Ptr field points to heap-allocated element array)
- List (likely same issue with Ptr node pointers)
- Any struct with Ptr fields pointing to heap data
- Str when dynamically allocated (c_string Ptr field)

*** Fix
Serialize heap data to static arrays: Copy the heap contents into C static
arrays and patch the pointers to reference them. This preserves the
optimization benefit of precomputation.

**** Generic approach
The correct solution is NOT to hardcode specific types (Vec, List, Map), but to
handle ANY struct with owned Ptr fields generically:

1. For each Ptr field in the struct, check if ~is_borrowed~ is false (owned)
2. If owned, the Ptr points to heap data that needs serialization
3. Recursively serialize whatever that Ptr points to (could be another struct
   with Ptr fields, requiring further recursion)
4. Emit static arrays for the serialized data
5. Patch the Ptr to reference the static array instead of the heap address

This approach automatically handles:
- Vec (ptr field points to element array)
- List (node pointers)
- Map (bucket pointers)
- Any user-defined struct with owned Ptr fields
- Arbitrary nesting depth

Current implementation handles Vec specifically; List and Map need the same
treatment but haven't been implemented yet.

*** Workaround (for unsupported types)
Change ~func~ to ~proc~ for functions that return unsupported heap types.
Since precomp only evaluates ~func~ (pure functions), using ~proc~ forces runtime evaluation:

#+BEGIN_SRC til
// Works (all Vec types now supported):
create_chromatic := func() returns Vec { ... }
create_mode_intervals := func() returns Vec { ... }  // Vec<Vec<I64>>

// Broken (List, Map not yet supported), use proc:
create_items := proc() returns List { ... }
#+END_SRC

*** Progress (2026-01-30)
Rust fix merged to master. Files modified:
- ~src/rs/eval_arena.rs~ - VecContents, StrContents extraction functions
- ~src/rs/init.rs~ - PrecomputedHeapValue struct
- ~src/rs/precomp.rs~ - track precomputed heap values
- ~src/rs/ccodegen.rs~ - emit static arrays and patched assignments

TIL port complete (2026-01-30). Files modified:
- ~src/self/eval_arena.til~ - VecContents, extract_vec_contents, extract_str_at_offset, type_needs_heap_serialization
- ~src/self/init.til~ - PrecomputedHeapValue struct
- ~src/self/precomp.til~ - track precomputed heap values
- ~src/self/ccodegen.til~ - PrecomputedStaticInfo, emit_precomputed_static_arrays, hex_byte, bytes_to_i64
- ~src/core/str.til~ - Str.from_byte (consolidation)
- ~src/test/strings.til~ - tests for char_at and from_byte

**** Current test results (simple Vec<I64>, Vec<U8>, Vec<Str>):
- rs_interpreted: PASS
- rs_compiled: PASS (Bug #133 fix works)
- til_interpreted: PASS (Bug #145 resolved)
- til_compiled: PASS (TIL port complete)

**** What works now (both rs_compiled and til_compiled):
- ~Vec<I64>~ - emits static I64 array
- ~Vec<U8>~ - emits static U8 array
- ~Vec<Str>~ - emits string literals + Str struct array (two-level)
- ~Vec<Vec<T>>~ - recursive serialization of nested Vecs

**** Still broken (both rs_compiled and til_compiled):
- ~List~ - linked node pointers not serialized
- ~Map~ - internal structure not serialized

**** Future work:
1. Generalize to handle any struct with owned Ptr fields (not just Vec)
2. Add List serialization support (linked node pointers)
3. Add Map serialization support (internal structure)

*** Implementation Plan
Serialize heap contents to static C arrays and patch pointers to reference them.

**** Before (broken):
#+BEGIN_SRC c
til_chromatic = (til_Vec){.ptr = (til_Ptr){3615}, ._len = 12, ...};  // 3615 is garbage
#+END_SRC

**** After (working):
#+BEGIN_SRC c
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)"do"}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)"do#"}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ._len = 12, ...};
#+END_SRC

**** Step 1: Add Vec/Str extraction to eval_arena.rs [DONE]
Add struct and function to extract Vec contents given an instance name:
#+BEGIN_SRC rust
pub struct VecContents {
    pub element_type_name: String,
    pub type_size: i64,
    pub element_bytes: Vec<Vec<u8>>,
}

pub fn extract_vec_contents(ctx: &Context, instance_name: &str)
    -> Result<VecContents, String>
#+END_SRC

**** Step 2: Track precomputed heap values in precomp.rs [DONE]
Add struct for tracking precomputed heap values:
#+BEGIN_SRC rust
pub struct PrecomputedHeapValue {
    pub var_name: String,
    pub instance_name: String,
    pub type_name: String,
}
#+END_SRC

In ~precomp_declaration()~, when a global declaration has a precomputed Vec/List:
- Store in new ~Context.precomputed_heap_values: Vec<PrecomputedHeapValue>~

**** Step 3: Emit static arrays in ccodegen.rs [DONE for simple types]
Before emitting main(), add a new pass:
#+BEGIN_SRC rust
for phv in &context.precomputed_heap_values {
    if phv.type_name == "Vec" {
        let contents = EvalArena::extract_vec_contents(ctx, &phv.instance_name)?;
        emit_static_vec_data(&phv.var_name, &contents, output)?;
    }
}
#+END_SRC

**** Step 4: Patch struct literals to use static pointers [DONE]
When emitting a global declaration in ~precomputed_heap_values~:
- Instead of ~.ptr = (til_Ptr){1234}~
- Emit ~.ptr = (til_Ptr){(til_I64)_precomp_{var_name}_data}~

**** Handling Nested Types
For Vec<I64>: [DONE]
#+BEGIN_SRC c
static til_I64 _precomp_myints_data[5] = {1, 2, 3, 4, 5};
til_myints = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_myints_data}, ._len = 5, ...};
#+END_SRC

For Vec<Str> (two-level): [DONE]
#+BEGIN_SRC c
static const char _precomp_chromatic_str_0[] = "do";
static const char _precomp_chromatic_str_1[] = "do#";
// ...
static til_Str _precomp_chromatic_data[12] = {
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_0}, .cap = 2},
    {.c_string = (til_Ptr){(til_I64)_precomp_chromatic_str_1}, .cap = 3},
    // ...
};
til_chromatic = (til_Vec){.ptr = (til_Ptr){(til_I64)_precomp_chromatic_data}, ...};
#+END_SRC

For Vec<Vec<T>>: Recursively emit inner arrays first, then outer. [TODO]

**** Complexity Notes
- Vec<Str> requires two-level static arrays (strings + Str structs) [DONE]
- Vec<Vec<T>> requires recursive serialization [TODO]
- List would need similar treatment (linked nodes -> static array) [TODO]
- Start with Vec only, extend to List/Map later if needed

** Bug #130: Unify type resolution with type checking into single pass
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPACT: Two separate passes (check_types + resolve_inferred_types) when one would suffice
:STATUS: Open
:RELATED: Bug #128 (completed prerequisite work)
:END:

*** Description
Currently typer has two passes: check_types() validates types, then resolve_inferred_types()
replaces INFER_TYPE with concrete types. These should be merged into a single pass that
both checks types and resolves INFER_TYPE in one traversal.

*** Background
Bug #128 cleaned up INFER_TYPE handling across the codebase (Steps 2-6). This is the
remaining work (was Step 7) split into its own bug for clarity.

*** Fix
Merge check_types() and resolve_inferred_types() into a single function that:
1. Validates types as it traverses
2. Replaces INFER_TYPE with resolved types in the same pass
3. Returns the modified AST with all types resolved

Files: src/rs/typer.rs, src/self/typer.til

** Bug #114: ScopeStack lookup functions leak memory by copying entire ScopeFrame
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Memory leak in self-hosted interpreter, grows with scope depth and lookup frequency
:STATUS: Partial - Option C implemented, ScopeFrame copy remains (see Bug #144)
:END:

*** Description
TIL's ScopeStack lookup functions (lookup_var, lookup_symbol, lookup_func, lookup_enum,
lookup_struct, is_closure_capture, all_structs, etc.) copy entire ScopeFrame objects
when iterating through frames:

#+BEGIN_SRC til
// Current pattern (leaks memory)
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()   // Allocates new ScopeFrame
    self.frames.get(i, frame)   // Copies ALL fields including 5 Maps

    if frame.arena_index.contains_key(name) {
        // ...
    }
    // frame goes out of scope - Maps inside are NOT freed
}
#+END_SRC

ScopeFrame contains 5 Maps (arena_index, symbols, funcs, enums, structs). Each copy
duplicates the Map struct which holds pointers to heap-allocated Vec data. When the
copied frame goes out of scope, those Map copies leak because TIL has no automatic
destructor/drop mechanism.

*** Why Rust Doesn't Have This Problem
Rust iterates by reference, not by copy:
#+BEGIN_SRC rust
for frame in self.frames.iter().rev() {
    if let Some(offset) = frame.arena_index.get(name) {
        // frame is &ScopeFrame - no copy, no allocation
    }
}
#+END_SRC

*** Potential Solutions

**** Option A: Return references from Vec.get (language change)
Change Vec.get to return a reference/pointer instead of copying:
#+BEGIN_SRC til
// Hypothetical - would require language support for references
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame := self.frames.get_ref(i)  // Returns reference, no copy
    if frame.arena_index.contains_key(name) { ... }
}
#+END_SRC
Pros: Matches Rust semantics, clean syntax
Cons: Major language change, needs reference/borrow system

**** Option B: Vec.get_ptr + manual offset calculation (branch approach)
Use pointer arithmetic to access fields without copying entire struct:
#+BEGIN_SRC til
structs_offset := mul(size_of(Map), 4)
mut scratch_map := Map.new(Str, SStructDef)
for i in self.frames.len().sub(1)..sub(0, 1) {
    frame_ptr := self.frames.get_ptr(i)
    structs_ptr := add(frame_ptr, structs_offset)
    memcpy(to_ptr(scratch_map), structs_ptr, size_of(Map))
    if scratch_map.contains_key(name) { ... }
}
#+END_SRC
Pros: Works now, fixes leak
Cons: Fragile (hardcoded offsets), diverges from Rust significantly, error-prone

**** Option C: Existence-check methods (has_struct, has_symbol, etc.)
Add cheap existence-check methods that avoid full struct retrieval:
#+BEGIN_SRC til
// Instead of:
_ := self.scope_stack.lookup_struct(name)  // Copies SStructDef
catch { }

// Use:
if self.scope_stack.has_struct(name) { ... }  // Just checks existence
#+END_SRC
Pros: Simple, matches Rust .is_some() pattern, no language changes
Cons: Only helps existence checks (~40 places), doesn't fix cases needing the value

**** Option D: Explicit free/drop for complex types
Add manual memory management:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    // ... use frame ...
    frame.free()  // Explicitly free copied Maps
}
#+END_SRC
Pros: Explicit, controllable
Cons: Error-prone, verbose, easy to forget

**** Option E: For-in loop over Vec doesn't copy (compiler optimization)
Make the compiler smart enough to not copy when iterating:
#+BEGIN_SRC til
for frame: ScopeFrame in self.frames.reverse() {
    // frame is a reference, not a copy (compiler detects loop pattern)
}
#+END_SRC
Pros: Clean syntax, no code changes needed
Cons: Significant compiler work, may be complex to implement correctly

**** Option F: ASAP destruction (Mojo-style automatic delete on last use)
Compiler inserts destructor calls automatically when a value is last used:
#+BEGIN_SRC til
for i in self.frames.len().sub(1)..sub(0, 1) {
    mut frame := ScopeFrame()
    self.frames.get(i, frame)
    if frame.arena_index.contains_key(name) {
        // ...
    }
    // Compiler detects frame's last use and inserts: frame.__del__()
}
#+END_SRC
Pros: Automatic, no manual memory management, matches Mojo semantics
Cons: Requires:
  - Destructor support (__del__ methods on types with heap data)
  - Liveness analysis in compiler to detect last use
  - Careful handling of control flow (returns, throws, branches)
  - May interact poorly with references if added later

This is how Mojo handles memory: values are destroyed as soon as they're last used,
not at end of scope. This enables deterministic destruction without garbage collection.

*** Recommended Approach
Start with Option C (has_* methods) as immediate mitigation - it's simple, matches Rust,
and fixes ~40 call sites. For long-term, evaluate:
- Option F (ASAP destruction) - most automatic, Mojo-proven approach
- Option A (references) - matches Rust semantics closely
- Option E (smart for-in) - transparent optimization

*** Progress
**** Option C implemented (2026-01-29)
Added has_var, has_symbol, has_func, has_enum, has_struct methods to ScopeStack.
Updated all call sites using lookup_*.is_some() pattern to use has_* instead.

Note: The has_* methods still copy ScopeFrame in the for-in loop, which is
Bug #144's problem (for-in iterates by copy). Option C avoids copying the
*definition* objects (VarDef, FuncDef, etc.) but not the ScopeFrame itself.

*** Related Work
- Branch ~claude/detect-ccodegen-translation-diffs-A08OT~ attempted Option B
- That branch was not merged due to Rust/TIL divergence concerns
- ~has_struct~ method was prototyped on that branch

** Bug #113: Self-hosted interpreter fails with "symbol 'msg' not found"
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPACT: Blocks HashMap implementation, breaks til_interpreted tests
:STATUS: Not Reproducible
:END:

*** Status: Not Reproducible (in isolation)
Created src/test/bug113.til to reproduce this issue, but all tests pass in all 4
modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled). The bug may
be specific to the HashMap implementation context and cannot be isolated.

Will not be closed until Bug #112 is resolved, since the bug was initially
reproduced and documented when testing the HashMap implementation for #112.

*** Original Description
The self-hosted TIL interpreter (bin/til) fails with "symbol 'msg' not found" in
~generate_struct_mappings~ when using a ~mut~ variable (that was passed to Vec.get
or Map.get) in a subsequent function call.

*** Reproduction Attempt
#+BEGIN_SRC til
mode test
import("core.vec")

test_it := proc() {
    mut v := Vec.new(I64)
    v.push(42)
    mut val := 0
    v.get(0, val)
    // This line was reported to fail with "symbol 'msg' not found":
    test(loc(), val.eq(42), "test with val")

    catch (err: AllocError) { exit(1) }
    catch (err: IndexOutOfBoundsError) { exit(1) }
}
test_it()
#+END_SRC

*** Observations
- Originally reported to work with rstil but fail with til
- Test file bug113.til passes in all modes - cannot reproduce
- May only occur in specific HashMap implementation context

** Bug #99: Eliminate all C compiler warnings and enable -Werror
:PROPERTIES:
:DISCOVERED: 2026-01-11
:IMPACT: Warnings may hide real bugs; clean builds improve code quality
:STATUS: Open
:END:

*** Description
The generated C code and ext.c produce various gcc warnings. These should be
fixed so we can enable ~-Werror~ (treat warnings as errors) in the build.

*** Compiler flags
- gcc: ~-Werror~ treats all warnings as errors
- rustc: ~-D warnings~ treats all warnings as errors

*** Status
- rustc: DONE - added ~-D warnings~ to Makefile and make.til (no warnings currently)
- gcc: TODO - need to fix warnings before enabling ~-Werror~

*** Warning Categories (updated 2026-01-25)
Audit of generated C code with ~gcc -Wall -Wextra~:

| Type                         | Count | Priority | Notes                                      |
|------------------------------+-------+----------+--------------------------------------------|
| -Wunused-variable            |  1514 | Low      | Generated temp vars not always used        |
| -Wdangling-pointer           |   971 | High     | Statement expressions return &local_var    |
| -Wunused-but-set-variable    |   386 | Low      | Similar to above                           |
| -Wunused-label               |   153 | Low      | Catch labels generated but not jumped to   |
| -Wunused-parameter           |     ? | Low      | Suppressed - underscore params intentional |
| -Wmissing-braces             |     0 | Low      | FIXED 2026-01-25                           |
| -Wmissing-field-initializers |     0 | Low      | FIXED 2026-01-25                           |
| -Wreturn-type                |     0 | High     | FIXED 2026-01-25                           |
| -Wincompatible-pointer-types |     0 | Medium   | FIXED 2026-01-13                           |
| -Wc23-extensions             |     0 | Low      | FIXED 2026-01-28 - emit param names always |

*** Fix Strategy (Incremental)
1. Suppress current warnings to get clean baseline (DONE)
2. Enable ~-Werror~ (DONE - 2026-01-13)
3. Re-enable warning flags one by one, fixing each category
4. Switch to ~-Wall -Wextra -Werror~ with suppressions (DONE - 2026-01-25)
5. Remove suppressions one by one as each warning category is fixed

*** Current Build Flags (target.rs/til)
Now using ~-Wall -Wextra -Werror~ with suppressions for unfixed warnings (2026-01-26):

**** Common flags (both gcc and clang)
- ~-Wno-unused-variable~ (1514 occurrences)
- ~-Wno-unused-but-set-variable~ (386 occurrences)
- ~-Wno-unused-label~ (153 occurrences)

**** GCC-only flags
- ~-Wno-dangling-pointer~ (971 occurrences) - high priority to fix

**** Clang-only flags
- ~-Wno-sometimes-uninitialized~ - exception control flow paths
- ~-Wno-self-assign~ - til_result = til_result patterns in generated code
- ~-Wno-c23-extensions~ - unnamed parameters in function definitions
- ~-Wno-uninitialized~ - variable used before initialization in some paths
- ~-Wno-unused-function~ - enum to_str functions generated but not always used

To fix a warning category: remove the ~-Wno-~ flag and fix the resulting errors.

*** Testing with clang locally (Issue #131)
To build til.til with clang (this is what fails in macOS CI):
#+begin_src bash
./bin/rstil build src/til.til --cc=clang --force-rebuild
#+end_src

To run tests with clang instead of gcc:
#+begin_src bash
./bin/rs/make tests --cc=clang
#+end_src

Note: ~./make.til tests --cc=clang~ does NOT work because the shebang causes
rstil to consume the flag. Use the compiled binary ~./bin/rs/make~ directly.

*** Additional Fix: Null byte escaping in ccodegen (2026-01-13)
GCC 13 errors on raw null bytes in string literals. Fixed emit_str_literal() in
ccodegen.rs and ccodegen.til to escape null bytes as ~\0~ in C output.

*** Progress
- [X] Step 1: Suppress warnings (add -Wno-incompatible-pointer-types, -Wno-int-conversion)
- [X] Step 2: Add -Werror to build (2026-01-13)
- [X] Step 3a: Fix and re-enable -Wincompatible-pointer-types (2026-01-13) - added (til_Dynamic*) cast for hoisted args, used decl.value_type for constant types
- [X] Step 3b: Fix and re-enable -Wdiscarded-qualifiers (2026-01-13) - added const to enum_to_str
- [X] Step 3c: Fix and re-enable -Wint-conversion (2026-01-13) - cast RHS to Dynamic in emit_assignment
- [X] Step 3e: Enable and fix -Wreturn-type (2026-01-25) - add implicit return 0 to throwing functions, add zero-initialized fallback return to non-throwing functions with return types
- [X] Step 4: Switch to -Wall -Wextra -Werror with suppressions (2026-01-25)
- [X] Step 5a: Remove -Wno-dangling-pointer (971 occurrences) - fixed by Bug #143, flag removed in Bug #140 fix
- [-] Step 5b: Remove -Wno-unused-variable (1514 occurrences, partial progress)
- [ ] Step 5c: Remove -Wno-unused-but-set-variable (386 occurrences)
- [ ] Step 5d: Remove -Wno-unused-label (153 occurrences)
- [X] Step 5e: Remove -Wno-unused-parameter (2026-01-25) - emit unnamed C params for underscore-prefixed TIL params (e.g., ~const til_Str*~ instead of ~const til_Str* til__path~); also emit unnamed argc/argv in main() when not used
- [X] Step 5f: Remove -Wno-missing-braces (2026-01-25) - use Ptr() instead of NULL for Declaration.default_value in desugarer.til/garbager.til; Ptr() emits ~((til_Ptr){0})~ with proper braces
- [X] Step 5g: Remove -Wno-missing-field-initializers (2026-01-25) - add cap=0 to Str literals for Type params in ccodegen emit_main_args

** Bug #94: gcc warnings cause bug47.til compilation failure
:PROPERTIES:
:DISCOVERED: 2026-01-08
:IMPACT: Compiled mode fails for complex tests
:STATUS: Open
:END:

*** Description
~src/test/bug47.til~ originally failed with exit code 141 in rs_compiled mode.
GCC failed due to ~-Werror~ treating warnings as errors.

*** Test Results (2026-01-13)
| Mode            | Result              | Time  |
|-----------------+---------------------+-------|
| rstil interpret | pass                | 2.3s  |
| rstil run       | pass                | 5.2s  |
| til interpret   | pass                | 53s   |
| til run         | OOM killed (exit 137) | ~61s  |

~til run~ gets SIGKILL from OOM killer after ~61s (with 10s sys time indicating
memory pressure). The til ccodegen uses excessive memory when processing
bug47.til which imports self.typer (most of the compiler).

Note: til is ~20x slower than rstil for interpretation, but the real issue
is memory consumption during ccodegen causing OOM.

*** Current Warnings (2026-01-13)
1654 total warnings when compiling with ~gcc -Wall -Wextra~:

| Count | Type                        | Severity |
|-------+-----------------------------+----------|
|   933 | -Wunused-variable           | Low      |
|   318 | -Wdangling-pointer          | High     |
|   195 | -Wincompatible-pointer-types | Medium   |
|   135 | -Wunused-but-set-variable   | Low      |
|    66 | -Wunused-label              | Low      |
|     5 | -Wunused-parameter          | Low      |
|     1 | -Wreturn-type               | High     |
|     1 | null character in literal   | Low      |

**** Dangling Pointer (318 occurrences)
Statement expressions return pointers to local variables that go out of scope:
#+BEGIN_SRC c
// Generated code pattern:
if (til_not(({ til_Bool _tmp = til_U8_eq(&a, &b); &_tmp; })).data) { ... }
//                                                 ^^^^^
// _tmp goes out of scope, pointer dangles
#+END_SRC

**** Incompatible Pointer Types (195 occurrences)
Vec_push expects ~void**~ but receives typed pointers:
#+BEGIN_SRC c
til_Vec_push(&_err, &vec, &_tmp_str);  // _tmp_str is til_Str*
#+END_SRC

**** Return Type (1 occurrence)
Function ~til_get_value_type~ at line 13360 - control reaches end without return.

*** Progress (2026-01-25)
Most warning issues now consolidated into Bug #99 (gcc warnings). Bug #140 (dangling pointers) fixed via Bug #143.

*** TODO
- [X] Investigate why ~til run bug47.til~ fails - OOM during ccodegen
- [X] Fix missing return statement (commit 129ba21a)
- [X] Add casts for Vec_push calls - fixed in Bug #99 Step 3a (-Wincompatible-pointer-types)
- [X] Consider which unused-* warnings to fix vs suppress - done in Bug #99 Step 4
- [ ] Fix til ccodegen memory usage (OOM on large files) - may be fixed by Issue #117 (borrow checker)
- [X] Fix dangling pointer pattern - fixed by Bug #143

*** Related Issues
- Bug #99: Eliminate all C compiler warnings and enable -Werror (main tracking)
- Bug #140: Dangling pointers in generated C code (FIXED via Bug #143)
- Issue #117: Borrow checker / memory management (may fix OOM)

** Bug #80: ccodegen.til generates different C code than ccodegen.rs
:PROPERTIES:
:DISCOVERED: 2026-01-01
:IMPACT: til_compiled fails - ./bin/til build/run generates invalid C code
:STATUS: Active
:END:

*** Description
The self-hosted TIL compiler generates C code that differs from the Rust compiler's output.
The generated C code fails to compile with gcc due to multiple issues.

*** History

**** 2026-01-01 to 2026-01-08: Initial Approach (Abandoned)
Original approach was to incrementally fix divergences in the existing ccodegen.til
through line-by-line comparison with ccodegen.rs. This proved problematic because:
- ccodegen.til had many missing ports from Rust
- Contained unauthorized workarounds and non-matching comments
- AI assistants kept adding more divergences instead of fixing them
- The accumulation of issues made systematic comparison impossible

**** 2026-01-09: Fresh Rewrite
Decision made to delete all self-hosted compiler files and start fresh:
- Commit ~1f29279a~: "Remove self-hosted compiler files for fresh rewrite"
- Blind translation of ccodegen.til, builder.til, til.til from Rust
- ~150+ commits fixing syntax, types, missing methods, etc.

***** WARNING: Broken Commit Range
Commits from ~1f29279a~ (origin/master + 1) through ~fad411f8~ are ALL BROKEN.
The build fails throughout this range because:
1. Fresh translation introduced many syntax/type errors
2. Each commit fixed some errors but build still failed
3. Only at ~fad411f8~ "Fix uninitialized variables..." does build pass again

This matters for:
- ~git bisect~: Skip this entire range, it's all broken
- ~git rebase -i~: Could squash ~1f29279a..fad411f8~ into single commit
- Archaeology: Don't waste time investigating individual commits in this range

**** 2026-01-12: Progress - Fixed if-let-Ok pattern in init.til
Build passes. 80/80 tests pass (0 failures). Test breakdown:
- 65 tests in all_common (pass all 4 modes) - includes maps.til!
- 1 test in til_common (panic.til)
- 4 tests in rs_interpreted
- 3 tests in rs_compiled
- 7 tests in rs_common
- 0 tests in til_interpreted (empty!)

Recent fixes:
- Fixed gcc stderr handling in builder.til to match Rust (capture stderr, only show on failure)
- Fixed hoisted_exprs collision: clear per-function to avoid cross-file line/col key collisions
- Fixed many if-let-Some translation bugs in ccodegen.til per rs2til.org rules:
  - emit_switch: enum_has_payloads, collect_declarations, payload lookup patterns
  - collect_declarations_recursive: type inference pattern
  - emit_assignment, emit_if, emit_while: vt check patterns
  - Various enum/struct lookup patterns with flag variables
- KEY FIX: Fixed if-let-Ok translation bug in init.til get_fcall_value_type
  - target_type was used after get_value_type could throw, causing garbage data
  - Added flag pattern: ~mut have_target_type := true~ with catch setting to false
  - This fixed enums.til and other nested function + switch case failures
- KEY FIX: Fixed ext.c run_cmd returning wrong exit code when output exceeds 64KB buffer
  - Rust's Command::output() captures all output; ext.c had 64KB limit
  - When buffer filled, pclose() with unread data caused gcc to get SIGPIPE -> non-zero exit
  - Added drain loop to consume remaining output before pclose()
  - This fixed maps.til and allowed moving it to all_common (all 4 modes pass)

*** Root Cause Analysis

The recurring bug pattern was if-let-Some/if-let-Ok translations from Rust:

#+begin_src rust
// Rust: if get_value_type fails, body is skipped
if let Ok(target_type) = get_value_type(context, first_arg) {
    // use target_type
}
#+end_src

#+begin_src til
// WRONG TIL: target_type is garbage if get_value_type throws!
target_type := get_value_type(context, first_arg)
catch (err: Str) { }
switch target_type {  // Uses garbage!
#+end_src

#+begin_src til
// CORRECT TIL: flag pattern per rs2til.org
mut have_target_type := true
target_type := get_value_type(context, first_arg)
catch (err: Str) {
    have_target_type = false
}
if have_target_type {
    switch target_type {  // Safe to use
#+end_src

*** Remaining Work
- 7 tests in rs_common (pass with rstil but not with til)
- Final verification: ~./src/til_diff.til src/til.til~ must show no differences
  - Note: times out at 300s - likely infinite loop (til compiled total is only 80s)

*** Debugging Tools

- ~./src/til_diff.til src/test/foo.til~ - compare rstil vs til generated C code
- ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ - test single file
- ~./make.til til_debug~ - build til with debug symbols for gdb
- ~gdb ./bin/til_debug~ - step through with breakpoints, inspect variable values
- ~gdb -batch -ex "run ..." -ex "bt" ./bin/til~ - get crash backtrace
- Look at ~gen/c/test/*.c~ for generated code

TIL code must be an exact translation from Rust (comments and variable names included)
using rs2til.org translation rules. Any differences detected must be fixed immediately,
even if only cosmetic.

Current test: ~src/test/c_mem.til~

**** Iterative Fix Workflow
1. User picks a test from til_interpreted that they want working in til_compiled
2. Run ~./src/til_diff.til src/test/chosen_test.til~ to compare rstil vs til generated C code
3. Analyze the diff - identify what's different in the generated C
4. Identify root cause in ccodegen.til
5. Verify against Rust - check equivalent code in ccodegen.rs
6. Fix following rs2til.org - apply correct translation pattern
7. Test the fix: ~./bin/til run src/test/chosen_test.til~
8. Run ~timeout 300 make benchmark~ (always use timeout 300 for make benchmark)
9. Re-run all failing tests in parallel to update TODO comments:
   - Run ~timeout 10 ./bin/til run src/test/X.til 2>&1~ for each test in til_interpreted
   - Update inline TODO comments with current errors
   - If any tests now pass, move them from til_interpreted + rs_common to all_common
   - If tests were moved, run ~make benchmark~ again to verify
10. Commit the fix (tests.til now has up-to-date TODOs and test locations)
11. Wait for user to pick next test to fix

**** Test Tracking
Each test in til_interpreted (src/tests.til) has an inline TODO comment explaining
why it fails in til_compiled:
#+BEGIN_SRC til
til_interpreted.push(TestEntry(path="src/test/foo.til"))  // TODO: too few args to til_Array_get
#+END_SRC
When a test passes til_compiled, remove TODO and move to all_common.

**** Updating TODO Comments
- Run ~timeout 10 ./bin/til run src/test/foo.til 2>&1~ for each test to get the error
- Use timeout to catch infinite loops (exit code 124 = timeout)
- Run tests in parallel (multiple Bash tool calls), no shell loops
- NO filtering (no head, tail, grep) - see full output
- Extract the key error from output and add as inline TODO comment

**** Critical Rules
- Source of truth is Rust + rs2til.org - TIL code must match Rust translated per rs2til.org rules
- Validate changes by comparing Rust to TIL - run ~git diff~ and check both sides match per rs2til.org
- Correctness per rs2til.org is primary - whether a change "fixes" a test is secondary
- If change follows rs2til.org but doesn't fix issue - there's a DIFFERENT bug elsewhere
- NEVER filter make benchmark output - see ALL errors
- Variable shadowing is now supported (Bug #97 fixed via name mangling)
- Port fixes to BOTH Rust and TIL when needed

**** Files Modified
- src/self/ccodegen.til
- src/self/builder.til
- src/til.til
- src/rs/ccodegen.rs (when porting fixes)
- src/rs/builder.rs (when porting fixes)
- src/tests.til (when moving tests back to all_common)

*** Progress

**** Fixed Issues (from fresh rewrite)
1. Variable shadowing in emit_declaration (fcall_arg, hoisted_arg, ref_arg)
2. Variable shadowing in builder (reuse errors vector, default_fd rename)
3. Uninitialized variables after throwing calls:
   - detect_variadic_fcall (8 locations)
   - get_type_arg_name
   - lookup_struct
   - get_fcall_func_def in emit_throw
   - get_fcall_func_def in hoist_throwing_expr

**** Issues Found in hello_script.til Diff (2026-01-11)
Current diff from ~./src/til_diff.til src/examples/hello_script.til~:

***** Issue 1: til_Array_get missing 3 arguments
rstil generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1, til_extra_msgs, &_for_i_panic_0, (til_Dynamic*)&til_extra_msg);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_panic_1 = til_Array_get(&_err0__tmp_panic_1);
#+END_SRC
Affects 5 locations in hello_script.til (lines 101, 132, 165, 185, 233)

****** 2026-01-11: Fixed - Multiple issues in emit_throwing_call* functions
Root cause: Several interrelated bugs in argument emission for throwing function calls.

1. Catch block placement: Catch blocks were placed AFTER emit_arg_with_param_type(),
   so when param_by_ref.get() or param_types.get() threw IndexOutOfBoundsError,
   emit_arg_with_param_type was skipped entirely, causing missing arguments.

2. param_types type mismatch: emit_throwing_call_propagate and emit_throwing_call_with_goto
   stored Vec<Ptr> but hoist_for_dynamic_params expected Vec<ValueType>. This caused
   incorrect Dynamic casts to be applied to all arguments.

3. regular_arg_count defaulting to 0: In emit_throwing_call_with_goto, for non-variadic
   functions, regular_arg_count came from variadic_info.regular_count which defaults to 0.
   The loop `if arg_i.sub(1).gteq(regular_arg_count)` would break immediately.
   Fixed by using 999999999 for non-variadic (matches Rust's usize::MAX pattern).

Fixed in emit_throwing_call, emit_throwing_call_propagate, emit_throwing_call_with_goto:
- Move catch blocks immediately after .get() calls, before emit_arg_with_param_type
- Change param_types from Vec<Ptr> to Vec<ValueType>
- Convert ValueType to Ptr when calling emit_arg_with_param_type
- Use large default for regular_arg_count in non-variadic case

After fix: til_Array_get arguments now match rstil output.
Remaining diffs are hoisting differences (temp var numbering) which are cosmetic.

***** Issue 2: til_malloc missing 1 argument
rstil generates:
#+BEGIN_SRC c
til_I64 _tmp_format_13 = til_add(&til_result.cap, &(til_I64){1});
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12, &_tmp_format_13);
#+END_SRC
til generates:
#+BEGIN_SRC c
int _status__tmp_format_12 = til_malloc(&_ret__tmp_format_12, &_err0__tmp_format_12);
#+END_SRC

***** Issue 3: Hoisting differences
rstil hoists expressions to temp vars:
#+BEGIN_SRC c
til_I64 _tmp_format_14 = til_mul(til_index, &til_self->type_size);
const til_I64 til_src = til_add(&til_self->ptr, &_tmp_format_14);
#+END_SRC
til uses inline compound literals:
#+BEGIN_SRC c
const til_I64 til_src = til_add(&til_self->ptr, &(til_I64){til_mul(til_index, &til_self->type_size)});
#+END_SRC
Both are valid C but cause temp variable numbering drift.

***** Issue 4: .msg inline vs hoisted
rstil hoists format call:
#+BEGIN_SRC c
til_Str _tmp_til_Array_get_7 = til_format(...);
*_err1 = (til_IndexOutOfBoundsError){.msg = _tmp_til_Array_get_7};
#+END_SRC
til inlines:
#+BEGIN_SRC c
*_err1 = (til_IndexOutOfBoundsError){.msg = til_format(...)};
#+END_SRC

****** 2026-01-12: Fixed - is_struct_constructor catch placement in init.til
The is_struct_constructor function in init.til had a catch block placed outside
the if block where the throwing code was:

#+BEGIN_SRC til
// WRONG - catch was outside if block, never catches lookup_struct exceptions
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    return true
}
catch (err: KeyNotFoundError) {  // Never triggered!
    return false
}
#+END_SRC

Fixed by moving the catch inside the if block:

#+BEGIN_SRC til
// CORRECT - catch inside same scope as throwing code
if parts.len().eq(1) {
    _ := self.lookup_struct(struct_name)
    catch (err: KeyNotFoundError) {
        return false
    }
    return true
}
#+END_SRC

This fix resolves the hoisting differences - til_diff.til now shows "OK: No differences found!"

****** 2026-01-12: Test re-categorization after is_struct_constructor fix
With the catch placement fix, many tests now pass til_compiled mode.
Updated test categories in src/tests.til:
- 17 tests in all_common (pass all 4 modes)
- 49 tests in til_interpreted (pass til interpret, fail til compile)
- 53 tests in rs_common (pass rstil, fail til compile)

****** 2026-01-12: Discovered til.til run_cmd_vec swallows output
Tests showing "empty output" in til_compiled mode are caused by til.til's
run_cmd_vec function capturing stdout into a variable but never printing it:

#+BEGIN_SRC til
run_cmd_vec := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args { full_cmd = full_cmd.concat(" ").concat(arg) }
    mut output := ""
    return output.run_cmd("bash", "-c", full_cmd)  // output captured but never printed!
}
#+END_SRC

In contrast, rstil.rs uses Command::new().status() which inherits stdout.
This is NOT a ccodegen bug - the C code is identical. Needs separate fix in til.til.

****** 2026-01-12: Fixed run_cmd_vec output swallowing
Added run_cmd_vec_print to sys.til that prints captured output after run_cmd:

#+BEGIN_SRC til
run_cmd_vec_print := proc(cmd: Str, args: Vec) returns I64 {
    mut full_cmd := cmd
    for arg: Str in args {
        full_cmd = full_cmd.concat(" ").concat(arg)
    }
    mut output := ""
    exit_code := output.run_cmd("bash", "-c", full_cmd)
    if output.len().gt(0) {
        print(output)
    }
    return exit_code
}
#+END_SRC

Updated til.til's run_file_or_exit to use run_cmd_vec_print instead of run_cmd_vec.
This matches rstil.rs's Command::new().status() behavior of inheriting stdout.

****** 2026-01-12: Final test re-categorization after run_cmd_vec_print fix
Tests that were failing with "empty output" now work correctly.
Updated test categories in src/tests.til:
- 22 tests in all_common (pass all 4 modes)
- 1 test in til_common (panic.til - error msg format differs "til" vs "rstil")
- 43 tests in til_interpreted (pass til interpret, fail til compile)
- 48 tests in rs_common (pass rstil, fail til compile)
- Total: 121 tests, 0 failures

Tests moved to all_common:
- hello_cli.til, hello_script.til, lolalalo.til (examples)
- bug46.til, underscore.til (tests)

****** 2026-01-12: Fixed hello_test.til constant folding
Two fixes to make hello_test.til pass til_compiled:

1. emit_arg_with_param_type in ccodegen.til: Added fc_fd_found flag to prevent
   double-emission when catch block handles KeyNotFoundError. The catch block
   would emit the expression, then code continued to emit it again.

2. is_comptime_evaluable in precomp.til: Changed from lookup_func to
   get_func_def_for_fcall_with_expr for proper UFCS resolution. This allows
   constant folding of expressions like ~not(I64.eq(42, 43))~.

Tests moved to all_common (11 tests):
- hello_test.til, arithmetics.til, boolean.til
- branchless.til, bug41.til, circular_test.til, comparisons.til
- eval.til, intro.til, literals.til, namespaces.til, variadic.til

Tests moved back from all_common (failed til_compiled):
- arenas.til (gcc type mismatch)
- arrays.til (gcc type mismatch)
- bug52.til (gcc shadow warning)
- underscore.til (segfault)

**** Known Error Patterns in Generated C
- ~too few arguments to function~ - missing args in generated calls
- ~undeclared variable~ - variable not emitted

*** Files That Must Match
- ~ccodegen.til~ must match ~ccodegen.rs~
- ~til.til~ must match ~rstil.rs~
- ~builder.til~ must match ~builder.rs~
- ~target.til~ must match ~target.rs~

*** Final Verification
~make benchmark~ - all tests pass

