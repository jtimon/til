#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-11-10
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #38: Vec.get doesn't preserve enum payload values
:PROPERTIES:
:DISCOVERED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Open
:END:

*** Description
When storing enums with payloads in a Vec and retrieving them with Vec.get, the enum tag is preserved but the payload value is corrupted.

#+BEGIN_EXAMPLE til
PayloadEnum := enum {
    None,
    Number: I64,
    Text: Str,
}

p := PayloadEnum.Number(42)
mut items := Vec.new(PayloadEnum)
items.push(p)

mut out := PayloadEnum.None
items.get(0, out)

// Expected: out is PayloadEnum.Number(42)
// Actual: out is PayloadEnum.Number(2745) - payload corrupted
#+END_EXAMPLE

*** Root Cause
The memcpy-based storage in Vec copies the enum bytes (tag + payload), but the payload bytes are not being correctly interpreted when read back. The issue is likely in how Arena stores enum payloads vs how Vec's raw memory storage works.

*** Workaround
Use enums without payloads in Vec collections, or store payload data separately.

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_payload() (currently disabled)

** Bug #37: Vec.push with direct enum constructor doesn't store data correctly
:PROPERTIES:
:DISCOVERED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Open
:END:

*** Description
When pushing an enum value directly using a constructor expression (e.g., `colors.push(SimpleColor.Red)`), the data is not stored correctly in the Vec. However, pushing via a variable works correctly.

#+BEGIN_EXAMPLE til
SimpleColor := enum { Red, Green, Blue }

mut colors := Vec.new(SimpleColor)

// This FAILS - data is corrupted:
colors.push(SimpleColor.Red)

// This WORKS:
c := SimpleColor.Red
colors.push(c)
#+END_EXAMPLE

*** Root Cause
When calling Vec.push with a Dynamic parameter that is an enum constructor expression (not a variable), the to_ptr() function doesn't return the correct arena offset for the temporary enum value. The expression is evaluated but the result isn't stored in a location that to_ptr() can find.

*** Workaround
Always assign enum values to variables before pushing to Vec:

#+BEGIN_EXAMPLE til
c_red := SimpleColor.Red
colors.push(c_red)
#+END_EXAMPLE

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_direct_push() (currently disabled)

** Bug #35: Special `_` variable does not allow repeated declarations :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
The special `_` variable (used for discarding return values) throws "already declared" errors when used multiple times in the same scope.

#+BEGIN_EXAMPLE til
// This should work (both values are discarded):
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)  // ERROR: '_' already declared
#+END_EXAMPLE

*** Fix (2025-12-14)
Modified type checker and code generator to special-case "_" declarations:

*Type checker (init.rs, init.til):*
1. In =declare_var()=: Skip the "already declared in this scope" check when name is "_"
2. In =init_context()= Declaration handler: Skip the "already declared" check when name is "_"

*Code generator (ccodegen.rs, ccodegen.til):*
1. In =emit_constant_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
2. In =emit_global_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
3. In =emit_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations

This approach:
- Allows multiple "_" declarations in the same TIL scope
- Generates unique C variable names (like =_tmp0=, =_tmp1=) to avoid C redefinition errors
- Evaluates the RHS expression for its side effects (return value is discarded)

*** Now Works
#+BEGIN_EXAMPLE til
// Both values are discarded - no error
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)
#+END_EXAMPLE

*** Test Coverage
- src/test/underscore.til: Tests multiple "_" declarations at both top-level and function scope

*** Files Modified
- src/rs/init.rs: declare_var, init_context
- src/rs/ccodegen.rs: emit_constant_declaration, emit_global_declaration, emit_declaration
- src/self/init.til: declare_var, init_context
- src/self/ccodegen.til: emit_constant_declaration, emit_global_declaration, emit_declaration

** Bug #34: Code after catch blocks doesn't run in error path
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Error handling semantics
:STATUS: Partially Fixed
:END:

*** Description
Code placed AFTER catch blocks doesn't run when an error is caught.

*** Partial Fix (2025-12-15)
A fix was attempted that works ONLY when there's no code between the throwing
call and the catch block:

#+BEGIN_EXAMPLE til
// This case WORKS after the partial fix:
throwing_call()
catch (err: Error) { }
code_after_catch()  // Runs correctly in both paths
#+END_EXAMPLE

*** Remaining Bug
When there IS code between the throwing call and the catch block, the code
AFTER the catch block does NOT run on the error path:

#+BEGIN_EXAMPLE til
// This case is BROKEN:
throwing_call()
between = true      // Between throw and catch - correctly skipped
catch (err: Error) {
    // error caught
}
code_after_catch()  // BUG: Does NOT run when error was caught!
#+END_EXAMPLE

*** Workaround
Do not put any code between a throwing call and its catch block. Move such
code either before the throwing call or after the catch block.

*** Root Cause (partial fix)
In the C code generator, statements after the last catch block were emitted BEFORE
the ~goto _end_catches~ jump, so they only ran on the success path.

*** Files Modified (partial fix)
- src/rs/ccodegen.rs: Rust implementation
- src/self/ccodegen.til: TIL port
- src/test/errors.til: Regression test (test_bug34 - only tests simple case)

** Bug #33: for-in loops don't work with enum collections
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:FIXED: 2025-12-15
:END:

*** Description
The for-in loop syntax doesn't work when iterating over collections of enum values (e.g., Vec<ValueType>).

#+BEGIN_EXAMPLE til
// This fails:
for val: ValueType in vec_of_valuetypes {
    // ...
}
#+END_EXAMPLE

*** Root Cause
The for-in desugaring in precomp.rs creates code like:

#+BEGIN_EXAMPLE til
for _for_i in 0..collection.len() {
    mut val := ValueType()    // <-- Problem: no parameterless constructor
    collection.get(_for_i, val)
    // body
}
#+END_EXAMPLE

For structs, `StructName()` creates a default-initialized instance. But enums don't have a parameterless constructor - all variants require payloads (e.g., `ValueType.TCustom(Str)`, `ValueType.TFunction(FunctionType)`).

*** Fix Applied
Changed for-in desugaring to detect when the iteration type is an enum and generate
an appropriate placeholder value using the first variant:
- For variants without payload: `EnumType.FirstVariant`
- For variants with payload: `EnumType.FirstVariant(default_payload)`

The placeholder value is immediately overwritten by the get() call, so any valid
variant works as an initializer.

*** Files Changed
- src/rs/precomp.rs: Added build_default_value() helper and updated precomp_forin()
- src/self/precomp.til: TIL port with build_default_value_for_forin() and updated precomp_forin()
- src/test/forin_enum.til: Regression test
- src/tests.til: Added forin_enum.til to test suite
- src/test/run_cmd.til: Updated directory list (bots/ removed, c/ and out/ added)

*** Affected Code
- src/self/typer.til: Converted for-in loops over ValueType to while loops
- src/self/ccodegen.til: Same workaround applied

** Bug #32: TIL doesn't support chained field access + method calls
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Open
:END:

*** Description
TIL doesn't support chained field access followed by method calls like:
#+BEGIN_EXAMPLE til
lexer.peek().token_type.eq(TokenType.Colon)
#+END_EXAMPLE

This causes parse errors like:
#+BEGIN_EXAMPLE
Expected '(' after method name 'token_type', found 'Dot'
#+END_EXAMPLE

Or type errors like:
#+BEGIN_EXAMPLE
Cannot call 'peeked.token_type', it is not a function, it is 'TokenType'
#+END_EXAMPLE

*** Workaround
Use intermediate variables:
#+BEGIN_EXAMPLE til
peeked := lexer.peek()
peeked_tt := peeked.token_type
switch peeked_tt {
case TokenType.Colon:
    // ...
}
#+END_EXAMPLE

*** Affected Code
- src/self/parser.til: parse_for_statement (TODO #32 workaround)

* Fixed Bugs Summary

** Bug #36: Throwing functions in struct literal parameters not recognized :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Type checker correctness
:STATUS: Fixed
:END:

*** Description
When calling a throwing function inside struct literal named parameters, the compiler failed to recognize that the function throws and incorrectly reported that the error type is never thrown.

*** Fix
Modified =check_body_returns_throws= in typer.rs/typer.til to:
1. Handle =NamedArg= nodes inside function call arguments
2. Check arguments of struct/enum constructors (=Ok(None)= / =KeyNotFoundError= case)
3. Track thrown types from nested function calls in both cases

*** Changes
- src/rs/typer.rs: Added NamedArg handling and struct constructor argument checking
- src/self/typer.til: Ported same fix from Rust
- src/std/map.til: Removed workaround (can now inline clone() calls)
- src/self/init.til: Added throws declarations to clone() functions
- src/test/errors.til: Regression test (test_bug36)

** Bug #31: Switch on struct field with pattern matching fails :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-06
:FIXED: 2025-12-06
:IMPACT: Self-hosting, pattern matching
:STATUS: Fixed
:END:

*** Description
When using =switch= on a struct field that is an enum (e.g., =switch s.color=), pattern matching with payload extraction failed with "Enum definition for 'StructName' not found" error.

*** Example Problem
#+BEGIN_EXAMPLE til
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)
    switch s.color {
    case Color.Number(n): result = n  // FAILED: Enum definition not found
    case: result = 0
    }
}
#+END_EXAMPLE

*** Root Cause
Two issues in interpreter and arena code:

1. *Pattern matching code extracted only base identifier* (interpreter.rs:390-394):
   When processing =switch s.color=, the code only extracted "s" from =to_switch.node_type= instead of constructing the full path "s.color".

2. *get_enum didn't resolve field types* (arena.rs:764+):
   =get_enum= looked up the base variable's type instead of the field's type. For "s.color", it got =StructWithPayloadEnum= instead of =Color=.

*** Fix (2025-12-06)
*Rust side:*

1. *interpreter.rs*: Modified pattern matching code to construct full field path from to_switch expression params:
#+BEGIN_SRC rust
let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
    if !to_switch.params.is_empty() {
        let mut full_path = name.clone();
        for param in &to_switch.params {
            if let NodeType::Identifier(field_name) = &param.node_type {
                full_path.push('.');
                full_path.push_str(field_name);
            }
        }
        full_path
    } else {
        name.clone()
    }
} else { /* error */ };
#+END_SRC

2. *arena.rs*: Modified =get_enum= to use =get_field_type= for dotted paths:
#+BEGIN_SRC rust
let enum_type = if id.contains('.') {
    match ctx.get_field_type(id) {
        Ok(ValueType::TCustom(type_name)) => type_name,
        // ... error handling
    }
} else {
    // original lookup_symbol logic
};
#+END_SRC

3. *init.rs*: Added =get_field_type= function to resolve the ValueType for a field path.

*TIL side:*
- Ported same changes to interpreter.til, arena.til, and init.til

*** Test Coverage
- src/test/enums.til: =test_switch_on_struct_field= (simple switch on field)
- src/test/enums.til: =test_switch_on_struct_field_with_payload= (pattern matching with payload)

** Bug #30: ext_proc signature mismatch between TIL and Rust :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-03
:FIXED: 2025-12-03
:IMPACT: Type safety
:STATUS: Fixed
:END:

*** Description
=single_print= was incorrectly declared as variadic (=..Str=) in TIL, but =proc_single_print= in ext.rs expects exactly 1 argument.

*** Problem
#+begin_src til
// Wrong declaration (variadic):
single_print := ext_proc(args: ..Str);

// Both pass type check AND runtime (variadic wraps args into Array):
single_print("one")        // Works: Array with 1 element
single_print("one", "two") // Also "works": prints Array representation
#+end_src

*** Why It Wasn't Caught
Variadic parameters get wrapped into an Array before being passed to ext.rs. So =validate_arg_count= sees 1 argument (the Array), passing validation. The function then prints whatever =result.value= is - which would be the Array's string representation instead of the expected Str.

*** Fix (2025-12-03)
1. Changed declaration from variadic to single parameter in core.til:
#+begin_src til
// Correct declaration:
single_print := ext_proc(s: Str);
#+end_src

2. Added warning comment to =proc_single_print= in ext.rs referencing Bug #30.

*** Systemic Issue
The compiler cannot verify that ext_proc TIL declarations match their Rust implementations. Variadic wrapping bypasses =validate_arg_count= by passing all args as a single Array. This is an inherent FFI limitation.

** Bug #28: UFCS fails inside pattern match case bodies with bindings :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-02
:FIXED: 2025-12-02
:IMPACT: Self-hosting, type checking
:STATUS: Fixed
:END:

*** Description
UFCS method calls failed with "Could not find function definition" when inside pattern match case bodies that have bindings (e.g., =case Enum.Variant(binding):=).

*** Root Cause
The =check_body_returns_throws= function ran without proper scope tracking:
1. Pattern binding variables weren't declared in the scope
2. Local variables declared within case bodies weren't visible

*** Fix (2025-12-02)
Added proper scope management to =check_body_returns_throws= in =typer.rs=:

1. *Pattern binding scope*: When processing switch cases with pattern bindings, push a Block scope and declare the binding variable with its payload type (mirrors =check_switch_statement=).

2. *Variable declarations*: When processing Declaration nodes, infer the type from the initializer and declare the variable in the current scope (if not already declared).

Files modified:
- =src/rs/typer.rs= lines 767-825 (NodeType::Switch handler)
- =src/rs/typer.rs= lines 828-845 (NodeType::Declaration handler)

*** Test Coverage
- =src/test/ufcs.til=: =test_ufcs_struct_field_in_pattern_match=
- =src/test/enums.til=: =test_bug28_ufcs_push_in_binding=, =test_bug28_ufcs_len_in_binding=

All tests pass.

** Bug #29: Catch variable not accessible in arena :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-19
:FIXED: 2025-11-19
:IMPACT: Error handling, catch blocks
:STATUS: Fixed
:END:

*** Description
Caught error variable (=err=) not properly stored in execution arena. Accessing =err.msg= in catch block caused:
- Type error: "Undefined symbol 'err'"
- Runtime error: "base variable 'err' not found in arena_index"

Affected: =throw err.msg=, =return err.msg=, =msg = err.msg= - any field access on caught errors.

*** Fix (2025-11-19, commit 0024caa)
Properly register catch parameter in both interpreter and typer:
- =interpreter.rs=: Register base variable when propagating throws (line 3020) and in catch fallback (line 2438)
- =typer.rs=: Create temp_context with catch parameter before type-checking catch body (lines 665-692)

*** Test Coverage
- =src/test/errors.til=: =test_rethrow_error_field= (tests =throw err.msg=)
- =src/test/errors.til=: =test_rethrow_error_field_via_assign= (tests =msg = err.msg= then =throw msg=)

** Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*: ✅ FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
// ✅ Capture the return value
result := my_add(1, 2)

// ✅ Use as argument to another function
double(my_add(3, 4))

// ✅ Explicitly discard with _
_ := get_value()

// ✅ Procs don't return values, no capture needed
print_hello()

// ❌ ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

** Bug #27: Cannot inline Vec.new() as function argument :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-18
:FIXED: 2025-11-18
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
The TIL evaluator cannot handle inline Vec.new(Expr) calls when passed as arguments to functions. This requires creating a variable first instead of passing the expression directly.

*** Example Problem
#+BEGIN_EXAMPLE til
// Rust does (parser.rs:1180):
return Ok(Expr::new_explicit(
    NodeType::Pattern(pattern_info),
    Vec::new(),  // Inline Vec::new() works
    left.line,
    left.col
));

// TIL must do (parser.til:1326-1330):
empty_params := Vec.new(Expr)  // Create variable first
return Expr.new_explicit(NodeType.Pattern(pattern_info), empty_params, left.line, left.col)
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil eval ERROR: Struct argument must be an identifier or field access
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 1780-1796

When evaluating function calls with struct arguments, the evaluator checks if the parameter is marked as 'own'. For non-own struct parameters, it requires the argument to be an identifier or field access (not an arbitrary expression).

The 'params' parameter in Expr.new_explicit is declared as 'params: Vec' (not 'own Vec'), so inline expressions like Vec.new(Expr) are rejected.

*** Fix (2025-11-18)
Modified interpreter.rs to allow non-identifier expression arguments for struct parameters:

1. Lines 1778-1782: For field access chains with expressions, use result_str
2. Lines 1787-1795: For simple expressions (like Vec.new()), use result_str
3. Lines 1899-1904: For non-Identifier node types, allocate struct and copy fields from result_str

The key insight: when an expression is evaluated (like Vec.new(Expr)), the result
is allocated in the arena and result_str contains the identifier. We can use this
to copy the struct to the parameter, just like we do for identifier arguments.

*** Now Works
#+BEGIN_SRC til
// Can inline Vec.new(Expr) directly as argument
return Expr.new_explicit(NodeType.Pattern(pattern_info), Vec.new(Expr), left.line, left.col)
#+END_SRC

*** Previous Workaround (No Longer Needed)
#+BEGIN_SRC til
// Old workaround - create variable first
empty_params := Vec.new(Expr)
return Expr.new_explicit(..., empty_params, ...)
#+END_SRC

** Bug #26: Nested struct corruption in Vec/Map :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-17
:FIXED: 2025-11-17
:IMPACT: Data integrity, collection storage
:STATUS: Fixed
:COMMIT: ea8cd2b
:END:

*** Description
When structs containing nested structs (like Vec, Map, List) were stored in collections, the nested structs were allocated separately instead of inline, causing memory corruption.

*** Fix
Modified insert_struct_at_offset in init.rs to accept optional existing_offset parameter, allowing nested structs to be allocated inline within parent's memory block.

*** Commit
ea8cd2b: Fix Bug #26: nested struct corruption in Vec/Map

** Bug #25: Field offset refactor breaks typer method resolution :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-13
:FIXED: 2025-11-13
:IMPACT: API consistency, method resolution
:STATUS: Fixed - uniform len() API implemented
:END:

*** Description
The typer fails to find I64.eq method when chaining method calls on struct field access (e.g., `s.items.len.eq(0)`). This was discovered during field offset refactoring work but the root cause was different.

*** Example Problem
#+BEGIN_EXAMPLE til
// In ufcs.til line 300 - this WORKS:
items_len := s.items.len

// In ufcs.til line 304 - this FAILS:
len_check := s.items.len.eq(0)  // Error: "Could not find function definition"
#+END_EXAMPLE

The field access works, but method resolution on the result fails!

*** Root Cause (FOUND!)
The real issue was NOT the field offset refactor, but an API inconsistency:
- Vec, List, and Array had `len` as a FIELD instead of a METHOD
- When the typer tried to resolve `s.items.len.eq(0)`, it saw `.len` as a field access
- Field accesses return `auto` type (requiring type inference)
- The typer couldn't properly infer the type for chained method calls
- Result: "Could not find function definition" for `.eq(0)`

This became apparent when `s.items.len` was accessed - it worked as a field, but the moment you tried to call a method on the result, type resolution failed.

*** Solution (2025-11-13)
Implemented uniform len() API across all collection types:

1. **Renamed internal fields**: `len` → `_len` (cap kept as-is)
2. **Added uniform methods**:
   - `len()` returns element count (_len)
   - `size()` returns byte size (len * type_size)
3. **Implemented for**: Vec, List, Array (src/core/core.til)
4. **Updated all code** to use `.len()` method calls:
   - Core library: lexer.til, parser.til, typer.til, interpreter.til
   - Test files: ufcs.til, args.til, arrays.til, dynamic_arrays.til, lists.til, maps.til, mut_test.til, variadic.til
5. **Updated interpreter**: init.rs to look for `._len` field offset
6. **For-loop workaround**: Store `len()` in local variable (e.g., `mut args_len := args.len()`)

*** Now Works
#+BEGIN_EXAMPLE til
// ✅ All these patterns now work correctly:
items_len := s.items.len()
len_check := s.items.len().eq(0)
if i.lt(s.items.len().add(5)) { }
comparison := i.lt(e.params.len())
#+END_EXAMPLE

*** Test Coverage (Regression Prevention)
The existing test file `src/test/ufcs.til` provides comprehensive regression coverage:

**test_bug10_fixed()** (lines 296-317):
- Line 304: `len_check := s.items.len().eq(0)` - EXACT failing pattern
- Line 309: `comparison := i.lt(s.items.len().add(5))` - Chained method calls
- Line 314: `name_len := name.len()` - String len() method

**test_bug10_parser_patterns_fixed()** (lines 320-341):
- Line 334: `len_is_zero := e.params.len().eq(0)` - Another instance of failing pattern
- Line 338: `len_plus_five := e.params.len().add(5)` - Arithmetic on method result

These tests run in the standard test suite and will catch any regression
that breaks chained method calls on field access. All tests pass (exit code 0).

*** Commits
- 27dc3ae: Fix Bug #25: Implement uniform len() API for Vec, List, and Array
- 1444a8b: Complete len() API standardization - fixes Bug #25

** Bug #24: Variable Declarations Share Arena Offsets Instead of Copying :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Fixed - mut declarations now copy
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Fix Applied

**Design Decision**: Only mut declarations create copies. Non-mut declarations share offsets (read-only aliases).

**Implementation** (src/rs/interpreter.rs lines 923-935):
- **mut declarations**: Call insert_struct() + copy_fields() to create independent copy
- **non-mut declarations**: Share arena offset (efficient, type checker enforces immutability)

**Result**:
#+BEGIN_SRC til
mut dup := original  // Creates independent copy
dup := original      // Shares offset (read-only alias)
#+END_SRC

This design aligns with Mojo's ownership model:
- mut = mutable copy (prevents aliasing)
- default = reference (efficient, safe with type checker)
- Future: 'own' keyword for ownership transfer

See doc/ownership.org for full design analysis and Mojo comparison.

**All tests pass**, including test_declaration_creates_copy (args.til:484)

** Bug #24: Struct Field Access Returns Copy Instead of Reference :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-18
:IMPACT: Data structure mutation, memory management
:STATUS: Fixed - Pass-by-reference for field access
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Fix Applied (2025-11-18)

Bug #24 was fixed as part of implementing pass-by-reference for field access parameters and fixing Bug #26.

**Three-part solution:**

*Fix 1: Inline nested struct allocation* (init.rs:1510-1625)
- Modified insert_struct_at_offset to accept optional existing_offset
- Nested structs now allocated inline within parent's memory block
- Previously: nested structs allocated separately, causing corruption

*Fix 2: Pass-by-reference for field access parameters* (interpreter.rs:1820-1872)
- Extended pass-by-ref to field access like `self.type_names.push(...)`
- Share arena offset instead of allocating and copying
- Register field symbols for UFCS method resolution
- Previously only simple identifiers used pass-by-ref

*Fix 3: Zero-copy return value transfers* (interpreter.rs:970-985)
- Detect temporary return values and share offset instead of copy
- mut x := func() now zero-copy (transfers ownership)
- Only copy when source is real variable (preserves Bug #25 fix)

**Result:**
The workaround pattern is no longer needed. Direct field mutations now work:

#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  // ✅ NOW WORKS - modifies via reference!
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

**Test Coverage:**
- src/test/tmp/test_bug24.til - Comprehensive test verifying direct field mutations
- All existing tests pass with the fix

**Note on Workarounds:**
While the bug is fixed, existing workarounds (copy-modify-reassign pattern) can remain for now
as they are functionally equivalent. Workarounds exist in:
- src/core/core.til (List.push, List.set, List.pop, etc.)
- src/core/lexer.til
- src/core/parser.til
- src/core/std.til (potentially)
They can be removed in a future cleanup pass to simplify the code and potentially improve performance.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` ✅
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` ✅
- Throw from regular function ✅

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` ❌

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // ✅ Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed - Field access and method calls work
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
