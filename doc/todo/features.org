#+TITLE: Language Features
#+AUTHOR: TIL Development
#+DATE: 2026-02-23
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks language feature requests -- new syntax, new
capabilities, new operators. Moved here from future.org to separate
features from performance/architecture/cleanup work.

For bugs, see bugs.org. For performance/architecture, see future.org.
For pre-1.0 work, see pre.org. For post-self-hosting, see post.org.

* Open Issues

** Issue #188: Defer statement
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Resource management, cleanup guarantees, memory management
:STATUS: Open
:RELATED: Issue #183 (manual delete calls), Issue #117 (ASAP destruction), Bug #170 (scope-exit deletion)
:END:

*** Description
Add a ~defer~ statement that schedules code to run at scope exit, regardless of
how the scope is exited (normal return, throw, early return). This is a
well-established pattern in Go, Zig, Odin, and Swift (~defer~/~errdefer~).

#+BEGIN_SRC til
read_file := func(path: Str) returns Str = {
    handle := open(path)?
    defer close(handle)

    contents := read_all(handle)?
    return contents
    // close(handle) runs here automatically
}
#+END_SRC

*** Why this matters

*Memory management (#183, #117, #170)*: Even with ASAP destruction and automatic
delete insertion, there are cases where manual cleanup is needed -- aliases,
borrowed pointers, partially constructed state. ~defer~ gives the programmer a
clean way to express "clean this up when we leave" without tracking every exit path.

#+BEGIN_SRC til
process := func(data: Vec) returns Str = {
    temp := data.clone()
    defer Str.delete(temp)

    if some_condition() {
        return early_result()   // temp still gets deleted
    }
    return compute(temp)        // temp still gets deleted
}
#+END_SRC

*Resource management*: When TIL eventually supports streaming file I/O, network
sockets, database connections, etc., defer is the natural pattern for ensuring
resources get released:

#+BEGIN_SRC til
query := func(db: Connection, sql: Str) returns Vec = {
    stmt := db.prepare(sql)?
    defer stmt.finalize()

    results := stmt.execute()?
    return results
}
#+END_SRC

*** Semantics

- Deferred statements execute in LIFO order (last defer runs first)
- Execute on all scope exits: return, throw, end of block
- The deferred expression is evaluated at defer time (captures current values)
  but executed at scope exit
- Multiple defers in the same scope stack up

*** Implementation approach

Desugar in the desugarer or garbager phase. For each scope with defers:
1. Collect defer statements in order
2. At every exit point (return, throw, end of body), insert the deferred
   calls in reverse order before the exit

This is purely an AST transformation -- no runtime support needed. Both
interpreter and compiler benefit automatically.

*** Scope

- Parser: recognize ~defer~ keyword + expression/statement
- Desugarer or garbager: insert deferred calls at exit points
- Port to both Rust and TIL

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #182: Closures -- explicit capture lists for functions and blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- enables higher-order patterns that reference enclosing scope
:STATUS: Open
:RELATED: Issue #91 (first-class functions -- lambdas, function pointers), Issue #181 (standalone body blocks), doc/first_class.org
:END:

*** Description

Closures are functions that access variables from their enclosing scope.
TIL requires *explicit capture lists* using ~[square brackets]~, inspired
by Jai (Jonathan Blow). If a function references an outer variable, it MUST
be listed in the capture list. This makes dependencies visible and
refactoring mechanical.

*** Capture syntax

#+BEGIN_SRC til
scale := 3

// Closure: captures scale from outer scope
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Normal form equivalent:
scaled := numbers.map(func(I64) returns I64 = (a) [scale] { return a.mul(scale) })

// Named closure:
make_scaler : func(s: I64) returns Transformer = {
    return func(a: I64) returns I64 [s] { return a.mul(s) }
}
triple := make_scaler(3)
tripled := numbers.map(triple)  // [3, 6, 9, 12, 15]
#+END_SRC

*** Why explicit captures

Implicit captures (like Python, JavaScript, Rust) feel magical:

Problems:
- *Reading*: you see ~scale~ and have to hunt for where it's defined.
  Is it a global? A local three scopes up? A typo for a parameter?
- *Refactoring*: extracting a block into a function means figuring out
  ALL the implicit dependencies. Miss one and it breaks.
- *Inlining*: moving a closure back inline means understanding what it
  captures to know where it can safely go.

Explicit captures solve all three:
- *Reading*: ~[scale]~ tells you exactly what comes from outside.
- *Refactoring*: captures become parameters. Mechanical transformation.
- *Inlining*: captures tell you exactly what the block depends on.

*** Capture semantics

Captures follow the same rules as function parameters:

| Capture syntax | Semantics                         | Same as param mode |
|----------------+-----------------------------------+--------------------|
| ~[x]~          | Const by reference (default)      | ~x: T~             |
| ~[mut x]~      | Mutable reference                 | ~mut x: T~         |
| ~[copy x]~     | Deep copy (snapshot)              | ~copy x: T~        |
| ~[own x]~      | Ownership transfer (moved in)     | ~own x: T~         |

#+BEGIN_SRC til
mut total := 0
data := Vec.from(1, 2, 3)

// mut capture: closure can modify total
data.for_each(func(x: I64) [mut total] { total = total.add(x) })

// copy capture: closure gets a snapshot, original unchanged
data.map(func(x: I64) returns I64 [copy total] { return x.add(total) })

// own capture: moves data into the closure, caller can't use it after
consume : proc() = [own data] { data.clear() }
#+END_SRC

No new rules to learn -- captures are just arguments that come from the
enclosing scope instead of the call site.

*** Block captures (depends on #181)

Even without making a function, you can add a capture list to a bare
code block to limit what it can see. This is an "insurance policy" that
the block only touches specified state:

#+BEGIN_SRC til
mut total := 0
mut count := 0
data := Vec.from(1, 2, 3)

// Only total and data are accessible inside this block
[total, data] {
    for item in data {
        total = total.add(item)
    }
}
// count is guaranteed untouched
#+END_SRC

*** Refactoring progression (from Jai)

#+BEGIN_SRC til
// Step 1: inline code
total = total.add(x)

// Step 2: block with captures (limit scope, verify dependencies)
[total, x] {
    total = total.add(x)
}

// Step 3: promote to lambda (add params, same captures)
adder : func(a: I64) returns I64 = [total] { return total.add(a) }

// Step 4: promote to pure function (captures become params, no more closure)
adder : func(a: I64, b: I64) returns I64 = { return a.add(b) }
#+END_SRC

Each step is mechanical. The capture list tells you exactly what needs to
become a parameter when you promote to a pure function.

*** Syntax decision needed

Two options for how captures are specified:

**** Option A: Square brackets (Jai-style, current first_class.org design)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Block capture:
[total, data] {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: concise, visually distinct from parameters.
Con: ~[]~ already used for array indexing in many languages. Inconsistent
with ~returns~ and ~throws~ which are keywords, not punctuation.

**** Option B: ~captures~ keyword (consistent with returns/throws)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) captures scale returns I64 { return a.mul(scale) })

// Block capture:
captures total, data {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: consistent with the existing ~returns~ / ~throws~ keyword pattern in
function signatures -- no parentheses, just commas. Reads naturally: "func
that takes I64, captures scale, returns I64". Searchable and greppable.
Con: more verbose.

**** Comparison

#+BEGIN_SRC til
// Option A:
f : func(I64) returns I64 = (a) [scale, mut total] { ... }

// Option B:
f : func(I64) captures scale, mut total returns I64 = (a) { ... }
#+END_SRC

Note: with Option B, ~captures~ sits before ~returns~ in the signature,
like how ~throws~ sits after ~returns~. Full order would be:
~func(params) captures X returns Y throws Z~.

*** References
- Jai Primer: explicit capture lists, same philosophy
- doc/first_class.org: full design document

** Issue #181: First-class bodies -- store, pass, and return code blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- bodies as values, zero-argument closures
:STATUS: Open
:RELATED: Issue #91 (first-class functions), Issue #105 (first-class structs), Issue #106 (first-class enums), Issue #182 (closures), doc/first_class.org
:END:

*** Description

Bodies as values that can be stored, passed, and returned:

#+BEGIN_SRC til
my_block : Body = {
    println("hello")
    some_call()
}

// Pass as argument
run_block(my_block)

// Return from function
make_block : func() returns Body = {
    return { println("deferred") }
}
#+END_SRC

A Body is essentially a zero-argument closure. Should be designed alongside
#91 (first-class functions) and #182 (closures) to share infrastructure and
avoid duplicated effort.

*** Note

Standalone bare ~{ ... }~ blocks already work (parser, interpreter, and
ccodegen all handle Body nodes). This issue is about making bodies into
first-class values, not about block syntax.

** Issue #180: Bang operator ~!~ for panic-on-throw (Rust ~.unwrap()~ equivalent)
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Ergonomics -- cleaner translation of Rust .unwrap(), less boilerplate catch blocks
:STATUS: In Progress
:RELATED: rs2til.org (? operator semantics)
:END:

*** Progress

- [X] Lexer: renamed ~TokenType.Not~ to ~TokenType.ExclamationMark~, removed error for ~!~
- [X] Parser: ~!~ accepted as synonym for ~?~ at all 3 fcall sites (produces ~FCall(true)~)
- [ ] Desugarer: generate catch blocks with ~panic(loc(), "TypeName")~ for each thrown type
- [ ] Typer: consume thrown_types for ~!~ calls so user catch triggers "not among thrown types"
- [ ] Test: ~src/test/panic_bang.til~ with ~expected_status=1~
- [ ] Docs: update ~rs2til.org~ with ~!~ / ~.unwrap()~ mapping

Currently ~!~ behaves identically to ~?~ (no desugaring yet).

*** Description

Currently ~?~ marks that a call may throw. There is no concise way to say
"call this, and if it throws, panic." You must write a full catch block:

#+BEGIN_SRC til
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Propose ~!~ as an alternative to ~?~ meaning "panic on throw":

#+BEGIN_SRC til
result := might_fail(x)!   // panics if might_fail throws
#+END_SRC

This maps directly to Rust's ~.unwrap()~:

#+BEGIN_SRC rust
// Rust
let result = might_fail(x).unwrap();

// TIL equivalent
result := might_fail(x)!
#+END_SRC

*** Implementation

Desugarer transforms ~func()!~ by inserting a catch block with panic for
every throwable type immediately after the call:

#+BEGIN_SRC til
// Before desugaring:
result := might_fail(x)!

// After desugaring:
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Steps:
1. Lexer: recognize ~!~ after fcall (new token or reuse existing)
2. Parser: parse ~!~ like ~?~ but store a flag (e.g. ~FCall(does_throw=true, is_bang=true)~)
3. Desugarer: for bang calls, look up the function's throw types and generate
   a catch block with ~panic(loc(), err.msg)~ for each thrown type

*** Notes

- The desugarer needs access to function signatures to know which error types
  to catch. This is already available via ~context.scope_stack.lookup_func~.
- ~!~ should NOT be allowed on calls that don't throw (typer error).
- Multiple throw types generate multiple catch blocks, all panicking.

** Issue #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Open
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: In progress - FunctionSig type + function pointers done (2026-02-21), next: lambdas/collections
:RELATED: Bug #90 (semicolon/body syntax), Bug #159 (needs func ptrs for deep clone/delete), Issue #105 (First-Class Structs), Issue #106 (First-Class Enums), Issue #182 (Closures -- explicit captures), src/test/function_pointers.til, doc/first_class.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

TIL is now self-hosting, so the earlier concern about "post-self-hosting timing"
is resolved. Additionally, Bug #159 (shallow copy elimination) is blocked on
function pointer support for deep Vec.clone/delete -- making this a priority.

*** Core Semantics

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type declarations*: A function type is a function with no body.
   #+BEGIN_SRC til
   // Function type declaration (no body):
   BinaryOp := func(a: I64, b: I64) returns I64
   // With throws:
   Parser := func(s: Str) returns Ast throws ParseError
   #+END_SRC

3. *Throws are part of the signature*.

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures*: Functions can only reference their own parameters and globals.
   Capturing enclosing scope variables is deferred (likely harder).

6. *Return functions and store in struct fields*: Include if not too much extra
   work over the basic "pass as arguments" support.

*** Example
#+BEGIN_SRC til
// Define a function type (no body = type declaration)
BinaryOp := func(a: I64, b: I64) returns I64

// Function that takes a function as argument
apply : func(op: BinaryOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}

// Define functions matching the type
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }
mul : func(a: I64, b: I64) returns I64 = { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** Syntax Decision

**** New unified syntax (DONE - f9af099f, fb40690b, b0badfdd, 2026-02-21)
Parser uses the unified ~name : Type = value~ syntax for functions,
as designed in doc/first_class.org. Two equivalent forms:
#+BEGIN_SRC til
// Sugar form (names in signature):
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }

// Normal form (type-only params + binding tuple):
add : func(I64, I64) returns I64 = (a, b) { return a.add(b) }
#+END_SRC

**** FunctionSig type definitions (DONE - 65fd0227, 2026-02-21)
#+BEGIN_SRC til
BinaryOp := func(I64, I64) returns I64 {}
my_add : BinaryOp = (a, b) { return a.add(b) }
#+END_SRC

**** Function pointers (DONE - 2026-02-21)
Pass functions as arguments, call through variable, signature compatibility checking.
Typer, interpreter, ccodegen, scavenger all updated.

*** What is missing
- Lambda syntax (anonymous inline functions)
- Storing function pointers in collections (Vec/Map of function pointers)
- Returning functions from functions
- Closures (Issue #182 -- explicit capture lists)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/rs/init.rs / src/self/init.til (SFuncDef, ScopeFrame, ValueType, dispatch)
- src/test/function_pointers.til (test cases)

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured -> splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded -> same behavior, splice
_ := declare_const(a, I64, 42)

// Captured -> get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #106: First-Class Enums
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPACT: Language feature, anonymous data structures
:STATUS: Partial
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs)
:END:

*** Description
Allow anonymous enum type definitions to be passed as arguments:

#+BEGIN_SRC til
some_function(enum {A, B})
#+END_SRC

Similar in spirit to Issue #91 (first-class functions) but for enums.

*** Progress (2026-02-20): Macro-returned enums with namespace support

Implemented the same macro infrastructure that Issue #105 provides for structs,
but for enums. Macro-returned enums now work with =namespace:= blocks and type
parameter substitution in variant payload types.

**** What works
- =macro(T: Type) returns enum { ... }= syntax
- Named enum pattern inside macro body (=TemplatedOption := enum { ... }=)
- Internal-to-external name substitution (=TemplatedOption= -> =I64Option=)
- Type substitution in variant payload types (=Some: T= -> =Some: I64=)
- Pattern substitution in switch-case (=case TemplatedOption.Some(val):= -> =case I64Option.Some(val):=)
- =namespace:= methods on macro-returned enums
- Auto-generated delete/clone methods
- Anonymous enum registration with =__anon_enum_N= temp names
- Global frame enum registration (survives macro function scope pops)
- =returns enum= in parser for macro return types

**** Completed (2026-02-21) -- enum_def_of: runtime enum introspection

**** What remains
- Anonymous enum as inline arguments: =some_function(enum {A, B})=
- Multiple type parameters in enum macros
- Enum macros with complex payload types (structs, nested enums)

** Issue #161: Namespace constants, static mutables, and per-instance immutables
:PROPERTIES:
:DISCOVERED: 2026-02-04
:IMPACT: Unified syntax for type-level and instance-level data
:STATUS: Open - detailed plan ready
:RELATED: Issue #108 (namespace blocks - implemented)
:END:

*** Overview

Follow-up to Issue #108 (namespace blocks for associated functions). This issue
extends namespaces to support constants and mutable state, and adds per-instance
immutable fields to structs.

After this issue, four kinds of declarations exist:

| Location  | Syntax             | Meaning                          |
|-----------+--------------------+----------------------------------|
| namespace | ~Max := 100~       | Associated constant (static)     |
| namespace | ~mut counter := 0~ | Associated mutable (static)      |
| struct    | ~id := 0~          | Per-instance immutable (frozen)  |
| struct    | ~mut name := ""~   | Per-instance mutable             |

*** Step 1: Associated constants in namespace blocks

Move type-level constants from standalone globals into type namespaces.

**** Current state
Constants are standalone globals with naming conventions:
#+BEGIN_SRC til
MAX_I64 := 9223372036854775807
MIN_I64 := -9223372036854775808
I64_SIZE := 8
#+END_SRC

**** Target state
Constants live in type namespaces:
#+BEGIN_SRC til
namespace I64 {
    Max := 9223372036854775807
    Min := -9223372036854775808
    Size := 8
}
// Usage: I64.Max instead of MAX_I64
#+END_SRC

**** Implementation

***** Step 1.1: Verify namespace blocks support constants
Namespace blocks already support function definitions. Verify they also support
constant declarations (non-mut, non-function). This likely already works since
init.rs merges all namespace members into the type.

Test with:
#+BEGIN_SRC til
namespace I64 {
    TestConst := 42
}
assert_eq(loc(), 42, I64.TestConst)
#+END_SRC

Files to check: init.rs:1311-1400, init.til (NamespaceDef handling)

***** Step 1.2: Audit existing constants
Find all type-related constants in the codebase:
- I64: MAX_I64, MIN_I64, I64_SIZE
- U8: (check if any exist)
- Str: (check if any exist)
- Other types in src/core/

***** Step 1.3: Migrate constants to namespaces
For each type, move constants into namespace blocks:
#+BEGIN_SRC til
// Before (in i64.til)
MAX_I64 := 9223372036854775807

// After (in i64.til)
namespace I64 {
    Max := 9223372036854775807
}
#+END_SRC

***** Step 1.4: Update all usages
Find and replace all old constant names:
- ~MAX_I64~ -> ~I64.Max~
- ~MIN_I64~ -> ~I64.Min~
- etc.

***** Step 1.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 2: Associated mutable state in namespace blocks

Allow ~mut~ declarations in namespace blocks - these work like static variables.

**** Use case
#+BEGIN_SRC til
Soldier := struct {
    mut id := 0
    mut name := "unknown"
}

namespace Soldier {
    mut counter := 0  // Static counter shared by all instances

    new := func(name: Str = "unknown") returns Soldier {
        s := Soldier(id=counter, name=name)
        counter = counter + 1
        return s
    }
}

// Usage:
s1 := Soldier.new("Alice")  // id=0
s2 := Soldier.new("Bob")    // id=1
#+END_SRC

**** Implementation

***** Step 2.1: Parser - allow mut in namespace blocks
Check if parser already accepts ~mut~ declarations in namespace blocks.
If not, update parse_namespace_definition to accept them.

Files: parser.rs, parser.til

***** Step 2.2: Init - register namespace mutables
When init processes NamespaceDef, it currently registers functions.
Extend to also register mutable variables with their initial values.

The mutable needs to be:
- Registered as a symbol with is_mut=true
- Stored in the global scope (not per-instance)

Files: init.rs, init.til

***** Step 2.3: Interpreter - handle namespace mutable access
When evaluating ~TypeName.mutable_var~, look up and return/assign the value.
This is similar to how ~TypeName.constant~ works, but allows mutation.

Files: interpreter.rs, interpreter.til

***** Step 2.4: Ccodegen - emit namespace mutable as static
In C, namespace mutables become static variables:
#+BEGIN_SRC c
// For: namespace Soldier { mut counter := 0 }
static long long til_Soldier_counter = 0;
#+END_SRC

Files: ccodegen.rs, ccodegen.til, scavenger.rs, scavenger.til

***** Step 2.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Step 3: Per-instance immutable fields in structs

Allow non-mut fields in structs that are set at construction and frozen afterward.

**** Use case
#+BEGIN_SRC til
Entry := struct {
    id := 0              // Immutable after construction
    mut name := ""       // Mutable
    mut desc := ""       // Mutable
}

mut e := Entry(id=get_unique_id(), name="test", desc="description")
e.name = "new name"  // OK - name is mut
e.id = 999           // ERROR - id is not mut, frozen after construction
#+END_SRC

**** Current state
Non-mut fields in structs are currently used for associated constants/functions:
#+BEGIN_SRC til
MyStruct := struct {
    static_const := 42       // Associated constant (no mut)
    mut instance_data := 0   // Instance field (mut)
}
#+END_SRC

After Issue #108, functions are in namespace blocks. But constants in struct
still work as associated constants (e.g., Cell.CHAR_WIDTH in hello_gui.til).

**** Design decision
With namespace blocks, associated constants should move to namespaces (Step 1).
This frees up non-mut struct fields for a new meaning: per-instance immutables.

Migration path:
1. Step 1 moves associated constants to namespaces
2. Step 3 repurposes non-mut fields for instance immutables
3. Deprecation warning for old pattern during transition

**** Implementation

***** Step 3.1: Migrate existing struct constants to namespaces
Before changing semantics, move all existing struct constants to namespace blocks.
Example from hello_gui.til:
#+BEGIN_SRC til
// Before
Cell := struct {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}

// After
Cell := struct {}
namespace Cell {
    CHAR_WIDTH := 8
    LINE_HEIGHT := 16
}
#+END_SRC

***** Step 3.2: Typer - track field mutability
The typer needs to know which struct fields are mutable vs immutable.
Add check: if assigning to a non-mut field after construction, emit error.

Challenge: distinguishing construction from assignment.
- Construction: ~Entry(id=42)~ - allowed to set immutable fields
- Assignment: ~e.id = 42~ - not allowed for immutable fields

Files: typer.rs, typer.til

***** Step 3.3: Interpreter - enforce field immutability
After struct construction, track which fields are frozen.
Reject mutations to immutable fields.

Approach: In eval_set, before modifying a struct field, check if field is mut.
If not mut and struct already exists, error.

Files: interpreter.rs, interpreter.til

***** Step 3.4: Ccodegen - enforce field immutability (optional)
Could add runtime checks in generated C, or rely on typer catching it.
Typer-only enforcement is simpler and sufficient.

***** Step 3.5: Port to TIL
All changes to .rs files must be ported to .til files.

*** Testing

**** Step 1 tests
#+BEGIN_SRC til
// Test namespace constants
namespace I64 {
    TestMax := 9223372036854775807
}
assert_eq(loc(), 9223372036854775807, I64.TestMax)
#+END_SRC

**** Step 2 tests
#+BEGIN_SRC til
// Test namespace mutable (static)
Counter := struct {}
namespace Counter {
    mut value := 0
    increment := func() returns I64 {
        value = value + 1
        return value
    }
}
assert_eq(loc(), 1, Counter.increment())
assert_eq(loc(), 2, Counter.increment())
assert_eq(loc(), 2, Counter.value)
#+END_SRC

**** Step 3 tests
#+BEGIN_SRC til
// Test per-instance immutable
ImmutableTest := struct {
    id := 0        // Immutable
    mut name := "" // Mutable
}

mut t := ImmutableTest(id=42, name="test")
assert_eq(loc(), 42, t.id)
t.name = "changed"  // OK
// t.id = 99       // Should error: cannot assign to immutable field
#+END_SRC

*** Verification
1. Run ~make benchmark~ after each step - all tests must pass
2. Port each .rs change to .til immediately
3. Test both interpreter and compiler modes

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Deferred to post-self-hosting
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix (deferred)
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.
