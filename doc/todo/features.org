#+TITLE: Language Features
#+AUTHOR: TIL Development
#+DATE: 2026-02-23
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks language feature requests -- new syntax, new
capabilities, new operators. Moved here from future.org to separate
features from performance/architecture/cleanup work.

For bugs, see bugs.org. For performance/architecture, see future.org.
For pre-1.0 work, see pre.org. For post-self-hosting, see post.org.

* Open Issues

** Issue #196: U64 native unsigned 64-bit integer type
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- unsigned 64-bit integer type
:STATUS: Open
:RELATED: U8, U32, I64
:END:

*** Description

Add U64 as a native unsigned 64-bit integer type, following the same pattern
as U8 and I64. U64 gets its own ~u64.til~ file, just like ~u8.til~ and
~i64.til~. Same size as I64, but unsigned.

*** Range

0 to 18,446,744,073,709,551,615 (2^64 - 1)

** Issue #195: U32 native unsigned 32-bit integer type
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- unsigned 32-bit integer type
:STATUS: Open
:RELATED: U8, I64
:END:

*** Description

Add U32 as a native unsigned 32-bit integer type, following the same pattern
as U8 and I64. U32 gets its own ~u32.til~ file, just like ~u8.til~ and
~i64.til~. Half the size of I64, four times the size of U8, unsigned.

*** Range

0 to 4,294,967,295 (2^32 - 1)

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #182: Closures -- explicit capture lists for functions and blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- enables higher-order patterns that reference enclosing scope
:STATUS: Open
:RELATED: Issue #91 (first-class functions -- lambdas, function pointers), Issue #181 (standalone body blocks), doc/first_class.org
:END:

*** Description

Closures are functions that access variables from their enclosing scope.
TIL requires *explicit capture lists* using ~[square brackets]~, inspired
by Jai (Jonathan Blow). If a function references an outer variable, it MUST
be listed in the capture list. This makes dependencies visible and
refactoring mechanical.

*** Capture syntax

#+BEGIN_SRC til
scale := 3

// Closure: captures scale from outer scope
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Normal form equivalent:
scaled := numbers.map(func(I64) returns I64 = (a) [scale] { return a.mul(scale) })

// Named closure:
make_scaler : func(s: I64) returns Transformer = {
    return func(a: I64) returns I64 [s] { return a.mul(s) }
}
triple := make_scaler(3)
tripled := numbers.map(triple)  // [3, 6, 9, 12, 15]
#+END_SRC

*** Why explicit captures

Implicit captures (like Python, JavaScript, Rust) feel magical:

Problems:
- *Reading*: you see ~scale~ and have to hunt for where it's defined.
  Is it a global? A local three scopes up? A typo for a parameter?
- *Refactoring*: extracting a block into a function means figuring out
  ALL the implicit dependencies. Miss one and it breaks.
- *Inlining*: moving a closure back inline means understanding what it
  captures to know where it can safely go.

Explicit captures solve all three:
- *Reading*: ~[scale]~ tells you exactly what comes from outside.
- *Refactoring*: captures become parameters. Mechanical transformation.
- *Inlining*: captures tell you exactly what the block depends on.

*** Capture semantics

Captures follow the same rules as function parameters:

| Capture syntax | Semantics                         | Same as param mode |
|----------------+-----------------------------------+--------------------|
| ~[x]~          | Const by reference (default)      | ~x: T~             |
| ~[mut x]~      | Mutable reference                 | ~mut x: T~         |
| ~[copy x]~     | Deep copy (snapshot)              | ~copy x: T~        |
| ~[own x]~      | Ownership transfer (moved in)     | ~own x: T~         |

#+BEGIN_SRC til
mut total := 0
data := Vec.from(1, 2, 3)

// mut capture: closure can modify total
data.for_each(func(x: I64) [mut total] { total = total.add(x) })

// copy capture: closure gets a snapshot, original unchanged
data.map(func(x: I64) returns I64 [copy total] { return x.add(total) })

// own capture: moves data into the closure, caller can't use it after
consume : proc() = [own data] { data.clear() }
#+END_SRC

No new rules to learn -- captures are just arguments that come from the
enclosing scope instead of the call site.

*** Block captures (depends on #181)

Even without making a function, you can add a capture list to a bare
code block to limit what it can see. This is an "insurance policy" that
the block only touches specified state:

#+BEGIN_SRC til
mut total := 0
mut count := 0
data := Vec.from(1, 2, 3)

// Only total and data are accessible inside this block
[total, data] {
    for item in data {
        total = total.add(item)
    }
}
// count is guaranteed untouched
#+END_SRC

*** Refactoring progression (from Jai)

#+BEGIN_SRC til
// Step 1: inline code
total = total.add(x)

// Step 2: block with captures (limit scope, verify dependencies)
[total, x] {
    total = total.add(x)
}

// Step 3: promote to lambda (add params, same captures)
adder : func(a: I64) returns I64 = [total] { return total.add(a) }

// Step 4: promote to pure function (captures become params, no more closure)
adder : func(a: I64, b: I64) returns I64 = { return a.add(b) }
#+END_SRC

Each step is mechanical. The capture list tells you exactly what needs to
become a parameter when you promote to a pure function.

*** Syntax decision needed

Two options for how captures are specified:

**** Option A: Square brackets (Jai-style, current first_class.org design)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Block capture:
[total, data] {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: concise, visually distinct from parameters.
Con: ~[]~ already used for array indexing in many languages. Inconsistent
with ~returns~ and ~throws~ which are keywords, not punctuation.

**** Option B: ~captures~ keyword (consistent with returns/throws)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) captures scale returns I64 { return a.mul(scale) })

// Block capture:
captures total, data {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: consistent with the existing ~returns~ / ~throws~ keyword pattern in
function signatures -- no parentheses, just commas. Reads naturally: "func
that takes I64, captures scale, returns I64". Searchable and greppable.
Con: more verbose.

**** Comparison

#+BEGIN_SRC til
// Option A:
f : func(I64) returns I64 = (a) [scale, mut total] { ... }

// Option B:
f : func(I64) captures scale, mut total returns I64 = (a) { ... }
#+END_SRC

Note: with Option B, ~captures~ sits before ~returns~ in the signature,
like how ~throws~ sits after ~returns~. Full order would be:
~func(params) captures X returns Y throws Z~.

*** References
- Jai Primer: explicit capture lists, same philosophy
- doc/first_class.org: full design document

** Issue #181: First-class bodies -- store, pass, and return code blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- bodies as values, zero-argument closures
:STATUS: Open
:RELATED: Issue #91 (first-class functions), Issue #105 (first-class structs), Issue #106 (first-class enums), Issue #182 (closures), doc/first_class.org
:END:

*** Description

Bodies as values that can be stored, passed, and returned:

#+BEGIN_SRC til
my_block : Body = {
    println("hello")
    some_call()
}

// Pass as argument
run_block(my_block)

// Return from function
make_block : func() returns Body = {
    return { println("deferred") }
}
#+END_SRC

A Body is essentially a zero-argument closure. Should be designed alongside
#91 (first-class functions) and #182 (closures) to share infrastructure and
avoid duplicated effort.

*** Note

Standalone bare ~{ ... }~ blocks already work (parser, interpreter, and
ccodegen all handle Body nodes). This issue is about making bodies into
first-class values, not about block syntax.

** Issue #180: Bang operator ~!~ for panic-on-throw (Rust ~.unwrap()~ equivalent)
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Ergonomics -- cleaner translation of Rust .unwrap(), less boilerplate catch blocks
:STATUS: In Progress
:RELATED: rs2til.org (? operator semantics)
:END:

*** Progress

- [X] Lexer: renamed ~TokenType.Not~ to ~TokenType.ExclamationMark~, removed error for ~!~
- [X] Parser: ~!~ accepted as synonym for ~?~ at all 3 fcall sites (produces ~FCall(true)~)
- [X] Parser step 2: changed ~FCall(bool)~ to ~FCall(FCallInfo)~ with ~does_throw~ and ~is_bang~ fields
- [X] Typer: skip throw tracking for ~is_bang~ calls (FCall, Declaration, Assignment)
- [X] Desugarer: generate ~catch (err: Type) { panic(loc(), err.msg) }~ for each thrown type
- [ ] Test: ~src/test/panic_bang.til~ with ~expected_status=1~
- [ ] Docs: update ~rs2til.org~ with ~!~ / ~.unwrap()~ mapping

Works for direct function calls (e.g. ~might_fail(x)!~). Method calls
(e.g. ~arr.get(i, val)!~) not yet supported -- desugarer runs before UFCS
and cannot resolve method signatures via ~lookup_func~.

*** Description

Currently ~?~ marks that a call may throw. There is no concise way to say
"call this, and if it throws, panic." You must write a full catch block:

#+BEGIN_SRC til
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Propose ~!~ as an alternative to ~?~ meaning "panic on throw":

#+BEGIN_SRC til
result := might_fail(x)!   // panics if might_fail throws
#+END_SRC

This maps directly to Rust's ~.unwrap()~:

#+BEGIN_SRC rust
// Rust
let result = might_fail(x).unwrap();

// TIL equivalent
result := might_fail(x)!
#+END_SRC

*** Implementation

Desugarer transforms ~func()!~ by inserting a catch block with panic for
every throwable type immediately after the call:

#+BEGIN_SRC til
// Before desugaring:
result := might_fail(x)!

// After desugaring:
result := might_fail(x)?
catch (err: SomeError) { panic(loc(), err.msg) }
#+END_SRC

Steps:
1. [DONE] Lexer: recognize ~!~ after fcall (new token or reuse existing)
2. [DONE] Parser: parse ~!~ like ~?~ but store a flag (~FCall(FCallInfo(does_throw=true, is_bang=true))~)
3. [DONE] Typer: when ~is_bang~ is true, skip adding throw types to ~thrown_types~
   (in FCall, Declaration, and Assignment handlers of ~check_body_returns_throws~)
4. [DONE] Desugarer: ~desugar_bang_in_body~ iterates body statements, finds bang FCalls
   via ~find_bang_func_name~, looks up throw types via ~lookup_func~, generates
   catch blocks via ~build_bang_catch~, and clears ~is_bang~ flag via ~clear_bang_flag~.
   Integrated into FuncDef body and Body node handlers.

*** Limitations

- Only works for direct function calls where ~params[0]~ is ~Identifier(name)~
  and ~lookup_func(name)~ succeeds. Method calls (UFCS) like ~arr.get(i, val)!~
  are not yet supported because the desugarer runs before UFCS rewriting.
- To support method calls, either move bang desugaring after UFCS, or add
  type-aware method resolution to the desugarer.

*** Notes

- The desugarer needs access to function signatures to know which error types
  to catch. This is already available via ~context.scope_stack.lookup_func~.
- ~!~ should NOT be allowed on calls that don't throw (typer error).
- Multiple throw types generate multiple catch blocks, all panicking.

** Issue #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Open
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Issue #91: First-Class Functions
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, polymorphism, higher-order programming
:STATUS: Nearly complete - func ptrs, lambdas, return, struct fields, throws, Vec of func ptrs, TFuncDef all done (2026-02-26). Vec of FuncSig/FuncDef and closures remaining.
:RELATED: Bug #90 (semicolon/body syntax), Bug #159 (needs func ptrs for deep clone/delete), Issue #105 (First-Class Structs), Issue #106 (First-Class Enums), Issue #182 (Closures -- explicit captures), src/test/function_pointers.til, doc/first_class.org
:END:

*** Background

Functions should be first-class values that can be passed as arguments,
enabling polymorphism and higher-order programming patterns. Currently,
~FuncDef~ exists but functions cannot be passed around as values.

TIL is now self-hosting, so the earlier concern about "post-self-hosting timing"
is resolved. Additionally, Bug #159 (shallow copy elimination) is blocked on
function pointer support for deep Vec.clone/delete -- making this a priority.

*** Core Semantics

1. *Pass functions as arguments*: Functions can be passed to other functions
   and called inside them.

2. *Function type declarations*: A function type is a function with no body.
   #+BEGIN_SRC til
   // Function type declaration (no body):
   BinaryOp := func(a: I64, b: I64) returns I64
   // With throws:
   Parser := func(s: Str) returns Ast throws ParseError
   #+END_SRC

3. *Throws are part of the signature*.

4. *Separate func/proc types*: ~func~ and ~proc~ are distinct types.
   A ~proc~ type cannot be passed where a ~func~ is expected (and vice versa).

5. *No closures*: Functions can only reference their own parameters and globals.
   Capturing enclosing scope variables is deferred (likely harder).

6. *Return functions and store in struct fields*: Include if not too much extra
   work over the basic "pass as arguments" support.

*** Example
#+BEGIN_SRC til
// Define a function type (no body = type declaration)
BinaryOp := func(a: I64, b: I64) returns I64

// Function that takes a function as argument
apply : func(op: BinaryOp, a: I64, b: I64) returns I64 = {
    return op(a, b)
}

// Define functions matching the type
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }
mul : func(a: I64, b: I64) returns I64 = { return a.mul(b) }

// Pass functions as arguments
apply(add, 3, 5)  // returns 8
apply(mul, 3, 5)  // returns 15
#+END_SRC

*** Syntax Decision

**** New unified syntax (DONE - f9af099f, fb40690b, b0badfdd, 2026-02-21)
Parser uses the unified ~name : Type = value~ syntax for functions,
as designed in doc/first_class.org. Two equivalent forms:
#+BEGIN_SRC til
// Sugar form (names in signature):
add : func(a: I64, b: I64) returns I64 = { return a.add(b) }

// Normal form (type-only params + binding tuple):
add : func(I64, I64) returns I64 = (a, b) { return a.add(b) }
#+END_SRC

**** FunctionSig type definitions (DONE - 65fd0227, 2026-02-21)
#+BEGIN_SRC til
BinaryOp := func(I64, I64) returns I64 {}
my_add : BinaryOp = (a, b) { return a.add(b) }
#+END_SRC

**** Function pointers (DONE - 2026-02-21)
Pass functions as arguments, call through variable, signature compatibility checking.
Typer, interpreter, ccodegen, scavenger all updated.

**** Lambda syntax / anonymous inline functions (DONE - 2026-02-21)
#+BEGIN_SRC til
apply_op(func(a: I64, b: I64) returns I64 { return a.add(b) }, 3, 5)
#+END_SRC

**** Returning functions from functions (DONE - 2026-02-21)
#+BEGIN_SRC til
get_op : func(which: I64) returns BinaryIntOp = {
    if which.eq(0) { return add2 }
    return subtract
}
#+END_SRC

**** Struct fields with function pointers (DONE - 2026-02-25)
#+BEGIN_SRC til
Handler := struct {
    mut on_click: BinaryIntOp = add2
}
h := Handler()
op := h.on_click
assert_eq(loc(), 8, op(3, 5))

// Construct with specific function
h2 := Handler(on_click=subtract)

// Reassign
h.on_click = multiply
#+END_SRC
Changes: init (get_type_size/get_field_offset FuncSig->Str), typer (accept TFuncSig as struct member),
preinit (skip FuncSig in delete/clone generation), interpreter (store/read func name as Str at field offsets),
garbager (skip clone for FuncSig assignments/struct fields), scavenger (collect_local_declarations for local func ptrs),
ccodegen (typedef ordering, function name emission in struct literals/assignments).

**** Func ptr passthrough (return parameter) (DONE - 2026-02-25)
#+BEGIN_SRC til
passthrough_op : func(op: BinaryIntOp) returns BinaryIntOp = { return op }
#+END_SRC
Interpreter: eval_custom_expr TFuncSig case re-registers func def in parent frame.
Ccodegen: return FuncSig distinguishes FuncSig-typed variables from global function names.

**** Throwing function pointers (DONE - 2026-02-25)
#+BEGIN_SRC til
ThrowingOp := func(I64, I64) returns I64 throws Str {}
safe_div : ThrowingOp = (a, b) { ... }
#+END_SRC

**** Collection infrastructure (DONE - 2026-02-25)
Infrastructure for storing func ptrs in Vec/Map:
- Scavenger: collect_local_declarations handles func/proc/ext_func/ext_proc/macro cases
- Interpreter: FuncSig-typed variable resolution (looks up stored function name,
  resolves actual FuncDef) for variables assigned from struct fields or casts
- ext.til: string_from_addr helper for reading function name strings from heap addresses
- Ccodegen: FuncSig case/switch handling for function pointer types in assignments and returns

**** Vec of function pointers (DONE - 6f936429, 2026-02-26)
#+BEGIN_SRC til
mut ops := Vec.new(BinaryIntOp)
ops.push(own add2)
op0 := cast(BinaryIntOp, ops.get(0)?)
assert_eq(loc(), 8, op0(3, 5))
#+END_SRC
Fix: hoist func-name-as-Dynamic to temp variable in emit_arg_string so memcpy
copies the pointer value, not machine code bytes.

**** TFuncDef metatype (DONE - 1d902a51, 2026-02-26)
Added ~TFuncDef~ to ~TTypeDef~ enum for symmetry with TStructDef/TEnumDef/TFuncSig.
Allows ~MyFunc : FuncDef = func(...) returns ... = { ... }~ explicit metatype annotations.

*** What is missing
- Vec of FuncSig (different signatures stored in same Vec)
- Vec of FuncDef (different definitions stored in same Vec)
- Closures (Issue #182 -- explicit capture lists)

*** Key Files
- src/rs/parser.rs / src/self/parser.til (function type parsing)
- src/rs/typer.rs / src/self/typer.til (signature matching)
- src/rs/ccodegen.rs / src/self/ccodegen.til (function pointer emission)
- src/rs/interpreter.rs / src/self/interpreter.til (function reference resolution)
- src/rs/init.rs / src/self/init.til (SFuncDef, ScopeFrame, ValueType, dispatch)
- src/test/function_pointers.til (test cases)

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this)
:END:

*** Description
Allow functions to return Dynamic type. Currently Vec.get uses inout parameter
as workaround. With ~returns Dynamic~, APIs become cleaner and closer to Rust/templates.

*** Key Constraint
Disallow type inference for Dynamic returns - caller must annotate the type:
#+BEGIN_SRC til
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer Dynamic return
#+END_SRC

This sidesteps inference complexity while enabling the feature.

*** Benefits
- Vec.get returns value directly instead of inout param
- enum_payload (Issue #110) can work cleanly
- Closer to Rust and future templates
- More idiomatic TIL

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout
- Set/Map: get, contains, etc. return value instead of inout
Big cleanup of self-hosted code.

*** Example
Current (workaround):
#+BEGIN_SRC til
mut val: I64 = 0
vec.get(0, mut val)  // inout parameter
#+END_SRC

With returns Dynamic:
#+BEGIN_SRC til
val: I64 = vec.get(0)  // direct return
#+END_SRC

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured -> splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded -> same behavior, splice
_ := declare_const(a, I64, 42)

// Captured -> get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Deferred to post-self-hosting
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix (deferred)
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.
