#+TITLE: Language Features
#+AUTHOR: TIL Development
#+DATE: 2026-02-23
# BOT: Issues use next number from doc/todo/next_issue_num.txt, then increment it.
# BOT: Add new issues at the top of Open Issues section.
# BOT: When implemented, move to Implemented Issues section in doc/todo/fixed.org.
# BOT: Keep summary.org updated when adding/removing/moving issues.

* Overview

This document tracks language feature requests -- new syntax, new
capabilities, new operators. Moved here from future.org to separate
features from performance/architecture/cleanup work.

For bugs, see bugs.org. For performance/architecture, see future.org.
For pre-1.0 work, see pre.org. For post-self-hosting, see post.org.

* Open Issues

** Issue #203: Borrowed returns -- optional keyword to mark borrowed return values
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Garbager correctness -- know which returns are borrowed vs owned
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic), Bug #159 (shallow copies), Bug #165 (memory leaks)
:END:

*** Description
Add an optional keyword before ~returns~ to indicate that a function returns
borrowed data rather than owned data. In TIL, all values are passed by
reference (offset binding), but the distinction between borrowed and owned
matters for the garbager: owned return values can be deleted by the caller,
borrowed return values must NOT be deleted.

*** Problem
Currently there is no way for the garbager to know whether a function's
return value is borrowed or owned. This matters for Bug #159 (shallow copies)
and Bug #165 (memory leaks). Consider:

#+BEGIN_SRC til
// Returns owned -- caller is responsible for deletion
clone := func(self: Vec) returns Vec { ... }

// Returns borrowed -- caller must NOT delete
get := func(self: Vec, i: I64) returns Ptr { ... }
#+END_SRC

Without this annotation, the garbager must guess (whitelist/blacklist) which
functions return owned vs borrowed data. This is fragile and error-prone.

*** Proposed syntax
#+BEGIN_SRC til
// Borrowed return (pointer into existing data, must not be freed by caller):
get := func(self: Vec, i: I64) returns borrowed Ptr { ... }

// Owned return (freshly allocated, caller must eventually free):
clone := func(self: Vec) returns Vec { ... }   // owned is the default
#+END_SRC

The ~borrowed~ keyword tells the garbager: the return value points into data
owned by one of the arguments (typically ~self~). The caller gets a reference
that is only valid while the source lives. No deletion should be generated.

*** Analogy to Rust
In Rust, this is the difference between returning ~&T~ (borrowed reference)
and ~T~ (owned value). In TIL everything is a reference, so instead of
different pointer types, we annotate the return with ~borrowed~ to convey
the same information.

*** Scope
- Parser: recognize ~borrowed~ keyword before return type
- Type checker: track borrowed vs owned on function signatures
- Garbager: skip deletion of borrowed return values
- Interpreter: no change (offset binding, no ownership tracking)
- CCodegen: generate pointer returns for borrowed, value returns for owned

** Issue #200: File I/O -- open, read, write, seek, binary and text modes
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- proper file handling beyond all-or-nothing readfile/writefile
:STATUS: Open
:END:

*** Description

TIL currently only supports all-or-nothing file operations: ~readfile(path)~
reads an entire file into a string, ~writefile(path, contents)~ writes an
entire string to a file. There is no way to:

- Open a file and keep a handle
- Read or write at a cursor position
- Move the cursor (seek) without reading or writing
- Read/write in binary mode vs text mode
- Read/write partial data (lines, bytes, chunks)

This issue covers adding proper file I/O with open/read/write/seek/close
operations, supporting both binary and text modes.

** Issue #199: Codebase cleanup -- use ~!~ where ~?~ + catch-panic is unnecessary
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Code quality -- remove boilerplate catch blocks, cleaner error handling
:STATUS: Open
:RELATED: Issue #180 (bang operator)
:END:

*** Description

Now that ~!~ (Issue #180) is implemented, audit the codebase for ~?~ calls
that are immediately followed by a catch block that just panics or re-throws.
These can be replaced with ~!~, removing boilerplate.

Also applies beyond ~get()~ -- any throwing function where the caller doesn't
meaningfully handle the error is a candidate for ~!~.

The compiler guides this work: change ~?~ to ~!~, and it reports which catches
and ~throws~ declarations are now unnecessary.

*** Partial cleanup done

The lexer.til ~get()~ calls were converted to ~!~ as a proof of concept,
with the cascade fixed through parser.til, mode.til, init.til,
interpreter.til, builder.til, and test files.

** Issue #198: Usize -- pointer-sized unsigned type for pointers and indexes
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- unified type for pointer widths and collection indexing
:STATUS: Open
:RELATED: Issue #195 (U32), Issue #196 (U64), Issue #197 (unsigned pointers)
:END:

*** Description

Most languages have a pointer-sized unsigned integer type that serves for
both pointer representation and collection indexing: Rust has ~usize~, C has
~size_t~, Go has ~uint~, Zig has ~usize~.

TIL should have ~Usize~ -- an unsigned integer whose width matches the
target pointer size (64-bit on 64-bit machines, 32-bit on 32-bit machines).

This solves the naming problem from Issue #197: the internal pointer type
doesn't need an ad-hoc name like ~RawPtr~ or ~AddrSize~ -- it's just ~Usize~,
which is the standard name for this concept. It also naturally serves as the
index type for Vec, Array, and other collections.

*** Relationship to U32/U64

Usize is not a replacement for U32 or U64 -- those are fixed-width types
with specific semantics. Usize is target-dependent: it equals U64 on 64-bit
targets and U32 on 32-bit targets.

** Issue #197: Internal pointer representation should be unsigned, not I64
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Correctness, portability -- pointers are not signed integers
:STATUS: Open
:RELATED: Issue #195 (U32), Issue #196 (U64)
:END:

*** Description

TIL internally represents pointers as I64. Pointers are unsigned values --
using a signed type is semantically wrong and wastes half the address space
on the sign bit.

The natural replacement is U64, but U32 could serve as a temporary
optimization worth trying (smaller footprint, sufficient for 32-bit targets).

Eventually the internal pointer size should be target-dependent: U64 on
64-bit machines, U32 on 32-bit machines. This means the compiler needs an
internal pointer-sized type that adapts to the target.

*** Naming problem

The obvious name ~Ptr~ is already taken by the existing Ptr type, which is
a bloated high-level type that does many things. The internal pointer
representation needs a distinct name -- something like ~UPtr~, ~RawPtr~,
or ~AddrSize~ -- to avoid collision with the existing Ptr type.

*** Steps

1. Introduce U32 and/or U64 types (Issues #195, #196)
2. Choose a name for the internal pointer-width type
3. Replace I64 pointer representation with the new unsigned type
4. Eventually make pointer width target-dependent

** Issue #196: U64 native unsigned 64-bit integer type
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- unsigned 64-bit integer type
:STATUS: Open
:RELATED: U8, U32, I64
:END:

*** Description

Add U64 as a native unsigned 64-bit integer type, following the same pattern
as U8 and I64. U64 gets its own ~u64.til~ file, just like ~u8.til~ and
~i64.til~. Same size as I64, but unsigned.

*** Range

0 to 18,446,744,073,709,551,615 (2^64 - 1)

** Issue #195: U32 native unsigned 32-bit integer type
:PROPERTIES:
:DISCOVERED: 2026-02-27
:IMPACT: Language feature -- unsigned 32-bit integer type
:STATUS: Open
:RELATED: U8, I64
:END:

*** Description

Add U32 as a native unsigned 32-bit integer type, following the same pattern
as U8 and I64. U32 gets its own ~u32.til~ file, just like ~u8.til~ and
~i64.til~. Half the size of I64, four times the size of U8, unsigned.

*** Range

0 to 4,294,967,295 (2^32 - 1)

** Issue #153: Enable field and method access on Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-11-12
:IMPACT: Dynamic typing, Python-like features, duck typing
:STATUS: Open
:RELATED: Issue #111 (returns Dynamic)
:END:

*** Problem
Currently, ~Dynamic~ parameters skip type checking when passed to functions,
but inside the function, field access and method calls are still type-checked
and fail because ~Dynamic~ has no members.

*** Current Behavior
#+BEGIN_SRC til
test_field_access := proc(obj: Dynamic) returns I64 {
    return obj.x  // ERROR: Struct 'Dynamic' has no member 'x'
}

test_method_call := proc(obj: Dynamic) returns I64 {
    return obj.sum()  // ERROR: Type 'Dynamic' has no method 'sum'
}
#+END_SRC

*** Desired Behavior
The type checker should skip validation for operations on ~Dynamic~ values:
- Field access deferred to runtime
- Method calls resolved at runtime
- Duck typing patterns enabled

*** Implementation Notes
The type checker would need to:
1. Recognize when an expression involves a ~Dynamic~ type
2. Skip member/method existence validation for Dynamic expressions
3. Defer checks to runtime (eval phase)
4. Handle runtime errors gracefully when members/methods don't exist

*** Use Cases
- Generic helper functions that work with any struct
- Duck typing patterns (if it has a ~.x~ field, use it)
- Python-style flexible code

*** Relationship to Issue #111
Issue #111 is about ~returns Dynamic~ (functions returning Dynamic).
This issue is about operations ON Dynamic values (~obj.field~, ~obj.method()~).
Both improve the Dynamic type's usefulness.

** Issue #182: Closures -- explicit capture lists for functions and blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- enables higher-order patterns that reference enclosing scope
:STATUS: Open
:RELATED: Issue #91 (first-class functions -- lambdas, function pointers), Issue #181 (standalone body blocks), doc/first_class.org
:END:

*** Description

Closures are functions that access variables from their enclosing scope.
TIL requires *explicit capture lists* using ~[square brackets]~, inspired
by Jai (Jonathan Blow). If a function references an outer variable, it MUST
be listed in the capture list. This makes dependencies visible and
refactoring mechanical.

*** Capture syntax

#+BEGIN_SRC til
scale := 3

// Closure: captures scale from outer scope
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Normal form equivalent:
scaled := numbers.map(func(I64) returns I64 = (a) [scale] { return a.mul(scale) })

// Named closure:
make_scaler : func(s: I64) returns Transformer = {
    return func(a: I64) returns I64 [s] { return a.mul(s) }
}
triple := make_scaler(3)
tripled := numbers.map(triple)  // [3, 6, 9, 12, 15]
#+END_SRC

*** Why explicit captures

Implicit captures (like Python, JavaScript, Rust) feel magical:

Problems:
- *Reading*: you see ~scale~ and have to hunt for where it's defined.
  Is it a global? A local three scopes up? A typo for a parameter?
- *Refactoring*: extracting a block into a function means figuring out
  ALL the implicit dependencies. Miss one and it breaks.
- *Inlining*: moving a closure back inline means understanding what it
  captures to know where it can safely go.

Explicit captures solve all three:
- *Reading*: ~[scale]~ tells you exactly what comes from outside.
- *Refactoring*: captures become parameters. Mechanical transformation.
- *Inlining*: captures tell you exactly what the block depends on.

*** Capture semantics

Captures follow the same rules as function parameters:

| Capture syntax | Semantics                         | Same as param mode |
|----------------+-----------------------------------+--------------------|
| ~[x]~          | Const by reference (default)      | ~x: T~             |
| ~[mut x]~      | Mutable reference                 | ~mut x: T~         |
| ~[copy x]~     | Deep copy (snapshot)              | ~copy x: T~        |
| ~[own x]~      | Ownership transfer (moved in)     | ~own x: T~         |

#+BEGIN_SRC til
mut total := 0
data := Vec.from(1, 2, 3)

// mut capture: closure can modify total
data.for_each(func(x: I64) [mut total] { total = total.add(x) })

// copy capture: closure gets a snapshot, original unchanged
data.map(func(x: I64) returns I64 [copy total] { return x.add(total) })

// own capture: moves data into the closure, caller can't use it after
consume : proc() = [own data] { data.clear() }
#+END_SRC

No new rules to learn -- captures are just arguments that come from the
enclosing scope instead of the call site.

*** Block captures (depends on #181)

Even without making a function, you can add a capture list to a bare
code block to limit what it can see. This is an "insurance policy" that
the block only touches specified state:

#+BEGIN_SRC til
mut total := 0
mut count := 0
data := Vec.from(1, 2, 3)

// Only total and data are accessible inside this block
[total, data] {
    for item in data {
        total = total.add(item)
    }
}
// count is guaranteed untouched
#+END_SRC

*** Refactoring progression (from Jai)

#+BEGIN_SRC til
// Step 1: inline code
total = total.add(x)

// Step 2: block with captures (limit scope, verify dependencies)
[total, x] {
    total = total.add(x)
}

// Step 3: promote to lambda (add params, same captures)
adder : func(a: I64) returns I64 = [total] { return total.add(a) }

// Step 4: promote to pure function (captures become params, no more closure)
adder : func(a: I64, b: I64) returns I64 = { return a.add(b) }
#+END_SRC

Each step is mechanical. The capture list tells you exactly what needs to
become a parameter when you promote to a pure function.

*** Syntax decision needed

Two options for how captures are specified:

**** Option A: Square brackets (Jai-style, current first_class.org design)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) returns I64 [scale] { return a.mul(scale) })

// Block capture:
[total, data] {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: concise, visually distinct from parameters.
Con: ~[]~ already used for array indexing in many languages. Inconsistent
with ~returns~ and ~throws~ which are keywords, not punctuation.

**** Option B: ~captures~ keyword (consistent with returns/throws)

#+BEGIN_SRC til
scaled := numbers.map(func(a: I64) captures scale returns I64 { return a.mul(scale) })

// Block capture:
captures total, data {
    for item in data { total = total.add(item) }
}
#+END_SRC

Pro: consistent with the existing ~returns~ / ~throws~ keyword pattern in
function signatures -- no parentheses, just commas. Reads naturally: "func
that takes I64, captures scale, returns I64". Searchable and greppable.
Con: more verbose.

**** Comparison

#+BEGIN_SRC til
// Option A:
f : func(I64) returns I64 = (a) [scale, mut total] { ... }

// Option B:
f : func(I64) captures scale, mut total returns I64 = (a) { ... }
#+END_SRC

Note: with Option B, ~captures~ sits before ~returns~ in the signature,
like how ~throws~ sits after ~returns~. Full order would be:
~func(params) captures X returns Y throws Z~.

*** References
- Jai Primer: explicit capture lists, same philosophy
- doc/first_class.org: full design document

** Issue #181: First-class bodies -- store, pass, and return code blocks
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Language feature -- bodies as values, zero-argument closures
:STATUS: Open
:RELATED: Issue #91 (first-class functions), Issue #105 (first-class structs), Issue #106 (first-class enums), Issue #182 (closures), doc/first_class.org
:END:

*** Description

Bodies as values that can be stored, passed, and returned:

#+BEGIN_SRC til
my_block : Body = {
    println("hello")
    some_call()
}

// Pass as argument
run_block(my_block)

// Return from function
make_block : func() returns Body = {
    return { println("deferred") }
}
#+END_SRC

A Body is essentially a zero-argument closure. Should be designed alongside
#91 (first-class functions) and #182 (closures) to share infrastructure and
avoid duplicated effort.

*** Note

Standalone bare ~{ ... }~ blocks already work (parser, interpreter, and
ccodegen all handle Body nodes). This issue is about making bodies into
first-class values, not about block syntax.


** Issue #83: No spread/splat operator for variadic argument forwarding
:PROPERTIES:
:DISCOVERED: 2026-01-03
:IMPACT: Cannot forward variadic args to another variadic function
:STATUS: Open
:RELATED: Bug #95 (duplicate)
:END:

*** Description
TIL lacks a spread/splat operator to expand an array/Vec into variadic arguments.
This prevents:
1. Forwarding variadic args from one function to another
2. Passing dynamically collected arguments to variadic functions

*** TIL Example (currently broken)
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    println(args)
    return output_str.run_cmd(args)  // FAILS: args is Array, not spread
}
#+END_SRC

*** Other languages

**** JavaScript - prefix ~...~
#+BEGIN_SRC javascript
function wrapper(...args) {
    return inner(...args);  // spread with ...
}
#+END_SRC

**** Python - prefix ~*~
#+BEGIN_SRC python
def wrapper(*args):
    return inner(*args)  # unpack with *
#+END_SRC

**** Ruby - prefix ~*~
#+BEGIN_SRC ruby
def wrapper(*args)
    inner(*args)  # splat with *
#+END_SRC

**** Kotlin - prefix ~*~
#+BEGIN_SRC kotlin
fun wrapper(vararg args: String) {
    inner(*args)  // spread with *
}
#+END_SRC

**** Lua - ~unpack()~ / ~table.unpack()~
#+BEGIN_SRC lua
function wrapper(...)
    local args = {...}
    return inner(unpack(args))
end
#+END_SRC

**** Go - suffix ~...~
#+BEGIN_SRC go
func wrapper(args ...string) {
    inner(args...)  // spread with suffix ...
}
#+END_SRC

**** Rust - no variadics, uses slices/iterators
#+BEGIN_SRC rust
// Rust doesn't have variadic functions in the same way
// Uses slices or iterators instead
command.args(&extra_args);  // args takes impl IntoIterator
#+END_SRC

*** Dynamic collection example
#+BEGIN_SRC til
// We have a Vec of args built dynamically
extra_args := Vec.new(Str)
extra_args.push("--verbose")
extra_args.push("output.txt")

// Want to call: run_cmd(output, exe_path, "--verbose", "output.txt")
// But can't expand extra_args into variadic position
#+END_SRC

*** Syntax options for TIL
| Option | Syntax                      | Notes                                    |
|--------+-----------------------------+------------------------------------------|
| A      | ~run_cmd(args...)~          | Go-style, suffix                         |
| B      | ~run_cmd(*args)~            | Python/Ruby/Kotlin-style, prefix         |
| C      | ~run_cmd(...args)~          | JavaScript-style, prefix                 |
| D      | ~run_cmd(..args)~           | TIL-style, matches ~..Str~ in declaration |
| E      | ~run_cmd(args.to_variadic())~ | Method on Array, no special syntax needed |
| F      | ~run_cmd(spread(args))~     | Explicit spread function, like Lua       |

*** Workaround
For shell commands, build a command string with a for-in loop and use ~bash -c~:
#+BEGIN_SRC til
run_print_cmd := proc(mut output_str: Str, args: ..Str) returns I64 {
    mut cmd := ""
    for arg: Str in args {
        if cmd.len().gt(0) {
            cmd = format(cmd, " ", arg)
        } else {
            cmd = arg
        }
    }
    println(cmd)
    return output_str.run_cmd("bash", "-c", cmd)
}
#+END_SRC

** Issue #111: Support returns Dynamic
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPACT: Cleaner API for Vec.get, enum_payload, etc.
:STATUS: Open
:RELATED: Issue #110 (enum_payload needs this), Issue #202 (polymorphism)
:END:

*** Description
Allow ~func(a: Dynamic) returns Dynamic~ -- functions that accept and return
type-erased values. This enables generic-style APIs without templates.

*** Current state (2026-02-27)
~Vec.get~ currently returns a borrowed ~Ptr~, which callers turn into an
alias via ~cast~:
#+BEGIN_SRC til
elem := cast(Expr, vec.get(i)?)
dont_delete(elem)
#+END_SRC

This works but is verbose and requires manual borrow management.

*** Wanted syntax
#+BEGIN_SRC til
// Function signature:
get := func(self: Vec, index: I64) returns Dynamic throws IndexOutOfBoundsError { ... }

// Caller must annotate type explicitly (no inference for Dynamic):
val: I64 = vec.get(0)      // OK - type annotated
val := vec.get(0)          // ERROR - can't infer from Dynamic return
#+END_SRC

*** Key constraint
When ~returns Dynamic~ appears in a Declaration, type inference is not
possible. The caller MUST provide an explicit type annotation. This
sidesteps inference complexity while enabling the feature.

*** Refactor Opportunity
Once implemented, refactor collection APIs in src/core and src/self:
- Array/Vec: get, pop, etc. return value instead of inout/Ptr
- Set/Map: get, contains, etc. return value instead of inout/Ptr
Big cleanup of self-hosted code (~cast~ + ~dont_delete~ boilerplate removed).

** Issue #88: Macro Support (Compile-Time Evaluation)
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPACT: Language feature, metaprogramming, compile-time computation
:STATUS: Partial (Step 1 done, Step 2 open)
:RELATED: doc/metaprogramming.org (full vision)
:END:

*** Background

The ~macro~ keyword is parsed and creates ~FTMacro~ function type. This issue
tracks implementing true compile-time macro evaluation in two steps.

*** Step 1: Forced Compile-Time Evaluation [DONE 2026-01-26]

Macros are now forced to evaluate at compile-time (at global scope). If arguments
are not compile-time constants, an error is raised instead of deferring to runtime.

Changes made:
- Added ~is_macro()~ helper to SFuncDef (parser.rs/parser.til)
- Added ~is_macro_fcall()~ and macro handling in precomp (precomp.rs/precomp.til)
- Added src/test/macros.til with tests including recursive factorial/fibonacci

| Aspect              | Funcs                       | Macros           |
|---------------------|-----------------------------|------------------|
| Args not comptime   | Silent skip, run at runtime | ERROR            |
| Evaluation          | Optional optimization       | Mandatory        |

Note: This is essentially "strict constant folding" - macros can compute values
at compile-time (factorial, fibonacci, etc.) but cannot yet generate types or code.

*** Step 2: Code/Type Generation [OPEN]

The real metaprogramming power - macros that generate types and code:

1. *Return StructDef*: Generate types at compile-time
   #+BEGIN_SRC til
   make_point := macro(n: I64) returns StructDef {
       // Generate Point2D, Point3D, etc. based on n
   }
   #+END_SRC

2. *Return FuncDef*: Generate functions at compile-time
   #+BEGIN_SRC til
   make_getter := macro(field_name: Str) returns FuncDef {
       // Generate a getter function for the given field
   }
   #+END_SRC

3. *Return Expr*: Generate AST/code to be inserted
   #+BEGIN_SRC til
   debug_print := macro(expr: Expr) returns Expr {
       // Generate: println("expr = ", expr)
   }
   #+END_SRC

4. *Quote/unquote syntax*: ~quote { $var }~ for AST building

This requires:
- Extending return type handling to allow StructDef, FuncDef, Expr
- AST quoting mechanism
- See doc/metaprogramming.org for full design

*** Possible Path: Implicit Splice via Unused Return

When a macro returns Expr and the result is not captured, the compiler splices
the returned AST in place. No special syntax needed - behavior depends on usage:

#+BEGIN_SRC til
// Macro that returns Expr for "a: I64 = 42"
declare_const := macro(name: Ident, T: Type, value: Dynamic) returns Expr {
    // import parser, construct declaration AST, return it
}

// Not captured -> splice the Expr here (becomes: a: I64 = 42)
declare_const(a, I64, 42)

// Discarded -> same behavior, splice
_ := declare_const(a, I64, 42)

// Captured -> get Expr as data for inspection/manipulation
my_ast := declare_const(a, I64, 42)
#+END_SRC

This avoids needing special macro invocation syntax (~!~, ~@~, etc.). The
distinction is implicit: capture the Expr to get data, ignore it to splice code.

*** Possible Path: Postfix ~!~ Syntax (like ~?~ for errors)

Instead of implicit behavior, use explicit postfix ~!~ to mark macro splices.
This is consistent with TIL's postfix ~?~ for error handling:

#+BEGIN_SRC til
// Error handling - postfix ?
risky_call()?

// Macro splice - postfix !
declare_const(a, I64, 42)!

// Throwing macro - both!
scary_macro(args)!?
#+END_SRC

Advantages:
- Explicit - clear what's a macro splice vs normal call
- Consistent with existing postfix ~?~ convention
- Captures work naturally: ~my_ast := macro_call()~ gets Expr data (no ~!~)
- Splices are obvious: ~macro_call()!~ splices the returned AST

Comparison with Rust:
- Rust: prefix ~macro_name!(args)~
- TIL: postfix ~macro_name(args)!~

Both paths depend on: ~returns Expr~ support (related to Issue #111 ~returns
Dynamic~, but could be implemented independently as a narrower feature for macros).

*** References
- doc/metaprogramming.org: Full macro/generics design vision
- src/test/macros.til: Current macro tests

** Issue #151: Explicit pointer/reference syntax for the language
:PROPERTIES:
:DISCOVERED: 2026-01-29
:IMPACT: Enables working with references without copying, foundational language feature
:STATUS: Open - design phase
:RELATED: Bug #144 (for-in copies), Issue #117 (ASAP destruction), Issue #115 (owned fields)
:END:

*** Description
TIL currently lacks explicit pointer/reference syntax at the language level.
The ~Ptr~ type exists internally, but users cannot express "reference to T"
in type annotations. Every dereference (~Ptr.dereference~, ~copy_to_dynamic~)
makes a copy - there's no way to access data through a pointer without copying.

*** The Core Problem
~Ptr.dereference(T, dest)~ copies data into ~dest~. There's no syntax to say
"give me a reference to T that I can read/write through without copying".

This affects:
- For-in loops (Bug #144) - each iteration copies the element
- Any code working with collections - must copy to access
- Performance-sensitive code - unnecessary copying

*** Current Workaround (Ptr directly)
Users can work with raw Ptr and manual offset calculation, but this is:
- Error-prone (manual size calculations)
- Not type-safe (Ptr is untyped)
- Verbose (explicit memcpy everywhere)

*** What We Need
A way to express "pointer to T" or "reference to T" in the type system,
with syntax for:
1. Taking a reference: ~&x~ or ~ptr(x)~ or similar
2. Dereferencing for access: ~*p~ or ~p^~ or auto-deref
3. Type annotations: ~&T~ or ~*T~ or ~Ptr(T)~ or ~ref T~

*** Syntax Options

**** Option A: Ampersand (Rust/C++ style)
#+BEGIN_SRC til
p: &Vec2 = &my_vec              // p is reference to Vec2
println(p.x)                    // auto-deref for field access
p.x = 10                        // write through reference (if &mut)
#+END_SRC
Pros: Familiar to Rust/C++ users
Cons: If we add operator overloading (~a & b~ -> ~a.and(b)~), conflicts with ~&x~

**** Option B: Asterisk (C style)
#+BEGIN_SRC til
p: *Vec2 = &my_vec              // p is pointer to Vec2
println((*p).x)                 // explicit deref required
println(p->x)                   // or arrow syntax
#+END_SRC
Pros: Familiar to C users
Cons: Verbose; if we add operator overloading (~a * b~ -> ~a.mul(b)~), conflicts with ~*p~

**** Option C: Caret (Pascal/Delphi style)
#+BEGIN_SRC til
p: ^Vec2 = @my_vec              // p is pointer to Vec2
println(p^.x)                   // explicit deref with ^
#+END_SRC
Pros: Unambiguous, no conflict with existing operators
Cons: Less familiar to modern programmers

**** Option D: Keyword (ref/ptr)
#+BEGIN_SRC til
p: ref Vec2 = ref my_vec        // explicit keyword
println(p.x)                    // auto-deref
#+END_SRC
Pros: Readable, no symbol conflicts
Cons: More verbose

*** Design Questions

1. **First-class types or sugar?**
   - First-class: ~&T~ is a distinct type from ~T~
   - Sugar: ~&T~ desugars to ~Ptr~ with type info attached

2. **Auto-deref or explicit?**
   - Rust-style: ~p.field~ auto-derefs
   - C-style: must write ~(*p).field~ or ~p->field~

3. **Mutable vs immutable references?**
   - Rust has ~&T~ (immutable) and ~&mut T~ (mutable)
   - Could mirror TIL's existing ~mut~ keyword: ~&T~ vs ~mut &T~ or ~&mut T~

4. **Interaction with existing parameter keywords?**
   - TIL already has ~mut~, ~copy~, ~own~ for parameters
   - How does ~&T~ interact? Is ~mut p: &T~ different from ~p: &mut T~?

5. **Lifetime tracking?**
   - Probably not for v1 - rely on Issue #117 (ASAP destruction)
   - Could add later if needed

*** Implementation Approach

Desugars to existing Ptr operations:
- ~&x~ -> wraps ~to_ptr(x)~ with type info
- Field access ~p.field~ -> offset calculation + typed read
- Assignment ~p.field = v~ -> offset calculation + typed write
- No actual copy until value is bound to a non-reference variable

*** Relationship to Other Issues

- **Bug #144** (for-in copies): Could be solved with ref syntax, but also
  has a simpler workaround using Ptr directly in desugaring
- **Issue #117** (ASAP destruction): Safety net for any copies that do happen
- **Issue #115** (owned fields): ~own~ vs borrowed semantics for struct fields
- **ownership.org**: Documents existing ~mut~/~copy~/~own~ parameter semantics

*** Note on For-In Loops (Bug #144)

For-in loops are the most visible symptom, but solving Bug #144 doesn't require
this full feature. A simpler workaround using Ptr in the desugaring could work.
This issue is about the general language feature; Bug #144 is a specific application.

** Bug #64: Custom main args in mode cli don't work properly
:PROPERTIES:
:DISCOVERED: 2025-12-30
:IMPACT: CLI programs must use args: ..Str and parse manually
:STATUS: Deferred to post-self-hosting
:END:

*** Description
Mode cli has two issues with custom main signatures:

1. I64 parameters cause a type error even when the caller provides a valid integer string (interpreted mode)
2. Custom named parameters don't work at all in compiled mode - only ~args: ..Str~ works

*** Workaround
Use ~args: ..Str~ and parse manually:
#+BEGIN_SRC til
main := proc(args: ..Str) {
    name := args.get(0)
    count := args.get(1).to_i64()
    println("name:", name, "count:", count.to_str())
}
#+END_SRC

*** Fix (deferred)
1. The interpreter should auto-convert Str args to I64 when main expects I64.
2. The C codegen should unpack argv into individual named parameters for custom signatures.
