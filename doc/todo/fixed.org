#+TITLE: Fixed Bugs and Implemented Issues
#+AUTHOR: TIL Development
#+DATE: 2026-01-24
# BOT: Fixed bugs go at the top of Fixed Bugs section.
# BOT: Implemented issues go at the top of Implemented Issues section.
# BOT: Keep the same issue number - numbers are never reused.

* Cancelled Issues

** Optimization #51: Precomp doesn't propagate constants through function parameters
:PROPERTIES:
:DISCOVERED: 2025-12-19
:CANCELLED: 2026-02-23
:END:

Cancelled. This was about making function parameters comptime when the caller
passes literals -- per-call body specialization. Too complex (requires storing
original bodies, caching specialized versions, unique codegen names). The right
pattern is to call pure funcs at global scope or inside func bodies (once #89
is fixed), not to propagate comptime-ness through parameter binding.

The motivating example (lolalalo.til) was restructured to call pure funcs at
global scope instead of routing literals through a proc.

* Fixed Bugs

** Bug #192: Own parameter through by-reference intermediary causes use-after-free -- FIXED 2026-02-25
:PROPERTIES:
:DISCOVERED: 2026-02-25
:FIXED: 2026-02-25
:IMPACT: Data corruption -- garbager deletes data that was transferred via own through a by-ref wrapper
:RELATED: #191, #159
:END:

*** Summary
When a function takes a parameter by reference (default) and internally passes
it with ~own~ to ~Vec.push~/~Set.insert~/~Map.set~, the data is shallow-copied
into the container. The caller still holds the original pointer. If the garbager's
delete-before-reassignment (#191) frees the caller's variable, the container holds
a dangling pointer (use-after-free).

*** Fix
The type checker now rejects ~own var~ when ~var~ is a borrowed (const/mut)
function parameter. Only ~own~ and ~copy~ params own their data and can transfer
ownership. Locals are always owned, so ~own local_var~ remains valid.

Implementation:
1. Added ~borrowed_args: HashSet<String>~ (Rust) / ~borrowed_args: Set~ (TIL)
   to ~ScopeStack~ struct
2. Populated in ~check_func_proc_types~ param loop: params that are neither
   ~own~ nor ~copy~ are added to ~borrowed_args~
3. Save/clear/restore ~borrowed_args~ at function boundaries (same pattern as
   ~used_symbols~ and ~function_locals~)
4. In ~check_fcall_args~: when callee's param has ~is_own~ and the argument is
   a simple identifier in ~borrowed_args~, emit type error with suggestion to
   declare the param as ~own~ or ~copy~
5. Updated 12 ~ScopeStack~ functions in ~init.til~ to take ~own~ params where
   Rust takes ~String~ (owned). Callers updated with ~.clone()~ where the
   source is an alias (for-in loop variable, cast result, borrowed param field).

Files modified: init.rs, init.til, typer.rs, typer.til, interpreter.til,
eval_heap.til, precomp.til, desugarer.til, garbager.til, ccodegen.til,
scavenger.til, ufcs.til, ext.til, bug192.til, args.til, cross_file_forward/entity.til,
examples/lolalalo.til

** Bug #171: make.til doesn't detect when it needs to rebuild itself
:PROPERTIES:
:DISCOVERED: 2026-02-11
:FIXED: 2026-02-20
:END:

make.til now detects when it has been modified and rebuilds itself automatically.
The self-rebuild check was added to the make.til build script. Verified with
~touch make.til && make rstil~ -- outputs "make.til: rebuilding myself...".

** Bug #166: Containers duplicate type info already in Ptr
:PROPERTIES:
:DISCOVERED: 2026-02-10
:FIXED: 2026-02-20
:END:

Removed duplicate ~type_name~ and ~type_size~ fields from all homogeneous containers
(Vec, Array, Set, Map, HashMap). Type info now accessed through ~Ptr.elem_type~ and
~Ptr.elem_size~. Array migrated from raw ~I64~ ptr to ~Ptr~ struct. Arena migrated
from Vec to raw Ptr. Vec went from 176 to 56 bytes, Array from 80 to 48 bytes.
List investigated -- heterogeneous per-element type info is not redundant.

** Bug #176: UFCS doesn't resolve on create_alias variables
:PROPERTIES:
:DISCOVERED: 2026-02-19
:FIXED: 2026-02-20
:END:

UFCS method calls like ~v.clone()~ failed on variables created via ~create_alias~
because the typer/UFCS pass didn't know the variable's type.

Fixed by replacing ~create_alias~ with ~cast(Type, Ptr)~, which uses regular
declaration syntax (~v := cast(Type, ptr)~). The UFCS pass sees ~v~ as a normal
declared variable with its type known, so ~v.clone()~, ~v.eq()~, etc. resolve
correctly. All ~create_alias~ code removed; for-in desugaring also converted to
use cast. ~create_alias~ ext_func and all special-case handling deleted.

** Bug #173: Rust typer missing variable shadowing check (ccodegen =*_ret= assignment bug)
:PROPERTIES:
:DISCOVERED: 2026-02-18
:FIXED: 2026-02-18
:IMPACT: Compiler error (-Werror=unused-parameter) in generated C; wrong codegen for shadowed variables
:STATUS: Fixed
:RELATED: Bug #168 (ccodegen return copies), Issue #66 (variable shadowing policy)
:END:

*** Root cause
TIL's typer rejects same-named variables in different scopes within a function
("Variable 'p' already declared in this function (shadowing not allowed)") via
=is_shadowing_in_function= at typer.til:2092-2103. The Rust typer never had this
check, allowing shadowing through to ccodegen where =find_ret_var_for_placement=
confuses two different variables with the same name.

*** Fix
1. Added shadowing check to =check_declaration= in =src/rs/typer.rs=, porting
   the existing TIL check. Uses =is_shadowing_in_function=, =is_already_processed=,
   and =register_function_local= (all already existed in init.rs).

2. Fixed all shadowing errors across the entire codebase (both TIL and Rust):
   - src/self/preinit.til + src/rs/preinit.rs
   - src/self/scavenger.til + src/rs/scavenger.rs
   - src/self/eval_heap.til
   - src/self/init.til + src/rs/init.rs
   - src/self/interpreter.til + src/rs/interpreter.rs
   - src/self/precomp.til + src/rs/precomp.rs
   - src/self/typer.til + src/rs/typer.rs
   - src/self/garbager.til + src/rs/garbager.rs
   - src/self/desugarer.til + src/rs/desugarer.rs
   - src/self/ccodegen.til + src/rs/ccodegen.rs
   - src/test_runner.til, src/tests.til

*** Test
=src/test/bug173.til= - all_common with expected_status=1 (both typers reject it).

** Bug #164: List has no capacity tracking - heap overrun on cloned List push
:PROPERTIES:
:DISCOVERED: 2026-02-09
:FIXED: 2026-02-09
:IMPACT: Heap corruption crash on push to cloned List; silent data corruption in arena mode
:STATUS: Fixed
:END:

*** Description
List allocated a fixed 1024-byte data buffer in List.new() but had NO capacity
field, no growth logic, and no bounds checking in push(). List.clone() allocated
exactly calc_used() bytes, so any push to a cloned List wrote past the buffer.

Discovered via Issue #163 heap allocation - the heap isolates allocations,
exposing overruns that were silently hidden by the arena's contiguous memory.

*** What was done
- Added cap field to List struct
- Set cap = 1024 in List.new(), cap = self.cap in List.clone()
- Added growth logic in List.push() and List.set() (Case 2: different-size replacement)
- Removed 64-byte padding hack from TIL heap_alloc and debug tracing from Rust


** Bug #162: Typer own-param requires mut variable + no control-flow awareness
:PROPERTIES:
:DISCOVERED: 2026-02-08
:FIXED: 2026-02-08
:IMPACT: Blocks Issue #117 Step 5 (typer own-consumption analysis)
:STATUS: Fixed
:END:

*** Description
Two issues with ~own~ parameter handling in the typer:

1. ~own~ params incorrectly require ~mut~ variables. The typer checked
   ~if arg.is_mut || arg.is_own~ and rejected const variables. But ~own~ just
   transfers ownership -- it should accept const variables.

2. ~own~ consumption has no control-flow awareness. ~remove_symbol~ was called
   unconditionally when a variable was passed to an ~own~ param. If this happened
   inside an if-branch, the variable became undefined in the else-branch.

*** What was done
Typer changes (typer.rs + typer.til):
- Mut check: changed ~if arg.is_mut || arg.is_own~ to ~if arg.is_mut~ -- only
  ~mut~ params require mutable variables, ~own~ accepts const
- Control-flow-aware own-consumption tracking via lazy removal logging
  (originally used ~snapshot_symbols~ / ~restore_removed_symbols~ which cloned
  the entire symbol map; replaced by ~begin_removal_tracking~ /
  ~end_removal_tracking~ / ~removal_mark~ / ~drain_removals_since~ /
  ~restore_removed~ in ScopeStack -- cost proportional to actual removals
  instead of total symbol count, ~30% improvement in til interpreted benchmark)
- ~check_if_statement~: begin tracking, mark/drain/restore per branch.
  After all branches, remove symbols consumed in ALL branches (intersection).
  If-without-else: no definite consumption.
- ~check_switch_statement~: begin tracking, mark/drain/restore per case body
- ~check_func_proc_types~: snapshot before body, restore before throw analysis
  (needs UFCS resolution which needs all symbols)

Ccodegen changes (ccodegen.rs + ccodegen.til):
- Removed ~const~ qualifier for struct/enum local variables (7 locations).
  Garbager inserts ~Type.delete()~ calls which take ~mut self~, so locals
  cannot be ~const~.
- ~emit_precomputed_vec_assignment~: removed ~is_mut~ parameter
- General const declaration: only emit ~const~ for primitive types
  (I64, U8, Type, Dynamic)

Other:
- 3 clone fixes in typer.til from latest117 branch (~path.clone()~,
  ~return_val_e.clone()~, ~switch_case_expr.clone()~)
- 1 clone fix in ccodegen.til (~value_type.clone()~)
- Test: ~src/test/bug162.til~

*** UFCS + own params issue (FIXED)
Root cause: ~check_body_returns_throws~ re-walks the AST doing UFCS
resolution via ~get_func_def_for_fcall~ AFTER the type-check pass has
removed own-consumed symbols. Local variables were re-declared by the
Declaration handler in ~check_body_returns_throws~, but function
parameters were not, so UFCS on consumed parameters failed.

Fix: wrap the function body type-check loop in removal tracking
(~begin_removal_tracking~ / ~drain_removals_since~ / ~restore_removed~
/ ~end_removal_tracking~), restoring all own-consumed symbols before
~check_body_returns_throws~ runs. File: typer.rs only (TIL typer
doesn't have own-consumption tracking).

** Bug #160: Eliminate field paths from arena_index
:PROPERTIES:
:DISCOVERED: 2026-02-03
:FIXED: 2026-02-07
:IMPACT: Code quality, memory efficiency, cleaner architecture
:STATUS: Fixed
:END:

*** Description
Field paths like "var.field" or "var.field.subfield" were stored in arena_index
as a legacy hack. get_field_offset() already computes all field offsets
dynamically from struct layout + base offset, making stored field paths redundant.

*** What was done (first pass, 2026-02-03)
Eliminated map_instance_fields and switched to deterministic field offset
calculation via get_field_offset(). Removed fallback patterns. Performance
improved 34s (-4.1%).

*** What was done (second pass, 2026-02-07)
Fully eliminated all remaining field path storage from arena_index:

1. copy_fields: Removed insert_var for src/dest field keys and declare_symbol
   for dest. Added temp insert_var/remove_var for dest only around recursive
   calls (needed when base type is Dynamic).

2. insert_string_core: Changed is_field branch from lookup_var to
   get_field_offset. Removed two arena_index sub-field inserts.

3. insert_struct_core: Removed temp inserts for nested Str and struct fields.
   Added temp base var+symbol registration at start of field init loop with
   cleanup at end (needed for get_field_offset during field initialization).

4. generate_struct_mappings: Removed nested arena_mappings extension (kept
   symbol extension only).

5. interpreter.rs: Removed all 7 prefix-based arena_index scan locations
   (catch block, own param transfer/cleanup, saved offsets, PBR field copy,
   throw propagation). Kept symbol prefix transfers.

*** Files modified
- src/rs/eval_arena.rs, src/self/eval_arena.til
- src/rs/interpreter.rs, src/self/interpreter.til

** Bug #158: test_runner.til compiled mode timing may include compilation
:PROPERTIES:
:DISCOVERED: 2026-01-31
:FIXED: 2026-02-03
:IMPACT: Benchmark numbers for compiled modes inaccurate after make clean
:STATUS: Fixed
:END:

*** Description
After ~make clean~, benchmark showed compiled mode times ~30% higher than
subsequent cached runs. Tests with expected_status != 0 were not pre-built,
so their timing included compilation.

*** Root Cause
In tests.til ~run_parallel~, pre-build only happened for tests where
~expected_status.eq(0)~. Error tests (expected_status=1) were skipped,
causing compilation to happen during timing on first run.

*** Fix
Removed the ~expected_status.eq(0)~ condition from pre-build logic.
All tests are now pre-built regardless of expected status. Some pre-builds
fail for intentional error tests, but those failures also occur during
the actual test run, so timing is unaffected.

*** Results
Before fix: til compiled 40.447s after clean, 30.249s cached (34% diff)
After fix: til compiled 30.442s after clean (matches cached performance)

** Bug #139: Type checker allows assigning I64 to Ptr field
:PROPERTIES:
:DISCOVERED: 2026-01-25
:FIXED: 2026-02-03
:IMPACT: Type errors silently pass, causing gcc warnings
:STATUS: Fixed
:END:

*** Description
The type checker allowed assigning an I64 value to a Ptr field without error.
For example, ~TestStruct(ptr_field=0)~ where ~ptr_field: Ptr~ would compile
without error, causing gcc warnings about incompatible types.

*** Fix
Added type checking for struct field assignments in both Rust typer (typer.rs)
and TIL typer (typer.til). When a named argument is provided to a struct
constructor, the type checker now verifies that the value's type matches the
field's declared type.

Special case: I64 literals can still be assigned to U8 fields (Bug #124
coercion rule) to allow ~Bool(data=0)~ and similar patterns.

*** Test
~src/test/bug139.til~ - now expects exit status 1 (type error detected).

** Bug #157: Field access on throwing calls in declarations
:PROPERTIES:
:DISCOVERED: 2026-01-31
:FIXED: 2026-01-31
:IMPACT: Generates invalid C for declarations like ~x := throwing_call()?.field~
:STATUS: Fixed
:RELATED: Issue #110, Bug #143
:END:

*** Description
Declarations with field access on throwing calls (e.g., ~val := lexer.peek()?.token_type~)
failed in both ccodegen and interpreter:
- ccodegen: ~emit_declaration~ only used ~emit_arg_string~ for direct FCall RHS
- interpreter: ~eval_identifier_expr~ returned field path instead of enum value

*** Fix
**** ccodegen (emit_declaration)
Modified ~emit_declaration~ to detect UFCS field access patterns (~Identifier("_")~)
where ~params[0]~ is a throwing FCall. Hoists the FCall using ~emit_arg_string~ and
appends the field chain to the returned temp var.

**** interpreter (eval_identifier_expr)
When the final type in a field chain is an enum, read the actual enum value from
arena using ~EvalArena::get_enum~ and return it in ~EnumType.VariantName~ format
instead of just returning the field path.

*** Test
~src/test/bug157.til~ - tests field access on throwing call in declaration.

** Bug #145: til_interpreted diverges from rs_interpreted for func in global init
:PROPERTIES:
:DISCOVERED: 2026-01-27
:FIXED: 2026-01-30
:IMPACT: til_interpreted crashed when func returns Vec used in global initialization
:STATUS: Fixed
:RELATED: Bug #133 (similar workaround, different root cause)
:END:

*** Description
When a ~func~ returns a Vec and is used in global initialization, til_interpreted
was reported to fail with "Ptr.new_by_size: invalid size" while rs_interpreted
works correctly.

*** Resolution (2026-01-30)
After merging the Bug #133 fix to master and completing the TIL port, this bug
no longer manifests. All 4 modes now pass the test case.

*** Final test results:
#+BEGIN_SRC
create_data := func() returns Vec { ... }
data := create_data()  // Global initialization

rs_interpreted:  PASS
rs_compiled:     PASS (Bug #133 fix)
til_interpreted: PASS (Bug #145 resolved)
til_compiled:    PASS (TIL port of Bug #133 complete)
#+END_SRC

** Bug #98: ext_proc errors should throw specific error types instead of panicking
:PROPERTIES:
:DISCOVERED: 2026-01-10
:FIXED: 2026-01-30
:IMPACT: I/O failures are now catchable instead of crashing
:STATUS: Fixed
:END:

*** Description
ext_proc functions (writefile, readfile, input_read_line, list_dir_raw) either
panicked or returned silently on error. Now they throw proper error types.

*** Error Types Added
- ReadError: Thrown by readfile, input_read_line
- WriteError: Thrown by writefile
- IOError: Thrown by list_dir_raw, list_dir, glob_files

*** Implementation
- src/std/io.til: Added ReadError/WriteError structs, updated function signatures
- src/std/sys.til: Added IOError struct, updated list_dir_raw/list_dir/glob_files
- src/ext.c: Updated til_readfile, til_writefile, til_input_read_line, til_list_dir_raw
  to set error message and return 1 (throw) instead of panicking or returning empty
- src/rs/ext.rs: Updated proc_readfile, proc_writefile, proc_input_read_line,
  func_list_dir_raw to return EvalResult.new_throw with proper error type
- src/self/ext.til: Ported the Rust changes to TIL interpreter

*** Callers Updated
- src/self/init.til: Added ReadError catch for readfile
- src/self/interpreter.til: Added ReadError catch for readfile
- src/self/builder.til: Added ReadError/WriteError catches
- src/test_runner.til: Added WriteError/ReadError catches
- src/tests.til: Added WriteError/ReadError catches
- src/test/syscalls.til: Updated to test IOError throwing on non-existent directory
- src/test/extra_syscalls.til: Added IOError catches
- src/test/test_lexer.til: Added ReadError catches
- make.til: Added IOError catch

** Bug #97: Variable shadowing causes C codegen to generate broken C code
:PROPERTIES:
:DISCOVERED: 2026-01-10
:FIXED: 2026-01-30
:IMPACT: Variable shadowing with different types caused C compiler errors
:STATUS: Fixed
:RELATED: Issue #66 (shadowing policy - now obsolete)
:END:

*** Description
TIL's C codegen didn't handle variable shadowing (reusing same name with different type).
The interpreter handles it fine, but C can't shadow with different types:

#+BEGIN_SRC til
mut x := 1        // I64
if true {
    mut x := "hi" // Str - shadows with different type
}
#+END_SRC

Previous ccodegen generated broken C:
#+BEGIN_SRC c
til_I64 til_x;           // Declared as I64
til_x = ((til_Str){...}); // ERROR: assigning Str to I64
#+END_SRC

*** Fix
Implemented name mangling with type prefix:
- ~x: I64~ becomes ~til_I64_x~
- ~x: Str~ becomes ~til_Str_x~

Changes in ccodegen (both Rust and TIL):
- Added ~til_var_name(name, type_prefix)~ helper function
- Added ~value_type_to_c_prefix(vt)~ to convert ValueType to string prefix
- Added ~til_var_name_from_context(name, context)~ to look up type and return mangled name
- Updated ~emit_declaration~ to compute type-mangled ~c_var_name~
- Updated hoisting in ~emit_if~, ~emit_while~, ~emit_switch~
- Updated ~emit_throwing_call~, ~emit_throwing_call_propagate~, ~emit_throwing_call_with_goto~
- Updated ~emit_variadic_call~ declaration and assignment handling
- Updated Pattern handling in ~emit_switch~ for binding variables
- Updated Type variable references in ~size_of~, ~type_as_str~, ~enum_get_payload~

Changes in desugarer (both Rust and TIL):
- Changed for-in catch error variable from ~err~ to unique ~_err_forin_N~ to avoid
  shadowing when loop variable is named ~err~

*** Benefits
- Shadowing is now a valid TIL feature (like Rust)
- Much less friction when porting Rust code (~let x = x.trim()~ patterns)
- No need to manually rename variables during translation
- Issue #66 policy debate is obsolete - shadowing just works

** Bug #96: Unreachable code error when return is before catch in early-return pattern
:PROPERTIES:
:DISCOVERED: 2026-01-09
:FIXED: 2026-01-30
:IMPACT: Cannot translate Rust's if-let-some early-return pattern directly
:STATUS: Fixed
:END:

*** Description
When translating Rust's ~if let Some(x) = map.get(key) { use(x); return; }~ pattern,
the natural TIL translation puts a ~return~ before the catch block, causing an
"unreachable code" error because the compiler didn't understand that the catch
is reachable via the throw path.

*** Fix
Fixed typer.rs and typer.til to recognize that catch blocks are reachable via
the throw path, not sequential control flow. A return/throw on the success path
doesn't make catch unreachable.

Changes:
- Skip unreachable error for Catch nodes after return/throw
- Reset unconditional_exit flag after processing catch (code after catch is reachable)
- Removed all ~if true { }~ workarounds from ccodegen.til
- Updated rs2til.org to show correct pattern (no workaround needed)

** #pre: Pre-Self-Hosting Prerequisites Complete
:PROPERTIES:
:COMPLETED: 2025-11-12
:STATUS: All tasks complete
:END:

*** Description
All rstil (Rust interpreter) prerequisites for self-hosting were completed.
This milestone enabled the self-hosted TIL interpreter to run.

*** Completed Tasks
- [X] Pass-by-reference semantics with three argument modes (const/mut/copy/own)
- [X] Phase 1: Type checker immutability enforcement
- [X] Phase 2: Add 'copy' keyword for explicit copy semantics
- [X] Phase 3: Pass-by-reference for ALL struct types
- [X] Phase 3a: Separate Type from Dynamic
- [X] Phase 3b: Enable pass-by-ref for Dynamic and own parameters
- [X] Bug #26: Vec/Map corruption with nested structs (FIXED)
- [X] Phase 4: Remove Bug #24 workarounds from core library
- [X] Standardize len/cap API across collections (fixes Bug #25)

*** Implementation Notes
- Non-copy, non-own, non-Dynamic, non-Type parameters share arena offsets (zero-copy)
- Field offsets calculated dynamically from struct definitions
- Pass-by-ref extended to field access parameters (e.g., o1.inner_vec)
- Renamed internal fields: len -> _len, added uniform len()/size() methods

*** Source
Migrated from doc/todo/pre.org (now deleted)

** Bug #150: C codegen doesn't emit struct definitions for local structs used only in globals
:PROPERTIES:
:DISCOVERED: 2026-01-29
:FIXED: 2026-01-29
:IMPACT: Compiled modes fail with gcc error "unknown type name"
:STATUS: Fixed
:RELATED: Found while testing Bug #139
:END:

*** Description
When a struct is defined locally in a file and only used in a global variable
declaration, the C code generator doesn't emit the struct definition. This
causes gcc to fail with "unknown type name".

*** Fix
The scavenger's ~compute_reachable~ function processed struct constructor calls
but didn't add the struct name to ~used_types~. When a struct was only used in
a global variable (via constructor call), it was never marked as a used type,
so the scavenger removed it.

Fixed by adding ~used_types.insert(func_name.clone())~ when processing struct
constructors in ~compute_reachable~ (both Rust and TIL versions).

Files changed:
- ~src/rs/scavenger.rs~: Added ~used_types.insert()~ in struct constructor branch
- ~src/self/scavenger.til~: Same fix ported to TIL
- ~src/tests.til~: Moved bug139.til from rs_interpreted/til_interpreted to all_common

** Bug #92: Range loops should allow explicit iterator type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-08
:FIXED: 2026-01-29
:IMPACT: Type safety, code clarity
:STATUS: Fixed
:END:

*** Description
Range loops (e.g., ~for i in 0..100~) infer the iterator type automatically.
However, there's no way to explicitly specify the iterator type when desired
for clarity or type safety.

All of these should be valid:
- ~for i in 0..100~ - no annotation, infers I64 (current behavior)
- ~for i: I64 in 0..100~ - explicit I64
- ~for i: U8 in 0..100~ - explicit U8 (overrides default I64 inference)
- ~for i: auto in 0..100~ - explicit auto (same as no annotation, infers I64)

Note: Literal numbers default to I64 unless explicitly annotated otherwise.

*** Failed Attempt (2026-01-08): Unified iteration via I64Range struct

**** Approach
Tried to unify range and collection iteration by creating an I64Range struct
with len()/get() methods, allowing range loops to use the same desugaring
path as collection loops (for-in over Vec, Array, etc.):

- Created ~src/core/range.til~ with I64Range struct
- Parser changes: removed range-to-while desugaring, created ForIn nodes
- Precomp changes: wrapped Range expressions with I64Range(start=X, end=Y)
- Range loops would then use standard len()/get() desugaring

**** Why It Failed
The I64Range.get() method throws IndexOutOfBoundsError. The for-in desugaring
generates a catch block for this error that panics. This catch block contains
a variable ~til_err~.

When C code is generated, all local variables are hoisted to function scope.
If a function has multiple for-in loops over ranges, each generates its own
catch block with ~til_err~, causing redeclaration errors in C.

Additionally, the existing parser-based range desugaring was simpler and
didn't require any error handling (it used direct increment/decrement without
bounds checking on each iteration).

**** Key Diff Insight (from bootstrap/til.c)
OLD (parser desugaring):
#+BEGIN_SRC c
til_I64 til_i = 0;
while (til_lt(&til_i, &end).data) {
    // body
    til_I64_inc(&til_i);
}
#+END_SRC

NEW (I64Range approach):
#+BEGIN_SRC c
til_I64 _for_i_func_0 = 0;
til_I64 til_i;
while (til_lt(&_for_i_func_0, &(til_I64){til_I64Range_len(...)}).data) {
    til_IndexOutOfBoundsError _thrown_...;
    til_I64Range_get(...);  // throws
    if (0) { _catch_...:
        til_IndexOutOfBoundsError til_err = ...;  // PROBLEM: hoisted
        til_panic(...);
    }
    // body
}
#+END_SRC

The ~til_err~ variable gets hoisted, and multiple catch blocks in the same
function cause redeclaration errors.

**** Code: I64Range struct (src/core/range.til)
#+BEGIN_SRC til
mode lib

// I64Range struct for unified iteration over numeric ranges
// Used by for-in loops: `for i in 0..10` becomes iteration over I64Range(start=0, end=10)
// Named I64Range (not Range) to prepare for future template support: Range<I64>, Range<U8>, etc.

I64Range := struct {
    mut start: I64 = 0
    mut end: I64 = 0

    // Required by collection interface
    size := func(self: I64Range) returns I64 {
        return 16  // Two I64 fields (8 bytes each)
    }

    len := func(self: I64Range) returns I64 {
        if self.end.gteq(self.start) {
            return self.end.sub(self.start)
        }
        return self.start.sub(self.end)
    }

    get := proc(self: I64Range, index: I64, mut out: Dynamic) throws IndexOutOfBoundsError {
        if index.gteq(self.len()) {
            throw IndexOutOfBoundsError(msg="I64Range.get: index out of bounds")
        }
        if self.end.gteq(self.start) {
            out = self.start.add(index)  // Forward: 0..10 -> 0,1,2...
        } else {
            out = self.start.sub(index)  // Reverse: 10..0 -> 10,9,8...
        }
    }
}
#+END_SRC

**** Code: Precomp change to wrap Range in I64Range (src/rs/precomp.rs)
#+BEGIN_SRC rust
// In precomp_forin(), after getting raw_collection_expr:

// Bug #92: If collection is a Range expression, wrap it in I64Range(start=..., end=...)
// This allows range loops to use the same len()/get() desugaring as collections
let collection_expr = if let NodeType::Range = &raw_collection_expr.node_type {
    let start_expr = raw_collection_expr.get(0)?.clone();
    let end_expr = raw_collection_expr.get(1)?.clone();
    // Build: I64Range(start=<start>, end=<end>)
    Expr::new_explicit(
        NodeType::FCall,
        vec![
            Expr::new_explicit(NodeType::Identifier("I64Range".to_string()), vec![], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("start".to_string()), vec![start_expr], e.line, e.col),
            Expr::new_explicit(NodeType::NamedArg("end".to_string()), vec![end_expr], e.line, e.col),
        ],
        e.line,
        e.col,
    )
} else {
    raw_collection_expr
};
#+END_SRC

**** Alternative Approaches to Consider
1. **Non-throwing Range.get()**: Return a sentinel/default instead of throwing.
   But this breaks the collection interface contract.

2. **Special-case ranges**: Keep ranges separate from collections. They're
   fundamentally different (arithmetic progression vs stored elements).

3. **Fix C hoisting**: Track catch block error variables specially to avoid
   redeclaration. Complex.

4. **Keep current parser desugaring**: The simplest approach. Range loops
   work correctly as-is. Focus on adding type annotation support without
   changing the desugaring mechanism.

*** Fix (2026-01-29)
Used approach #4: Keep current parser desugaring, add type annotation support.

In ~parse_for_statement~ in both Rust and TIL parsers:
- When a type annotation is present (~for VAR: TYPE in ...~), check if the
  expression after ~in~ is a Range (~..~) by peeking for DoubleDot token
- If Range: use the same while-loop desugaring as untyped ranges, but with
  explicit type in the Declaration instead of INFER_TYPE
- If not Range: use ForIn node for collection iteration (existing behavior)

Key insight: Don't use ~parse_case_expr~ because its pattern matching logic
interferes with function calls like ~list_dir(dir)?~. Instead, use ~parse_primary~
and manually check for ~..~ token afterward.

Example usage:
#+BEGIN_SRC til
for i: I64 in 0..10 {
    println(i)  // i has explicit I64 type
}
#+END_SRC

** Bug #148: No typer error when ? is used on non-throwing call
:PROPERTIES:
:DISCOVERED: 2026-01-29
:FIXED: 2026-01-29
:IMPACT: Unnecessary ? operators silently accepted, may cause unneeded hoisting code
:STATUS: Fixed
:END:

*** Description
When the ~?~ operator is used on a function call that doesn't throw, the typer
should emit an error. Previously it silently accepted the unnecessary ~?~.

*** Root Cause
The ~check_struct_def~ function in the typer was checking struct field default
values for type compatibility and purity (no proc calls), but never called
~check_types_with_context~ on the expression. This meant FCall nodes with ~?~
on non-throwing functions were never validated by ~check_fcall~.

*** Fix
Added a call to ~check_types_with_context(context, inner_e, ExprContext::ValueUsed)~
at the beginning of the default value handling branch in ~check_struct_def~.

Files modified:
- ~src/rs/typer.rs~: Added check_types_with_context call for struct default values
- ~src/self/typer.til~: Ported the same fix

** Bug #140: Dangling pointers in generated C code (undefined behavior)
:PROPERTIES:
:DISCOVERED: 2026-01-25
:FIXED: 2026-01-29
:IMPACT: Undefined behavior in generated C code; works by luck, may break with optimization
:STATUS: Fixed
:RELATED: Bug #99 Step 5a, Bug #143
:END:

*** Description
The C codegen generated undefined behavior when passing rvalue results by-reference.
GCC's ~-Wdangling-pointer~ warning (971 occurrences) revealed the problem:
#+BEGIN_SRC c
til_foo(({ til_Str _tmp = til_bar(); &_tmp; }))
#+END_SRC

The ~_tmp~ variable is local to the statement expression, so ~&_tmp~ is a dangling
pointer once the expression ends.

*** Root Cause
Statement expressions were used to create temporary variables for rvalue-to-reference
conversion. The temp variables went out of scope immediately after the statement
expression ended, leaving dangling pointers.

*** Fix (Bug #143)
Bug #143 restructured the ccodegen architecture with a single-pass hoist+emit approach
using ~emit_arg_string~ and ~hoist_output~. This change:
1. Processes each argument once through ~emit_arg_string~
2. Hoists non-lvalue arguments to temp variables BEFORE the function call
3. Returns the hoisted temp var name for use in the call

This completely eliminates statement expressions for temporary variables.

*** Files Changed
- src/rs/target.rs: Removed ~-Wno-dangling-pointer~ flag
- src/self/target.til: Removed ~-Wno-dangling-pointer~ flag

The architectural fix was already implemented in Bug #143 (commit b6f616a).

** Bug #146: C translation non-determinism in loop variable naming
:PROPERTIES:
:DISCOVERED: 2026-01-28
:FIXED: 2026-01-29
:IMPACT: Generated C code differs between builds, complicating diffs and version control
:STATUS: Fixed
:END:

*** Description
The C code generator produces different loop variable names between builds.
For example, the same loop may be named ~_loop_3~ in one build and ~_loop_1~
in another.

*** Root Cause
The ~LOOP_VAR_COUNTER~ in ~src/rs/parser.rs~ (and ~src/self/parser.til~) is a
global static counter that generates ~_loop_N~ names for ~for _ in~ loops.
Unlike ~precomp_forin_counter~ (fixed in Issue #127), this counter was never
reset - not per-file, not per-function.

Secondary issue: HashMap iteration order in Rust is non-deterministic due to
randomized hashing, causing different file processing orders between builds.

*** Implementation

**** Part 1: Reset counter per-function
Reset ~LOOP_VAR_COUNTER~ at the start of each function definition, similar to
how Issue #127 fixed ~precomp_forin_counter~.

Files modified:
- ~src/rs/parser.rs~: Added ~save_loop_var_counter~, ~reset_loop_var_counter~,
  ~restore_loop_var_counter~ functions
- ~src/self/parser.til~: Ported the same fix

**** Part 2: Fix file processing order
Implemented ~OrderedMap~ in ~src/rs/ordered_map.rs~ - a HashMap-like structure
that maintains insertion order using Vec internally.

Changed ~imported_asts~ and ~imported_modes~ in ~src/rs/init.rs~ from HashMap
to OrderedMap. This ensures deterministic file processing order across builds.

Note: TIL already uses ~Map~ which maintains sorted order (deterministic),
so no TIL changes were needed.

*** Files Changed
- src/rs/parser.rs: Counter save/reset/restore functions
- src/self/parser.til: Ported counter fix
- src/rs/ordered_map.rs: New OrderedMap implementation
- src/rs/init.rs: Use OrderedMap for imported_asts and imported_modes
- src/rstil.rs: Added ordered_map module

** Bug #143: ccodegen hoisted_exprs uses fragile identity mechanism
:PROPERTIES:
:DISCOVERED: 2026-01-27
:FIXED: 2026-01-29
:IMPACT: TIL ccodegen fails when multiple expressions share same line/col (e.g., desugared switch)
:STATUS: Fixed
:END:

*** Description
The ccodegen hoisted_exprs map tracked which expressions had been "hoisted" (extracted
to separate statements with temp variables) so that emit_expr could use the temp var
instead of re-emitting the expression.

The identity mechanism differed between Rust and TIL:
- Rust used memory address: ~expr as *const Expr as usize~
- TIL used line*1000000+col as workaround: ~expr.line.mul(1000000).add(expr.col)~

Both approaches were fragile:
- Memory addresses depend on how/when expressions are accessed
- Line/col collides when expressions share locations (desugared switch statements)

*** Implementation (Solution C: Single-pass hoist+emit)
Combined hoisting and emission into a single pass via ~emit_arg_string~ function.
When encountering an expression that needs hoisting, we hoist and emit in one step.

**** What was done:
1. Converted all call sites to use ~emit_arg_string~
   - ~emit_fcall~: Process all args upfront, then emit call with pre-computed strings
   - ~emit_variadic_call~, ~emit_throwing_call~, etc.
   - Return statement variadic call handling
   - Declaration RHS handling

2. Removed old hoisting functions (now dead code)
   - ~hoist_throwing_expr~ (-290 lines)
   - ~hoist_throwing_args~ (-285 lines)
   - ~hoist_for_dynamic_params~ (-160 lines)
   - ~emit_fcall_name_and_args_for_throwing~ (-110 lines)
   - ~emit_arg_with_param_type~ (-340 lines)
   - ~HoistedArg~ struct, ~ThrowingDefault~ struct

3. Removed ~hoisted_exprs~ HashMap entirely
   - Removed field from ~CodegenContext~
   - Removed all lookups in ~emit_expr~, ~emit_fcall~, etc.
   - No more fragile identity tracking

*** Files Changed
- src/rs/ccodegen.rs: Implemented emit_arg_string, removed hoisting functions and hoisted_exprs
- src/self/ccodegen.til: Ported same changes, adapted for TIL syntax

*** Result
~-1400 lines of code removed from each implementation. Simpler architecture,
no identity tracking needed.

*** Additional TIL Porting Work
After initial port, TIL-generated C differed from Rust. Required fixes:

1. Switch case handling must match Rust structure exactly:
   - Identifier/LLiteral: use ~emit_expr~ with shared ~) {\n~ after all branches
   - FCall else branch: use ~emit_arg_string~ with compound statement (GNU extension)
   - Generic case: use ~emit_expr~ with shared ~) {\n~
   - TIL had incorrectly used ~emit_arg_string~ everywhere, diverging from Rust

2. ~is_pure_lvalue~ struct lookup: TIL uses flag pattern since ~lookup_struct~ throws
   on not-found (Rust returns Option). Changed to:
   ~mut is_struct := false; _ := lookup_struct()?; is_struct = true; catch {...}~

3. Variadic returns: TIL was using ~emit_variadic_array_with_strings~ but Rust uses
   ~hoist_variadic_args~. The difference: ~hoist_variadic_args~ includes error check
   blocks for Array.set, ~emit_variadic_array_with_strings~ doesn't. Fixed TIL to
   call ~hoist_variadic_args~ matching Rust.

Key lesson: TIL code must match Rust structure exactly (same functions called in
same places), not just produce similar output. Even dead code (empty if blocks)
must be identical.

*** Related
- Bug #149: Discovered during port - scavenger was removing enum payload types
- Issue #110: Switch desugaring was blocked by this bug

** Bug #149: Scavenger removes enum payload types
:PROPERTIES:
:DISCOVERED: 2026-01-29
:FIXED: 2026-01-29
:IMPACT: GCC errors when compiling code that uses enums with struct payloads
:STATUS: Fixed
:END:

*** Description
The scavenger phase was removing struct types that are used as enum payloads
(e.g., Declaration, SFuncDef, SEnumDef, SStructDef, PatternInfo in NodeType enum).

This caused GCC errors like:
~error: unknown type name 'til_Declaration'~

The root cause:
1. Enums are always kept in the output (not filtered by used_types)
2. But their payload types (which are structs) were only kept if in used_types
3. Enum payload types weren't being added to used_types during reachability analysis

*** Implementation
Added Step 2b to scavenger that:
- Collects all enum payload types from the AST
- Computes transitive closure (struct field types of payload types)
- Adds them to used_types before the filtering step

*** Files Changed
- src/rs/scavenger.rs: Added Step 2b after variadic support handling
- src/self/scavenger.til: Ported same fix

*** Discovered While
Working on Bug #143 (single-pass hoist+emit port to TIL)

** Bug #101: Warn/error on unused things
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-01-13
:IMPACT: Code quality, catch dead code
:STATUS: Fixed
:END:

*** Description
Add warnings or errors for unused variables, functions, imports, struct fields, etc.
Currently we rely on rustc to catch these. Once rstil is gone, TIL needs this itself.

*** Implementation
- Error (not warning) for unused local variables and function arguments
- Suppression: prefix with underscore (e.g., ~_unused_var~)
- Tracks usage via ~used_symbols~ HashSet in ScopeStack
- ~mark_symbol_used()~ called when Identifier is checked
- ~get_unused_symbols()~ returns declared-but-unused symbols at function end
- Nested functions: inner usage merges back to outer scope

*** Files Changed
- src/rs/init.rs, src/self/init.til: Added used_symbols, mark_symbol_used, get_unused_symbols
- src/rs/typer.rs, src/self/typer.til: Mark symbols used, check at function end
- Various test and compiler files: Prefixed intentionally unused vars with ~_~

*** Decisions Made
- Error not warning: forces action, matches Go's approach
- Underscore prefix: simple, familiar convention from Python/Rust/Go
- Function-local only: global unused detection is more complex (may be used by other files)
- Nested function propagation: fixes false positives for outer vars used by inner functions

** Bug #129: Parser cannot handle explicit ~auto~ type annotation
:PROPERTIES:
:DISCOVERED: 2026-01-21
:FIXED: 2026-01-26
:IMPACT: Inconsistent syntax - ~a := 69~ works but ~a : auto = 69~ fails
:STATUS: Fixed
:END:

*** Description
The syntax ~a := 69~ is internally parsed as a Declaration with value_type="auto" (INFER_TYPE).
However, writing ~a : auto = 69~ explicitly fails with a parse error.

*** Root Cause
In parser.rs, parse_declaration uses ~explicit_type != INFER_TYPE~ to determine whether
to skip a type token. When user writes ~: auto~, the parser passes "auto" as explicit_type.
Since "auto" == INFER_TYPE, the condition is false and the parser doesn't skip the type token,
causing it to see ~=~ where it expects the value expression.

*** Fix
Added ~has_explicit_type: bool~ parameter to ~parse_declaration~ instead of relying on
string comparison. Callers now pass ~true~ when there's a type token to skip, ~false~ otherwise.
This decouples the token-skipping logic from the type value.

*** Files Modified
- ~src/rs/parser.rs~ - add has_explicit_type parameter, use it for advance decision
- ~src/self/parser.til~ - port same fix to TIL parser
- ~src/test/test_parser.til~ - update test call to pass new parameter

** Bug #141: Race condition in parallel tests - rstil and rstil_til share gen/bin directories
:PROPERTIES:
:DISCOVERED: 2026-01-26
:FIXED: 2026-01-26
:IMPACT: Flaky test failures in parallel test runs
:STATUS: Fixed
:END:

*** Description
When running tests in parallel, ~rstil~ (Rust compiler) and ~rstil_til~ (TIL self-hosted
compiler) both write to the same ~gen/c/~ and ~bin/~ directories. This causes race
conditions where one compiler overwrites files generated by the other.

*** Symptoms
- Tests pass with ~-j1~ but fail randomly with higher parallelism
- Different tests fail each run (non-deterministic)
- Errors like "undeclared variable" in generated C code (stale file from other compiler)

*** Fix
Separate output directories using ~LANG_NAME_141~ constant:
- ~gen/rs/c/~ and ~bin/rs/~ for rstil (LANG_NAME_141="rs")
- ~gen/til/c/~ and ~bin/til/~ for til (LANG_NAME_141="til")

*** Files Modified
- ~src/rs/lexer.rs~ - add LANG_NAME_141 constant ("rs")
- ~src/self/lexer.til~ - add LANG_NAME_141 constant ("til")
- ~src/rs/builder.rs~ - use LANG_NAME_141 in gen/bin paths
- ~src/self/builder.til~ - use LANG_NAME_141 in gen/bin paths
- ~src/rstil.rs~ - use LANG_NAME_141 in source_to_binary_path
- ~src/til.til~ - use LANG_NAME_141 in source_to_binary_path
- ~src/tests.til~ - update paths to bin/rs/ and bin/rs/til
- ~src/test_runner.til~ - update til command paths
- ~make.til~ - update all gen/ and bin/ paths
- ~Makefile~ - update bin path to bin/rs/make

** Bug #136: Switch on structs compares instance names, not values
:PROPERTIES:
:DISCOVERED: 2026-01-23
:FIXED: 2026-01-24
:IMPACT: Switch on struct values silently fails to match
:STATUS: Fixed
:END:

*** Description
Switch statements on struct types don't work correctly. The interpreter compares
instance names (like "p1" vs "__return_instance_0") instead of actual struct values.

*** Root Cause
In interpreter.rs, switch comparison uses ~result_to_switch.value == result_case.value~.
For structs, variable ~p~ evaluates to its name "p", while literal ~Point(x=5)~ evaluates
to temp name "__return_instance_N". These strings never match.

*** Fix
Modified switch comparison in both interpreters AND both codegens to detect struct
types and call their ~eq()~ method instead of comparing instance names:
- Skip primitive types (I64, U8, Bool, Str) whose values are literals, not instance names
- For non-primitive struct types, look up and call TypeName.eq(switch_val, case_val)
- If struct lacks eq() method, emit error: "Struct X requires eq() method for switch"
- Ccodegen emits ~til_TypeName_eq(&switch_var, &case_val).data~ for struct comparisons

Also completed porting Issue #119 (skip empty struct error parameters) to ccodegen.til
which was discovered as incomplete during testing.

*** Files Changed
- src/rs/interpreter.rs: Added struct eq() call in switch handling
- src/self/interpreter.til: Same change for self-hosted interpreter
- src/rs/ccodegen.rs: Added struct eq() call generation in switch handling
- src/self/ccodegen.til: Same change + completed Issue #119 porting
- src/rs/parser.rs: Handle Assignment nodes (name := func) inside struct definitions
- src/self/parser.til: Same change
- src/rs/scavenger.rs: Mark eq() methods as reachable when struct type is used
- src/self/scavenger.til: Same change
- src/test/flow.til: Added test_switch_struct_eq test

** Bug #123: UFCS method calls fail on recursive nested function results
:PROPERTIES:
:DISCOVERED: 2026-01-16
:FIXED: 2026-01-24
:IMPACT: Workaround required (use explicit Type.method() syntax)
:STATUS: Fixed
:END:

*** Description
When a nested function (defined inside a proc) calls itself recursively, UFCS method
resolution failed to find the return type. This prevented using `.add()`, `.sub()`, etc.
on the recursive call's result.

*** Root Cause
In ~ufcs_declaration~, the function definition was registered AFTER transforming its body.
For recursive nested functions, when transforming the body, the function's return type
wasn't available yet because it hadn't been registered.

*** Fix
In ~ufcs_declaration~ (both src/rs/ufcs.rs and src/self/ufcs.til), pre-register the
function definition BEFORE transforming its body. This allows recursive calls to resolve
UFCS on the function's own return type.

*** Files Changed
- src/rs/ufcs.rs: Added pre-registration of FuncDef before transforming body
- src/self/ufcs.til: Same change for self-hosted compiler
- src/test/bug123.til: Updated test to use UFCS version
- src/test/ufcs.til: Added test_ufcs_recursive_nested_functions
- src/test/fibonacci.til: Updated to use UFCS now that bug is fixed

** Bug #137: enum_get_payload reads from wrong offset in compiled mode
:PROPERTIES:
:DISCOVERED: 2026-01-23
:FIXED: 2026-01-23
:IMPACT: Enum payload extraction returns garbage in compiled code
:STATUS: Fixed
:REPRODUCER: tmp/test_enum_get_payload.til
:END:

*** Description
The ~enum_get_payload~ function in ~src/ext.c~ reads payload from a fixed offset,
but C struct alignment varies based on the payload union's largest member alignment.
Different enum types had different payload offsets (e.g., 4 for small payloads, 8 for
payloads containing I64).

*** Root Cause
C enums are typically 4 bytes (sizeof(int)), but payload unions align to their
largest member's alignment. This caused inconsistent payload offsets across
different enum types, making a fixed offset impossible.

*** Fix
Changed enum tag type from C enum to ~til_I64~ (8 bytes) to ensure consistent
8-byte offset for all payloads:
- ~src/ext.c~: Use ~sizeof(til_I64)~ for payload offset
- ~src/rs/ccodegen.rs~: Emit ~til_I64 tag;~ instead of ~EnumName_Tag tag;~
- ~src/self/ccodegen.til~: Same change for self-hosted compiler

*** Regression Test
Added ~test_bug137_enum_get_payload~ in ~src/test/enums.til~.

** Bug #126: Error message divergence between rstil and til
:PROPERTIES:
:DISCOVERED: 2026-01-19
:FIXED: 2026-01-22
:IMPACT: Tests must be in rs_common/til_common separately, not all_common
:STATUS: Fixed
:RELATED: Issue #69 (test organization), Bug #125 (non-deterministic errors)
:END:

*** Description
When the same code produces errors in both rstil and til, the error messages
differ in content, format, and/or order. This prevents tests from being in
all_common (which requires identical output across all 4 modes).

*** Examples (from src/test/sugar.til)

rstil produces extra errors that til doesn't:
- "Type 'Thing' has no method 'eq'" (init ERROR)

rstil has debug markers that til doesn't:
- "struct 'Thing' has no member 'eq' c" (trailing " c")
- See src/rs/init.rs:530 (" b"), 708 (" c"), 716 (" d")

*** Root Cause
1. Debug markers (" b", " c", " d") in Rust error messages not ported to TIL
2. Different code paths triggered between Rust and TIL implementations
3. Error collection/reporting order differs

*** Workaround
Tests with error output divergence go in rs_common AND til_common separately
(per Issue #69), with separate expected output files for each.

For sugar.til specifically, underscore-prefixed variables (_t1, _t2) avoid
Bug #125's non-deterministic unused variable errors.

*** Fix
Align error messages between src/rs/ and src/self/:
1. Remove debug markers from Rust or add them to TIL
2. Ensure same code paths produce same errors in same order
3. Port any error message changes bidirectionally

** Bug #124: I64 literals cannot be passed to U8 parameters in method calls
:PROPERTIES:
:DISCOVERED: 2026-01-17
:FIXED: 2026-01-22
:IMPACT: Must declare U8 constants for literals when calling U8 methods
:STATUS: Fixed
:END:

*** Description
When calling methods on U8 values using UFCS syntax, I64 numeric literals (like 42 or 255)
cannot be directly passed as arguments to U8 parameters. The type checker rejects them even
though I64 literals work fine in other contexts where U8 is expected (like variable assignment).

*** Example
#+BEGIN_SRC til
mut val : U8 = 41
val.inc()
test(loc(), val.eq(42), "should work but fails")  // ERROR: expects U8, got I64

// Workaround: declare constant first
u8_42 : U8 = 42
test(loc(), val.eq(u8_42), "works")  // OK
#+END_SRC

*** Root Cause
After refactoring U8.lt and U8.gt to use native u8_lt/u8_gt ext_funcs (instead of converting
to I64 internally), the type checker now strictly enforces U8 parameter types. The issue is
that literal type inference doesn't work for method call arguments the same way it works for
variable assignments.

Variable assignment: `val : U8 = 42` - the literal 42 is inferred as U8 (works)
Method call: `val.eq(42)` - the literal 42 is typed as I64 (fails)

*** The Fix
Added special case coercion in check_fcall (typer.rs and typer.til) to allow I64 numeric
literals to be passed to U8 parameters. The coercion only applies when:
1. Expected type is U8
2. Found type is I64
3. The argument expression is a numeric literal (NodeType::LLiteral(Literal::Number(_)))

This matches the existing behavior in init.rs/init.til for variable assignments.

*** Files Modified
- src/rs/typer.rs: Added is_u8_i64_coercion_skip check in check_fcall for Bug #61 loop,
  added is_u8_i64_coercion check before type mismatch error
- src/self/typer.til: Same fix ported

*** Notes
This affects U8.eq, U8.lt, U8.gt, U8.lteq, U8.gteq and any other U8 methods that take U8 parameters.
The old implementation of U8.lt/U8.gt worked around this by converting to I64 internally, but that
defeated the purpose of having native U8 comparison functions.

** Bug #128: INFER_TYPE should not exist in AST after typer phase
:PROPERTIES:
:DISCOVERED: 2026-01-20
:FIXED: 2026-01-21
:IMPACT: Phases after typer require type inference machinery they shouldn't need
:STATUS: Fixed
:RELATED: Issue #127, Bug #130 (remaining work)
:END:

*** Description
After typer completes, no INFER_TYPE references should remain in the AST.
Declaration nodes had value_type=INFER_TYPE after typer, requiring later phases
(precomp, interpreter, ccodegen) to re-infer types.

*** Fix Summary
Cleaned up INFER_TYPE handling across the codebase in 6 steps:
- Step 2: Added resolve_inferred_types() calls to builder.til
- Step 3: Simplified resolve_inferred_types() to use get_value_type() directly
- Step 4: Fixed desugarer to use I64 directly for _for_i index variables
- Step 4b: Fixed resolve_inferred_types to recurse into StructDef default_values
- Step 5: Removed INFER_TYPE handling from precomp (both Rust and TIL)
- Step 6: Removed INFER_TYPE handling from ccodegen (both Rust and TIL)

Remaining work (unifying type checking with type resolution) split to Bug #130.

** Bug #125: Non-deterministic unused variable error ordering
:PROPERTIES:
:DISCOVERED: 2026-01-19
:FIXED: 2026-01-21
:IMPACT: Minor - warnings appeared in random order
:STATUS: Fixed
:END:

*** Description
Unused variable warnings were reported in non-deterministic order because
`function_locals` was stored in a HashSet (unordered).

*** Fix
Changed `function_locals` from HashSet to Vec<FunctionLocal>, which maintains
insertion order. Errors now consistently report in declaration order (a, b, c).

Verified by running the same test file multiple times with both rstil and til -
output is now deterministic.

** Bug #118: Unreachable code error message should clarify catch blocks are statements
:PROPERTIES:
:DISCOVERED: 2026-01-15
:FIXED: 2026-01-21
:IMPACT: Developer confusion, especially for LLMs and those from try/catch languages
:STATUS: Fixed
:END:

*** Description
The unreachable code error message didn't clarify that catch blocks are also subject
to this rule. Developers (and LLMs) coming from languages with try/catch syntax often
place catch blocks after return statements, expecting them to work like Java/Python/C++
where catch is syntactically bound to try and doesn't need to be "reached".

*** Fix
Updated error message in both src/rs/typer.rs and src/self/typer.til to include:
"Note: In TIL, catch is a statement that must be reachable, not syntax bound to a try block."

*** Note
This message may not be ideal for users seeing the error without using catch at all.
A future issue could improve this by only mentioning catch when a catch block is
actually present in the unreachable code. For now, the clarification helps more than
it confuses.

** Bug #102: Automatic dependency tracking from imports
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-01-16
:IMPACT: Build performance, eliminates unnecessary recompilation
:STATUS: Fixed
:END:

*** Description
Have ~til run~ analyze dependencies from import() calls automatically. When the
binary already exists and neither the source nor any of its dependencies changed,
run the binary directly without recompiling.

*** Implementation
Added automatic dependency collection and mtime checking to the ~run~ command:

1. ~collect_all_deps(path)~ in builder.rs/builder.til:
   - Parses main file to get mode and imports
   - Recursively collects all transitive imports
   - Includes core.til and mode-specific imports
   - Returns list of all .til file dependencies

2. ~needs_rebuild(binary_path, deps)~ in rstil.rs/til.til:
   - Checks if binary exists
   - Compares binary mtime against all dependency mtimes
   - Returns true if any dep is newer than binary

3. Modified ~run_file_or_exit~ to:
   - Compute expected binary path
   - Collect dependencies
   - Skip build if binary is up-to-date
   - Execute binary directly

*** Design Decisions
- No caching: Dependencies recomputed each run (simpler, no invalidation issues)
- No ext_dep syntax: Only tracks .til files for now
- Lightweight parsing: Uses parse-only pass without full init/typer phases

*** Results
- ~til compiled~ test time dropped from 72s to 6s (binaries reused) when deps unchanged
- ~rs compiled~ drops from 28s to 3s on incremental runs (binaries reused)
- No change to build correctness (touching any dep triggers rebuild)

*** Files Modified
- src/rs/builder.rs: Added ~collect_import_paths~, ~collect_all_deps~
- src/rstil.rs: Added ~file_mtime~, ~source_to_binary_path~, ~needs_rebuild~;
  modified ~build_file_or_exit~ and ~run_file_or_exit~; added ~--force-rebuild~ flag
- src/self/builder.til: Ported ~collect_import_paths~, ~collect_all_deps~
- src/til.til: Added ~source_to_binary_path~, ~needs_rebuild~;
  modified ~build_file_or_exit~ and ~run_file_or_exit~; added ~--force-rebuild~ flag
- make.til: Simplified - removed manual .til dep tracking (now automatic);
  changed shebang to ~rstil run~; tracks ~g_compiler_changed~ to pass ~--force-rebuild~ to tests
- src/test_runner.til: Accepts ~--force-rebuild~ flag; shebang changed to ~rstil run~
- src/tests.til: Accepts ~--force-rebuild~ flag and passes to test_runner; shebang changed to ~rstil run~
- src/til_diff.til: Shebang changed to ~rstil run~

*** --force-rebuild Flag
Tests only force rebuild when compiler changed:
1. make.til sets ~g_compiler_changed~ when ~bin/rstil~ is newer than ~bin/til~
2. ~run_tests~ passes ~--force-rebuild~ to ~tests.til~ only when compiler changed
3. ~tests.til~ passes it to ~test_runner.til~
4. ~test_runner.til~ passes it to ~rstil run~ / ~til run~
This ensures fresh test builds after compiler changes, while allowing binary reuse otherwise.

*** Fair Benchmark Timing
For compiled mode tests, build time is now separated from execution timing:
1. For tests expecting success (~expected_status == 0~), ~test_runner.til~ first runs
   ~rstil build~ or ~til build~ (with ~--force-rebuild~ if needed) before timing
2. The timed command (~rstil run~ / ~til run~) then just executes the already-built binary
3. Error tests (~expected_status != 0~) skip pre-building since they're designed to fail
This ensures benchmark times are consistent whether the binary needed building or not.

** Bug #115: Map iteration using wrong pattern (len() instead of direct iteration)
:PROPERTIES:
:DISCOVERED: 2026-01-15
:FIXED: 2026-01-15
:IMPACT: Potential data corruption with Map lazy deletion; deviation from rs2til.org rules
:STATUS: Fixed
:END:

*** Description
Several places in interpreter.til and typer.til used index-based Map iteration with
~map.len()~ instead of direct iteration over ~map.keys~ as specified in rs2til.org.
This pattern would fail with lazy deletion where ~_size < keys._len~.

*** Root Cause
The Rust code uses ~for (k, v) in &map~ which iterates all keys. The correct TIL
translation per rs2til.org is ~for k: Str in map.keys~, but several places used:

#+BEGIN_SRC til
// WRONG: Uses map.len() which returns _size
for i in 0..map.len() {
    map.keys.get(i, key)
    ...
}
#+END_SRC

*** Fix
Changed all occurrences to use direct iteration per rs2til.org:

#+BEGIN_SRC til
// CORRECT: Direct iteration over keys Vec
for key: Str in map.keys {
    mut val := ...
    map.get(key, val)
    ...
}
#+END_SRC

*** Files Modified
- src/self/interpreter.til:
  - Line ~161: nested_values iteration in read_struct_primitive_fields
  - Line ~251: nested map iteration in eval_struct_defaults
  - Line ~264: primitive_values iteration in eval_struct_defaults
  - Lines ~2011, ~2044, ~2391: catch handler iterations (keys._len pattern)
- src/self/typer.til:
  - Line ~2821: default_values iteration in is_expr_calling_procs

*** Notes
- The keys._len pattern at lines 2011, 2044, 2391 is kept for future HashMap support
- Removed now-unnecessary IndexOutOfBoundsError catch blocks
- No performance impact (within noise margin)

** Bug #86: For-in loop fails with enum that has enum payload
:PROPERTIES:
:DISCOVERED: 2026-01-06
:FIXED: 2026-01-15
:IMPACT: Cannot use for-in loops with certain enum types
:STATUS: Fixed
:END:

*** Description
When an enum's first variant has another enum as its payload type, using that
enum type in a for-in loop fails at init time with the error:
"Enum constructor X expects payload of type Y, but got enum"

*** Example
#+BEGIN_SRC til
InnerEnum := enum { FTFunc, FTProc }
OuterEnum := enum {
    TFunction: InnerEnum,  // First variant has enum payload
    TCustom: Str,
}

mut v := Vec.new(OuterEnum)
for item: OuterEnum in v {  // ERROR at init time
    // ...
}
#+END_SRC

*** Root Cause
~build_default_value~ in precomp.rs/til was generating invalid enum constructors.
For an enum whose first variant has an enum payload, it generated ~InnerEnum()~
instead of the correct ~InnerEnum.FTFunc~ (or appropriate default variant).

*** Fix
Made ~build_default_value~ recursive: when the first variant has an enum payload,
it now calls ~build_default_value~ again for that nested enum, producing the
correct default constructor chain.

*** Tests
- src/test/loops.til: test_forin_payload_enum (previously commented out, now works)

** Bug #93: Test runner returns exit code 0 even with failures
:PROPERTIES:
:DISCOVERED: 2026-01-08
:FIXED: 2026-01-10
:IMPACT: CI/CD reliability
:STATUS: Fixed
:END:

*** Description
~make tests~ returned exit code 0 even when tests failed. This broke CI/CD
pipelines that rely on exit codes to detect failures.

*** Root Cause
In make.til's ~run_tests~ proc, the exit code from ~./bin/tests~ was being
overwritten by the subsequent ~cp~ command before checking.

*** Fix
Save the tests exit code before running cp:
#+BEGIN_SRC til
status = run_stream_cmd("./bin/tests")
tests_status := status  // Save before cp overwrites it
status = run_stream_cmd("cp gen/c/test/constfold.c src/test/constfold.c")
if tests_status.eq(0).not() {
    exit(1)
}
#+END_SRC

*** Test
Added src/test/panic.til with expected_status=1 to verify exit code handling.

** Bug #95: Need spread operator to expand Vec/Array for variadic arguments
:PROPERTIES:
:DISCOVERED: 2026-01-09
:IMPACT: Cannot pass collected arguments to variadic functions
:STATUS: Fixed
:DUPLICATE: Bug #83
:END:

See Bug #83 for full details. All unique content merged there.

** Bug #87: Scavenger not pruning struct methods
:PROPERTIES:
:DISCOVERED: 2026-01-07
:FIXED: 2026-01-07
:IMPACT: Generated C code 10x larger than necessary
:STATUS: Fixed
:END:

*** Description
The scavenger phase was not properly pruning unused struct methods. An empty
script (just =mode script=) generated 1,167 lines of C code instead of ~100.

*** Root Cause
In =compute_reachable=, when processing struct constructors (e.g., =Bool()=),
the code walked into ALL =default_values= including method bodies (FuncDef).
This incorrectly marked all methods as reachable even when not called.

#+begin_src rust
// BUG: This walked into method bodies too
for default_expr in struct_def.default_values.values() {
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Fix
Skip FuncDef values when processing struct constructors - methods should only
be walked if explicitly called via their qualified name (e.g., =I64.eq=).

#+begin_src rust
for default_expr in struct_def.default_values.values() {
    if let NodeType::FuncDef(_) = &default_expr.node_type {
        continue;  // Skip methods
    }
    collect_called_functions(default_expr, &mut called);
}
#+end_src

*** Files Changed
- =src/rs/scavenger.rs= (lines 239-244)
- =src/self/scavenger.til= (lines 274-280)

*** Results
- =empty.c=: 1,167 lines -> 99 lines (92% reduction)
- =til compiled= benchmark: 39s -> 27s (~30% faster)
- All 107 tests pass

*** Additional Fix: Prune Unused Struct Definitions

After fixing method pruning, we also added pruning of unused struct/enum definitions.
The scavenger now tracks which types are actually used (in function signatures, declarations,
constructors) and removes struct definitions that aren't referenced.

**** Implementation
- Added =used_types: HashSet<String>= to =ComputeReachableResult=
- Added =EXT_C_TYPES= constant for types required by ext.c (Bool, Str, I64, U8, AllocError, Array)
- Added =extract_type_name()=, =collect_used_types_from_expr()=, =collect_used_types_from_func()=
- Transitive closure: when a type is used, its field types are also marked as used
- Struct filtering in AST rebuild checks =used_types.contains(&decl.name)=

**** Results
- =empty.c=: 99 lines -> 61 lines (additional 38% reduction)
- All 107 tests pass

**** Also Added
- =Ptr.is_null()= method to src/core/ptr.til (matches rs2til.org documentation)

** Bug #84: run_cmd output capture broken in compiled mode
:PROPERTIES:
:DISCOVERED: 2026-01-05
:FIXED: 2026-01-05
:IMPACT: Cannot use compiled test.til
:STATUS: Fixed
:END:

*** Description
The =run_cmd= ext_proc didn't capture command output correctly in compiled mode.
The mutable output string parameter remained empty (or got only a newline).

*** Root Cause
The C implementation in =src/ext.c= used =popen()= which passes commands through the shell.
Arguments weren't quoted, so =bash -c echo hello= was executed instead of =bash -c 'echo hello'=.

*** Fix
1. =src/ext.c=: Added single-quote wrapping for arguments (except command) with proper escaping of embedded single quotes as ='\''=.
2. =src/self/ext.til=: Implemented =proc_run_cmd= to call the host's =run_cmd= via =bash -c= with properly quoted arguments. This was previously throwing "not yet implemented".

*** Test
=src/test/syscalls.til= has =test_run_cmd_output()= which verifies output capture works.

** Bug #85: Typer accepts struct literal with non-existent field name
:PROPERTIES:
:DISCOVERED: 2026-01-05
:FIXED: 2026-01-08
:IMPACT: Silent code generation with wrong semantics
:STATUS: Fixed
:END:

*** Description
The type checker accepts struct literals with field names that don't exist in the struct definition.

*** Example
#+begin_src til
KeyNotFoundError := struct {
    mut msg: Str = ""
}

// This should be a type error but compiles successfully:
throw KeyNotFoundError(key="not variadic")
// Should be: throw KeyNotFoundError(msg="not variadic")
#+end_src

The struct only has a ~msg~ field, but ~key=~ is accepted without error.

*** Solution
Added field name validation in ~check_fcall()~ (typer.rs/typer.til).

When a function call returns ~None~ from ~get_func_def_for_fcall_with_expr~
(indicating struct/enum instantiation), we now:
1. Look up the struct definition
2. Collect all valid field names
3. For each ~NamedArg~ in the call, verify the field name exists
4. Report type error if field doesn't exist

The fix also type-checks argument values, which was previously skipped for
struct instantiation.

*** Files Modified
- ~src/rs/typer.rs~: Added validation in ~check_fcall()~
- ~src/self/typer.til~: Ported same changes

*** Bonus Fix
The fix caught a pre-existing bug in ~src/self/ccodegen.til~ where
~SymbolInfo~ was being constructed with non-existent fields:
- ~symbol_type~ (doesn't exist - removed)
- ~is_mutable~ (should be ~is_mut~ - corrected)

** Bug #78: TIL scavenger/ccodegen divergence from Rust
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_compiled (./bin/til build/run) crashes
:STATUS: Fixed
:END:

*** Description
The self-hosted TIL compiler crashed when running ~./bin/til build src/examples/empty.til~.
Multiple divergences between Rust and TIL implementations were causing issues.

*** Root Causes and Fixes

1. **scavenger.til compute_reachable return type**: TIL version handled
   ~needs_variadic_support~ inside the function with a recursive call, while Rust
   handled it at the call site. Fixed by adding ~ComputeReachableResult~ struct
   to both Rust and TIL, returning both values and handling at call site.

2. **ccodegen.til topological_sort_types**: TIL version used ~List~ with nested
   ~Vec~ elements, but modifications to copies didn't persist (TIL collections
   return copies, not references). Fixed by:
   - Changed parameter from ~List~ to ~Vec~
   - Changed internal ~List~ of ~Vec~ to ~Map<I64, Vec>~ with get/modify/set pattern
   - All catch blocks now throw ~err.msg~ instead of being empty (matching Rust panics)

3. **rs2til.org documentation**: Added new section "Implicit panics become throws Str"
   documenting that Rust code that would panic should throw Str in TIL.

*** Current Status
Scavenger and topological sort phases complete successfully. Crash now occurs
later in emit phase - investigation continues.

** Bug #77: Nested enum patterns incorrectly treated as binding variables
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: til_interpreted tests fail - bug47 and til.til help blocked
:STATUS: Fixed
:END:

*** Description
When parsing switch case patterns like ~case ValueType.TType(TTypeDef.TEnumDef):~,
the parser incorrectly treated the nested identifier ~TTypeDef.TEnumDef~ as a binding
variable with name "TTypeDef", causing the typer to declare a local symbol "TTypeDef"
with value_type TCustom("TTypeDef") that shadowed the real enum definition.

*** Root Cause
In parser.til parse_case_expr function, when checking if an FCall argument is a binding
variable (line 2005), it only checked if ~p1.node_type~ was an Identifier, but did not
check if the identifier had nested params. The Rust version had an additional check:
~if left.params[1].params.is_empty()~ to only treat simple identifiers as bindings.

*** Fix
Added check in parser.til at line 2008: ~if p1.params.len().eq(0)~
This ensures only simple identifiers (no nested params like TTypeDef.TEnumDef) are
treated as binding variables. Nested patterns remain as FCall for proper matching.

** Bug #73: TTypeDef value_type stored as TStructDef (actually Bug #77)
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: Cannot import self.init with til interpret
:STATUS: Fixed
:END:

*** Description
The symptoms were "Struct 'TTypeDef' not found" when processing init.til, but the
actual root cause was Bug #77 - nested enum patterns being incorrectly treated as
bindings, causing TTypeDef to be declared as TCustom("TTypeDef") in a local scope.

** Bug #74: TIL interpreter mut enum parameter write-back loses payload
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: vecs.til test fails - enum payload lost when extracting via switch
:STATUS: Fixed
:END:

*** Description
When a mut enum parameter is passed to a function (like Vec.get), and that function
modifies the enum (via memcpy), the payload is lost when writing back to the caller.

*** Root Cause
TIL's interpreter.til was missing the Bug #38 fix in the ~MutArgValue.Enum~ case
of the mut argument write-back logic. Rust sets ~context.temp_enum_payload~ before
calling ~insert_enum~ to preserve the payload data, but TIL was not doing this.

*** Fix
Added the Bug #38 fix to interpreter.til line 3154-3167:
#+BEGIN_SRC til
case MutArgValue.Enum(enum_val):
    // Bug #38 fix: Set temp_enum_payload so insert_enum preserves the payload
    if not(NULL.eq(enum_val.payload.data)).and(not(NULL.eq(enum_val.payload_type.data))) {
        // Read payload Vec and ValueType from the pointers
        mut payload_vec := Vec.new(U8)
        memcpy(to_ptr(payload_vec), enum_val.payload.data, size_of(Vec))
        mut payload_type := ValueType.TCustom("")
        memcpy(to_ptr(payload_type), enum_val.payload_type.data, size_of(ValueType))
        // Create EnumPayload and set temp_enum_payload
        mut temp_payload := EnumPayload(data=payload_vec.clone(), value_type=payload_type)
        heap_payload_ptr := malloc(size_of(EnumPayload))
        memcpy(heap_payload_ptr, to_ptr(temp_payload), size_of(EnumPayload))
        context.temp_enum_payload.data = heap_payload_ptr
    }
    _ := EvalArena.insert_enum(...)
#+END_SRC

*** Test
~src/test/vecs.til~ - now passes with ~til interpret~.

** Bug #75: TIL interpreter missing string range comparison support
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: test_lexer.til fails - lexer uses case "0".."9" patterns
:STATUS: Fixed
:END:

*** Description
The TIL interpreter threw "String range comparisons not yet supported" when
encountering switch case patterns like ~case "0".."9"~ in lexer.til. This
blocked the test_lexer.til test from running with ~./bin/til interpret~.

*** Root Cause
The Rust interpreter uses native string comparison operators (~>=~ and ~<=~)
for lexicographic comparison, but TIL's interpreter.til was throwing an error
instead of implementing the comparison.

*** Fix
Added ~Str.cmp()~ method to str.til that performs lexicographic comparison:
#+BEGIN_SRC til
cmp := func(self: Str, other: Str) returns I64 {
    mut min_len := self.len()
    if other.len().lt(min_len) {
        min_len = other.len()
    }
    for i in 0..min_len {
        a_byte := self.char_at(i)
        b_byte := other.char_at(i)
        a_val := U8.to_i64(a_byte)
        b_val := U8.to_i64(b_byte)
        if a_val.lt(b_val) {
            return sub(0, 1)
        }
        if a_val.gt(b_val) {
            return 1
        }
    }
    return sub(self.len(), other.len())
}
#+END_SRC

Updated interpreter.til to use it instead of throwing:
#+BEGIN_SRC til
// Lexicographic string comparison
cmp_start := result_to_switch.value.cmp(start.value)
cmp_end := result_to_switch.value.cmp(end.value)
is_match = cmp_start.gteq(0).and(cmp_end.lteq(0))
#+END_SRC

*** Test
~src/test/test_lexer.til~ - now passes with ~til interpret~.

** Bug #76: Optional function arguments not working in til_interpreted
:PROPERTIES:
:DISCOVERED: 2026-01-01
:FIXED: 2026-01-01
:IMPACT: optional_args.til fails - functions with default arg values have args.len() = 0
:STATUS: Fixed
:END:

*** Description
Functions with optional arguments (e.g., ~greeting: Str = "Hello"~) were failing
in the til-interpreted tests with "expects at most 0 args" error. The function's
args.len() was 0 when looked up, even though it was declared with correct args.

*** Root Cause
In ~parse_func_proc_args~ in parser.til, when parsing optional argument default
values, the code was:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    decl.default_value.data = to_ptr(default_expr)  // BUG: pointer to local!
#+END_SRC

~default_expr~ is a local variable on the stack. Taking a pointer to it with
~to_ptr(default_expr)~ creates a dangling pointer when the function returns.
This is a use-after-free bug - the memory at that address gets reused for other
data, corrupting the default_value pointer.

*** Fix
Allocate heap memory for the Expr and copy it there:
#+BEGIN_SRC til
case TokenType.Equal:
    lexer.advance(1)  // consume '='
    mut default_expr := parse_primary(lexer)
    // Must allocate heap memory - to_ptr(default_expr) would create dangling pointer
    decl.default_value.data = malloc(size_of(Expr))
    memcpy(decl.default_value.data, to_ptr(default_expr), size_of(Expr))
#+END_SRC

*** Test
~src/test/optional_args.til~ - now passes with ~til interpret~.

** Bug #72: Copying global enum with payload segfaults in til interpreter
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2026-01-01
:IMPACT: enums.til test fails with til interpret
:STATUS: Fixed
:END:

*** Description
When a global enum variable has a payload (e.g., ~Color.Green(true)~) and is copied
to a local variable inside a function, the til interpreter segfaults.

*** Root Cause
Two issues in ~eval_arena.til~'s ~get_enum~ and ~get_enum_at_offset~ functions:
1. ~payload_bytes~ and ~payload_type~ are local stack variables
2. ~to_ptr()~ returns pointers to these stack variables
3. When the function returns, these pointers become stale (use-after-free)

Additionally, pattern binding for enum payloads that are themselves enums was missing
proper arena insertion.

*** Fix
1. In ~get_enum~ and ~get_enum_at_offset~: heap-allocate the Vec and ValueType structs
   using ~malloc(size_of(...))~ before returning, so pointers remain valid.
2. In ~interpreter.til~ pattern binding: added TEnumDef case that properly looks up
   the inner enum variant, sets ~temp_enum_payload~ if needed, and calls ~insert_enum~.

*** Test
~src/test/enums.til~ - now passes with ~til interpret~.

** Bug #71: TIL interpreter enum pattern binding use-after-free
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Pattern binding in switch cases failed with "Type unknown not supported yet"
:STATUS: Fixed
:END:

*** Description
When pattern matching on enum variants with payloads (e.g., ~case TestEnum.TypeC(n)~),
the bound variable ~n~ could not be used - accessing it gave "Type unknown not supported yet".

*** Root Cause
~EnumVal~ in TIL uses ~Ptr~ fields for ~payload~ and ~payload_type~, pointing to local
stack variables in ~get_enum~. When ~get_enum~ returns, these pointers become stale
(use-after-free). The Rust version uses owned ~Option<Vec<u8>>~ and ~Option<ValueType>~
which don't have this issue.

*** Fix
Changed pattern binding code in ~interpreter.til~ to look up payload type directly from
the enum definition (via ~lookup_enum~) and read payload bytes directly from the arena,
instead of using the stale ~EnumVal.payload_type~ and ~EnumVal.payload~ pointers.

Supports all payload types: I64, Str, and structs (including Bool and custom structs).

*** Test
~src/test/ufcs.til~ - tests pattern matching with I64 and Str enum payloads.

** Bug #70: C codegen variable type collision causes struct default garbage
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: Struct fields with default I64 values returned garbage in til interpret
:STATUS: Fixed
:END:

*** Description
~src/test/mut_test.til~ failed with ~til interpret~, returning garbage values for
struct fields with default I64 values:
#+BEGIN_EXAMPLE
src/test/mut_test.til:65:19:assert_eq failed: expected '0', found '2147395840'
#+END_EXAMPLE

*** Root Cause
In ~src/self/eval_arena.til~'s ~insert_struct_core~, both U8 and I64 branches
used a local variable named ~v~:
#+BEGIN_SRC til
if type_name.eq("U8") {
    v := U8.from_str(default_value)  // v declared as U8
    ...
} else {
    if type_name.eq("I64") {
        v := I64.from_str(default_value)  // v redeclared as I64
        ...
#+END_SRC

The C code generator reused the same variable declaration:
#+BEGIN_SRC c
til_U8 til_v;  // Declared as U8
...
til_v = til_I64_from_str(&til_default_value);  // Assigned I64 to U8!
#+END_SRC

This caused an 8-byte I64 value to be stored in a 1-byte U8 variable,
then only 1 byte was copied to the arena, resulting in garbage values.

*** Fix
Renamed variables to be unique: ~u8_val~ for U8 branch, ~i64_val~ for I64 branch.
This prevents variable name collisions across different type branches.

Files modified:
- ~src/self/eval_arena.til~ (TIL version)
- ~src/rs/eval_arena.rs~ (Rust version, for consistency)

** Bug #63: Typer allows passing const variable to own parameter
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-31
:IMPACT: Incorrect ownership semantics, gcc warnings about discarding const
:STATUS: Fixed
:END:

*** Description
When a function has an ~own~ parameter, the typer should require the caller
to pass a ~mut~ variable, just like it does for ~mut~ parameters. Currently,
the typer allows passing const variables to ~own~ parameters.

*** Reproducing
#+BEGIN_SRC til
consume := proc(own v: Vec2) returns I64 {
    return add(v.x, v.y)
}

test := proc() {
    original := Vec2(x=1, y=2)  // const, not mut
    result := consume(original)  // Should error, but doesn't
}
#+END_SRC

*** Expected behavior
Typer should emit an error like: "Cannot pass const variable 'original' to own parameter 'v'"

*** Fix Applied
Added check in typer.rs and typer.til for ~is_own~ parameter, similar to existing
~is_mut~ check. When processing FCall args, if the parameter is ~own~ and the
argument is a const variable (identifier with ~!symbol_info.is_mut~), emit type error.

** Bug #68: TIL typer doesn't remove symbol for own parameter (Bug #49 fix not working)
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: til_interpreted output mismatch on bug49.til (1 error vs 2)
:STATUS: Fixed
:RELATED: Bug #49 (original fix), Bug #65 (similar Rust/TIL divergence)
:END:

*** Description
The Bug #49 fix (remove_symbol for own parameters) exists in both typer.rs and typer.til,
but the TIL version doesn't work. When a variable is passed to an ~own~ parameter:
- rstil: 2 errors (type ERROR + init ERROR for undefined symbol)
- til: 1 error (init ERROR only)

The ~remove_symbol~ call at typer.til:861 is being executed, but the symbol remains
findable by subsequent lookups.

*** Code Location
typer.til lines 854-866:
#+BEGIN_SRC til
// Bug #49: Handle ownership transfer for 'own' parameters
if arg.is_own {
    switch arg_expr.node_type {
    case NodeType.Identifier(var_name):
        if arg_expr.params.len().eq(0) {
            _ := context.scope_stack.remove_symbol(var_name)
        }
    case:
    }
}
#+END_SRC

*** Investigation Notes (2025-12-31)
- Debug prints confirmed ~remove_symbol~ IS being called and modifies the frame correctly
- After removal, ~lookup_symbol~ correctly shows ~contains_key=false~ for all frames
- BUT ~symbol_found~ is still set to ~true~ after the catch block

*** Root Cause Hypothesis
Examined generated C code in bootstrap/til.c. Found that when there are TWO consecutive
catch blocks for the SAME error type, the second one is MISSING the ~goto~ statement:

~lookup_func~ (first catch - CORRECT):
#+BEGIN_SRC c
int _status_104 = til_ScopeStack_lookup_func(...);
if (_status_104 == 1) { ... goto _catch_KeyNotFoundError_96; }  // <-- goto EXISTS
til_func_found = true;
if (0) { _catch_KeyNotFoundError_96: ... }
#+END_SRC

~lookup_symbol~ (second catch - BROKEN):
#+BEGIN_SRC c
int _status_105 = til_ScopeStack_lookup_symbol(...);
// <-- NO GOTO HERE! Missing: if (_status_105 == 1) { goto _catch_97; }
til_symbol_found = true;
if (0) { _catch_KeyNotFoundError_97: ... }
#+END_SRC

This is a ccodegen.rs bug: consecutive catch blocks for same error type lose their goto.

*** Reproducing Test
Test file: src/test/bug68.til

- ~rstil interpret src/test/bug68.til~  PASS (symbol_found=false, catch works)
- ~rstil run src/test/bug68.til~  FAIL (symbol_found=true, catch doesn't execute)

The test imports typer.til and calls ~check_types_with_context~ directly, which
contains the buggy consecutive catch pattern.

*** Partial Fix Applied
Added explicit ~func_found = false~ and ~symbol_found = false~ in catch blocks in typer.til.
This is correct - per rs2til.org, catching KeyNotFoundError is like ~.is_some() = false~.
The catch blocks now have the right code, but ccodegen.rs doesn't generate the goto to reach them.

*** Plan to Fix
1.  Created reproducing test (bug68.til)
2.  Verified ~rstil interpret~ works but ~rstil run~ fails
3.  Added explicit false assignments in catch blocks (typer.til)
4.  Fixed ccodegen.rs: added ~func_level_catches.is_empty()~ check to propagate condition
5.  Ported fix to ccodegen.til

*** Fix Applied
The propagate condition was missing the ~func_level_catches.is_empty()~ check.
When ~local_catch_labels~ was empty (after processing an earlier catch), the code
would propagate errors even when there were more catches in the block.

Fix: Changed propagate condition from:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() {
#+END_SRC
To:
#+BEGIN_SRC rust
} else if !ctx.current_throw_types.is_empty() && ctx.local_catch_labels.is_empty() && func_level_catches.is_empty() {
#+END_SRC

This ensures we only propagate when there are NO catches in the block, not just when
~local_catch_labels~ happens to be empty due to earlier catch processing.

** Bug #67: Enum variant payload type comes through as empty string in til
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 4 til_interpreted tests affected (bug56, editor_mode_test, enums, forward_declarations)
:STATUS: Fixed
:END:

*** Description
When an enum has a variant with a payload type (e.g., ~Variant1: Str~), the self-hosted
TIL interpreter receives the type as empty string, causing "uses undefined type ''" errors.
The Rust interpreter works correctly.

*** Root Cause
In parser.til, ~to_ptr(payload_type)~ was storing a pointer to a stack variable that
became invalid when the loop continued or function returned. The Rust version uses
~Option<Box<ValueType>>~ which properly heap-allocates, but the TIL translation using
~Ptr~ (per rs2til.org for Option fields) requires explicit heap allocation.

Two locations affected:
1. ~EnumVariant.clone()~ - stored pointer to stack variable ~cloned_type~
2. ~enum_definition()~ - stored pointer to stack variable ~payload_type~

*** Fix
Used malloc to allocate heap memory instead of storing stack pointer:
#+BEGIN_SRC til
// In EnumVariant.clone():
result.payload_type.data = malloc(size_of(ValueType))
memcpy(result.payload_type.data, self.payload_type.data, size_of(ValueType))

// In enum_definition():
payload_ptr.data = malloc(size_of(ValueType))
memcpy(payload_ptr.data, to_ptr(payload_type), size_of(ValueType))
#+END_SRC

*** Results
- bug56.til: Fixed (now in til_interpreted)
- editor_mode_test.til: Fixed (now in til_interpreted)
- forward_declarations.til: Fixed (now in til_interpreted)
- enums.til: Still segfaults (different bug, not enum payload related)

** Bug #65: "Source 'X' not found in caller context" with Dynamic parameters
:PROPERTIES:
:DISCOVERED: 2025-12-31
:FIXED: 2025-12-31
:IMPACT: 10 til_interpreted tests fail (arenas, arrays, clone, lists, loops, maps, etc.)
:STATUS: Fixed
:RELATED: Issue #66 (shadowing policy)
:END:

*** Description
When passing literal values to Dynamic parameters (e.g., ~v.push(10)~ on a Vec),
the self-hosted TIL interpreter fails with "Source '10' not found in caller context".
The Rust interpreter works correctly.

*** Root Cause
Rust/TIL divergence in interpreter.rs/interpreter.til:

Rust used variable shadowing (~let custom_type_name = ...~) to resolve Dynamic/Type
parameters to their actual types. TIL doesn't support shadowing the same way, so it
used a different variable (~resolved_type_name~) but then inconsistently used the
original ~custom_type_name~ in subsequent code.

*** Fix
Changed both Rust and TIL to use ~resolved_type_name~ consistently (no shadowing).
Updated ~-Wshadow~ flag for gcc to catch similar issues in generated C code.

Test file: src/test/bug65.til

See Issue #66 in doc/todo/future.org for long-term shadowing policy discussion.

** Bug #60: ccodegen passes const/own args by value instead of by pointer
:PROPERTIES:
:DISCOVERED: 2025-12-28
:FIXED: 2025-12-29
:IMPACT: Stack overflow on recursive functions with large struct args
:STATUS: Fixed
:END:

*** Description
In TIL, function arguments should be passed as follows:
- *const (default)*: by const pointer (const T*)
- *own*: by pointer (T*) - caller transfers ownership
- *mut*: by pointer (T*) - currently correct
- *copy*: by value (T) - currently correct

Currently, ccodegen.rs passes const and own args by value, causing stack
overflow when functions with large struct arguments are called recursively.

*** Reproducing
Inspect gen/c/test/args.c after running ~./bin/rstil run src/test/args.til~:

#+BEGIN_SRC c
// WRONG - const args passed by value:
til_I64 til_test_i64_arg(const til_I64 til_n);
til_Bool til_test_bool_arg(const til_Bool til_b);

// WRONG - own args passed by value:
til_I64 til_consume_i64(til_I64 til_n);
til_I64 til_consume_vec(til_Vec2 til_v);

// CORRECT - mut args passed by pointer:
til_I64 til_mixed_params(const til_I64 til_normal, til_I64* til_m, til_I64 til_o);

// CORRECT - copy args passed by value:
til_I64 til_test_copy_i64(til_I64 til_x);
til_Vec2 til_test_copy_struct(til_Vec2 til_v);
#+END_SRC

Expected signatures:
#+BEGIN_SRC c
// const args should be const pointers:
til_I64 til_test_i64_arg(const til_I64* til_n);
til_Bool til_test_bool_arg(const til_Bool* til_b);

// own args should be pointers:
til_I64 til_consume_i64(til_I64* til_n);
til_I64 til_consume_vec(til_Vec2* til_v);
#+END_SRC

*** Fix
Requires changes in several places in ccodegen.rs:

1. *emit_func_signature* - Change signature generation for const and own:
   - const: ~const til_Type* til_arg~
   - own: ~til_Type* til_arg~

2. *param_by_ref calculation* - Change from ~is_mut~ to ~!is_copy~:
   - Affects all places that calculate ~param_by_ref~ vector

3. *current_ref_params tracking* - Track all non-copy params:
   - Change from ~is_mut~ to ~!is_copy~ in function body setup

4. *hoist_for_ref_params* - Add hoisting for literals that can't use ~&~:
   - Similar pattern to existing ~hoist_for_dynamic_params~
   - Only TWO cases need hoisting:
     a) *I64 literals*: ~&69~ is invalid C (can't take address of rvalue)
        Must hoist to: ~til_I64 _tmp = 69; func(&_tmp);~
     b) *Type literals*: ~&"Str"~ gives ~char**~ but we need ~const char* const*~
        Must hoist to: ~til_Type _tmp = "Str"; func(&_tmp);~
   - Note: Type is a special type like Dynamic - see how Dynamic is handled

5. *emit_arg_with_param_type* - For identifiers that are ref params:
   - When ~param_by_ref~ is true and arg is already a pointer, just emit name
   - Don't call ~emit_expr~ which would dereference with ~(*name)~

6. *ext.c functions* - Update to accept pointers for const/own args:
   - All ext functions should use ~const til_Type*~ for const args
   - Example: ~til_add(const til_I64* a, const til_I64* b)~
   - This keeps everything consistent - no special-casing ext funcs

*** Literal Types - What CAN vs CANNOT use ~&~ prefix

*CAN use ~&~ directly (compound literals in C99+):*
- Str: ~&((til_Str){(til_I64)"hello", 5})~ - valid, compound literal is lvalue
- U8: ~&((til_U8){42})~ - valid, compound literal is lvalue
- Bool: ~&((til_Bool){1})~ - valid, compound literal is lvalue
- Any struct: ~&((til_MyStruct){...})~ - valid, compound literal is lvalue

*CANNOT use ~&~ - must hoist to temp var:*
- I64: ~&69~ - INVALID, plain integer is rvalue
- Type: ~&"Str"~ - gives wrong type (~char**~ instead of ~const char* const*~)

*** Solution
Implemented all the planned fixes:
1. Added ~param_needs_by_ref~ helper function to determine if param should be passed by pointer
2. Changed ~param_by_ref~ calculation from ~is_mut~ to ~param_needs_by_ref(arg)~
3. Added ~hoist_for_ref_params~ function to hoist I64 literals and function call results
4. Updated ~emit_func_signature~ to emit const pointers for const params
5. Updated ~emit_arg_with_param_type~ to handle by-ref params correctly
6. Updated ~ext.c~ functions to accept pointers for const/own args
7. Fixed hardcoded main args initialization to use compound literals for I64

Files modified:
- src/rs/ccodegen.rs, src/self/ccodegen.til
- src/rs/init.rs, src/self/init.til (added is_enum_constructor helpers)
- src/ext.c (updated function signatures)

*Performance Impact:*
Passing primitives (I64, Bool) by pointer adds overhead:
- til_interpreted tests: ~8.5s -> ~13.8s per test (~60% slower)
- Total til_interpreted: 338s -> 543s
This is expected since primitives were previously passed by value (fast) and now
require pointer indirection. The correctness fix was necessary to prevent stack
overflow on recursive functions with large struct arguments.

** Bug #61: Optional args before variadic don't use default when type mismatches
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Cannot have optional args before variadic with type-based defaulting
:STATUS: Fixed
:END:

*** Description
When a function has an optional argument (with default value) before a variadic
argument, and the caller omits the optional arg, the typer doesn't detect that
the provided arg type doesn't match and use the default.

*** Fix
Modified check_fcall in typer.rs to track definition arg index separately from
provided arg index. When type doesn't match and the param has a default value
and variadic follows, skip the optional param and continue matching.

Also modified precompute_fcall_args in precomp.rs to insert default values for
skipped optional args before variadic.

Files modified:
- src/rs/typer.rs - check_fcall with def_arg_idx tracking and skip logic
- src/rs/precomp.rs - reorder_named_args with optional-before-variadic handling
- src/self/typer.til - same changes
- src/self/precomp.til - same changes
- src/test/args.til - uncommented test_optional_before_variadic test

** Bug #62: U8 type annotations generate I64 in C codegen
:PROPERTIES:
:DISCOVERED: 2025-12-29
:FIXED: 2025-12-29
:IMPACT: Wrong type in generated C code, potential overflow/truncation bugs
:STATUS: Fixed
:END:

*** Description
When declaring a variable with explicit U8 type annotation, the C codegen
generates til_I64 instead of til_U8.

*** Root Cause
In ccodegen.rs emit_declaration, the code always called get_value_type() to
infer the type from the RHS expression, ignoring explicit type annotations.
Integer literals return I64 from get_value_type(), so U8 annotations were lost.

*** Fix
Check if decl.value_type is INFER_TYPE before inferring. If an explicit type
is provided, use it directly instead of inferring from RHS.

Files modified:
- src/rs/ccodegen.rs - emit_declaration, mut and const branches
- src/self/ccodegen.til - emit_declaration, mut and const branches

Test: src/test/literals.til

** Bug #58: Error messages show file path twice
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Confusing error messages
:STATUS: Fixed
:END:

*** Description
Error messages show the file path duplicated:
#+BEGIN_EXAMPLE
src/test/bug50.til:src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

Should show:
#+BEGIN_EXAMPLE
src/test/bug50.til:10:16: rstil type ERROR: ...
#+END_EXAMPLE

*** Root Cause
In interpreter.rs and builder.rs, errors were printed with ~println!("{}:{}", path, err)~
but ~err~ already contains the path from ~error()~ / ~todo_error()~ which format as
~"path:line:col: ..."~.

*** Fix
Removed the duplicate path prefix from error printing in:
- src/rs/interpreter.rs (lines 2889, 2917, 2949)
- src/rs/builder.rs (lines 158, 165, 189, 205, 214)
- src/self/interpreter.til (lines 3222, 3255, 3296)
- src/self/builder.til (5 locations)

** Bug #50: Codegen doesn't capture outer variables in nested functions
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-27
:IMPACT: Nested functions fail to compile when accessing outer scope variables
:STATUS: Fixed
:END:

*** Description
Nested functions (closures) in TIL can access variables from their enclosing scope.
This works correctly in the interpreter but fails during C code generation - the
outer variables are not captured/passed to the nested function.

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug50.til
#+END_SRC

*** Error Output
#+BEGIN_EXAMPLE
gen/c/test/bug50.c: In function 'til_test_closure_inner':
gen/c/test/bug50.c:1703:12: error: 'til_outer_var' undeclared (first use in this function)
#+END_EXAMPLE

*** Root Cause
In ccodegen, when emitting nested functions, variables from the outer scope (s1, s2,
silabes) are referenced but not passed as parameters or captured in a closure struct.

*** Potential Solutions

**** 1. Lambda Lifting (Recommended)
Transform nested functions into top-level functions, adding captured variables as
explicit parameters. The compiler would:
- Analyze which outer variables are referenced inside the nested function
- Add those as extra parameters to the lifted function
- At call sites, pass the captured variables explicitly

Pros: Simple, no runtime overhead, matches how TIL already handles explicit params
Cons: Recursive nested functions need care (captured vars passed through each call)

**** 2. Closure Struct
Create a struct containing all captured variables, pass pointer to nested function:
#+BEGIN_SRC c
struct poem_closure { Str s1; Str s2; };
Str poem(I64 depth, Str current, struct poem_closure* ctx) {
    // use ctx->s1, ctx->s2
}
#+END_SRC

Pros: Clean abstraction, single extra parameter regardless of capture count
Cons: Slightly more complex codegen, minor indirection overhead

**** 3. GCC Nested Functions Extension
GCC supports nested functions as a non-standard extension. We could use this directly.

Pros: Zero codegen changes for nested function bodies
Cons: GCC-only (not clang/MSVC), uses trampolines (executable stack), less portable

**** 4. Restrict Nested Function Captures (CHOSEN)
Disallow nested functions from capturing outer variables - require explicit parameters.
This is a language design change rather than a fix.

Pros: Simpler language semantics, no closure machinery needed
Cons: Breaking change, less ergonomic for users

*** Fix (2025-12-27)
Added =is_closure_capture()= function to ScopeStack (init.rs/init.til) that detects
when a symbol access would require closure capture. In typer (typer.rs/typer.til),
when an identifier is found to be a closure capture, emit a todo_error:
"Closures are not supported yet. Pass 'varname' as a parameter instead."

Full closure support deferred to post.org.

*** Files Modified
- src/rs/init.rs: Added =is_closure_capture()= to ScopeStack
- src/rs/typer.rs: Added closure capture check in NodeType::Identifier handling
- src/self/init.til: Ported =is_closure_capture()=
- src/self/typer.til: Ported closure capture check
- src/examples/lolalalo.til: Fixed to pass captured vars as explicit parameters
- src/test/bug50.til: Regression test (expected to fail with todo_error)

*** Historical: Lambda Lifting Attempt (2025-12-19, abandoned)
Before choosing option 4, started "Phase A: Const Args by Reference" in =wio= branch
as a prerequisite for lambda lifting. This is no longer needed since we chose to
forbid closures instead of implementing them.

Phase A completed items (for reference if lambda lifting is revisited):
- emit_func_signature: all non-copy params now const Type*
- by_ref calculations: changed from is_mut to !is_copy (7 locations)
- current_ref_params: now includes all non-copy params
- Variadic handling: fixed in emit_fcall_name_and_args_for_throwing and emit_fcall
- Compound literals: added for number/string literals

Phase A remaining issue:
- Nested struct-returning function calls passed to by-ref params need hoisting
- Current hoisting only works at statement level (indent > 0)

** Bug #47: Self-hosted TIL interpreter fails with "NodeType.?" error
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-27
:IMPACT: ./bin/til interpret fails on any file
:STATUS: Fixed
:END:

*** Description
The compiled self-hosted TIL interpreter (./bin/til) fails immediately when trying
to interpret any file, including empty.til. The error occurs during core library
initialization (vec.til:63).

*** Error Message
#+BEGIN_EXAMPLE
Error during file execution: src/core/core.til:src/core/vec.til:63:63: til init ERROR: Identifiers can only contain identifiers, found 'NodeType.?'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Analysis
The "NodeType.?" indicates an invalid enum tag value is being read from memory.
This happens in init.til's =get_value_type= function when iterating over
=e.params= (a Vec of Expr) - some Expr has a corrupted NodeType field.

*** Bug Type
CODEGEN BUG - rstil works, compiled til fails. Per methodology: "interpret works
but run fails" = codegen issue in ccodegen.rs

*** Investigation Notes
- rstil interpret works fine, only til (compiled self-hosted) fails
- The error is consistent - always at vec.til:63 during init
- Struct sizes match between TIL calculation and C sizeof for Expr (288 bytes)
- Invalid NodeType tag value found: 840973088 (0x32202E32) - looks like ASCII data

*** Key Discovery (2025-12-19)
Added =Expr.to_str()= and debug prints to =get_value_type= in init.til.

The expression =self.ptr= at vec.til:63 is processed 3 times:
#+BEGIN_EXAMPLE
1st call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
2nd call: e.params = [Expr{Identifier("ptr"), ...}]  <- correct
3rd call: e.params = [Expr{NodeType.?, ...}]         <- CORRUPTED
#+END_EXAMPLE

*Critical*: The corruption is visible in =e.to_str()= BEFORE iterating over params.
This means corruption happens BETWEEN calls to get_value_type, not during the
for-in loop or Vec.get. Something external is corrupting the Expr data.

*** What Was Ruled Out
- Bug #52 (static buffer in ext.c) - fixed, didn't solve this
- Bug #53 (missing null termination in str.til) - fixed, didn't solve this
- for-in vs while+Vec.get - both show same corruption

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug47.til  # PASS
./bin/til interpret src/test/bug47.til    # FAIL with NodeType.?
#+END_SRC

The test file (src/test/bug47.til) calls check_types directly without
using interpret_file, isolating the bug to the typer code path.

*** Notes
Bug #52 and #53 were discovered while investigating this issue. Both are now fixed
but did not resolve the NodeType memory corruption.

*** Narrowed Down Location (2025-12-19)
The corruption happens in =check_types_with_context= function in typer.til:
- Specifically in the =NodeType.Identifier(name)= case (lines 237-272)
- Around the =lookup_symbol= call (lines 259-265)

Call tracing showed:
- get_value_type calls #477 and #478 share the same =params.ptr=
- Call #477 sees valid data: =self.ptr line=63=
- Call #478 sees corrupted data: =? line=26726118198=
- Corruption happens BETWEEN these calls, during check_types_with_context

*** Debug Strategy
To find the exact line causing corruption:
1. Add debug print with =e.to_str()= after EVERY line in check_types_with_context
2. Run test once
3. Find where output changes from valid to corrupted

*** Minimal Reproducer (2025-12-26)
Found a minimal reproducer in =src/test/bug47.til=:

#+BEGIN_SRC til
mode test
import("self.builder")

run_it := proc(path: Str) throws Str, AllocError {
    mut args := Vec.new(Str)
    _ := run_file(path, args)
}

wrapper := proc() {
    run_it("src/examples/empty.til")
    catch (err: Str) { println(err) }  // Using 'err' triggers bug
    catch (err: AllocError) { }
}

wrapper()
#+END_SRC

Key finding: The bug only triggers when the caught error variable =err= is actually
USED inside the catch block (e.g., =println(err)=). An empty catch block or one that
doesn't reference =err= does NOT trigger the bug.

Reproduce:
#+BEGIN_SRC bash
./bin/rstil run src/test/bug47.til  # FAILS with NodeType.?
#+END_SRC

*** What Triggers vs What Doesn't
| Catch block code         | Result   |
|--------------------------+----------|
| catch (err: Str) { }     | Works    |
| catch (err: Str) { println("Error") } | Works |
| catch (err: Str) { println(err) }     | BUG    |

This suggests the bug is related to how the caught error variable is stored/accessed
in the generated C code when used inside the catch block body.

*** Fix (2025-12-27)
Removed 4 =id_params.delete()= calls in typer.til (lines 2657, 2694, 2699, 2704).

The issue was that =id_params= was a shallow clone of expression params, and
=extra_arg_e= (used in UFCS transformation) still referenced memory owned by
=id_params=. When =id_params.delete()= was called, it freed memory that
=extra_arg_e= was still using, causing memory corruption.

Note: ./bin/til still segfaults on other issues, but the NodeType.? error is fixed.
The test src/test/bug47.til now passes in rs_common (both interpret and run).

** Bug #56: Interpreter rejects FCall in enum payload inside func/proc
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Workaround required for clone calls in enum constructors
:STATUS: Fixed
:END:

*** Description
When constructing an enum with a payload that is a function call (FCall),
the interpreter rejected it with "Struct payload must be a variable identifier
or literal, got FCall". This only happened inside func/proc bodies - top level
declarations worked fine. Compiled mode also worked fine.

*** Root Cause
In interpreter.rs, the match statement handling struct payloads (for enum
variants) only handled Identifier and Literal node types, not FCall. Top-level
worked because it used a different code path.

*** Fix
Added a case for NodeType::FCall when the struct type is "Str". The fix creates
a temporary variable to hold the FCall result, then uses that variable name
as the payload. This mirrors what the existing Identifier and Literal handlers do.

Changes made:
- interpreter.rs: Added FCall case for Str payloads in enum variant construction
- interpreter.til: Ported fix to TIL self-hosted implementation
- Also fixed error message from "Struct payload" to "Enum variant payload"

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug56.til
# Output: All tests passed
#+END_SRC

** Bug #57: continue in for loops causes infinite loop
:PROPERTIES:
:DISCOVERED: 2025-12-27
:FIXED: 2025-12-27
:IMPACT: Must use while loops instead of for when continue is needed
:STATUS: Fixed
:END:

*** Description
The ~continue~ statement caused infinite loops when used in ~for~ loops.
This happened because ~for~ desugars to ~while~ with the loop variable increment
at the END of the body. ~continue~ skips the rest of the body including the
increment, causing the loop variable to never change.

*** Root Cause
The parser desugars ~for i in 0..N { body }~ to:
#+BEGIN_SRC til
mut i := 0
while lt(i, N) {
    body
    i.inc()  // increment at END
}
#+END_SRC

When ~continue~ is in the body, it jumps to the while condition check,
skipping ~i.inc()~.

*** Fix
Transform continue statements to include the step expression before the continue.
The transformation replaces ~continue~ with ~{ i.inc(); continue }~.

This ensures the loop variable is always incremented/decremented before jumping
to the condition check, regardless of whether continue was used.

Changes made:
- parser.rs: Added ~transform_continue_with_step~ helper, applied to range-based for loops
- precomp.rs: Same fix for collection-based for-in loops
- parser.til, precomp.til: Ported fixes to TIL self-hosted implementation

*** Test
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug57.til
# Output: Bug #57 test passed: continue in for loops works correctly
#+END_SRC

** Bug #55: C codegen generates wrong code for throwing function calls inside struct literals
:PROPERTIES:
:DISCOVERED: 2025-12-26
:FIXED: 2025-12-26
:IMPACT: C compile error, blocks removing legacy .new() methods
:STATUS: Fixed
:END:

*** Description
When a function that throws (uses out-parameter calling convention in C) is called
inside a struct literal field initializer, the C codegen generates incorrect code
with 1 argument instead of 3 (out-param + error-param + actual args).

*** Example
#+BEGIN_SRC til
Item := struct {
    mut name: Str = ""
    mut count: I64 = 0
}

test := proc() {
    original := "hello"
    // Bug: clone() inside struct literal generates wrong C code
    items.push(Item(name=original.clone(), count=42))
}
#+END_SRC

*** Generated C (incorrect)
#+BEGIN_SRC c
til_Item _tmp = (til_Item){.name = til_Str_clone(til_original), .count = 42};
// ERROR: til_Str_clone expects 3 args: (til_Str* _ret, til_AllocError* _err, til_Str self)
#+END_SRC

*** Expected C (correct)
#+BEGIN_SRC c
til_Str _cloned_name;
til_AllocError _err;
if (til_Str_clone(&_cloned_name, &_err, til_original)) { /* handle error */ }
til_Item _tmp = (til_Item){.name = _cloned_name, .count = 42};
#+END_SRC

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/test/bug55.til
# Previously: ERROR: gcc failed: too few arguments to function 'til_Str_clone'
# Now: passes
#+END_SRC

*** Root Cause
In ~hoist_throwing_args~, non-FCall arguments (like NamedArg nodes inside struct
literals) were not being processed. When ~items.push(Item(name=original.clone()))~
was passed, the struct literal's arguments are NamedArg nodes, and these fell
through the if/else-if chain without being processed, so the throwing call inside
the NamedArg never got hoisted.

*** Fix
Added an else clause at the end of ~hoist_throwing_args~ to call ~hoist_throwing_expr~
for non-FCall arguments. This ensures throwing calls inside named args (and other
non-FCall expression types) are properly hoisted.

Files changed:
- src/rs/ccodegen.rs: Added else clause in hoist_throwing_args
- src/self/ccodegen.til: Same fix ported
- src/test/bug55.til: Test case added to rs_common

** Bug #42: Temp variable naming inconsistency causes undeclared _tmp_N errors
:PROPERTIES:
:DISCOVERED: 2025-12-17
:FIXED: 2025-12-26
:IMPACT: Compilation fails
:STATUS: Fixed
:END:

*** Description
After commit 5707c2d (Make _for_i_ variable names deterministic), some code paths generate temp variables with old-style names (_tmp_N) while others use new-style names (_tmp_funcname_N). This causes gcc errors for undeclared variables.

#+BEGIN_EXAMPLE
gcc error: '_tmp_13' undeclared (first use in this function)
In til_Vec_clone:
til_Vec til_cloned = {..., .ptr = _tmp_13, ...};
#+END_EXAMPLE

*** Root Cause
~emit_struct_func_body~ (ccodegen.rs:2527-2597) did NOT set ~current_function_name~
before emitting the function body, while regular functions did. This caused struct
methods like ~Array.new~, ~Array.get~, ~Vec.clone~ to generate temp names like
~_tmp_0~ instead of ~_tmp_Array_new_0~.

*** The Fix
Added save/set/restore pattern for ~current_function_name~ and ~mangling_counter~
in ~emit_struct_func_body~, matching the pattern used for regular functions.

Also fixed TIL's ~next_mangled~ to include function name prefix (was missing entirely).

*** Files Modified
- src/rs/ccodegen.rs: Added current_function_name handling to emit_struct_func_body
- src/self/ccodegen.til: Same fix + updated next_mangled to include function prefix

** Bug #54: Pure functions that throw are not folded at compile time
:PROPERTIES:
:DISCOVERED: 2025-12-20
:FIXED: 2025-12-26
:IMPACT: Missed compile-time error detection, deferred to runtime
:STATUS: Fixed
:END:

*** Description
Pure functions with ~throws~ in their signature are not evaluated at compile
time, even when called with literal arguments. This prevents catching errors
at compile time that could be detected during precomputation.

*** Example
#+BEGIN_SRC til
always_throws := func(n: I64) returns I64 throws Str {
    if gt(n, 0) {
        throw "intentional error"
    }
    return 0
}
x := always_throws(5)  // Should fail at compile time, but runs at runtime
#+END_SRC

*** Reproducing
See ~src/test/precomp_throw.til~ - the test is expected to fail at precomp time
but currently reaches runtime instead.

*** Root Cause
In commit 9a79e93c (Dec 11, 2025), a check was added to ~is_comptime_evaluable~
that blocks folding for any function with throw_types:

#+BEGIN_SRC rust
// src/rs/precomp.rs lines 265-269
if !func_def.throw_types.is_empty() {
    return false;
}
#+END_SRC

Before this change, the comment said: "Functions that can throw are allowed -
if they actually throw, we'll report the error in eval_comptime"

The ~eval_comptime~ function already has infrastructure to handle thrown
exceptions (lines 291-296) and report them as precomp errors.

*** Solution
Removed the blanket throw_types check. Now only functions throwing ~AllocError~,
~IndexOutOfBoundsError~, or ~KeyNotFoundError~ are excluded (these depend on runtime state).
Other throwing functions are evaluated at compile time, and if they throw, the exception
is caught by ~eval_comptime~ and reported as a compile-time error.

*** Fix Details
Part of the precomp overhaul (see doc/todo/precomp_overhaul.org):
- Modified ~is_comptime_evaluable~ to only exclude specific runtime-dependent error types
- Added is_proc() check and return_types.is_empty() check
- Added U8 support in ~eval_comptime~
- Many other structural improvements to make precomp work like interpreter

** Bug #48: Typer missing validation that mut arguments must be lvalues
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: No clear error message when passing literals to mut params
:STATUS: Fixed
:END:

*** Description
The typer phase is missing a validation check: arguments to =mut= parameters
must be lvalues (identifiers or field access). This affects both interpreter
and compiler paths - both should catch this in the typer phase.

*** Example
#+BEGIN_SRC til
test_mut := proc(mut n: I64) {
    n = 99
}
test_mut(42)  // Should be rejected by typer
#+END_SRC

*** Fix Applied (2025-12-18, commit ae0b5eb)
Added =NodeType::LLiteral= case in =check_fcall= to reject literals passed to
mut parameters. Error message: "Cannot pass literal to mut parameter 'X'. Use
a variable instead."

*** Files Modified
- src/rs/typer.rs: Added LLiteral case in is_mut check
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug48.til with expected_status=1

*** Regression Test
src/test/bug48.til (expects exit code 1 - type error)

** Bug #49: Typer missing use-after-move check for own parameters
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-20
:IMPACT: Compiled code allows use of moved variable
:STATUS: Fixed
:END:

*** Description
When a variable is passed to an =own= parameter, the variable should be
invalidated in the caller's scope. The interpreter catches this at eval time,
but the typer doesn't track it - so compiled code allows using the variable.

*** Example
#+BEGIN_SRC til
consume := proc(own n: I64) returns I64 {
    return mul(n, 2)
}

test := proc() {
    mut x := 42
    result := consume(x)
    println(I64.to_str(x))  // Should be rejected - x was moved
}
#+END_SRC

*** Expected Behavior
Typer should reject use of =x= after it was passed to =own= parameter:
"Variable 'x' was moved and can no longer be used"

*** Actual Behavior
- Typer: No tracking of moved variables (the bug)
- Interpreter: Catches at eval - "Undefined symbol 'x'" (wrong phase)
- Compiler: No catch at all - x still usable with original value

*** Fix Applied (2025-12-20)
In typer's =check_fcall= function, after all type checking for an argument is complete,
if the parameter has =is_own= and the argument is a simple identifier, remove the
symbol from scope using =context.scope_stack.remove_symbol()=.

Key insight: The removal must happen AFTER =get_value_type= is called on the argument,
not before - otherwise the type lookup fails for the current argument.

*** Files Modified
- src/rs/typer.rs: Added remove_symbol call at end of argument loop in check_fcall
- src/self/typer.til: Same fix ported
- src/tests.til: Added bug49.til with expected_status=1

*** Regression Test
src/test/bug49.til (expects exit code 1 - type error)

*** Related
- Bug #48: Similar issue for =mut= parameters (lvalue check)
- See doc/ownership.org for full ownership design

** Bug #34: Code after catch blocks doesn't run in error path
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

*** Description
Code placed AFTER catch blocks doesn't run when an error is caught.

*** Example
#+BEGIN_EXAMPLE til
throwing_call()
between = true      // Between throw and catch - correctly skipped on error
catch (err: Error) {
    // error caught
}
code_after_catch()  // Now runs correctly in both success and error paths
#+END_EXAMPLE

*** Root Cause
In the C code generator, statements after the last catch block were emitted BEFORE
the ~goto _end_catches~ jump, so they only ran on the success path.

*** Complete Fix (2025-12-15, commit 9781c41)
The initial partial fix used emit_expr directly for statements after the last
catch block. However, emit_expr doesn't do throwing call detection, causing
throwing functions like Vec.push to be emitted without error parameters.

The complete fix:
1. Find the index of the last catch block in emit_stmts
2. Only emit statements up to and including the last catch in the main loop
3. After emitting _end_catches label, call emit_stmts recursively for remaining
   statements - this properly handles throwing calls with error detection and
   goto labels

*** Files Modified
- src/rs/ccodegen.rs: emit_stmts recursive call for statements after last catch
- src/self/ccodegen.til: Same fix ported
- src/test/errors.til: Regression test (test_bug34)

** Bug #46: Infinite loop in typer.til due to catch catching later throw
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: til interpret/run hangs indefinitely
:STATUS: Fixed
:END:

*** Description
When running =./bin/til interpret= or =./bin/til run=, the self-hosted compiler hangs
in an infinite loop. Debug output shows "struct_found=true" printing infinitely in
typer.til's struct/enum lookup code.

*** Root Cause
In typer.til around lines 2500-2520, a catch block catches a throw that comes AFTER it
lexically, creating an infinite loop:

#+BEGIN_EXAMPLE til
// typer.til lines ~2500-2520 (approximate)
struct_def = context.scope_stack.lookup_struct(combined_name)
struct_found = true
catch (err: KeyNotFoundError) {  // Line ~2508 - catches lookup_struct errors
    // Struct not found, continue to enum check
}

if struct_found {
    // Line ~2515 - THIS throw gets caught by the catch at line ~2508!
    throw KeyNotFoundError(msg=format("Struct instantiation: ", combined_name))
}
#+END_EXAMPLE

The flow:
1. lookup_struct throws KeyNotFoundError
2. Catch at ~2508 handles it, struct_found remains false
3. Code continues, struct_found is set true later
4. Throw at ~2515 is caught by the catch at ~2508 (wrong!)
5. Execution continues after catch, loops back, struct_found=true prints
6. Infinite loop

*** Expected Behavior
The throw at line ~2515 should propagate UP to the caller, not be caught by
the catch at ~2508 which is meant only for lookup_struct errors.

*** Actual Behavior
The catch block's scope extends beyond just the lookup_struct call, incorrectly
catching throws that come after it in the source code.

*** Reproducing Test
src/test/bug46.til - Passes with interpreter, fails with compiler:
#+BEGIN_SRC bash
./bin/rstil interpret src/test/bug46.til  # PASS
./bin/rstil run src/test/bug46.til        # FAIL - Bug #46 present
#+END_SRC

Self-hosted compiler hangs:
#+BEGIN_SRC bash
timeout 30 ./bin/rstil build src/til.til && timeout 10 ./bin/til interpret src/examples/empty.til
# Times out (exit code 124)
#+END_SRC

*** Related
- Bug #34: Code after catch blocks doesn't run in error path (partially fixed)
- Bug #39: Non-consecutive catches fail (fixed)
- Bug #44: Codegen missing status check after blocks with catches (fixed)

All these bugs relate to catch block scope/semantics in generated C code.

*** Fix Applied (2025-12-18)
The issue was in ccodegen's emit_stmts function. When processing catch blocks,
they were added to =local_catch_labels= at the START of statement processing.
This meant ALL throws anywhere in the function could jump to ANY catch, even
catches that appeared BEFORE the throw lexically.

The fix: After emitting a catch block, remove it from =local_catch_labels=.
This ensures only throws that come BEFORE a catch can use it, mirroring the
interpreter's behavior where =pending_throw= is set by statements and only
subsequent catches can handle it.

*Rust* (src/rs/ccodegen.rs lines 3149-3153):
#+BEGIN_SRC rust
// Bug #46 fix: Remove this catch from local_catch_labels
// Catches should only handle throws from BEFORE them, not after.
ctx.local_catch_labels.remove(err_type_name);
#+END_SRC

*TIL* (src/self/ccodegen.til lines 4551-4555):
#+BEGIN_SRC til
// Bug #46 fix: Remove this catch from local_catch_labels
ctx.local_catch_labels.remove(err_type_name)
#+END_SRC

*** Files Modified
- src/rs/ccodegen.rs: Added removal of catch from local_catch_labels after processing
- src/self/ccodegen.til: Same fix ported

** Bug #45: init.til uses invalid fallthrough switch syntax
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Functions not registered - til fails with "Undefined symbol 'sub'"
:STATUS: Fixed
:END:

*** Description
init.til incorrectly uses C-style switch fallthrough syntax, which TIL does not support.
TIL requires each case to have its own body - there is no fallthrough.

This causes functions (FTFunc, FTProc, etc.) to not be registered in init_context, since
only the FTMacro case has the declare_func call.

*** Wrong TIL Source (init.til lines 1466-1474)
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
case FunctionType.FTFuncExt:
case FunctionType.FTProc:
case FunctionType.FTProcExt:
case FunctionType.FTMacro:
    // WRONG: only FTMacro case has the body!
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Correct TIL (bodies must be repeated)
Per doc/translate_rs2til.org lines 39-50, TIL requires separate case arms:
#+BEGIN_EXAMPLE til
switch ftype {
case FunctionType.FTFunc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTFuncExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProc:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTProcExt:
    context.scope_stack.declare_func(decl.name, func_def)
case FunctionType.FTMacro:
    context.scope_stack.declare_func(decl.name, func_def)
}
#+END_EXAMPLE

*** Root Cause
Translation error from Rust to TIL. Rust uses | to combine patterns, TIL requires
repeated bodies. See doc/translate_rs2til.org for the translation rules.

*** Fix Applied (2025-12-18)
Fixed init.til lines 1465-1511 to repeat the switch body for each FunctionType case:
- FTFunc, FTFuncExt, FTProc, FTProcExt, FTMacro all now have identical bodies
- Each case calls declare_symbol and declare_func

Searched all other .til files in src/self/ for similar patterns - none found.
Other consecutive case patterns are either:
1. Cases with bodies on same line (e.g., `case X: return "x"`)
2. Intentional "do nothing" cases with comments (e.g., skip primitives I64/U8/Str)

** Bug #44: Codegen missing status check for throwing call after block with catches
:PROPERTIES:
:DISCOVERED: 2025-12-18
:IMPACT: Wrong code execution - statements after throwing call run when they shouldn't
:STATUS: Fixed
:END:

*** Description
When a throwing function call is followed by catch, but there's a preceding block
(if/switch) that also contains catches, the status check for the later throwing call
is sometimes missing from the generated C code.

This causes the "func 'Bool' returns multiple values" error when til processes
bool.til, because get_fcall_value_type incorrectly finds Bool as a function (due
to lookup_func not properly short-circuiting on KeyNotFoundError).

*** Example Problem
#+BEGIN_EXAMPLE til
test_func := func() returns I64 throws Str {
    // Block with catches
    if true {
        mut val := maybe_throw_A(false)
        catch (err: ErrorA) { }
    }

    // After the block - status check is MISSING for this call!
    mut found := false
    mut result := maybe_throw_C(true)  // This throws
    found = true  // BUG: This runs even though C threw!
    catch (err: ErrorC) { }

    if found { throw "found should be false!" }
    return 0
}
#+END_EXAMPLE

*** Generated C Code (broken)
The call at line 10488 in til.c is missing the status check:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
// MISSING: if (_status_... == 1) { goto _catch_...; }
til_standalone_func_def = _ret_...;
til_found_standalone = true;  // Runs unconditionally!
if (0) { _catch_KeyNotFoundError_...: ... }
#+END_EXAMPLE

Compare with line 24060 which is correct:
#+BEGIN_EXAMPLE c
int _status_... = til_ScopeStack_lookup_func(...);
if (_status_... == 1) { _thrown_... = _err0_...; goto _catch_...; }  // Correct!
til_func_def = _ret_...;
#+END_EXAMPLE

*** Root Cause (Likely)
In ccodegen.rs, the `local_catch_labels` map is being cleared/repopulated
incorrectly when processing blocks with catches, causing the catch for the
later throwing call to not be registered when the call is processed.

The bug affects get_fcall_value_type in init.til (line 651) but NOT
is_expr_calling_procs in typer.til (same pattern, but generates correctly).

*** Reproducing Test
src/test/bug44.til

*** Files to Investigate
- src/rs/ccodegen.rs: emit_stmts, local_catch_labels handling
- Specifically the logic at lines 3215-3233 where next_catches is built
- Compare what's different about init.til vs typer.til that causes only one to fail

** Bug #43: Map.get returns wrong value when Map is field inside struct (rstil interpreter)
:PROPERTIES:
:DISCOVERED: 2025-12-18
:FIXED: 2025-12-18
:IMPACT: Data corruption in interpreter
:STATUS: Fixed
:END:

*** Description
When a Map is stored as a field inside a struct, the rstil interpreter's Map.get returns incorrect values (0 instead of actual stored value). The compiled version (rstil run) works correctly.

*** Example Problem
#+BEGIN_EXAMPLE til
import("std.map")

Frame := struct {
    mut funcs: Map = Map.new(Str, I64)
}

test_map_in_struct := proc() {
    mut frame := Frame()
    frame.funcs.insert("test", 42)

    mut val := 0
    frame.funcs.get("test", val)
    println("Got value = ", val.to_str())  // BUG: prints 0, should print 42
}
#+END_EXAMPLE

*** Test Results (Before Fix)
- =rstil interpret tmp/test_scope_pattern.til= -> val = 0 (WRONG)
- =rstil run tmp/test_scope_pattern.til= -> val = 42 (CORRECT)

*** Root Cause
Three issues were discovered when structs have nested struct defaults like =Map.new(Str, I64)=:

1. *Vec.ptr not initialized*: When struct templates were created, ptr fields were
   skipped (to avoid dangling pointers), but Vec.push didn't check for ptr=0.
   This caused pushes to write to NULL memory when Vec was part of a struct default.

2. *Str fields not copied*: read_struct_primitive_fields only read I64/U8 values.
   Str fields like =key_type_name= weren't being read from the evaluated instance,
   causing Map to have empty type names and fail key comparisons.

3. *Vec.cap not preserved*: The Vec's capacity from Vec.new was lost because nested
   struct fields weren't being recursively read. This caused malloc(0) in Vec.push.

*** Fix Applied (2025-12-18)

*Part 1: Vec.push null pointer check* (src/core/vec.til lines 60-71)
Added check at start of push to allocate if ptr=0:
#+BEGIN_SRC til
if self.ptr.eq(0) {
    if self.cap.eq(0) {
        self.cap = Vec.INIT_CAP
    }
    self.ptr = malloc(mul(self.cap, self.type_size))
    if NULL.eq(self.ptr) {
        throw AllocError(msg=format(loc(), "Vec.push: malloc failed"))
    }
}
#+END_SRC

*Part 2: read_struct_primitive_fields* (src/rs/interpreter.rs lines 214-279)
New function that reads primitive values from evaluated struct instances:
- Reads I64 values (skipping ptr/c_string to avoid dangling pointers)
- Reads U8 values
- Reads Str values using string_from_context (gets actual string content)
- Recursively reads nested struct primitive fields (Vec, etc.)

*Part 3: eval_struct_defaults* (src/rs/interpreter.rs lines 303-319)
After getting static defaults for nested structs, override with actual primitive
values from the evaluated instance:
#+BEGIN_SRC rust
let primitive_values = read_struct_primitive_fields(ctx, &instance_id, type_name, "", e)?;
for (k, v) in primitive_values {
    defaults.insert(format!("{}.{}", decl.name, k), v);
}
#+END_SRC

*Part 4: TIL port* (src/self/interpreter.til lines 138-219, 304-316)
Same changes ported to the self-hosted interpreter.

*** Reproducing Test
src/test/bug43.til (now passes both interpret and run)

*** Files Modified
- src/rs/interpreter.rs: Added read_struct_primitive_fields, modified eval_struct_defaults
- src/rs/eval_arena.rs: Minor cleanup
- src/core/vec.til: Added null pointer check in Vec.push
- src/self/interpreter.til: Ported fix to TIL version

** Bug #40: Precomp generates non-deterministic _for_i_ variable names
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Build reproducibility
:STATUS: Fixed
:END:

*** Description
The precomp phase generates `_for_i_N` variable names for desugared for-in loops using a global counter (`Arena::g().temp_id_counter`). This counter accumulates across file compilations, causing the same source code to produce different C output depending on compilation order or what was compiled before.

#+BEGIN_EXAMPLE
// First compilation produces:
til_I64 _for_i_159 = 0;

// Second compilation (same source) produces:
til_I64 _for_i_160 = 0;
#+END_EXAMPLE

This makes diffs between generated C files noisy and harder to review.

*** Root Cause
In precomp.rs (line 422-424), the `_for_i_` index variable name is generated using a global singleton counter:

#+BEGIN_SRC rust
let forin_id = Arena::g().temp_id_counter;
Arena::g().temp_id_counter += 1;
let index_var_name = format!("_for_i_{}", forin_id);
#+END_SRC

Unlike ccodegen's `next_mangled()` which was fixed to reset per-function and include function name prefix, precomp still uses this global counter.

*** Related
- ccodegen's `_tmp_` variables were fixed to be deterministic (counter moved to CodegenContext, reset per-function, includes function name prefix)
- interpreter.rs also uses `Arena::g().temp_id_counter` for return instance names

*** Proposed Fix
Apply similar pattern as ccodegen fix:
1. Add function name context to precomp (track current function being processed)
2. Reset counter when entering each function in `precomp_func_def`
3. Include function name in generated variable name: `_for_i_funcname_N`

*** Files to Modify
- src/rs/precomp.rs: Add counter reset in precomp_func_def, modify index_var_name format
- src/self/precomp.til: Same changes ported

*** Fix Details
Added two new fields to Context:
- `current_precomp_func`: Tracks the current function being processed (Option<String> in Rust, Str in TIL)
- `precomp_forin_counter`: Per-function counter for _for_i_ variable names

Modified three functions:
1. `precomp_declaration`: Sets function name and resets counter BEFORE processing function body
2. `precomp_struct_def`: Sets function name for struct method definitions (default values)
3. `precomp_forin`: Uses context fields instead of global counter, generates names like `_for_i_funcname_N`

Files modified:
- src/rs/init.rs: Added fields to Context struct
- src/rs/precomp.rs: Bug #40 fix in precomp_declaration, precomp_struct_def, precomp_forin
- src/self/init.til: Added fields to Context struct
- src/self/precomp.til: Same fixes ported

Test: src/test/deterministic.til

** Bug #52: Static buffer in ext.c til_i64_to_str caused string corruption
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Multiple to_str() calls before println showed wrong values
:STATUS: Fixed
:END:

*** Description
When multiple =to_str()= calls happened before =println= (e.g., printing two numbers),
they all showed the same value - the last one converted. This was because all calls
shared the same static buffer.

*** Root Cause
The =til_i64_to_str= function in =src/ext.c= used a static buffer:
#+BEGIN_SRC c
static char buf[32];  // SHARED BY ALL CALLS!
snprintf(buf, sizeof(buf), "%lld", (long long)v);
#+END_SRC

Each =to_str()= call returned a Str pointing to this same buffer. When a second
call happened, it overwrote the buffer, making both Strs show the second value.

*** Fix
Changed =til_i64_to_str=, =til_input_read_line=, and =til_run_cmd= in =src/ext.c=
to allocate memory with =malloc()= instead of using static buffers.

*** Regression Test
src/test/bug52.til - tests reading global variables inside for-in loops
with multiple =to_str()= calls to detect buffer sharing issues.

*** Notes
Discovered while investigating Bug #47 (NodeType corruption). The static buffer
issue explained why debug output showed wrong values, but Bug #47 itself is a
different issue that remains open.

** Bug #53: String functions missing null termination
:PROPERTIES:
:DISCOVERED: 2025-12-19
:FIXED: 2025-12-19
:IMPACT: Garbage characters in string output, potential memory corruption
:STATUS: Fixed
:END:

*** Description
String functions =clone()=, =concat()=, =format()=, and =replace()= in str.til
allocated memory without +1 for the null terminator and didn't write the null
byte. This caused garbage characters when strings were printed via C's printf.

*** Root Cause
All four functions used =malloc(cap)= instead of =malloc(cap.add(1))= and didn't
call =memset= to write the null terminator at position =cap=.

*** Fix Applied (2025-12-19)
Changed all four functions in src/core/str.til:
- =clone()=: malloc(cap.add(1)), memset null at cap
- =concat()=: malloc(cap.add(1)), memset null at cap
- =format()=: malloc(cap.add(1)), memset null at cap
- =replace()=: malloc(new_len.add(1)), memset null at cap

*** Regression Test
No regression test was created because the bug cannot be reliably reproduced in
a unit test. The issue only manifests when malloc returns memory with non-zero
bytes at position =cap= (outside the allocated region without the fix). Modern
allocators typically return zeroed memory, making the bug appear to not exist
even without the fix.

The bug was discovered during Bug #47 investigation when "NodeType.?" garbage
appeared in debug output. This occurred because the heap was heavily fragmented
during ./bin/til execution, causing non-zero bytes to appear at string boundaries.

*** Files Modified
- src/core/str.til: Fixed clone, concat, format, replace functions

** Bug #41: mode liba not respected when file is imported
:PROPERTIES:
:DISCOVERED: 2025-12-16
:FIXED: 2025-12-17
:IMPACT: Debugging, purity rules
:STATUS: Fixed
:END:

*** Description
When a file with `mode liba` is imported into another file (e.g., `mode cli`), the purity rules of the importing file apply instead of the imported file's mode. This means `func` definitions in `mode liba` files cannot call `print`/`println` when imported, even though `mode liba` is supposed to allow print in funcs for debugging.

*** Root Cause
The typer phase's `typer_import_declarations` function only saved and restored `context.path` when type-checking imported files, but did not save and restore `context.mode_def`. This caused the importing file's mode to be used for type checking the imported file.

*** Fix Applied (2025-12-17)
Two-part fix:

1. *Store mode during init phase* (src/rs/init.rs, src/self/init.til):
   - Added `imported_modes: HashMap<String, ModeDef>` to Context struct
   - In `init_import_declarations`, store the imported file's mode alongside its AST

2. *Use stored mode during type checking* (src/rs/typer.rs, src/self/typer.til):
   - In `typer_import_declarations`, retrieve stored mode and set `context.mode_def`
   - Save and restore both `context.path` AND `context.mode_def`

Also added `ModeDef.clone()` method to src/self/mode.til for proper mode copying.

*** Test Coverage
Regression test: src/test/bug41.til

*** Files Modified
- src/rs/init.rs: Added imported_modes field, store mode during import
- src/rs/typer.rs: Save/restore mode_def in typer_import_declarations
- src/self/init.til: Same changes ported
- src/self/typer.til: Same changes ported
- src/self/mode.til: Added ModeDef.clone() method
- src/test/bug41.til: Regression test
- src/test/bug41_liba_helper.til: Helper file for test

** Bug #39: Non-consecutive catches fail - second catch never executes
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-16
:IMPACT: Error handling semantics
:STATUS: Fixed
:END:

Related: Bug #34 (same underlying goto structure issue)

*** Description
When a function has multiple throw+catch pairs separated by code, only the first catch works. The second catch block never executes because the code generator's goto structure jumps past subsequent throw+catch pairs after the first catch completes.

#+BEGIN_EXAMPLE til
throw_a_maybe(true)  // throws ErrorA
after_a_ran = true   // correctly skipped
catch (err: ErrorA) { caught_a = true }

throw_b_maybe(true)  // throws ErrorB - NEVER EXECUTES!
after_b_ran = true
catch (err: ErrorB) { caught_b = true }  // NEVER EXECUTES!
#+END_EXAMPLE

*** Root Cause
The C code generator groups ALL catches at the end with shared labels:

#+BEGIN_SRC c
if (_status_A == 1) { goto _catch_A; }
if (_status_B == 1) { goto _catch_B; }
goto _end_catches;

_catch_A: { ... goto _end_catches; }  // BUG: jumps PAST throw_b_maybe!
_catch_B: { ... }
_end_catches:;
#+END_SRC

After catching ErrorA, ~goto _end_catches~ jumps past the second throw+catch entirely. The second throwing call never executes.

*** Proposed Fix
Instead of shared goto labels, use if-else blocks for each throw+catch pair:

#+BEGIN_SRC c
// First throw+catch
int _status_A = call_a();
if (_status_A == 0) {
    after_a_ran = true;
} else if (_status_A == 1) {
    // catch A body
}

// Second throw+catch - executes regardless of first catch
int _status_B = call_b();
if (_status_B == 0) {
    after_b_ran = true;
} else if (_status_B == 1) {
    // catch B body
}
#+END_SRC

*** Files to Modify
- src/rs/ccodegen.rs: emit_stmts, emit_throwing_call_with_goto
- src/self/ccodegen.til: Same changes ported

*** Test Coverage
Tests added in src/test/errors.til:
- test_non_consecutive_catches
- test_caller_callee_different_throws
- test_multi_throw_single_catch
- test_multi_throw_success

*** Fix Applied
Key changes to ccodegen.rs and ccodegen.til:

1. **Call ~next_mangled()~ inside the loop, not before** - Previously called once
   before the loop, giving all catches the same suffix. Now called for EACH catch,
   so multiple catches of the same error type get different labels.

2. **Store statement index with each catch** - ~all_catch_info~ tracks
   ~(stmt_index, type_name, label, temp_var, catch_block)~ to match throwing
   calls to their NEXT catch by position in the source.

3. **Emit catches inline with ~if(0) { label: }~** - Instead of grouping all
   catches at the end with ~goto _end_catches~, catches are emitted inline where
   they appear. The ~if(0)~ block is skipped in normal execution but ~goto~ can
   jump into it. Execution falls through after the catch body.

4. **Update ~local_catch_labels~ before each throwing call** - Clear and rebuild
   with only catches AFTER current statement position. Each throwing call now
   jumps to its correct NEXT catch, not always the first one.

5. **Only use immediate-catch optimization when ~func_level_catches.is_empty()~** -
   Prevents inline handling when the catch is also needed by earlier throwing calls
   (which need the label to be emitted).

Also added ~Map.clear()~ method to src/std/map.til, and removed unused
~get_variant_payload_type~ function from init.rs.

** Bug #38: Vec.get doesn't preserve enum payload values
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When storing enums with payloads in a Vec and retrieving them with Vec.get, the enum tag is preserved but the payload value is corrupted.

#+BEGIN_EXAMPLE til
PayloadEnum := enum {
    None,
    Number: I64,
    Text: Str,
}

p := PayloadEnum.Number(42)
mut items := Vec.new(PayloadEnum)
items.push(p)

mut out := PayloadEnum.None
items.get(0, out)

// Expected: out is PayloadEnum.Number(42)
// Actual: out is PayloadEnum.Number(2745) - payload corrupted
#+END_EXAMPLE

*** Root Cause
When passing an enum constructor like `PayloadEnum.None` to a Dynamic parameter (as in Vec.push),
the argument binding code incorrectly identified `PayloadEnum` as a type identifier (because TEnumDef
is a TType) and stored just the type name string instead of the actual enum value. This caused the
enum data to not be inserted into the function frame, resulting in memcpy reading from garbage memory.

The issue was in interpreter.rs at the Dynamic/Type parameter handling: the code checked if the
identifier resolved to a TType but didn't check if the expression had params (field access).
`PayloadEnum.None` has params (the `.None` access), so it should NOT be treated as a bare type.

*** Fix
Added a check for `current_arg.params.is_empty()` before treating an identifier as a type identifier.
This ensures enum constructors like `PayloadEnum.None` fall through to normal enum handling.

Files changed:
- src/rs/interpreter.rs: Added params.is_empty() check in Dynamic/Type handling
- src/self/interpreter.til: Same fix ported to self-hosted version

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_payload() (enabled)

** Bug #37: Vec.push with direct enum constructor doesn't store data correctly :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Data corruption
:STATUS: Fixed
:END:

*** Description
When pushing an enum value directly using a constructor expression (e.g., `colors.push(SimpleColor.Red)`), the data is not stored correctly in the Vec. However, pushing via a variable works correctly.

#+BEGIN_EXAMPLE til
SimpleColor := enum { Red, Green, Blue }

mut colors := Vec.new(SimpleColor)

// This FAILS - data is corrupted:
colors.push(SimpleColor.Red)

// This WORKS:
c := SimpleColor.Red
colors.push(c)
#+END_EXAMPLE

*** Root Cause (Found)
The bug was in the interpreter's handling of Dynamic parameters. When an enum constructor expression like `SimpleColor.Green` was passed to a Dynamic parameter:

1. The parser creates an Identifier("SimpleColor") node with params [Identifier("Green")]
2. The interpreter checked if "SimpleColor" was a type reference (TType)
3. Since SimpleColor is an enum type definition, it matched as TType
4. The code incorrectly treated it as a bare type reference, storing "SimpleColor" as a string
5. This caused to_ptr(value) to return the wrong arena offset

*** Fix (2025-12-15)
Added check for `current_arg.params.is_empty()` before treating an identifier as a type reference:

*interpreter.rs (line 1938):*
#+BEGIN_SRC rust
if current_arg.params.is_empty() {
    if let Some(sym) = context.scope_stack.lookup_symbol(id_name) {
        if let ValueType::TType(_) = &sym.value_type {
            // Only treat as type reference if params are empty
        }
    }
}
#+END_SRC

*interpreter.til (line 2022):*
#+BEGIN_SRC til
if current_arg.params.len().eq(0) {
    // Only treat as type reference if params are empty
}
#+END_SRC

Workarounds in std/map.til were also removed - now uses Vec.push() directly.

*** Test Coverage
Regression test in src/test/vecs.til: test_vec_enum_direct_push() (enabled)

** Bug #35: Special `_` variable does not allow repeated declarations :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
The special `_` variable (used for discarding return values) throws "already declared" errors when used multiple times in the same scope.

#+BEGIN_EXAMPLE til
// This should work (both values are discarded):
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)  // ERROR: '_' already declared
#+END_EXAMPLE

*** Fix (2025-12-14)
Modified type checker and code generator to special-case "_" declarations:

*Type checker (init.rs, init.til):*
1. In =declare_var()=: Skip the "already declared in this scope" check when name is "_"
2. In =init_context()= Declaration handler: Skip the "already declared" check when name is "_"

*Code generator (ccodegen.rs, ccodegen.til):*
1. In =emit_constant_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
2. In =emit_global_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
3. In =emit_declaration()=: Use =next_mangled()= to generate unique names for "_" declarations
4. In =emit_variadic_call()=: Skip variable declaration entirely for "_", just emit the function call (2026-01-04)

This approach:
- Allows multiple "_" declarations in the same TIL scope
- Generates unique C variable names (like =_tmp0=, =_tmp1=) to avoid C redefinition errors
- Evaluates the RHS expression for its side effects (return value is discarded)

*** Now Works
#+BEGIN_EXAMPLE til
// Both values are discarded - no error
_ := context.imports_init_done.insert(path)
_ := context.imports_typer_done.insert(path)
#+END_EXAMPLE

*** Test Coverage
- src/test/underscore.til: Tests multiple "_" declarations at both top-level and function scope, including variadic function calls

*** Files Modified
- src/rs/init.rs: declare_var, init_context
- src/rs/ccodegen.rs: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call
- src/self/init.til: declare_var, init_context
- src/self/ccodegen.til: emit_constant_declaration, emit_global_declaration, emit_declaration, emit_variadic_call

** Bug #33: for-in loops don't work with enum collections
:PROPERTIES:
:DISCOVERED: 2025-12-14
:IMPACT: Code ergonomics
:STATUS: Fixed
:FIXED: 2025-12-15
:END:

*** Description
The for-in loop syntax doesn't work when iterating over collections of enum values (e.g., Vec<ValueType>).

#+BEGIN_EXAMPLE til
// This fails:
for val: ValueType in vec_of_valuetypes {
    // ...
}
#+END_EXAMPLE

*** Root Cause
The for-in desugaring in precomp.rs creates code like:

#+BEGIN_EXAMPLE til
for _for_i in 0..collection.len() {
    mut val := ValueType()    // <-- Problem: no parameterless constructor
    collection.get(_for_i, val)
    // body
}
#+END_EXAMPLE

For structs, `StructName()` creates a default-initialized instance. But enums don't have a parameterless constructor - all variants require payloads (e.g., `ValueType.TCustom(Str)`, `ValueType.TFunction(FunctionType)`).

*** Fix Applied
Changed for-in desugaring to detect when the iteration type is an enum and generate
an appropriate placeholder value using the first variant:
- For variants without payload: `EnumType.FirstVariant`
- For variants with payload: `EnumType.FirstVariant(default_payload)`

The placeholder value is immediately overwritten by the get() call, so any valid
variant works as an initializer.

*** Files Changed
- src/rs/precomp.rs: Added build_default_value() helper and updated precomp_forin()
- src/self/precomp.til: TIL port with build_default_value_for_forin() and updated precomp_forin()
- src/test/forin_enum.til: Regression test
- src/tests.til: Added forin_enum.til to test suite
- src/test/run_cmd.til: Updated directory list (bots/ removed, c/ and out/ added)

*** Affected Code
- src/self/typer.til: Converted for-in loops over ValueType to while loops
- src/self/ccodegen.til: Same workaround applied

** Bug #32: TIL doesn't support chained field access + method calls
:PROPERTIES:
:DISCOVERED: 2025-12-14
:FIXED: 2025-12-15
:IMPACT: Code ergonomics
:STATUS: Fixed
:END:

*** Description
TIL doesn't support chained field access followed by method calls like:
#+BEGIN_EXAMPLE til
lexer.peek().token_type.eq(TokenType.Colon)
#+END_EXAMPLE

This causes parse errors like:
#+BEGIN_EXAMPLE
Expected '(' after method name 'token_type', found 'Dot'
#+END_EXAMPLE

Or type errors like:
#+BEGIN_EXAMPLE
Cannot call 'peeked.token_type', it is not a function, it is 'TokenType'
#+END_EXAMPLE

*** Fix
Parser now handles field access after function/method calls by using
Identifier("_") as a marker where params[0] holds the base expression
and params[1..] holds the field chain. Changes in parser, init, typer,
interpreter, and ccodegen (both Rust and TIL).

Tests added to src/test/structs.til.

*** Affected Code
- src/self/parser.til: parse_for_statement (workaround removed)

** Bug #36: Throwing functions in struct literal parameters not recognized :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-15
:FIXED: 2025-12-15
:IMPACT: Type checker correctness
:STATUS: Fixed
:END:

*** Description
When calling a throwing function inside struct literal named parameters, the compiler failed to recognize that the function throws and incorrectly reported that the error type is never thrown.

*** Fix
Modified =check_body_returns_throws= in typer.rs/typer.til to:
1. Handle =NamedArg= nodes inside function call arguments
2. Check arguments of struct/enum constructors (=Ok(None)= / =KeyNotFoundError= case)
3. Track thrown types from nested function calls in both cases

*** Changes
- src/rs/typer.rs: Added NamedArg handling and struct constructor argument checking
- src/self/typer.til: Ported same fix from Rust
- src/std/map.til: Removed workaround (can now inline clone() calls)
- src/self/init.til: Added throws declarations to clone() functions
- src/test/errors.til: Regression test (test_bug36)

** Bug #31: Switch on struct field with pattern matching fails :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-06
:FIXED: 2025-12-06
:IMPACT: Self-hosting, pattern matching
:STATUS: Fixed
:END:

*** Description
When using =switch= on a struct field that is an enum (e.g., =switch s.color=), pattern matching with payload extraction failed with "Enum definition for 'StructName' not found" error.

*** Example Problem
#+BEGIN_EXAMPLE til
StructWithPayloadEnum := struct {
    mut color: Color = Color.Unknown
}

test := proc() {
    mut s := StructWithPayloadEnum()
    s.color = Color.Number(42)
    switch s.color {
    case Color.Number(n): result = n  // FAILED: Enum definition not found
    case: result = 0
    }
}
#+END_EXAMPLE

*** Root Cause
Two issues in interpreter and arena code:

1. *Pattern matching code extracted only base identifier* (interpreter.rs:390-394):
   When processing =switch s.color=, the code only extracted "s" from =to_switch.node_type= instead of constructing the full path "s.color".

2. *get_enum didn't resolve field types* (arena.rs:764+):
   =get_enum= looked up the base variable's type instead of the field's type. For "s.color", it got =StructWithPayloadEnum= instead of =Color=.

*** Fix (2025-12-06)
*Rust side:*

1. *interpreter.rs*: Modified pattern matching code to construct full field path from to_switch expression params:
#+BEGIN_SRC rust
let enum_var_name = if let NodeType::Identifier(name) = &to_switch.node_type {
    if !to_switch.params.is_empty() {
        let mut full_path = name.clone();
        for param in &to_switch.params {
            if let NodeType::Identifier(field_name) = &param.node_type {
                full_path.push('.');
                full_path.push_str(field_name);
            }
        }
        full_path
    } else {
        name.clone()
    }
} else { /* error */ };
#+END_SRC

2. *arena.rs*: Modified =get_enum= to use =get_field_type= for dotted paths:
#+BEGIN_SRC rust
let enum_type = if id.contains('.') {
    match ctx.get_field_type(id) {
        Ok(ValueType::TCustom(type_name)) => type_name,
        // ... error handling
    }
} else {
    // original lookup_symbol logic
};
#+END_SRC

3. *init.rs*: Added =get_field_type= function to resolve the ValueType for a field path.

*TIL side:*
- Ported same changes to interpreter.til, arena.til, and init.til

*** Test Coverage
- src/test/enums.til: =test_switch_on_struct_field= (simple switch on field)
- src/test/enums.til: =test_switch_on_struct_field_with_payload= (pattern matching with payload)

** Bug #30: ext_proc signature mismatch between TIL and Rust :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-03
:FIXED: 2025-12-03
:IMPACT: Type safety
:STATUS: Fixed
:END:

*** Description
=single_print= was incorrectly declared as variadic (=..Str=) in TIL, but =proc_single_print= in ext.rs expects exactly 1 argument.

*** Problem
#+begin_src til
// Wrong declaration (variadic):
single_print := ext_proc(args: ..Str);

// Both pass type check AND runtime (variadic wraps args into Array):
single_print("one")        // Works: Array with 1 element
single_print("one", "two") // Also "works": prints Array representation
#+end_src

*** Why It Wasn't Caught
Variadic parameters get wrapped into an Array before being passed to ext.rs. So =validate_arg_count= sees 1 argument (the Array), passing validation. The function then prints whatever =result.value= is - which would be the Array's string representation instead of the expected Str.

*** Fix (2025-12-03)
1. Changed declaration from variadic to single parameter in core.til:
#+begin_src til
// Correct declaration:
single_print := ext_proc(s: Str);
#+end_src

2. Added warning comment to =proc_single_print= in ext.rs referencing Bug #30.

*** Systemic Issue
The compiler cannot verify that ext_proc TIL declarations match their Rust implementations. Variadic wrapping bypasses =validate_arg_count= by passing all args as a single Array. This is an inherent FFI limitation.

** Bug #28: UFCS fails inside pattern match case bodies with bindings :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-12-02
:FIXED: 2025-12-02
:IMPACT: Self-hosting, type checking
:STATUS: Fixed
:END:

*** Description
UFCS method calls failed with "Could not find function definition" when inside pattern match case bodies that have bindings (e.g., =case Enum.Variant(binding):=).

*** Root Cause
The =check_body_returns_throws= function ran without proper scope tracking:
1. Pattern binding variables weren't declared in the scope
2. Local variables declared within case bodies weren't visible

*** Fix (2025-12-02)
Added proper scope management to =check_body_returns_throws= in =typer.rs=:

1. *Pattern binding scope*: When processing switch cases with pattern bindings, push a Block scope and declare the binding variable with its payload type (mirrors =check_switch_statement=).

2. *Variable declarations*: When processing Declaration nodes, infer the type from the initializer and declare the variable in the current scope (if not already declared).

Files modified:
- =src/rs/typer.rs= lines 767-825 (NodeType::Switch handler)
- =src/rs/typer.rs= lines 828-845 (NodeType::Declaration handler)

*** Test Coverage
- =src/test/ufcs.til=: =test_ufcs_struct_field_in_pattern_match=
- =src/test/enums.til=: =test_bug28_ufcs_push_in_binding=, =test_bug28_ufcs_len_in_binding=

All tests pass.

** Bug #29: Catch variable not accessible in arena :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-19
:FIXED: 2025-11-19
:IMPACT: Error handling, catch blocks
:STATUS: Fixed
:END:

*** Description
Caught error variable (=err=) not properly stored in execution arena. Accessing =err.msg= in catch block caused:
- Type error: "Undefined symbol 'err'"
- Runtime error: "base variable 'err' not found in arena_index"

Affected: =throw err.msg=, =return err.msg=, =msg = err.msg= - any field access on caught errors.

*** Fix (2025-11-19, commit 0024caa)
Properly register catch parameter in both interpreter and typer:
- =interpreter.rs=: Register base variable when propagating throws (line 3020) and in catch fallback (line 2438)
- =typer.rs=: Create temp_context with catch parameter before type-checking catch body (lines 665-692)

*** Test Coverage
- =src/test/errors.til=: =test_rethrow_error_field= (tests =throw err.msg=)
- =src/test/errors.til=: =test_rethrow_error_field_via_assign= (tests =msg = err.msg= then =throw msg=)

** Bug #1: Enum Comparison in Switch/Case

- *Status*:  NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

** Bug #2: Return Statement Stack Frame Handling

- *Status*:  NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

** Bug #3: Nested Enum Payloads

- *Status*:  FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

** Bug #4: Enum Payload Copy

- *Status*:  FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

** Bug #5: rsonly_enum_extract_payload Function

- *Status*:  FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

** Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*:  FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

** Bug #7: Enum Return Value Handling

- *Status*:  FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

** Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*:  FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

**** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

**** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     //  Prints
    lexer.expect(TokenType.LeftParen)      //  Causes function to return!
    println("[DEBUG 2] After expect")      //  Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

**** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

**** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

**** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

**** Valid Code Patterns
```til
//  Capture the return value
result := my_add(1, 2)

//  Use as argument to another function
double(my_add(3, 4))

//  Explicitly discard with _
_ := get_value()

//  Procs don't return values, no capture needed
print_hello()

//  ERROR: Return value not captured
my_add(1, 2)
```

**** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

**** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

**** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

** Division/Modulo by Zero

- *Status*:  FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

** Bug #27: Cannot inline Vec.new() as function argument :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-18
:FIXED: 2025-11-18
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
The TIL evaluator cannot handle inline Vec.new(Expr) calls when passed as arguments to functions. This requires creating a variable first instead of passing the expression directly.

*** Example Problem
#+BEGIN_EXAMPLE til
// Rust does (parser.rs:1180):
return Ok(Expr::new_explicit(
    NodeType::Pattern(pattern_info),
    Vec::new(),  // Inline Vec::new() works
    left.line,
    left.col
));

// TIL must do (parser.til:1326-1330):
empty_params := Vec.new(Expr)  // Create variable first
return Expr.new_explicit(NodeType.Pattern(pattern_info), empty_params, left.line, left.col)
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil eval ERROR: Struct argument must be an identifier or field access
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 1780-1796

When evaluating function calls with struct arguments, the evaluator checks if the parameter is marked as 'own'. For non-own struct parameters, it requires the argument to be an identifier or field access (not an arbitrary expression).

The 'params' parameter in Expr.new_explicit is declared as 'params: Vec' (not 'own Vec'), so inline expressions like Vec.new(Expr) are rejected.

*** Fix (2025-11-18)
Modified interpreter.rs to allow non-identifier expression arguments for struct parameters:

1. Lines 1778-1782: For field access chains with expressions, use result_str
2. Lines 1787-1795: For simple expressions (like Vec.new()), use result_str
3. Lines 1899-1904: For non-Identifier node types, allocate struct and copy fields from result_str

The key insight: when an expression is evaluated (like Vec.new(Expr)), the result
is allocated in the arena and result_str contains the identifier. We can use this
to copy the struct to the parameter, just like we do for identifier arguments.

*** Now Works
#+BEGIN_SRC til
// Can inline Vec.new(Expr) directly as argument
return Expr.new_explicit(NodeType.Pattern(pattern_info), Vec.new(Expr), left.line, left.col)
#+END_SRC

*** Previous Workaround (No Longer Needed)
#+BEGIN_SRC til
// Old workaround - create variable first
empty_params := Vec.new(Expr)
return Expr.new_explicit(..., empty_params, ...)
#+END_SRC

** Bug #26: Nested struct corruption in Vec/Map :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-17
:FIXED: 2025-11-17
:IMPACT: Data integrity, collection storage
:STATUS: Fixed
:COMMIT: ea8cd2b
:END:

*** Description
When structs containing nested structs (like Vec, Map, List) were stored in collections, the nested structs were allocated separately instead of inline, causing memory corruption.

*** Fix
Modified insert_struct_at_offset in init.rs to accept optional existing_offset parameter, allowing nested structs to be allocated inline within parent's memory block.

*** Commit
ea8cd2b: Fix Bug #26: nested struct corruption in Vec/Map

** Bug #25: Field offset refactor breaks typer method resolution :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-13
:FIXED: 2025-11-13
:IMPACT: API consistency, method resolution
:STATUS: Fixed
:END:

*** Description
The typer fails to find I64.eq method when chaining method calls on struct field access (e.g., `s.items.len.eq(0)`). This was discovered during field offset refactoring work but the root cause was different.

*** Example Problem
#+BEGIN_EXAMPLE til
// In ufcs.til line 300 - this WORKS:
items_len := s.items.len

// In ufcs.til line 304 - this FAILS:
len_check := s.items.len.eq(0)  // Error: "Could not find function definition"
#+END_EXAMPLE

The field access works, but method resolution on the result fails!

*** Root Cause (FOUND!)
The real issue was NOT the field offset refactor, but an API inconsistency:
- Vec, List, and Array had `len` as a FIELD instead of a METHOD
- When the typer tried to resolve `s.items.len.eq(0)`, it saw `.len` as a field access
- Field accesses return `auto` type (requiring type inference)
- The typer couldn't properly infer the type for chained method calls
- Result: "Could not find function definition" for `.eq(0)`

This became apparent when `s.items.len` was accessed - it worked as a field, but the moment you tried to call a method on the result, type resolution failed.

*** Solution (2025-11-13)
Implemented uniform len() API across all collection types:

1. **Renamed internal fields**: `len`  `_len` (cap kept as-is)
2. **Added uniform methods**:
   - `len()` returns element count (_len)
   - `size()` returns byte size (len * type_size)
3. **Implemented for**: Vec, List, Array (src/core/core.til)
4. **Updated all code** to use `.len()` method calls:
   - Core library: lexer.til, parser.til, typer.til, interpreter.til
   - Test files: ufcs.til, args.til, arrays.til, dynamic_arrays.til, lists.til, maps.til, mut_test.til, variadic.til
5. **Updated interpreter**: init.rs to look for `._len` field offset
6. **For-loop workaround**: Store `len()` in local variable (e.g., `mut args_len := args.len()`)

*** Now Works
#+BEGIN_EXAMPLE til
//  All these patterns now work correctly:
items_len := s.items.len()
len_check := s.items.len().eq(0)
if i.lt(s.items.len().add(5)) { }
comparison := i.lt(e.params.len())
#+END_EXAMPLE

*** Test Coverage (Regression Prevention)
The existing test file `src/test/ufcs.til` provides comprehensive regression coverage:

**test_bug10_fixed()** (lines 296-317):
- Line 304: `len_check := s.items.len().eq(0)` - EXACT failing pattern
- Line 309: `comparison := i.lt(s.items.len().add(5))` - Chained method calls
- Line 314: `name_len := name.len()` - String len() method

**test_bug10_parser_patterns_fixed()** (lines 320-341):
- Line 334: `len_is_zero := e.params.len().eq(0)` - Another instance of failing pattern
- Line 338: `len_plus_five := e.params.len().add(5)` - Arithmetic on method result

These tests run in the standard test suite and will catch any regression
that breaks chained method calls on field access. All tests pass (exit code 0).

*** Commits
- 27dc3ae: Fix Bug #25: Implement uniform len() API for Vec, List, and Array
- 1444a8b: Complete len() API standardization - fixes Bug #25

** Bug #24: Variable Declarations Share Arena Offsets Instead of Copying :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-12
:IMPACT: Data integrity, aliasing bugs
:STATUS: Fixed
:END:

*** Description
When declaring a new variable from an existing struct (e.g., `mut dup := original`), the interpreter shares the arena offset instead of creating an independent copy. This causes unintended aliasing where modifications to the new variable also modify the original.

*** Example Problem
#+BEGIN_EXAMPLE til
original := Vec2.new(1, 2)
mut dup := original  // Should copy, but currently shares offset
dup.x = 999          // Modifies BOTH dup AND original!
// original.x is now 999 instead of 1
#+END_EXAMPLE

*** Root Cause
File: src/rs/interpreter.rs, lines 920-921

The declaration code path shares the arena offset:
#+BEGIN_SRC rust
if let Some(offset) = context.arena_index.get(&expr_result_str) {
    context.arena_index.insert(declaration.name.to_string(), *offset);  // Shares!
}
#+END_SRC

However, the assignment code path (line 1002) correctly copies:
#+BEGIN_SRC rust
context.copy_fields(custom_type_name, &expr_result_str, var_name, inner_e)?;  // Copies!
#+END_SRC

This inconsistency means declarations create aliases while assignments create copies.

*** Impact
- Unintended aliasing bugs where modifying one variable affects another
- Breaks expected semantics: `mut dup := original` should create independent copy
- Inconsistent behavior between declaration and assignment
- Makes it impossible to pass const params by reference safely (Phase 3 blocker)

*** Test Case
Added in src/test/args.til line 484 (test_declaration_creates_copy)
Currently FAILS with: `assert_eq failed: expected '1', found '999'`

*** Fix Applied

**Design Decision**: Only mut declarations create copies. Non-mut declarations share offsets (read-only aliases).

**Implementation** (src/rs/interpreter.rs lines 923-935):
- **mut declarations**: Call insert_struct() + copy_fields() to create independent copy
- **non-mut declarations**: Share arena offset (efficient, type checker enforces immutability)

**Result**:
#+BEGIN_SRC til
mut dup := original  // Creates independent copy
dup := original      // Shares offset (read-only alias)
#+END_SRC

This design aligns with Mojo's ownership model:
- mut = mutable copy (prevents aliasing)
- default = reference (efficient, safe with type checker)
- Future: 'own' keyword for ownership transfer

See doc/ownership.org for full design analysis and Mojo comparison.

**All tests pass**, including test_declaration_creates_copy (args.til:484)

** Bug #24: Struct Field Access Returns Copy Instead of Reference :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-12
:FIXED: 2025-11-18
:IMPACT: Data structure mutation, memory management
:STATUS: Fixed
:END:

*** Description
When accessing struct fields that are themselves structs (like Vec, Map, List), TIL returns a COPY of the field value rather than a reference. This means that modifications to the field are made to the copy and do not affect the original struct member.

This is particularly problematic for collection types stored as struct members, where methods that mutate the collection (like push, set, delete) don't actually update the parent struct's field.

*** Example Problem
#+BEGIN_EXAMPLE til
List := struct {
    mut type_names : Vec = Vec()
    ...
    push := proc(mut self: List, T: Dynamic, value: Dynamic) {
        mut type_name := type_as_str(T)
        self.type_names.push(type_name)  // DOES NOT WORK - modifies copy
        self.len = add(self.len, 1)      // Works - primitive field
    }
}
#+END_EXAMPLE

After `list.push(I64, 42)`:
- `list.len` is correctly incremented to 1
- `list.type_names.len` remains 0 (the Vec was modified in a copy, not the original)

*** Current Workaround
Must explicitly copy the field, modify it, and reassign:
#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)

    // Workaround: copy, modify, reassign
    mut names := self.type_names
    names.push(type_name)
    self.type_names = names

    self.len = add(self.len, 1)
}
#+END_EXAMPLE

*** Impact
- Verbose code with manual copy-modify-reassign pattern
- Potential for bugs if developers forget to reassign
- Performance overhead from unnecessary copying
- Confusing behavior - `mut self` suggests fields should be mutable

*** Affected Code
- src/core/core.til:980-999 (List.push)
- src/core/core.til:1062-1066 (List.set same size case)
- src/core/core.til:1086-1093 (List.set different size case)
- Potentially any struct with collection-type fields

*** Fix Applied (2025-11-18)

Bug #24 was fixed as part of implementing pass-by-reference for field access parameters and fixing Bug #26.

**Three-part solution:**

*Fix 1: Inline nested struct allocation* (init.rs:1510-1625)
- Modified insert_struct_at_offset to accept optional existing_offset
- Nested structs now allocated inline within parent's memory block
- Previously: nested structs allocated separately, causing corruption

*Fix 2: Pass-by-reference for field access parameters* (interpreter.rs:1820-1872)
- Extended pass-by-ref to field access like `self.type_names.push(...)`
- Share arena offset instead of allocating and copying
- Register field symbols for UFCS method resolution
- Previously only simple identifiers used pass-by-ref

*Fix 3: Zero-copy return value transfers* (interpreter.rs:970-985)
- Detect temporary return values and share offset instead of copy
- mut x := func() now zero-copy (transfers ownership)
- Only copy when source is real variable (preserves Bug #25 fix)

**Result:**
The workaround pattern is no longer needed. Direct field mutations now work:

#+BEGIN_EXAMPLE til
push := proc(mut self: List, T: Dynamic, value: Dynamic) {
    mut type_name := type_as_str(T)
    self.type_names.push(type_name)  //  NOW WORKS - modifies via reference!
    self.len = add(self.len, 1)
}
#+END_EXAMPLE

**Test Coverage:**
- src/test/tmp/test_bug24.til - Comprehensive test verifying direct field mutations
- All existing tests pass with the fix

**Note on Workarounds:**
While the bug is fixed, existing workarounds (copy-modify-reassign pattern) can remain for now
as they are functionally equivalent. Workarounds exist in:
- src/core/core.til (List.push, List.set, List.pop, etc.)
- src/core/lexer.til
- src/core/parser.til
- src/core/std.til (potentially)
They can be removed in a future cleanup pass to simplify the code and potentially improve performance.

** Bug #22: Dynamic Type Parameters Not Working in User Functions :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: API ergonomics, collection constructors
:STATUS: Fixed
:COMMIT: 2138e15
:END:

*** Description
When type identifiers (I64, U8, Str, etc.) were passed as Dynamic parameters to user-defined functions, the interpreter tried to evaluate them as expressions, causing "Expr index 0 out of bounds" errors.

This prevented the desired ergonomic API for collection constructors:
#+BEGIN_EXAMPLE
Array.new(U8, 3)      // DESIRED - clean and simple
Array.new("U8", size_of(U8), 3)  // OLD - verbose and redundant
#+END_EXAMPLE

*** Example Error
#+BEGIN_EXAMPLE
ERROR: While running file src/test/tmp/test_array_new.til:
src/test/tmp/test_array_new.til:9:26: rstil assert ERROR: Expr index 0 out of bounds (len: 0).
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause
The interpreter was attempting to evaluate all arguments before passing them to user-defined functions (line 1492 in interpreter.rs). When a type identifier like `I64` was encountered, it tried to evaluate it as a struct constructor, which expected parameters (e.g., `I64()`), but the bare identifier had no parameters, causing the "index 0 out of bounds" error.

The key difference:
- **Values** (like `42`, `"hello"`) can be evaluated
- **Type identifiers** (like `I64`, `U8`) should NOT be evaluated when passed to Dynamic parameters

*** Solution (2025-11-11)
Fixed in commit 2138e15 with a three-part approach:

1. **Skip evaluation** (src/rs/interpreter.rs:1459-1478):
   When a type identifier is passed to a Dynamic parameter, detect it and skip the eval_expr() call entirely.

2. **Store type name as string** (src/rs/interpreter.rs:1467-1471):
   Store the type name (e.g., "U8") as a string value for the parameter name (e.g., "T").

3. **Resolve in introspection functions** (src/rs/ext.rs:239-256, 274-291):
   Modified size_of() and type_as_str() to check if the identifier is a string variable (Dynamic parameter), and if so, use that string value to look up the type.

*** Now Works
#+BEGIN_SRC til
// Clean API for all collection constructors
mut arr := Array.new(U8, 3)
mut vec := Vec.new(I64)
mut map := Map.new(Str, I64)
mut ptr := Ptr.new(I64)

// Inside the constructor, introspection works correctly
new := proc(T: Dynamic, capacity: I64) returns Array throws AllocError {
    mut arr := Array()
    arr.type_name = type_as_str(T)  // Returns "U8"
    arr.type_size = size_of(T)       // Returns 1
    // ...
}
#+END_SRC

*** Impact
This enables the planned refactor to simplify all collection constructor APIs across the codebase (124 call sites: 15 Array, 73 Vec, 36 Map).

*** Related
See doc/todo/pre.org item #21 for the API refactor plan.

** Bug #11: Cannot Access String Fields in Caught Error Structs :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-11
:FIXED: 2025-11-11
:IMPACT: Error handling, test code quality
:STATUS: Fixed
:END:

*** Description
When catching an error in a catch block, accessing string fields of the error struct fails with "missing field 'err.msg.c_string'" error.

*** Example
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  // FAILS: missing field 'err.msg.c_string'
}
#+END_EXAMPLE

*** Error Message
#+BEGIN_EXAMPLE
rstil context ERROR: missing field 'err.msg.c_string'
Explanation: This should never happen, this is a bug in the language.
#+END_EXAMPLE

*** Root Cause (FOUND!)
The bug ONLY occurs when errors are thrown from UFCS method calls. When an error is thrown from a method and caught, the string fields' arena_index entries (like `.msg.c_string`) are not being properly propagated from the method's local context to the calling context.

Working cases:
- Direct throw: `throw IndexOutOfBounds Error.new("msg")` 
- Throw with format: `throw IndexOutOfBoundsError.new(format(...))` 
- Throw from regular function 

Failing case:
- Throw from UFCS method: `s.throws_error()` where method does `throw` 

The issue is in how the throw result is handled when returning from a method call. The arena_index entries for the error struct's string fields exist in the method's context but aren't being copied back to the caller's context.

*** Impact
- Cannot access error messages from built-in collection methods (Array.set, Vec.push, etc.)
- Forces workarounds like hardcoded error strings
- Prevents implementing the desired panic(loc(), format("ERROR:", err.msg)) pattern
- Makes test error handling less informative

*** Test Cases
- src/test/tmp/test_err_simple.til - Direct throw (WORKS)
- src/test/tmp/test_err_format_call.til - Throw with format (WORKS)
- src/test/tmp/test_err_ufcs.til - Throw from UFCS method (FAILS)
- src/test/tmp/test_err_array.til - Array.set error (FAILS)

*** Fix (2025-11-11)
Fixed in src/rs/interpreter.rs:1686-1720 in eval_user_func_proc_call().

When a function/method throws an error, we now check if the thrown value is a struct type. If it is, we copy all arena_index and symbol entries for the struct's fields (including nested fields like `.msg.c_string`) from the function's local context to the calling context.

This mirrors the logic already in place for returning struct values, but applies it to thrown values as well.

*Now works:*
#+BEGIN_EXAMPLE
arr.set(999, 84)
catch (err: IndexOutOfBoundsError) {
    println(err.msg)  //  Works! Prints the error message
}
#+END_EXAMPLE

** Bug #10: UFCS Does Not Work on Struct Fields :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-11
:IMPACT: Code ergonomics, parser implementation
:STATUS: Fixed
:END:

*** Description
UFCS (Uniform Function Call Syntax) failed when trying to call methods on struct fields. This manifested in two ways:

1. *Runtime error* when calling methods directly on struct fields:
   #+BEGIN_EXAMPLE
   s.items.push(10)  // FAILED
   Error: "Cannot use 'self' of type 'Array' as an argument"
   #+END_EXAMPLE

2. *Compile-time error* when chaining property access with methods:
   #+BEGIN_EXAMPLE
   s.items.len.eq(3)  // FAILED
   Error: "Cannot call 's.items', it is not a function"

   if i.lt(e.params.len) { }  // FAILED
   Error: "Cannot call 'e.params', it is not a function"
   #+END_EXAMPLE

*** Fix (2025-11-11)
Fixed both type checker and interpreter to handle multi-level field access chains:

*Type Checker (src/rs/init.rs):*
- Modified get_fcall_value_type() to decompose field+method chains
- When encountering struct.field.method, resolve field access first, then method lookup
- Check for methods on all types (I64.eq, etc.) not just structs in struct_defs

*Interpreter (src/rs/interpreter.rs):*
- Handle field access chains in struct arguments (not just simple identifiers)
- Build full arena paths like "s.items" for field lookups
- Support field access in mut arguments for proper write-back

*Now works:*
#+BEGIN_EXAMPLE
s.items.len              // Multi-level field access
s.items.len.eq(3)        // 4-level chain with method call
if i.lt(e.params.len) {} // Field access in comparisons
#+END_EXAMPLE

*** Known Limitation
While field access and read-only methods work, modifying struct fields through mut methods has remaining issues:
#+BEGIN_EXAMPLE
s.items.push(42)  // Length increases but values not stored correctly
#+END_EXAMPLE

This is a deeper issue with struct field pass-by-value vs pass-by-reference semantics.
Workaround: Extract to local variable, modify, write back:
#+BEGIN_SRC til
mut items := s.items
items.push(42)
s.items = items
#+END_SRC

*** Test Coverage
Comprehensive tests in =src/test/ufcs.til= verify field access and method calls work correctly.

** Bug #9: Error Line Numbers from Imported Files :FIXED:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:FIXED: 2025-11-12
:IMPACT: Developer experience, debugging
:STATUS: Fixed
:END:

*** Description
When errors occur in imported files (e.g., parser.til imported by test_parser.til), the error messages show incorrect line numbers and file paths.

*** Example
#+BEGIN_EXAMPLE
ERROR: While running file src/test/test_parser.til:
src/test/test_parser.til:src/test/test_parser.til:129:13: rstil eval ERROR: ...
#+END_EXAMPLE

Note the duplicated file path and the line number (129) referring to the calling file rather than the actual error location in the imported file.

*** Impact
- Makes debugging harder when errors occur in imported modules
- Line numbers may not correspond to the actual error location
- File paths are duplicated and unclear

*** Workaround
When debugging, add print statements or trace through the call stack manually to find the actual error location.

*** Investigation (2025-11-11)

*Root Cause Analysis:*

The problem stems from multiple layers of error message prefixing and incorrect context.path tracking:

1. *Expr only stores line/col, not file path*
   - Location: src/rs/parser.rs:101-106
   - The Expr struct only stores line and col from tokens, no file path
   - When AST is parsed from imported file, line/col are correct but no file association

2. *Context.path exists but errors don't use it*
   - Location: src/rs/init.rs:834-835
   - TODO comment acknowledges issue: "use Context.path to properly report eval errors"
   - context.path is updated on import (ext.rs:721) but not propagated to errors

3. *Error methods only use Expr's line/col*
   - Location: src/rs/parser.rs:166-171
   - error() and lang_error() only use self.line and self.col
   - No access to file path information

4. *Multiple prefixing layers cause duplication*
   - First prefix: rstil.rs:199 in main_run() adds format!("{}:{}", path, err)
   - Second prefix: ext.rs:727-728 in proc_import() wraps error again
   - Result: path appears twice in error message

5. *loc() function works correctly*
   - Location: ext.rs:34-41
   - Combines context.path with e.line and e.col
   - This mechanism could be model for error messages

*Potential Fix Approaches:*

Option 1: Store file path in Expr (Most Robust)
- Add file: String field to Expr struct
- Update all Expr creation to include file path
- Update error methods to use self.file
- Pros: Complete fix, correct attribution
- Cons: Memory overhead, requires updating all Expr construction

Option 2: Pass Context to error methods
- Change error() signature to accept &Context parameter
- Use context.path in error messages
- Pros: No AST changes needed
- Cons: Context not always available, requires signature changes

Option 3: Avoid double-prefixing (Quick Fix)
- Remove one layer of path prefixing
- Only prefix at outermost level (main_run)
- Pros: Simple, fixes duplication
- Cons: Doesn't fix attribution across file boundaries

Option 4: Use context.path consistently (Recommended)
- Make error methods take optional file path parameter
- If not provided, format as just "line:col:"
- Always prefix at outermost level with actual file path
- Update proc_import to not re-prefix errors

*** Solution (2025-11-12)
Fixed using a comprehensive approach combining Options 1 and 2:

1. **Updated error method signatures to include path** (src/rs/parser.rs:188, src/rs/lexer.rs:76):
   - Changed `Expr.error()` to accept `path: &str` parameter instead of just `phase` and `msg`
   - Changed `Token.error()` to accept `path: &str` parameter
   - Error format now: `file:line:col: phase ERROR: message`

2. **Pass file paths to error methods** (~207 call sites updated):
   - Parser functions use `&lexer.path`
   - Init/typer/interpreter functions use `&context.path`
   - Helper functions accept `path: &str` parameter passed from callers

3. **Set lexer path correctly** (src/rs/lexer.rs:610):
   - Updated `lexer_from_source()` to set `lexer.path = path.clone()`
   - Previously was defaulting to `"<test>"`, now uses actual file path

4. **Store source path in function definitions** (src/rs/parser.rs:46, 661):
   - Added `source_path: String` field to `SFuncDef`
   - Set during parsing to `lexer.path.clone()`
   - Enables tracking where each function was defined

5. **Use function's source path during execution** (src/rs/interpreter.rs:1424):
   - When calling user-defined functions, set `function_context.path = func_def.source_path.clone()`
   - Errors during function execution now show the correct source file

*** Now Works
All error phases show correct file paths:

*Lexer errors:*
#+BEGIN_EXAMPLE
src/test/tmp/lexer_error_test.til:5:5: Lexical error 0: Invalid character...
#+END_EXAMPLE

*Parser errors:*
#+BEGIN_EXAMPLE
src/test/tmp/parser_error_test.til:6:9: parse ERROR: Expected '{' after condition...
#+END_EXAMPLE

*Type checker errors:*
#+BEGIN_EXAMPLE
src/test/tmp/init_error_test.til:5:12: type ERROR: Return value in pos 0...
#+END_EXAMPLE

*Evaluation errors from imported files:*
#+BEGIN_EXAMPLE
src/test/tmp/imported_helper.til:7:10: type ERROR: Undefined symbol 'undefined_var'
#+END_EXAMPLE

*** Impact
- Debugging is now much easier with accurate file paths
- Errors in imported modules show the correct source location
- All compiler phases (lexer, parser, init, typer, eval) report consistent paths
- No more duplicate path prefixes in error messages

*Relevant Code Locations (post-fix):*
- Error generation: src/rs/parser.rs:150-171, src/rs/ext.rs:34-41
- Import handling: src/rs/ext.rs:693-736, src/rs/init.rs:542-625
- Error prefixing: src/rstil.rs:199, src/rs/ext.rs:727-728
- Context path: src/rs/ext.rs:721,726,734

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
* Implemented Issues

** Issue #106: First-Class Enums -- IMPLEMENTED 2026-02-26
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-02-26
:IMPACT: Language feature, anonymous data structures, templates
:RELATED: Issue #91 (First-Class Functions), Issue #105 (First-Class Structs), doc/first_class.org
:END:

Allow enums to be truly first-class values: pass as arguments, store in
collections, introspect at runtime.

*** Implementation
- [X] Parser: ~enum~ as return type keyword in func/proc returns
- [X] Init: defer enum registration for macro FCall RHS to precomp
- [X] Precomp: ~expand_struct_macros()~ handles enum macros (name substitution, type substitution)
- [X] Macro namespace support: ~namespace:~ inside macro-returned enums
- [X] ~src/std/typed_option.til~: ~make_option(T)~ macro -- real generics for enums
- [X] ~enum_def_of(type_name)~ runtime introspection via ext functions (interpreter only)
- [X] Anonymous enum expressions: ~some_macro(enum { A, B })~ (in macro args)
- [X] Explicit metatype annotations (~Color : EnumDef = enum { ... }~)
- [X] Vec of enum instances (~Vec.new(Direction)~)
- [X] ~enum_def_of~ introspection in compiled mode (4a02061f, 2026-02-26)
      Codegen pass 4e emits C implementations of ~__enum_variant_*~ ext_funcs.
- [X] Vec of EnumDef (~Vec.new(EnumDef)~) via ~enum_def_of~ (39192242, 2026-02-26)
      Scavenger recognizes ~enum_def_of("TypeName")~ string args as type references.
- [X] Anonymous enum as Dynamic arg (~vec.push(own enum { ... })~) (2026-02-26)
      Precomp replaces bare EnumDef value args with ~enum_def_of("AnonEnumN")~ calls.
      Distinguishes macro args (use Identifier) from value args (use enum_def_of).
      Handles OwnArg wrapper. All 4 modes pass.

** Issue #105: First-Class Structs -- IMPLEMENTED 2026-02-26
:PROPERTIES:
:DISCOVERED: 2026-01-12
:FIXED: 2026-02-26
:IMPACT: Language feature, anonymous data structures, templates
:RELATED: Issue #91 (First-Class Functions), Issue #106 (First-Class Enums), doc/first_class.org
:END:

Allow structs to be truly first-class values: pass as arguments, store in
collections, introspect at runtime.

*** Implementation
- [X] Parser: ~struct~ as return type keyword in func/proc returns
- [X] Init: defer struct registration for macro FCall RHS to precomp
- [X] Precomp: ~expand_struct_macros()~ expands macro calls, registers structs
- [X] Macro namespace support: ~namespace:~ inside macro-returned structs
- [X] ~src/std/typed_ptr.til~: ~make_typed_ptr(T)~ macro -- real generics
- [X] ~struct_def_of(type_name)~ runtime introspection via ext functions (interpreter only)
- [X] Anonymous struct expressions: ~struct { ... }(args)~ (in macro args)
- [X] Step 4a: NamespaceDef moved into StructDef.ns and EnumDef.ns fields
- [X] Step 4c: SStructDef -> StructDef, SEnumDef -> EnumDef, SFuncDef -> FuncDef
- [X] Step 4d: Explicit metatype annotations (~Point : StructDef = struct { ... }~)
- [X] Vec of struct instances (~Vec.new(Point)~)
- [X] ~struct_def_of~ introspection in compiled mode (4a02061f, 2026-02-26)
      Codegen pass 4e emits C implementations of ~__struct_field_*~ ext_funcs.
- [X] Vec of StructDef (~Vec.new(StructDef)~) via ~struct_def_of~ (39192242, 2026-02-26)
      Scavenger recognizes ~struct_def_of("TypeName")~ string args as type references.
- [X] Anonymous struct as Dynamic arg (~vec.push(own struct { ... })~) (2026-02-26)
      Precomp replaces bare StructDef value args with ~struct_def_of("AnonStructN")~ calls.
      Handles OwnArg wrapper. All 4 modes pass.

** Issue #191: Garbager deletes old value on reassignment of owned variables -- FIXED 2026-02-25
:PROPERTIES:
:DISCOVERED: 2026-02-24
:FIXED: 2026-02-25
:IMPACT: Memory leaks on every reassignment of a variable holding heap data
:RELATED: Issue #117 (ASAP destruction), Issue #183 (manual deletes), Bug #170 (scope-exit), Bug #192 (own through by-ref)
:END:

*** Summary
When a ~mut~ variable holding owned heap data is reassigned, the old value leaked.
The garbager now inserts ~Type.delete(var)~ before each reassignment of struct-typed
locals. Cast-initialized variables are excluded (aliases, not owned). Self-referencing
RHS (~result = Expr.clone(result)~) skips the delete to avoid use-after-free.

*** Fix history
1. *Assignment handler fix* (2026-02-24): Removed ~params.is_empty()~ check, uses
   ~get_value_type(context, rhs)~ to infer type for all RHS expressions including
   field access chains.
2. *Delete-before-reassignment* (2026-02-25): Re-enabled after Bug #192 fix.
   Builds ~declared_types~ map from body declarations, excludes ~cast_vars~,
   inserts ~Type.delete(var)~ before top-level assignments. ~expr_references_var~
   prevents use-after-free on self-referencing RHS.

Files modified: garbager.rs, garbager.til

** Issue #185: Require ~own~ keyword at call sites, improve consumed-variable errors
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPACT: Usability, readability, better error messages
:STATUS: Fixed
:FIXED: 2026-02-24
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned struct fields)
:END:

*Part 1: Require ~own~ at call sites (2026-02-24)*

- Added ~OwnArg~ variant to ~NodeType~ enum (ast.rs, ast.til)
- Parser: ~parse_args~ recognizes ~own expr~ in call arguments, wraps in ~OwnArg~ node
- Typer (~check_fcall~): unwraps ~OwnArg~ before type-checking the inner expression,
  then validates: error if ~own~ param missing ~own~ at call site, error if ~own~ used
  on non-own param
- Typer (~check_body_returns_throws~): handles ~OwnArg~ at top level and unwraps
  ~OwnArg~ in FCall/constructor arg loops so throw tracking sees through the wrapper
- Typer (~check_types_with_context~, ~is_expr_calling_procs~): added ~OwnArg~ cases
- Desugarer: unwraps ~OwnArg~ to inner expression (node doesn't survive past desugarer)
- Guards in ufcs, precomp, interpreter, ccodegen: panic/error if ~OwnArg~ reaches them
- Updated ~1900 call sites across the entire codebase (core, std, self, test, examples)

*Part 2: Better error for consumed variables (2026-02-24)*

- Added ~ConsumedSymbolInfo~ struct to init.rs/init.til with ~consumed_by~ and ~expr~
- Added ~consumed_symbols~ HashMap on ScopeStack to track consumed variables
- Added ~consume_symbol()~ and ~lookup_consumed_symbol()~ methods
- Typer: replaced ~remove_symbol~ with ~consume_symbol~ in ~check_fcall~ own handling
- Typer: added consumed checks in Identifier handler, field assignment handler, and
  UFCS resolution (~get_func_def_for_fcall_with_expr~)
- Two errors emitted per consumed use: one at the use site, one at the consumption site
- Added early-return in ~check_fcall~ to prevent duplicate errors from ~get_value_type~
- Test: src/test/bug185.til (UFCS and non-UFCS consumed variable detection)
- All 92 tests pass in all 4 modes

** Issue #188: Defer statement
:PROPERTIES:
:DISCOVERED: 2026-02-23
:IMPLEMENTED: 2026-02-24
:IMPACT: Resource management, cleanup guarantees, memory management -- step 2 of memory pipeline
:STATUS: Implemented
:RELATED: Issue #183 (manual deletes, step 1), Bug #170 (scope-exit, step 3), Issue #117 (ASAP, step 4)
:END:

*** Summary
Added ~defer~ statement that schedules code to run before function exit (return,
throw, or fall-through). Pure AST desugaring in the desugarer phase -- no
interpreter, ccodegen, or runtime changes needed.

Semantics: block-scoped (like Zig/Odin), LIFO order. Defers run at end of the
scope they're declared in. Returns hoist the return value to a temp var, run all
defers (inner scope first, LIFO within each scope), then return the temp. No
boolean flags, no if-guards.

Implementation: ~desugar_defer_in_body~ called from FuncDef handler in
~desugar_expr~. Recursively processes statement lists via
~desugar_defer_in_scope~, handling If, While, Body (from switch desugaring),
Return, Throw, and Defer nodes. Return value hoisting uses the function's actual
return type (not INFER_TYPE, since desugarer runs after typer). Lexer, parser,
AST, desugarer changes in both Rust and TIL. Later phases have error guards for
any surviving Defer nodes.

Test: src/test/defer.til (all 4 modes).

** Issue #89: Constant folding inside function bodies
:PROPERTIES:
:DISCOVERED: 2026-01-07
:IMPLEMENTED: 2026-02-23
:IMPACT: Performance, code generation quality
:STATUS: Implemented
:RELATED: Issue #88 (Macros), src/test/constfold.til, src/examples/lolalalo.til
:END:

*** Summary
Removed ~at_global_scope~ guard from FCall folding in precomp so pure func
calls with literal args are now constant-folded inside function bodies.

*** Changes
- precomp.rs/til: removed at_global_scope guard from constfold path, added
  try-catch for eval_comptime failures (silently skip unfoldable calls)
- precomp.rs/til: macros inside function bodies skip if args aren't comptime
  (error only at global scope)
- precomp.rs/til: struct/enum constructors only fold at global scope (to avoid
  ownership semantics changes, e.g., Str() becoming borrowed literal)
- precomp.rs/til: zero-arg functions not folded inside bodies (likely stateful)
- eval_comptime: U8 results skip folding (Literal.Number can't distinguish U8
  from I64, causing type erasure in generated C)
- All delete methods changed from proc to func (delete is infrastructure, not
  a semantic side effect; also prevents delete from blocking constfold of callers)
- preinit.rs/til: auto-generated delete methods use FTFunc instead of FTProc
- bug41_liba_helper.til: print_debug changed from func to proc (has I/O)

** Issue #107: First-Class Namespaces (CANCELLED)
:PROPERTIES:
:DISCOVERED: 2026-01-12
:CANCELLED: 2026-02-20
:STATUS: Cancelled -- superseded by namespace: keyword inside structs/enums
:RELATED: Issue #174 (namespace: keyword), Issue #105 (First-Class Structs), doc/first_class.org
:END:

Namespaces are no longer a separate concept. As decided in doc/first_class.org,
namespace functionality is provided by the ~namespace:~ keyword inside struct and
enum bodies (Issue #174, implemented 2026-02-19). Passing a "namespace" as an
argument is equivalent to passing a struct with static members.

** Issue #174: Replace separate namespace blocks with ~namespace:~ keyword inside type bodies
:PROPERTIES:
:DISCOVERED: 2026-02-19
:IMPLEMENTED: 2026-02-19
:IMPACT: Syntax unification, macro-friendly type definitions, path to first-class everything
:STATUS: Implemented
:RELATED: Issue #108 (namespace blocks - implemented), Issue #161 (namespace constants/statics), Issue #91 (first-class functions), doc/first_class.org
:END:

*** Background

Issue #108 moved associated functions from inside struct bodies to separate
~namespace TypeName { ... }~ blocks. This enabled enum methods (enums can't
mix variants with function declarations) and avoided ambiguity between storage
fields and associated functions.

However, separate namespace blocks create problems:
1. *Two declarations for one type*: ~Point := struct { ... }~ then
   ~Point := namespace { ... }~. Unusual and disconnected.
2. *Macros can't return complete types*: A macro returning a struct can't
   include its methods. Would need to return struct + namespace separately.
3. *First-class types*: If types are values that can be passed and returned,
   they should be self-contained.

*** Solution: ~namespace:~ keyword inside type bodies

Move the namespace content inside the struct/enum body, using ~namespace:~
as a section separator (like ~protected:~/~private:~ in C++):

#+BEGIN_SRC til
Point := struct {
    mut x : I64 = 0
    mut y : I64 = 0

namespace:
    origin := func() returns Point { return Point() }
    add := func(self: Point, other: Point) returns Point {
        return Point(x=self.x.add(other.x), y=self.y.add(other.y))
    }
}

Color := enum {
    Red,
    Green,
    Blue,

namespace:
    default := func() returns Color { return Color.Red }
    to_str := func(c: Color) returns Str {
        switch c {
            Color.Red   => return "red"
            Color.Green => return "green"
            Color.Blue  => return "blue"
        }
    }
}
#+END_SRC

*** What was done

Used Option B: the parser packs namespace member Exprs into the StructDef/
EnumDef params Vec, then a ~split_inline_namespaces~ post-parse pass extracts
them into synthetic NamespaceDef nodes. No new fields on SStructDef/SEnumDef
(zero extra memory). Init, typer, ccodegen unchanged -- they still see the
same NamespaceDef nodes as before.

**** Commit ~8e25ff25~: Add inline ~namespace:~ syntax

- *Parser*: Modified ~parse_struct_definition~ and ~enum_definition~ to
  recognize ~namespace:~ and parse declarations after it. Updated
  ~split_inline_namespaces~ to extract namespace members from both
  StructDef and EnumDef into synthetic NamespaceDef AST nodes.
- *Init*: NamespaceDef handler only supported structs (had a TODO).
  Added ~lookup_enum~ fallback so enum namespaces work. Also added
  method fallback in TEnumDef variant resolution (when ~Color.method()~
  is called, the init phase resolves ~Color~ as TEnumDef which only
  checked variants -- now falls back to namespace methods).
- Files: parser.rs, parser.til, init.rs, init.til
- All 89/89 tests pass.

**** Commit ~f5a26608~: Migrate all 48 namespace blocks

- Migrated all 48 ~namespace TypeName { ... }~ blocks across 33 files
  to inline ~namespace:~ syntax.
- Files: src/core/*.til (10), src/std/*.til (5), src/self/*.til (6),
  src/test/*.til (12), src/examples/hello_gui.til.
- Fixed one line-number assertion in errors.til (shifted by migration).
- All 93/93 tests pass.

**** Commit ~264775af~: Remove old namespace block syntax

- Removed ~parse_namespace_definition~ from parser.rs and parser.til.
- Replaced call sites with error messages: "Separate namespace blocks are
  no longer supported. Use inline namespace: inside struct/enum bodies."
- Kept SNamespaceDef as internal AST node (still used by
  ~split_inline_namespaces~).
- All 93/93 tests pass.

*** Notes

- The ~namespace:~ keyword name is provisional. See doc/first_class.org for
  alternatives (~associated:~, ~impl:~, ~methods:~, etc.).
- #108 was not wasted work -- it enabled enum methods, and the init merging
  logic carries over directly. This issue just changed the syntax surface.
- Related to #161 which adds ~static mut~ and constants after ~namespace:~.
  That work builds on top of this issue.

** Issue #163: Replace arena allocator with heap allocation (malloc/free)
:PROPERTIES:
:DISCOVERED: 2026-02-09
:IMPLEMENTED: 2026-02-09
:IMPACT: Enables actual memory reclamation when Type.delete() is called
:STATUS: Implemented
:RELATED: Issue #117 (ASAP destruction), Issue #115 (owned struct fields)
:END:

*** Description
The arena allocator (bump allocator) was the bottleneck for memory management.
It could only grow, never free individual objects. With Type.delete() from Issue
#117, we needed heap allocation so free() actually reclaims memory.

*** What was done
1. *Step 1*: Added heap_alloc/heap_free alongside arena. Dual dispatch.
2. *Step 2*: Moved struct allocations from arena to heap.
3. *Step 3*: Removed arena from EvalArena. All allocations via heap.
   Deleted arena.rs. Kept arena.til as standalone std library.
4. *Step 4 (cleanup)*: Renamed EvalArena to EvalHeap everywhere.
   - git mv eval_arena.rs -> eval_heap.rs, eval_arena.til -> eval_heap.til
   - Renamed: EvalArena->EvalHeap, g_arena->g_heap, arena_index->heap_index,
     arena_offset->heap_offset, arena_mappings->heap_mappings,
     arena_memory_slice->heap_memory_slice, EvalArenaMapping->EvalHeapMapping
   - Updated all imports, comments, and error strings across 15+ files
   - Removed dead code: extract_vec_contents_at_offset (Rust), StrContents
     struct + extract_str_contents (both Rust and TIL)

** Issue #108: Namespace blocks for associated functions
:PROPERTIES:
:DISCOVERED: 2026-01-12
:IMPLEMENTED: 2026-02-04
:IMPACT: Unified syntax for associated functions on structs and enums
:STATUS: Fixed
:END:

*** Description
Structs could define associated functions (AFs) inline because the ~mut~ keyword
distinguishes storage fields from AFs. Enums couldn't do this - their syntax just
lists variants. Users needed a way to define AFs for enums (like ~to_str()~,
~eq()~, custom methods).

*** Solution
Added ~namespace TypeName { ... }~ blocks where AFs can be defined and associated
with a type's namespace. After init phase, namespace members are merged into the
type - other phases never see NamespaceDef.

#+begin_src til
Color := enum { Red, Green, Blue }

namespace Color {
    to_str := func(c: Color) returns Str {
        switch c {
            Color.Red   => return "red"
            Color.Green => return "green"
            Color.Blue  => return "blue"
        }
    }
}
#+end_src

Both ~Color.to_str(my_color)~ and ~my_color.to_str()~ work via UFCS.

*** Implementation Steps
1. Lexer: Added ~Namespace~ token
2. Parser: Added ~SNamespaceDef~ struct and ~NamespaceDef~ variant
3. Init: Merge namespace members into existing type's scope
4. Migrated all struct AFs to namespace blocks across codebase
5. Typer: Added check to reject FuncDef inside struct blocks
6. Dead code removal: Removed ~200 lines handling inline struct functions

*** Files Changed
- lexer.rs/til: Namespace token
- parser.rs/til: NamespaceDef parsing
- init.rs/til: Namespace merging, removed inline function registration
- typer.rs/til: Reject functions in structs
- ccodegen.rs/til: Removed emit_struct_func_prototypes/bodies
- interpreter.rs/til: Removed TFunction handling for struct members
- All core/*.til files: Migrated AFs to namespace blocks

*** Future Steps (not implemented)
- Step 3: Associated constants in namespaces (I64.Max instead of MAX_I64)
- Step 5: Per-instance immutable fields
- Step 6: Associated mutable state in namespaces

** Issue #110: Desugar switch to if/else in desugarer
:PROPERTIES:
:DISCOVERED: 2026-01-13
:IMPLEMENTED: 2026-01-31
:IMPACT: Simplify interpreter and ccodegen, reduce internal complexity
:STATUS: Fixed
:BRANCH: claude/fix-issue-110-9OxnI
:END:

*** Description
Desugar switch/case to if/else chains in the desugarer phase. This simplifies the
interpreter, ccodegen, and precomp by removing switch handling from those phases.

*** Implementation
- ~src/rs/desugarer.rs~ - added ~desugar_switch()~ and helper functions (1146 lines total)
- ~src/self/desugarer.til~ - TIL port of the same logic (2010 lines total)
- Added AST construction helpers (~make_id~, ~make_call~, ~make_str~, etc.) to reduce verbosity
- Removed switch handling from: ufcs, precomp, interpreter, ccodegen (both .rs and .til)
- Added ~enum_get_payload_type~ ext_func for nested enum pattern matching

For enum switches: uses ~enum_to_str()~ for comparison, ~enum_get_payload()~ for payloads.
For non-enum switches: uses direct ~eq()~ method calls.
Nested enum patterns use combined conditions with ~enum_get_payload_type()~.

*** Performance Impact
The switch desugaring causes a benchmark regression due to generating more code:

| Mode | Before | After (final) | Change |
|------|--------|---------------|--------|
| rust interpreted | 169.7s | 214.1s | +26% |
| rust compiled | 4.4s | 4.4s | -1% |
| til interpreted | 380.7s | 547.2s | +44% |
| til compiled | 15.4s | 25.4s | +65% |
| Total | 570.3s | 791.1s | +39% |

Trade-off: simpler code in interpreter/ccodegen/precomp at cost of runtime performance.
Future optimization: could add fast-path for enum switches avoiding string comparison.

*** Lines of Code Impact (vs master)

| Language | Files | Added | Removed | Net |
|----------|-------|-------|---------|-----|
| Rust     | 7     | +1016 | -1280   | -264 |
| TIL      | 7     | +1611 | -1380   | +231 |
| C        | 1     | +42621 | -37392 | +5229 |

Note: C changes are in bootstrap/til.c (generated from TIL self-hosted compiler).
Net effect: Rust -264 lines, TIL +231 lines = -33 source lines total.

*** Desugarer vs Old Ccodegen Size Analysis

Old ~emit_switch~ in ccodegen was 370 lines. After optimization, ~desugar_switch~ +
~build_case_condition~ is ~420 lines total (+50 lines). Initial version was 506 lines
before removing match flag bloat.

| Section | OLD (lines) | INITIAL (lines) | OPTIMIZED (lines) |
|---------|-------------|-----------------|-------------------|
| Setup/params check | 10 | 10 | 10 |
| Type/enum detection | 63 | 26 | 26 |
| Temp var + declarations | 8 | 79 | 79 |
| Hoist/scope handling | 32 | 54 | 54 |
| Nested pattern check | 0 | 16 | 0 (removed) |
| Match flag path | 0 | 66 | 0 (removed) |
| Case loop/chain | 23 | 36 | 36 |
| Pattern case | 55 | 59 | 59 |
| Range case | 27 | 14 | 14 |
| Identifier case | 39 | 19 | 19 |
| LLiteral case | 25 | (combined) | (combined) |
| FCall case | 72 | 64 | 64 |
| Nested enum combined | 0 | 0 | ~15 (new) |
| Fallback | 0 | 13 | 13 |

*** Nested Pattern Fix (COMPLETED)

Added ~enum_get_payload_type(enum_val, VariantName, PayloadType)~ ext_func that returns
the payload's enum tag as a string without extracting. This enables combined conditions:

#+begin_src til
// For: case ValueType.TType(TTypeDef.TEnumDef)
// Generates:
if and(
    _switch_variant.eq("ValueType.TType"),
    enum_get_payload_type(_switch_expr, TType, TTypeDef).eq("TTypeDef.TEnumDef")
) { ... }
#+end_src

Changes:
- Added ~enum_get_payload_type~ to ext.rs/ext.til, interpreter.rs/interpreter.til, ccodegen.rs/ccodegen.til
- Added ext_func declaration to meta.til
- Removed match flag pattern (~66 lines)
- Removed nested pattern detection pass (~16 lines)
- Fixed variable naming: set ~current_precomp_func~ in desugarer's Declaration handler

File sizes after fix:
- desugarer.rs: 1146 lines
- desugarer.til: 2010 lines

** Issue #147: Add Ptr.dereference method for cleaner pointer dereferencing
:PROPERTIES:
:DISCOVERED: 2026-01-28
:IMPLEMENTED: 2026-01-28
:IMPACT: Cleaner API for reading values from pointers
:STATUS: Fixed
:END:

*** Description
Add a ~dereference~ method to Ptr that copies the value at the pointer address
into a destination variable.

*** Implementation
#+BEGIN_SRC til
/** Dereference pointer - copy value at this address into dest. */
dereference := proc(self: Ptr, T: Type, mut dest: Dynamic) {
    memcpy(to_ptr(dest), self.data, size_of(T))
}
#+END_SRC

Note: Takes Type parameter because ~type_of~ builtin doesn't exist yet.

*** Future
Parser syntax ~*ptr~ that desugars to ~ptr.dereference(dest)~.

** Issue #131: Clang support (gcc/clang interchangeable)
:PROPERTIES:
:DISCOVERED: 2026-01-21
:IMPLEMENTED: 2026-01-26
:IMPACT: Broader platform support, developer choice
:STATUS: Fixed
:END:

*** Description
Make gcc and clang interchangeable as C compilers via ~--cc=COMPILER~ flag.

*** Implementation
Added ~--cc=COMPILER~ flag to rstil and til:
- ~--cc=clang~ to use clang instead of gcc on Linux
- Default remains gcc on Linux/Windows, clang on macOS
- Compiler-specific warning flags handled automatically:
  - GCC-only: ~-Wno-dangling-pointer~
  - Clang-only: ~-Wno-sometimes-uninitialized~, ~-Wno-self-assign~,
    ~-Wno-c23-extensions~, ~-Wno-uninitialized~, ~-Wno-unused-function~

*** Usage
To build til.til with clang (this is what fails in macOS CI):
#+begin_src bash
./bin/rstil build src/til.til --cc=clang --force-rebuild
#+end_src

To run tests with clang locally:
#+begin_src bash
./bin/rs/make tests --cc=clang
#+end_src

Note: Using ~./make.til tests --cc=clang~ does NOT work because the shebang
(~#!/usr/bin/env -S ./bin/rstil run~) causes rstil to consume the ~--cc=~ flag
for its own compilation rather than passing it to the make.til program.
Use the compiled binary ~./bin/rs/make~ directly instead.

*** Files Modified
- ~src/rstil.rs~ - parse ~--cc=~ flag, pass to build functions
- ~src/rs/builder.rs~ - accept cc parameter, use if provided
- ~src/rs/target.rs~ - add ~is_clang()~ helper, update ~toolchain_extra_args~
- ~src/til.til~ - parse ~--cc=~ flag, pass to build functions
- ~src/self/builder.til~ - accept cc parameter, use if provided
- ~src/self/target.til~ - add ~is_clang()~ helper, update ~toolchain_extra_args~
- ~make.til~ - parse ~--cc=~ flag, pass to build and test commands
- ~src/tests.til~ - parse ~--cc=~ flag, pass to test_runner
- ~src/test_runner.til~ - parse ~--cc=~ flag, add to compiled test commands

** Issue #116: Refactor Str to use len/cap pattern
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPLEMENTED: 2026-01-25
:IMPACT: Enables Str.delete() and ownership tracking
:STATUS: Fixed
:RELATED: Issue #117 (ASAP destruction depends on this)
:END:

*** Description
Str previously used ~cap~ field as length. Refactored to proper _len/cap layout
like Vec, enabling ownership tracking (cap=0 means literal/unowned, cap>0 means
heap/owned).

*** Implementation
Changed Str struct from 2 fields to 3 fields:
#+BEGIN_SRC til
Str := struct {
    mut c_string: Ptr = Ptr()  // Pointer to null-terminated C string
    mut _len: I64 = 0          // Length of string (not including null terminator)
    mut cap: I64 = 0           // Allocated capacity (0 = literal/unowned, >0 = owned)
}
#+END_SRC

Note: Field named ~_len~ (not ~len~) to avoid conflict with ~len()~ method.

*** Ownership Semantics
- ~cap = 0~: Literal/unowned - DO NOT free (points to .rodata)
- ~cap > 0~: Owned - CAN free (heap allocated)
- ~c_string.is_borrowed = 1~: Borrowed pointer (literals)
- ~c_string.is_borrowed = 0~: Owned pointer (heap allocated)

*** Changes Made
- *src/core/str.til*: Renamed ~cap~ to ~_len~, added new ~cap~ field, updated all
  allocating methods (clone, concat, format, join, repeat, get_substr, replace,
  inc, dec) to set cap and is_borrowed correctly
- *src/rs/ccodegen.rs*: Updated emit_str_literal to emit 3-field format with cap=0,
  updated emit_enum_to_str_from_variants to include cap field
- *src/self/ccodegen.til*: Same changes for TIL version
- *src/ext.c*: Updated all Str handling to use 3-field format, changed .cap reads
  to ._len for length access
- *src/rs/interpreter.rs*: Fixed string_from_context to read ~._len~ instead of ~.cap~
- *src/self/ext.til*: Fixed byte_to_str and string_from_context
- *src/rs/eval_arena.rs*: Changed insert_string functions to write length to ~._len~,
  fixed insert_string_core field name checks
- *src/self/eval_arena.til*: Same changes for TIL version
- *src/test/c_mem.til*: Updated size_of(Str) expectation from 24 to 32
- *src/test/scope_isolation.til*: Changed ~msg.cap~ to ~msg.len()~

*** ABI Change
This changed til_Str struct size from 24 to 32 bytes. Required full rebuild with
~make clean && make benchmark~.

** Issue #134: Ptr type refactor - distinguish pointer fields from I64
:PROPERTIES:
:DISCOVERED: 2026-01-23
:IMPLEMENTED: 2026-01-24
:IMPACT: Enables proper serialization of heap data, foundation for Bug #133 fix
:STATUS: Fixed
:RELATED: Bug #133 (precomputed heap values), Issue #115 (owned struct fields)
:END:

*** Description
Changed pointer fields in core structs (Vec.ptr, Str.c_string, List.data) from
type I64 to use the existing Ptr struct type. This allows ccodegen to distinguish
pointer fields from regular integers.

*** Implementation (Option A from proposal)
Used the existing ~Ptr~ type from core/ptr.til which wraps an I64 in a struct:
#+BEGIN_SRC til
Ptr := struct {
    mut data: I64 = NULL
}
#+END_SRC

*** Changes Made
- *src/core/ptr.til*: Added ~copy_from_dynamic~ and ~copy_to_dynamic~ methods
  to encapsulate memcpy with Dynamic arguments
- *src/core/vec.til*: Changed ~ptr: I64~ to ~ptr: Ptr~, updated all usages to
  use Ptr interface (is_null, delete, offset, copy_from, copy_from_dynamic, copy_to_dynamic)
- *src/core/str.til*: Changed ~c_string: I64~ to ~c_string: Ptr~, updated all
  string manipulation functions
- *src/std/list.til*: Changed ~data: I64~ to ~data: Ptr~, updated all list operations
- *src/std/map.til*: Updated to use UFCS style and Ptr.offset().data for pointer math
- *src/core/set.til*: Updated to use UFCS style and Ptr interface
- *src/std/arena.til*: Updated to use Ptr.offset().data internally
- *src/self/eval_arena.til*: Updated to pass .data when calling Arena methods
- *src/self/ext.til*: Updated byte_to_str to use Ptr.new_by_size
- *src/self/interpreter.til*: Updated to use .ptr.data for memcpy
- *src/ext.c*: Updated all c_string accesses to use .data (e.g., s->c_string.data)
- *src/rs/ccodegen.rs*: Updated size_of function to use c_string.data
- *src/test/vecs.til*: Updated tests to use is_null() instead of comparing to 0

*** Key Patterns
Old pattern -> New pattern:
- ~vec.ptr = NULL~ -> ~vec.ptr = Ptr()~
- ~malloc(size)?~ catch BadAlloc panic -> ~Ptr.new_by_size(size)~
- ~if gt(self.ptr, 0)~ -> ~if not(self.ptr.is_null())~
- ~free(self.ptr)~ -> ~self.ptr.delete()~
- ~add(self.ptr, offset)~ -> ~self.ptr.offset(offset).data~
- ~memcpy(dest, to_ptr(value), size)~ -> ~dest.copy_from_dynamic(value, size)~
- ~memcpy(to_ptr(T), src, size)~ -> ~src.copy_to_dynamic(T, size)~

*** Testing
All 91 tests pass in all 4 modes (rs_interpreted, rs_compiled, til_interpreted, til_compiled).

** Issue #119: Skip empty struct error parameters in C codegen
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPLEMENTED: 2026-01-24
:IMPACT: Smaller generated C code, simpler function signatures
:STATUS: Fixed
:END:

*** Description
When a throws clause uses an empty struct (like BadAlloc), the C codegen no longer
passes a pointer to the error struct as a parameter. For empty structs, only the
return status code matters (0 = success, 1+ = error type index).

*** Implementation
- Added ~is_empty_error_struct~ helper to check if error type has no fields
- ~emit_func_signature~ skips error parameters for empty structs
- ~emit_throwing_call~, ~emit_throwing_call_propagate~, ~emit_throwing_call_with_goto~
  skip declaring, passing, and copying empty struct errors
- Catch blocks use ~= {}~ initializer for empty struct error bindings
- Updated ~til_malloc~ in src/ext.c to match new signature

*** Files Modified
- src/rs/ccodegen.rs: Added empty struct error handling throughout
- src/self/ccodegen.til: Ported same changes
- src/ext.c: Removed unused error parameter from til_malloc

*** Incomplete Port Note (discovered during Bug #136)
The initial port to ccodegen.til was incomplete - it was missing the "skip copying
empty struct errors" checks in many places. The Rust version (ccodegen.rs) had about
20 locations with Issue #119 checks, but ccodegen.til only had a few. During Bug #136
work, we discovered the gap when til_compiled tests failed with wrong argument counts
to til_malloc. The remaining ~8 locations were added to ccodegen.til:
- Local catch error copying (goto blocks)
- Error propagation copying (return blocks)
- Throw statement error assignments
- Catch body error variable bindings

** Issue #132: Mandatory ? for calls to throwing functions [DONE]
:PROPERTIES:
:DISCOVERED: 2026-01-22
:COMPLETED: 2026-01-23
:IMPACT: Explicit error propagation, catches sneaky throws at compile time
:STATUS: Fixed
:RELATED: Bug #54 (precomp_throw divergence)
:END:

*** Description
Make ~?~ mandatory at call sites for functions that throw.
- ~myvec.get(i)?~ instead of ~myvec.get(i)~
- Typer enforces: call to throwing function without ~?~ = type error

*** Syntax
- ~foo()?~ - foo throws
- ~foo().bar()?~ - only bar throws
- ~foo()?.bar()~ - only foo throws
- ~foo()?.bar()?~ - both throw

*** Implementation
- Lexer: Added ~QuestionMark~ token for ~?~
- Parser: Added ~does_throw: bool~ field to FCall, consumed ~?~ after ~)~
- Typer: Check ~does_throw~ matches function's throws clause
- All phases updated to handle ~FCall(bool)~ pattern
- All .til files updated with ~?~ on throwing calls (~4000+ changes)

** Issue #127: Pipeline refactoring - Add Desugarer and UFCS phases [DONE]
:PROPERTIES:
:DISCOVERED: 2026-01-19
:COMPLETED: 2026-01-20
:IMPACT: Cleaner architecture, single-pass type inference, easier maintenance
:STATUS: Fixed
:END:

*** Description
Refactor the compilation pipeline to separate concerns. See doc/pipeline.org
for full details including current vs target state and migration TODOs.

*** Current Problems
- Precomp is overloaded: UFCS + forin + switch + const-folding + macros
- Typer only validates, doesn't annotate AST with resolved types
- Later phases re-infer types repeatedly
- Parser desugars range for directly (should just build AST)

*** Target Pipeline
Lexer -> Parser -> Mode -> Init -> Typer -> Desugarer -> UFCS -> Precomp -> Scavenger -> Build/Interpret

Where:
- Typer: validates AND annotates AST with resolved types (no later phase infers)
- Desugarer: desugar forin, switch, range for (needs type info)
- UFCS: desugar x.method(y) -> Type.method(x, y)
- Precomp: const-folding, macros only

*** Related Issues
- Issue #110: Switch desugaring (will move to Desugarer phase)

*** Commit 1: Separate Desugarer phase from Precomp [DONE]

**** Overview
Create new desugarer phase that handles ForIn desugaring. Currently precomp
does desugaring inline during its recursive pass. The new design runs desugarer
as a separate pass before precomp.

**** Completion Notes
- Key fix: Do NOT declare loop variable in scope_stack during desugaring.
  The desugarer just transforms AST; declaring variables was leaking type
  information across files during batch compilation (caused custom_type_name
  in interpreter.til to be incorrectly typed as SymbolEntry from eval_arena.til's
  for-in loop over SymbolEntry).

**** Post-completion fix: Counter reset for determinism (2026-01-21)
When ForIn desugaring was moved from precomp to desugarer, the per-function
counter reset logic was NOT moved along with it. This caused non-deterministic
temp variable names (~_for_i_N~) in generated C code.

precomp.rs had this pattern for FuncDef processing:
#+BEGIN_SRC rust
let saved_counter = context.precomp_forin_counter;
context.precomp_forin_counter = 0;
// ... process function body ...
context.precomp_forin_counter = saved_counter;
#+END_SRC

But desugarer.rs was missing it. Fix: Added the same save/reset/restore pattern
to ~desugar_expr~ FuncDef handling in both desugarer.rs and desugarer.til.

**** Files to create
- src/rs/desugarer.rs - Rust implementation
- src/self/desugarer.til - TIL implementation (port from Rust)

**** Code to move from precomp.rs to desugarer.rs
1. transform_continue_with_step() - Bug #57 fix for continue in for-in loops
2. build_default_value() - Creates default values for enum payloads
3. precomp_forin() -> desugar_forin() - The actual ForIn desugaring logic

**** New entry point: desugar_expr()
Recursive function that:
- Handles NodeType::ForIn by calling desugar_forin()
- Recurses into FuncDef bodies (methods need desugaring too)
- Recurses into StructDef default values (may contain function defs)
- For all other nodes, recurses into params

**** Changes to precomp.rs
- Remove transform_continue_with_step, build_default_value, precomp_forin
- Replace ForIn case with panic:
  NodeType::ForIn(_) => panic!("ForIn should have been desugared")

**** Changes to interpreter.rs
- Add: use crate::rs::desugarer::desugar_expr;
- Before each precomp_expr call, add: e = desugar_expr(context, &e)?;

**** Changes to builder.rs
- Before each precomp_expr call, add desugar_expr call

**** Changes to rstil.rs
- Add: pub mod desugarer; (between typer and precomp)

**** TIL port (desugarer.til)
- Port all functions following doc/rs2til.org translation rules
- Import: import("self.init")
- Entry: desugar_expr proc

**** Changes to precomp.til
- Remove desugar-related functions
- Replace ForIn case with panic

**** Changes to interpreter.til, builder.til
- Add: import("self.desugarer")
- Call desugar_expr before precomp_expr

**** Verification
Run: make benchmark
All tests must pass.

*** Commit 2: Separate UFCS phase from Precomp [DONE]

**** Overview
Create new ufcs phase that handles UFCS desugaring. Currently precomp does
UFCS resolution inline in precomp_fcall. The new design runs ufcs as a
separate pass after desugarer, before precomp.

**** Completion Notes
- Key fix: U8 type annotation handling must be in ufcs_declaration, not just
  precomp_declaration. When `mut val : U8 = 41`, the literal 41 infers as I64
  but must be registered as U8 so UFCS transforms `val.inc()` to `U8.inc(val)`.
- TIL port required renaming `ufcs_func_def` variable in typer.til to `ufcs_fn_def`
  to avoid collision with the new ufcs_func_def function (TIL has global scope).

**** Files to create
- src/rs/ufcs.rs - Rust implementation
- src/self/ufcs.til - TIL implementation (port from Rust)

**** Code to move from precomp.rs to ufcs.rs
From precomp_fcall():
1. UFCS for chained calls (lines ~1176-1200): func(result, args) -> Type.func(result, args)
2. UFCS with dot notation (lines ~1202-1250): a.method(b) -> Type.method(a, b)
3. Named argument reordering (reorder_named_args function)

**** New entry point: ufcs_expr()
Recursive function that:
- Handles NodeType::FCall by resolving UFCS and reordering named args
- Recurses into FuncDef bodies
- Recurses into StructDef default values
- For all other nodes, recurses into params

**** Changes to precomp.rs
- Remove UFCS resolution code from precomp_fcall
- Remove reorder_named_args function
- precomp_fcall only handles: comptime intrinsics, struct/enum constructors, import()

**** Changes to interpreter.rs
- Add: use crate::rs::ufcs::ufcs_expr;
- Pipeline becomes: typer -> desugarer -> ufcs -> precomp

**** Changes to builder.rs
- Pipeline becomes: typer -> desugarer -> ufcs -> precomp

**** Changes to rstil.rs
- Add: pub mod ufcs; (between desugarer and precomp)

**** TIL port (ufcs.til)
- Port all functions following doc/rs2til.org translation rules

**** Verification
Run: make benchmark
All tests must pass.

** Issue #69: Test Organization - all_common category
:PROPERTIES:
:DISCOVERED: 2025-12-31
:IMPACT: Test infrastructure, rstil/til output validation
:STATUS: Fixed
:FIXED: 2026-02-11
:RELATED: Bug #126 (error message divergence), Bug #100 (get rid of rstil)
:END:

*** Background
Tests that pass with BOTH rstil and til (with identical output) need a category
that runs all modes. Previously tests were either in ~rs_common~ (rstil only)
or ~til_interpreted~ (til only), with no way to verify identical behavior.

*** Solution Implemented
Added ~all_common~ category in tests.til that runs 4 modes:
- rs_interpreted (rstil interpret)
- rs_compiled (rstil run)
- til_interpreted (til interpret)
- til_compiled (til run)

*** Test Categorization Strategy
- ~all_common~: Tests producing identical output across all 4 modes (67 tests)
- ~rs_common~: Tests that pass with rstil but have different output from til
- ~til_common~: Tests that pass with til but have different output from rstil
- ~rs_interpreted~, ~rs_compiled~: Mode-specific tests
- Empty categories are skipped in benchmark output

*** Error Message Divergence (Bug #126)
Tests with expected failures (expected_status != 0) often can't go in all_common
because rstil and til produce different error messages. Common divergences:
- Debug markers (" b", " c", " d") in Rust not ported to TIL
- Different code paths triggered between implementations
- Different error collection/reporting order

Such tests must go in BOTH rs_common AND til_common with separate expected
output files. See sugar.til for an example.

*** Example: bug50 (RESOLVED)
bug50.til produced ~rstil type ERROR~ vs ~til type ERROR~ (binary name in output).
Fixed by unifying LANG_NAME to "til" in both src/rs/lexer.rs and src/self/lexer.til.
bug50.til now in all_common (2026-01-22).

*** Progress
Tests moved to all_common:
- panic.til (2026-01-22): Error messages now identical after Bug #126 fixes
- bug50.til (2026-01-22): LANG_NAME unified to "til" in both implementations
- sugar.til (2026-02-11): Fixed spurious println! in init.rs UFCS error handling

*** Fix Details (sugar.til)
Root cause: init.rs had two ~println!()~ calls (at the "struct has no member c"
and "struct has no member (variadic)" error paths) that printed intermediate UFCS
errors before returning a different error. The TIL equivalent correctly discarded
the intermediate error. Removed the printlns so all 4 modes produce identical output.
sugar.til moved from rs_common + til_common to all_common. til_common now empty.

*** Benchmark Annotations
4-phase all_common tests will show timing comparisons:
- ~(rstil: faster interpreted)~ or ~(rstil: faster compiled)~ - comparing rstil modes
- ~(interpreted: faster rstil)~ or ~(interpreted: faster til)~ - comparing interpreters
- ~(compiled: faster rstil)~ or ~(compiled: faster til)~ - comparing compilers

*** Files Modified
- src/tests.til: Added all_common Vec, processing in run_all_tests(), updated usage()
* Implemented Issues

** Issue #193: Remove `copy` parameter mode (desugar to `own` + caller `.clone()`)
:PROPERTIES:
:DISCOVERED: 2026-02-26
:IMPLEMENTED: 2026-02-26
:IMPACT: Simplifies compiler -- 531 net lines removed from source
:STATUS: Fixed
:END:

Removed ~copy~ parameter mode entirely. It was syntactic sugar: the garbager
auto-inserted ~.clone()~ at call sites. Users can achieve the same with ~own~
params and explicit ~.clone()~ at the call site. Can be re-added as a desugarer
pass if desired.

What was removed:
- ~is_copy~ field from Declaration (ast.rs) and SymbolInfo (init.rs/init.til)
- ~TokenType::Copy~ keyword from lexer (Rust + TIL)
- Copy param parsing and ~validate_mut_copy_own_modifiers~ from parser (Rust + TIL)
- Clone-check validation block from type checker (Rust + TIL)
- ~transform_fcall_copy_params()~ function from garbager (Rust + TIL)
- Copy-specific by-value passing from ccodegen (Rust + TIL)
- ~is_copy~ boilerplate propagation from precomp, interpreter, desugarer, preinit, eval_heap, ufcs
- Copy param tests from ~src/test/args.til~
- Copy row from ~doc/modifiers.org~ modifier table

Total: 321 ~is_copy~ references across 23 files eliminated. 838 lines removed, 307 added (531 net).

** Issue #120: Str.ends_with() and Str.starts_with()
:PROPERTIES:
:DISCOVERED: 2026-01-15
:IMPLEMENTED: 2026-01-20
:IMPACT: Common string operations, needed for file filtering and pattern matching
:STATUS: Fixed
:END:

*** Description
Convenience functions to check if a string starts or ends with a given substring.
These are fundamental string operations found in virtually every language.

*** Implementation
- ~starts_with(s, prefix)~ in src/core/str.til:563-579
- ~ends_with(s, suffix)~ in src/core/str.til:582-599
- Tests in src/test/strings.til:37-56

*** Use cases
- File extension filtering: ~filename.ends_with(".til")~
- Path checking: ~path.starts_with("/home/")~
- Protocol detection: ~url.starts_with("https://")~
- Suffix stripping: ~if name.ends_with("Error") { ... }~

** Bug #144: for-in loops iterate by copy instead of by reference
:PROPERTIES:
:DISCOVERED: 2026-01-27
:IMPACT: Performance overhead, breaks pointer identity assumptions
:STATUS: FIXED (2026-02-14)
:RELATED: Bug #143 (hoisted_exprs identity depends on this), Issue #117 Step 9.3
:END:

*** Description
For-in loops copy each element via ~get()~. With Step 10 (auto-delete), the
local copy's ~delete()~ would corrupt the container (double-free).

*** Fix (2026-02-14)

Two commits:

*Commit 1* (44715b46): Unified ALL for-in loops (including primitives) to use
~get_by_ref~ + ~create_alias~. Desugared for-in is now:
#+BEGIN_SRC til
_ref_forin_N := get_by_ref(vec, _for_i_func_N)
catch (_err_forin_N: IndexOutOfBoundsError) { panic(loc(), _err_forin_N.msg) }
create_alias(item, MyStruct, _ref_forin_N.data)
#+END_SRC

*Commit 2*: Fixed ccodegen to use C99 block scoping for create_alias variables.
The old approach hoisted pointer declarations with ~is_pointer~ flag, which
broke when the same variable name appeared as both a create_alias target (pointer)
in one scope and a normal value-type variable in another scope of the same function.
New approach: create_alias always emits inline ~Type* var;~ inside the loop body,
which C99 block scoping shadows over any outer hoisted ~Type var;~. Added
save/restore of ~current_ref_params~ around emit_body/emit_if/emit_while/catch
to scope pointer semantics correctly.

Generated C for a for-in over Expr is truly zero-copy:
#+BEGIN_SRC c
til_Vec_get_by_ref(&_ref_forin_0, &_err0, &params, &_for_i_0);
til_Expr* til_Expr_child;
til_Expr_child = (til_Expr*)_ref_forin_0.data;  // pointer, no memcpy
#+END_SRC

Verified in generated til.c: all 367 for-in loops use get_by_ref + pointer
cast, no copies. Performance improvement is negligible because the avoided
memcpy was always cheap relative to the work done inside loop bodies.

Every phase with scope tracking recognizes create_alias as a variable
declaration: init, typer, ufcs, precomp, ccodegen, interpreter (ext.rs).

*** Design notes

**** create_alias API
~create_alias(var_identifier: Dynamic, type_name: Type, source_addr: I64)~

Declared in ~src/core/mem.til~ as ext_func. The ~Dynamic~ parameter is the
variable name (unevaluated identifier). The ~Type~ parameter follows the
same convention as ~size_of(type: Type)~.

**** How each phase handles create_alias
Each phase that maintains a scope_stack must recognize ~create_alias~ FCall
nodes and call ~declare_symbol(var_name, TCustom(type_name))~:
- **Init**: declares variable (only reaches root-level create_alias)
- **Typer**: validates type exists, declares variable, type-checks addr expr
- **UFCS**: declares variable so ~item.method()~ resolves correctly
- **Precomp**: declares variable so ~get_value_type~ lookups work
- **Interpreter** (ext.rs): declares symbol + inserts arena var at addr
- **CCodegen**: emits inline pointer decl + cast from addr (C99 block scoping)

**** TIL's design principle at play
TIL defaults to by-const-ref for function args  no ~&~, no annotations, most
efficient is the default with least syntax. For-in follows the same principle:
~for item: T in vec~ is by const ref, zero-copy. Rust needs ~for item in &vec~
or ~for item in vec.iter()~  TIL drops that ceremony.

If copy semantics are later needed in for-in, add ~copy~ explicitly (like args).

*** Files modified
- ~src/rs/desugarer.rs~ + ~src/self/desugarer.til~ - for-in desugaring
- ~src/rs/garbager.rs~ + ~src/self/garbager.til~ - strip ~dont_delete~ from Body nodes
- ~src/rs/ccodegen.rs~ + ~src/self/ccodegen.til~ - C99 block scoped pointer decls
- ~src/core/array.til~ - added ~Array.get_by_ref~
- ~src/core/set.til~ - added ~Set.get_by_ref~

** Bug #177: ccodegen missing =*_ret= for cast returns -- FIXED 2026-02-20
:PROPERTIES:
:DISCOVERED: 2026-02-19
:FIXED: 2026-02-20
:IMPACT: Compiler error (-Werror=unused-parameter) in generated C; return value never written
:RELATED: Bug #168 (ret_var_alias optimization)
:END:

*** Root cause
The =find_ret_var_for_placement= optimization (Bug #168) is incompatible with cast
variables. It aliases a return variable to =_ret= via =resolve_var_name=, but cast
declarations use =til_var_name_from_context= directly, bypassing the alias. This means:
- Cast declaration writes to =til_t= (real name)
- All reads go through =resolve_var_name= mapping =t= -> =_ret= (uninitialized)
- =emit_return= sees the alias match, skips =*_ret= assignment, emits bare =return 0;=

*** Fix
Clear =ctx.ret_var_alias= in =emit_declaration= when a cast variable matches the alias.
After clearing, =resolve_var_name= returns the real name, and =emit_return= falls through
to the normal path: =*_ret = (*til_t);= which correctly dereferences the cast pointer.

*** Files modified
- ~src/rs/ccodegen.rs~ + ~src/self/ccodegen.til~ - clear ret_var_alias for cast vars
- ~src/self/lexer.til~ - removed 4 =.clone()= workarounds

** Bug #114: ScopeStack lookup functions leak memory by copying entire ScopeFrame -- FIXED 2026-02-20
:PROPERTIES:
:DISCOVERED: 2026-01-15
:FIXED: 2026-02-20
:IMPACT: Memory leak in self-hosted interpreter, grows with scope depth and lookup frequency
:END:

*** Summary
All ScopeStack lookup/has functions copied entire ScopeFrame objects (5 Maps each)
on every iteration, plus Map.get within lookups copied the found value.

*** Fix history
1. *has_* methods* (2026-01-29): Added has_var/symbol/func/enum/struct to avoid
   copying definition objects when only checking existence.
2. *Zero-copy Expr.get()* (2026-02-14): Replaced =.params.get(i, var)= with
   =.get(i)= + =dont_delete(var)= across all 11 TIL self-hosted files. 490 copies eliminated.
3. *Zero-copy ScopeFrame iteration* (2026-02-14): All 23 ScopeStack lookup/has functions
   converted from =frames.get(i, frame)= to =get_by_ref= + =create_alias= (now =cast=).
4. *Zero-copy Map lookups* (2026-02-20): Removed =Map.get= entirely. All 6 callers in
   init.til converted to =get_by_ref= + =cast=. Map.get removed from garbager whitelist.
