#+TITLE: TIL Optimizations - Future Improvements
# BOT: New issues use next number from doc/todo/next_issue_num.txt, then increment it,
# BOT: add them at the top of pending optimizations, when done, move them to the top of completed

* Overview

This document tracks potential optimizations that could improve generated code
size or runtime performance. These are not bugs - the code works correctly,
but could be more efficient.

* Pending Optimizations

** Optimization #51: Precomp doesn't propagate constants through function parameters
:PROPERTIES:
:DISCOVERED: 2025-12-19
:IMPACT: Missed compile-time optimizations, larger generated code
:STATUS: Open
:END:

*** Description
When a function is called with literal arguments, the parameters inside the
function body are not treated as compile-time constants, preventing constfolding.

*** Example
#+BEGIN_SRC til
test_equal := proc(s1: Str, s2: Str) {
    preffix := "\nPara "
    for_whom := preffix.concat(s1).concat(s2)  // NOT folded
    ...
}
test_equal("lo", "la")  // Called with literals
#+END_SRC

Even though ~test_equal("lo", "la")~ passes literals, inside the function:
- ~preffix~ is a literal -> comptime
- ~s1~, ~s2~ are parameters -> NOT comptime
- ~preffix.concat(s1)~ cannot fold because ~s1~ isn't comptime

*** Reproducing
#+BEGIN_SRC bash
./bin/rstil run src/examples/lolalalo.til
# Inspect gen/c/examples/lolalalo.c line 771:
# til_for_whom = til_concat(til_concat(til_preffix, til_s1), til_s2);
# Should be: til_for_whom = ((til_Str){(til_I64)"\nPara lola", 10});
#+END_SRC

*** Root Cause
In ~precomp_func_def~ (src/rs/precomp.rs:749):
#+BEGIN_SRC rust
is_comptime_const: false,  // Function args are not comptime constants
#+END_SRC

Function parameters are unconditionally marked as non-comptime, even when
the function is called exclusively with literal arguments.

*** Deeper Analysis (2025-12-26)

The core insight: *comptime-ness of parameters should be per-call, not per-function*.

#+BEGIN_SRC til
test_equal("lo", "la")      // s1, s2 SHOULD be comptime here
test_equal(get_input(), "la")  // s1 NOT comptime, s2 IS comptime
#+END_SRC

**** Why current design can't support this

1. *Original body discarded*: ~precomp_func_def~ transforms the body once at
   definition time. After transformation, the original untransformed body is gone.

2. *Parameters marked once*: At definition time, we don't know what arguments
   will be passed. So parameters are marked as non-comptime unconditionally.

3. *No per-call mechanism*: When a call like ~test_equal("lo", "la")~ is seen,
   we know the args are comptime, but the body was already transformed without
   that knowledge.

**** The architectural gap

#+BEGIN_EXAMPLE
Definition time:                    Call time:
  precomp_func_def                    precomp_fcall
    -> params: is_comptime=false        -> args are literals (comptime!)
    -> transform body                   -> but body already transformed
    -> discard original                 -> can't re-transform with comptime params
#+END_EXAMPLE

*** Potential Solution: Store Original Body + Per-Call Transformation

**** Step 1: Modify SFuncDef to preserve original body

#+BEGIN_SRC rust
pub struct SFuncDef {
    // ... existing fields ...
    pub body: Vec<Expr>,
    pub original_body: Option<Vec<Expr>>,  // NEW: preserved for per-call transform
}
#+END_SRC

**** Step 2: Per-call body transformation

When processing a function call, if any argument is comptime:
1. Look up the ~original_body~ (untransformed)
2. Create a scope where each param's comptime-ness matches the call arg's comptime-ness
3. Transform the original body in this new scope
4. Use/cache this specialized version for codegen

#+BEGIN_SRC rust
fn precomp_body_with_comptime_params(
    context: &mut Context,
    original_body: &[Expr],
    args: &[Declaration],
    call_args: &[Expr],
) -> Result<Vec<Expr>, String> {
    context.scope_stack.push(ScopeType::Function);
    for (i, arg) in args.iter().enumerate() {
        let is_comptime = is_comptime_evaluable(context, &call_args[i]);
        context.scope_stack.declare_symbol(arg.name.clone(), SymbolInfo {
            is_comptime_const: is_comptime,  // Per-call!
            // ...
        });
    }
    // Transform body with this call's parameter context
    // ...
}
#+END_SRC

**** Challenges

- *Multiple versions*: Different call sites may need different specialized bodies
- *Caching*: Need to cache by comptime pattern to avoid redundant transformation
- *Codegen*: Need to generate unique function names for each specialized version
- *Recursion*: Recursive functions need careful handling to avoid infinite loops

*** Workaround
None - this is an optimization issue, not a correctness bug. Code runs correctly
but with larger generated code and more runtime computation than necessary.

*** Related
- Bug #50 (Fixed): Similar pattern - both require per-call analysis instead of once-at-definition
- #51 is about per-call comptime-ness (precomp phase)
- #50 was about per-call variable capture (codegen phase) - now fixed by forbidding closures

* Completed Optimizations

(None yet)
