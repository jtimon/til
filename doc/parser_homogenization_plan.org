#+TITLE: Parser Homogenization Plan - Detailed Roadmap
#+AUTHOR: TIL Self-Hosting Project
#+DATE: 2025-11-09

* Overview

Goal: Restore 100% structural equivalence between parser.til and parser.rs.

Direction: **Rust → TIL** (parser.rs is source of truth, parser.til must match)

Current Status: ~60% equivalent (diverged during recent StrMap→Map refactoring)

Target Status: 100% equivalent (same data structures, same algorithms, comments aligned)

* Root Cause Analysis

** What Happened
During recent work to implement the generic Map class (replacing StrMap),
parser.til was updated to use Map, but the changes went beyond simple
replacement:

1. SStructDef.members changed from storing Declaration info to string→string
2. SFuncDef.args changed from storing Declaration array to string→string Map
3. SEnumDef.enum_map changed to store string payloads instead of ValueType
4. Parse functions simplified to not populate full metadata

** Why It's a Problem
- TIL and Rust parsers no longer produce equivalent internal structures
- TIL's simplified structures lose type information
- Homogenization goal is to have identical implementations (modulo syntax)
- Later stages (init, typer) may rely on complete metadata

** Why Tests Still Pass
The test suite passes because:
- Later compilation stages (init.til, typer.til) compensate for missing data
- The AST structure (NodeType/Expr) is still correct
- Only the metadata structs (SFuncDef, SStructDef, etc.) are incomplete

* Critical Divergences (Priority Order)

** Priority 1: Data Structure Definitions

*** 1.1 SEnumDef Struct

*Current TIL (WRONG):*
#+BEGIN_SRC til
SEnumDef := struct {
    mut enum_map: Map = Map.new("Str", size_of(Str), "Str", size_of(Str))
    // variant_name → payload_type_name (empty string = no payload)
}
#+END_SRC

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub struct SEnumDef {
    pub enum_map: HashMap<String, Option<ValueType>>,
}
#+END_SRC

*Required Fix:*
- Change Map<Str,Str> to Map<Str, ValueType>
- Store actual ValueType enum values, not strings
- Use special "None" ValueType or enum variant for no-payload cases
- OR: Store array of tuples (variant_name, Option<payload_type>)

*** 1.2 SStructDef Struct

*Current TIL (WRONG):*
#+BEGIN_SRC til
SStructDef := struct {
    mut members: Map = Map.new("Str", size_of(Str), "Str", size_of(Str))
    mut default_value_fields: Array = Array()
    mut default_value_exprs: Array = Array()
    mut default_values: Map = Map.new("Str", size_of(Str), "Str", size_of(Str))
}
#+END_SRC

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub struct SStructDef {
    pub members: Vec<(String, Declaration)>,  // field with full Declaration
    pub default_values: HashMap<String, Expr>,
}
#+END_SRC

*Required Fix:*
- Remove: default_value_fields, default_value_exprs arrays
- Change members from Map<Str,Str> to Array of (name, Declaration) tuples
- Keep default_values as Map<Str, Expr>
- Store full Declaration objects (name, type, is_mut) not just type strings

*** 1.3 SFuncDef Struct

*Current TIL (WRONG):*
#+BEGIN_SRC til
SFuncDef := struct {
    mut function_type: FunctionType = FunctionType.FTFunc
    mut args: Map = Map.new("Str", size_of(Str), "Str", size_of(Str))
    mut return_types: Array = Array()
    mut throw_types: Array = Array()
    mut body: Expr = Expr()
}
#+END_SRC

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub struct SFuncDef {
    pub function_type: FunctionType,
    pub args: Vec<Declaration>,       // full Declaration objects
    pub returns: Vec<ValueType>,      // full ValueType enums
    pub throws: Vec<ValueType>,
    pub body: Vec<Expr>,              // Vec of Expr
}
#+END_SRC

*Required Fix:*
- Change args from Map<Str,Str> to Array of Declaration
- Change return_types from generic Array to Array of ValueType
- Change throw_types from generic Array to Array of ValueType
- Change body from single Expr to Array of Expr (or keep as Expr if functionally same)
- Store full typed information, not string representations

*** 1.4 ValueType Enum

*Current TIL (INCOMPLETE):*
#+BEGIN_SRC til
ValueType := enum {
    TFunction,      // No payload
    TType,          // No payload
    TCustom: Str,
    TMulti,         // No payload
}
#+END_SRC

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub enum ValueType {
    TFunction(FunctionType),  // Includes function type
    TType(TTypeDef),          // Includes typedef variant
    TCustom(String),
    TMulti(String),           // Includes type name
}
#+END_SRC

*Required Fix:*
- Add FunctionType payload to TFunction variant
- Add TTypeDef payload to TType variant
- Add String payload to TMulti variant (type name)
- Update all code that constructs/matches ValueType

** Priority 2: Parse Function Implementation

*** 2.1 parse_func_proc_args

*Current TIL (INCOMPLETE):*
- Function only validates syntax
- Doesn't build or return Declaration array
- Line 851-962 in parser.til

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn parse_func_proc_args(lexer: &mut Lexer) -> Result<Vec<Declaration>, String> {
    let mut args : Vec<Declaration> = Vec::new();
    // ... builds and returns Declaration vector
}
#+END_SRC

*Required Fix:*
- Change return type from void to Array (of Declaration)
- Build Declaration array while parsing
- Return the array
- Each Declaration needs: name, value_type (as ValueType enum), is_mut flag

*** 2.2 func_proc_returns

*Current TIL (name: parse_func_proc_returns):*
- Line 1123-1180 in parser.til
- Returns Array but may store as strings

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn func_proc_returns(lexer: &mut Lexer) -> Result<Vec<ValueType>, String>
#+END_SRC

*Required Fix:*
- Ensure returns Array of ValueType enums, not strings
- Parse type names and convert to ValueType using str_to_value_type()

*** 2.3 func_proc_throws

*Current TIL (name: parse_func_proc_throws):*
- Line 1182-1239 in parser.til
- Similar to returns

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn func_proc_throws(lexer: &mut Lexer) -> Result<Vec<ValueType>, String>
#+END_SRC

*Required Fix:*
- Same as func_proc_returns above
- Return Array of ValueType enums

*** 2.4 parse_func_proc_definition

*Current TIL (INCOMPLETE):*
- Line 965-1121 in parser.til
- Creates SFuncDef but doesn't populate args/returns/throws properly

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn parse_func_proc_definition(lexer, function_type, do_parse_body)
    -> Result<Expr, String> {
    // ...
    let args = parse_func_proc_args(lexer)?;
    let returns = func_proc_returns(lexer)?;
    let throws = func_proc_throws(lexer)?;
    let func_def = SFuncDef {
        function_type,
        args,      // Vec<Declaration>
        returns,   // Vec<ValueType>
        throws,    // Vec<ValueType>
        body,
    };
}
#+END_SRC

*Required Fix:*
- Call parse_func_proc_args() and store result in func_def.args
- Call func_proc_returns() and store result in func_def.returns
- Call func_proc_throws() and store result in func_def.throws
- Pass fully populated SFuncDef to NodeType.FuncDef

*** 2.5 parse_struct_definition

*Current TIL (WRONG STRUCTURE):*
- Line 1383-1452 in parser.til
- Uses Map for members (string→string with "mut:" prefix hack)
- Uses parallel arrays for default values

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn parse_struct_definition(lexer) -> Result<Expr, String> {
    let mut members: Vec<(String, Declaration)> = Vec::new();
    let mut default_values: HashMap<String, Expr> = HashMap::new();
    // ...
    members.push((decl.name.clone(), decl.clone()));
    if has_default {
        default_values.insert(decl.name.clone(), val.clone());
    }
}
#+END_SRC

*Required Fix:*
- Remove "mut:" and "const:" prefix hack
- Change members to Array of (name, Declaration) tuples
- Remove default_value_fields and default_value_exprs arrays
- Keep default_values as Map<Str, Expr>
- Store full Declaration with is_mut field

*** 2.6 enum_definition

*Current TIL (STRING PAYLOADS):*
- Line 1455-1534 in parser.til
- Stores payload types as strings in Map

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
fn enum_definition(lexer) -> Result<Expr, String> {
    let mut enum_map: HashMap<String, Option<ValueType>> = HashMap::new();
    // ...
    if has_payload {
        enum_map.insert(variant_name, Some(str_to_value_type(type_name)));
    } else {
        enum_map.insert(variant_name, None);
    }
}
#+END_SRC

*Required Fix:*
- Change enum_map from Map<Str,Str> to Map<Str, Option<ValueType>>
- Convert type strings to ValueType using str_to_value_type()
- Use None for variants without payloads (not empty string)

** Priority 3: Helper Functions

*** 3.1 str_to_value_type

*Current TIL:*
- Line 188-216 in parser.til
- Returns ValueType but without payloads

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub fn str_to_value_type(arg_type: &str) -> ValueType {
    match arg_type {
        "func" => ValueType::TFunction(FunctionType::FTFunc),
        "proc" => ValueType::TFunction(FunctionType::FTProc),
        // ...
    }
}
#+END_SRC

*Required Fix:*
- Add payload construction for TFunction variants
- Add payload for TType variants
- Add payload for TMulti if needed
- Match Rust's string→ValueType mapping exactly

*** 3.2 value_type_to_str

*Current TIL:*
- Line 168-186 in parser.til
- Doesn't extract payloads from ValueType

*Rust (CORRECT TARGET):*
#+BEGIN_SRC rust
pub fn value_type_to_str(arg_type: &ValueType) -> String {
    match arg_type {
        ValueType::TFunction(FunctionType::FTFunc) => "func".to_string(),
        ValueType::TFunction(FunctionType::FTProc) => "proc".to_string(),
        // ...
    }
}
#+END_SRC

*Required Fix:*
- Extract payloads from ValueType enums
- Match on payload values
- Return appropriate string representations

* Implementation Plan

** Phase 1: Update Data Structure Definitions (Day 1)

*** Task 1.1: ValueType Enum
- [ ] Add FunctionType payload to TFunction
- [ ] Add TTypeDef payload to TType
- [ ] Add String payload to TMulti
- [ ] Test: Create ValueType instances with payloads

*** Task 1.2: SEnumDef Struct
- [ ] Change enum_map type to store ValueType (or Option<ValueType>)
- [ ] Test: Create SEnumDef with ValueType payloads

*** Task 1.3: SStructDef Struct
- [ ] Change members to Array of (String, Declaration) tuples
- [ ] Remove default_value_fields and default_value_exprs
- [ ] Keep default_values as Map<Str, Expr>
- [ ] Test: Create SStructDef with Declaration tuples

*** Task 1.4: SFuncDef Struct
- [ ] Change args to Array of Declaration
- [ ] Change return_types to Array of ValueType
- [ ] Change throw_types to Array of ValueType
- [ ] Test: Create SFuncDef with typed arrays

** Phase 2: Update Helper Functions (Day 1-2)

*** Task 2.1: str_to_value_type
- [ ] Add FunctionType payload construction
- [ ] Add TTypeDef payload construction
- [ ] Add TMulti payload if needed
- [ ] Test: Convert all type strings

*** Task 2.2: value_type_to_str
- [ ] Extract and match on payloads
- [ ] Return correct string representations
- [ ] Test: Round-trip conversion

** Phase 3: Update Parse Functions (Day 2)

*** Task 3.1: parse_func_proc_args
- [ ] Change return type to Array of Declaration
- [ ] Build Declaration array while parsing
- [ ] Return the array
- [ ] Test: Parse function with multiple args

*** Task 3.2: func_proc_returns
- [ ] Ensure returns Array of ValueType
- [ ] Use str_to_value_type() for conversion
- [ ] Test: Parse multiple return types

*** Task 3.3: func_proc_throws
- [ ] Same as func_proc_returns
- [ ] Test: Parse multiple throw types

*** Task 3.4: parse_func_proc_definition
- [ ] Call parse_func_proc_args() and store result
- [ ] Call func_proc_returns() and store result
- [ ] Call func_proc_throws() and store result
- [ ] Populate SFuncDef completely
- [ ] Test: Parse complete function definition

*** Task 3.5: parse_struct_definition
- [ ] Remove "mut:"/"const:" prefix hack
- [ ] Build Array of (name, Declaration) tuples
- [ ] Remove parallel arrays
- [ ] Store Declaration objects with is_mut
- [ ] Test: Parse struct with mut/non-mut fields

*** Task 3.6: enum_definition
- [ ] Change to store ValueType enums
- [ ] Use None for no-payload variants
- [ ] Convert strings with str_to_value_type()
- [ ] Test: Parse enum with and without payloads

** Phase 4: Validation & Testing (Day 3)

*** Task 4.1: Compile and Fix Errors
- [ ] Run make
- [ ] Fix all type errors
- [ ] Fix all compilation errors
- [ ] Iterate until clean compile

*** Task 4.2: Run Test Suite
- [ ] Run full test suite (make)
- [ ] All tests must pass
- [ ] Fix any test failures

*** Task 4.3: Structural Comparison
- [ ] Write test to compare parser.til and parser.rs output
- [ ] Parse same input with both
- [ ] Compare SFuncDef structures
- [ ] Compare SStructDef structures
- [ ] Compare SEnumDef structures
- [ ] Verify identical data (not just test passing)

*** Task 4.4: Comment Alignment
- [ ] Compare comments in both files
- [ ] Add missing comments to parser.til
- [ ] Ensure documentation matches

** Phase 5: Documentation (Day 3)

*** Task 5.1: Update self_hosting_progress.org
- [ ] Change parser status to "100% HOMOLOGIZATION COMPLETE"
- [ ] Update completion percentage to 100%
- [ ] Document that homogenization is complete

*** Task 5.2: Mark This Plan Complete
- [ ] Add completion date to this file
- [ ] Archive for future reference

* Success Criteria

Parser homogenization is COMPLETE when:

- [ ] All data structures match (SEnumDef, SStructDef, SFuncDef, ValueType)
- [ ] All parse functions populate complete metadata
- [ ] str_to_value_type/value_type_to_str handle payloads
- [ ] Both parsers produce structurally identical output for same input
- [ ] All tests pass (src/tests.til)
- [ ] Comments aligned between files
- [ ] self_hosting_progress.org updated to 100% complete

* Timeline Estimate

| Phase | Tasks                      | Time    | Status |
|-------+----------------------------+---------+--------|
|     1 | Update data structures     | 4 hours | [ ]    |
|     2 | Update helper functions    | 3 hours | [ ]    |
|     3 | Update parse functions     | 8 hours | [ ]    |
|     4 | Validation & testing       | 6 hours | [ ]    |
|     5 | Documentation              | 1 hour  | [ ]    |
|-------+----------------------------+---------+--------|
|       | *Total*                    | *22h*   | ~3 days|

* Notes

- Created: 2025-11-09
- Status: Ready to execute
- Direction: Rust → TIL (parser.rs is source of truth)
- Priority: NEXT UP (after current Map test work)
