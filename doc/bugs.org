#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-01-10

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

** Bug #8: Uncaptured Return Values Propagate Up Call Stack (CRITICAL)

- *Status*: ❌ ACTIVE - Not a priority to fix yet, but blocks parser.til
- *Discovery*: 2025-01-10 during parser.til investigation
- *Impact*: CRITICAL - Cannot call ANY function/method that returns without capturing

*** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

*** Evidence
**Method example:**
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

**Standalone function example:**
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    lexer_expect(lexer, TokenType.LeftParen)  // ❌ Also causes return!
    println("[DEBUG] After lexer_expect")     // ❌ Never executes
}
```

Debug output shows `lexer_expect` completes and returns, but the caller never continues after the call.

**Workaround that works:**
```til
    _ := lexer.expect(TokenType.LeftParen)  // ✅ Works when captured
```

*** Root Cause
Currently, when a function/method returns a value that is not captured in an assignment, that value propagates up the call stack, causing the caller to also return with that value. This was not implemented as a deliberate design choice - it simply wasn't a priority to fix yet. The desired behavior is for uncaptured return values to be discarded.

*** Why This Is Problematic
- **Extremely unintuitive** - violates principle of least surprise
- **Makes code verbose** - must capture every return value even when not needed
- **Blocks natural code patterns** - can't call functions for side effects if they return values
- **Hard to debug** - causes mysterious early returns

*** Impact
- **BLOCKS** parser.til homogenization (requires `_ := func()` workarounds everywhere)
- Makes TIL code unnatural and verbose
- This bug needs to be fixed in rstil

*** Workaround
Always capture return values with `_ := func()` or `result := func()`, even when the value isn't needed.

*** What Needs to be Fixed
In rstil's interpreter.rs, function/method calls that return values should discard the return value if it's not being assigned to a variable, instead of propagating it up the call stack.

* Fixed Bugs Summary

Bugs #1-#7 have been fixed and their tests integrated into the regular test suite (=enums.til=, =flow.til=, =arithmetics.til=).

* Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

* Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

* Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

* Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

* Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

* Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

* Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

* Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

* Bug #8: Method Return Causes Caller to Return (FALSE POSITIVE)

- *Status*: ❌ NOT A BUG - False positive from incorrect usage
- *Discovery*: 2025-01-10 during parser.til work
- *Investigation*: 2025-01-10
- *Resolution*: Methods that return values work correctly

*** Original Symptom
When calling `lexer.expect(TokenType.LeftParen)` from parser.til, the calling function would return immediately.

*** Root Cause
The issue was not a bug in method returns, but incorrect function signatures after a global find-and-replace:
- Changed `lexer_expect(lexer, TokenType.LeftParen)` to `lexer.expect(lexer, TokenType.LeftParen)`
- The `lexer` parameter should have been removed when switching to method syntax
- Correct method call: `lexer.expect(TokenType.LeftParen)`

*** Testing
Created test cases confirming that:
1. Methods returning I64 work correctly
2. Methods returning struct types (Token) work correctly
3. The `Lexer.expect()` method works when called correctly

*** Workaround (Unnecessary)
The standalone `lexer_expect()` function was used temporarily during investigation, but methods work fine when called correctly.

* Summary

*All historical bugs (#1-#7) fixed as of January 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
