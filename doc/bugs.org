#+TITLE: rstil Bug Fixes - Historical Reference
#+AUTHOR: rstil Development
#+DATE: 2025-11-10

* Overview

This document provides a brief changelog of bugs that were fixed in the rstil interpreter.

* Active Bugs

No active bugs at this time.

* Fixed Bugs Summary

Bugs #1-#8 have been fixed and their tests integrated into the regular test suite (=enums.til=, =flow.til=, =arithmetics.til=, =return_value_usage.til=).

* Bug #1: Enum Comparison in Switch/Case

- *Status*: ❌ NOT PRESENT - Type system prevents this issue
- *Workaround*: Commit 46a00bc (string comparison)

* Bug #2: Return Statement Stack Frame Handling

- *Status*: ❌ NOT PRESENT - All nested return tests pass
- *Workaround*: Commit 46a00bc (function inlining)

* Bug #3: Nested Enum Payloads

- *Status*: ✅ FIXED - Direct nested enum construction works
- *Fix*: interpreter.rs:607-633 (recursive enum constructor evaluation)
- *Commit*: b75c886

* Bug #4: Enum Payload Copy

- *Status*: ✅ FIXED - Payloads preserved when copying between variables
- *Fix*: interpreter.rs:1125-1135, 1214-1224 (temp_enum_payload handling)
- *Commit*: 6b1702a

* Bug #5: rsonly_enum_extract_payload Function

- *Status*: ✅ FIXED - All payload types (I64, Str, Struct, Nested) work
- *Fix*: interpreter.rs:2346 (map_instance_fields for struct payloads)
- *Commit*: 4676a6b

* Bug #6: Enum Payloads Lost in Struct-to-Struct Copy

- *Status*: ✅ FIXED - Enum fields now reserve maximum variant size
- *Symptom*: When copying a struct that contains enum fields with payloads, the payloads were lost or corrupted
- *Root Cause*: Structs were allocated with fixed sizes based on =get_type_size()=, which returned only 8 bytes for all enums regardless of payload size. When enum payloads were written, they extended beyond the allocated space, causing memory corruption.
- *Solution*: Modified =get_type_size()= to calculate and reserve the maximum variant size for each enum type (8 bytes for tag + largest payload size), following the Rust approach.
- *Fix*: init.rs:1118-1144 (calculate max variant size in get_type_size)
- *Tests*: src/test/enums.til includes comprehensive regression tests for direct assignment and struct copying
- *Discovery*: 2025-01-09 during test_parser.til investigation
- *Fixed*: 2025-01-09

* Bug #7: Enum Return Value Handling

- *Status*: ✅ FIXED - Functions can now return enums with payloads correctly
- *Symptom*: When a function returned an enum value (especially with enum payloads), the payload data was lost, causing "range end index out of bounds" errors or incorrect values
- *Root Cause*: Enums were not being properly transferred from the function's context to the caller's context. The =temp_enum_payload= stored in the function context was discarded when the function returned.
- *Solution*: Added special handling for enum return values in =eval_func_proc_call=:
  - For constructor expressions (e.g., =OuterType.Nested=), transfer =temp_enum_payload= from function context to caller context
  - For variable returns, copy the enum value with its payload to caller context using =get_enum= and =insert_enum=
- *Fix*: interpreter.rs:1761-1786 (enum return value handling)
- *Tests*: src/test/enums.til:test_enum_constructor_in_function (comprehensive tests for returning enums with enum payloads)
- *Discovery*: 2025-01-10 during parser.til homogenization
- *Fixed*: 2025-01-10
- *Commit*: 05dd5c9

* Division/Modulo by Zero

- *Status*: ✅ FIXED - Returns 0 instead of panicking (safe default)
- *Fix*: interpreter.rs (zero checks in div/mod operations)
- *Commit*: 576a7fe
- *Note*: Users can implement custom error handling with throw/catch if needed

* Bug #8: Uncaptured Return Values Propagate Up Call Stack

- *Status*: ✅ FIXED - Compile-time enforcement of return value usage
- *Discovery*: 2025-11-10 during parser.til investigation
- *Fixed*: 2025-11-10 with type checker enhancements
- *Commit*: [current]

*** Problem
When you call a function or method that returns a value but DON'T capture the return value, it causes the calling function to return early with that function/method's return value. This affects BOTH methods AND standalone functions.

*** Original Behavior
```til
parse_func_proc_args := func(mut lexer: Lexer) returns Array {
    println("[DEBUG 1] Before expect")     // ✅ Prints
    lexer.expect(TokenType.LeftParen)      // ❌ Causes function to return!
    println("[DEBUG 2] After expect")      // ❌ Never executes
}
```

The uncaptured return value would propagate up the call stack, causing mysterious early returns.

*** Solution
Rather than fixing the runtime propagation behavior, we implemented **compile-time enforcement** that requires return values to be explicitly used or discarded. This is a better approach because:
1. Catches errors at compile time instead of runtime
2. Makes code intent explicit
3. Follows best practices from Rust (#[must_use]), Swift (@discardableResult), etc.

*** Implementation
Added context tracking to the type checker (typer.rs):
- Created =ExprContext= enum (ValueUsed vs ValueDiscarded)
- Modified =check_types_with_context()= to propagate context through type checking
- Added =check_fcall_return_usage()= to validate return value handling
- Updated all helper functions to pass appropriate contexts

*** Type Checking Rules
- **ValueUsed contexts**: Variable declarations, assignments, function arguments, return/throw statements
- **ValueDiscarded contexts**: Top-level statements in function bodies, if/while/switch/catch bodies

When a function returning a value is called in a ValueDiscarded context, the compiler produces:
```
type ERROR: Function 'func_name' returns a value that is not being used.
Hint: Capture the return value with '_ := func_name(...)' or use it in an expression.
```

*** Valid Code Patterns
```til
// ✅ Capture the return value
result := my_add(1, 2)

// ✅ Use as argument to another function
double(my_add(3, 4))

// ✅ Explicitly discard with _
_ := get_value()

// ✅ Procs don't return values, no capture needed
print_hello()

// ❌ ERROR: Return value not captured
my_add(1, 2)
```

*** Files Modified
- =src/rs/typer.rs=: Added ExprContext tracking and return value usage checking
- =src/test/errors.til=: Fixed one instance of uncaptured return value
- =src/test/return_value_usage.til=: Created comprehensive test suite

*** Tests
All existing tests pass. New test file demonstrates:
1. Return values captured in declarations work
2. Return values used as arguments work
3. Explicit discard with =_= works
4. Procs without return values work
5. Uncaptured return values produce helpful compile errors

*** Design Decision
This decision was made to:
1. Fix Bug #8 at compile time instead of runtime
2. Make TIL code more explicit and safer
3. Align with modern language best practices
4. Prevent subtle bugs from uncaptured return values

After self-hosting is complete, we may reconsider whether to relax this requirement for certain cases, but the explicit approach is the safer default.

* Summary

*All historical bugs (#1-#8) fixed as of November 2025.*

For implementation details and self-hosting progress, see git history and commit messages.
