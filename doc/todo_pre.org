#+TITLE: Pre-Self-Hosting TODO List
#+AUTHOR: rstil Development
#+DATE: 2025-11-10

* Overview

This document tracks TODOs in the *Rust implementation (rstil)* that must be completed before the self-hosted til interpreter can run successfully.

*Current Status:* All documented bugs fixed (see [[file:bugs.org][bugs.org]]). Parser homogenization complete. Ready for next phase.

*Scope:* This focuses on rstil (Rust) implementation issues, NOT on completing the til-based interpreter/typer/etc.

* Progress Summary

| Component           | Status                          | Notes                                           |
|---------------------+---------------------------------+-------------------------------------------------|
| Known Bugs          | ✅ ALL FIXED                    | Bugs #1-#8 all resolved                        |
| Error Handling      | ✅ WORKING                      | throw/throws/catch fully functional             |
| Import System       | ✅ WORKING                      | Basic imports work in all modes                 |
| Test Suite          | ✅ PASSING                      | All tests pass including return value checks    |
| Type System         | ✅ COMPLETE                     | Return value usage enforced at compile time     |
| Parser Homogenization | ✅ COMPLETE                    | parser.til aligned with parser.rs              |

* Active TODOs

** TODO Consider Implementing Enum Tag Comparison Feature               :LOW:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Code quality, parser implementation
:PRIORITY: Low (workaround exists)
:END:

*** Problem
Rust has an enum `.tag()` method that returns the discriminant (variant identifier) as an integer, allowing comparison of enum variants without caring about payloads. TIL doesn't have this feature.

Current parser.til has many uses of `.tag().eq()` pattern from the Rust version that don't work in TIL:
#+BEGIN_SRC til
// Rust pattern (doesn't work in TIL):
if nt.tag().eq(NodeType.Identifier("").tag()) { ... }

// TIL workaround (what we must use):
mut is_identifier := false
switch nt {
    case NodeType.Identifier:
        is_identifier = true
}
if is_identifier { ... }
#+END_SRC

*** Current Workaround
Use switch statements to check enum variants. This works but is more verbose.

*** Potential Solutions
1. Implement `.tag()` method for all enums that returns I64 discriminant
2. Implement direct enum comparison with `==` that compares only variants (not payloads)
3. Keep using switch statements (current approach)
4. Check if `enum_to_str()` or similar function already exists that could help

*** Remaining `.tag()` Uses in parser.til
Lines: 971, 984, 1011, 1014, 1329, 1338, 1345, 1376, 1388
These will fail if those code paths are executed.

*** Impact on Self-Hosting
Low - The switch statement workaround is sufficient. This is a nice-to-have feature for cleaner code.

** TODO Fix Error Line Numbers from Imported Files                      :LOW:
:PROPERTIES:
:DISCOVERED: 2025-11-10
:IMPACT: Developer experience, debugging
:PRIORITY: Low (doesn't block self-hosting)
:END:

*** Problem
Error messages from imported files show incorrect/duplicated file paths and misleading line numbers.

See Bug #9 in [[file:bugs.org][bugs.org]] for details and examples.

*** Impact on Self-Hosting
Low - This is a quality-of-life issue that makes debugging harder but doesn't prevent the self-hosted interpreter from running.

* Recently Completed

** DONE Improve Forward Reference Error Messages                         :MEDIUM:
CLOSED: [2025-11-10]
:PROPERTIES:
:DISCOVERED: 2025-01-09
:FIXED: 2025-11-10
:IMPACT: Developer experience, debugging
:COMMIT: 7bfec12
:END:

*** Solution Implemented
Forward declarations already worked! The real issue was that completely undefined types were silently accepted.

Added compile-time validation in typer.rs:
- check_enum_def() now validates custom types exist in context
- check_struct_def() now validates member types exist in context
- Both check that types are actually enums/structs, not values

*** Key Discovery
The original example from the TODO already works:
#+BEGIN_SRC til
ValueType := enum {
    TFunction: FunctionType,  // Forward reference - works!
}

FunctionType := enum {
    FTFunc,
    FTProc,
}
#+END_SRC

Forward references work for:
- Enum payloads (enum -> enum, enum -> struct)
- Struct members (struct -> enum, struct -> struct)
- Function parameters and return types
- Struct method return types

*** Error Messages
Now gives clear compile-time errors for truly undefined types:
#+BEGIN_EXAMPLE
src/test/test_undefined_type.til:4:12: type ERROR: Enum variant 'Variant' uses undefined type 'NonExistentType'.
Hint: Make sure 'NonExistentType' is defined before this enum.
#+END_EXAMPLE

*** Test Coverage
Added comprehensive tests:
- forward_declarations.til: Tests all forward reference scenarios
- test_undefined_type.til: Verifies undefined enum types error properly
- test_undefined_struct_type.til: Verifies undefined struct member types error
- test_original_forward_ref.til: Original example works as expected

* References

- [[file:bugs.org][bugs.org]] - Fixed bugs (Bugs #1-#8 all resolved)
- [[file:todo_self_hosting.org][todo_self_hosting.org]] - Component completion status
- [[file:todo_post.org][todo_post.org]] - Post self-hosting TODOs
- [[file:design_notes.org][design_notes.org]] - Language design decisions
- [[file:../src/tests.til][src/tests.til]] - Test suite (all tests passing)
- [[file:../src/test/todo.til][src/test/todo.til]] - Additional language TODOs

* Notes

** Focus on rstil, Not til Implementation
This document tracks what the *Rust interpreter (rstil)* needs to support self-hosting.

Completing interpreter.til, typer.til, etc. is a separate concern - those are the GOAL of self-hosting, not prerequisites.

** Workarounds Are Okay Temporarily
Some workarounds (like PatternInfo for tuples) are acceptable short-term. The priority is getting rstil stable enough to run the self-hosted code, even if that code has workarounds.
