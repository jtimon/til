* TIL Compilation Pipeline

This document describes the phases for the TIL compiler/interpreter pipeline.

** Phases Overview

The pipeline processes source code through these phases in order:

| Phase     | Input          | Output         | Purpose                                    |
|-----------+----------------+----------------+--------------------------------------------|
| Lexer     | Source string  | Tokens         | Tokenize source code                       |
| Parser    | Tokens         | AST            | Build abstract syntax tree                 |
| Mode      | Lexer          | ModeDef        | Parse mode declaration (test, script, etc) |
| Init      | AST, Context   | Context        | Register declarations in scope             |
| Typer     | AST, Context   | AST            | Type checking, validation, type completion |
| Desugarer | AST, Context   | AST            | Desugar syntactic sugar constructs         |
| UFCS      | AST, Context   | AST            | Desugar uniform function call syntax       |
| Precomp   | AST, Context   | AST            | Const-folding, macros                      |
| Scavenger | AST, Context   | AST            | Remove unused declarations (build only)    |
| Build     | AST, Context   | C source       | Generate C code (ccodegen)                 |
| Interpret | AST, Context   | EvalResult     | Execute program (eval)                     |

** Phase Details

*** Lexer (src/rs/lexer.rs, src/self/lexer.til)
- Converts source string into stream of tokens
- Handles string literals, numbers, identifiers, operators
- Entry: lexer_from_source()

*** Parser (src/rs/parser.rs, src/self/parser.til)
- Builds AST from token stream
- Parses all for-in variants as ForIn node (desugared later in Sugar)
- Entry: parse_tokens()

*** Mode (src/rs/mode.rs, src/self/mode.til)
- Parses the mode declaration at start of file
- Sets imports, permissions, and behavior flags
- Entry: parse_mode()

*** Init (src/rs/init.rs, src/self/init.til)
- Registers all declarations into scope stack:
  - Structs and their fields
  - Enums and their variants
  - Functions and procedures
  - Type aliases
- Processes imports recursively
- Entry: init_context()

*** Typer (src/rs/typer.rs, src/self/typer.til)
- Type checking and semantic validation
- Verifies function calls match signatures
- Checks type compatibility in assignments
- Validates enum variant usage
- Completes type inference in AST (annotates nodes with resolved types)
- No later phase should need to infer types
- Entry: check_types(), basic_mode_checks()

*** Desugarer (src/rs/desugarer.rs, src/self/desugarer.til)
- Desugars syntactic sugar constructs:
  - range for: for i in 0..10 -> while loop (type from AST annotation)
  - forin: for x: T in collection -> while loop with len/get calls
  - switch: (TODO Issue #110) switch/case on enums -> if/else chains
- Runs after typer because AST is annotated with resolved types
- Entry: desugar_expr()

*** UFCS (src/rs/ufcs.rs, src/self/ufcs.til)
- Desugars uniform function call syntax:
  - x.method(y) -> Type.method(x, y)
- Runs after sugar because sugar may generate UFCS calls
- Entry: ufcs_expr()

*** Precomp (src/rs/precomp.rs, src/self/precomp.til)
- Constant folding
- Macro expansion
- Other compile-time computations
- Entry: precomp_expr()

*** Scavenger (src/rs/scavenger.rs, src/self/scavenger.til)
- Removes unused function declarations
- Only used by builder (code size matters for compiled output)
- Disabled for interpreter (modules not merged)
- Entry: scavenger_expr()

*** Build (src/rs/ccodegen.rs, src/self/ccodegen.til)
- Generates C source code from AST
- Handles memory management, struct layouts
- Entry: emit()

*** Interpret (src/rs/interpreter.rs, src/self/interpreter.til)
- Executes the program directly
- Manages eval arena for memory
- Entry: eval_expr()

** Build vs Interpret

The builder (src/rs/builder.rs) and interpreter (src/rs/interpreter.rs) share
the same phases up through scavenger, but diverge afterward:

Build pipeline:
  Lexer -> Parser -> Mode -> Init -> Typer -> Desugarer -> UFCS -> Precomp -> Scavenger -> Build -> GCC

Interpret pipeline:
  Lexer -> Parser -> Mode -> Init -> Typer -> Desugarer -> UFCS -> Precomp -> Interpret

** Import Processing

Imports are processed in multiple phases with tracking to handle circular imports:
- context.imports_init_done - Files that completed init phase
- context.imports_typer_done - Files that completed typer phase
- context.imports_desugar_done - Files that completed desugarer phase
- context.imports_ufcs_done - Files that completed ufcs phase
- context.imports_precomp_done - Files that completed precomp phase
- context.imports_eval_done - Files that completed eval phase

Each file is marked "done" at the START of processing to prevent infinite loops
from circular imports.

** Entry Points

- interpret_file() - Main entry for interpreter
- main_interpret() - Core interpret logic
- build() - Main entry for builder

