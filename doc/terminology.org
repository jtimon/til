#+TITLE: TIL Terminology Guide
#+AUTHOR: TIL Development Team
#+DATE: 2025-01-10

* Overview

This document defines terminology used in TIL documentation and codebase to maintain consistency and clarity.

* Function vs Func/Proc/Macro

** "Functions" (general term)
When used generically, "functions" refers to ALL callable constructs in TIL, including:
- =func= (pure functions)
- =proc= (procedures with side effects)
- =macro= (future: compile-time code generation)

** "Func" and "Proc" (specific terms)
When being specific about which type of callable:
- Use =func= for pure functions (no side effects, must return a value)
- Use =proc= for procedures (may have side effects, may or may not return)
- Use =func/proc= when discussing both explicitly
- Future: =funcs/procs/macros= when all three are relevant

** Usage Examples

*Generic (includes all types):*
- "User-defined functions support variadic arguments"
- "This function takes two parameters"
- "Functions must explicitly declare what they can throw"

*Specific (distinguishes types):*
- "Core func 'malloc' takes exactly 1 argument"
- "Core proc 'single_print' takes exactly 1 argument"
- "The validate_arg_count helper is only for ext funcs/procs"
- "Future: funcs/procs/macros will have different call conventions"

** Rationale

Using "functions" as the generic term aligns with common programming terminology while maintaining precision when needed. The =func/proc= distinction is critical for:

1. **Type checking**: Funcs must return, procs may not
2. **Side effects**: Funcs are pure, procs may mutate state
3. **Error messages**: Users need to know which type they're calling
4. **Future extensibility**: Clear pattern for adding macros

* Const vs Mut Parameters

** "Const parameters" (default, implicit)
When we say "const parameters" or "const arguments", we refer to function parameters that do NOT have the 'mut' keyword:
- No keyword needed - const is the implicit default
- Parameters are immutable (cannot be modified)
- Passed by reference for efficiency
- Example: ~func(x: I64)~ - x is a const parameter

** "Mut parameters" (explicit)
When we say "mut parameters" or "mut arguments", we refer to function parameters declared with 'mut':
- Requires explicit 'mut' keyword
- Parameters can be modified, affecting the caller's value
- Passed by reference (required for modifications to propagate)
- Example: ~func(mut x: I64)~ - x is a mut parameter

** Usage Examples

*Const parameters (default):*
- "Const parameters are passed by reference for zero-copy efficiency"
- "This function takes three const arguments"
- "Const parameters are safe to reference because they cannot be modified"

*Mut parameters (explicit):*
- "Mut parameters must be passed by reference"
- "This function modifies its mut argument in place"
- "Copy-modify-copyback would be wasteful for mut parameters"

** Rationale

Using "const" to refer to default (non-mut) parameters:
1. Makes discussion clearer when contrasting with mut
2. Aligns with common terminology (const vs mutable)
3. Emphasizes that immutability is the default
4. Matches internal implementation semantics

* Collection Types

TIL provides four built-in collection types with different characteristics:

** Array (Fixed-size, Homogeneous)
- Fixed capacity set at creation
- All elements must be same type
- Type specified via string: =Array.new("I64", size_of(I64), capacity)=
- No growth - throws =IndexOutOfBoundsError= if capacity exceeded
- Direct memory access, minimal overhead
- Use when: Size known at compile time, no resizing needed

** Vec (Dynamic Array, Homogeneous)
- Growable array with automatic capacity expansion
- All elements must be same type
- Initial capacity: 16 elements
- Growth strategy: doubles capacity when full (16 → 32 → 64 → ...)
- Max capacity: 1024 elements
- Type specified at construction: =Vec.new("I64", size_of(I64))=
- Use when: Size varies at runtime, all elements same type

** Map (Ordered Dictionary)
- Key-value pairs maintaining insertion order
- Not hashed - O(n) lookup performance
- Keys and values can be any type (specified at creation)
- Special handling for Str keys (content comparison via Str.eq)
- Other types use memcmp for byte-wise comparison
- Warning: Struct keys compare raw bytes including padding
- Implementation: Two parallel Vec instances (keys and values)
- Use when: Need key-value lookup, order matters, small datasets

** List (Dynamic Heterogeneous Collection)

Also known as: Tuple (both names describe this structure)

- Dynamic array of mixed types
- Elements can be any type: I64, Bool, Str, structs, enums, nested Lists
- Runtime type tracking via type names and sizes
- Memory layout: Contiguous blob with metadata vectors
- Initial capacity: 256 bytes
- Growth strategy: doubles capacity when full
- Max capacity: 64KB

Type specified at: =List.new("List", size_of(List))=
Usage: Store heterogeneous elements, extract via type checking

Example:
#+BEGIN_SRC til
mut list := List.new()
list.push(42)           // I64
list.push("hello")      // Str
list.push(true)         // Bool

mut num := 0
list.get(0, num)        // num = 42

mut text := ""
list.get(1, text)       // text = "hello"
#+END_SRC

Memory characteristics:
- Each element: type_name (Str) + type_size (I64) + raw bytes
- Offsets calculated on-demand from sizes (no storage redundancy)
- Nested Lists supported (Lists can contain Lists)

Use when:
- Need to store mixed types together
- Building generic data structures
- Implementing interpreters, serialization, or dynamic APIs
- Similar to: Python lists, Elisp lists, JSON arrays

** Comparison Summary

| Type  | Size     | Elements    | Growth   | Lookup  | Use Case                 |
|-------+----------+-------------+----------+---------+--------------------------|
| Array | Fixed    | Same type   | No       | O(1)    | Known size, no resizing  |
| Vec   | Dynamic  | Same type   | 2x       | O(1)    | Variable size, one type  |
| Map   | Dynamic  | Key-Value   | 2x       | O(n)    | Lookups, small datasets  |
| List  | Dynamic  | Mixed types | 2x       | O(1)    | Heterogeneous data       |

* Notes

- Created: 2025-01-10
- Updated: 2025-11-11 (added const/mut parameter terminology, collection types)
- This terminology guide will be integrated into a more comprehensive documentation structure in the future
