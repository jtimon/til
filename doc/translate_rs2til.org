
Translation patterns for converting Rust code to TIL, primarily for self-hosting the compiler/interpreter.

* Overview

TIL and Rust have different idioms, but the translation is mechanical. This guide documents the patterns discovered when analyzing lexer.rs, parser.rs, and init.rs against their TIL counterparts.

* Lexer Patterns (lexer.rs -> lexer.til)

** Match on Option<byte> -> switch on string

Rust:
#+begin_src rust
match source.as_bytes().get(pos).copied() {
    Some(b'0'..=b'9') => ...,
    Some(b'a'..=b'z') | Some(b'A'..=b'Z') => ...,
    _ => ...
}
#+end_src

TIL:
#+begin_src til
c := source.get_substr(pos, pos.add(1))
switch c {
    case "0".."9": ...
    case "a".."z": ...
    case "A".."Z": ...
    case: ...
}
#+end_src

** String slicing

Rust: ~&source[start..end]~
TIL: ~source.get_substr(start, end)~

** OR patterns in match

Rust uses ~|~ to combine patterns. TIL uses separate case arms:

Rust:
#+begin_src rust
Some(b'a'..=b'z') | Some(b'A'..=b'Z') | Some(b'_') => is_ident()
#+end_src

TIL:
#+begin_src til
case "a".."z": is_ident()
case "A".."Z": is_ident()
case "_": is_ident()
#+end_src

* Parser Patterns (parser.rs -> parser.til)

** OR patterns in match

Rust:
#+begin_src rust
match func_type {
    FunctionType::FTProc | FunctionType::FTProcExt => true,
    _ => false
}
#+end_src

TIL:
#+begin_src til
switch func_type {
    case FTProc: return true
    case FTProcExt: return true
    case: return false
}
#+end_src

** Vec literals

Rust: ~vec![a, b, c]~

TIL:
#+begin_src til
mut v := Vec.new(T)
v.push(a)
v.push(b)
v.push(c)
#+end_src

** Struct literals

Rust:
#+begin_src rust
let info = SymbolInfo {
    value_type: some_type,
    is_mut: true,
    is_copy: false,
    is_own: false,
};
#+end_src

TIL uses constructor-style syntax with named arguments. Only specify fields that differ from defaults:
#+begin_src til
// Only set fields that differ from struct defaults
info := SymbolInfo(value_type=some_type, is_mut=true)

// All fields use defaults
info := SymbolInfo()

// Order doesn't matter
p := Vec2(y=20, x=10)
#+end_src

* Init Patterns (init.rs -> init.til)

** Not-equal comparisons (ne -> not(eq()))

TIL does not have a ~ne~ function. Use ~not(eq())~ instead:

Rust:
#+begin_src rust
if a != b { ... }
if x.len() != 0 { ... }
#+end_src

TIL:
#+begin_src til
if not(a.eq(b)) { ... }
if not(x.len().eq(0)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.ne()~ - it doesn't exist in TIL. Always use ~not(eq())~ or ~not(...eq(...))~.

** Enum comparisons (use switch, not eq)

Enums do NOT have an ~.eq()~ method. Use ~switch~ to compare enum values:

Rust:
#+begin_src rust
if value_type == ValueType::TInfer { ... }
if my_enum != SomeEnum::Variant { ... }
#+end_src

TIL:
#+begin_src til
// For equality check, use switch with a boolean flag
mut is_infer := false
switch value_type {
case ValueType.TInfer:
    is_infer = true
case:
    // Other variants
}
if is_infer { ... }

// For inequality, negate the flag
if not(is_infer) { ... }
#+end_src

For enum comparisons where you need to compare two enum values, use ~enum_to_str()~:
#+begin_src til
if enum_to_str(enum_a).eq(enum_to_str(enum_b)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.eq()~ on enums - it doesn't exist. Use ~switch~ or ~enum_to_str()~.

** if let Some(x) = ...

Rust uses ~if let~ for Option destructuring. TIL checks for default/empty value or uses catch blocks:

Rust:
#+begin_src rust
if let Some(val) = map.get(key) {
    // use val
}
#+end_src

TIL (check default):
#+begin_src til
val := map.get(key)
if not(val.eq("")) {
    // use val
}
#+end_src

TIL (catch block):
#+begin_src til
catch {
    val := map.get_or_throw(key)
    // use val
}
#+end_src

** Reverse iteration

Rust: ~items.iter().rev()~

TIL:
#+begin_src til
mut i := items.len().sub(1)
while i.gteq(0) {  // TODO: use reverse range when implemented: for i in items.len().sub(1)..0
    mut item := T()
    items.get(i, item)
    // use item
    i.dec()
}
#+end_src

Note: Start at ~len().sub(1)~, loop while ~i.gteq(0)~ to include index 0, decrement at end with ~i.dec()~.

** For-in loops

Rust:
#+begin_src rust
for item in &items {
    // use item
}

for (i, item) in items.iter().enumerate() {
    // use i and item
}
#+end_src

TIL:
#+begin_src til
for item: T in items {
    // use item
}

for i in 0..items.len() {
    mut item := T()
    items.get(i, item)
    // use i and item
}
#+end_src

Note: TIL's ~for item: T in vec~ iterates by value. For indexed access, use range loop with ~get~.

** Return type and error translation patterns

This is the canonical mapping from Rust return types to TIL throws:

| Rust                        | TIL                                  |
|-----------------------------+--------------------------------------|
| ~Result<T, String>~         | ~returns T throws Str~               |
| ~Option<T>~                 | ~returns T throws KeyNotFoundError~  |
| ~Result<Option<T>, String>~ | ~returns T throws Str, KeyNotFoundError~ |

Examples:

Rust:
#+begin_src rust
fn lookup_symbol(&self, name: &str) -> Option<&SymbolInfo> { ... }
fn parse_expr(&mut self) -> Result<Expr, String> { ... }
fn try_lookup(&self, name: &str) -> Result<Option<&Value>, String> { ... }
#+end_src

TIL:
#+begin_src til
lookup_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws KeyNotFoundError { ... }
parse_expr := func(mut self: Parser) returns Expr throws Str { ... }
try_lookup := func(self: Context, name: Str) returns Value throws Str, KeyNotFoundError { ... }
#+end_src

IMPORTANT: Internal errors (like ~IndexOutOfBoundsError~ from ~Vec.get()~) should be caught
internally and NOT exposed in the throws signature. Only expose the semantic error types
that correspond to the Rust return type.

** Option handling patterns

Rust uses ~Option<T>~ with ~.ok_or_else()~, ~.is_some()~, ~.is_none()~.

TIL uses throw/catch instead:
- Function throws ~KeyNotFoundError~ instead of returning None
- Caller uses catch block to handle the not-found case
- ~map.contains_key(k)~ to check existence without fetching

** Method chaining with ?

Rust: ~let x = foo()?.bar()?.baz()?;~

TIL: Operations throw on failure, caller catches. No explicit propagation needed.

** Default switch case syntax

Rust uses ~_~ for catch-all. TIL uses empty ~case:~

Rust:
#+begin_src rust
match x {
    Foo::A => ...,
    _ => ...  // catch-all
}
#+end_src

TIL:
#+begin_src til
switch x {
    case Foo.A: ...
    case: ...  // catch-all (NOT "case _:")
}
#+end_src

** NULL pointer comparison

Rust: ~ptr.is_some()~ or ~ptr != NULL~

TIL: Use ~not(NULL.eq(ptr.data))~ - TIL doesn't have ~.ne()~ method:

#+begin_src til
if not(NULL.eq(func_ptr.data)) {
    // pointer is valid
}
#+end_src

** Option<T> struct fields -> Ptr

Rust uses ~Option<T>~ for optional struct fields. TIL uses ~Ptr~ where ~NULL~ represents ~None~:

Rust:
#+begin_src rust
struct EnumVal {
    pub payload: Option<Vec<u8>>,
    pub payload_type: Option<ValueType>,
}

// Usage
if let Some(payload_type) = &enum_val.payload_type {
    // use payload_type
}
#+end_src

TIL:
#+begin_src til
EnumVal := struct {
    mut payload: Ptr = Ptr()  // Ptr to Vec<U8>, NULL = None
    mut payload_type: Ptr = Ptr()  // Ptr to ValueType, NULL = None
}

// Usage - check for NULL to see if present
if not(NULL.eq(enum_val.payload_type.data)) {
    // pointer is valid, use it
}
#+end_src

Comment pattern: ~# Ptr to T, NULL = None~ or ~// Ptr for Option pattern, NULL = None~

** Vec/Map.get() out-parameter pattern

Rust returns the value directly. TIL uses out-parameter pattern:

Rust:
#+begin_src rust
let item = vec.get(i)?;
let val = map.get(&key)?;
#+end_src

TIL:
#+begin_src til
mut item := T()  // default init
vec.get(i, item)  // out-parameter, throws IndexOutOfBoundsError

mut val := V()
map.get(key, val)  // out-parameter, throws KeyNotFoundError
#+end_src

** Catch blocks placement

Catch blocks CANNOT be placed in unreachable code (after the final return/throw of a function).
Placement depends on the error type:

*** KeyNotFoundError (like Rust's Option::None)

Place catch immediately after the throwing call, before using the result:

#+begin_src til
lookup_func := func(self: ScopeStack, name: Str) returns SFuncDef throws KeyNotFoundError {
    mut i := self.frames.len().sub(1)
    while i.gteq(0) {
        mut frame := ScopeFrame()
        self.frames.get(i, frame)

        if frame.funcs.contains_key(name) {
            mut func_def := SFuncDef()
            frame.funcs.get(name, func_def)
            catch (err: KeyNotFoundError) {
                // Function not found, continue searching
            }
            return func_def
        }

        i.dec()
    }

    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "IndexOutOfBoundsError in lookup_func: ", err.msg)
    }
    throw KeyNotFoundError(msg="lookup_func: Function not found in Context")
}
#+end_src

*** Panic-like errors (IndexOutOfBoundsError, AllocError, etc.)

Can be grouped at the end of the function to avoid repetition:

#+begin_src til
my_func := func() returns T throws Str {
    // ... code that may throw various errors ...

    result := compute_result()

    catch (err: IndexOutOfBoundsError) { throw err.msg }
    catch (err: AllocError) { throw err.msg }

    return result
}
#+end_src

*** panic for impossible errors

Use ~panic(loc(), "message")~ for errors that should never happen (e.g., index errors when iterating within known bounds):

#+begin_src til
mut i := vec.len().sub(1)
while i.gteq(0) {
    mut item := T()
    vec.get(i, item)
    catch (err: IndexOutOfBoundsError) {
        panic(loc(), "vec.get can't fail: i is always within bounds: ", err.msg)
    }
    // use item
    i.dec()
}
#+end_src

* Clone Methods (derive(Clone) -> manual implementation)

Rust uses ~#[derive(Clone)]~ to auto-generate clone methods. TIL has no derive macros,
so clone methods must be written manually for each struct/enum that needs them.

Rust:
#+begin_src rust
#[derive(Clone)]
struct MyStruct {
    field1: String,
    field2: i64,
}
#+end_src

TIL:
#+begin_src til
MyStruct := struct {
    mut field1: Str = ""
    mut field2: I64 = 0

    clone := func(self: MyStruct) returns MyStruct {
        mut result := MyStruct()
        result.field1 = self.field1.clone()
        result.field2 = self.field2
        return result
    }
}
#+end_src

Clone behavior by type:
- Primitives (I64, Bool, U8): direct copy, no clone needed
- Enums: direct copy, no clone needed (enums are value types in TIL)
- Str: use ~.clone()~
- Vec: use ~.clone()~ (deep copy)
- Map: use ~.clone()~ (deep copy)
- Structs: create clone method, copy each field appropriately

IMPORTANT: Enums do NOT need clone in TIL. Unlike Rust where ~#[derive(Clone)]~ is needed,
TIL enums are value types and are automatically copied on assignment. Just assign directly:

#+begin_src til
// Rust: let copy = my_enum.clone();
// TIL: just assign - enums copy by value
copy := my_enum
#+end_src

IMPORTANT: When a struct contains other structs that need cloning, call their
clone methods recursively.

* Summary

The translation is mechanical:
1. OR patterns (~|~) -> separate case arms
2. ~if let~ -> check default value or catch block
3. Iterator methods -> explicit loops
4. Return type translation:
   - ~Result<T, String>~ -> ~returns T throws Str~
   - ~Option<T>~ -> ~returns T throws KeyNotFoundError~
   - ~Result<Option<T>, String>~ -> ~returns T throws Str, KeyNotFoundError~
5. Internal errors (IndexOutOfBoundsError, AllocError, etc.) should be caught internally, not exposed
6. String slicing -> ~get_substr~
7. UFCS works similarly: ~a.method(b)~ in both languages
8. Default case: ~_~ -> empty ~case:~
9. NULL check: ~!= NULL~ -> ~not(NULL.eq(x))~
10. ~vec.get(i)~ -> out-parameter: ~vec.get(i, out_val)~
11. Catch blocks come before final return/throw
12. Not-equal: ~!=~ or ~.ne()~ -> ~not(eq())~ or ~not(x.eq(y))~ (TIL has no ~ne~ function)
13. Enum comparison: ~==~ on enums -> use ~switch~ with boolean flag, or ~enum_to_str()~ (enums have no ~eq~ method)
