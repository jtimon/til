#+TITLE: TIL vs Mojo: Ownership and Memory Safety Design Comparison
#+DATE: 2025-11-12
#+UPDATED: 2025-11-12
#+AUTHOR: TIL Development

* Overview

Comparison of TIL's ownership model with Mojo's ownership system, showing remarkable convergence in design philosophy.

* Mojo's Design

** Argument Conventions (Function Parameters)

Mojo has three main argument conventions:

1. **read** (default): Immutable reference, no copy
   - Efficient for large values
   - Cannot modify the argument

2. **mut**: Mutable reference (inout parameter)
   - Modifications visible to caller
   - Enforces exclusivity (no aliasing)

3. **var**: Ownership transfer
   - Function takes ownership
   - Either copy (if copyable) or move with ^ sigil

** Local Variables (Updated 2025)

Mojo REMOVED the `let` keyword for immutable variables because:
- Immutability only applied to the binding, not the referenced value
- This was confusing with reference types
- Not needed for Python programmers
- Immutability better handled through function parameters

Current design:
- **var**: Mutable variables (only kind of local variable)
- **ref**: Explicit reference binding (for aliasing)

** Philosophy

- Value semantics by default
- References for performance
- Automatic lifetime checking by compiler
- Simplicity over completeness (removed `let`)
- Ownership rules: "Every value has only one owner at a time"

* TIL's Current Design (Post Bug #25 Fix)

** Function Parameters

1. **Default (no keyword)**: Immutable parameter
   - Currently COPIES (inefficient)
   - Phase 3 goal: Make it a reference
   - Type checker prevents modification

2. **mut**: Mutable reference
   - Modifications visible to caller
   - Works for primitives and structs

3. **copy**: Explicit copy
   - Local modifications don't affect caller
   - Added in Phase 2

4. **own** (future): Ownership transfer
   - Caller can pass with `own` at call site
   - Invalidates variable in caller's context
   - Example: `func(own my_string)` transfers ownership
   - Works even if function declared with `mut` (opt-in at call site)

** Local Variable Declarations (Bug #25 Fix)

After Bug #25 fix, TIL has clean semantics:

1. **mut x := original**: Creates INDEPENDENT COPY
   - Modifications to x don't affect original
   - Safe, prevents aliasing
   - Equivalent to Mojo's `var x = original`

2. **x := original** (no keyword): Immutable reference binding
   - Shares arena offset (no copy)
   - Type checker prevents modification
   - Efficient, safe
   - **Equivalent to Mojo's `ref x = original`**

** Design Insight

TIL's default (no keyword) ‚âà Mojo's `ref`
- Both are reference bindings
- Both are immutable (enforced by type checker/compiler)
- User doesn't need to care if it's a "const copy" or "const reference" - same behavior!

The key realization: **const copy vs const reference is an implementation detail**.
From the user's perspective, if you can't modify it, it doesn't matter whether
it's copied or referenced. TIL chooses reference (efficient), Mojo makes it explicit
with `ref` keyword. TIL's approach is arguably simpler.

* Comparison Table (Updated)

| Feature                 | Mojo (2025)    | TIL (Current)       | Notes                               |
|-------------------------+----------------+---------------------+-------------------------------------|
| Default param           | read (ref)     | Copy                | Phase 3: will become ref            |
| Mutable param           | mut (ref)      | mut (ref)           | ‚úÖ Same                             |
| Copy param              | var (copy)     | copy                | ‚úÖ Same concept                     |
| Ownership transfer      | var with ^     | own (at call site)  | TIL: opt-in at call, not signature  |
| Mut local               | var x = y      | mut x := y          | ‚úÖ Equivalent (both copy)           |
| Immut local             | (REMOVED)      | x := y (ref)        | TIL simpler: default is ref         |
| Explicit ref            | ref x = y      | x := y              | TIL: no keyword needed (is default) |
| Move at call site       | foo(x^)        | foo(own x)          | TIL: uses own keyword               |

* Key Differences

** Where TIL is Simpler

1. **No explicit ref keyword needed**: Default is reference
   - Mojo: `ref x = y` (explicit)
   - TIL: `x := y` (implicit, cleaner)

2. **Consistent ownership transfer**: Uses `own` keyword everywhere
   - Mojo: `^` sigil (punctuation)
   - TIL: `own` keyword (readable)

3. **Opt-in at call site**: Caller decides ownership transfer
   - `func(mut x: T)` can receive `func(own my_var)` - caller chooses transfer
   - More flexible than requiring signature change

4. **Simpler local variables**: Only two cases
   - `mut x := y` = mutable copy
   - `x := y` = immutable reference
   - No need to learn separate `ref` keyword

** Where Mojo is More Explicit

1. **Explicit ref binding**: `ref` keyword makes aliasing visible
2. **Default params are refs**: Already efficient (TIL needs Phase 3)
3. **Mature lifetime system**: Compiler-enforced lifetimes

** Implementation Status

TIL is currently missing:
1. **Phase 3**: Default params should be references (blocked by arena issues)
2. **own keyword**: Ownership transfer not implemented yet
3. **Lifetime tracking**: Would need for move-only types

* TIL's Design Philosophy (Refined Understanding)

** Core Insight: Const Copy vs Const Reference Doesn't Matter

From user discussion:
> "why does it matter to the user if it's a const copy or a const reference?
> you can't modify it either way."

This is **exactly right** and a key design principle. If a binding is immutable:
- Whether it's a copy or reference is an **implementation detail**
- User sees identical behavior either way
- Implementation can choose most efficient approach

This is why Mojo removed `let` - the distinction was confusing and unnecessary.

** Current Semantics (Post Bug #25)

Local variables:
```til
x := original        // Immutable reference (shares offset, can't modify)
mut x := original    // Mutable copy (independent, can modify)
```

Function parameters:
```til
func(x: T)           // Immutable (currently copies, should be ref in Phase 3)
func(mut x: T)       // Mutable reference
func(copy x: T)      // Explicit copy
```

** Ownership Transfer Design (Future)

Use `own` at **call site**, not in signature:
```til
func(mut x: String)      // Function declared with mut
// ...
func(own my_string)      // Caller chooses to transfer ownership
// my_string is now invalid in caller's context
```

Key insight: Ownership transfer is opt-in by **caller**, not required by signature.
This is more flexible than Mojo's approach where signature must declare `var`.

** Comparison with Mojo's Equivalents

| TIL                | Mojo Equivalent     | Notes                              |
|--------------------+---------------------+------------------------------------|
| x := y             | ref x = y           | **TIL's default ‚â° Mojo's ref**     |
| mut x := y         | var x = y           | Both copy                          |
| func(own x)        | func(x^)            | TIL: keyword vs sigil              |
| func(mut x: T)     | func(mut x: T)      | Same (mutable reference)           |

**Key Equivalence**: TIL's default (no keyword) is equivalent to Mojo's `ref`.
Both create immutable reference bindings. TIL doesn't need explicit `ref` keyword
because the default behavior IS reference binding.

* Implementation Roadmap

** ‚úÖ Phase 1: Immutability Enforcement (COMPLETE)
- Type checker prevents modification of non-mut parameters
- Prevents field modification
- Foundation for safe reference semantics

** ‚úÖ Phase 2: Copy Keyword (COMPLETE)
- Added `copy` keyword for explicit copying
- Mutually exclusive with `mut`
- Enables fine-grained control

** ‚úÖ Bug #25 Fix: Declaration Semantics (COMPLETE)
- `mut x := y` creates independent copy
- `x := y` creates immutable reference binding
- Aligns with Mojo's philosophy

** ‚è∏ Phase 3: Default Params as References (DEFERRED)
- Goal: Make `func(x: T)` pass by reference instead of copy
- Blocked: Arena singleton + context cloning causes corruption
- Can revisit post self-hosting with better debugging tools

** üîÆ Future: Ownership Transfer
Use `own` at call site for ownership transfer:
```til
func(mut s: String)      // Function signature
func(own my_string)      // Caller transfers ownership
```

Would require:
- Lexer: Add `own` token (can reuse from parameter declarations)
- Type checker: Track moved variables, prevent use-after-move
- Interpreter: Transfer without copy, invalidate source

** üîÆ Future: Move-Only Types (Maybe)
Needs more research and real-world examples to determine necessity.

* Conclusion

TIL's ownership model has **remarkable convergence with Mojo**:

**Similarities:**
- Default locals are references (TIL implicit, Mojo explicit with `ref`)
- Mutable locals copy (both use different keywords: TIL `mut`, Mojo `var`)
- Mutable parameters are references (both use `mut`)
- Ownership transfer supported (TIL `own`, Mojo `^`)

**Where TIL is simpler:**
- No explicit `ref` keyword needed (default behavior)
- Readable `own` keyword instead of `^` sigil
- Opt-in ownership transfer at call site (more flexible)

**Where TIL needs work:**
- Phase 3: Default params should be refs (currently copy)
- Implement `own` keyword
- Lifetime tracking for move-only types (if needed)

The key insight: **const copy vs const reference is an implementation detail**.
Users don't need to care, type checker ensures safety either way.
