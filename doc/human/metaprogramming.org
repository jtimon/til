* TODO WARNING generated by grok from some notes, it's not quite correct yet
* Til Generics and Macros: Design Overview

This document outlines Til's approach to generics and macros, emphasizing their integration with the Dynamic typing system. Til desugars generics to macros for implementation, enabling compile-time expansion while preserving runtime flexibility. This design draws from C++ templates for familiarity, Jai/Zig comptime for metaprogramming power, and Lisp homoiconicity for extensibility—all unified under Til's "eat your cake" ethos.

** Core Concepts

- *Macros*: Compile-time functions that generate and insert code. Defined as ~macro(name: Params) returns Body { ... }~, where ~Body~ is an internal compiler class representing AST fragments (e.g., a ~List<Expr>~). Macros are evaluated via the interpreter in a pre-compile phase, producing fresh code that replaces the macro call in the main compilation pipeline. This ensures hygiene and avoids runtime overhead. Alternatively, a string-return variant (~returns Str~) allows simple template-like expansion, similar to Jai's ~inline~ procs.

- *Generics*: Parameterized types and functions that monomorphize at compile-time for efficiency. Syntax is desugared to macros, allowing bounds, introspection, and fallbacks to Dynamic typing. Generics favor static resolution but can emit dynamic code via flags or guards.

- *Dynamic Typing*: A runtime-erasured mode using ~Dynamic~ (struct with type tags and boxed values). Serves as a fallback for generics, enabling Python-like simplicity. Post-self-hosting, macros can switch between static and dynamic impls based on context.

** Macro Syntax and Mechanics

Macros operate on ~Type~ (comptime type info) and ~Expr~/~Stmt~ (code fragments), with built-in operators for introspection. The macro body executes normally (via interpreter), and its return value (e.g., an ~Expr~ or ~Stmt~) is spliced in place of the call—dynamic resolution happens at expansion time.

*** Definition
A macro for comptime-sized allocation, e.g., creating a fixed ~Ptr~ or ~Array~ based on a constant size arg:

#+BEGIN_SRC til
alloc_fixed = macro(size: I64) returns Expr {  // Or returns Str for template mode
    if not @is_const(size) {
        compile_error("Size must be comptime constant")
    }
    // Expand to direct alloc call
    return quote {
        mut ptr := Ptr.new_by_size($size)
        ptr.set_zero($size)
        ptr
    }
    // String variant: return format("Ptr.new_by_size({})", size)
}
#+END_SRC

Usage: ~let buf = alloc_fixed(1024);~ expands to the quoted alloc code.

*** Introspection Operators
- ~@hasField(T: Type, field: Str) -> Bool~: Checks if type has a field.
- ~@fieldValue(T: Type, field: Str) -> Dynamic~: Gets comptime value (for consts).
- ~@isStruct(T: Type) -> Bool~: Type predicates (e.g., ~@isPrimitive~, ~@isGeneric~).
- ~quote { ... }~: Quasiquote for AST building (injects params via ~$var~); ~unquote~ for eval.

*** Evaluation
Compiler invokes interpreter on macro body; output ~Body.expand_to: List<Stmt>~ (or parsed ~Str~) replaces the call site. For ~alloc_fixed(1024)~, it becomes ~mut ptr := Ptr.new_by_size(1024); ptr.set_zero(1024); ptr~.

** Generics Syntax Options

Til explores C++-inspired templates with Til sugar, desugaring to macros for all cases.

*** Explicit Templates (~<T>~)
#+BEGIN_SRC til
Vec<T> := struct {  // Desugars to vec_macro(T)
    data: Array<T>
    len: I64 = 0  // Field access: self.len

    push(mut self: Vec<T>, val: T) { ... }
}

-- Use: Vec<I64>, monomorphs to Vec_i64
#+END_SRC

*** Inline Bounds (~for T in Type~)
#+BEGIN_SRC til
Vec for T in Type := struct { ... }  -- Til-y loop echo

-- Macro desugar guards: if @isConcrete(T) { mono } else { DynamicVec }
#+END_SRC

*** Trait-Bounded (~where~)
#+BEGIN_SRC til
Vec<T where Sized> := struct { ... }  -- Sized requires @hasField("len")

-- Enforced at desugar: compile_error if unbound
#+END_SRC

** Desugaring Mechanics

Generics expand via a bootstrap macro (e.g., ~generic_macro~), run interpreter-side:

#+BEGIN_SRC til
generic_macro = macro(params: List<(Str, Type)>) returns Body {
    let bounds = extract_where(params)  -- Parse "T where Sized"
    for (name, T) in params {
        if not @satisfies(T, bounds) { compile_error(...) }
        if @isConcrete(T) {
            let mono = monomorphize(name, T)  -- Emit Vec_I64 struct/funcs
        } else if compiler_flag("--prefer-dynamic") {
            return dynamic_impl(name)  -- Erase to Dynamic vtable
        }
    }
    return Body.from(mono_stmts)
}
#+END_SRC

This yields zero-cost statics by default, dynamic fallbacks for size/perf tradeoffs.

** Integration with Dynamic

- *Fallback*: Unresolved generics (e.g., runtime ~T~) box to ~Dynamic::as<T>()~.
- *Translation*: Macros like ~@to_generic(DynamicCode)~ rewrite Python-style to static where possible.
- *Efficiency*: Use ~@mode lib_static~ for mono-only; ~@mode script_dynamic~ for REPL.

** Future Extensions

- *Variadics*: ~Vec<Ts: ..Type>~ for heterogeneous (ties to List).
- *Specialization*: ~@specialize Vec<Str>~ for custom impls.
- *Hygiene*: ~quote~ scopes vars; ~@fresh_id()~ for gensyms.

This design ensures Til's multi-everything promise: Write once, compile to your needs.
