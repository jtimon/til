* Til Generics and Macros: Design Overview

This document outlines Til's approach to generics and macros, emphasizing their integration with the Dynamic typing system. Til desugars generics to macros for implementation, enabling compile-time expansion while preserving runtime flexibility. This design draws from C++ templates for familiarity, Jai/Zig comptime for metaprogramming power, and Lisp homoiconicity for extensibility—all unified under Til's "eat your cake" ethos.

** Core Concepts

- *Macros*: Compile-time functions that generate and insert code or values. Defined as ~macro(name: Params) returns Type { ... }~, where the return type (e.g., ~Expr~, ~Body~, ~Str~, ~StructDef~) determines the expansion form. Macros are evaluated via the interpreter in a pre-compile phase, producing concrete values or AST that replace the call site in the main compilation pipeline. This ensures hygiene and avoids runtime overhead. For simple cases, ~returns Str~ allows template-like expansion (parsed as code). Constancy is enforced by the type checker post-expansion—no explicit ~@is_const~ annotations needed.

- *Generics*: Parameterized types and functions implemented via macros, monomorphizing at compile-time for efficiency. Syntax desugars to macro calls, allowing bounds, introspection, and fallbacks to Dynamic typing. Generics favor static resolution but can emit dynamic code via flags or guards.

- *Dynamic Typing*: A runtime-erasured mode using ~Dynamic~ (struct with type tags and boxed values). Serves as a fallback for generics, enabling Python-like simplicity. Post-self-hosting, macros can switch between static and dynamic impls based on context.

** Macro Syntax and Mechanics

Macros operate on ~Type~ (comptime type info) and ~Expr~/~Stmt~ (code fragments), with built-in operators for introspection. The body executes normally (via interpreter), returning a value spliced as-is (e.g., a computed ~List~ becomes a literal). An extra type-checking phase follows expansion to validate constancy and types.

*** Definition
A simple range macro: Computes a ~List~ at comptime, expands to a static literal.

#+BEGIN_SRC til
range = macro(start: I64, end: I64) returns List<I64> {
    mut items := List<I64>.new()
    for i in start..end {
        items.push(i)
    }
    return items
}
#+END_SRC

Usage: ~let r: List<I64> = range(0, 5);~ expands to ~let r: List<I64> = [0, 1, 2, 3, 4];~ (literal array init).

For const strings: ~returns Str~ for baked literals.

#+BEGIN_SRC til
add_project_prefix = macro(s: Str) returns Str {
    return format("Common prefix for constant strings: ", s)
}
#+END_SRC

Usage: ~const MY_CONSTANT_STRING = add_project_prefix("my example constant string");~ expands to ~const MY_CONSTANT_STRING = "Common prefix for constant strings: my example constant string";~.

*** Introspection Operators
- ~@hasField(T: Type, field: Str) -> Bool~: Checks if type has a field.
- ~@fieldValue(T: Type, field: Str) -> Dynamic~: Gets comptime value (for consts).
- ~@isStruct(T: Type) -> Bool~: Type predicates (e.g., ~@isPrimitive~, ~@isGeneric~).
- ~quote { ... }~: Quasiquote for AST building (injects params via ~$var~); used for ~returns Body~ or ~Expr~.

*** Evaluation
Compiler invokes interpreter on macro body; output replaces the call site. Post-expansion, a second type check enforces constancy (e.g., rejects non-lit args in const contexts). For ~Body~/~Expr~ returns, splices as code; ~Str~ parses to AST; simple types (e.g., ~List~) coerce to literals.

** Generics Syntax Options

Til implements generics via macros, desugaring definitions to macro calls. Usage instantiates by calling the macro with concrete types.

*** Explicit Templates (~<T>~)
Generics desugar to macro invocations for monomorphization.

#+BEGIN_SRC til
-- Desugars to generic_pair_macro(T)
Vec<T> := generic_vec_macro(T)  // Macro returns StructDef

-- Use: Vec<I64> expands to monomorphized struct
#+END_SRC

*** Inline Bounds (~for T in Type~)
#+BEGIN_SRC til
Vec for T in Type := generic_vec_macro(T)  // Til-y loop echo; desugars similarly

-- Macro guards: if @isConcrete(T) { mono } else { DynamicVec }
#+END_SRC

*** Trait-Bounded (~where~)
#+BEGIN_SRC til
Vec<T where Sized> := generic_vec_macro(T, Sized)  // Pass trait as param

// Enforced at desugar: compile_error if unbound
#+END_SRC

** Desugaring Mechanics

Generics expand via dedicated macros (e.g., ~generic_pair~), run interpreter-side. Returns ~StructDef~ (internal AST for struct + methods).

#+BEGIN_SRC til
generic_pair = macro(T: Type, default: Dynamic) returns StructDef {
    temp_def := struct {
        a : T = default
        b : T = default

        return_one := func(self: temp_def, first: Bool) returns T {
            if first {
                return self.a
            }
            return self.b
        }
    }
}
#+END_SRC

Usage:
#+BEGIN_SRC til
PairU8 := generic_pair(U8, 0)
PairStr := generic_pair(Str, "")
#+END_SRC

Expands to: PairU8 := struct { a: U8 = 0; b: U8 = 0; return_one := func(...) { ... } };
Monomorphizes methods per T (e.g., Str ops in PairStr)

A bootstrap ~generic_macro~ handles multi-param desugaring:

WARNING: grok made some stuff up here from the explanations, but the point is that we can have a compile option so that generics expand to using Dynamic instead of true generics for smaller binaries when that is preferred over more optimal runtime. The following is from grok and I haven't preoperly reviewed it yet.

#+BEGIN_SRC til
generic_macro = macro(params: List<(Str, Type)>) returns StructDef {
    mut bounds = extract_bounds(params)  // Helper: Parses "T where Sized" -> Map{"T": "Sized"}
    mut mono_struct = StructDef.new("Generic")  // Base AST node
    for (name, T) in params {
        if not(satisfies(T, bounds.get(name))) {  // Plain func: satisfies(Type, Str) -> Bool
            compile_error(format("Type ", T.name, " does not satisfy bound ", bounds.get(name)))
        }
        if is_concrete(T) {  // Plain func: is_concrete(Type) -> Bool
            mono_struct.add_field(name, T, default_val)  // Emit typed field
            mono_struct.add_method(format(name, "_ops"), T)  // Monomorphize funcs
        } else if is_dynamic_preferred() {  // Core func: Queries --prefer-dynamic flag
            mono_struct.add_dynamic_field(name, T)  // Erase to Dynamic slot + vtable stub
        }
    }
    return mono_struct
}
#+END_SRC

This yields zero-cost statics by default, dynamic fallbacks for size/perf tradeoffs. Post-expansion type check validates.

But, yeah, since we're self hosted, we can use the structs for the self implementation in macros directly, a Body, an Expr, a StructDef, an EnumDef or whatever. They're just part of the core. I mean, You may want to use the Lexer struct for some tooling project, for example.

WARNING: some more invalid syntax made up by grok ahead.

** Integration with Dynamic

- *Fallback*: Unresolved generics (e.g., runtime ~T~) box to ~Dynamic::as<T>()~.
- *Translation*: Macros like ~@to_generic(DynamicCode)~ rewrite Python-style to static where possible.
- *Efficiency*: Use ~@mode lib_static~ for mono-only; ~@mode script_dynamic~ for REPL.

** Future Extensions

- *Variadics*: ~Vec<Ts: ..Type>~ for heterogeneous (ties to List).
- *Specialization*: ~@specialize Vec<Str>~ for custom impls.
- *Hygiene*: ~quote~ scopes vars; ~@fresh_id()~ for gensyms.

This design ensures Til's multi-everything promise: Write once, compile to your needs.
