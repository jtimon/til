
Translation patterns for converting Rust code to TIL, primarily for self-hosting the compiler/interpreter.

* Overview

TIL and Rust have different idioms, but the translation is mechanical. This guide documents the patterns discovered when analyzing lexer.rs, parser.rs, and init.rs against their TIL counterparts.

* Lexer Patterns (lexer.rs -> lexer.til)

** Match on Option<byte> -> switch on string

Rust:
#+begin_src rust
match source.as_bytes().get(pos).copied() {
    Some(b'0'..=b'9') => ...,
    Some(b'a'..=b'z') | Some(b'A'..=b'Z') => ...,
    _ => ...
}
#+end_src

TIL:
#+begin_src til
c := source.get_substr(pos, pos.add(1))
switch c {
    case "0".."9": ...
    case "a".."z": ...
    case "A".."Z": ...
    case: ...
}
#+end_src

** String slicing

Rust: ~&source[start..end]~
TIL: ~source.get_substr(start, end)~

** OR patterns in match

Rust uses ~|~ to combine patterns. TIL uses separate case arms:

Rust:
#+begin_src rust
Some(b'a'..=b'z') | Some(b'A'..=b'Z') | Some(b'_') => is_ident()
#+end_src

TIL:
#+begin_src til
case "a".."z": is_ident()
case "A".."Z": is_ident()
case "_": is_ident()
#+end_src

* Parser Patterns (parser.rs -> parser.til)

** OR patterns in match

Rust:
#+begin_src rust
match func_type {
    FunctionType::FTProc | FunctionType::FTProcExt => true,
    _ => false
}
#+end_src

TIL:
#+begin_src til
switch func_type {
    case FTProc: return true
    case FTProcExt: return true
    case: return false
}
#+end_src

** Vec literals

Rust: ~vec![a, b, c]~

TIL:
#+begin_src til
mut v := Vec.new(T)
v.push(a)
v.push(b)
v.push(c)
#+end_src

* Init Patterns (init.rs -> init.til)

** Not-equal comparisons (ne -> not(eq()))

TIL does not have a ~ne~ function. Use ~not(eq())~ instead:

Rust:
#+begin_src rust
if a != b { ... }
if x.len() != 0 { ... }
#+end_src

TIL:
#+begin_src til
if not(a.eq(b)) { ... }
if not(x.len().eq(0)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.ne()~ - it doesn't exist in TIL. Always use ~not(eq())~ or ~not(...eq(...))~.

** Enum comparisons (use switch, not eq)

Enums do NOT have an ~.eq()~ method. Use ~switch~ to compare enum values:

Rust:
#+begin_src rust
if value_type == ValueType::TInfer { ... }
if my_enum != SomeEnum::Variant { ... }
#+end_src

TIL:
#+begin_src til
// For equality check, use switch with a boolean flag
mut is_infer := false
switch value_type {
case ValueType.TInfer:
    is_infer = true
case:
    // Other variants
}
if is_infer { ... }

// For inequality, negate the flag
if not(is_infer) { ... }
#+end_src

For enum comparisons where you need to compare two enum values, use ~enum_to_str()~:
#+begin_src til
if enum_to_str(enum_a).eq(enum_to_str(enum_b)) { ... }
#+end_src

IMPORTANT: Do NOT use ~.eq()~ on enums - it doesn't exist. Use ~switch~ or ~enum_to_str()~.

** if let Some(x) = ...

Rust uses ~if let~ for Option destructuring. TIL checks for default/empty value or uses catch blocks:

Rust:
#+begin_src rust
if let Some(val) = map.get(key) {
    // use val
}
#+end_src

TIL (check default):
#+begin_src til
val := map.get(key)
if not(val.eq("")) {
    // use val
}
#+end_src

TIL (catch block):
#+begin_src til
catch {
    val := map.get_or_throw(key)
    // use val
}
#+end_src

** Reverse iteration

Rust: ~items.iter().rev()~

TIL:
#+begin_src til
mut i := items.len()
while i.gt(0) {
    i = i.sub(1)
    item := items.get(i)
    // use item
}
#+end_src

** Return type and error translation patterns

This is the canonical mapping from Rust return types to TIL throws:

| Rust                        | TIL                                  |
|-----------------------------+--------------------------------------|
| ~Result<T, String>~         | ~returns T throws Str~               |
| ~Option<T>~                 | ~returns T throws KeyNotFoundError~  |
| ~Result<Option<T>, String>~ | ~returns T throws Str, KeyNotFoundError~ |

Examples:

Rust:
#+begin_src rust
fn lookup_symbol(&self, name: &str) -> Option<&SymbolInfo> { ... }
fn parse_expr(&mut self) -> Result<Expr, String> { ... }
fn try_lookup(&self, name: &str) -> Result<Option<&Value>, String> { ... }
#+end_src

TIL:
#+begin_src til
lookup_symbol := func(self: ScopeStack, name: Str) returns SymbolInfo throws KeyNotFoundError { ... }
parse_expr := func(mut self: Parser) returns Expr throws Str { ... }
try_lookup := func(self: Context, name: Str) returns Value throws Str, KeyNotFoundError { ... }
#+end_src

IMPORTANT: Internal errors (like ~IndexOutOfBoundsError~ from ~Vec.get()~) should be caught
internally and NOT exposed in the throws signature. Only expose the semantic error types
that correspond to the Rust return type.

** Option handling patterns

Rust uses ~Option<T>~ with ~.ok_or_else()~, ~.is_some()~, ~.is_none()~.

TIL uses throw/catch instead:
- Function throws ~KeyNotFoundError~ instead of returning None
- Caller uses catch block to handle the not-found case
- ~map.contains_key(k)~ to check existence without fetching

** Method chaining with ?

Rust: ~let x = foo()?.bar()?.baz()?;~

TIL: Operations throw on failure, caller catches. No explicit propagation needed.

** Default switch case syntax

Rust uses ~_~ for catch-all. TIL uses empty ~case:~

Rust:
#+begin_src rust
match x {
    Foo::A => ...,
    _ => ...  // catch-all
}
#+end_src

TIL:
#+begin_src til
switch x {
    case Foo.A: ...
    case: ...  // catch-all (NOT "case _:")
}
#+end_src

** NULL pointer comparison

Rust: ~ptr.is_some()~ or ~ptr != NULL~

TIL: Use ~not(NULL.eq(ptr.data))~ - TIL doesn't have ~.ne()~ method:

#+begin_src til
if not(NULL.eq(func_ptr.data)) {
    // pointer is valid
}
#+end_src

** Vec/Map.get() out-parameter pattern

Rust returns the value directly. TIL uses out-parameter pattern:

Rust:
#+begin_src rust
let item = vec.get(i)?;
let val = map.get(&key)?;
#+end_src

TIL:
#+begin_src til
mut item := T()  // default init
vec.get(i, item)  // out-parameter, throws IndexOutOfBoundsError

mut val := V()
map.get(key, val)  // out-parameter, throws KeyNotFoundError
#+end_src

** Catch blocks placement

In TIL, catch blocks must come BEFORE the final return/throw:

#+begin_src til
proc my_proc() throws Str {
    do_something()  // may throw IndexOutOfBoundsError

    catch (err: IndexOutOfBoundsError) {
        throw format("Index error: ", err.msg)
    }

    return result  // return comes AFTER catch blocks
}
#+end_src

** Simplified error handling with throws Str

Complex functions often declare ~throws Str~ only, converting typed errors:

#+begin_src til
my_func := func() returns T throws Str {
    // ... code that may throw various errors ...

    catch (err: IndexOutOfBoundsError) {
        throw format("Index error: ", err.msg)
    }
    catch (err: KeyNotFoundError) {
        throw format("Key error: ", err.msg)
    }
    catch (err: AllocError) {
        throw "Allocation failed"
    }

    return result
}
#+end_src

* Summary

The translation is mechanical:
1. OR patterns (~|~) -> separate case arms
2. ~if let~ -> check default value or catch block
3. Iterator methods -> explicit loops
4. Return type translation:
   - ~Result<T, String>~ -> ~returns T throws Str~
   - ~Option<T>~ -> ~returns T throws KeyNotFoundError~
   - ~Result<Option<T>, String>~ -> ~returns T throws Str, KeyNotFoundError~
5. Internal errors (IndexOutOfBoundsError, AllocError, etc.) should be caught internally, not exposed
6. String slicing -> ~get_substr~
7. UFCS works similarly: ~a.method(b)~ in both languages
8. Default case: ~_~ -> empty ~case:~
9. NULL check: ~!= NULL~ -> ~not(NULL.eq(x))~
10. ~vec.get(i)~ -> out-parameter: ~vec.get(i, out_val)~
11. Catch blocks come before final return/throw
12. Not-equal: ~!=~ or ~.ne()~ -> ~not(eq())~ or ~not(x.eq(y))~ (TIL has no ~ne~ function)
13. Enum comparison: ~==~ on enums -> use ~switch~ with boolean flag, or ~enum_to_str()~ (enums have no ~eq~ method)
