* What is Precomp?

Precomp (pre-computation) is a phase that runs BEFORE the main interpreter/compiler.

** What Precomp Does (3 steps)

1. *Find comptime stuff* - Determine what can be evaluated at compile time
2. *Eval it to fold it* - Evaluate comptime expressions and replace them with results
3. *Leave runtime stuff* - Pass everything else to interpreter/builder unchanged

** Core Principle

Precomp is "interpreter for compile-time code". For anything that CAN be evaluated
at compile time, precomp must behave EXACTLY like interpreter. No special cases.

When precomp needs to evaluate, it calls eval_expr directly. Same function, same behavior.

** What Makes Something Comptime?

The TYPE does not matter. Only HOW the value is computed matters.

Comptime:
- Literals: 42, "hello", true
- Pure function calls with comptime args: add(1, 2), my_func(10, 20)
- Struct/enum constructors with comptime args: Bool(data=1), Color.Red
- Type definitions: struct, enum, func definitions

Runtime (not comptime):
- malloc (runtime state)
- Procs (they don't return values, can't fold them)
- Anything depending on runtime state

** Print in Pure Functions (mode pura/liba exception)

In ~mode pura~ and ~mode liba~, print/println inside pure functions is ALLOWED as a
debugging exception. The typer already enforces which procs can be called in funcs
based on mode - precomp does NOT need to second-guess this.

When precomp evaluates a func for constfolding, it just runs whatever is in the body,
including any procs that the typer allowed. The side effects (like printing) happen
at compile time, and the result is folded.

*IMPORTANT*: If a func is evaluated during precomp, it must be FOLDED (replaced with
the result). Otherwise the side effects run twice - once during precomp and once at
runtime. This is a bug, not expected behavior.

** Function Arguments and Comptime

Whether a function argument is comptime depends on the CALLER:

#+begin_src til
my_func := func(a: I64, b: I64) returns I64 {
    return add(a, b)
}

x := my_func(10, 20)    // comptime: a=10, b=20 are both comptime
y := my_func(x, 20)     // comptime: x was folded to 30, so a=30, b=20
z := my_func(rand(), 5) // runtime: rand() is not comptime, so a is not comptime
#+end_src

When evaluating ~my_func(10, 20)~:
- a is bound to 10 (comptime)
- b is bound to 20 (comptime)
- ~add(a, b)~ becomes ~add(10, 20)~ which is comptime
- Result: 30, the call is folded to literal 30

* Constant Folding

Constant folding replaces comptime expressions with their evaluated results.

** Example 1: Simple arithmetic

#+begin_src til
// Before precomp:
aaa := add(34, 35)

// After precomp:
aaa := 69
#+end_src

The declaration stays. The RHS expression ~add(34, 35)~ is evaluated at compile time,
result is 69, replaced with literal 69.

AST transformation:
- Before: ~Declaration(aaa, FCall(add, [34, 35]))~
- After:  ~Declaration(aaa, LLiteral(69))~

** Example 2: Nested function calls

#+begin_src til
// Before precomp:
bbb := mul(add(2, 3), add(4, 6))

// After precomp:
bbb := 50
#+end_src

Inner calls are folded first: ~add(2,3)~ -> 5, ~add(4,6)~ -> 10
Then outer call: ~mul(5, 10)~ -> 50

** Example 3: User-defined pure function

#+begin_src til
double := func(x: I64) returns I64 {
    return mul(x, 2)
}

// Before precomp:
ccc := double(21)

// After precomp:
ccc := 42
#+end_src

~double~ is pure, arg 21 is literal, so the call is evaluated at compile time.

** Example 4: Chained comptime

#+begin_src til
aaa := add(10, 20)    // folded to: aaa := 30
bbb := add(aaa, 5)    // folded to: bbb := 35 (aaa was already folded to 30)
#+end_src

** Example 5: Runtime - not folded

#+begin_src til
// This is NOT folded (rand is not pure):
ddd := add(rand(), 5)

// This is NOT folded (read_input is not pure):
eee := add(read_input(), 10)
#+end_src

The expressions stay as-is, evaluated at runtime by interpreter/codegen.

** Summary Table

| Expression | Comptime? | Folds to |
|------------|-----------|----------|
| 42 | yes | LLiteral(Number("42")) |
| "hello" | yes | LLiteral(Str("hello")) |
| add(1, 2) | yes (pure, literal args) | LLiteral(Number("3")) |
| my_func(10, 20) | yes (pure, literal args) | LLiteral of result |
| Bool(data=1) | yes | FCall AST via to_struct_literal |
| Color.Red | yes | FCall AST via to_enum_literal |
| rand() | no (side effect) | unchanged |
| my_proc() | no (proc, no return) | unchanged |

* Precomp vs Interpreter: Differences

** Legitimate Differences (by design)

| Aspect           | Precomp                              | Interpreter                    |
|------------------|--------------------------------------|--------------------------------|
| Entry point      | precomp_expr returns Expr            | eval_expr returns EvalResult   |
| AST transforms   | For-in desugaring, UFCS resolution   | None (works on final AST)      |
| Constant folding | Converts eval results back to AST    | Not needed                     |

That's it. Everything else is THE SAME:
- Scope handling: same scope_stack, same push/pop
- Function bodies: precomp evaluates them (via eval_expr) when called with comptime args
- Storage: precomp calls same insert_primitive, insert_struct_instance, etc.

* Precomp vs Codegen: Differences

** Legitimate Differences (by design)

| Aspect      | Precomp                        | Codegen                        |
|-------------|--------------------------------|--------------------------------|
| Input       | Original AST                   | Transformed AST (after precomp)|
| Output      | Transformed AST + arena values | C code                         |
| Evaluation  | Actually runs comptime code    | Generates code to run later    |
| Arena usage | Writes values                  | Reads values for constants     |

** What Codegen Expects from Precomp

1. AST correctly transformed (for-in desugared, UFCS resolved)
2. Global constants stored in EvalArena (so codegen can emit them)
3. Type definitions registered (structs, enums, funcs)
4. Templates created for struct types

* How Precomp Evaluates (eval_comptime flow)

When precomp needs to evaluate a comptime expression, it calls ~eval_comptime~:

1. ~precomp_fcall~ transforms the FCall AST (doesn't evaluate)
2. ~precomp_expr~ checks ~is_comptime_evaluable~
3. If true, calls ~eval_comptime~
4. ~eval_comptime~ calls ~eval_expr~ (interpreter's eval!)
5. ~eval_expr~ runs the code exactly like interpreter does
6. For ext funcs: ~eval_func_proc_call~ -> ~is_ext()~ -> ~eval_core_func_proc_call~ dispatch
7. Result is converted back to AST literal

This means nested function calls work correctly. When evaluating ~my_func(10, 20)~:
- ~eval_expr~ evaluates the function body
- If body contains ~add(a, b)~, that goes through ~eval_func_proc_call~
- ~add~ is ext, so it dispatches to ~eval_core_func_proc_call~ -> ~ext::func_add~
- Same path as interpreter - no special handling needed

** import() is a Special Case

~import()~ is an ~ext_proc~ (declared in core/comptime.til). Procs are NOT comptime-evaluable
because they don't return values (can't fold to a literal).

But ~import()~ MUST run during precomp to load code. So ~precomp_fcall~ has a special case:
when it sees ~import()~, it calls ~eval_expr~ directly to trigger the import.

This is the ONE special case in precomp_fcall. All other ext funcs go through the normal
~is_comptime_evaluable~ -> ~eval_comptime~ -> ~eval_expr~ flow.

* Key Functions

- precomp_expr: Main entry point, dispatches by node type
- precomp_declaration: Handles declarations, should call eval_declaration
- precomp_fcall: Handles function calls, transforms AST (evaluation happens via eval_comptime)
- eval_comptime: Evaluates comptime expression via eval_expr, converts result back to AST literal
- is_comptime_evaluable: Checks if an expression CAN be evaluated at compile time
