mode test

// boolean logic:

test(loc(), true, "true is true")
test(loc(), not(false), "not: not false is true")
test(loc(), not(not(true)), "not: not not true is true")
// and(true, 1111) // fails, 'and' cannot take number literals
// and(true, "asdfgdfafgd") // fails, 'and' cannot take string literals
test(loc(), and(true, true), "and(true, true) == true")
test(loc(), not(and(true, false)), "and(true, false) == false")
test(loc(), not(and(true, false)), "and(false, true) == false")
test(loc(), not(and(false, true)), "and(false, true) == false")
test(loc(), not(and(false, false)), "and(false, false) == false")

test(loc(), or(true, true), "or(true, true) == true")
test(loc(), or(true, false), "or(true, false) == true")
test(loc(), or(false, true), "or(false, true) == true")
test(loc(), not(or(false, false)), "or(false, false) == false")

// note that both 'and' and 'or' can take any number of bools as args, like in lisp
// test(loc(), or(false, true, true), "or(false, false, true) == true")
// test(loc(), not(and(false, true, true)), "and(false, false, true) == false")

test(loc(), or(true, false), "and: true or false is true")

test(loc(), xor(true, false), "and: true xor false is true")
test(loc(), not(xor(true, true)), "xor(true, true) == false")

// --------------- TODO remove redundancies

// Bool to int tests tests
test(loc(), I64.eq(Bool.to_i64(true), 1), "Bool.to_i64(true) = 1")
test(loc(), I64.eq(Bool.to_i64(false), 0), "Bool.to_i64(false) = 0")

